{"files":[{"patch":"@@ -245,1 +245,0 @@\n-JDKOPT_DETECT_INTREE_EC\n","filename":"make\/autoconf\/configure.ac","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -231,17 +231,0 @@\n-#\n-# Enable or disable the elliptic curve crypto implementation\n-#\n-AC_DEFUN_ONCE([JDKOPT_DETECT_INTREE_EC],\n-[\n-  AC_MSG_CHECKING([if elliptic curve crypto implementation is present])\n-\n-  if test -d \"${TOPDIR}\/src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\"; then\n-    ENABLE_INTREE_EC=true\n-    AC_MSG_RESULT([yes])\n-  else\n-    ENABLE_INTREE_EC=false\n-    AC_MSG_RESULT([no])\n-  fi\n-\n-  AC_SUBST(ENABLE_INTREE_EC)\n-])\n","filename":"make\/autoconf\/jdk-options.m4","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -498,10 +498,1 @@\n-jdk.disabled.namedCurves = secp112r1, secp112r2, secp128r1, secp128r2, \\\n-    secp160k1, secp160r1, secp160r2, secp192k1, secp192r1, secp224k1, \\\n-    secp224r1, secp256k1, sect113r1, sect113r2, sect131r1, sect131r2, \\\n-    sect163k1, sect163r1, sect163r2, sect193r1, sect193r2, sect233k1, \\\n-    sect233r1, sect239k1, sect283k1, sect283r1, sect409k1, sect409r1, \\\n-    sect571k1, sect571r1, X9.62 c2tnb191v1, X9.62 c2tnb191v2, \\\n-    X9.62 c2tnb191v3, X9.62 c2tnb239v1, X9.62 c2tnb239v2, X9.62 c2tnb239v3, \\\n-    X9.62 c2tnb359v1, X9.62 c2tnb431r1, X9.62 prime192v2, X9.62 prime192v3, \\\n-    X9.62 prime239v1, X9.62 prime239v2, X9.62 prime239v3, brainpoolP256r1, \\\n-    brainpoolP320r1, brainpoolP384r1, brainpoolP512r1\n+#jdk.disabled.namedCurves=\n@@ -645,2 +636,1 @@\n-    RSA keySize < 1024, DSA keySize < 1024, EC keySize < 224, \\\n-    include jdk.disabled.namedCurves\n+    RSA keySize < 1024, DSA keySize < 1024, EC keySize < 224\n@@ -710,1 +700,1 @@\n-      DSA keySize < 1024, include jdk.disabled.namedCurves\n+      DSA keySize < 1024\n@@ -745,2 +735,1 @@\n-    EC keySize < 224, 3DES_EDE_CBC, anon, NULL, \\\n-    include jdk.disabled.namedCurves\n+    EC keySize < 224, 3DES_EDE_CBC, anon, NULL\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":4,"deletions":15,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -172,15 +172,9 @@\n-        if (resultOpt.isPresent()) {\n-            result = resultOpt.get();\n-        } else {\n-            if (SunEC.isNativeDisabled()) {\n-                NamedCurve privNC = CurveDB.lookup(privateKey.getParams());\n-                NamedCurve pubNC = CurveDB.lookup(publicKey.getParams());\n-                throw new IllegalStateException(\n-                        new InvalidAlgorithmParameterException(\"Legacy SunEC \" +\n-                                \"curve disabled, one or both keys:  \" +\n-                                \"Private: \" + ((privNC != null) ?\n-                                privNC.toString() : \" unknown\") +\n-                                \", PublicKey:\" + ((pubNC != null) ?\n-                                pubNC.toString() : \" unknown\")));\n-            }\n-            result = deriveKeyNative(privateKey, publicKey);\n+        if (resultOpt.isEmpty()) {\n+            NamedCurve privNC = CurveDB.lookup(privateKey.getParams());\n+            NamedCurve pubNC = CurveDB.lookup(publicKey.getParams());\n+            throw new IllegalStateException(\n+                new InvalidAlgorithmParameterException(\n+                    \"Curve not supported:  Private: \" +\n+                        ((privNC != null) ? privNC.toString() : \" unknown\") +\n+                        \", PublicKey:\" +\n+                        ((pubNC != null) ? pubNC.toString() : \" unknown\")));\n@@ -188,0 +182,1 @@\n+        result = resultOpt.get();\n@@ -266,38 +261,0 @@\n-\n-    private static\n-    byte[] deriveKeyNative(ECPrivateKey privateKey, ECPublicKey publicKey) {\n-\n-        ECParameterSpec params = privateKey.getParams();\n-        byte[] s = privateKey.getS().toByteArray();\n-        byte[] encodedParams =                   \/\/ DER OID\n-            ECUtil.encodeECParameterSpec(null, params);\n-\n-        byte[] publicValue;\n-        if (publicKey instanceof ECPublicKeyImpl) {\n-            ECPublicKeyImpl ecPub = (ECPublicKeyImpl) publicKey;\n-            publicValue = ecPub.getEncodedPublicValue();\n-        } else { \/\/ instanceof ECPublicKey\n-            publicValue =\n-                ECUtil.encodePoint(publicKey.getW(), params.getCurve());\n-        }\n-\n-        try {\n-            return deriveKey(s, publicValue, encodedParams);\n-\n-        } catch (GeneralSecurityException e) {\n-            throw new ProviderException(\"Could not derive key\", e);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Generates a secret key using the public and private keys.\n-     *\n-     * @param s the private key's S value.\n-     * @param w the public key's W point (in uncompressed form).\n-     * @param encodedParams the curve's DER encoded object identifier.\n-     *\n-     * @return byte[] the secret key.\n-     *\/\n-    private static native byte[] deriveKey(byte[] s, byte[] w,\n-        byte[] encodedParams) throws GeneralSecurityException;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDHKeyAgreement.java","additions":10,"deletions":53,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -469,47 +469,0 @@\n-    private Optional<byte[]> signDigestAvailable(ECPrivateKey privateKey,\n-        byte[] digest, SecureRandom random) throws SignatureException {\n-\n-        ECParameterSpec params = privateKey.getParams();\n-\n-        \/\/ seed is the key size + 64 bits\n-        int seedBits = params.getOrder().bitLength() + 64;\n-        Optional<ECDSAOperations> opsOpt =\n-            ECDSAOperations.forParameters(params);\n-        if (opsOpt.isEmpty()) {\n-            return Optional.empty();\n-        } else {\n-            byte[] sig = signDigestImpl(opsOpt.get(), seedBits, digest,\n-                privateKey, random);\n-            return Optional.of(sig);\n-        }\n-    }\n-\n-    private byte[] signDigestNative(ECPrivateKey privateKey, byte[] digest,\n-        SecureRandom random) throws SignatureException {\n-\n-        byte[] s = privateKey.getS().toByteArray();\n-        ECParameterSpec params = privateKey.getParams();\n-\n-        \/\/ DER OID\n-        byte[] encodedParams = ECUtil.encodeECParameterSpec(null, params);\n-        int orderLength = params.getOrder().bitLength();\n-\n-        \/\/ seed is twice the order length (in bytes) plus 1\n-        byte[] seed = new byte[(((orderLength + 7) >> 3) + 1) * 2];\n-\n-        random.nextBytes(seed);\n-\n-        \/\/ random bits needed for timing countermeasures\n-        int timingArgument = random.nextInt();\n-        \/\/ values must be non-zero to enable countermeasures\n-        timingArgument |= 1;\n-\n-        try {\n-            return signDigest(digest, s, encodedParams, seed,\n-                timingArgument);\n-        } catch (GeneralSecurityException e) {\n-            throw new SignatureException(\"Could not sign data\", e);\n-        }\n-\n-    }\n-\n@@ -525,14 +478,9 @@\n-        Optional<byte[]> sigOpt = signDigestAvailable(privateKey, digest, random);\n-        byte[] sig;\n-        if (sigOpt.isPresent()) {\n-            sig = sigOpt.get();\n-        } else {\n-            if (SunEC.isNativeDisabled()) {\n-                NamedCurve nc = CurveDB.lookup(privateKey.getParams());\n-                throw new SignatureException(\n-                        new InvalidAlgorithmParameterException(\n-                                \"Legacy SunEC curve disabled:  \" +\n-                                        (nc != null ? nc.toString()\n-                                                : \"unknown\")));\n-            }\n-            sig = signDigestNative(privateKey, digest, random);\n+        ECParameterSpec params = privateKey.getParams();\n+\n+        \/\/ seed is the key size + 64 bits\n+        int seedBits = params.getOrder().bitLength() + 64;\n+        Optional<ECDSAOperations> opsOpt =\n+            ECDSAOperations.forParameters(params);\n+        if (opsOpt.isEmpty()) {\n+            throw new SignatureException(\"Curve not supported: \" +\n+                params.toString());\n@@ -540,0 +488,2 @@\n+        byte[] sig = signDigestImpl(opsOpt.get(), seedBits, digest, privateKey,\n+            random);\n@@ -560,38 +510,0 @@\n-        Optional<Boolean> verifyOpt\n-                = verifySignedDigestAvailable(publicKey, sig, digest);\n-\n-        if (verifyOpt.isPresent()) {\n-            return verifyOpt.get();\n-        } else {\n-            if (SunEC.isNativeDisabled()) {\n-                NamedCurve nc = CurveDB.lookup(publicKey.getParams());\n-                throw new SignatureException(\n-                        new InvalidAlgorithmParameterException(\n-                                \"Legacy SunEC curve disabled:  \" +\n-                                        (nc != null ? nc.toString()\n-                                                : \"unknown\")));\n-            }\n-\n-            byte[] w;\n-            ECParameterSpec params = publicKey.getParams();\n-            \/\/ DER OID\n-            byte[] encodedParams = ECUtil.encodeECParameterSpec(null, params);\n-\n-            if (publicKey instanceof ECPublicKeyImpl) {\n-                w = ((ECPublicKeyImpl) publicKey).getEncodedPublicValue();\n-            } else { \/\/ instanceof ECPublicKey\n-                w = ECUtil.encodePoint(publicKey.getW(), params.getCurve());\n-            }\n-\n-            try {\n-                return verifySignedDigest(sig, digest, w, encodedParams);\n-            } catch (GeneralSecurityException e) {\n-                throw new SignatureException(\"Could not verify signature\", e);\n-            }\n-        }\n-    }\n-\n-    private Optional<Boolean> verifySignedDigestAvailable(\n-            ECPublicKey publicKey, byte[] sig, byte[] digestValue) {\n-\n-        ECParameterSpec params = publicKey.getParams();\n@@ -600,1 +512,1 @@\n-                ECDSAOperations.forParameters(params);\n+            ECDSAOperations.forParameters(publicKey.getParams());\n@@ -602,5 +514,2 @@\n-            return Optional.empty();\n-        } else {\n-            boolean result = verifySignedDigestImpl(opsOpt.get(), digestValue,\n-                    publicKey, sig);\n-            return Optional.of(result);\n+            throw new SignatureException(\"Curve not supported: \" +\n+                publicKey.getParams().toString());\n@@ -608,5 +517,1 @@\n-    }\n-\n-    private boolean verifySignedDigestImpl(ECDSAOperations ops,\n-            byte[] digest, ECPublicKey pub, byte[] sig) {\n-        return ops.verifySignedDigest(digest, sig, pub.getW());\n+        return opsOpt.get().verifySignedDigest(digest, sig, publicKey.getW());\n@@ -660,36 +565,0 @@\n-\n-    \/**\n-     * Signs the digest using the private key.\n-     *\n-     * @param digest the digest to be signed.\n-     * @param s the private key's S value.\n-     * @param encodedParams the curve's DER encoded object identifier.\n-     * @param seed the random seed.\n-     * @param timing When non-zero, the implmentation will use timing\n-     *     countermeasures to hide secrets from timing channels. The EC\n-     *     implementation will disable the countermeasures when this value is\n-     *     zero, because the underlying EC functions are shared by several\n-     *     crypto operations, some of which do not use the countermeasures.\n-     *     The high-order 31 bits must be uniformly random. The entropy from\n-     *     these bits is used by the countermeasures.\n-     *\n-     * @return byte[] the signature.\n-     *\/\n-    private static native byte[] signDigest(byte[] digest, byte[] s,\n-                                            byte[] encodedParams, byte[] seed, int timing)\n-        throws GeneralSecurityException;\n-\n-    \/**\n-     * Verifies the signed digest using the public key.\n-     *\n-     * @param signature the signature to be verified. It is encoded\n-     *        as a concatenation of the key's R and S values.\n-     * @param digest the digest to be used.\n-     * @param w the public key's W point (in uncompressed form).\n-     * @param encodedParams the curve's DER encoded object identifier.\n-     *\n-     * @return boolean true if the signature is successfully verified.\n-     *\/\n-    private static native boolean verifySignedDigest(byte[] signature,\n-                                                     byte[] digest, byte[] w, byte[] encodedParams)\n-        throws GeneralSecurityException;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECDSASignature.java","additions":15,"deletions":146,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                    \"Unsupported curve: \" + params);\n+                    \"Curve not supported: \" + params);\n@@ -129,1 +129,1 @@\n-                \"Unsupported curve: \" + ecSpec.toString());\n+                \"Curve not supported: \" + ecSpec.toString());\n@@ -133,17 +133,1 @@\n-        if (ECOperations.forParameters(ecSpec).isPresent()) {\n-            return;\n-        }\n-\n-        \/\/ Check if the native library supported this curve, if available\n-        if (SunEC.isNativeDisabled()) {\n-            throw new InvalidAlgorithmParameterException(\n-                \"Unsupported curve: \" + ecSpec.toString());\n-        }\n-\n-        byte[] encodedParams;\n-        try {\n-            encodedParams = ecParams.getEncoded();\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-        if (!isCurveSupported(encodedParams)) {\n+        if (ECOperations.forParameters(ecSpec).isEmpty()) {\n@@ -151,1 +135,1 @@\n-                \"Unsupported curve: \" + ecParams.toString());\n+                \"Curve not supported: \" + ecSpec.toString());\n@@ -171,9 +155,2 @@\n-        if (SunEC.isNativeDisabled()) {\n-            throw new ProviderException(\"Legacy SunEC curve disabled:  \" +\n-                    params.toString());\n-        }\n-        try {\n-            return generateKeyPairNative(random);\n-        } catch (Exception ex) {\n-            throw new ProviderException(ex);\n-        }\n+        throw new ProviderException(\"Curve not supported:  \" +\n+            params.toString());\n@@ -234,26 +211,0 @@\n-    private KeyPair generateKeyPairNative(SecureRandom random)\n-        throws Exception {\n-\n-        ECParameterSpec ecParams = (ECParameterSpec) params;\n-        byte[] encodedParams = ECUtil.encodeECParameterSpec(null, ecParams);\n-\n-        \/\/ seed is twice the key size (in bytes) plus 1\n-        byte[] seed = new byte[(((keySize + 7) >> 3) + 1) * 2];\n-        random.nextBytes(seed);\n-        Object[] keyBytes = generateECKeyPair(keySize, encodedParams, seed);\n-\n-        \/\/ The 'params' object supplied above is equivalent to the native\n-        \/\/ one so there is no need to fetch it.\n-        \/\/ keyBytes[0] is the encoding of the native private key\n-        BigInteger s = new BigInteger(1, (byte[]) keyBytes[0]);\n-\n-        PrivateKey privateKey = new ECPrivateKeyImpl(s, ecParams);\n-\n-        \/\/ keyBytes[1] is the encoding of the native public key\n-        byte[] pubKey = (byte[]) keyBytes[1];\n-        ECPoint w = ECUtil.decodePoint(pubKey, ecParams.getCurve());\n-        PublicKey publicKey = new ECPublicKeyImpl(w, ecParams);\n-\n-        return new KeyPair(publicKey, privateKey);\n-    }\n-\n@@ -271,20 +222,0 @@\n-\n-    \/**\n-     * Checks whether the curve in the encoded parameters is supported by the\n-     * native implementation. Some curve operations will be performed by the\n-     * Java implementation, but not all of them. So native support is still\n-     * required for all curves.\n-     *\n-     * @param encodedParams encoded parameters in the same form accepted\n-     *    by generateECKeyPair\n-     * @return true if and only if generateECKeyPair will succeed for\n-     *    the supplied parameters\n-     *\/\n-    private static native boolean isCurveSupported(byte[] encodedParams);\n-\n-    \/*\n-     * Generates the keypair and returns a 2-element array of encoding bytes.\n-     * The first one is for the private key, the second for the public key.\n-     *\/\n-    private static native Object[] generateECKeyPair(int keySize,\n-        byte[] encodedParams, byte[] seed) throws GeneralSecurityException;\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":6,"deletions":75,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -51,13 +51,0 @@\n- * Supports EC keypair and parameter generation, ECDSA signing and\n- * ECDH key agreement.\n- *\n- * IMPLEMENTATION NOTE:\n- * The Java classes in this provider access a native ECC implementation\n- * via JNI to a C++ wrapper class which in turn calls C functions.\n- * The Java classes are packaged into the jdk.crypto.sunec module and the\n- * C++ and C functions are packaged into libsunec.so or sunec.dll in the\n- * JRE native libraries directory.  If the native library is not present\n- * then this provider is registered with support for fewer ECC algorithms\n- * (KeyPairGenerator, Signature and KeyAgreement are omitted).\n- *\n- * @since   1.7\n@@ -69,30 +56,0 @@\n-    \/\/ This flag is true if the native library is disabled or not loaded.\n-    private static boolean disableNative = true;\n-\n-    static {\n-        String s = sun.security.action.GetPropertyAction.privilegedGetProperty(\n-                \"jdk.sunec.disableNative\");\n-        if (s != null && s.equalsIgnoreCase(\"false\")) {\n-            disableNative = false;\n-        }\n-\n-        \/\/ If native is enabled, verify the library is available.\n-        if (!disableNative) {\n-            try {\n-                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                    public Void run() {\n-                        System.loadLibrary(\"sunec\"); \/\/ check for native library\n-                        return null;\n-                    }\n-                });\n-            } catch (UnsatisfiedLinkError e) {\n-                disableNative = true;\n-            }\n-        }\n-    }\n-\n-    \/\/ Check if native library support is disabled.\n-    static boolean isNativeDisabled() {\n-        return SunEC.disableNative;\n-    }\n-\n@@ -262,8 +219,1 @@\n-        if (SunEC.isNativeDisabled()) {\n-            supportedCurves = Collections.unmodifiableList(List.of(\n-                    CurveDB.lookup(\"secp256r1\"),\n-                    CurveDB.lookup(\"secp384r1\"),\n-                    CurveDB.lookup(\"secp521r1\")));\n-        } else {\n-            supportedCurves = CurveDB.getSupportedCurves();\n-        }\n+        supportedCurves = CurveDB.getSupportedCurves();\n@@ -383,1 +333,0 @@\n-        \/* XDH does not require native implementation *\/\n@@ -417,1 +366,0 @@\n-        \/* EdDSA does not require native implementation *\/\n","filename":"src\/jdk.crypto.ec\/share\/classes\/sun\/security\/ec\/SunEC.java","additions":1,"deletions":53,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -1,599 +0,0 @@\n-## Mozilla Elliptic Curve Cryptography (ECC)\n-\n-### Mozilla ECC Notice\n-\n-You are receiving a \n-[copy](http:\/\/hg.openjdk.java.net\/jdk\/jdk\/file\/tip\/src\/jdk.crypto.ec\/share\/native\/libsunec\/impl)\n-of the Elliptic Curve Cryptography library in source form or object code.\n-\n-```\n-The terms of the Oracle license do NOT apply to the Elliptic Curve Cryptography\n-library; it is licensed under the following license, separately from the Oracle \n-programs you received.  If you do not wish to install the Elliptic Curve \n-Cryptography library, you may delete the Elliptic Curve Cryptography library by \n-removing:\n-\n-      Linux:    $(JAVA_HOME)\/lib\/libsunec.so\n-      macOS:    $(JAVA_HOME)\/lib\/libsunec.dylib\n-      Windows:  $(JAVA_HOME)\\bin\\sunec.dll\n-\n-```\n-\n-#### Mozilla ECC Library Removal Impact\n-```\n-The Java Cryptographic Service SunEC Provider uses the Mozilla ECC library.  If \n-this native library is removed, the following algorithms will no longer be \n-available from the SunEC provider using the JCA\/JCE APIs:\n-\n-      KeyPairGenerator:  EC\n-      KeyAgreement:      ECDH\n-      Signature:         names that include *withECDSA* \n-\n-```\n-\n-#### Written Offer for Source Code\n-\n-```\n-For third party technology that you receive from Oracle in binary form which \n-is licensed under an open source license that gives you the right to receive \n-the source code for that binary, you can also receive a copy of the source \n-code on physical media by submitting a written request to:\n-\n-        Oracle America, Inc. \n-        Attn: Associate General Counsel, \n-        Development and Engineering Legal \n-        500 Oracle Parkway, 10th Floor \n-        Redwood Shores, CA 94065\n-\n-Your request should include:\n-```\n-\n-* The name of the component or binary file(s) for which you are requesting \n-  the source code\n-* The name and version number of the Oracle product containing the binary\n-* The date you received the Oracle product\n-* Your name\n-* Your company name (if applicable)\n-* Your return mailing address and email and \n-* A telephone number in the event we need to reach you.\n-\n-```\n-We may charge you a fee to cover the cost of physical media and processing.\n-Your request must be sent (i) within three (3) years of the date you received\n-the Oracle product that included the component or binary file(s) that are the\n-subject of your request, or (ii) in the case of code licensed under the GPL\n-v3, for as long as Oracle offers spare parts or customer support for that\n-product model.\n-\n-```\n-\n-### Mozilla ECC License\n-```\n-Software distributed under the License is distributed on an \"AS IS\" basis,\n-WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n-for the specific language governing rights and limitations under the\n-License.\n-\n-The Original Code is the Elliptic Curve Cryptography library.\n-\n-The Initial Developer of the Original Code is\n-Sun Microsystems, Inc.\n-Portions created by the Initial Developer are Copyright (C) 2003\n-the Initial Developer. All Rights Reserved.\n-\n-Contributor(s):\n-Dr Vipul Gupta  and\n-Douglas Stebila, Sun Microsystems Laboratories\n-\n-The Elliptic Curve Cryptography Library is subject to GNU Lesser Public License \n-Version 2.1.  \n-```\n-\n-#### LGPL 2.1\n-```\n-                  GNU LESSER GENERAL PUBLIC LICENSE\n-                       Version 2.1, February 1999\n-\n- Copyright (C) 1991, 1999 Free Software Foundation, Inc.\n- 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n- Everyone is permitted to copy and distribute verbatim copies\n- of this license document, but changing it is not allowed.\n-\n-[This is the first released version of the Lesser GPL.  It also counts\n- as the successor of the GNU Library Public License, version 2, hence\n- the version number 2.1.]\n-\n-                            Preamble\n-\n-  The licenses for most software are designed to take away your\n-freedom to share and change it.  By contrast, the GNU General Public\n-Licenses are intended to guarantee your freedom to share and change\n-free software--to make sure the software is free for all its users.\n-\n-  This license, the Lesser General Public License, applies to some\n-specially designated software packages--typically libraries--of the\n-Free Software Foundation and other authors who decide to use it.  You\n-can use it too, but we suggest you first think carefully about whether\n-this license or the ordinary General Public License is the better\n-strategy to use in any particular case, based on the explanations below.\n-\n-  When we speak of free software, we are referring to freedom of use,\n-not price.  Our General Public Licenses are designed to make sure that\n-you have the freedom to distribute copies of free software (and charge\n-for this service if you wish); that you receive source code or can get\n-it if you want it; that you can change the software and use pieces of\n-it in new free programs; and that you are informed that you can do\n-these things.\n-\n-  To protect your rights, we need to make restrictions that forbid\n-distributors to deny you these rights or to ask you to surrender these\n-rights.  These restrictions translate to certain responsibilities for\n-you if you distribute copies of the library or if you modify it.\n-\n-  For example, if you distribute copies of the library, whether gratis\n-or for a fee, you must give the recipients all the rights that we gave\n-you.  You must make sure that they, too, receive or can get the source\n-code.  If you link other code with the library, you must provide\n-complete object files to the recipients, so that they can relink them\n-with the library after making changes to the library and recompiling\n-it.  And you must show them these terms so they know their rights.\n-\n-  We protect your rights with a two-step method: (1) we copyright the\n-library, and (2) we offer you this license, which gives you legal\n-permission to copy, distribute and\/or modify the library.\n-\n-  To protect each distributor, we want to make it very clear that\n-there is no warranty for the free library.  Also, if the library is\n-modified by someone else and passed on, the recipients should know\n-that what they have is not the original version, so that the original\n-author's reputation will not be affected by problems that might be\n-introduced by others.\n-\n-  Finally, software patents pose a constant threat to the existence of\n-any free program.  We wish to make sure that a company cannot\n-effectively restrict the users of a free program by obtaining a\n-restrictive license from a patent holder.  Therefore, we insist that\n-any patent license obtained for a version of the library must be\n-consistent with the full freedom of use specified in this license.\n-\n-  Most GNU software, including some libraries, is covered by the\n-ordinary GNU General Public License.  This license, the GNU Lesser\n-General Public License, applies to certain designated libraries, and\n-is quite different from the ordinary General Public License.  We use\n-this license for certain libraries in order to permit linking those\n-libraries into non-free programs.\n-\n-  When a program is linked with a library, whether statically or using\n-a shared library, the combination of the two is legally speaking a\n-combined work, a derivative of the original library.  The ordinary\n-General Public License therefore permits such linking only if the\n-entire combination fits its criteria of freedom.  The Lesser General\n-Public License permits more lax criteria for linking other code with\n-the library.\n-\n-  We call this license the \"Lesser\" General Public License because it\n-does Less to protect the user's freedom than the ordinary General\n-Public License.  It also provides other free software developers Less\n-of an advantage over competing non-free programs.  These disadvantages\n-are the reason we use the ordinary General Public License for many\n-libraries.  However, the Lesser license provides advantages in certain\n-special circumstances.\n-\n-  For example, on rare occasions, there may be a special need to\n-encourage the widest possible use of a certain library, so that it becomes\n-a de-facto standard.  To achieve this, non-free programs must be\n-allowed to use the library.  A more frequent case is that a free\n-library does the same job as widely used non-free libraries.  In this\n-case, there is little to gain by limiting the free library to free\n-software only, so we use the Lesser General Public License.\n-\n-  In other cases, permission to use a particular library in non-free\n-programs enables a greater number of people to use a large body of\n-free software.  For example, permission to use the GNU C Library in\n-non-free programs enables many more people to use the whole GNU\n-operating system, as well as its variant, the GNU\/Linux operating\n-system.\n-\n-  Although the Lesser General Public License is Less protective of the\n-users' freedom, it does ensure that the user of a program that is\n-linked with the Library has the freedom and the wherewithal to run\n-that program using a modified version of the Library.\n-\n-  The precise terms and conditions for copying, distribution and\n-modification follow.  Pay close attention to the difference between a\n-\"work based on the library\" and a \"work that uses the library\".  The\n-former contains code derived from the library, whereas the latter must\n-be combined with the library in order to run.\n-\n-                  GNU LESSER GENERAL PUBLIC LICENSE\n-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION\n-\n-  0. This License Agreement applies to any software library or other\n-program which contains a notice placed by the copyright holder or\n-other authorized party saying it may be distributed under the terms of\n-this Lesser General Public License (also called \"this License\").\n-Each licensee is addressed as \"you\".\n-\n-  A \"library\" means a collection of software functions and\/or data\n-prepared so as to be conveniently linked with application programs\n-(which use some of those functions and data) to form executables.\n-\n-  The \"Library\", below, refers to any such software library or work\n-which has been distributed under these terms.  A \"work based on the\n-Library\" means either the Library or any derivative work under\n-copyright law: that is to say, a work containing the Library or a\n-portion of it, either verbatim or with modifications and\/or translated\n-straightforwardly into another language.  (Hereinafter, translation is\n-included without limitation in the term \"modification\".)\n-\n-  \"Source code\" for a work means the preferred form of the work for\n-making modifications to it.  For a library, complete source code means\n-all the source code for all modules it contains, plus any associated\n-interface definition files, plus the scripts used to control compilation\n-and installation of the library.\n-\n-  Activities other than copying, distribution and modification are not\n-covered by this License; they are outside its scope.  The act of\n-running a program using the Library is not restricted, and output from\n-such a program is covered only if its contents constitute a work based\n-on the Library (independent of the use of the Library in a tool for\n-writing it).  Whether that is true depends on what the Library does\n-and what the program that uses the Library does.\n-\n-  1. You may copy and distribute verbatim copies of the Library's\n-complete source code as you receive it, in any medium, provided that\n-you conspicuously and appropriately publish on each copy an\n-appropriate copyright notice and disclaimer of warranty; keep intact\n-all the notices that refer to this License and to the absence of any\n-warranty; and distribute a copy of this License along with the\n-Library.\n-\n-  You may charge a fee for the physical act of transferring a copy,\n-and you may at your option offer warranty protection in exchange for a\n-fee.\n-\n-  2. You may modify your copy or copies of the Library or any portion\n-of it, thus forming a work based on the Library, and copy and\n-distribute such modifications or work under the terms of Section 1\n-above, provided that you also meet all of these conditions:\n-\n-    a) The modified work must itself be a software library.\n-\n-    b) You must cause the files modified to carry prominent notices\n-    stating that you changed the files and the date of any change.\n-\n-    c) You must cause the whole of the work to be licensed at no\n-    charge to all third parties under the terms of this License.\n-\n-    d) If a facility in the modified Library refers to a function or a\n-    table of data to be supplied by an application program that uses\n-    the facility, other than as an argument passed when the facility\n-    is invoked, then you must make a good faith effort to ensure that,\n-    in the event an application does not supply such function or\n-    table, the facility still operates, and performs whatever part of\n-    its purpose remains meaningful.\n-\n-    (For example, a function in a library to compute square roots has\n-    a purpose that is entirely well-defined independent of the\n-    application.  Therefore, Subsection 2d requires that any\n-    application-supplied function or table used by this function must\n-    be optional: if the application does not supply it, the square\n-    root function must still compute square roots.)\n-\n-These requirements apply to the modified work as a whole.  If\n-identifiable sections of that work are not derived from the Library,\n-and can be reasonably considered independent and separate works in\n-themselves, then this License, and its terms, do not apply to those\n-sections when you distribute them as separate works.  But when you\n-distribute the same sections as part of a whole which is a work based\n-on the Library, the distribution of the whole must be on the terms of\n-this License, whose permissions for other licensees extend to the\n-entire whole, and thus to each and every part regardless of who wrote\n-it.\n-\n-Thus, it is not the intent of this section to claim rights or contest\n-your rights to work written entirely by you; rather, the intent is to\n-exercise the right to control the distribution of derivative or\n-collective works based on the Library.\n-\n-In addition, mere aggregation of another work not based on the Library\n-with the Library (or with a work based on the Library) on a volume of\n-a storage or distribution medium does not bring the other work under\n-the scope of this License.\n-\n-  3. You may opt to apply the terms of the ordinary GNU General Public\n-License instead of this License to a given copy of the Library.  To do\n-this, you must alter all the notices that refer to this License, so\n-that they refer to the ordinary GNU General Public License, version 2,\n-instead of to this License.  (If a newer version than version 2 of the\n-ordinary GNU General Public License has appeared, then you can specify\n-that version instead if you wish.)  Do not make any other change in\n-these notices.\n-\n-  Once this change is made in a given copy, it is irreversible for\n-that copy, so the ordinary GNU General Public License applies to all\n-subsequent copies and derivative works made from that copy.\n-\n-  This option is useful when you wish to copy part of the code of\n-the Library into a program that is not a library.\n-\n-  4. You may copy and distribute the Library (or a portion or\n-derivative of it, under Section 2) in object code or executable form\n-under the terms of Sections 1 and 2 above provided that you accompany\n-it with the complete corresponding machine-readable source code, which\n-must be distributed under the terms of Sections 1 and 2 above on a\n-medium customarily used for software interchange.\n-\n-  If distribution of object code is made by offering access to copy\n-from a designated place, then offering equivalent access to copy the\n-source code from the same place satisfies the requirement to\n-distribute the source code, even though third parties are not\n-compelled to copy the source along with the object code.\n-\n-  5. A program that contains no derivative of any portion of the\n-Library, but is designed to work with the Library by being compiled or\n-linked with it, is called a \"work that uses the Library\".  Such a\n-work, in isolation, is not a derivative work of the Library, and\n-therefore falls outside the scope of this License.\n-\n-  However, linking a \"work that uses the Library\" with the Library\n-creates an executable that is a derivative of the Library (because it\n-contains portions of the Library), rather than a \"work that uses the\n-library\".  The executable is therefore covered by this License.\n-Section 6 states terms for distribution of such executables.\n-\n-  When a \"work that uses the Library\" uses material from a header file\n-that is part of the Library, the object code for the work may be a\n-derivative work of the Library even though the source code is not.\n-Whether this is true is especially significant if the work can be\n-linked without the Library, or if the work is itself a library.  The\n-threshold for this to be true is not precisely defined by law.\n-\n-  If such an object file uses only numerical parameters, data\n-structure layouts and accessors, and small macros and small inline\n-functions (ten lines or less in length), then the use of the object\n-file is unrestricted, regardless of whether it is legally a derivative\n-work.  (Executables containing this object code plus portions of the\n-Library will still fall under Section 6.)\n-\n-  Otherwise, if the work is a derivative of the Library, you may\n-distribute the object code for the work under the terms of Section 6.\n-Any executables containing that work also fall under Section 6,\n-whether or not they are linked directly with the Library itself.\n-\n-  6. As an exception to the Sections above, you may also combine or\n-link a \"work that uses the Library\" with the Library to produce a\n-work containing portions of the Library, and distribute that work\n-under terms of your choice, provided that the terms permit\n-modification of the work for the customer's own use and reverse\n-engineering for debugging such modifications.\n-\n-  You must give prominent notice with each copy of the work that the\n-Library is used in it and that the Library and its use are covered by\n-this License.  You must supply a copy of this License.  If the work\n-during execution displays copyright notices, you must include the\n-copyright notice for the Library among them, as well as a reference\n-directing the user to the copy of this License.  Also, you must do one\n-of these things:\n-\n-    a) Accompany the work with the complete corresponding\n-    machine-readable source code for the Library including whatever\n-    changes were used in the work (which must be distributed under\n-    Sections 1 and 2 above); and, if the work is an executable linked\n-    with the Library, with the complete machine-readable \"work that\n-    uses the Library\", as object code and\/or source code, so that the\n-    user can modify the Library and then relink to produce a modified\n-    executable containing the modified Library.  (It is understood\n-    that the user who changes the contents of definitions files in the\n-    Library will not necessarily be able to recompile the application\n-    to use the modified definitions.)\n-\n-    b) Use a suitable shared library mechanism for linking with the\n-    Library.  A suitable mechanism is one that (1) uses at run time a\n-    copy of the library already present on the user's computer system,\n-    rather than copying library functions into the executable, and (2)\n-    will operate properly with a modified version of the library, if\n-    the user installs one, as long as the modified version is\n-    interface-compatible with the version that the work was made with.\n-\n-    c) Accompany the work with a written offer, valid for at\n-    least three years, to give the same user the materials\n-    specified in Subsection 6a, above, for a charge no more\n-    than the cost of performing this distribution.\n-\n-    d) If distribution of the work is made by offering access to copy\n-    from a designated place, offer equivalent access to copy the above\n-    specified materials from the same place.\n-\n-    e) Verify that the user has already received a copy of these\n-    materials or that you have already sent this user a copy.\n-\n-  For an executable, the required form of the \"work that uses the\n-Library\" must include any data and utility programs needed for\n-reproducing the executable from it.  However, as a special exception,\n-the materials to be distributed need not include anything that is\n-normally distributed (in either source or binary form) with the major\n-components (compiler, kernel, and so on) of the operating system on\n-which the executable runs, unless that component itself accompanies\n-the executable.\n-\n-  It may happen that this requirement contradicts the license\n-restrictions of other proprietary libraries that do not normally\n-accompany the operating system.  Such a contradiction means you cannot\n-use both them and the Library together in an executable that you\n-distribute.\n-\n-  7. You may place library facilities that are a work based on the\n-Library side-by-side in a single library together with other library\n-facilities not covered by this License, and distribute such a combined\n-library, provided that the separate distribution of the work based on\n-the Library and of the other library facilities is otherwise\n-permitted, and provided that you do these two things:\n-\n-    a) Accompany the combined library with a copy of the same work\n-    based on the Library, uncombined with any other library\n-    facilities.  This must be distributed under the terms of the\n-    Sections above.\n-\n-    b) Give prominent notice with the combined library of the fact\n-    that part of it is a work based on the Library, and explaining\n-    where to find the accompanying uncombined form of the same work.\n-\n-  8. You may not copy, modify, sublicense, link with, or distribute\n-the Library except as expressly provided under this License.  Any\n-attempt otherwise to copy, modify, sublicense, link with, or\n-distribute the Library is void, and will automatically terminate your\n-rights under this License.  However, parties who have received copies,\n-or rights, from you under this License will not have their licenses\n-terminated so long as such parties remain in full compliance.\n-\n-  9. You are not required to accept this License, since you have not\n-signed it.  However, nothing else grants you permission to modify or\n-distribute the Library or its derivative works.  These actions are\n-prohibited by law if you do not accept this License.  Therefore, by\n-modifying or distributing the Library (or any work based on the\n-Library), you indicate your acceptance of this License to do so, and\n-all its terms and conditions for copying, distributing or modifying\n-the Library or works based on it.\n-\n-  10. Each time you redistribute the Library (or any work based on the\n-Library), the recipient automatically receives a license from the\n-original licensor to copy, distribute, link with or modify the Library\n-subject to these terms and conditions.  You may not impose any further\n-restrictions on the recipients' exercise of the rights granted herein.\n-You are not responsible for enforcing compliance by third parties with\n-this License.\n-\n-  11. If, as a consequence of a court judgment or allegation of patent\n-infringement or for any other reason (not limited to patent issues),\n-conditions are imposed on you (whether by court order, agreement or\n-otherwise) that contradict the conditions of this License, they do not\n-excuse you from the conditions of this License.  If you cannot\n-distribute so as to satisfy simultaneously your obligations under this\n-License and any other pertinent obligations, then as a consequence you\n-may not distribute the Library at all.  For example, if a patent\n-license would not permit royalty-free redistribution of the Library by\n-all those who receive copies directly or indirectly through you, then\n-the only way you could satisfy both it and this License would be to\n-refrain entirely from distribution of the Library.\n-\n-If any portion of this section is held invalid or unenforceable under any\n-particular circumstance, the balance of the section is intended to apply,\n-and the section as a whole is intended to apply in other circumstances.\n-\n-It is not the purpose of this section to induce you to infringe any\n-patents or other property right claims or to contest validity of any\n-such claims; this section has the sole purpose of protecting the\n-integrity of the free software distribution system which is\n-implemented by public license practices.  Many people have made\n-generous contributions to the wide range of software distributed\n-through that system in reliance on consistent application of that\n-system; it is up to the author\/donor to decide if he or she is willing\n-to distribute software through any other system and a licensee cannot\n-impose that choice.\n-\n-This section is intended to make thoroughly clear what is believed to\n-be a consequence of the rest of this License.\n-\n-  12. If the distribution and\/or use of the Library is restricted in\n-certain countries either by patents or by copyrighted interfaces, the\n-original copyright holder who places the Library under this License may add\n-an explicit geographical distribution limitation excluding those countries,\n-so that distribution is permitted only in or among countries not thus\n-excluded.  In such case, this License incorporates the limitation as if\n-written in the body of this License.\n-\n-  13. The Free Software Foundation may publish revised and\/or new\n-versions of the Lesser General Public License from time to time.\n-Such new versions will be similar in spirit to the present version,\n-but may differ in detail to address new problems or concerns.\n-\n-Each version is given a distinguishing version number.  If the Library\n-specifies a version number of this License which applies to it and\n-\"any later version\", you have the option of following the terms and\n-conditions either of that version or of any later version published by\n-the Free Software Foundation.  If the Library does not specify a\n-license version number, you may choose any version ever published by\n-the Free Software Foundation.\n-\n-  14. If you wish to incorporate parts of the Library into other free\n-programs whose distribution conditions are incompatible with these,\n-write to the author to ask for permission.  For software which is\n-copyrighted by the Free Software Foundation, write to the Free\n-Software Foundation; we sometimes make exceptions for this.  Our\n-decision will be guided by the two goals of preserving the free status\n-of all derivatives of our free software and of promoting the sharing\n-and reuse of software generally.\n-\n-                            NO WARRANTY\n-\n-  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO\n-WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.\n-EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND\/OR\n-OTHER PARTIES PROVIDE THE LIBRARY \"AS IS\" WITHOUT WARRANTY OF ANY\n-KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE\n-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n-PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE\n-LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME\n-THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n-\n-  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN\n-WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY\n-AND\/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU\n-FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR\n-CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE\n-LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING\n-RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A\n-FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF\n-SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n-DAMAGES.\n-\n-                     END OF TERMS AND CONDITIONS\n-\n-           How to Apply These Terms to Your New Libraries\n-\n-  If you develop a new library, and you want it to be of the greatest\n-possible use to the public, we recommend making it free software that\n-everyone can redistribute and change.  You can do so by permitting\n-redistribution under these terms (or, alternatively, under the terms of the\n-ordinary General Public License).\n-\n-  To apply these terms, attach the following notices to the library.  It is\n-safest to attach them to the start of each source file to most effectively\n-convey the exclusion of warranty; and each file should have at least the\n-\"copyright\" line and a pointer to where the full notice is found.\n-\n-    <one line to give the library's name and a brief idea of what it does.>\n-    Copyright (C) <year>  <name of author>\n-\n-    This library is free software; you can redistribute it and\/or\n-    modify it under the terms of the GNU Lesser General Public\n-    License as published by the Free Software Foundation; either\n-    version 2.1 of the License, or (at your option) any later version.\n-\n-    This library is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-    Lesser General Public License for more details.\n-\n-    You should have received a copy of the GNU Lesser General Public\n-    License along with this library; if not, write to the Free Software\n-    Foundation, Inc., 51 Franklin Street, Fifth Floor, \n-    Boston, MA  02110-1301  USA\n-\n-Also add information on how to contact you by electronic and paper mail.\n-\n-You should also get your employer (if you work as a programmer) or your\n-school, if any, to sign a \"copyright disclaimer\" for the library, if\n-necessary.  Here is a sample; alter the names:\n-\n-  Yoyodyne, Inc., hereby disclaims all copyright interest in the\n-  library `Frob' (a library for tweaking knobs) written by James Random Hacker.\n-\n-  <signature of Ty Coon>, 1 April 1990\n-  Ty Coon, President of Vice\n-\n-That's all there is to it!\n-\n-```\n-\n","filename":"src\/jdk.crypto.ec\/share\/legal\/ecc.md","additions":0,"deletions":599,"binary":false,"changes":599,"status":"deleted"},{"patch":"@@ -1,527 +0,0 @@\n-\/*\n- * Copyright (c) 2009, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include <jni.h>\n-#include \"jni_util.h\"\n-#include \"impl\/ecc_impl.h\"\n-#include \"sun_security_ec_ECDHKeyAgreement.h\"\n-#include \"sun_security_ec_ECKeyPairGenerator.h\"\n-#include \"sun_security_ec_ECDSASignature.h\"\n-\n-#define ILLEGAL_STATE_EXCEPTION \"java\/lang\/IllegalStateException\"\n-#define INVALID_ALGORITHM_PARAMETER_EXCEPTION \\\n-        \"java\/security\/InvalidAlgorithmParameterException\"\n-#define INVALID_PARAMETER_EXCEPTION \\\n-        \"java\/security\/InvalidParameterException\"\n-#define KEY_EXCEPTION   \"java\/security\/KeyException\"\n-\n-extern \"C\" {\n-\n-\/*\n- * Declare library specific JNI_Onload entry if static build\n- *\/\n-DEF_STATIC_JNI_OnLoad\n-\n-\/*\n- * Throws an arbitrary Java exception.\n- *\/\n-void ThrowException(JNIEnv *env, const char *exceptionName)\n-{\n-    jclass exceptionClazz = env->FindClass(exceptionName);\n-    if (exceptionClazz != NULL) {\n-        env->ThrowNew(exceptionClazz, NULL);\n-    }\n-}\n-\n-\/*\n- * Deep free of the ECParams struct\n- *\/\n-void FreeECParams(ECParams *ecparams, jboolean freeStruct)\n-{\n-    \/\/ Use B_FALSE to free the SECItem->data element, but not the SECItem itself\n-    \/\/ Use B_TRUE to free both\n-\n-    SECITEM_FreeItem(&ecparams->fieldID.u.prime, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->curve.a, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->curve.b, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->curve.seed, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->base, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->order, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->DEREncoding, B_FALSE);\n-    SECITEM_FreeItem(&ecparams->curveOID, B_FALSE);\n-    if (freeStruct)\n-        free(ecparams);\n-}\n-\n-jbyteArray getEncodedBytes(JNIEnv *env, SECItem *hSECItem)\n-{\n-    SECItem *s = (SECItem *)hSECItem;\n-\n-    jbyteArray jEncodedBytes = env->NewByteArray(s->len);\n-    if (jEncodedBytes == NULL) {\n-        return NULL;\n-    }\n-    \/\/ Copy bytes from a native SECItem buffer to Java byte array\n-    env->SetByteArrayRegion(jEncodedBytes, 0, s->len, (jbyte *)s->data);\n-    if (env->ExceptionCheck()) { \/\/ should never happen\n-        return NULL;\n-    }\n-    return jEncodedBytes;\n-}\n-\n-\/*\n- * Class:     sun_security_ec_ECKeyPairGenerator\n- * Method:    isCurveSupported\n- * Signature: ([B)Z\n- *\/\n-JNIEXPORT jboolean\n-JNICALL Java_sun_security_ec_ECKeyPairGenerator_isCurveSupported\n-  (JNIEnv *env, jclass clazz, jbyteArray encodedParams)\n-{\n-    SECKEYECParams params_item;\n-    ECParams *ecparams = NULL;\n-    jboolean result = JNI_FALSE;\n-\n-    \/\/ The curve is supported if we can get parameters for it\n-    params_item.len = env->GetArrayLength(encodedParams);\n-    params_item.data =\n-        (unsigned char *) env->GetByteArrayElements(encodedParams, 0);\n-    if (params_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Fill a new ECParams using the supplied OID\n-    if (EC_DecodeParams(&params_item, &ecparams, 0) != SECSuccess) {\n-        \/* bad curve OID *\/\n-        goto cleanup;\n-    }\n-\n-    \/\/ If we make it to here, then the curve is supported\n-    result = JNI_TRUE;\n-\n-cleanup:\n-    {\n-        if (params_item.data) {\n-            env->ReleaseByteArrayElements(encodedParams,\n-                (jbyte *) params_item.data, JNI_ABORT);\n-        }\n-        if (ecparams) {\n-            FreeECParams(ecparams, true);\n-        }\n-    }\n-\n-    return result;\n-}\n-\n-\/*\n- * Class:     sun_security_ec_ECKeyPairGenerator\n- * Method:    generateECKeyPair\n- * Signature: (I[B[B)[[B\n- *\/\n-JNIEXPORT jobjectArray\n-JNICALL Java_sun_security_ec_ECKeyPairGenerator_generateECKeyPair\n-  (JNIEnv *env, jclass clazz, jint keySize, jbyteArray encodedParams, jbyteArray seed)\n-{\n-    ECPrivateKey *privKey = NULL; \/\/ contains both public and private values\n-    ECParams *ecparams = NULL;\n-    SECKEYECParams params_item;\n-    jint jSeedLength;\n-    jbyte* pSeedBuffer = NULL;\n-    jobjectArray result = NULL;\n-    jclass baCls = NULL;\n-    jbyteArray jba;\n-\n-    \/\/ Initialize the ECParams struct\n-    params_item.len = env->GetArrayLength(encodedParams);\n-    params_item.data =\n-        (unsigned char *) env->GetByteArrayElements(encodedParams, 0);\n-    if (params_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Fill a new ECParams using the supplied OID\n-    if (EC_DecodeParams(&params_item, &ecparams, 0) != SECSuccess) {\n-        \/* bad curve OID *\/\n-        ThrowException(env, INVALID_ALGORITHM_PARAMETER_EXCEPTION);\n-        goto cleanup;\n-    }\n-\n-    \/\/ Copy seed from Java to native buffer\n-    jSeedLength = env->GetArrayLength(seed);\n-    pSeedBuffer = new jbyte[jSeedLength];\n-    env->GetByteArrayRegion(seed, 0, jSeedLength, pSeedBuffer);\n-\n-    \/\/ Generate the new keypair (using the supplied seed)\n-    if (EC_NewKey(ecparams, &privKey, (unsigned char *) pSeedBuffer,\n-        jSeedLength, 0) != SECSuccess) {\n-        ThrowException(env, KEY_EXCEPTION);\n-        goto cleanup;\n-    }\n-\n-    jboolean isCopy;\n-    baCls = env->FindClass(\"[B\");\n-    if (baCls == NULL) {\n-        goto cleanup;\n-    }\n-    result = env->NewObjectArray(2, baCls, NULL);\n-    if (result == NULL) {\n-        goto cleanup;\n-    }\n-    jba = getEncodedBytes(env, &(privKey->privateValue));\n-    if (jba == NULL) {\n-        result = NULL;\n-        goto cleanup;\n-    }\n-    env->SetObjectArrayElement(result, 0, jba); \/\/ big integer\n-    if (env->ExceptionCheck()) { \/\/ should never happen\n-        result = NULL;\n-        goto cleanup;\n-    }\n-\n-    jba = getEncodedBytes(env, &(privKey->publicValue));\n-    if (jba == NULL) {\n-        result = NULL;\n-        goto cleanup;\n-    }\n-    env->SetObjectArrayElement(result, 1, jba); \/\/ encoded ec point\n-    if (env->ExceptionCheck()) { \/\/ should never happen\n-        result = NULL;\n-        goto cleanup;\n-    }\n-\n-cleanup:\n-    {\n-        if (params_item.data) {\n-            env->ReleaseByteArrayElements(encodedParams,\n-                (jbyte *) params_item.data, JNI_ABORT);\n-        }\n-        if (ecparams) {\n-            FreeECParams(ecparams, true);\n-        }\n-        if (privKey) {\n-            FreeECParams(&privKey->ecParams, false);\n-            SECITEM_FreeItem(&privKey->version, B_FALSE);\n-            SECITEM_FreeItem(&privKey->privateValue, B_FALSE);\n-            SECITEM_FreeItem(&privKey->publicValue, B_FALSE);\n-            free(privKey);\n-        }\n-\n-        if (pSeedBuffer) {\n-            delete [] pSeedBuffer;\n-        }\n-    }\n-\n-    return result;\n-}\n-\n-\/*\n- * Class:     sun_security_ec_ECDSASignature\n- * Method:    signDigest\n- * Signature: ([B[B[B[B)[B\n- *\/\n-JNIEXPORT jbyteArray\n-JNICALL Java_sun_security_ec_ECDSASignature_signDigest\n-  (JNIEnv *env, jclass clazz, jbyteArray digest, jbyteArray privateKey, jbyteArray encodedParams, jbyteArray seed, jint timing)\n-{\n-    jbyte* pDigestBuffer = NULL;\n-    jint jDigestLength = env->GetArrayLength(digest);\n-    jbyteArray jSignedDigest = NULL;\n-\n-    SECItem signature_item;\n-    jbyte* pSignedDigestBuffer = NULL;\n-    jbyteArray temp;\n-\n-    jint jSeedLength = env->GetArrayLength(seed);\n-    jbyte* pSeedBuffer = NULL;\n-\n-    \/\/ Copy digest from Java to native buffer\n-    pDigestBuffer = new jbyte[jDigestLength];\n-    env->GetByteArrayRegion(digest, 0, jDigestLength, pDigestBuffer);\n-    SECItem digest_item;\n-    digest_item.data = (unsigned char *) pDigestBuffer;\n-    digest_item.len = jDigestLength;\n-\n-    ECPrivateKey privKey;\n-    privKey.privateValue.data = NULL;\n-\n-    \/\/ Initialize the ECParams struct\n-    ECParams *ecparams = NULL;\n-    SECKEYECParams params_item;\n-    params_item.len = env->GetArrayLength(encodedParams);\n-    params_item.data =\n-        (unsigned char *) env->GetByteArrayElements(encodedParams, 0);\n-    if (params_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Fill a new ECParams using the supplied OID\n-    if (EC_DecodeParams(&params_item, &ecparams, 0) != SECSuccess) {\n-        \/* bad curve OID *\/\n-        ThrowException(env, INVALID_ALGORITHM_PARAMETER_EXCEPTION);\n-        goto cleanup;\n-    }\n-\n-    \/\/ Extract private key data\n-    privKey.ecParams = *ecparams; \/\/ struct assignment\n-    privKey.privateValue.len = env->GetArrayLength(privateKey);\n-    privKey.privateValue.data =\n-        (unsigned char *) env->GetByteArrayElements(privateKey, 0);\n-    if (privKey.privateValue.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Prepare a buffer for the signature (twice the key length)\n-    pSignedDigestBuffer = new jbyte[ecparams->order.len * 2];\n-    signature_item.data = (unsigned char *) pSignedDigestBuffer;\n-    signature_item.len = ecparams->order.len * 2;\n-\n-    \/\/ Copy seed from Java to native buffer\n-    pSeedBuffer = new jbyte[jSeedLength];\n-    env->GetByteArrayRegion(seed, 0, jSeedLength, pSeedBuffer);\n-\n-    \/\/ Sign the digest (using the supplied seed)\n-    if (ECDSA_SignDigest(&privKey, &signature_item, &digest_item,\n-        (unsigned char *) pSeedBuffer, jSeedLength, 0, timing) != SECSuccess) {\n-        ThrowException(env, KEY_EXCEPTION);\n-        goto cleanup;\n-    }\n-\n-    \/\/ Create new byte array\n-    temp = env->NewByteArray(signature_item.len);\n-    if (temp == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Copy data from native buffer\n-    env->SetByteArrayRegion(temp, 0, signature_item.len, pSignedDigestBuffer);\n-    jSignedDigest = temp;\n-\n-cleanup:\n-    {\n-        if (params_item.data) {\n-            env->ReleaseByteArrayElements(encodedParams,\n-                (jbyte *) params_item.data, JNI_ABORT);\n-        }\n-        if (privKey.privateValue.data) {\n-            env->ReleaseByteArrayElements(privateKey,\n-                (jbyte *) privKey.privateValue.data, JNI_ABORT);\n-        }\n-        if (pDigestBuffer) {\n-            delete [] pDigestBuffer;\n-        }\n-        if (pSignedDigestBuffer) {\n-            delete [] pSignedDigestBuffer;\n-        }\n-        if (pSeedBuffer) {\n-            delete [] pSeedBuffer;\n-        }\n-        if (ecparams) {\n-            FreeECParams(ecparams, true);\n-        }\n-    }\n-\n-    return jSignedDigest;\n-}\n-\n-\/*\n- * Class:     sun_security_ec_ECDSASignature\n- * Method:    verifySignedDigest\n- * Signature: ([B[B[B[B)Z\n- *\/\n-JNIEXPORT jboolean\n-JNICALL Java_sun_security_ec_ECDSASignature_verifySignedDigest\n-  (JNIEnv *env, jclass clazz, jbyteArray signedDigest, jbyteArray digest, jbyteArray publicKey, jbyteArray encodedParams)\n-{\n-    jboolean isValid = false;\n-\n-    \/\/ Copy signedDigest from Java to native buffer\n-    jbyte* pSignedDigestBuffer = NULL;\n-    jint jSignedDigestLength = env->GetArrayLength(signedDigest);\n-    pSignedDigestBuffer = new jbyte[jSignedDigestLength];\n-    env->GetByteArrayRegion(signedDigest, 0, jSignedDigestLength,\n-        pSignedDigestBuffer);\n-    SECItem signature_item;\n-    signature_item.data = (unsigned char *) pSignedDigestBuffer;\n-    signature_item.len = jSignedDigestLength;\n-\n-    \/\/ Copy digest from Java to native buffer\n-    jbyte* pDigestBuffer = NULL;\n-    jint jDigestLength = env->GetArrayLength(digest);\n-    pDigestBuffer = new jbyte[jDigestLength];\n-    env->GetByteArrayRegion(digest, 0, jDigestLength, pDigestBuffer);\n-    SECItem digest_item;\n-    digest_item.data = (unsigned char *) pDigestBuffer;\n-    digest_item.len = jDigestLength;\n-\n-    \/\/ Extract public key data\n-    ECPublicKey pubKey;\n-    pubKey.publicValue.data = NULL;\n-    ECParams *ecparams = NULL;\n-    SECKEYECParams params_item;\n-\n-    \/\/ Initialize the ECParams struct\n-    params_item.len = env->GetArrayLength(encodedParams);\n-    params_item.data =\n-        (unsigned char *) env->GetByteArrayElements(encodedParams, 0);\n-    if (params_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Fill a new ECParams using the supplied OID\n-    if (EC_DecodeParams(&params_item, &ecparams, 0) != SECSuccess) {\n-        \/* bad curve OID *\/\n-        ThrowException(env, INVALID_ALGORITHM_PARAMETER_EXCEPTION);\n-        goto cleanup;\n-    }\n-    pubKey.ecParams = *ecparams; \/\/ struct assignment\n-    pubKey.publicValue.len = env->GetArrayLength(publicKey);\n-    pubKey.publicValue.data =\n-        (unsigned char *) env->GetByteArrayElements(publicKey, 0);\n-\n-    if (ECDSA_VerifyDigest(&pubKey, &signature_item, &digest_item, 0)\n-            != SECSuccess) {\n-        goto cleanup;\n-    }\n-\n-    isValid = true;\n-\n-cleanup:\n-    {\n-        if (params_item.data)\n-            env->ReleaseByteArrayElements(encodedParams,\n-                (jbyte *) params_item.data, JNI_ABORT);\n-\n-        if (pubKey.publicValue.data)\n-            env->ReleaseByteArrayElements(publicKey,\n-                (jbyte *) pubKey.publicValue.data, JNI_ABORT);\n-\n-        if (ecparams)\n-            FreeECParams(ecparams, true);\n-\n-        if (pSignedDigestBuffer)\n-            delete [] pSignedDigestBuffer;\n-\n-        if (pDigestBuffer)\n-            delete [] pDigestBuffer;\n-    }\n-\n-    return isValid;\n-}\n-\n-\/*\n- * Class:     sun_security_ec_ECDHKeyAgreement\n- * Method:    deriveKey\n- * Signature: ([B[B[B)[B\n- *\/\n-JNIEXPORT jbyteArray\n-JNICALL Java_sun_security_ec_ECDHKeyAgreement_deriveKey\n-  (JNIEnv *env, jclass clazz, jbyteArray privateKey, jbyteArray publicKey, jbyteArray encodedParams)\n-{\n-    jbyteArray jSecret = NULL;\n-    ECParams *ecparams = NULL;\n-    SECItem privateValue_item;\n-    privateValue_item.data = NULL;\n-    SECItem publicValue_item;\n-    publicValue_item.data = NULL;\n-    SECKEYECParams params_item;\n-    params_item.data = NULL;\n-\n-    \/\/ Extract private key value\n-    privateValue_item.len = env->GetArrayLength(privateKey);\n-    privateValue_item.data =\n-            (unsigned char *) env->GetByteArrayElements(privateKey, 0);\n-    if (privateValue_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Extract public key value\n-    publicValue_item.len = env->GetArrayLength(publicKey);\n-    publicValue_item.data =\n-        (unsigned char *) env->GetByteArrayElements(publicKey, 0);\n-    if (publicValue_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Initialize the ECParams struct\n-    params_item.len = env->GetArrayLength(encodedParams);\n-    params_item.data =\n-        (unsigned char *) env->GetByteArrayElements(encodedParams, 0);\n-    if (params_item.data == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Fill a new ECParams using the supplied OID\n-    if (EC_DecodeParams(&params_item, &ecparams, 0) != SECSuccess) {\n-        \/* bad curve OID *\/\n-        ThrowException(env, INVALID_ALGORITHM_PARAMETER_EXCEPTION);\n-        goto cleanup;\n-    }\n-\n-    \/\/ Prepare a buffer for the secret\n-    SECItem secret_item;\n-    secret_item.data = NULL;\n-    secret_item.len = ecparams->order.len * 2;\n-\n-    if (ECDH_Derive(&publicValue_item, ecparams, &privateValue_item, B_FALSE,\n-        &secret_item, 0) != SECSuccess) {\n-        ThrowException(env, ILLEGAL_STATE_EXCEPTION);\n-        goto cleanup;\n-    }\n-\n-    \/\/ Create new byte array\n-    jSecret = env->NewByteArray(secret_item.len);\n-    if (jSecret == NULL) {\n-        goto cleanup;\n-    }\n-\n-    \/\/ Copy bytes from the SECItem buffer to a Java byte array\n-    env->SetByteArrayRegion(jSecret, 0, secret_item.len,\n-        (jbyte *)secret_item.data);\n-\n-    \/\/ Free the SECItem data buffer\n-    SECITEM_FreeItem(&secret_item, B_FALSE);\n-\n-cleanup:\n-    {\n-        if (privateValue_item.data)\n-            env->ReleaseByteArrayElements(privateKey,\n-                (jbyte *) privateValue_item.data, JNI_ABORT);\n-\n-        if (publicValue_item.data)\n-            env->ReleaseByteArrayElements(publicKey,\n-                (jbyte *) publicValue_item.data, JNI_ABORT);\n-\n-        if (params_item.data)\n-            env->ReleaseByteArrayElements(encodedParams,\n-                (jbyte *) params_item.data, JNI_ABORT);\n-\n-        if (ecparams)\n-            FreeECParams(ecparams, true);\n-    }\n-\n-    return jSecret;\n-}\n-\n-} \/* extern \"C\" *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/ECC_JNI.cpp","additions":0,"deletions":527,"binary":false,"changes":527,"status":"deleted"},{"patch":"@@ -1,1091 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Elliptic Curve Cryptography library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com> and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"mplogic.h\"\n-#include \"ec.h\"\n-#include \"ecl.h\"\n-\n-#include <sys\/types.h>\n-#ifndef _KERNEL\n-#include <stdio.h>\n-#include <stdlib.h>\n-#include <string.h>\n-\n-#ifndef _WIN32\n-#include <strings.h>\n-#endif \/* _WIN32 *\/\n-\n-#endif\n-#include \"ecl-exp.h\"\n-#include \"mpi.h\"\n-#include \"ecc_impl.h\"\n-\n-#ifdef _KERNEL\n-#define PORT_ZFree(p, l)                bzero((p), (l)); kmem_free((p), (l))\n-#else\n-#ifndef _WIN32\n-#define PORT_ZFree(p, l)                bzero((p), (l)); free((p))\n-#else\n-#define PORT_ZFree(p, l)                memset((p), 0, (l)); free((p))\n-#endif \/* _WIN32 *\/\n-#endif\n-\n-\/*\n- * Returns true if pointP is the point at infinity, false otherwise\n- *\/\n-PRBool\n-ec_point_at_infinity(SECItem *pointP)\n-{\n-    unsigned int i;\n-\n-    for (i = 1; i < pointP->len; i++) {\n-        if (pointP->data[i] != 0x00) return PR_FALSE;\n-    }\n-\n-    return PR_TRUE;\n-}\n-\n-\/*\n- * Computes scalar point multiplication pointQ = k1 * G + k2 * pointP for\n- * the curve whose parameters are encoded in params with base point G.\n- *\/\n-SECStatus\n-ec_points_mul(const ECParams *params, const mp_int *k1, const mp_int *k2,\n-             const SECItem *pointP, SECItem *pointQ, int kmflag, int timing)\n-{\n-    mp_int Px, Py, Qx, Qy;\n-    mp_int Gx, Gy, order, irreducible, a, b;\n-#if 0 \/* currently don't support non-named curves *\/\n-    unsigned int irr_arr[5];\n-#endif\n-    ECGroup *group = NULL;\n-    SECStatus rv = SECFailure;\n-    mp_err err = MP_OKAY;\n-    unsigned int len;\n-\n-#if EC_DEBUG\n-    int i;\n-    char mpstr[256];\n-\n-    printf(\"ec_points_mul: params [len=%d]:\", params->DEREncoding.len);\n-    for (i = 0; i < params->DEREncoding.len; i++)\n-            printf(\"%02x:\", params->DEREncoding.data[i]);\n-    printf(\"\\n\");\n-\n-        if (k1 != NULL) {\n-                mp_tohex((mp_int*)k1, mpstr);\n-                printf(\"ec_points_mul: scalar k1: %s\\n\", mpstr);\n-                mp_todecimal((mp_int*)k1, mpstr);\n-                printf(\"ec_points_mul: scalar k1: %s (dec)\\n\", mpstr);\n-        }\n-\n-        if (k2 != NULL) {\n-                mp_tohex((mp_int*)k2, mpstr);\n-                printf(\"ec_points_mul: scalar k2: %s\\n\", mpstr);\n-                mp_todecimal((mp_int*)k2, mpstr);\n-                printf(\"ec_points_mul: scalar k2: %s (dec)\\n\", mpstr);\n-        }\n-\n-        if (pointP != NULL) {\n-                printf(\"ec_points_mul: pointP [len=%d]:\", pointP->len);\n-                for (i = 0; i < pointP->len; i++)\n-                        printf(\"%02x:\", pointP->data[i]);\n-                printf(\"\\n\");\n-        }\n-#endif\n-\n-        \/* NOTE: We only support uncompressed points for now *\/\n-        len = (params->fieldID.size + 7) >> 3;\n-        if (pointP != NULL) {\n-                if ((pointP->data[0] != EC_POINT_FORM_UNCOMPRESSED) ||\n-                        (pointP->len != (2 * len + 1))) {\n-                        return SECFailure;\n-                };\n-        }\n-\n-        MP_DIGITS(&Px) = 0;\n-        MP_DIGITS(&Py) = 0;\n-        MP_DIGITS(&Qx) = 0;\n-        MP_DIGITS(&Qy) = 0;\n-        MP_DIGITS(&Gx) = 0;\n-        MP_DIGITS(&Gy) = 0;\n-        MP_DIGITS(&order) = 0;\n-        MP_DIGITS(&irreducible) = 0;\n-        MP_DIGITS(&a) = 0;\n-        MP_DIGITS(&b) = 0;\n-        CHECK_MPI_OK( mp_init(&Px, kmflag) );\n-        CHECK_MPI_OK( mp_init(&Py, kmflag) );\n-        CHECK_MPI_OK( mp_init(&Qx, kmflag) );\n-        CHECK_MPI_OK( mp_init(&Qy, kmflag) );\n-        CHECK_MPI_OK( mp_init(&Gx, kmflag) );\n-        CHECK_MPI_OK( mp_init(&Gy, kmflag) );\n-        CHECK_MPI_OK( mp_init(&order, kmflag) );\n-        CHECK_MPI_OK( mp_init(&irreducible, kmflag) );\n-        CHECK_MPI_OK( mp_init(&a, kmflag) );\n-        CHECK_MPI_OK( mp_init(&b, kmflag) );\n-\n-        if ((k2 != NULL) && (pointP != NULL)) {\n-                \/* Initialize Px and Py *\/\n-                CHECK_MPI_OK( mp_read_unsigned_octets(&Px, pointP->data + 1, (mp_size) len) );\n-                CHECK_MPI_OK( mp_read_unsigned_octets(&Py, pointP->data + 1 + len, (mp_size) len) );\n-        }\n-\n-        \/* construct from named params, if possible *\/\n-        if (params->name != ECCurve_noName) {\n-                group = ECGroup_fromName(params->name, kmflag);\n-        }\n-\n-#if 0 \/* currently don't support non-named curves *\/\n-        if (group == NULL) {\n-                \/* Set up mp_ints containing the curve coefficients *\/\n-                CHECK_MPI_OK( mp_read_unsigned_octets(&Gx, params->base.data + 1,\n-                                                                                  (mp_size) len) );\n-                CHECK_MPI_OK( mp_read_unsigned_octets(&Gy, params->base.data + 1 + len,\n-                                                                                  (mp_size) len) );\n-                SECITEM_TO_MPINT( params->order, &order );\n-                SECITEM_TO_MPINT( params->curve.a, &a );\n-                SECITEM_TO_MPINT( params->curve.b, &b );\n-                if (params->fieldID.type == ec_field_GFp) {\n-                        SECITEM_TO_MPINT( params->fieldID.u.prime, &irreducible );\n-                        group = ECGroup_consGFp(&irreducible, &a, &b, &Gx, &Gy, &order, params->cofactor);\n-                } else {\n-                        SECITEM_TO_MPINT( params->fieldID.u.poly, &irreducible );\n-                        irr_arr[0] = params->fieldID.size;\n-                        irr_arr[1] = params->fieldID.k1;\n-                        irr_arr[2] = params->fieldID.k2;\n-                        irr_arr[3] = params->fieldID.k3;\n-                        irr_arr[4] = 0;\n-                        group = ECGroup_consGF2m(&irreducible, irr_arr, &a, &b, &Gx, &Gy, &order, params->cofactor);\n-                }\n-        }\n-#endif\n-        if (group == NULL)\n-                goto cleanup;\n-\n-        if ((k2 != NULL) && (pointP != NULL)) {\n-                CHECK_MPI_OK( ECPoints_mul(group, k1, k2, &Px, &Py, &Qx, &Qy, timing) );\n-        } else {\n-                CHECK_MPI_OK( ECPoints_mul(group, k1, NULL, NULL, NULL, &Qx, &Qy, timing) );\n-    }\n-\n-    \/* Construct the SECItem representation of point Q *\/\n-    pointQ->data[0] = EC_POINT_FORM_UNCOMPRESSED;\n-    CHECK_MPI_OK( mp_to_fixlen_octets(&Qx, pointQ->data + 1,\n-                                      (mp_size) len) );\n-    CHECK_MPI_OK( mp_to_fixlen_octets(&Qy, pointQ->data + 1 + len,\n-                                      (mp_size) len) );\n-\n-    rv = SECSuccess;\n-\n-#if EC_DEBUG\n-    printf(\"ec_points_mul: pointQ [len=%d]:\", pointQ->len);\n-    for (i = 0; i < pointQ->len; i++)\n-            printf(\"%02x:\", pointQ->data[i]);\n-    printf(\"\\n\");\n-#endif\n-\n-cleanup:\n-    ECGroup_free(group);\n-    mp_clear(&Px);\n-    mp_clear(&Py);\n-    mp_clear(&Qx);\n-    mp_clear(&Qy);\n-    mp_clear(&Gx);\n-    mp_clear(&Gy);\n-    mp_clear(&order);\n-    mp_clear(&irreducible);\n-    mp_clear(&a);\n-    mp_clear(&b);\n-    if (err) {\n-        MP_TO_SEC_ERROR(err);\n-        rv = SECFailure;\n-    }\n-\n-    return rv;\n-}\n-\n-\/* Generates a new EC key pair. The private key is a supplied\n- * value and the public key is the result of performing a scalar\n- * point multiplication of that value with the curve's base point.\n- *\/\n-SECStatus\n-ec_NewKey(ECParams *ecParams, ECPrivateKey **privKey,\n-    const unsigned char *privKeyBytes, int privKeyLen, int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    PRArenaPool *arena;\n-    ECPrivateKey *key;\n-    mp_int k;\n-    mp_err err = MP_OKAY;\n-    int len;\n-\n-#if EC_DEBUG\n-    printf(\"ec_NewKey called\\n\");\n-#endif\n-    k.dp = (mp_digit*)NULL;\n-\n-    if (!ecParams || !privKey || !privKeyBytes || (privKeyLen < 0)) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        return SECFailure;\n-    }\n-\n-    \/* Initialize an arena for the EC key. *\/\n-    if (!(arena = PORT_NewArena(NSS_FREEBL_DEFAULT_CHUNKSIZE)))\n-        return SECFailure;\n-\n-    key = (ECPrivateKey *)PORT_ArenaZAlloc(arena, sizeof(ECPrivateKey),\n-        kmflag);\n-    if (!key) {\n-        PORT_FreeArena(arena, PR_TRUE);\n-        return SECFailure;\n-    }\n-\n-    \/* Set the version number (SEC 1 section C.4 says it should be 1) *\/\n-    SECITEM_AllocItem(arena, &key->version, 1, kmflag);\n-    key->version.data[0] = 1;\n-\n-    \/* Copy all of the fields from the ECParams argument to the\n-     * ECParams structure within the private key.\n-     *\/\n-    key->ecParams.arena = arena;\n-    key->ecParams.type = ecParams->type;\n-    key->ecParams.fieldID.size = ecParams->fieldID.size;\n-    key->ecParams.fieldID.type = ecParams->fieldID.type;\n-    if (ecParams->fieldID.type == ec_field_GFp) {\n-        CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.fieldID.u.prime,\n-            &ecParams->fieldID.u.prime, kmflag));\n-    } else {\n-        CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.fieldID.u.poly,\n-            &ecParams->fieldID.u.poly, kmflag));\n-    }\n-    key->ecParams.fieldID.k1 = ecParams->fieldID.k1;\n-    key->ecParams.fieldID.k2 = ecParams->fieldID.k2;\n-    key->ecParams.fieldID.k3 = ecParams->fieldID.k3;\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curve.a,\n-        &ecParams->curve.a, kmflag));\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curve.b,\n-        &ecParams->curve.b, kmflag));\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curve.seed,\n-        &ecParams->curve.seed, kmflag));\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.base,\n-        &ecParams->base, kmflag));\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.order,\n-        &ecParams->order, kmflag));\n-    key->ecParams.cofactor = ecParams->cofactor;\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.DEREncoding,\n-        &ecParams->DEREncoding, kmflag));\n-    key->ecParams.name = ecParams->name;\n-    CHECK_SEC_OK(SECITEM_CopyItem(arena, &key->ecParams.curveOID,\n-        &ecParams->curveOID, kmflag));\n-\n-    len = (ecParams->fieldID.size + 7) >> 3;\n-    SECITEM_AllocItem(arena, &key->publicValue, 2*len + 1, kmflag);\n-    len = ecParams->order.len;\n-    SECITEM_AllocItem(arena, &key->privateValue, len, kmflag);\n-\n-    \/* Copy private key *\/\n-    if (privKeyLen >= len) {\n-        memcpy(key->privateValue.data, privKeyBytes, len);\n-    } else {\n-        memset(key->privateValue.data, 0, (len - privKeyLen));\n-        memcpy(key->privateValue.data + (len - privKeyLen), privKeyBytes, privKeyLen);\n-    }\n-\n-    \/* Compute corresponding public key *\/\n-    MP_DIGITS(&k) = 0;\n-    CHECK_MPI_OK( mp_init(&k, kmflag) );\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&k, key->privateValue.data,\n-        (mp_size) len) );\n-\n-    \/* key generation does not support timing mitigation *\/\n-    rv = ec_points_mul(ecParams, &k, NULL, NULL, &(key->publicValue), kmflag, \/*timing*\/ 0);\n-    if (rv != SECSuccess) goto cleanup;\n-    *privKey = key;\n-\n-cleanup:\n-    mp_clear(&k);\n-    if (rv) {\n-        PORT_FreeArena(arena, PR_TRUE);\n-    }\n-\n-#if EC_DEBUG\n-    printf(\"ec_NewKey returning %s\\n\",\n-        (rv == SECSuccess) ? \"success\" : \"failure\");\n-#endif\n-\n-    return rv;\n-\n-}\n-\n-\/* Generates a new EC key pair. The private key is a supplied\n- * random value (in seed) and the public key is the result of\n- * performing a scalar point multiplication of that value with\n- * the curve's base point.\n- *\/\n-SECStatus\n-EC_NewKeyFromSeed(ECParams *ecParams, ECPrivateKey **privKey,\n-    const unsigned char *seed, int seedlen, int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    rv = ec_NewKey(ecParams, privKey, seed, seedlen, kmflag);\n-    return rv;\n-}\n-\n-\/* Generate a random private key using the algorithm A.4.1 of ANSI X9.62,\n- * modified a la FIPS 186-2 Change Notice 1 to eliminate the bias in the\n- * random number generator.\n- *\n- * Parameters\n- * - order: a buffer that holds the curve's group order\n- * - len: the length in octets of the order buffer\n- * - random: a buffer of 2 * len random bytes\n- * - randomlen: the length in octets of the random buffer\n- *\n- * Return Value\n- * Returns a buffer of len octets that holds the private key. The caller\n- * is responsible for freeing the buffer with PORT_ZFree.\n- *\/\n-static unsigned char *\n-ec_GenerateRandomPrivateKey(const unsigned char *order, int len,\n-    const unsigned char *random, int randomlen, int kmflag)\n-{\n-    SECStatus rv = SECSuccess;\n-    mp_err err;\n-    unsigned char *privKeyBytes = NULL;\n-    mp_int privKeyVal, order_1, one;\n-\n-    MP_DIGITS(&privKeyVal) = 0;\n-    MP_DIGITS(&order_1) = 0;\n-    MP_DIGITS(&one) = 0;\n-    CHECK_MPI_OK( mp_init(&privKeyVal, kmflag) );\n-    CHECK_MPI_OK( mp_init(&order_1, kmflag) );\n-    CHECK_MPI_OK( mp_init(&one, kmflag) );\n-\n-    \/*\n-     * Reduces the 2*len buffer of random bytes modulo the group order.\n-     *\/\n-    if ((privKeyBytes = PORT_Alloc(2*len, kmflag)) == NULL) goto cleanup;\n-    if (randomlen != 2 * len) {\n-        randomlen = 2 * len;\n-    }\n-    \/* No need to generate - random bytes are now supplied *\/\n-    \/* CHECK_SEC_OK( RNG_GenerateGlobalRandomBytes(privKeyBytes, 2*len) );*\/\n-    memcpy(privKeyBytes, random, randomlen);\n-\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&privKeyVal, privKeyBytes, 2*len) );\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&order_1, order, len) );\n-    CHECK_MPI_OK( mp_set_int(&one, 1) );\n-    CHECK_MPI_OK( mp_sub(&order_1, &one, &order_1) );\n-    CHECK_MPI_OK( mp_mod(&privKeyVal, &order_1, &privKeyVal) );\n-    CHECK_MPI_OK( mp_add(&privKeyVal, &one, &privKeyVal) );\n-    CHECK_MPI_OK( mp_to_fixlen_octets(&privKeyVal, privKeyBytes, len) );\n-    memset(privKeyBytes+len, 0, len);\n-cleanup:\n-    mp_clear(&privKeyVal);\n-    mp_clear(&order_1);\n-    mp_clear(&one);\n-    if (err < MP_OKAY) {\n-        MP_TO_SEC_ERROR(err);\n-        rv = SECFailure;\n-    }\n-    if (rv != SECSuccess && privKeyBytes) {\n-#ifdef _KERNEL\n-        kmem_free(privKeyBytes, 2*len);\n-#else\n-        free(privKeyBytes);\n-#endif\n-        privKeyBytes = NULL;\n-    }\n-    return privKeyBytes;\n-}\n-\n-\/* Generates a new EC key pair. The private key is a random value and\n- * the public key is the result of performing a scalar point multiplication\n- * of that value with the curve's base point.\n- *\/\n-SECStatus\n-EC_NewKey(ECParams *ecParams, ECPrivateKey **privKey,\n-    const unsigned char* random, int randomlen, int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    int len;\n-    unsigned char *privKeyBytes = NULL;\n-\n-    if (!ecParams) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        return SECFailure;\n-    }\n-\n-    len = ecParams->order.len;\n-    privKeyBytes = ec_GenerateRandomPrivateKey(ecParams->order.data, len,\n-        random, randomlen, kmflag);\n-    if (privKeyBytes == NULL) goto cleanup;\n-    \/* generate public key *\/\n-    CHECK_SEC_OK( ec_NewKey(ecParams, privKey, privKeyBytes, len, kmflag) );\n-\n-cleanup:\n-    if (privKeyBytes) {\n-        PORT_ZFree(privKeyBytes, len * 2);\n-    }\n-#if EC_DEBUG\n-    printf(\"EC_NewKey returning %s\\n\",\n-        (rv == SECSuccess) ? \"success\" : \"failure\");\n-#endif\n-\n-    return rv;\n-}\n-\n-\/* Validates an EC public key as described in Section 5.2.2 of\n- * X9.62. The ECDH primitive when used without the cofactor does\n- * not address small subgroup attacks, which may occur when the\n- * public key is not valid. These attacks can be prevented by\n- * validating the public key before using ECDH.\n- *\/\n-SECStatus\n-EC_ValidatePublicKey(ECParams *ecParams, SECItem *publicValue, int kmflag)\n-{\n-    mp_int Px, Py;\n-    ECGroup *group = NULL;\n-    SECStatus rv = SECFailure;\n-    mp_err err = MP_OKAY;\n-    unsigned int len;\n-\n-    if (!ecParams || !publicValue) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        return SECFailure;\n-    }\n-\n-    \/* NOTE: We only support uncompressed points for now *\/\n-    len = (ecParams->fieldID.size + 7) >> 3;\n-    if (publicValue->data[0] != EC_POINT_FORM_UNCOMPRESSED) {\n-        PORT_SetError(SEC_ERROR_UNSUPPORTED_EC_POINT_FORM);\n-        return SECFailure;\n-    } else if (publicValue->len != (2 * len + 1)) {\n-        PORT_SetError(SEC_ERROR_BAD_KEY);\n-        return SECFailure;\n-    }\n-\n-    MP_DIGITS(&Px) = 0;\n-    MP_DIGITS(&Py) = 0;\n-    CHECK_MPI_OK( mp_init(&Px, kmflag) );\n-    CHECK_MPI_OK( mp_init(&Py, kmflag) );\n-\n-    \/* Initialize Px and Py *\/\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&Px, publicValue->data + 1, (mp_size) len) );\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&Py, publicValue->data + 1 + len, (mp_size) len) );\n-\n-    \/* construct from named params *\/\n-    group = ECGroup_fromName(ecParams->name, kmflag);\n-    if (group == NULL) {\n-        \/*\n-         * ECGroup_fromName fails if ecParams->name is not a valid\n-         * ECCurveName value, or if we run out of memory, or perhaps\n-         * for other reasons.  Unfortunately if ecParams->name is a\n-         * valid ECCurveName value, we don't know what the right error\n-         * code should be because ECGroup_fromName doesn't return an\n-         * error code to the caller.  Set err to MP_UNDEF because\n-         * that's what ECGroup_fromName uses internally.\n-         *\/\n-        if ((ecParams->name <= ECCurve_noName) ||\n-            (ecParams->name >= ECCurve_pastLastCurve)) {\n-            err = MP_BADARG;\n-        } else {\n-            err = MP_UNDEF;\n-        }\n-        goto cleanup;\n-    }\n-\n-    \/* validate public point *\/\n-    if ((err = ECPoint_validate(group, &Px, &Py)) < MP_YES) {\n-        if (err == MP_NO) {\n-            PORT_SetError(SEC_ERROR_BAD_KEY);\n-            rv = SECFailure;\n-            err = MP_OKAY;  \/* don't change the error code *\/\n-        }\n-        goto cleanup;\n-    }\n-\n-    rv = SECSuccess;\n-\n-cleanup:\n-    ECGroup_free(group);\n-    mp_clear(&Px);\n-    mp_clear(&Py);\n-    if (err) {\n-        MP_TO_SEC_ERROR(err);\n-        rv = SECFailure;\n-    }\n-    return rv;\n-}\n-\n-\/*\n-** Performs an ECDH key derivation by computing the scalar point\n-** multiplication of privateValue and publicValue (with or without the\n-** cofactor) and returns the x-coordinate of the resulting elliptic\n-** curve point in derived secret.  If successful, derivedSecret->data\n-** is set to the address of the newly allocated buffer containing the\n-** derived secret, and derivedSecret->len is the size of the secret\n-** produced. It is the caller's responsibility to free the allocated\n-** buffer containing the derived secret.\n-*\/\n-SECStatus\n-ECDH_Derive(SECItem  *publicValue,\n-            ECParams *ecParams,\n-            SECItem  *privateValue,\n-            PRBool    withCofactor,\n-            SECItem  *derivedSecret,\n-            int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    unsigned int len = 0;\n-    SECItem pointQ = {siBuffer, NULL, 0};\n-    mp_int k; \/* to hold the private value *\/\n-    mp_int cofactor;\n-    mp_err err = MP_OKAY;\n-#if EC_DEBUG\n-    int i;\n-#endif\n-\n-    if (!publicValue || !ecParams || !privateValue ||\n-        !derivedSecret) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        return SECFailure;\n-    }\n-\n-    if (EC_ValidatePublicKey(ecParams, publicValue, kmflag) != SECSuccess) {\n-        return SECFailure;\n-    }\n-\n-    memset(derivedSecret, 0, sizeof *derivedSecret);\n-    len = (ecParams->fieldID.size + 7) >> 3;\n-    pointQ.len = 2*len + 1;\n-    if ((pointQ.data = PORT_Alloc(2*len + 1, kmflag)) == NULL) goto cleanup;\n-\n-    MP_DIGITS(&k) = 0;\n-    CHECK_MPI_OK( mp_init(&k, kmflag) );\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&k, privateValue->data,\n-                                          (mp_size) privateValue->len) );\n-\n-    if (withCofactor && (ecParams->cofactor != 1)) {\n-            \/* multiply k with the cofactor *\/\n-            MP_DIGITS(&cofactor) = 0;\n-            CHECK_MPI_OK( mp_init(&cofactor, kmflag) );\n-            mp_set(&cofactor, ecParams->cofactor);\n-            CHECK_MPI_OK( mp_mul(&k, &cofactor, &k) );\n-    }\n-\n-    \/* Multiply our private key and peer's public point *\/\n-    \/* ECDH doesn't support timing mitigation *\/\n-    if ((ec_points_mul(ecParams, NULL, &k, publicValue, &pointQ, kmflag, \/*timing*\/ 0) != SECSuccess) ||\n-        ec_point_at_infinity(&pointQ))\n-        goto cleanup;\n-\n-    \/* Allocate memory for the derived secret and copy\n-     * the x co-ordinate of pointQ into it.\n-     *\/\n-    SECITEM_AllocItem(NULL, derivedSecret, len, kmflag);\n-    memcpy(derivedSecret->data, pointQ.data + 1, len);\n-\n-    rv = SECSuccess;\n-\n-#if EC_DEBUG\n-    printf(\"derived_secret:\\n\");\n-    for (i = 0; i < derivedSecret->len; i++)\n-        printf(\"%02x:\", derivedSecret->data[i]);\n-    printf(\"\\n\");\n-#endif\n-\n-cleanup:\n-    mp_clear(&k);\n-\n-    if (pointQ.data) {\n-        PORT_ZFree(pointQ.data, 2*len + 1);\n-    }\n-\n-    return rv;\n-}\n-\n-\/* Computes the ECDSA signature (a concatenation of two values r and s)\n- * on the digest using the given key and the random value kb (used in\n- * computing s).\n- *\/\n-SECStatus\n-ECDSA_SignDigestWithSeed(ECPrivateKey *key, SECItem *signature,\n-    const SECItem *digest, const unsigned char *kb, const int kblen, int kmflag,\n-    int timing)\n-{\n-    SECStatus rv = SECFailure;\n-    mp_int x1;\n-    mp_int d, k;     \/* private key, random integer *\/\n-    mp_int r, s;     \/* tuple (r, s) is the signature *\/\n-    mp_int n;\n-    mp_err err = MP_OKAY;\n-    ECParams *ecParams = NULL;\n-    SECItem kGpoint = { siBuffer, NULL, 0};\n-    int flen = 0;    \/* length in bytes of the field size *\/\n-    unsigned olen;   \/* length in bytes of the base point order *\/\n-    unsigned int orderBitSize;\n-\n-#if EC_DEBUG\n-    char mpstr[256];\n-#endif\n-\n-    \/* Initialize MPI integers. *\/\n-    \/* must happen before the first potential call to cleanup *\/\n-    MP_DIGITS(&x1) = 0;\n-    MP_DIGITS(&d) = 0;\n-    MP_DIGITS(&k) = 0;\n-    MP_DIGITS(&r) = 0;\n-    MP_DIGITS(&s) = 0;\n-    MP_DIGITS(&n) = 0;\n-\n-    \/* Check args *\/\n-    if (!key || !signature || !digest || !kb || (kblen < 0)) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        goto cleanup;\n-    }\n-\n-    ecParams = &(key->ecParams);\n-    flen = (ecParams->fieldID.size + 7) >> 3;\n-    olen = ecParams->order.len;\n-    if (signature->data == NULL) {\n-        \/* a call to get the signature length only *\/\n-        goto finish;\n-    }\n-    if (signature->len < 2*olen) {\n-        PORT_SetError(SEC_ERROR_OUTPUT_LEN);\n-        rv = SECBufferTooSmall;\n-        goto cleanup;\n-    }\n-\n-\n-    CHECK_MPI_OK( mp_init(&x1, kmflag) );\n-    CHECK_MPI_OK( mp_init(&d, kmflag) );\n-    CHECK_MPI_OK( mp_init(&k, kmflag) );\n-    CHECK_MPI_OK( mp_init(&r, kmflag) );\n-    CHECK_MPI_OK( mp_init(&s, kmflag) );\n-    CHECK_MPI_OK( mp_init(&n, kmflag) );\n-\n-    SECITEM_TO_MPINT( ecParams->order, &n );\n-    SECITEM_TO_MPINT( key->privateValue, &d );\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&k, kb, kblen) );\n-    \/* Make sure k is in the interval [1, n-1] *\/\n-    if ((mp_cmp_z(&k) <= 0) || (mp_cmp(&k, &n) >= 0)) {\n-#if EC_DEBUG\n-        printf(\"k is outside [1, n-1]\\n\");\n-        mp_tohex(&k, mpstr);\n-        printf(\"k : %s \\n\", mpstr);\n-        mp_tohex(&n, mpstr);\n-        printf(\"n : %s \\n\", mpstr);\n-#endif\n-        PORT_SetError(SEC_ERROR_NEED_RANDOM);\n-        goto cleanup;\n-    }\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.3.2, Step 2\n-    **\n-    ** Compute kG\n-    *\/\n-    kGpoint.len = 2*flen + 1;\n-    kGpoint.data = PORT_Alloc(2*flen + 1, kmflag);\n-    if ((kGpoint.data == NULL) ||\n-        (ec_points_mul(ecParams, &k, NULL, NULL, &kGpoint, kmflag, timing)\n-            != SECSuccess))\n-        goto cleanup;\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.3.3, Step 1\n-    **\n-    ** Extract the x co-ordinate of kG into x1\n-    *\/\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&x1, kGpoint.data + 1,\n-                                          (mp_size) flen) );\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.3.3, Step 2\n-    **\n-    ** r = x1 mod n  NOTE: n is the order of the curve\n-    *\/\n-    CHECK_MPI_OK( mp_mod(&x1, &n, &r) );\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.3.3, Step 3\n-    **\n-    ** verify r != 0\n-    *\/\n-    if (mp_cmp_z(&r) == 0) {\n-        PORT_SetError(SEC_ERROR_NEED_RANDOM);\n-        goto cleanup;\n-    }\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.3.3, Step 4\n-    **\n-    ** s = (k**-1 * (HASH(M) + d*r)) mod n\n-    *\/\n-    SECITEM_TO_MPINT(*digest, &s);        \/* s = HASH(M)     *\/\n-\n-    \/* In the definition of EC signing, digests are truncated\n-     * to the order length\n-     * (see SEC 1 \"Elliptic Curve Digit Signature Algorithm\" section 4.1.*\/\n-    orderBitSize = mpl_significant_bits(&n);\n-    if (digest->len*8 > orderBitSize) {\n-        mpl_rsh(&s,&s,digest->len*8 - orderBitSize);\n-    }\n-\n-#if EC_DEBUG\n-    mp_todecimal(&n, mpstr);\n-    printf(\"n : %s (dec)\\n\", mpstr);\n-    mp_todecimal(&d, mpstr);\n-    printf(\"d : %s (dec)\\n\", mpstr);\n-    mp_tohex(&x1, mpstr);\n-    printf(\"x1: %s\\n\", mpstr);\n-    mp_todecimal(&s, mpstr);\n-    printf(\"digest: %s (decimal)\\n\", mpstr);\n-    mp_todecimal(&r, mpstr);\n-    printf(\"r : %s (dec)\\n\", mpstr);\n-    mp_tohex(&r, mpstr);\n-    printf(\"r : %s\\n\", mpstr);\n-#endif\n-\n-    CHECK_MPI_OK( mp_invmod(&k, &n, &k) );      \/* k = k**-1 mod n *\/\n-    CHECK_MPI_OK( mp_mulmod(&d, &r, &n, &d) );  \/* d = d * r mod n *\/\n-    CHECK_MPI_OK( mp_addmod(&s, &d, &n, &s) );  \/* s = s + d mod n *\/\n-    CHECK_MPI_OK( mp_mulmod(&s, &k, &n, &s) );  \/* s = s * k mod n *\/\n-\n-#if EC_DEBUG\n-    mp_todecimal(&s, mpstr);\n-    printf(\"s : %s (dec)\\n\", mpstr);\n-    mp_tohex(&s, mpstr);\n-    printf(\"s : %s\\n\", mpstr);\n-#endif\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.3.3, Step 5\n-    **\n-    ** verify s != 0\n-    *\/\n-    if (mp_cmp_z(&s) == 0) {\n-        PORT_SetError(SEC_ERROR_NEED_RANDOM);\n-        goto cleanup;\n-    }\n-\n-   \/*\n-    **\n-    ** Signature is tuple (r, s)\n-    *\/\n-    CHECK_MPI_OK( mp_to_fixlen_octets(&r, signature->data, olen) );\n-    CHECK_MPI_OK( mp_to_fixlen_octets(&s, signature->data + olen, olen) );\n-finish:\n-    signature->len = 2*olen;\n-\n-    rv = SECSuccess;\n-    err = MP_OKAY;\n-cleanup:\n-    mp_clear(&x1);\n-    mp_clear(&d);\n-    mp_clear(&k);\n-    mp_clear(&r);\n-    mp_clear(&s);\n-    mp_clear(&n);\n-\n-    if (kGpoint.data) {\n-        PORT_ZFree(kGpoint.data, 2*flen + 1);\n-    }\n-\n-    if (err) {\n-        MP_TO_SEC_ERROR(err);\n-        rv = SECFailure;\n-    }\n-\n-#if EC_DEBUG\n-    printf(\"ECDSA signing with seed %s\\n\",\n-        (rv == SECSuccess) ? \"succeeded\" : \"failed\");\n-#endif\n-\n-   return rv;\n-}\n-\n-\/*\n-** Computes the ECDSA signature on the digest using the given key\n-** and a random seed.\n-*\/\n-SECStatus\n-ECDSA_SignDigest(ECPrivateKey *key, SECItem *signature, const SECItem *digest,\n-    const unsigned char* random, int randomLen, int kmflag, int timing)\n-{\n-    SECStatus rv = SECFailure;\n-    int len;\n-    unsigned char *kBytes= NULL;\n-\n-    if (!key) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        return SECFailure;\n-    }\n-\n-    \/* Generate random value k *\/\n-    len = key->ecParams.order.len;\n-    kBytes = ec_GenerateRandomPrivateKey(key->ecParams.order.data, len,\n-        random, randomLen, kmflag);\n-    if (kBytes == NULL) goto cleanup;\n-\n-    \/* Generate ECDSA signature with the specified k value *\/\n-    rv = ECDSA_SignDigestWithSeed(key, signature, digest, kBytes, len, kmflag, timing);\n-\n-cleanup:\n-    if (kBytes) {\n-        PORT_ZFree(kBytes, len * 2);\n-    }\n-\n-#if EC_DEBUG\n-    printf(\"ECDSA signing %s\\n\",\n-        (rv == SECSuccess) ? \"succeeded\" : \"failed\");\n-#endif\n-\n-    return rv;\n-}\n-\n-\/*\n-** Checks the signature on the given digest using the key provided.\n-*\/\n-SECStatus\n-ECDSA_VerifyDigest(ECPublicKey *key, const SECItem *signature,\n-                 const SECItem *digest, int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    mp_int r_, s_;           \/* tuple (r', s') is received signature) *\/\n-    mp_int c, u1, u2, v;     \/* intermediate values used in verification *\/\n-    mp_int x1;\n-    mp_int n;\n-    mp_err err = MP_OKAY;\n-    ECParams *ecParams = NULL;\n-    SECItem pointC = { siBuffer, NULL, 0 };\n-    int slen;       \/* length in bytes of a half signature (r or s) *\/\n-    int flen;       \/* length in bytes of the field size *\/\n-    unsigned olen;  \/* length in bytes of the base point order *\/\n-    unsigned int orderBitSize;\n-\n-#if EC_DEBUG\n-    char mpstr[256];\n-    printf(\"ECDSA verification called\\n\");\n-#endif\n-\n-    \/* Initialize MPI integers. *\/\n-    \/* must happen before the first potential call to cleanup *\/\n-    MP_DIGITS(&r_) = 0;\n-    MP_DIGITS(&s_) = 0;\n-    MP_DIGITS(&c) = 0;\n-    MP_DIGITS(&u1) = 0;\n-    MP_DIGITS(&u2) = 0;\n-    MP_DIGITS(&x1) = 0;\n-    MP_DIGITS(&v)  = 0;\n-    MP_DIGITS(&n)  = 0;\n-\n-    \/* Check args *\/\n-    if (!key || !signature || !digest) {\n-        PORT_SetError(SEC_ERROR_INVALID_ARGS);\n-        goto cleanup;\n-    }\n-\n-    ecParams = &(key->ecParams);\n-    flen = (ecParams->fieldID.size + 7) >> 3;\n-    olen = ecParams->order.len;\n-    if (signature->len == 0 || signature->len%2 != 0 ||\n-        signature->len > 2*olen) {\n-        PORT_SetError(SEC_ERROR_INPUT_LEN);\n-        goto cleanup;\n-    }\n-    slen = signature->len\/2;\n-\n-    SECITEM_AllocItem(NULL, &pointC, 2*flen + 1, kmflag);\n-    if (pointC.data == NULL)\n-        goto cleanup;\n-\n-    CHECK_MPI_OK( mp_init(&r_, kmflag) );\n-    CHECK_MPI_OK( mp_init(&s_, kmflag) );\n-    CHECK_MPI_OK( mp_init(&c, kmflag)  );\n-    CHECK_MPI_OK( mp_init(&u1, kmflag) );\n-    CHECK_MPI_OK( mp_init(&u2, kmflag) );\n-    CHECK_MPI_OK( mp_init(&x1, kmflag)  );\n-    CHECK_MPI_OK( mp_init(&v, kmflag)  );\n-    CHECK_MPI_OK( mp_init(&n, kmflag)  );\n-\n-    \/*\n-    ** Convert received signature (r', s') into MPI integers.\n-    *\/\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&r_, signature->data, slen) );\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&s_, signature->data + slen, slen) );\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.2, Steps 1 and 2\n-    **\n-    ** Verify that 0 < r' < n and 0 < s' < n\n-    *\/\n-    SECITEM_TO_MPINT(ecParams->order, &n);\n-    if (mp_cmp_z(&r_) <= 0 || mp_cmp_z(&s_) <= 0 ||\n-        mp_cmp(&r_, &n) >= 0 || mp_cmp(&s_, &n) >= 0) {\n-        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);\n-        goto cleanup; \/* will return rv == SECFailure *\/\n-    }\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.2, Step 3\n-    **\n-    ** c = (s')**-1 mod n\n-    *\/\n-    CHECK_MPI_OK( mp_invmod(&s_, &n, &c) );      \/* c = (s')**-1 mod n *\/\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.2, Step 4\n-    **\n-    ** u1 = ((HASH(M')) * c) mod n\n-    *\/\n-    SECITEM_TO_MPINT(*digest, &u1);                  \/* u1 = HASH(M)     *\/\n-\n-    \/* In the definition of EC signing, digests are truncated\n-     * to the order length, in bits.\n-     * (see SEC 1 \"Elliptic Curve Digit Signature Algorithm\" section 4.1.*\/\n-    \/* u1 = HASH(M')     *\/\n-    orderBitSize = mpl_significant_bits(&n);\n-    if (digest->len*8 > orderBitSize) {\n-        mpl_rsh(&u1,&u1,digest->len*8- orderBitSize);\n-    }\n-\n-#if EC_DEBUG\n-    mp_todecimal(&r_, mpstr);\n-    printf(\"r_: %s (dec)\\n\", mpstr);\n-    mp_todecimal(&s_, mpstr);\n-    printf(\"s_: %s (dec)\\n\", mpstr);\n-    mp_todecimal(&c, mpstr);\n-    printf(\"c : %s (dec)\\n\", mpstr);\n-    mp_todecimal(&u1, mpstr);\n-    printf(\"digest: %s (dec)\\n\", mpstr);\n-#endif\n-\n-    CHECK_MPI_OK( mp_mulmod(&u1, &c, &n, &u1) );  \/* u1 = u1 * c mod n *\/\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.2, Step 4\n-    **\n-    ** u2 = ((r') * c) mod n\n-    *\/\n-    CHECK_MPI_OK( mp_mulmod(&r_, &c, &n, &u2) );\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.3, Step 1\n-    **\n-    ** Compute u1*G + u2*Q\n-    ** Here, A = u1.G     B = u2.Q    and   C = A + B\n-    ** If the result, C, is the point at infinity, reject the signature\n-    *\/\n-    \/* verification does not support timing mitigation *\/\n-    if (ec_points_mul(ecParams, &u1, &u2, &key->publicValue, &pointC, kmflag, \/*timing*\/ 0)\n-        != SECSuccess) {\n-        rv = SECFailure;\n-        goto cleanup;\n-    }\n-    if (ec_point_at_infinity(&pointC)) {\n-        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);\n-        rv = SECFailure;\n-        goto cleanup;\n-    }\n-\n-    CHECK_MPI_OK( mp_read_unsigned_octets(&x1, pointC.data + 1, flen) );\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.4, Step 2\n-    **\n-    ** v = x1 mod n\n-    *\/\n-    CHECK_MPI_OK( mp_mod(&x1, &n, &v) );\n-\n-#if EC_DEBUG\n-    mp_todecimal(&r_, mpstr);\n-    printf(\"r_: %s (dec)\\n\", mpstr);\n-    mp_todecimal(&v, mpstr);\n-    printf(\"v : %s (dec)\\n\", mpstr);\n-#endif\n-\n-    \/*\n-    ** ANSI X9.62, Section 5.4.4, Step 3\n-    **\n-    ** Verification:  v == r'\n-    *\/\n-    if (mp_cmp(&v, &r_)) {\n-        PORT_SetError(SEC_ERROR_BAD_SIGNATURE);\n-        rv = SECFailure; \/* Signature failed to verify. *\/\n-    } else {\n-        rv = SECSuccess; \/* Signature verified. *\/\n-    }\n-\n-#if EC_DEBUG\n-    mp_todecimal(&u1, mpstr);\n-    printf(\"u1: %s (dec)\\n\", mpstr);\n-    mp_todecimal(&u2, mpstr);\n-    printf(\"u2: %s (dec)\\n\", mpstr);\n-    mp_tohex(&x1, mpstr);\n-    printf(\"x1: %s\\n\", mpstr);\n-    mp_todecimal(&v, mpstr);\n-    printf(\"v : %s (dec)\\n\", mpstr);\n-#endif\n-\n-cleanup:\n-    mp_clear(&r_);\n-    mp_clear(&s_);\n-    mp_clear(&c);\n-    mp_clear(&u1);\n-    mp_clear(&u2);\n-    mp_clear(&x1);\n-    mp_clear(&v);\n-    mp_clear(&n);\n-\n-    if (pointC.data) SECITEM_FreeItem(&pointC, PR_FALSE);\n-    if (err) {\n-        MP_TO_SEC_ERROR(err);\n-        rv = SECFailure;\n-    }\n-\n-#if EC_DEBUG\n-    printf(\"ECDSA verification %s\\n\",\n-        (rv == SECSuccess) ? \"succeeded\" : \"failed\");\n-#endif\n-\n-    return rv;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec.c","additions":0,"deletions":1091,"binary":false,"changes":1091,"status":"deleted"},{"patch":"@@ -1,52 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Elliptic Curve Cryptography library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#ifndef __ec_h_\n-#define __ec_h_\n-\n-#define EC_DEBUG                          0\n-#define EC_POINT_FORM_COMPRESSED_Y0    0x02\n-#define EC_POINT_FORM_COMPRESSED_Y1    0x03\n-#define EC_POINT_FORM_UNCOMPRESSED     0x04\n-#define EC_POINT_FORM_HYBRID_Y0        0x06\n-#define EC_POINT_FORM_HYBRID_Y1        0x07\n-\n-#define ANSI_X962_CURVE_OID_TOTAL_LEN    10\n-#define SECG_CURVE_OID_TOTAL_LEN          7\n-#define BRAINPOOL_CURVE_OID_TOTAL_LEN    11\n-\n-#endif \/* __ec_h_ *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec.h","additions":0,"deletions":52,"binary":false,"changes":52,"status":"deleted"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for binary polynomial field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#ifndef _EC2_H\n-#define _EC2_H\n-\n-#include \"ecl-priv.h\"\n-\n-\/* Checks if point P(px, py) is at infinity.  Uses affine coordinates. *\/\n-mp_err ec_GF2m_pt_is_inf_aff(const mp_int *px, const mp_int *py);\n-\n-\/* Sets P(px, py) to be the point at infinity.  Uses affine coordinates. *\/\n-mp_err ec_GF2m_pt_set_inf_aff(mp_int *px, mp_int *py);\n-\n-\/* Computes R = P + Q where R is (rx, ry), P is (px, py) and Q is (qx,\n- * qy). Uses affine coordinates. *\/\n-mp_err ec_GF2m_pt_add_aff(const mp_int *px, const mp_int *py,\n-                                                  const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                                  mp_int *ry, const ECGroup *group);\n-\n-\/* Computes R = P - Q.  Uses affine coordinates. *\/\n-mp_err ec_GF2m_pt_sub_aff(const mp_int *px, const mp_int *py,\n-                                                  const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                                  mp_int *ry, const ECGroup *group);\n-\n-\/* Computes R = 2P.  Uses affine coordinates. *\/\n-mp_err ec_GF2m_pt_dbl_aff(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                  mp_int *ry, const ECGroup *group);\n-\n-\/* Validates a point on a GF2m curve. *\/\n-mp_err ec_GF2m_validate_point(const mp_int *px, const mp_int *py, const ECGroup *group);\n-\n-\/* by default, this routine is unused and thus doesn't need to be compiled *\/\n-#ifdef ECL_ENABLE_GF2M_PT_MUL_AFF\n-\/* Computes R = nP where R is (rx, ry) and P is (px, py). The parameters\n- * a, b and p are the elliptic curve coefficients and the irreducible that\n- * determines the field GF2m.  Uses affine coordinates. *\/\n-mp_err ec_GF2m_pt_mul_aff(const mp_int *n, const mp_int *px,\n-                                                  const mp_int *py, mp_int *rx, mp_int *ry,\n-                                                  const ECGroup *group);\n-#endif\n-\n-\/* Computes R = nP where R is (rx, ry) and P is (px, py). The parameters\n- * a, b and p are the elliptic curve coefficients and the irreducible that\n- * determines the field GF2m.  Uses Montgomery projective coordinates. *\/\n-mp_err ec_GF2m_pt_mul_mont(const mp_int *n, const mp_int *px,\n-                                                   const mp_int *py, mp_int *rx, mp_int *ry,\n-                                                   const ECGroup *group, int timing);\n-\n-#ifdef ECL_ENABLE_GF2M_PROJ\n-\/* Converts a point P(px, py) from affine coordinates to projective\n- * coordinates R(rx, ry, rz). *\/\n-mp_err ec_GF2m_pt_aff2proj(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                   mp_int *ry, mp_int *rz, const ECGroup *group);\n-\n-\/* Converts a point P(px, py, pz) from projective coordinates to affine\n- * coordinates R(rx, ry). *\/\n-mp_err ec_GF2m_pt_proj2aff(const mp_int *px, const mp_int *py,\n-                                                   const mp_int *pz, mp_int *rx, mp_int *ry,\n-                                                   const ECGroup *group);\n-\n-\/* Checks if point P(px, py, pz) is at infinity.  Uses projective\n- * coordinates. *\/\n-mp_err ec_GF2m_pt_is_inf_proj(const mp_int *px, const mp_int *py,\n-                                                          const mp_int *pz);\n-\n-\/* Sets P(px, py, pz) to be the point at infinity.  Uses projective\n- * coordinates. *\/\n-mp_err ec_GF2m_pt_set_inf_proj(mp_int *px, mp_int *py, mp_int *pz);\n-\n-\/* Computes R = P + Q where R is (rx, ry, rz), P is (px, py, pz) and Q is\n- * (qx, qy, qz).  Uses projective coordinates. *\/\n-mp_err ec_GF2m_pt_add_proj(const mp_int *px, const mp_int *py,\n-                                                   const mp_int *pz, const mp_int *qx,\n-                                                   const mp_int *qy, mp_int *rx, mp_int *ry,\n-                                                   mp_int *rz, const ECGroup *group);\n-\n-\/* Computes R = 2P.  Uses projective coordinates. *\/\n-mp_err ec_GF2m_pt_dbl_proj(const mp_int *px, const mp_int *py,\n-                                                   const mp_int *pz, mp_int *rx, mp_int *ry,\n-                                                   mp_int *rz, const ECGroup *group);\n-\n-\/* Computes R = nP where R is (rx, ry) and P is (px, py). The parameters\n- * a, b and p are the elliptic curve coefficients and the prime that\n- * determines the field GF2m.  Uses projective coordinates. *\/\n-mp_err ec_GF2m_pt_mul_proj(const mp_int *n, const mp_int *px,\n-                                                   const mp_int *py, mp_int *rx, mp_int *ry,\n-                                                   const ECGroup *group);\n-#endif\n-\n-#endif \/* _EC2_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec2.h","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,260 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for binary polynomial field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang-Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <fungstep@hotmail.com>, and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-#include \"ec2.h\"\n-#include \"mp_gf2m.h\"\n-#include \"mp_gf2m-priv.h\"\n-#include \"mpi.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Fast reduction for polynomials over a 163-bit curve. Assumes reduction\n- * polynomial with terms {163, 7, 6, 3, 0}. *\/\n-mp_err\n-ec_GF2m_163_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit *u, z;\n-\n-        if (a != r) {\n-                MP_CHECKOK(mp_copy(a, r));\n-        }\n-#ifdef ECL_SIXTY_FOUR_BIT\n-        if (MP_USED(r) < 6) {\n-                MP_CHECKOK(s_mp_pad(r, 6));\n-        }\n-        u = MP_DIGITS(r);\n-        MP_USED(r) = 6;\n-\n-        \/* u[5] only has 6 significant bits *\/\n-        z = u[5];\n-        u[2] ^= (z << 36) ^ (z << 35) ^ (z << 32) ^ (z << 29);\n-        z = u[4];\n-        u[2] ^= (z >> 28) ^ (z >> 29) ^ (z >> 32) ^ (z >> 35);\n-        u[1] ^= (z << 36) ^ (z << 35) ^ (z << 32) ^ (z << 29);\n-        z = u[3];\n-        u[1] ^= (z >> 28) ^ (z >> 29) ^ (z >> 32) ^ (z >> 35);\n-        u[0] ^= (z << 36) ^ (z << 35) ^ (z << 32) ^ (z << 29);\n-        z = u[2] >> 35;                         \/* z only has 29 significant bits *\/\n-        u[0] ^= (z << 7) ^ (z << 6) ^ (z << 3) ^ z;\n-        \/* clear bits above 163 *\/\n-        u[5] = u[4] = u[3] = 0;\n-        u[2] ^= z << 35;\n-#else\n-        if (MP_USED(r) < 11) {\n-                MP_CHECKOK(s_mp_pad(r, 11));\n-        }\n-        u = MP_DIGITS(r);\n-        MP_USED(r) = 11;\n-\n-        \/* u[11] only has 6 significant bits *\/\n-        z = u[10];\n-        u[5] ^= (z << 4) ^ (z << 3) ^ z ^ (z >> 3);\n-        u[4] ^= (z << 29);\n-        z = u[9];\n-        u[5] ^= (z >> 28) ^ (z >> 29);\n-        u[4] ^= (z << 4) ^ (z << 3) ^ z ^ (z >> 3);\n-        u[3] ^= (z << 29);\n-        z = u[8];\n-        u[4] ^= (z >> 28) ^ (z >> 29);\n-        u[3] ^= (z << 4) ^ (z << 3) ^ z ^ (z >> 3);\n-        u[2] ^= (z << 29);\n-        z = u[7];\n-        u[3] ^= (z >> 28) ^ (z >> 29);\n-        u[2] ^= (z << 4) ^ (z << 3) ^ z ^ (z >> 3);\n-        u[1] ^= (z << 29);\n-        z = u[6];\n-        u[2] ^= (z >> 28) ^ (z >> 29);\n-        u[1] ^= (z << 4) ^ (z << 3) ^ z ^ (z >> 3);\n-        u[0] ^= (z << 29);\n-        z = u[5] >> 3;                          \/* z only has 29 significant bits *\/\n-        u[1] ^= (z >> 25) ^ (z >> 26);\n-        u[0] ^= (z << 7) ^ (z << 6) ^ (z << 3) ^ z;\n-        \/* clear bits above 163 *\/\n-        u[11] = u[10] = u[9] = u[8] = u[7] = u[6] = 0;\n-        u[5] ^= z << 3;\n-#endif\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Fast squaring for polynomials over a 163-bit curve. Assumes reduction\n- * polynomial with terms {163, 7, 6, 3, 0}. *\/\n-mp_err\n-ec_GF2m_163_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit *u, *v;\n-\n-        v = MP_DIGITS(a);\n-\n-#ifdef ECL_SIXTY_FOUR_BIT\n-        if (MP_USED(a) < 3) {\n-                return mp_bsqrmod(a, meth->irr_arr, r);\n-        }\n-        if (MP_USED(r) < 6) {\n-                MP_CHECKOK(s_mp_pad(r, 6));\n-        }\n-        MP_USED(r) = 6;\n-#else\n-        if (MP_USED(a) < 6) {\n-                return mp_bsqrmod(a, meth->irr_arr, r);\n-        }\n-        if (MP_USED(r) < 12) {\n-                MP_CHECKOK(s_mp_pad(r, 12));\n-        }\n-        MP_USED(r) = 12;\n-#endif\n-        u = MP_DIGITS(r);\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        u[11] = gf2m_SQR1(v[5]);\n-        u[10] = gf2m_SQR0(v[5]);\n-        u[9] = gf2m_SQR1(v[4]);\n-        u[8] = gf2m_SQR0(v[4]);\n-        u[7] = gf2m_SQR1(v[3]);\n-        u[6] = gf2m_SQR0(v[3]);\n-#endif\n-        u[5] = gf2m_SQR1(v[2]);\n-        u[4] = gf2m_SQR0(v[2]);\n-        u[3] = gf2m_SQR1(v[1]);\n-        u[2] = gf2m_SQR0(v[1]);\n-        u[1] = gf2m_SQR1(v[0]);\n-        u[0] = gf2m_SQR0(v[0]);\n-        return ec_GF2m_163_mod(r, r, meth);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Fast multiplication for polynomials over a 163-bit curve. Assumes\n- * reduction polynomial with terms {163, 7, 6, 3, 0}. *\/\n-mp_err\n-ec_GF2m_163_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a2 = 0, a1 = 0, a0, b2 = 0, b1 = 0, b0;\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit a5 = 0, a4 = 0, a3 = 0, b5 = 0, b4 = 0, b3 = 0;\n-        mp_digit rm[6];\n-#endif\n-\n-        if (a == b) {\n-                return ec_GF2m_163_sqr(a, r, meth);\n-        } else {\n-                switch (MP_USED(a)) {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                case 6:\n-                        a5 = MP_DIGIT(a, 5);\n-                case 5:\n-                        a4 = MP_DIGIT(a, 4);\n-                case 4:\n-                        a3 = MP_DIGIT(a, 3);\n-#endif\n-                case 3:\n-                        a2 = MP_DIGIT(a, 2);\n-                case 2:\n-                        a1 = MP_DIGIT(a, 1);\n-                default:\n-                        a0 = MP_DIGIT(a, 0);\n-                }\n-                switch (MP_USED(b)) {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                case 6:\n-                        b5 = MP_DIGIT(b, 5);\n-                case 5:\n-                        b4 = MP_DIGIT(b, 4);\n-                case 4:\n-                        b3 = MP_DIGIT(b, 3);\n-#endif\n-                case 3:\n-                        b2 = MP_DIGIT(b, 2);\n-                case 2:\n-                        b1 = MP_DIGIT(b, 1);\n-                default:\n-                        b0 = MP_DIGIT(b, 0);\n-                }\n-#ifdef ECL_SIXTY_FOUR_BIT\n-                MP_CHECKOK(s_mp_pad(r, 6));\n-                s_bmul_3x3(MP_DIGITS(r), a2, a1, a0, b2, b1, b0);\n-                MP_USED(r) = 6;\n-                s_mp_clamp(r);\n-#else\n-                MP_CHECKOK(s_mp_pad(r, 12));\n-                s_bmul_3x3(MP_DIGITS(r) + 6, a5, a4, a3, b5, b4, b3);\n-                s_bmul_3x3(MP_DIGITS(r), a2, a1, a0, b2, b1, b0);\n-                s_bmul_3x3(rm, a5 ^ a2, a4 ^ a1, a3 ^ a0, b5 ^ b2, b4 ^ b1,\n-                                   b3 ^ b0);\n-                rm[5] ^= MP_DIGIT(r, 5) ^ MP_DIGIT(r, 11);\n-                rm[4] ^= MP_DIGIT(r, 4) ^ MP_DIGIT(r, 10);\n-                rm[3] ^= MP_DIGIT(r, 3) ^ MP_DIGIT(r, 9);\n-                rm[2] ^= MP_DIGIT(r, 2) ^ MP_DIGIT(r, 8);\n-                rm[1] ^= MP_DIGIT(r, 1) ^ MP_DIGIT(r, 7);\n-                rm[0] ^= MP_DIGIT(r, 0) ^ MP_DIGIT(r, 6);\n-                MP_DIGIT(r, 8) ^= rm[5];\n-                MP_DIGIT(r, 7) ^= rm[4];\n-                MP_DIGIT(r, 6) ^= rm[3];\n-                MP_DIGIT(r, 5) ^= rm[2];\n-                MP_DIGIT(r, 4) ^= rm[1];\n-                MP_DIGIT(r, 3) ^= rm[0];\n-                MP_USED(r) = 12;\n-                s_mp_clamp(r);\n-#endif\n-                return ec_GF2m_163_mod(r, r, meth);\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Wire in fast field arithmetic for 163-bit curves. *\/\n-mp_err\n-ec_group_set_gf2m163(ECGroup *group, ECCurveName name)\n-{\n-        group->meth->field_mod = &ec_GF2m_163_mod;\n-        group->meth->field_mul = &ec_GF2m_163_mul;\n-        group->meth->field_sqr = &ec_GF2m_163_sqr;\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec2_163.c","additions":0,"deletions":260,"binary":false,"changes":260,"status":"deleted"},{"patch":"@@ -1,277 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for binary polynomial field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang-Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <fungstep@hotmail.com>, and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-#include \"ec2.h\"\n-#include \"mp_gf2m.h\"\n-#include \"mp_gf2m-priv.h\"\n-#include \"mpi.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Fast reduction for polynomials over a 193-bit curve. Assumes reduction\n- * polynomial with terms {193, 15, 0}. *\/\n-mp_err\n-ec_GF2m_193_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit *u, z;\n-\n-        if (a != r) {\n-                MP_CHECKOK(mp_copy(a, r));\n-        }\n-#ifdef ECL_SIXTY_FOUR_BIT\n-        if (MP_USED(r) < 7) {\n-                MP_CHECKOK(s_mp_pad(r, 7));\n-        }\n-        u = MP_DIGITS(r);\n-        MP_USED(r) = 7;\n-\n-        \/* u[6] only has 2 significant bits *\/\n-        z = u[6];\n-        u[3] ^= (z << 14) ^ (z >> 1);\n-        u[2] ^= (z << 63);\n-        z = u[5];\n-        u[3] ^= (z >> 50);\n-        u[2] ^= (z << 14) ^ (z >> 1);\n-        u[1] ^= (z << 63);\n-        z = u[4];\n-        u[2] ^= (z >> 50);\n-        u[1] ^= (z << 14) ^ (z >> 1);\n-        u[0] ^= (z << 63);\n-        z = u[3] >> 1;                          \/* z only has 63 significant bits *\/\n-        u[1] ^= (z >> 49);\n-        u[0] ^= (z << 15) ^ z;\n-        \/* clear bits above 193 *\/\n-        u[6] = u[5] = u[4] = 0;\n-        u[3] ^= z << 1;\n-#else\n-        if (MP_USED(r) < 13) {\n-                MP_CHECKOK(s_mp_pad(r, 13));\n-        }\n-        u = MP_DIGITS(r);\n-        MP_USED(r) = 13;\n-\n-        \/* u[12] only has 2 significant bits *\/\n-        z = u[12];\n-        u[6] ^= (z << 14) ^ (z >> 1);\n-        u[5] ^= (z << 31);\n-        z = u[11];\n-        u[6] ^= (z >> 18);\n-        u[5] ^= (z << 14) ^ (z >> 1);\n-        u[4] ^= (z << 31);\n-        z = u[10];\n-        u[5] ^= (z >> 18);\n-        u[4] ^= (z << 14) ^ (z >> 1);\n-        u[3] ^= (z << 31);\n-        z = u[9];\n-        u[4] ^= (z >> 18);\n-        u[3] ^= (z << 14) ^ (z >> 1);\n-        u[2] ^= (z << 31);\n-        z = u[8];\n-        u[3] ^= (z >> 18);\n-        u[2] ^= (z << 14) ^ (z >> 1);\n-        u[1] ^= (z << 31);\n-        z = u[7];\n-        u[2] ^= (z >> 18);\n-        u[1] ^= (z << 14) ^ (z >> 1);\n-        u[0] ^= (z << 31);\n-        z = u[6] >> 1;                          \/* z only has 31 significant bits *\/\n-        u[1] ^= (z >> 17);\n-        u[0] ^= (z << 15) ^ z;\n-        \/* clear bits above 193 *\/\n-        u[12] = u[11] = u[10] = u[9] = u[8] = u[7] = 0;\n-        u[6] ^= z << 1;\n-#endif\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Fast squaring for polynomials over a 193-bit curve. Assumes reduction\n- * polynomial with terms {193, 15, 0}. *\/\n-mp_err\n-ec_GF2m_193_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit *u, *v;\n-\n-        v = MP_DIGITS(a);\n-\n-#ifdef ECL_SIXTY_FOUR_BIT\n-        if (MP_USED(a) < 4) {\n-                return mp_bsqrmod(a, meth->irr_arr, r);\n-        }\n-        if (MP_USED(r) < 7) {\n-                MP_CHECKOK(s_mp_pad(r, 7));\n-        }\n-        MP_USED(r) = 7;\n-#else\n-        if (MP_USED(a) < 7) {\n-                return mp_bsqrmod(a, meth->irr_arr, r);\n-        }\n-        if (MP_USED(r) < 13) {\n-                MP_CHECKOK(s_mp_pad(r, 13));\n-        }\n-        MP_USED(r) = 13;\n-#endif\n-        u = MP_DIGITS(r);\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        u[12] = gf2m_SQR0(v[6]);\n-        u[11] = gf2m_SQR1(v[5]);\n-        u[10] = gf2m_SQR0(v[5]);\n-        u[9] = gf2m_SQR1(v[4]);\n-        u[8] = gf2m_SQR0(v[4]);\n-        u[7] = gf2m_SQR1(v[3]);\n-#endif\n-        u[6] = gf2m_SQR0(v[3]);\n-        u[5] = gf2m_SQR1(v[2]);\n-        u[4] = gf2m_SQR0(v[2]);\n-        u[3] = gf2m_SQR1(v[1]);\n-        u[2] = gf2m_SQR0(v[1]);\n-        u[1] = gf2m_SQR1(v[0]);\n-        u[0] = gf2m_SQR0(v[0]);\n-        return ec_GF2m_193_mod(r, r, meth);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Fast multiplication for polynomials over a 193-bit curve. Assumes\n- * reduction polynomial with terms {193, 15, 0}. *\/\n-mp_err\n-ec_GF2m_193_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a3 = 0, a2 = 0, a1 = 0, a0, b3 = 0, b2 = 0, b1 = 0, b0;\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit a6 = 0, a5 = 0, a4 = 0, b6 = 0, b5 = 0, b4 = 0;\n-        mp_digit rm[8];\n-#endif\n-\n-        if (a == b) {\n-                return ec_GF2m_193_sqr(a, r, meth);\n-        } else {\n-                switch (MP_USED(a)) {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                case 7:\n-                        a6 = MP_DIGIT(a, 6);\n-                case 6:\n-                        a5 = MP_DIGIT(a, 5);\n-                case 5:\n-                        a4 = MP_DIGIT(a, 4);\n-#endif\n-                case 4:\n-                        a3 = MP_DIGIT(a, 3);\n-                case 3:\n-                        a2 = MP_DIGIT(a, 2);\n-                case 2:\n-                        a1 = MP_DIGIT(a, 1);\n-                default:\n-                        a0 = MP_DIGIT(a, 0);\n-                }\n-                switch (MP_USED(b)) {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                case 7:\n-                        b6 = MP_DIGIT(b, 6);\n-                case 6:\n-                        b5 = MP_DIGIT(b, 5);\n-                case 5:\n-                        b4 = MP_DIGIT(b, 4);\n-#endif\n-                case 4:\n-                        b3 = MP_DIGIT(b, 3);\n-                case 3:\n-                        b2 = MP_DIGIT(b, 2);\n-                case 2:\n-                        b1 = MP_DIGIT(b, 1);\n-                default:\n-                        b0 = MP_DIGIT(b, 0);\n-                }\n-#ifdef ECL_SIXTY_FOUR_BIT\n-                MP_CHECKOK(s_mp_pad(r, 8));\n-                s_bmul_4x4(MP_DIGITS(r), a3, a2, a1, a0, b3, b2, b1, b0);\n-                MP_USED(r) = 8;\n-                s_mp_clamp(r);\n-#else\n-                MP_CHECKOK(s_mp_pad(r, 14));\n-                s_bmul_3x3(MP_DIGITS(r) + 8, a6, a5, a4, b6, b5, b4);\n-                s_bmul_4x4(MP_DIGITS(r), a3, a2, a1, a0, b3, b2, b1, b0);\n-                s_bmul_4x4(rm, a3, a6 ^ a2, a5 ^ a1, a4 ^ a0, b3, b6 ^ b2, b5 ^ b1,\n-                                   b4 ^ b0);\n-                rm[7] ^= MP_DIGIT(r, 7);\n-                rm[6] ^= MP_DIGIT(r, 6);\n-                rm[5] ^= MP_DIGIT(r, 5) ^ MP_DIGIT(r, 13);\n-                rm[4] ^= MP_DIGIT(r, 4) ^ MP_DIGIT(r, 12);\n-                rm[3] ^= MP_DIGIT(r, 3) ^ MP_DIGIT(r, 11);\n-                rm[2] ^= MP_DIGIT(r, 2) ^ MP_DIGIT(r, 10);\n-                rm[1] ^= MP_DIGIT(r, 1) ^ MP_DIGIT(r, 9);\n-                rm[0] ^= MP_DIGIT(r, 0) ^ MP_DIGIT(r, 8);\n-                MP_DIGIT(r, 11) ^= rm[7];\n-                MP_DIGIT(r, 10) ^= rm[6];\n-                MP_DIGIT(r, 9) ^= rm[5];\n-                MP_DIGIT(r, 8) ^= rm[4];\n-                MP_DIGIT(r, 7) ^= rm[3];\n-                MP_DIGIT(r, 6) ^= rm[2];\n-                MP_DIGIT(r, 5) ^= rm[1];\n-                MP_DIGIT(r, 4) ^= rm[0];\n-                MP_USED(r) = 14;\n-                s_mp_clamp(r);\n-#endif\n-                return ec_GF2m_193_mod(r, r, meth);\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Wire in fast field arithmetic for 193-bit curves. *\/\n-mp_err\n-ec_group_set_gf2m193(ECGroup *group, ECCurveName name)\n-{\n-        group->meth->field_mod = &ec_GF2m_193_mod;\n-        group->meth->field_mul = &ec_GF2m_193_mul;\n-        group->meth->field_sqr = &ec_GF2m_193_sqr;\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec2_193.c","additions":0,"deletions":277,"binary":false,"changes":277,"status":"deleted"},{"patch":"@@ -1,300 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for binary polynomial field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang-Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <fungstep@hotmail.com>, and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-#include \"ec2.h\"\n-#include \"mp_gf2m.h\"\n-#include \"mp_gf2m-priv.h\"\n-#include \"mpi.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Fast reduction for polynomials over a 233-bit curve. Assumes reduction\n- * polynomial with terms {233, 74, 0}. *\/\n-mp_err\n-ec_GF2m_233_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit *u, z;\n-\n-        if (a != r) {\n-                MP_CHECKOK(mp_copy(a, r));\n-        }\n-#ifdef ECL_SIXTY_FOUR_BIT\n-        if (MP_USED(r) < 8) {\n-                MP_CHECKOK(s_mp_pad(r, 8));\n-        }\n-        u = MP_DIGITS(r);\n-        MP_USED(r) = 8;\n-\n-        \/* u[7] only has 18 significant bits *\/\n-        z = u[7];\n-        u[4] ^= (z << 33) ^ (z >> 41);\n-        u[3] ^= (z << 23);\n-        z = u[6];\n-        u[4] ^= (z >> 31);\n-        u[3] ^= (z << 33) ^ (z >> 41);\n-        u[2] ^= (z << 23);\n-        z = u[5];\n-        u[3] ^= (z >> 31);\n-        u[2] ^= (z << 33) ^ (z >> 41);\n-        u[1] ^= (z << 23);\n-        z = u[4];\n-        u[2] ^= (z >> 31);\n-        u[1] ^= (z << 33) ^ (z >> 41);\n-        u[0] ^= (z << 23);\n-        z = u[3] >> 41;                         \/* z only has 23 significant bits *\/\n-        u[1] ^= (z << 10);\n-        u[0] ^= z;\n-        \/* clear bits above 233 *\/\n-        u[7] = u[6] = u[5] = u[4] = 0;\n-        u[3] ^= z << 41;\n-#else\n-        if (MP_USED(r) < 15) {\n-                MP_CHECKOK(s_mp_pad(r, 15));\n-        }\n-        u = MP_DIGITS(r);\n-        MP_USED(r) = 15;\n-\n-        \/* u[14] only has 18 significant bits *\/\n-        z = u[14];\n-        u[9] ^= (z << 1);\n-        u[7] ^= (z >> 9);\n-        u[6] ^= (z << 23);\n-        z = u[13];\n-        u[9] ^= (z >> 31);\n-        u[8] ^= (z << 1);\n-        u[6] ^= (z >> 9);\n-        u[5] ^= (z << 23);\n-        z = u[12];\n-        u[8] ^= (z >> 31);\n-        u[7] ^= (z << 1);\n-        u[5] ^= (z >> 9);\n-        u[4] ^= (z << 23);\n-        z = u[11];\n-        u[7] ^= (z >> 31);\n-        u[6] ^= (z << 1);\n-        u[4] ^= (z >> 9);\n-        u[3] ^= (z << 23);\n-        z = u[10];\n-        u[6] ^= (z >> 31);\n-        u[5] ^= (z << 1);\n-        u[3] ^= (z >> 9);\n-        u[2] ^= (z << 23);\n-        z = u[9];\n-        u[5] ^= (z >> 31);\n-        u[4] ^= (z << 1);\n-        u[2] ^= (z >> 9);\n-        u[1] ^= (z << 23);\n-        z = u[8];\n-        u[4] ^= (z >> 31);\n-        u[3] ^= (z << 1);\n-        u[1] ^= (z >> 9);\n-        u[0] ^= (z << 23);\n-        z = u[7] >> 9;                          \/* z only has 23 significant bits *\/\n-        u[3] ^= (z >> 22);\n-        u[2] ^= (z << 10);\n-        u[0] ^= z;\n-        \/* clear bits above 233 *\/\n-        u[14] = u[13] = u[12] = u[11] = u[10] = u[9] = u[8] = 0;\n-        u[7] ^= z << 9;\n-#endif\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Fast squaring for polynomials over a 233-bit curve. Assumes reduction\n- * polynomial with terms {233, 74, 0}. *\/\n-mp_err\n-ec_GF2m_233_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit *u, *v;\n-\n-        v = MP_DIGITS(a);\n-\n-#ifdef ECL_SIXTY_FOUR_BIT\n-        if (MP_USED(a) < 4) {\n-                return mp_bsqrmod(a, meth->irr_arr, r);\n-        }\n-        if (MP_USED(r) < 8) {\n-                MP_CHECKOK(s_mp_pad(r, 8));\n-        }\n-        MP_USED(r) = 8;\n-#else\n-        if (MP_USED(a) < 8) {\n-                return mp_bsqrmod(a, meth->irr_arr, r);\n-        }\n-        if (MP_USED(r) < 15) {\n-                MP_CHECKOK(s_mp_pad(r, 15));\n-        }\n-        MP_USED(r) = 15;\n-#endif\n-        u = MP_DIGITS(r);\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        u[14] = gf2m_SQR0(v[7]);\n-        u[13] = gf2m_SQR1(v[6]);\n-        u[12] = gf2m_SQR0(v[6]);\n-        u[11] = gf2m_SQR1(v[5]);\n-        u[10] = gf2m_SQR0(v[5]);\n-        u[9] = gf2m_SQR1(v[4]);\n-        u[8] = gf2m_SQR0(v[4]);\n-#endif\n-        u[7] = gf2m_SQR1(v[3]);\n-        u[6] = gf2m_SQR0(v[3]);\n-        u[5] = gf2m_SQR1(v[2]);\n-        u[4] = gf2m_SQR0(v[2]);\n-        u[3] = gf2m_SQR1(v[1]);\n-        u[2] = gf2m_SQR0(v[1]);\n-        u[1] = gf2m_SQR1(v[0]);\n-        u[0] = gf2m_SQR0(v[0]);\n-        return ec_GF2m_233_mod(r, r, meth);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Fast multiplication for polynomials over a 233-bit curve. Assumes\n- * reduction polynomial with terms {233, 74, 0}. *\/\n-mp_err\n-ec_GF2m_233_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a3 = 0, a2 = 0, a1 = 0, a0, b3 = 0, b2 = 0, b1 = 0, b0;\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit a7 = 0, a6 = 0, a5 = 0, a4 = 0, b7 = 0, b6 = 0, b5 = 0, b4 =\n-                0;\n-        mp_digit rm[8];\n-#endif\n-\n-        if (a == b) {\n-                return ec_GF2m_233_sqr(a, r, meth);\n-        } else {\n-                switch (MP_USED(a)) {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                case 8:\n-                        a7 = MP_DIGIT(a, 7);\n-                case 7:\n-                        a6 = MP_DIGIT(a, 6);\n-                case 6:\n-                        a5 = MP_DIGIT(a, 5);\n-                case 5:\n-                        a4 = MP_DIGIT(a, 4);\n-#endif\n-                case 4:\n-                        a3 = MP_DIGIT(a, 3);\n-                case 3:\n-                        a2 = MP_DIGIT(a, 2);\n-                case 2:\n-                        a1 = MP_DIGIT(a, 1);\n-                default:\n-                        a0 = MP_DIGIT(a, 0);\n-                }\n-                switch (MP_USED(b)) {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                case 8:\n-                        b7 = MP_DIGIT(b, 7);\n-                case 7:\n-                        b6 = MP_DIGIT(b, 6);\n-                case 6:\n-                        b5 = MP_DIGIT(b, 5);\n-                case 5:\n-                        b4 = MP_DIGIT(b, 4);\n-#endif\n-                case 4:\n-                        b3 = MP_DIGIT(b, 3);\n-                case 3:\n-                        b2 = MP_DIGIT(b, 2);\n-                case 2:\n-                        b1 = MP_DIGIT(b, 1);\n-                default:\n-                        b0 = MP_DIGIT(b, 0);\n-                }\n-#ifdef ECL_SIXTY_FOUR_BIT\n-                MP_CHECKOK(s_mp_pad(r, 8));\n-                s_bmul_4x4(MP_DIGITS(r), a3, a2, a1, a0, b3, b2, b1, b0);\n-                MP_USED(r) = 8;\n-                s_mp_clamp(r);\n-#else\n-                MP_CHECKOK(s_mp_pad(r, 16));\n-                s_bmul_4x4(MP_DIGITS(r) + 8, a7, a6, a5, a4, b7, b6, b5, b4);\n-                s_bmul_4x4(MP_DIGITS(r), a3, a2, a1, a0, b3, b2, b1, b0);\n-                s_bmul_4x4(rm, a7 ^ a3, a6 ^ a2, a5 ^ a1, a4 ^ a0, b7 ^ b3,\n-                                   b6 ^ b2, b5 ^ b1, b4 ^ b0);\n-                rm[7] ^= MP_DIGIT(r, 7) ^ MP_DIGIT(r, 15);\n-                rm[6] ^= MP_DIGIT(r, 6) ^ MP_DIGIT(r, 14);\n-                rm[5] ^= MP_DIGIT(r, 5) ^ MP_DIGIT(r, 13);\n-                rm[4] ^= MP_DIGIT(r, 4) ^ MP_DIGIT(r, 12);\n-                rm[3] ^= MP_DIGIT(r, 3) ^ MP_DIGIT(r, 11);\n-                rm[2] ^= MP_DIGIT(r, 2) ^ MP_DIGIT(r, 10);\n-                rm[1] ^= MP_DIGIT(r, 1) ^ MP_DIGIT(r, 9);\n-                rm[0] ^= MP_DIGIT(r, 0) ^ MP_DIGIT(r, 8);\n-                MP_DIGIT(r, 11) ^= rm[7];\n-                MP_DIGIT(r, 10) ^= rm[6];\n-                MP_DIGIT(r, 9) ^= rm[5];\n-                MP_DIGIT(r, 8) ^= rm[4];\n-                MP_DIGIT(r, 7) ^= rm[3];\n-                MP_DIGIT(r, 6) ^= rm[2];\n-                MP_DIGIT(r, 5) ^= rm[1];\n-                MP_DIGIT(r, 4) ^= rm[0];\n-                MP_USED(r) = 16;\n-                s_mp_clamp(r);\n-#endif\n-                return ec_GF2m_233_mod(r, r, meth);\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Wire in fast field arithmetic for 233-bit curves. *\/\n-mp_err\n-ec_group_set_gf2m233(ECGroup *group, ECCurveName name)\n-{\n-        group->meth->field_mod = &ec_GF2m_233_mod;\n-        group->meth->field_mul = &ec_GF2m_233_mul;\n-        group->meth->field_sqr = &ec_GF2m_233_sqr;\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec2_233.c","additions":0,"deletions":300,"binary":false,"changes":300,"status":"deleted"},{"patch":"@@ -1,349 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for binary polynomial field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"ec2.h\"\n-#include \"mplogic.h\"\n-#include \"mp_gf2m.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Checks if point P(px, py) is at infinity.  Uses affine coordinates. *\/\n-mp_err\n-ec_GF2m_pt_is_inf_aff(const mp_int *px, const mp_int *py)\n-{\n-\n-        if ((mp_cmp_z(px) == 0) && (mp_cmp_z(py) == 0)) {\n-                return MP_YES;\n-        } else {\n-                return MP_NO;\n-        }\n-\n-}\n-\n-\/* Sets P(px, py) to be the point at infinity.  Uses affine coordinates. *\/\n-mp_err\n-ec_GF2m_pt_set_inf_aff(mp_int *px, mp_int *py)\n-{\n-        mp_zero(px);\n-        mp_zero(py);\n-        return MP_OKAY;\n-}\n-\n-\/* Computes R = P + Q based on IEEE P1363 A.10.2. Elliptic curve points P,\n- * Q, and R can all be identical. Uses affine coordinates. *\/\n-mp_err\n-ec_GF2m_pt_add_aff(const mp_int *px, const mp_int *py, const mp_int *qx,\n-                                   const mp_int *qy, mp_int *rx, mp_int *ry,\n-                                   const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int lambda, tempx, tempy;\n-\n-        MP_DIGITS(&lambda) = 0;\n-        MP_DIGITS(&tempx) = 0;\n-        MP_DIGITS(&tempy) = 0;\n-        MP_CHECKOK(mp_init(&lambda, FLAG(px)));\n-        MP_CHECKOK(mp_init(&tempx, FLAG(px)));\n-        MP_CHECKOK(mp_init(&tempy, FLAG(px)));\n-        \/* if P = inf, then R = Q *\/\n-        if (ec_GF2m_pt_is_inf_aff(px, py) == 0) {\n-                MP_CHECKOK(mp_copy(qx, rx));\n-                MP_CHECKOK(mp_copy(qy, ry));\n-                res = MP_OKAY;\n-                goto CLEANUP;\n-        }\n-        \/* if Q = inf, then R = P *\/\n-        if (ec_GF2m_pt_is_inf_aff(qx, qy) == 0) {\n-                MP_CHECKOK(mp_copy(px, rx));\n-                MP_CHECKOK(mp_copy(py, ry));\n-                res = MP_OKAY;\n-                goto CLEANUP;\n-        }\n-        \/* if px != qx, then lambda = (py+qy) \/ (px+qx), tempx = a + lambda^2\n-         * + lambda + px + qx *\/\n-        if (mp_cmp(px, qx) != 0) {\n-                MP_CHECKOK(group->meth->field_add(py, qy, &tempy, group->meth));\n-                MP_CHECKOK(group->meth->field_add(px, qx, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_div(&tempy, &tempx, &lambda, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(&lambda, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, &lambda, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, &group->curvea, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, px, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, qx, &tempx, group->meth));\n-        } else {\n-                \/* if py != qy or qx = 0, then R = inf *\/\n-                if (((mp_cmp(py, qy) != 0)) || (mp_cmp_z(qx) == 0)) {\n-                        mp_zero(rx);\n-                        mp_zero(ry);\n-                        res = MP_OKAY;\n-                        goto CLEANUP;\n-                }\n-                \/* lambda = qx + qy \/ qx *\/\n-                MP_CHECKOK(group->meth->field_div(qy, qx, &lambda, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&lambda, qx, &lambda, group->meth));\n-                \/* tempx = a + lambda^2 + lambda *\/\n-                MP_CHECKOK(group->meth->field_sqr(&lambda, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, &lambda, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, &group->curvea, &tempx, group->meth));\n-        }\n-        \/* ry = (qx + tempx) * lambda + tempx + qy *\/\n-        MP_CHECKOK(group->meth->field_add(qx, &tempx, &tempy, group->meth));\n-        MP_CHECKOK(group->meth->\n-                           field_mul(&tempy, &lambda, &tempy, group->meth));\n-        MP_CHECKOK(group->meth->\n-                           field_add(&tempy, &tempx, &tempy, group->meth));\n-        MP_CHECKOK(group->meth->field_add(&tempy, qy, ry, group->meth));\n-        \/* rx = tempx *\/\n-        MP_CHECKOK(mp_copy(&tempx, rx));\n-\n-  CLEANUP:\n-        mp_clear(&lambda);\n-        mp_clear(&tempx);\n-        mp_clear(&tempy);\n-        return res;\n-}\n-\n-\/* Computes R = P - Q. Elliptic curve points P, Q, and R can all be\n- * identical. Uses affine coordinates. *\/\n-mp_err\n-ec_GF2m_pt_sub_aff(const mp_int *px, const mp_int *py, const mp_int *qx,\n-                                   const mp_int *qy, mp_int *rx, mp_int *ry,\n-                                   const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int nqy;\n-\n-        MP_DIGITS(&nqy) = 0;\n-        MP_CHECKOK(mp_init(&nqy, FLAG(px)));\n-        \/* nqy = qx+qy *\/\n-        MP_CHECKOK(group->meth->field_add(qx, qy, &nqy, group->meth));\n-        MP_CHECKOK(group->point_add(px, py, qx, &nqy, rx, ry, group));\n-  CLEANUP:\n-        mp_clear(&nqy);\n-        return res;\n-}\n-\n-\/* Computes R = 2P. Elliptic curve points P and R can be identical. Uses\n- * affine coordinates. *\/\n-mp_err\n-ec_GF2m_pt_dbl_aff(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                   mp_int *ry, const ECGroup *group)\n-{\n-        return group->point_add(px, py, px, py, rx, ry, group);\n-}\n-\n-\/* by default, this routine is unused and thus doesn't need to be compiled *\/\n-#ifdef ECL_ENABLE_GF2M_PT_MUL_AFF\n-\/* Computes R = nP based on IEEE P1363 A.10.3. Elliptic curve points P and\n- * R can be identical. Uses affine coordinates. *\/\n-mp_err\n-ec_GF2m_pt_mul_aff(const mp_int *n, const mp_int *px, const mp_int *py,\n-                                   mp_int *rx, mp_int *ry, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int k, k3, qx, qy, sx, sy;\n-        int b1, b3, i, l;\n-\n-        MP_DIGITS(&k) = 0;\n-        MP_DIGITS(&k3) = 0;\n-        MP_DIGITS(&qx) = 0;\n-        MP_DIGITS(&qy) = 0;\n-        MP_DIGITS(&sx) = 0;\n-        MP_DIGITS(&sy) = 0;\n-        MP_CHECKOK(mp_init(&k));\n-        MP_CHECKOK(mp_init(&k3));\n-        MP_CHECKOK(mp_init(&qx));\n-        MP_CHECKOK(mp_init(&qy));\n-        MP_CHECKOK(mp_init(&sx));\n-        MP_CHECKOK(mp_init(&sy));\n-\n-        \/* if n = 0 then r = inf *\/\n-        if (mp_cmp_z(n) == 0) {\n-                mp_zero(rx);\n-                mp_zero(ry);\n-                res = MP_OKAY;\n-                goto CLEANUP;\n-        }\n-        \/* Q = P, k = n *\/\n-        MP_CHECKOK(mp_copy(px, &qx));\n-        MP_CHECKOK(mp_copy(py, &qy));\n-        MP_CHECKOK(mp_copy(n, &k));\n-        \/* if n < 0 then Q = -Q, k = -k *\/\n-        if (mp_cmp_z(n) < 0) {\n-                MP_CHECKOK(group->meth->field_add(&qx, &qy, &qy, group->meth));\n-                MP_CHECKOK(mp_neg(&k, &k));\n-        }\n-#ifdef ECL_DEBUG                                \/* basic double and add method *\/\n-        l = mpl_significant_bits(&k) - 1;\n-        MP_CHECKOK(mp_copy(&qx, &sx));\n-        MP_CHECKOK(mp_copy(&qy, &sy));\n-        for (i = l - 1; i >= 0; i--) {\n-                \/* S = 2S *\/\n-                MP_CHECKOK(group->point_dbl(&sx, &sy, &sx, &sy, group));\n-                \/* if k_i = 1, then S = S + Q *\/\n-                if (mpl_get_bit(&k, i) != 0) {\n-                        MP_CHECKOK(group->\n-                                           point_add(&sx, &sy, &qx, &qy, &sx, &sy, group));\n-                }\n-        }\n-#else                                                   \/* double and add\/subtract method from\n-                                                                 * standard *\/\n-        \/* k3 = 3 * k *\/\n-        MP_CHECKOK(mp_set_int(&k3, 3));\n-        MP_CHECKOK(mp_mul(&k, &k3, &k3));\n-        \/* S = Q *\/\n-        MP_CHECKOK(mp_copy(&qx, &sx));\n-        MP_CHECKOK(mp_copy(&qy, &sy));\n-        \/* l = index of high order bit in binary representation of 3*k *\/\n-        l = mpl_significant_bits(&k3) - 1;\n-        \/* for i = l-1 downto 1 *\/\n-        for (i = l - 1; i >= 1; i--) {\n-                \/* S = 2S *\/\n-                MP_CHECKOK(group->point_dbl(&sx, &sy, &sx, &sy, group));\n-                b3 = MP_GET_BIT(&k3, i);\n-                b1 = MP_GET_BIT(&k, i);\n-                \/* if k3_i = 1 and k_i = 0, then S = S + Q *\/\n-                if ((b3 == 1) && (b1 == 0)) {\n-                        MP_CHECKOK(group->\n-                                           point_add(&sx, &sy, &qx, &qy, &sx, &sy, group));\n-                        \/* if k3_i = 0 and k_i = 1, then S = S - Q *\/\n-                } else if ((b3 == 0) && (b1 == 1)) {\n-                        MP_CHECKOK(group->\n-                                           point_sub(&sx, &sy, &qx, &qy, &sx, &sy, group));\n-                }\n-        }\n-#endif\n-        \/* output S *\/\n-        MP_CHECKOK(mp_copy(&sx, rx));\n-        MP_CHECKOK(mp_copy(&sy, ry));\n-\n-  CLEANUP:\n-        mp_clear(&k);\n-        mp_clear(&k3);\n-        mp_clear(&qx);\n-        mp_clear(&qy);\n-        mp_clear(&sx);\n-        mp_clear(&sy);\n-        return res;\n-}\n-#endif\n-\n-\/* Validates a point on a GF2m curve. *\/\n-mp_err\n-ec_GF2m_validate_point(const mp_int *px, const mp_int *py, const ECGroup *group)\n-{\n-        mp_err res = MP_NO;\n-        mp_int accl, accr, tmp, pxt, pyt;\n-\n-        MP_DIGITS(&accl) = 0;\n-        MP_DIGITS(&accr) = 0;\n-        MP_DIGITS(&tmp) = 0;\n-        MP_DIGITS(&pxt) = 0;\n-        MP_DIGITS(&pyt) = 0;\n-        MP_CHECKOK(mp_init(&accl, FLAG(px)));\n-        MP_CHECKOK(mp_init(&accr, FLAG(px)));\n-        MP_CHECKOK(mp_init(&tmp, FLAG(px)));\n-        MP_CHECKOK(mp_init(&pxt, FLAG(px)));\n-        MP_CHECKOK(mp_init(&pyt, FLAG(px)));\n-\n-    \/* 1: Verify that publicValue is not the point at infinity *\/\n-        if (ec_GF2m_pt_is_inf_aff(px, py) == MP_YES) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-    \/* 2: Verify that the coordinates of publicValue are elements\n-     *    of the field.\n-     *\/\n-        if ((MP_SIGN(px) == MP_NEG) || (mp_cmp(px, &group->meth->irr) >= 0) ||\n-                (MP_SIGN(py) == MP_NEG) || (mp_cmp(py, &group->meth->irr) >= 0)) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-    \/* 3: Verify that publicValue is on the curve. *\/\n-        if (group->meth->field_enc) {\n-                group->meth->field_enc(px, &pxt, group->meth);\n-                group->meth->field_enc(py, &pyt, group->meth);\n-        } else {\n-                mp_copy(px, &pxt);\n-                mp_copy(py, &pyt);\n-        }\n-        \/* left-hand side: y^2 + x*y  *\/\n-        MP_CHECKOK( group->meth->field_sqr(&pyt, &accl, group->meth) );\n-        MP_CHECKOK( group->meth->field_mul(&pxt, &pyt, &tmp, group->meth) );\n-        MP_CHECKOK( group->meth->field_add(&accl, &tmp, &accl, group->meth) );\n-        \/* right-hand side: x^3 + a*x^2 + b *\/\n-        MP_CHECKOK( group->meth->field_sqr(&pxt, &tmp, group->meth) );\n-        MP_CHECKOK( group->meth->field_mul(&pxt, &tmp, &accr, group->meth) );\n-        MP_CHECKOK( group->meth->field_mul(&group->curvea, &tmp, &tmp, group->meth) );\n-        MP_CHECKOK( group->meth->field_add(&tmp, &accr, &accr, group->meth) );\n-        MP_CHECKOK( group->meth->field_add(&accr, &group->curveb, &accr, group->meth) );\n-        \/* check LHS - RHS == 0 *\/\n-        MP_CHECKOK( group->meth->field_add(&accl, &accr, &accr, group->meth) );\n-        if (mp_cmp_z(&accr) != 0) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-    \/* 4: Verify that the order of the curve times the publicValue\n-     *    is the point at infinity.\n-     *\/\n-        \/* timing mitigation is not supported *\/\n-        MP_CHECKOK( ECPoint_mul(group, &group->order, px, py, &pxt, &pyt, \/*timing*\/ 0) );\n-        if (ec_GF2m_pt_is_inf_aff(&pxt, &pyt) != MP_YES) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-\n-        res = MP_YES;\n-\n-CLEANUP:\n-        mp_clear(&accl);\n-        mp_clear(&accr);\n-        mp_clear(&tmp);\n-        mp_clear(&pxt);\n-        mp_clear(&pyt);\n-        return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec2_aff.c","additions":0,"deletions":349,"binary":false,"changes":349,"status":"deleted"},{"patch":"@@ -1,278 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for binary polynomial field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang-Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <fungstep@hotmail.com>, and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories.\n- *\n- *  Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"ec2.h\"\n-#include \"mplogic.h\"\n-#include \"mp_gf2m.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Compute the x-coordinate x\/z for the point 2*(x\/z) in Montgomery\n- * projective coordinates. Uses algorithm Mdouble in appendix of Lopez, J.\n- * and Dahab, R.  \"Fast multiplication on elliptic curves over GF(2^m)\n- * without precomputation\". modified to not require precomputation of\n- * c=b^{2^{m-1}}. *\/\n-static mp_err\n-gf2m_Mdouble(mp_int *x, mp_int *z, const ECGroup *group, int kmflag)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t1;\n-\n-        MP_DIGITS(&t1) = 0;\n-        MP_CHECKOK(mp_init(&t1, kmflag));\n-\n-        MP_CHECKOK(group->meth->field_sqr(x, x, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(z, &t1, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(x, &t1, z, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(x, x, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(&t1, &t1, group->meth));\n-        MP_CHECKOK(group->meth->\n-                           field_mul(&group->curveb, &t1, &t1, group->meth));\n-        MP_CHECKOK(group->meth->field_add(x, &t1, x, group->meth));\n-\n-  CLEANUP:\n-        mp_clear(&t1);\n-        return res;\n-}\n-\n-\/* Compute the x-coordinate x1\/z1 for the point (x1\/z1)+(x2\/x2) in\n- * Montgomery projective coordinates. Uses algorithm Madd in appendix of\n- * Lopex, J. and Dahab, R.  \"Fast multiplication on elliptic curves over\n- * GF(2^m) without precomputation\". *\/\n-static mp_err\n-gf2m_Madd(const mp_int *x, mp_int *x1, mp_int *z1, mp_int *x2, mp_int *z2,\n-                  const ECGroup *group, int kmflag)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t1, t2;\n-\n-        MP_DIGITS(&t1) = 0;\n-        MP_DIGITS(&t2) = 0;\n-        MP_CHECKOK(mp_init(&t1, kmflag));\n-        MP_CHECKOK(mp_init(&t2, kmflag));\n-\n-        MP_CHECKOK(mp_copy(x, &t1));\n-        MP_CHECKOK(group->meth->field_mul(x1, z2, x1, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(z1, x2, z1, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(x1, z1, &t2, group->meth));\n-        MP_CHECKOK(group->meth->field_add(z1, x1, z1, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(z1, z1, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(z1, &t1, x1, group->meth));\n-        MP_CHECKOK(group->meth->field_add(x1, &t2, x1, group->meth));\n-\n-  CLEANUP:\n-        mp_clear(&t1);\n-        mp_clear(&t2);\n-        return res;\n-}\n-\n-\/* Compute the x, y affine coordinates from the point (x1, z1) (x2, z2)\n- * using Montgomery point multiplication algorithm Mxy() in appendix of\n- * Lopex, J. and Dahab, R.  \"Fast multiplication on elliptic curves over\n- * GF(2^m) without precomputation\". Returns: 0 on error 1 if return value\n- * should be the point at infinity 2 otherwise *\/\n-static int\n-gf2m_Mxy(const mp_int *x, const mp_int *y, mp_int *x1, mp_int *z1,\n-                 mp_int *x2, mp_int *z2, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        int ret = 0;\n-        mp_int t3, t4, t5;\n-\n-        MP_DIGITS(&t3) = 0;\n-        MP_DIGITS(&t4) = 0;\n-        MP_DIGITS(&t5) = 0;\n-        MP_CHECKOK(mp_init(&t3, FLAG(x2)));\n-        MP_CHECKOK(mp_init(&t4, FLAG(x2)));\n-        MP_CHECKOK(mp_init(&t5, FLAG(x2)));\n-\n-        if (mp_cmp_z(z1) == 0) {\n-                mp_zero(x2);\n-                mp_zero(z2);\n-                ret = 1;\n-                goto CLEANUP;\n-        }\n-\n-        if (mp_cmp_z(z2) == 0) {\n-                MP_CHECKOK(mp_copy(x, x2));\n-                MP_CHECKOK(group->meth->field_add(x, y, z2, group->meth));\n-                ret = 2;\n-                goto CLEANUP;\n-        }\n-\n-        MP_CHECKOK(mp_set_int(&t5, 1));\n-        if (group->meth->field_enc) {\n-                MP_CHECKOK(group->meth->field_enc(&t5, &t5, group->meth));\n-        }\n-\n-        MP_CHECKOK(group->meth->field_mul(z1, z2, &t3, group->meth));\n-\n-        MP_CHECKOK(group->meth->field_mul(z1, x, z1, group->meth));\n-        MP_CHECKOK(group->meth->field_add(z1, x1, z1, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(z2, x, z2, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(z2, x1, x1, group->meth));\n-        MP_CHECKOK(group->meth->field_add(z2, x2, z2, group->meth));\n-\n-        MP_CHECKOK(group->meth->field_mul(z2, z1, z2, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(x, &t4, group->meth));\n-        MP_CHECKOK(group->meth->field_add(&t4, y, &t4, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&t4, &t3, &t4, group->meth));\n-        MP_CHECKOK(group->meth->field_add(&t4, z2, &t4, group->meth));\n-\n-        MP_CHECKOK(group->meth->field_mul(&t3, x, &t3, group->meth));\n-        MP_CHECKOK(group->meth->field_div(&t5, &t3, &t3, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&t3, &t4, &t4, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(x1, &t3, x2, group->meth));\n-        MP_CHECKOK(group->meth->field_add(x2, x, z2, group->meth));\n-\n-        MP_CHECKOK(group->meth->field_mul(z2, &t4, z2, group->meth));\n-        MP_CHECKOK(group->meth->field_add(z2, y, z2, group->meth));\n-\n-        ret = 2;\n-\n-  CLEANUP:\n-        mp_clear(&t3);\n-        mp_clear(&t4);\n-        mp_clear(&t5);\n-        if (res == MP_OKAY) {\n-                return ret;\n-        } else {\n-                return 0;\n-        }\n-}\n-\n-\/* Computes R = nP based on algorithm 2P of Lopex, J. and Dahab, R.  \"Fast\n- * multiplication on elliptic curves over GF(2^m) without\n- * precomputation\". Elliptic curve points P and R can be identical. Uses\n- * Montgomery projective coordinates. The timing parameter is ignored\n- * because this algorithm resists timing attacks by default. *\/\n-mp_err\n-ec_GF2m_pt_mul_mont(const mp_int *n, const mp_int *px, const mp_int *py,\n-                                        mp_int *rx, mp_int *ry, const ECGroup *group,\n-                                        int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int x1, x2, z1, z2;\n-        int i, j;\n-        mp_digit top_bit, mask;\n-\n-        MP_DIGITS(&x1) = 0;\n-        MP_DIGITS(&x2) = 0;\n-        MP_DIGITS(&z1) = 0;\n-        MP_DIGITS(&z2) = 0;\n-        MP_CHECKOK(mp_init(&x1, FLAG(n)));\n-        MP_CHECKOK(mp_init(&x2, FLAG(n)));\n-        MP_CHECKOK(mp_init(&z1, FLAG(n)));\n-        MP_CHECKOK(mp_init(&z2, FLAG(n)));\n-\n-        \/* if result should be point at infinity *\/\n-        if ((mp_cmp_z(n) == 0) || (ec_GF2m_pt_is_inf_aff(px, py) == MP_YES)) {\n-                MP_CHECKOK(ec_GF2m_pt_set_inf_aff(rx, ry));\n-                goto CLEANUP;\n-        }\n-\n-        MP_CHECKOK(mp_copy(px, &x1));   \/* x1 = px *\/\n-        MP_CHECKOK(mp_set_int(&z1, 1)); \/* z1 = 1 *\/\n-        MP_CHECKOK(group->meth->field_sqr(&x1, &z2, group->meth));      \/* z2 =\n-                                                                                                                                 * x1^2 =\n-                                                                                                                                 * px^2 *\/\n-        MP_CHECKOK(group->meth->field_sqr(&z2, &x2, group->meth));\n-        MP_CHECKOK(group->meth->field_add(&x2, &group->curveb, &x2, group->meth));      \/* x2\n-                                                                                                                                                                 * =\n-                                                                                                                                                                 * px^4\n-                                                                                                                                                                 * +\n-                                                                                                                                                                 * b\n-                                                                                                                                                                 *\/\n-\n-        \/* find top-most bit and go one past it *\/\n-        i = MP_USED(n) - 1;\n-        j = MP_DIGIT_BIT - 1;\n-        top_bit = 1;\n-        top_bit <<= MP_DIGIT_BIT - 1;\n-        mask = top_bit;\n-        while (!(MP_DIGITS(n)[i] & mask)) {\n-                mask >>= 1;\n-                j--;\n-        }\n-        mask >>= 1;\n-        j--;\n-\n-        \/* if top most bit was at word break, go to next word *\/\n-        if (!mask) {\n-                i--;\n-                j = MP_DIGIT_BIT - 1;\n-                mask = top_bit;\n-        }\n-\n-        for (; i >= 0; i--) {\n-                for (; j >= 0; j--) {\n-                        if (MP_DIGITS(n)[i] & mask) {\n-                                MP_CHECKOK(gf2m_Madd(px, &x1, &z1, &x2, &z2, group, FLAG(n)));\n-                                MP_CHECKOK(gf2m_Mdouble(&x2, &z2, group, FLAG(n)));\n-                        } else {\n-                                MP_CHECKOK(gf2m_Madd(px, &x2, &z2, &x1, &z1, group, FLAG(n)));\n-                                MP_CHECKOK(gf2m_Mdouble(&x1, &z1, group, FLAG(n)));\n-                        }\n-                        mask >>= 1;\n-                }\n-                j = MP_DIGIT_BIT - 1;\n-                mask = top_bit;\n-        }\n-\n-        \/* convert out of \"projective\" coordinates *\/\n-        i = gf2m_Mxy(px, py, &x1, &z1, &x2, &z2, group);\n-        if (i == 0) {\n-                res = MP_BADARG;\n-                goto CLEANUP;\n-        } else if (i == 1) {\n-                MP_CHECKOK(ec_GF2m_pt_set_inf_aff(rx, ry));\n-        } else {\n-                MP_CHECKOK(mp_copy(&x2, rx));\n-                MP_CHECKOK(mp_copy(&z2, ry));\n-        }\n-\n-  CLEANUP:\n-        mp_clear(&x1);\n-        mp_clear(&x2);\n-        mp_clear(&z1);\n-        mp_clear(&z2);\n-        return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec2_mont.c","additions":0,"deletions":278,"binary":false,"changes":278,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Stephen Fung <fungstep@hotmail.com>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecl-priv.h\"\n-\n-\/* Returns 2^e as an integer. This is meant to be used for small powers of\n- * two. *\/\n-int\n-ec_twoTo(int e)\n-{\n-        int a = 1;\n-        int i;\n-\n-        for (i = 0; i < e; i++) {\n-                a *= 2;\n-        }\n-        return a;\n-}\n-\n-\/* Computes the windowed non-adjacent-form (NAF) of a scalar. Out should\n- * be an array of signed char's to output to, bitsize should be the number\n- * of bits of out, in is the original scalar, and w is the window size.\n- * NAF is discussed in the paper: D. Hankerson, J. Hernandez and A.\n- * Menezes, \"Software implementation of elliptic curve cryptography over\n- * binary fields\", Proc. CHES 2000. *\/\n-mp_err\n-ec_compute_wNAF(signed char *out, int bitsize, const mp_int *in, int w)\n-{\n-        mp_int k;\n-        mp_err res = MP_OKAY;\n-        int i, twowm1, mask;\n-\n-        twowm1 = ec_twoTo(w - 1);\n-        mask = 2 * twowm1 - 1;\n-\n-        MP_DIGITS(&k) = 0;\n-        MP_CHECKOK(mp_init_copy(&k, in));\n-\n-        i = 0;\n-        \/* Compute wNAF form *\/\n-        while (mp_cmp_z(&k) > 0) {\n-                if (mp_isodd(&k)) {\n-                        out[i] = MP_DIGIT(&k, 0) & mask;\n-                        if (out[i] >= twowm1)\n-                                out[i] -= 2 * twowm1;\n-\n-                        \/* Subtract off out[i].  Note mp_sub_d only works with\n-                         * unsigned digits *\/\n-                        if (out[i] >= 0) {\n-                                mp_sub_d(&k, out[i], &k);\n-                        } else {\n-                                mp_add_d(&k, -(out[i]), &k);\n-                        }\n-                } else {\n-                        out[i] = 0;\n-                }\n-                mp_div_2(&k, &k);\n-                i++;\n-        }\n-        \/* Zero out the remaining elements of the out array. *\/\n-        for (; i < bitsize + 1; i++) {\n-                out[i] = 0;\n-        }\n-  CLEANUP:\n-        mp_clear(&k);\n-        return res;\n-\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ec_naf.c","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,271 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Netscape security libraries.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 1994-2000\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com> and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#ifndef _ECC_IMPL_H\n-#define _ECC_IMPL_H\n-\n-#ifdef __cplusplus\n-extern \"C\" {\n-#endif\n-\n-#include <sys\/types.h>\n-#include \"ecl-exp.h\"\n-\n-\/*\n- * Multi-platform definitions\n- *\/\n-#ifdef __linux__\n-#define B_FALSE FALSE\n-#define B_TRUE TRUE\n-typedef unsigned char uint8_t;\n-typedef unsigned long ulong_t;\n-typedef enum { B_FALSE, B_TRUE } boolean_t;\n-#endif \/* __linux__ *\/\n-\n-#ifdef _ALLBSD_SOURCE\n-#include <stdint.h>\n-#define B_FALSE FALSE\n-#define B_TRUE TRUE\n-typedef unsigned long ulong_t;\n-typedef enum boolean { B_FALSE, B_TRUE } boolean_t;\n-#endif \/* _ALLBSD_SOURCE *\/\n-\n-#ifdef AIX\n-#define B_FALSE FALSE\n-#define B_TRUE TRUE\n-typedef unsigned char uint8_t;\n-typedef unsigned long ulong_t;\n-#endif \/* AIX *\/\n-\n-#ifdef _WIN32\n-typedef unsigned char uint8_t;\n-typedef unsigned long ulong_t;\n-typedef enum boolean { B_FALSE, B_TRUE } boolean_t;\n-#define strdup _strdup          \/* Replace POSIX name with ISO C++ name *\/\n-#endif \/* _WIN32 *\/\n-\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif  \/* _KERNEL *\/\n-\n-#define EC_MAX_DIGEST_LEN 1024  \/* max digest that can be signed *\/\n-#define EC_MAX_POINT_LEN 145    \/* max len of DER encoded Q *\/\n-#define EC_MAX_VALUE_LEN 72     \/* max len of ANSI X9.62 private value d *\/\n-#define EC_MAX_SIG_LEN 144      \/* max signature len for supported curves *\/\n-#define EC_MIN_KEY_LEN  112     \/* min key length in bits *\/\n-#define EC_MAX_KEY_LEN  571     \/* max key length in bits *\/\n-#define EC_MAX_OID_LEN 10       \/* max length of OID buffer *\/\n-\n-\/*\n- * Various structures and definitions from NSS are here.\n- *\/\n-\n-#ifdef _KERNEL\n-#define PORT_ArenaAlloc(a, n, f)        kmem_alloc((n), (f))\n-#define PORT_ArenaZAlloc(a, n, f)       kmem_zalloc((n), (f))\n-#define PORT_ArenaGrow(a, b, c, d)      NULL\n-#define PORT_ZAlloc(n, f)               kmem_zalloc((n), (f))\n-#define PORT_Alloc(n, f)                kmem_alloc((n), (f))\n-#else\n-#define PORT_ArenaAlloc(a, n, f)        malloc((n))\n-#define PORT_ArenaZAlloc(a, n, f)       calloc(1, (n))\n-#define PORT_ArenaGrow(a, b, c, d)      NULL\n-#define PORT_ZAlloc(n, f)               calloc(1, (n))\n-#define PORT_Alloc(n, f)                malloc((n))\n-#endif\n-\n-#define PORT_NewArena(b)                (char *)12345\n-#define PORT_ArenaMark(a)               NULL\n-#define PORT_ArenaUnmark(a, b)\n-#define PORT_ArenaRelease(a, m)\n-#define PORT_FreeArena(a, b)\n-#define PORT_Strlen(s)                  strlen((s))\n-#define PORT_SetError(e)\n-\n-#define PRBool                          boolean_t\n-#define PR_TRUE                         B_TRUE\n-#define PR_FALSE                        B_FALSE\n-\n-#ifdef _KERNEL\n-#define PORT_Assert                     ASSERT\n-#define PORT_Memcpy(t, f, l)            bcopy((f), (t), (l))\n-#else\n-#define PORT_Assert                     assert\n-#define PORT_Memcpy(t, f, l)            memcpy((t), (f), (l))\n-#endif\n-\n-#define CHECK_OK(func) if (func == NULL) goto cleanup\n-#define CHECK_SEC_OK(func) if (SECSuccess != (rv = func)) goto cleanup\n-\n-typedef enum {\n-        siBuffer = 0,\n-        siClearDataBuffer = 1,\n-        siCipherDataBuffer = 2,\n-        siDERCertBuffer = 3,\n-        siEncodedCertBuffer = 4,\n-        siDERNameBuffer = 5,\n-        siEncodedNameBuffer = 6,\n-        siAsciiNameString = 7,\n-        siAsciiString = 8,\n-        siDEROID = 9,\n-        siUnsignedInteger = 10,\n-        siUTCTime = 11,\n-        siGeneralizedTime = 12\n-} SECItemType;\n-\n-typedef struct SECItemStr SECItem;\n-\n-struct SECItemStr {\n-        SECItemType type;\n-        unsigned char *data;\n-        unsigned int len;\n-};\n-\n-typedef SECItem SECKEYECParams;\n-\n-typedef enum { ec_params_explicit,\n-               ec_params_named\n-} ECParamsType;\n-\n-typedef enum { ec_field_GFp = 1,\n-               ec_field_GF2m\n-} ECFieldType;\n-\n-struct ECFieldIDStr {\n-    int         size;   \/* field size in bits *\/\n-    ECFieldType type;\n-    union {\n-        SECItem  prime; \/* prime p for (GFp) *\/\n-        SECItem  poly;  \/* irreducible binary polynomial for (GF2m) *\/\n-    } u;\n-    int         k1;     \/* first coefficient of pentanomial or\n-                         * the only coefficient of trinomial\n-                         *\/\n-    int         k2;     \/* two remaining coefficients of pentanomial *\/\n-    int         k3;\n-};\n-typedef struct ECFieldIDStr ECFieldID;\n-\n-struct ECCurveStr {\n-        SECItem a;      \/* contains octet stream encoding of\n-                         * field element (X9.62 section 4.3.3)\n-                         *\/\n-        SECItem b;\n-        SECItem seed;\n-};\n-typedef struct ECCurveStr ECCurve;\n-\n-typedef void PRArenaPool;\n-\n-struct ECParamsStr {\n-    PRArenaPool * arena;\n-    ECParamsType  type;\n-    ECFieldID     fieldID;\n-    ECCurve       curve;\n-    SECItem       base;\n-    SECItem       order;\n-    int           cofactor;\n-    SECItem       DEREncoding;\n-    ECCurveName   name;\n-    SECItem       curveOID;\n-};\n-typedef struct ECParamsStr ECParams;\n-\n-struct ECPublicKeyStr {\n-    ECParams ecParams;\n-    SECItem publicValue;   \/* elliptic curve point encoded as\n-                            * octet stream.\n-                            *\/\n-};\n-typedef struct ECPublicKeyStr ECPublicKey;\n-\n-struct ECPrivateKeyStr {\n-    ECParams ecParams;\n-    SECItem publicValue;   \/* encoded ec point *\/\n-    SECItem privateValue;  \/* private big integer *\/\n-    SECItem version;       \/* As per SEC 1, Appendix C, Section C.4 *\/\n-};\n-typedef struct ECPrivateKeyStr ECPrivateKey;\n-\n-typedef enum _SECStatus {\n-        SECBufferTooSmall = -3,\n-        SECWouldBlock = -2,\n-        SECFailure = -1,\n-        SECSuccess = 0\n-} SECStatus;\n-\n-#ifdef _KERNEL\n-#define RNG_GenerateGlobalRandomBytes(p,l) ecc_knzero_random_generator((p), (l))\n-#else\n-\/*\n- This function is no longer required because the random bytes are now\n- supplied by the caller. Force a failure.\n-*\/\n-#define RNG_GenerateGlobalRandomBytes(p,l) SECFailure\n-#endif\n-#define CHECK_MPI_OK(func) if (MP_OKAY > (err = func)) goto cleanup\n-#define MP_TO_SEC_ERROR(err)\n-\n-#define SECITEM_TO_MPINT(it, mp)                                        \\\n-        CHECK_MPI_OK(mp_read_unsigned_octets((mp), (it).data, (it).len))\n-\n-extern int ecc_knzero_random_generator(uint8_t *, size_t);\n-extern ulong_t soft_nzero_random_generator(uint8_t *, ulong_t);\n-\n-extern SECStatus EC_DecodeParams(const SECItem *, ECParams **, int);\n-extern SECItem * SECITEM_AllocItem(PRArenaPool *, SECItem *, unsigned int, int);\n-extern SECStatus SECITEM_CopyItem(PRArenaPool *, SECItem *, const SECItem *,\n-    int);\n-extern void SECITEM_FreeItem(SECItem *, boolean_t);\n-\/* This function has been modified to accept an array of random bytes *\/\n-extern SECStatus EC_NewKey(ECParams *ecParams, ECPrivateKey **privKey,\n-    const unsigned char* random, int randomlen, int);\n-\/* This function has been modified to accept an array of random bytes *\/\n-extern SECStatus ECDSA_SignDigest(ECPrivateKey *, SECItem *, const SECItem *,\n-    const unsigned char* random, int randomlen, int, int timing);\n-extern SECStatus ECDSA_VerifyDigest(ECPublicKey *, const SECItem *,\n-    const SECItem *, int);\n-extern SECStatus ECDH_Derive(SECItem *, ECParams *, SECItem *, boolean_t,\n-    SECItem *, int);\n-\n-#ifdef  __cplusplus\n-}\n-#endif\n-\n-#endif \/* _ECC_IMPL_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecc_impl.h","additions":0,"deletions":271,"binary":false,"changes":271,"status":"deleted"},{"patch":"@@ -1,642 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Elliptic Curve Cryptography library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com> and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: Nov 2016\n- *********************************************************************** *\/\n-\n-#include <sys\/types.h>\n-\n-#ifndef _WIN32\n-#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)\n-#include <sys\/systm.h>\n-#endif \/* __linux__ || _ALLBSD_SOURCE *\/\n-#include <sys\/param.h>\n-#endif \/* _WIN32 *\/\n-\n-#ifdef _KERNEL\n-#include <sys\/kmem.h>\n-#else\n-#include <stdio.h>\n-#include <string.h>\n-#endif\n-#include \"ec.h\"\n-#include \"ecl-curve.h\"\n-#include \"ecc_impl.h\"\n-\n-#define MAX_ECKEY_LEN           72\n-#define SEC_ASN1_OBJECT_ID      0x06\n-\n-\/*\n- * Initializes a SECItem from a hexadecimal string\n- *\n- * Warning: This function ignores leading 00's, so any leading 00's\n- * in the hexadecimal string must be optional.\n- *\/\n-static SECItem *\n-hexString2SECItem(PRArenaPool *arena, SECItem *item, const char *str,\n-    int kmflag)\n-{\n-    int i = 0;\n-    int byteval = 0;\n-    int tmp = (int)strlen(str);\n-\n-    if ((tmp % 2) != 0) return NULL;\n-\n-    \/* skip leading 00's unless the hex string is \"00\" *\/\n-    while ((tmp > 2) && (str[0] == '0') && (str[1] == '0')) {\n-        str += 2;\n-        tmp -= 2;\n-    }\n-\n-    item->data = (unsigned char *) PORT_ArenaAlloc(arena, tmp\/2, kmflag);\n-    if (item->data == NULL) return NULL;\n-    item->len = tmp\/2;\n-\n-    while (str[i]) {\n-        if ((str[i] >= '0') && (str[i] <= '9'))\n-            tmp = str[i] - '0';\n-        else if ((str[i] >= 'a') && (str[i] <= 'f'))\n-            tmp = str[i] - 'a' + 10;\n-        else if ((str[i] >= 'A') && (str[i] <= 'F'))\n-            tmp = str[i] - 'A' + 10;\n-        else\n-            return NULL;\n-\n-        byteval = byteval * 16 + tmp;\n-        if ((i % 2) != 0) {\n-            item->data[i\/2] = byteval;\n-            byteval = 0;\n-        }\n-        i++;\n-    }\n-\n-    return item;\n-}\n-\n-static SECStatus\n-gf_populate_params(ECCurveName name, ECFieldType field_type, ECParams *params,\n-    int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    const ECCurveParams *curveParams;\n-    \/* 2 ['0'+'4'] + MAX_ECKEY_LEN * 2 [x,y] * 2 [hex string] + 1 ['\\0'] *\/\n-    char genenc[3 + 2 * 2 * MAX_ECKEY_LEN];\n-\n-    if (((int)name < ECCurve_noName) || (name > ECCurve_pastLastCurve))\n-        goto cleanup;\n-    params->name = name;\n-    curveParams = ecCurve_map[params->name];\n-    CHECK_OK(curveParams);\n-    if ((strlen(curveParams->genx) + strlen(curveParams->geny)) > 2 * 2 * MAX_ECKEY_LEN) {\n-        goto cleanup;\n-    }\n-    params->fieldID.size = curveParams->size;\n-    params->fieldID.type = field_type;\n-    if (field_type == ec_field_GFp) {\n-        CHECK_OK(hexString2SECItem(NULL, &params->fieldID.u.prime,\n-            curveParams->irr, kmflag));\n-    } else {\n-        CHECK_OK(hexString2SECItem(NULL, &params->fieldID.u.poly,\n-            curveParams->irr, kmflag));\n-    }\n-    CHECK_OK(hexString2SECItem(NULL, &params->curve.a,\n-        curveParams->curvea, kmflag));\n-    CHECK_OK(hexString2SECItem(NULL, &params->curve.b,\n-        curveParams->curveb, kmflag));\n-    genenc[0] = '0';\n-    genenc[1] = '4';\n-    genenc[2] = '\\0';\n-    strcat(genenc, curveParams->genx);\n-    strcat(genenc, curveParams->geny);\n-    CHECK_OK(hexString2SECItem(NULL, &params->base, genenc, kmflag));\n-    CHECK_OK(hexString2SECItem(NULL, &params->order,\n-        curveParams->order, kmflag));\n-    params->cofactor = curveParams->cofactor;\n-\n-    rv = SECSuccess;\n-\n-cleanup:\n-    return rv;\n-}\n-\n-ECCurveName SECOID_FindOIDTag(const SECItem *);\n-\n-SECStatus\n-EC_FillParams(PRArenaPool *arena, const SECItem *encodedParams,\n-    ECParams *params, int kmflag)\n-{\n-    SECStatus rv = SECFailure;\n-    ECCurveName tag;\n-    SECItem oid = { siBuffer, NULL, 0};\n-\n-#if EC_DEBUG\n-    int i;\n-\n-    printf(\"Encoded params in EC_DecodeParams: \");\n-    for (i = 0; i < encodedParams->len; i++) {\n-            printf(\"%02x:\", encodedParams->data[i]);\n-    }\n-    printf(\"\\n\");\n-#endif\n-\n-    if ((encodedParams->len != ANSI_X962_CURVE_OID_TOTAL_LEN) &&\n-        (encodedParams->len != SECG_CURVE_OID_TOTAL_LEN) &&\n-        (encodedParams->len != BRAINPOOL_CURVE_OID_TOTAL_LEN)) {\n-            PORT_SetError(SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE);\n-            return SECFailure;\n-    };\n-\n-    oid.len = encodedParams->len - 2;\n-    oid.data = encodedParams->data + 2;\n-    if ((encodedParams->data[0] != SEC_ASN1_OBJECT_ID) ||\n-        ((tag = SECOID_FindOIDTag(&oid)) == ECCurve_noName)) {\n-            PORT_SetError(SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE);\n-            return SECFailure;\n-    }\n-\n-    params->arena = arena;\n-    params->cofactor = 0;\n-    params->type = ec_params_named;\n-    params->name = ECCurve_noName;\n-\n-    \/* For named curves, fill out curveOID *\/\n-    params->curveOID.len = oid.len;\n-    params->curveOID.data = (unsigned char *) PORT_ArenaAlloc(NULL, oid.len,\n-        kmflag);\n-    if (params->curveOID.data == NULL) goto cleanup;\n-    memcpy(params->curveOID.data, oid.data, oid.len);\n-\n-#if EC_DEBUG\n-#ifndef SECOID_FindOIDTagDescription\n-    printf(\"Curve: %s\\n\", ecCurve_map[tag]->text);\n-#else\n-    printf(\"Curve: %s\\n\", SECOID_FindOIDTagDescription(tag));\n-#endif\n-#endif\n-\n-    switch (tag) {\n-\n-    \/* Binary curves *\/\n-\n-    case ECCurve_X9_62_CHAR2_PNB163V1:\n-        \/* Populate params for c2pnb163v1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB163V1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB163V2:\n-        \/* Populate params for c2pnb163v2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB163V2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB163V3:\n-        \/* Populate params for c2pnb163v3 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB163V3, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB176V1:\n-        \/* Populate params for c2pnb176v1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB176V1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB191V1:\n-        \/* Populate params for c2tnb191v1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB191V1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB191V2:\n-        \/* Populate params for c2tnb191v2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB191V2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB191V3:\n-        \/* Populate params for c2tnb191v3 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB191V3, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB208W1:\n-        \/* Populate params for c2pnb208w1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB208W1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB239V1:\n-        \/* Populate params for c2tnb239v1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB239V1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB239V2:\n-        \/* Populate params for c2tnb239v2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB239V2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB239V3:\n-        \/* Populate params for c2tnb239v3 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB239V3, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB272W1:\n-        \/* Populate params for c2pnb272w1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB272W1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB304W1:\n-        \/* Populate params for c2pnb304w1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB304W1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB359V1:\n-        \/* Populate params for c2tnb359v1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB359V1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_PNB368W1:\n-        \/* Populate params for c2pnb368w1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_PNB368W1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_CHAR2_TNB431R1:\n-        \/* Populate params for c2tnb431r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_CHAR2_TNB431R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_113R1:\n-        \/* Populate params for sect113r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_113R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_113R2:\n-        \/* Populate params for sect113r2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_113R2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_131R1:\n-        \/* Populate params for sect131r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_131R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_131R2:\n-        \/* Populate params for sect131r2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_131R2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_163K1:\n-        \/* Populate params for sect163k1\n-         * (the NIST K-163 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_163K1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_163R1:\n-        \/* Populate params for sect163r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_163R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_163R2:\n-        \/* Populate params for sect163r2\n-         * (the NIST B-163 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_163R2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_193R1:\n-        \/* Populate params for sect193r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_193R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_193R2:\n-        \/* Populate params for sect193r2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_193R2, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_233K1:\n-        \/* Populate params for sect233k1\n-         * (the NIST K-233 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_233K1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_233R1:\n-        \/* Populate params for sect233r1\n-         * (the NIST B-233 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_233R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_239K1:\n-        \/* Populate params for sect239k1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_239K1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_283K1:\n-        \/* Populate params for sect283k1\n-         * (the NIST K-283 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_283K1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_283R1:\n-        \/* Populate params for sect283r1\n-         * (the NIST B-283 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_283R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_409K1:\n-        \/* Populate params for sect409k1\n-         * (the NIST K-409 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_409K1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_409R1:\n-        \/* Populate params for sect409r1\n-         * (the NIST B-409 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_409R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_571K1:\n-        \/* Populate params for sect571k1\n-         * (the NIST K-571 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_571K1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_CHAR2_571R1:\n-        \/* Populate params for sect571r1\n-         * (the NIST B-571 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_CHAR2_571R1, ec_field_GF2m,\n-            params, kmflag) );\n-        break;\n-\n-    \/* Prime curves *\/\n-\n-    case ECCurve_X9_62_PRIME_192V1:\n-        \/* Populate params for prime192v1 aka secp192r1\n-         * (the NIST P-192 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_192V1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_PRIME_192V2:\n-        \/* Populate params for prime192v2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_192V2, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_PRIME_192V3:\n-        \/* Populate params for prime192v3 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_192V3, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_PRIME_239V1:\n-        \/* Populate params for prime239v1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_239V1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_PRIME_239V2:\n-        \/* Populate params for prime239v2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_239V2, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_PRIME_239V3:\n-        \/* Populate params for prime239v3 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_239V3, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_X9_62_PRIME_256V1:\n-        \/* Populate params for prime256v1 aka secp256r1\n-         * (the NIST P-256 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_X9_62_PRIME_256V1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_112R1:\n-        \/* Populate params for secp112r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_112R1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_112R2:\n-        \/* Populate params for secp112r2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_112R2, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_128R1:\n-        \/* Populate params for secp128r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_128R1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_128R2:\n-        \/* Populate params for secp128r2 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_128R2, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_160K1:\n-        \/* Populate params for secp160k1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_160K1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_160R1:\n-        \/* Populate params for secp160r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_160R1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_160R2:\n-        \/* Populate params for secp160r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_160R2, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_192K1:\n-        \/* Populate params for secp192k1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_192K1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_224K1:\n-        \/* Populate params for secp224k1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_224K1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_224R1:\n-        \/* Populate params for secp224r1\n-         * (the NIST P-224 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_224R1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_256K1:\n-        \/* Populate params for secp256k1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_256K1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_384R1:\n-        \/* Populate params for secp384r1\n-         * (the NIST P-384 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_384R1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_SECG_PRIME_521R1:\n-        \/* Populate params for secp521r1\n-         * (the NIST P-521 curve)\n-         *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_SECG_PRIME_521R1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_BrainpoolP256r1:\n-        \/* Populate params for brainpoolP256r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_BrainpoolP256r1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_BrainpoolP320r1:\n-        \/* Populate params for brainpoolP320r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_BrainpoolP320r1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_BrainpoolP384r1:\n-        \/* Populate params for brainpoolP384r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_BrainpoolP384r1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    case ECCurve_BrainpoolP512r1:\n-        \/* Populate params for brainpoolP512r1 *\/\n-        CHECK_SEC_OK( gf_populate_params(ECCurve_BrainpoolP512r1, ec_field_GFp,\n-            params, kmflag) );\n-        break;\n-\n-    default:\n-        break;\n-    };\n-\n-cleanup:\n-    if (!params->cofactor) {\n-        PORT_SetError(SEC_ERROR_UNSUPPORTED_ELLIPTIC_CURVE);\n-#if EC_DEBUG\n-        printf(\"Unrecognized curve, returning NULL params\\n\");\n-#endif\n-    }\n-\n-    return rv;\n-}\n-\n-SECStatus\n-EC_DecodeParams(const SECItem *encodedParams, ECParams **ecparams, int kmflag)\n-{\n-    PRArenaPool *arena;\n-    ECParams *params;\n-    SECStatus rv = SECFailure;\n-\n-    \/* Initialize an arena for the ECParams structure *\/\n-    if (!(arena = PORT_NewArena(NSS_FREEBL_DEFAULT_CHUNKSIZE)))\n-        return SECFailure;\n-\n-    params = (ECParams *)PORT_ArenaZAlloc(NULL, sizeof(ECParams), kmflag);\n-    if (!params) {\n-        PORT_FreeArena(NULL, B_TRUE);\n-        return SECFailure;\n-    }\n-\n-    \/* Copy the encoded params *\/\n-    SECITEM_AllocItem(arena, &(params->DEREncoding), encodedParams->len,\n-        kmflag);\n-    memcpy(params->DEREncoding.data, encodedParams->data, encodedParams->len);\n-\n-    \/* Fill out the rest of the ECParams structure based on\n-     * the encoded params\n-     *\/\n-    rv = EC_FillParams(NULL, encodedParams, params, kmflag);\n-    if (rv == SECFailure) {\n-        PORT_FreeArena(NULL, B_TRUE);\n-        return SECFailure;\n-    } else {\n-        *ecparams = params;;\n-        return SECSuccess;\n-    }\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecdecode.c","additions":0,"deletions":642,"binary":false,"changes":642,"status":"deleted"},{"patch":"@@ -1,733 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _ECL_CURVE_H\n-#define _ECL_CURVE_H\n-\n-#include \"ecl-exp.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* NIST prime curves *\/\n-static const ECCurveParams ecCurve_NIST_P192 = {\n-        \"NIST-P192\", ECField_GFp, 192,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\",\n-        \"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\",\n-        \"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\",\n-        \"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\", 1\n-};\n-\n-static const ECCurveParams ecCurve_NIST_P224 = {\n-        \"NIST-P224\", ECField_GFp, 224,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\",\n-        \"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\",\n-        \"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\",\n-        \"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\", 1\n-};\n-\n-static const ECCurveParams ecCurve_NIST_P256 = {\n-        \"NIST-P256\", ECField_GFp, 256,\n-        \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\",\n-        \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\",\n-        \"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\",\n-        \"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\",\n-        \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\",\n-        \"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\", 1\n-};\n-\n-static const ECCurveParams ecCurve_NIST_P384 = {\n-        \"NIST-P384\", ECField_GFp, 384,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\",\n-        \"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\",\n-        \"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\",\n-        \"3617DE4A96262C6F5D9E98BF9292DC29F8F41DBD289A147CE9DA3113B5F0B8C00A60B1CE1D7E819D7A431D7C90EA0E5F\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\",\n-        1\n-};\n-\n-static const ECCurveParams ecCurve_NIST_P521 = {\n-        \"NIST-P521\", ECField_GFp, 521,\n-        \"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\n-        \"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\",\n-        \"0051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\",\n-        \"00C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\",\n-        \"011839296A789A3BC0045C8A5FB42C7D1BD998F54449579B446817AFBD17273E662C97EE72995EF42640C550B9013FAD0761353C7086A272C24088BE94769FD16650\",\n-        \"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\",\n-        1\n-};\n-\n-\/* NIST binary curves *\/\n-static const ECCurveParams ecCurve_NIST_K163 = {\n-        \"NIST-K163\", ECField_GF2m, 163,\n-        \"0800000000000000000000000000000000000000C9\",\n-        \"000000000000000000000000000000000000000001\",\n-        \"000000000000000000000000000000000000000001\",\n-        \"02FE13C0537BBC11ACAA07D793DE4E6D5E5C94EEE8\",\n-        \"0289070FB05D38FF58321F2E800536D538CCDAA3D9\",\n-        \"04000000000000000000020108A2E0CC0D99F8A5EF\", 2\n-};\n-\n-static const ECCurveParams ecCurve_NIST_B163 = {\n-        \"NIST-B163\", ECField_GF2m, 163,\n-        \"0800000000000000000000000000000000000000C9\",\n-        \"000000000000000000000000000000000000000001\",\n-        \"020A601907B8C953CA1481EB10512F78744A3205FD\",\n-        \"03F0EBA16286A2D57EA0991168D4994637E8343E36\",\n-        \"00D51FBC6C71A0094FA2CDD545B11C5C0C797324F1\",\n-        \"040000000000000000000292FE77E70C12A4234C33\", 2\n-};\n-\n-static const ECCurveParams ecCurve_NIST_K233 = {\n-        \"NIST-K233\", ECField_GF2m, 233,\n-        \"020000000000000000000000000000000000000004000000000000000001\",\n-        \"000000000000000000000000000000000000000000000000000000000000\",\n-        \"000000000000000000000000000000000000000000000000000000000001\",\n-        \"017232BA853A7E731AF129F22FF4149563A419C26BF50A4C9D6EEFAD6126\",\n-        \"01DB537DECE819B7F70F555A67C427A8CD9BF18AEB9B56E0C11056FAE6A3\",\n-        \"008000000000000000000000000000069D5BB915BCD46EFB1AD5F173ABDF\", 4\n-};\n-\n-static const ECCurveParams ecCurve_NIST_B233 = {\n-        \"NIST-B233\", ECField_GF2m, 233,\n-        \"020000000000000000000000000000000000000004000000000000000001\",\n-        \"000000000000000000000000000000000000000000000000000000000001\",\n-        \"0066647EDE6C332C7F8C0923BB58213B333B20E9CE4281FE115F7D8F90AD\",\n-        \"00FAC9DFCBAC8313BB2139F1BB755FEF65BC391F8B36F8F8EB7371FD558B\",\n-        \"01006A08A41903350678E58528BEBF8A0BEFF867A7CA36716F7E01F81052\",\n-        \"01000000000000000000000000000013E974E72F8A6922031D2603CFE0D7\", 2\n-};\n-\n-static const ECCurveParams ecCurve_NIST_K283 = {\n-        \"NIST-K283\", ECField_GF2m, 283,\n-        \"0800000000000000000000000000000000000000000000000000000000000000000010A1\",\n-        \"000000000000000000000000000000000000000000000000000000000000000000000000\",\n-        \"000000000000000000000000000000000000000000000000000000000000000000000001\",\n-        \"0503213F78CA44883F1A3B8162F188E553CD265F23C1567A16876913B0C2AC2458492836\",\n-        \"01CCDA380F1C9E318D90F95D07E5426FE87E45C0E8184698E45962364E34116177DD2259\",\n-        \"01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE9AE2ED07577265DFF7F94451E061E163C61\", 4\n-};\n-\n-static const ECCurveParams ecCurve_NIST_B283 = {\n-        \"NIST-B283\", ECField_GF2m, 283,\n-        \"0800000000000000000000000000000000000000000000000000000000000000000010A1\",\n-        \"000000000000000000000000000000000000000000000000000000000000000000000001\",\n-        \"027B680AC8B8596DA5A4AF8A19A0303FCA97FD7645309FA2A581485AF6263E313B79A2F5\",\n-        \"05F939258DB7DD90E1934F8C70B0DFEC2EED25B8557EAC9C80E2E198F8CDBECD86B12053\",\n-        \"03676854FE24141CB98FE6D4B20D02B4516FF702350EDDB0826779C813F0DF45BE8112F4\",\n-        \"03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEF90399660FC938A90165B042A7CEFADB307\", 2\n-};\n-\n-static const ECCurveParams ecCurve_NIST_K409 = {\n-        \"NIST-K409\", ECField_GF2m, 409,\n-        \"02000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000001\",\n-        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n-        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\",\n-        \"0060F05F658F49C1AD3AB1890F7184210EFD0987E307C84C27ACCFB8F9F67CC2C460189EB5AAAA62EE222EB1B35540CFE9023746\",\n-        \"01E369050B7C4E42ACBA1DACBF04299C3460782F918EA427E6325165E9EA10E3DA5F6C42E9C55215AA9CA27A5863EC48D8E0286B\",\n-        \"007FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE5F83B2D4EA20400EC4557D5ED3E3E7CA5B4B5C83B8E01E5FCF\", 4\n-};\n-\n-static const ECCurveParams ecCurve_NIST_B409 = {\n-        \"NIST-B409\", ECField_GF2m, 409,\n-        \"02000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000001\",\n-        \"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\",\n-        \"0021A5C2C8EE9FEB5C4B9A753B7B476B7FD6422EF1F3DD674761FA99D6AC27C8A9A197B272822F6CD57A55AA4F50AE317B13545F\",\n-        \"015D4860D088DDB3496B0C6064756260441CDE4AF1771D4DB01FFE5B34E59703DC255A868A1180515603AEAB60794E54BB7996A7\",\n-        \"0061B1CFAB6BE5F32BBFA78324ED106A7636B9C5A7BD198D0158AA4F5488D08F38514F1FDF4B4F40D2181B3681C364BA0273C706\",\n-        \"010000000000000000000000000000000000000000000000000001E2AAD6A612F33307BE5FA47C3C9E052F838164CD37D9A21173\", 2\n-};\n-\n-static const ECCurveParams ecCurve_NIST_K571 = {\n-        \"NIST-K571\", ECField_GF2m, 571,\n-        \"080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000425\",\n-        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\",\n-        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\",\n-        \"026EB7A859923FBC82189631F8103FE4AC9CA2970012D5D46024804801841CA44370958493B205E647DA304DB4CEB08CBBD1BA39494776FB988B47174DCA88C7E2945283A01C8972\",\n-        \"0349DC807F4FBF374F4AEADE3BCA95314DD58CEC9F307A54FFC61EFC006D8A2C9D4979C0AC44AEA74FBEBBB9F772AEDCB620B01A7BA7AF1B320430C8591984F601CD4C143EF1C7A3\",\n-        \"020000000000000000000000000000000000000000000000000000000000000000000000131850E1F19A63E4B391A8DB917F4138B630D84BE5D639381E91DEB45CFE778F637C1001\", 4\n-};\n-\n-static const ECCurveParams ecCurve_NIST_B571 = {\n-        \"NIST-B571\", ECField_GF2m, 571,\n-        \"080000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000425\",\n-        \"000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001\",\n-        \"02F40E7E2221F295DE297117B7F3D62F5C6A97FFCB8CEFF1CD6BA8CE4A9A18AD84FFABBD8EFA59332BE7AD6756A66E294AFD185A78FF12AA520E4DE739BACA0C7FFEFF7F2955727A\",\n-        \"0303001D34B856296C16C0D40D3CD7750A93D1D2955FA80AA5F40FC8DB7B2ABDBDE53950F4C0D293CDD711A35B67FB1499AE60038614F1394ABFA3B4C850D927E1E7769C8EEC2D19\",\n-        \"037BF27342DA639B6DCCFFFEB73D69D78C6C27A6009CBBCA1980F8533921E8A684423E43BAB08A576291AF8F461BB2A8B3531D2F0485C19B16E2F1516E23DD3C1A4827AF1B8AC15B\",\n-        \"03FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE661CE18FF55987308059B186823851EC7DD9CA1161DE93D5174D66E8382E9BB2FE84E47\", 2\n-};\n-\n-\/* ANSI X9.62 prime curves *\/\n-static const ECCurveParams ecCurve_X9_62_PRIME_192V2 = {\n-        \"X9.62 P-192V2\", ECField_GFp, 192,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\",\n-        \"CC22D6DFB95C6B25E49C0D6364A4E5980C393AA21668D953\",\n-        \"EEA2BAE7E1497842F2DE7769CFE9C989C072AD696F48034A\",\n-        \"6574D11D69B6EC7A672BB82A083DF2F2B0847DE970B2DE15\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFE5FB1A724DC80418648D8DD31\", 1\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_PRIME_192V3 = {\n-        \"X9.62 P-192V3\", ECField_GFp, 192,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\",\n-        \"22123DC2395A05CAA7423DAECCC94760A7D462256BD56916\",\n-        \"7D29778100C65A1DA1783716588DCE2B8B4AEE8E228F1896\",\n-        \"38A90F22637337334B49DCB66A6DC8F9978ACA7648A943B0\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFF7A62D031C83F4294F640EC13\", 1\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_PRIME_239V1 = {\n-        \"X9.62 P-239V1\", ECField_GFp, 239,\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\",\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\",\n-        \"6B016C3BDCF18941D0D654921475CA71A9DB2FB27D1D37796185C2942C0A\",\n-        \"0FFA963CDCA8816CCC33B8642BEDF905C3D358573D3F27FBBD3B3CB9AAAF\",\n-        \"7DEBE8E4E90A5DAE6E4054CA530BA04654B36818CE226B39FCCB7B02F1AE\",\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF9E5E9A9F5D9071FBD1522688909D0B\", 1\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_PRIME_239V2 = {\n-        \"X9.62 P-239V2\", ECField_GFp, 239,\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\",\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\",\n-        \"617FAB6832576CBBFED50D99F0249C3FEE58B94BA0038C7AE84C8C832F2C\",\n-        \"38AF09D98727705120C921BB5E9E26296A3CDCF2F35757A0EAFD87B830E7\",\n-        \"5B0125E4DBEA0EC7206DA0FC01D9B081329FB555DE6EF460237DFF8BE4BA\",\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF800000CFA7E8594377D414C03821BC582063\", 1\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_PRIME_239V3 = {\n-        \"X9.62 P-239V3\", ECField_GFp, 239,\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFF\",\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFF8000000000007FFFFFFFFFFC\",\n-        \"255705FA2A306654B1F4CB03D6A750A30C250102D4988717D9BA15AB6D3E\",\n-        \"6768AE8E18BB92CFCF005C949AA2C6D94853D0E660BBF854B1C9505FE95A\",\n-        \"1607E6898F390C06BC1D552BAD226F3B6FCFE48B6E818499AF18E3ED6CF3\",\n-        \"7FFFFFFFFFFFFFFFFFFFFFFF7FFFFF975DEB41B3A6057C3C432146526551\", 1\n-};\n-\n-\/* ANSI X9.62 binary curves *\/\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB163V1 = {\n-        \"X9.62 C2-PNB163V1\", ECField_GF2m, 163,\n-        \"080000000000000000000000000000000000000107\",\n-        \"072546B5435234A422E0789675F432C89435DE5242\",\n-        \"00C9517D06D5240D3CFF38C74B20B6CD4D6F9DD4D9\",\n-        \"07AF69989546103D79329FCC3D74880F33BBE803CB\",\n-        \"01EC23211B5966ADEA1D3F87F7EA5848AEF0B7CA9F\",\n-        \"0400000000000000000001E60FC8821CC74DAEAFC1\", 2\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB163V2 = {\n-        \"X9.62 C2-PNB163V2\", ECField_GF2m, 163,\n-        \"080000000000000000000000000000000000000107\",\n-        \"0108B39E77C4B108BED981ED0E890E117C511CF072\",\n-        \"0667ACEB38AF4E488C407433FFAE4F1C811638DF20\",\n-        \"0024266E4EB5106D0A964D92C4860E2671DB9B6CC5\",\n-        \"079F684DDF6684C5CD258B3890021B2386DFD19FC5\",\n-        \"03FFFFFFFFFFFFFFFFFFFDF64DE1151ADBB78F10A7\", 2\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB163V3 = {\n-        \"X9.62 C2-PNB163V3\", ECField_GF2m, 163,\n-        \"080000000000000000000000000000000000000107\",\n-        \"07A526C63D3E25A256A007699F5447E32AE456B50E\",\n-        \"03F7061798EB99E238FD6F1BF95B48FEEB4854252B\",\n-        \"02F9F87B7C574D0BDECF8A22E6524775F98CDEBDCB\",\n-        \"05B935590C155E17EA48EB3FF3718B893DF59A05D0\",\n-        \"03FFFFFFFFFFFFFFFFFFFE1AEE140F110AFF961309\", 2\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB176V1 = {\n-        \"X9.62 C2-PNB176V1\", ECField_GF2m, 176,\n-        \"0100000000000000000000000000000000080000000007\",\n-        \"E4E6DB2995065C407D9D39B8D0967B96704BA8E9C90B\",\n-        \"5DDA470ABE6414DE8EC133AE28E9BBD7FCEC0AE0FFF2\",\n-        \"8D16C2866798B600F9F08BB4A8E860F3298CE04A5798\",\n-        \"6FA4539C2DADDDD6BAB5167D61B436E1D92BB16A562C\",\n-        \"00010092537397ECA4F6145799D62B0A19CE06FE26AD\", 0xFF6E\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB191V1 = {\n-        \"X9.62 C2-TNB191V1\", ECField_GF2m, 191,\n-        \"800000000000000000000000000000000000000000000201\",\n-        \"2866537B676752636A68F56554E12640276B649EF7526267\",\n-        \"2E45EF571F00786F67B0081B9495A3D95462F5DE0AA185EC\",\n-        \"36B3DAF8A23206F9C4F299D7B21A9C369137F2C84AE1AA0D\",\n-        \"765BE73433B3F95E332932E70EA245CA2418EA0EF98018FB\",\n-        \"40000000000000000000000004A20E90C39067C893BBB9A5\", 2\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB191V2 = {\n-        \"X9.62 C2-TNB191V2\", ECField_GF2m, 191,\n-        \"800000000000000000000000000000000000000000000201\",\n-        \"401028774D7777C7B7666D1366EA432071274F89FF01E718\",\n-        \"0620048D28BCBD03B6249C99182B7C8CD19700C362C46A01\",\n-        \"3809B2B7CC1B28CC5A87926AAD83FD28789E81E2C9E3BF10\",\n-        \"17434386626D14F3DBF01760D9213A3E1CF37AEC437D668A\",\n-        \"20000000000000000000000050508CB89F652824E06B8173\", 4\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB191V3 = {\n-        \"X9.62 C2-TNB191V3\", ECField_GF2m, 191,\n-        \"800000000000000000000000000000000000000000000201\",\n-        \"6C01074756099122221056911C77D77E77A777E7E7E77FCB\",\n-        \"71FE1AF926CF847989EFEF8DB459F66394D90F32AD3F15E8\",\n-        \"375D4CE24FDE434489DE8746E71786015009E66E38A926DD\",\n-        \"545A39176196575D985999366E6AD34CE0A77CD7127B06BE\",\n-        \"155555555555555555555555610C0B196812BFB6288A3EA3\", 6\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB208W1 = {\n-        \"X9.62 C2-PNB208W1\", ECField_GF2m, 208,\n-        \"010000000000000000000000000000000800000000000000000007\",\n-        \"0000000000000000000000000000000000000000000000000000\",\n-        \"C8619ED45A62E6212E1160349E2BFA844439FAFC2A3FD1638F9E\",\n-        \"89FDFBE4ABE193DF9559ECF07AC0CE78554E2784EB8C1ED1A57A\",\n-        \"0F55B51A06E78E9AC38A035FF520D8B01781BEB1A6BB08617DE3\",\n-        \"000101BAF95C9723C57B6C21DA2EFF2D5ED588BDD5717E212F9D\", 0xFE48\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB239V1 = {\n-        \"X9.62 C2-TNB239V1\", ECField_GF2m, 239,\n-        \"800000000000000000000000000000000000000000000000001000000001\",\n-        \"32010857077C5431123A46B808906756F543423E8D27877578125778AC76\",\n-        \"790408F2EEDAF392B012EDEFB3392F30F4327C0CA3F31FC383C422AA8C16\",\n-        \"57927098FA932E7C0A96D3FD5B706EF7E5F5C156E16B7E7C86038552E91D\",\n-        \"61D8EE5077C33FECF6F1A16B268DE469C3C7744EA9A971649FC7A9616305\",\n-        \"2000000000000000000000000000000F4D42FFE1492A4993F1CAD666E447\", 4\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB239V2 = {\n-        \"X9.62 C2-TNB239V2\", ECField_GF2m, 239,\n-        \"800000000000000000000000000000000000000000000000001000000001\",\n-        \"4230017757A767FAE42398569B746325D45313AF0766266479B75654E65F\",\n-        \"5037EA654196CFF0CD82B2C14A2FCF2E3FF8775285B545722F03EACDB74B\",\n-        \"28F9D04E900069C8DC47A08534FE76D2B900B7D7EF31F5709F200C4CA205\",\n-        \"5667334C45AFF3B5A03BAD9DD75E2C71A99362567D5453F7FA6E227EC833\",\n-        \"1555555555555555555555555555553C6F2885259C31E3FCDF154624522D\", 6\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB239V3 = {\n-        \"X9.62 C2-TNB239V3\", ECField_GF2m, 239,\n-        \"800000000000000000000000000000000000000000000000001000000001\",\n-        \"01238774666A67766D6676F778E676B66999176666E687666D8766C66A9F\",\n-        \"6A941977BA9F6A435199ACFC51067ED587F519C5ECB541B8E44111DE1D40\",\n-        \"70F6E9D04D289C4E89913CE3530BFDE903977D42B146D539BF1BDE4E9C92\",\n-        \"2E5A0EAF6E5E1305B9004DCE5C0ED7FE59A35608F33837C816D80B79F461\",\n-        \"0CCCCCCCCCCCCCCCCCCCCCCCCCCCCCAC4912D2D9DF903EF9888B8A0E4CFF\", 0xA\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB272W1 = {\n-        \"X9.62 C2-PNB272W1\", ECField_GF2m, 272,\n-        \"010000000000000000000000000000000000000000000000000000010000000000000B\",\n-        \"91A091F03B5FBA4AB2CCF49C4EDD220FB028712D42BE752B2C40094DBACDB586FB20\",\n-        \"7167EFC92BB2E3CE7C8AAAFF34E12A9C557003D7C73A6FAF003F99F6CC8482E540F7\",\n-        \"6108BABB2CEEBCF787058A056CBE0CFE622D7723A289E08A07AE13EF0D10D171DD8D\",\n-        \"10C7695716851EEF6BA7F6872E6142FBD241B830FF5EFCACECCAB05E02005DDE9D23\",\n-        \"000100FAF51354E0E39E4892DF6E319C72C8161603FA45AA7B998A167B8F1E629521\",\n-        0xFF06\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB304W1 = {\n-        \"X9.62 C2-PNB304W1\", ECField_GF2m, 304,\n-        \"010000000000000000000000000000000000000000000000000000000000000000000000000807\",\n-        \"FD0D693149A118F651E6DCE6802085377E5F882D1B510B44160074C1288078365A0396C8E681\",\n-        \"BDDB97E555A50A908E43B01C798EA5DAA6788F1EA2794EFCF57166B8C14039601E55827340BE\",\n-        \"197B07845E9BE2D96ADB0F5F3C7F2CFFBD7A3EB8B6FEC35C7FD67F26DDF6285A644F740A2614\",\n-        \"E19FBEB76E0DA171517ECF401B50289BF014103288527A9B416A105E80260B549FDC1B92C03B\",\n-        \"000101D556572AABAC800101D556572AABAC8001022D5C91DD173F8FB561DA6899164443051D\", 0xFE2E\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB359V1 = {\n-        \"X9.62 C2-TNB359V1\", ECField_GF2m, 359,\n-        \"800000000000000000000000000000000000000000000000000000000000000000000000100000000000000001\",\n-        \"5667676A654B20754F356EA92017D946567C46675556F19556A04616B567D223A5E05656FB549016A96656A557\",\n-        \"2472E2D0197C49363F1FE7F5B6DB075D52B6947D135D8CA445805D39BC345626089687742B6329E70680231988\",\n-        \"3C258EF3047767E7EDE0F1FDAA79DAEE3841366A132E163ACED4ED2401DF9C6BDCDE98E8E707C07A2239B1B097\",\n-        \"53D7E08529547048121E9C95F3791DD804963948F34FAE7BF44EA82365DC7868FE57E4AE2DE211305A407104BD\",\n-        \"01AF286BCA1AF286BCA1AF286BCA1AF286BCA1AF286BC9FB8F6B85C556892C20A7EB964FE7719E74F490758D3B\", 0x4C\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_PNB368W1 = {\n-        \"X9.62 C2-PNB368W1\", ECField_GF2m, 368,\n-        \"0100000000000000000000000000000000000000000000000000000000000000000000002000000000000000000007\",\n-        \"E0D2EE25095206F5E2A4F9ED229F1F256E79A0E2B455970D8D0D865BD94778C576D62F0AB7519CCD2A1A906AE30D\",\n-        \"FC1217D4320A90452C760A58EDCD30C8DD069B3C34453837A34ED50CB54917E1C2112D84D164F444F8F74786046A\",\n-        \"1085E2755381DCCCE3C1557AFA10C2F0C0C2825646C5B34A394CBCFA8BC16B22E7E789E927BE216F02E1FB136A5F\",\n-        \"7B3EB1BDDCBA62D5D8B2059B525797FC73822C59059C623A45FF3843CEE8F87CD1855ADAA81E2A0750B80FDA2310\",\n-        \"00010090512DA9AF72B08349D98A5DD4C7B0532ECA51CE03E2D10F3B7AC579BD87E909AE40A6F131E9CFCE5BD967\", 0xFF70\n-};\n-\n-static const ECCurveParams ecCurve_X9_62_CHAR2_TNB431R1 = {\n-        \"X9.62 C2-TNB431R1\", ECField_GF2m, 431,\n-        \"800000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000001\",\n-        \"1A827EF00DD6FC0E234CAF046C6A5D8A85395B236CC4AD2CF32A0CADBDC9DDF620B0EB9906D0957F6C6FEACD615468DF104DE296CD8F\",\n-        \"10D9B4A3D9047D8B154359ABFB1B7F5485B04CEB868237DDC9DEDA982A679A5A919B626D4E50A8DD731B107A9962381FB5D807BF2618\",\n-        \"120FC05D3C67A99DE161D2F4092622FECA701BE4F50F4758714E8A87BBF2A658EF8C21E7C5EFE965361F6C2999C0C247B0DBD70CE6B7\",\n-        \"20D0AF8903A96F8D5FA2C255745D3C451B302C9346D9B7E485E7BCE41F6B591F3E8F6ADDCBB0BC4C2F947A7DE1A89B625D6A598B3760\",\n-        \"0340340340340340340340340340340340340340340340340340340323C313FAB50589703B5EC68D3587FEC60D161CC149C1AD4A91\", 0x2760\n-};\n-\n-\/* SEC2 prime curves *\/\n-static const ECCurveParams ecCurve_SECG_PRIME_112R1 = {\n-        \"SECP-112R1\", ECField_GFp, 112,\n-        \"DB7C2ABF62E35E668076BEAD208B\",\n-        \"DB7C2ABF62E35E668076BEAD2088\",\n-        \"659EF8BA043916EEDE8911702B22\",\n-        \"09487239995A5EE76B55F9C2F098\",\n-        \"A89CE5AF8724C0A23E0E0FF77500\",\n-        \"DB7C2ABF62E35E7628DFAC6561C5\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_112R2 = {\n-        \"SECP-112R2\", ECField_GFp, 112,\n-        \"DB7C2ABF62E35E668076BEAD208B\",\n-        \"6127C24C05F38A0AAAF65C0EF02C\",\n-        \"51DEF1815DB5ED74FCC34C85D709\",\n-        \"4BA30AB5E892B4E1649DD0928643\",\n-        \"adcd46f5882e3747def36e956e97\",\n-        \"36DF0AAFD8B8D7597CA10520D04B\", 4\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_128R1 = {\n-        \"SECP-128R1\", ECField_GFp, 128,\n-        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\",\n-        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC\",\n-        \"E87579C11079F43DD824993C2CEE5ED3\",\n-        \"161FF7528B899B2D0C28607CA52C5B86\",\n-        \"CF5AC8395BAFEB13C02DA292DDED7A83\",\n-        \"FFFFFFFE0000000075A30D1B9038A115\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_128R2 = {\n-        \"SECP-128R2\", ECField_GFp, 128,\n-        \"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\",\n-        \"D6031998D1B3BBFEBF59CC9BBFF9AEE1\",\n-        \"5EEEFCA380D02919DC2C6558BB6D8A5D\",\n-        \"7B6AA5D85E572983E6FB32A7CDEBC140\",\n-        \"27B6916A894D3AEE7106FE805FC34B44\",\n-        \"3FFFFFFF7FFFFFFFBE0024720613B5A3\", 4\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_160K1 = {\n-        \"SECP-160K1\", ECField_GFp, 160,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\",\n-        \"0000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000007\",\n-        \"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB\",\n-        \"938CF935318FDCED6BC28286531733C3F03C4FEE\",\n-        \"0100000000000000000001B8FA16DFAB9ACA16B6B3\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_160R1 = {\n-        \"SECP-160R1\", ECField_GFp, 160,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\",\n-        \"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\",\n-        \"4A96B5688EF573284664698968C38BB913CBFC82\",\n-        \"23A628553168947D59DCC912042351377AC5FB32\",\n-        \"0100000000000000000001F4C8F927AED3CA752257\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_160R2 = {\n-        \"SECP-160R2\", ECField_GFp, 160,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC70\",\n-        \"B4E134D3FB59EB8BAB57274904664D5AF50388BA\",\n-        \"52DCB034293A117E1F4FF11B30F7199D3144CE6D\",\n-        \"FEAFFEF2E331F296E071FA0DF9982CFEA7D43F2E\",\n-        \"0100000000000000000000351EE786A818F3A1A16B\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_192K1 = {\n-        \"SECP-192K1\", ECField_GFp, 192,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37\",\n-        \"000000000000000000000000000000000000000000000000\",\n-        \"000000000000000000000000000000000000000000000003\",\n-        \"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D\",\n-        \"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_224K1 = {\n-        \"SECP-224K1\", ECField_GFp, 224,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFE56D\",\n-        \"00000000000000000000000000000000000000000000000000000000\",\n-        \"00000000000000000000000000000000000000000000000000000005\",\n-        \"A1455B334DF099DF30FC28A169A467E9E47075A90F7E650EB6B7A45C\",\n-        \"7E089FED7FBA344282CAFBD6F7E319F7C0B0BD59E2CA4BDB556D61A5\",\n-        \"010000000000000000000000000001DCE8D2EC6184CAF0A971769FB1F7\", 1\n-};\n-\n-static const ECCurveParams ecCurve_SECG_PRIME_256K1 = {\n-        \"SECP-256K1\", ECField_GFp, 256,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000007\",\n-        \"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",\n-        \"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\", 1\n-};\n-\n-\/* SEC2 binary curves *\/\n-static const ECCurveParams ecCurve_SECG_CHAR2_113R1 = {\n-        \"SECT-113R1\", ECField_GF2m, 113,\n-        \"020000000000000000000000000201\",\n-        \"003088250CA6E7C7FE649CE85820F7\",\n-        \"00E8BEE4D3E2260744188BE0E9C723\",\n-        \"009D73616F35F4AB1407D73562C10F\",\n-        \"00A52830277958EE84D1315ED31886\",\n-        \"0100000000000000D9CCEC8A39E56F\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_113R2 = {\n-        \"SECT-113R2\", ECField_GF2m, 113,\n-        \"020000000000000000000000000201\",\n-        \"00689918DBEC7E5A0DD6DFC0AA55C7\",\n-        \"0095E9A9EC9B297BD4BF36E059184F\",\n-        \"01A57A6A7B26CA5EF52FCDB8164797\",\n-        \"00B3ADC94ED1FE674C06E695BABA1D\",\n-        \"010000000000000108789B2496AF93\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_131R1 = {\n-        \"SECT-131R1\", ECField_GF2m, 131,\n-        \"080000000000000000000000000000010D\",\n-        \"07A11B09A76B562144418FF3FF8C2570B8\",\n-        \"0217C05610884B63B9C6C7291678F9D341\",\n-        \"0081BAF91FDF9833C40F9C181343638399\",\n-        \"078C6E7EA38C001F73C8134B1B4EF9E150\",\n-        \"0400000000000000023123953A9464B54D\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_131R2 = {\n-        \"SECT-131R2\", ECField_GF2m, 131,\n-        \"080000000000000000000000000000010D\",\n-        \"03E5A88919D7CAFCBF415F07C2176573B2\",\n-        \"04B8266A46C55657AC734CE38F018F2192\",\n-        \"0356DCD8F2F95031AD652D23951BB366A8\",\n-        \"0648F06D867940A5366D9E265DE9EB240F\",\n-        \"0400000000000000016954A233049BA98F\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_163R1 = {\n-        \"SECT-163R1\", ECField_GF2m, 163,\n-        \"0800000000000000000000000000000000000000C9\",\n-        \"07B6882CAAEFA84F9554FF8428BD88E246D2782AE2\",\n-        \"0713612DCDDCB40AAB946BDA29CA91F73AF958AFD9\",\n-        \"0369979697AB43897789566789567F787A7876A654\",\n-        \"00435EDB42EFAFB2989D51FEFCE3C80988F41FF883\",\n-        \"03FFFFFFFFFFFFFFFFFFFF48AAB689C29CA710279B\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_193R1 = {\n-        \"SECT-193R1\", ECField_GF2m, 193,\n-        \"02000000000000000000000000000000000000000000008001\",\n-        \"0017858FEB7A98975169E171F77B4087DE098AC8A911DF7B01\",\n-        \"00FDFB49BFE6C3A89FACADAA7A1E5BBC7CC1C2E5D831478814\",\n-        \"01F481BC5F0FF84A74AD6CDF6FDEF4BF6179625372D8C0C5E1\",\n-        \"0025E399F2903712CCF3EA9E3A1AD17FB0B3201B6AF7CE1B05\",\n-        \"01000000000000000000000000C7F34A778F443ACC920EBA49\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_193R2 = {\n-        \"SECT-193R2\", ECField_GF2m, 193,\n-        \"02000000000000000000000000000000000000000000008001\",\n-        \"0163F35A5137C2CE3EA6ED8667190B0BC43ECD69977702709B\",\n-        \"00C9BB9E8927D4D64C377E2AB2856A5B16E3EFB7F61D4316AE\",\n-        \"00D9B67D192E0367C803F39E1A7E82CA14A651350AAE617E8F\",\n-        \"01CE94335607C304AC29E7DEFBD9CA01F596F927224CDECF6C\",\n-        \"010000000000000000000000015AAB561B005413CCD4EE99D5\", 2\n-};\n-\n-static const ECCurveParams ecCurve_SECG_CHAR2_239K1 = {\n-        \"SECT-239K1\", ECField_GF2m, 239,\n-        \"800000000000000000004000000000000000000000000000000000000001\",\n-        \"000000000000000000000000000000000000000000000000000000000000\",\n-        \"000000000000000000000000000000000000000000000000000000000001\",\n-        \"29A0B6A887A983E9730988A68727A8B2D126C44CC2CC7B2A6555193035DC\",\n-        \"76310804F12E549BDB011C103089E73510ACB275FC312A5DC6B76553F0CA\",\n-        \"2000000000000000000000000000005A79FEC67CB6E91F1C1DA800E478A5\", 4\n-};\n-\n-\/* WTLS curves *\/\n-static const ECCurveParams ecCurve_WTLS_1 = {\n-        \"WTLS-1\", ECField_GF2m, 113,\n-        \"020000000000000000000000000201\",\n-        \"000000000000000000000000000001\",\n-        \"000000000000000000000000000001\",\n-        \"01667979A40BA497E5D5C270780617\",\n-        \"00F44B4AF1ECC2630E08785CEBCC15\",\n-        \"00FFFFFFFFFFFFFFFDBF91AF6DEA73\", 2\n-};\n-\n-static const ECCurveParams ecCurve_WTLS_8 = {\n-        \"WTLS-8\", ECField_GFp, 112,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFDE7\",\n-        \"0000000000000000000000000000\",\n-        \"0000000000000000000000000003\",\n-        \"0000000000000000000000000001\",\n-        \"0000000000000000000000000002\",\n-        \"0100000000000001ECEA551AD837E9\", 1\n-};\n-\n-static const ECCurveParams ecCurve_WTLS_9 = {\n-        \"WTLS-9\", ECField_GFp, 160,\n-        \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC808F\",\n-        \"0000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000003\",\n-        \"0000000000000000000000000000000000000001\",\n-        \"0000000000000000000000000000000000000002\",\n-        \"0100000000000000000001CDC98AE0E2DE574ABF33\", 1\n-};\n-\n-static const ECCurveParams ecCurve_BrainpoolP256r1 = {\n-        \"brainpoolP256r1\", ECField_GFp, 256,\n-        \"A9FB57DBA1EEA9BC3E660A909D838D726E3BF623D52620282013481D1F6E5377\",\n-        \"7D5A0975FC2C3057EEF67530417AFFE7FB8055C126DC5C6CE94A4B44F330B5D9\",\n-        \"26DC5C6CE94A4B44F330B5D9BBD77CBF958416295CF7E1CE6BCCDC18FF8C07B6\",\n-        \"8BD2AEB9CB7E57CB2C4B482FFC81B7AFB9DE27E1E3BD23C23A4453BD9ACE3262\",\n-        \"547EF835C3DAC4FD97F8461A14611DC9C27745132DED8E545C1D54C72F046997\",\n-        \"A9FB57DBA1EEA9BC3E660A909D838D718C397AA3B561A6F7901E0E82974856A7\", 1\n-};\n-\n-static const ECCurveParams ecCurve_BrainpoolP320r1 = {\n-        \"brainpoolP320r1\", ECField_GFp, 320,\n-        \"D35E472036BC4FB7E13C785ED201E065F98FCFA6F6F40DEF4F92B9EC7893EC28FCD412B1F1B32E27\",\n-        \"3EE30B568FBAB0F883CCEBD46D3F3BB8A2A73513F5EB79DA66190EB085FFA9F492F375A97D860EB4\",\n-        \"520883949DFDBC42D3AD198640688A6FE13F41349554B49ACC31DCCD884539816F5EB4AC8FB1F1A6\",\n-        \"43BD7E9AFB53D8B85289BCC48EE5BFE6F20137D10A087EB6E7871E2A10A599C710AF8D0D39E20611\",\n-        \"14FDD05545EC1CC8AB4093247F77275E0743FFED117182EAA9C77877AAAC6AC7D35245D1692E8EE1\",\n-        \"D35E472036BC4FB7E13C785ED201E065F98FCFA5B68F12A32D482EC7EE8658E98691555B44C59311\", 1\n-};\n-\n-static const ECCurveParams ecCurve_BrainpoolP384r1 = {\n-        \"brainpoolP384r1\", ECField_GFp, 384,\n-        \"8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B412B1DA197FB71123ACD3A729901D1A71874700133107EC53\",\n-        \"7BC382C63D8C150C3C72080ACE05AFA0C2BEA28E4FB22787139165EFBA91F90F8AA5814A503AD4EB04A8C7DD22CE2826\",\n-        \"04A8C7DD22CE28268B39B55416F0447C2FB77DE107DCD2A62E880EA53EEB62D57CB4390295DBC9943AB78696FA504C11\",\n-        \"1D1C64F068CF45FFA2A63A81B7C13F6B8847A3E77EF14FE3DB7FCAFE0CBD10E8E826E03436D646AAEF87B2E247D4AF1E\",\n-        \"8ABE1D7520F9C2A45CB1EB8E95CFD55262B70B29FEEC5864E19C054FF99129280E4646217791811142820341263C5315\",\n-        \"8CB91E82A3386D280F5D6F7E50E641DF152F7109ED5456B31F166E6CAC0425A7CF3AB6AF6B7FC3103B883202E9046565\", 1\n-};\n-\n-static const ECCurveParams ecCurve_BrainpoolP512r1 = {\n-        \"brainpoolP512r1\", ECField_GFp, 512,\n-        \"AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA703308717D4D9B009BC66842AECDA12AE6A380E62881FF2F2D82C68528AA6056583A48F3\",\n-        \"7830A3318B603B89E2327145AC234CC594CBDD8D3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CA\",\n-        \"3DF91610A83441CAEA9863BC2DED5D5AA8253AA10A2EF1C98B9AC8B57F1117A72BF2C7B9E7C1AC4D77FC94CADC083E67984050B75EBAE5DD2809BD638016F723\",\n-        \"81AEE4BDD82ED9645A21322E9C4C6A9385ED9F70B5D916C1B43B62EEF4D0098EFF3B1F78E2D0D48D50D1687B93B97D5F7C6D5047406A5E688B352209BCB9F822\",\n-        \"7DDE385D566332ECC0EABFA9CF7822FDF209F70024A57B1AA000C55B881F8111B2DCDE494A5F485E5BCA4BD88A2763AED1CA2B2FA8F0540678CD1E0F3AD80892\",\n-        \"AADD9DB8DBE9C48B3FD4E6AE33C9FC07CB308DB3B3C9D20ED6639CCA70330870553E5C414CA92619418661197FAC10471DB1D381085DDADDB58796829CA90069\", 1\n-};\n-\n-\/* mapping between ECCurveName enum and pointers to ECCurveParams *\/\n-static const ECCurveParams *ecCurve_map[] = {\n-    NULL,                               \/* ECCurve_noName *\/\n-    &ecCurve_NIST_P192,                 \/* ECCurve_NIST_P192 *\/\n-    &ecCurve_NIST_P224,                 \/* ECCurve_NIST_P224 *\/\n-    &ecCurve_NIST_P256,                 \/* ECCurve_NIST_P256 *\/\n-    &ecCurve_NIST_P384,                 \/* ECCurve_NIST_P384 *\/\n-    &ecCurve_NIST_P521,                 \/* ECCurve_NIST_P521 *\/\n-    &ecCurve_NIST_K163,                 \/* ECCurve_NIST_K163 *\/\n-    &ecCurve_NIST_B163,                 \/* ECCurve_NIST_B163 *\/\n-    &ecCurve_NIST_K233,                 \/* ECCurve_NIST_K233 *\/\n-    &ecCurve_NIST_B233,                 \/* ECCurve_NIST_B233 *\/\n-    &ecCurve_NIST_K283,                 \/* ECCurve_NIST_K283 *\/\n-    &ecCurve_NIST_B283,                 \/* ECCurve_NIST_B283 *\/\n-    &ecCurve_NIST_K409,                 \/* ECCurve_NIST_K409 *\/\n-    &ecCurve_NIST_B409,                 \/* ECCurve_NIST_B409 *\/\n-    &ecCurve_NIST_K571,                 \/* ECCurve_NIST_K571 *\/\n-    &ecCurve_NIST_B571,                 \/* ECCurve_NIST_B571 *\/\n-    &ecCurve_X9_62_PRIME_192V2,         \/* ECCurve_X9_62_PRIME_192V2 *\/\n-    &ecCurve_X9_62_PRIME_192V3,         \/* ECCurve_X9_62_PRIME_192V3 *\/\n-    &ecCurve_X9_62_PRIME_239V1,         \/* ECCurve_X9_62_PRIME_239V1 *\/\n-    &ecCurve_X9_62_PRIME_239V2,         \/* ECCurve_X9_62_PRIME_239V2 *\/\n-    &ecCurve_X9_62_PRIME_239V3,         \/* ECCurve_X9_62_PRIME_239V3 *\/\n-    &ecCurve_X9_62_CHAR2_PNB163V1,      \/* ECCurve_X9_62_CHAR2_PNB163V1 *\/\n-    &ecCurve_X9_62_CHAR2_PNB163V2,      \/* ECCurve_X9_62_CHAR2_PNB163V2 *\/\n-    &ecCurve_X9_62_CHAR2_PNB163V3,      \/* ECCurve_X9_62_CHAR2_PNB163V3 *\/\n-    &ecCurve_X9_62_CHAR2_PNB176V1,      \/* ECCurve_X9_62_CHAR2_PNB176V1 *\/\n-    &ecCurve_X9_62_CHAR2_TNB191V1,      \/* ECCurve_X9_62_CHAR2_TNB191V1 *\/\n-    &ecCurve_X9_62_CHAR2_TNB191V2,      \/* ECCurve_X9_62_CHAR2_TNB191V2 *\/\n-    &ecCurve_X9_62_CHAR2_TNB191V3,      \/* ECCurve_X9_62_CHAR2_TNB191V3 *\/\n-    &ecCurve_X9_62_CHAR2_PNB208W1,      \/* ECCurve_X9_62_CHAR2_PNB208W1 *\/\n-    &ecCurve_X9_62_CHAR2_TNB239V1,      \/* ECCurve_X9_62_CHAR2_TNB239V1 *\/\n-    &ecCurve_X9_62_CHAR2_TNB239V2,      \/* ECCurve_X9_62_CHAR2_TNB239V2 *\/\n-    &ecCurve_X9_62_CHAR2_TNB239V3,      \/* ECCurve_X9_62_CHAR2_TNB239V3 *\/\n-    &ecCurve_X9_62_CHAR2_PNB272W1,      \/* ECCurve_X9_62_CHAR2_PNB272W1 *\/\n-    &ecCurve_X9_62_CHAR2_PNB304W1,      \/* ECCurve_X9_62_CHAR2_PNB304W1 *\/\n-    &ecCurve_X9_62_CHAR2_TNB359V1,      \/* ECCurve_X9_62_CHAR2_TNB359V1 *\/\n-    &ecCurve_X9_62_CHAR2_PNB368W1,      \/* ECCurve_X9_62_CHAR2_PNB368W1 *\/\n-    &ecCurve_X9_62_CHAR2_TNB431R1,      \/* ECCurve_X9_62_CHAR2_TNB431R1 *\/\n-    &ecCurve_SECG_PRIME_112R1,          \/* ECCurve_SECG_PRIME_112R1 *\/\n-    &ecCurve_SECG_PRIME_112R2,          \/* ECCurve_SECG_PRIME_112R2 *\/\n-    &ecCurve_SECG_PRIME_128R1,          \/* ECCurve_SECG_PRIME_128R1 *\/\n-    &ecCurve_SECG_PRIME_128R2,          \/* ECCurve_SECG_PRIME_128R2 *\/\n-    &ecCurve_SECG_PRIME_160K1,          \/* ECCurve_SECG_PRIME_160K1 *\/\n-    &ecCurve_SECG_PRIME_160R1,          \/* ECCurve_SECG_PRIME_160R1 *\/\n-    &ecCurve_SECG_PRIME_160R2,          \/* ECCurve_SECG_PRIME_160R2 *\/\n-    &ecCurve_SECG_PRIME_192K1,          \/* ECCurve_SECG_PRIME_192K1 *\/\n-    &ecCurve_SECG_PRIME_224K1,          \/* ECCurve_SECG_PRIME_224K1 *\/\n-    &ecCurve_SECG_PRIME_256K1,          \/* ECCurve_SECG_PRIME_256K1 *\/\n-    &ecCurve_SECG_CHAR2_113R1,          \/* ECCurve_SECG_CHAR2_113R1 *\/\n-    &ecCurve_SECG_CHAR2_113R2,          \/* ECCurve_SECG_CHAR2_113R2 *\/\n-    &ecCurve_SECG_CHAR2_131R1,          \/* ECCurve_SECG_CHAR2_131R1 *\/\n-    &ecCurve_SECG_CHAR2_131R2,          \/* ECCurve_SECG_CHAR2_131R2 *\/\n-    &ecCurve_SECG_CHAR2_163R1,          \/* ECCurve_SECG_CHAR2_163R1 *\/\n-    &ecCurve_SECG_CHAR2_193R1,          \/* ECCurve_SECG_CHAR2_193R1 *\/\n-    &ecCurve_SECG_CHAR2_193R2,          \/* ECCurve_SECG_CHAR2_193R2 *\/\n-    &ecCurve_SECG_CHAR2_239K1,          \/* ECCurve_SECG_CHAR2_239K1 *\/\n-    &ecCurve_WTLS_1,                    \/* ECCurve_WTLS_1 *\/\n-    &ecCurve_WTLS_8,                    \/* ECCurve_WTLS_8 *\/\n-    &ecCurve_WTLS_9,                    \/* ECCurve_WTLS_9 *\/\n-    &ecCurve_BrainpoolP256r1,           \/* ECCurve_BrainpoolP256r1 *\/\n-    &ecCurve_BrainpoolP320r1,           \/* ECCurve_BrainpoolP320r1 *\/\n-    &ecCurve_BrainpoolP384r1,           \/* ECCurve_brainpoolP384r1 *\/\n-    &ecCurve_BrainpoolP512r1,           \/* ECCurve_brainpoolP512r1 *\/\n-    NULL                                \/* ECCurve_pastLastCurve *\/\n-};\n-\n-#endif \/* _ECL_CURVE_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl-curve.h","additions":0,"deletions":733,"binary":false,"changes":733,"status":"deleted"},{"patch":"@@ -1,201 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _ECL_EXP_H\n-#define _ECL_EXP_H\n-\n-\/* Curve field type *\/\n-typedef enum {\n-        ECField_GFp,\n-        ECField_GF2m\n-} ECField;\n-\n-\/* Hexadecimal encoding of curve parameters *\/\n-struct ECCurveParamsStr {\n-        char *text;\n-        ECField field;\n-        unsigned int size;\n-        char *irr;\n-        char *curvea;\n-        char *curveb;\n-        char *genx;\n-        char *geny;\n-        char *order;\n-        int cofactor;\n-};\n-typedef struct ECCurveParamsStr ECCurveParams;\n-\n-\/* Named curve parameters *\/\n-typedef enum {\n-\n-        ECCurve_noName = 0,\n-\n-        \/* NIST prime curves *\/\n-        ECCurve_NIST_P192,\n-        ECCurve_NIST_P224,\n-        ECCurve_NIST_P256,\n-        ECCurve_NIST_P384,\n-        ECCurve_NIST_P521,\n-\n-        \/* NIST binary curves *\/\n-        ECCurve_NIST_K163,\n-        ECCurve_NIST_B163,\n-        ECCurve_NIST_K233,\n-        ECCurve_NIST_B233,\n-        ECCurve_NIST_K283,\n-        ECCurve_NIST_B283,\n-        ECCurve_NIST_K409,\n-        ECCurve_NIST_B409,\n-        ECCurve_NIST_K571,\n-        ECCurve_NIST_B571,\n-\n-        \/* ANSI X9.62 prime curves *\/\n-        \/* ECCurve_X9_62_PRIME_192V1 == ECCurve_NIST_P192 *\/\n-        ECCurve_X9_62_PRIME_192V2,\n-        ECCurve_X9_62_PRIME_192V3,\n-        ECCurve_X9_62_PRIME_239V1,\n-        ECCurve_X9_62_PRIME_239V2,\n-        ECCurve_X9_62_PRIME_239V3,\n-        \/* ECCurve_X9_62_PRIME_256V1 == ECCurve_NIST_P256 *\/\n-\n-        \/* ANSI X9.62 binary curves *\/\n-        ECCurve_X9_62_CHAR2_PNB163V1,\n-        ECCurve_X9_62_CHAR2_PNB163V2,\n-        ECCurve_X9_62_CHAR2_PNB163V3,\n-        ECCurve_X9_62_CHAR2_PNB176V1,\n-        ECCurve_X9_62_CHAR2_TNB191V1,\n-        ECCurve_X9_62_CHAR2_TNB191V2,\n-        ECCurve_X9_62_CHAR2_TNB191V3,\n-        ECCurve_X9_62_CHAR2_PNB208W1,\n-        ECCurve_X9_62_CHAR2_TNB239V1,\n-        ECCurve_X9_62_CHAR2_TNB239V2,\n-        ECCurve_X9_62_CHAR2_TNB239V3,\n-        ECCurve_X9_62_CHAR2_PNB272W1,\n-        ECCurve_X9_62_CHAR2_PNB304W1,\n-        ECCurve_X9_62_CHAR2_TNB359V1,\n-        ECCurve_X9_62_CHAR2_PNB368W1,\n-        ECCurve_X9_62_CHAR2_TNB431R1,\n-\n-        \/* SEC2 prime curves *\/\n-        ECCurve_SECG_PRIME_112R1,\n-        ECCurve_SECG_PRIME_112R2,\n-        ECCurve_SECG_PRIME_128R1,\n-        ECCurve_SECG_PRIME_128R2,\n-        ECCurve_SECG_PRIME_160K1,\n-        ECCurve_SECG_PRIME_160R1,\n-        ECCurve_SECG_PRIME_160R2,\n-        ECCurve_SECG_PRIME_192K1,\n-        \/* ECCurve_SECG_PRIME_192R1 == ECCurve_NIST_P192 *\/\n-        ECCurve_SECG_PRIME_224K1,\n-        \/* ECCurve_SECG_PRIME_224R1 == ECCurve_NIST_P224 *\/\n-        ECCurve_SECG_PRIME_256K1,\n-        \/* ECCurve_SECG_PRIME_256R1 == ECCurve_NIST_P256 *\/\n-        \/* ECCurve_SECG_PRIME_384R1 == ECCurve_NIST_P384 *\/\n-        \/* ECCurve_SECG_PRIME_521R1 == ECCurve_NIST_P521 *\/\n-\n-        \/* SEC2 binary curves *\/\n-        ECCurve_SECG_CHAR2_113R1,\n-        ECCurve_SECG_CHAR2_113R2,\n-        ECCurve_SECG_CHAR2_131R1,\n-        ECCurve_SECG_CHAR2_131R2,\n-        \/* ECCurve_SECG_CHAR2_163K1 == ECCurve_NIST_K163 *\/\n-        ECCurve_SECG_CHAR2_163R1,\n-        \/* ECCurve_SECG_CHAR2_163R2 == ECCurve_NIST_B163 *\/\n-        ECCurve_SECG_CHAR2_193R1,\n-        ECCurve_SECG_CHAR2_193R2,\n-        \/* ECCurve_SECG_CHAR2_233K1 == ECCurve_NIST_K233 *\/\n-        \/* ECCurve_SECG_CHAR2_233R1 == ECCurve_NIST_B233 *\/\n-        ECCurve_SECG_CHAR2_239K1,\n-        \/* ECCurve_SECG_CHAR2_283K1 == ECCurve_NIST_K283 *\/\n-        \/* ECCurve_SECG_CHAR2_283R1 == ECCurve_NIST_B283 *\/\n-        \/* ECCurve_SECG_CHAR2_409K1 == ECCurve_NIST_K409 *\/\n-        \/* ECCurve_SECG_CHAR2_409R1 == ECCurve_NIST_B409 *\/\n-        \/* ECCurve_SECG_CHAR2_571K1 == ECCurve_NIST_K571 *\/\n-        \/* ECCurve_SECG_CHAR2_571R1 == ECCurve_NIST_B571 *\/\n-\n-        \/* WTLS curves *\/\n-        ECCurve_WTLS_1,\n-        \/* there is no WTLS 2 curve *\/\n-        \/* ECCurve_WTLS_3 == ECCurve_NIST_K163 *\/\n-        \/* ECCurve_WTLS_4 == ECCurve_SECG_CHAR2_113R1 *\/\n-        \/* ECCurve_WTLS_5 == ECCurve_X9_62_CHAR2_PNB163V1 *\/\n-        \/* ECCurve_WTLS_6 == ECCurve_SECG_PRIME_112R1 *\/\n-        \/* ECCurve_WTLS_7 == ECCurve_SECG_PRIME_160R1 *\/\n-        ECCurve_WTLS_8,\n-        ECCurve_WTLS_9,\n-        \/* ECCurve_WTLS_10 == ECCurve_NIST_K233 *\/\n-        \/* ECCurve_WTLS_11 == ECCurve_NIST_B233 *\/\n-        \/* ECCurve_WTLS_12 == ECCurve_NIST_P224 *\/\n-\n-        \/* ECC Brainpool prime curves in RFC 5639*\/\n-        ECCurve_BrainpoolP256r1,\n-        ECCurve_BrainpoolP320r1,\n-        ECCurve_BrainpoolP384r1,\n-        ECCurve_BrainpoolP512r1,\n-\n-        ECCurve_pastLastCurve\n-} ECCurveName;\n-\n-\/* Aliased named curves *\/\n-\n-#define ECCurve_X9_62_PRIME_192V1 ECCurve_NIST_P192\n-#define ECCurve_X9_62_PRIME_256V1 ECCurve_NIST_P256\n-#define ECCurve_SECG_PRIME_192R1 ECCurve_NIST_P192\n-#define ECCurve_SECG_PRIME_224R1 ECCurve_NIST_P224\n-#define ECCurve_SECG_PRIME_256R1 ECCurve_NIST_P256\n-#define ECCurve_SECG_PRIME_384R1 ECCurve_NIST_P384\n-#define ECCurve_SECG_PRIME_521R1 ECCurve_NIST_P521\n-#define ECCurve_SECG_CHAR2_163K1 ECCurve_NIST_K163\n-#define ECCurve_SECG_CHAR2_163R2 ECCurve_NIST_B163\n-#define ECCurve_SECG_CHAR2_233K1 ECCurve_NIST_K233\n-#define ECCurve_SECG_CHAR2_233R1 ECCurve_NIST_B233\n-#define ECCurve_SECG_CHAR2_283K1 ECCurve_NIST_K283\n-#define ECCurve_SECG_CHAR2_283R1 ECCurve_NIST_B283\n-#define ECCurve_SECG_CHAR2_409K1 ECCurve_NIST_K409\n-#define ECCurve_SECG_CHAR2_409R1 ECCurve_NIST_B409\n-#define ECCurve_SECG_CHAR2_571K1 ECCurve_NIST_K571\n-#define ECCurve_SECG_CHAR2_571R1 ECCurve_NIST_B571\n-#define ECCurve_WTLS_3 ECCurve_NIST_K163\n-#define ECCurve_WTLS_4 ECCurve_SECG_CHAR2_113R1\n-#define ECCurve_WTLS_5 ECCurve_X9_62_CHAR2_PNB163V1\n-#define ECCurve_WTLS_6 ECCurve_SECG_PRIME_112R1\n-#define ECCurve_WTLS_7 ECCurve_SECG_PRIME_160R1\n-#define ECCurve_WTLS_10 ECCurve_NIST_K233\n-#define ECCurve_WTLS_11 ECCurve_NIST_B233\n-#define ECCurve_WTLS_12 ECCurve_NIST_P224\n-\n-#endif \/* _ECL_EXP_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl-exp.h","additions":0,"deletions":201,"binary":false,"changes":201,"status":"deleted"},{"patch":"@@ -1,300 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Stephen Fung <fungstep@hotmail.com> and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#ifndef _ECL_PRIV_H\n-#define _ECL_PRIV_H\n-\n-#include \"ecl.h\"\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-\n-\/* MAX_FIELD_SIZE_DIGITS is the maximum size of field element supported *\/\n-\/* the following needs to go away... *\/\n-#if defined(MP_USE_LONG_LONG_DIGIT) || defined(MP_USE_LONG_DIGIT)\n-#define ECL_SIXTY_FOUR_BIT\n-#else\n-#define ECL_THIRTY_TWO_BIT\n-#endif\n-\n-#define ECL_CURVE_DIGITS(curve_size_in_bits) \\\n-        (((curve_size_in_bits)+(sizeof(mp_digit)*8-1))\/(sizeof(mp_digit)*8))\n-#define ECL_BITS (sizeof(mp_digit)*8)\n-#define ECL_MAX_FIELD_SIZE_DIGITS (80\/sizeof(mp_digit))\n-\n-\/* Gets the i'th bit in the binary representation of a. If i >= length(a),\n- * then return 0. (The above behaviour differs from mpl_get_bit, which\n- * causes an error if i >= length(a).) *\/\n-#define MP_GET_BIT(a, i) \\\n-        ((i) >= mpl_significant_bits((a))) ? 0 : mpl_get_bit((a), (i))\n-\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-#define MP_ADD_CARRY(a1, a2, s, cin, cout)   \\\n-    { mp_word w; \\\n-    w = ((mp_word)(cin)) + (a1) + (a2); \\\n-    s = ACCUM(w); \\\n-    cout = CARRYOUT(w); }\n-\n-\/* Handle case when carry-in value is zero *\/\n-#define MP_ADD_CARRY_ZERO(a1, a2, s, cout)   \\\n-    MP_ADD_CARRY(a1, a2, s, 0, cout);\n-\n-#define MP_SUB_BORROW(a1, a2, s, bin, bout)   \\\n-    { mp_word w; \\\n-    w = ((mp_word)(a1)) - (a2) - (bin); \\\n-    s = ACCUM(w); \\\n-    bout = (w >> MP_DIGIT_BIT) & 1; }\n-\n-#else\n-\/* NOTE,\n- * cin and cout could be the same variable.\n- * bin and bout could be the same variable.\n- * a1 or a2 and s could be the same variable.\n- * don't trash those outputs until their respective inputs have\n- * been read. *\/\n-#define MP_ADD_CARRY(a1, a2, s, cin, cout)   \\\n-    { mp_digit tmp,sum; \\\n-    tmp = (a1); \\\n-    sum = tmp + (a2); \\\n-    tmp = (sum < tmp);                     \/* detect overflow *\/ \\\n-    s = sum += (cin); \\\n-    cout = tmp + (sum < (cin)); }\n-\n-\/* Handle case when carry-in value is zero *\/\n-#define MP_ADD_CARRY_ZERO(a1, a2, s, cout)   \\\n-    { mp_digit tmp,sum; \\\n-    tmp = (a1); \\\n-    sum = tmp + (a2); \\\n-    tmp = (sum < tmp);                     \/* detect overflow *\/ \\\n-    s = sum; \\\n-    cout = tmp; }\n-\n-#define MP_SUB_BORROW(a1, a2, s, bin, bout)   \\\n-    { mp_digit tmp; \\\n-    tmp = (a1); \\\n-    s = tmp - (a2); \\\n-    tmp = (s > tmp);                    \/* detect borrow *\/ \\\n-    if ((bin) && !s--) tmp++;   \\\n-    bout = tmp; }\n-#endif\n-\n-\n-struct GFMethodStr;\n-typedef struct GFMethodStr GFMethod;\n-struct GFMethodStr {\n-        \/* Indicates whether the structure was constructed from dynamic memory\n-         * or statically created. *\/\n-        int constructed;\n-        \/* Irreducible that defines the field. For prime fields, this is the\n-         * prime p. For binary polynomial fields, this is the bitstring\n-         * representation of the irreducible polynomial. *\/\n-        mp_int irr;\n-        \/* For prime fields, the value irr_arr[0] is the number of bits in the\n-         * field. For binary polynomial fields, the irreducible polynomial\n-         * f(t) is represented as an array of unsigned int[], where f(t) is\n-         * of the form: f(t) = t^p[0] + t^p[1] + ... + t^p[4] where m = p[0]\n-         * > p[1] > ... > p[4] = 0. *\/\n-        unsigned int irr_arr[5];\n-        \/* Field arithmetic methods. All methods (except field_enc and\n-         * field_dec) are assumed to take field-encoded parameters and return\n-         * field-encoded values. All methods (except field_enc and field_dec)\n-         * are required to be implemented. *\/\n-        mp_err (*field_add) (const mp_int *a, const mp_int *b, mp_int *r,\n-                                                 const GFMethod *meth);\n-        mp_err (*field_neg) (const mp_int *a, mp_int *r, const GFMethod *meth);\n-        mp_err (*field_sub) (const mp_int *a, const mp_int *b, mp_int *r,\n-                                                 const GFMethod *meth);\n-        mp_err (*field_mod) (const mp_int *a, mp_int *r, const GFMethod *meth);\n-        mp_err (*field_mul) (const mp_int *a, const mp_int *b, mp_int *r,\n-                                                 const GFMethod *meth);\n-        mp_err (*field_sqr) (const mp_int *a, mp_int *r, const GFMethod *meth);\n-        mp_err (*field_div) (const mp_int *a, const mp_int *b, mp_int *r,\n-                                                 const GFMethod *meth);\n-        mp_err (*field_enc) (const mp_int *a, mp_int *r, const GFMethod *meth);\n-        mp_err (*field_dec) (const mp_int *a, mp_int *r, const GFMethod *meth);\n-        \/* Extra storage for implementation-specific data.  Any memory\n-         * allocated to these extra fields will be cleared by extra_free. *\/\n-        void *extra1;\n-        void *extra2;\n-        void (*extra_free) (GFMethod *meth);\n-};\n-\n-\/* Construct generic GFMethods. *\/\n-GFMethod *GFMethod_consGFp(const mp_int *irr);\n-GFMethod *GFMethod_consGFp_mont(const mp_int *irr);\n-GFMethod *GFMethod_consGF2m(const mp_int *irr,\n-                                                        const unsigned int irr_arr[5]);\n-\/* Free the memory allocated (if any) to a GFMethod object. *\/\n-void GFMethod_free(GFMethod *meth);\n-\n-struct ECGroupStr {\n-        \/* Indicates whether the structure was constructed from dynamic memory\n-         * or statically created. *\/\n-        int constructed;\n-        \/* Field definition and arithmetic. *\/\n-        GFMethod *meth;\n-        \/* Textual representation of curve name, if any. *\/\n-        char *text;\n-#ifdef _KERNEL\n-        int text_len;\n-#endif\n-        \/* Curve parameters, field-encoded. *\/\n-        mp_int curvea, curveb;\n-        \/* x and y coordinates of the base point, field-encoded. *\/\n-        mp_int genx, geny;\n-        \/* Order and cofactor of the base point. *\/\n-        mp_int order;\n-        int cofactor;\n-        \/* Point arithmetic methods. All methods are assumed to take\n-         * field-encoded parameters and return field-encoded values. All\n-         * methods (except base_point_mul and points_mul) are required to be\n-         * implemented. *\/\n-        mp_err (*point_add) (const mp_int *px, const mp_int *py,\n-                                                 const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                                 mp_int *ry, const ECGroup *group);\n-        mp_err (*point_sub) (const mp_int *px, const mp_int *py,\n-                                                 const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                                 mp_int *ry, const ECGroup *group);\n-        mp_err (*point_dbl) (const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                 mp_int *ry, const ECGroup *group);\n-        mp_err (*point_mul) (const mp_int *n, const mp_int *px,\n-                                                 const mp_int *py, mp_int *rx, mp_int *ry,\n-                                                 const ECGroup *group, int timing);\n-        mp_err (*base_point_mul) (const mp_int *n, mp_int *rx, mp_int *ry,\n-                                                          const ECGroup *group);\n-        mp_err (*points_mul) (const mp_int *k1, const mp_int *k2,\n-                                                  const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                  mp_int *ry, const ECGroup *group,\n-                                                  int timing);\n-        mp_err (*validate_point) (const mp_int *px, const mp_int *py, const ECGroup *group);\n-        \/* Extra storage for implementation-specific data.  Any memory\n-         * allocated to these extra fields will be cleared by extra_free. *\/\n-        void *extra1;\n-        void *extra2;\n-        void (*extra_free) (ECGroup *group);\n-};\n-\n-\/* Wrapper functions for generic prime field arithmetic. *\/\n-mp_err ec_GFp_add(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_neg(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GFp_sub(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-\n-\/* fixed length in-line adds. Count is in words *\/\n-mp_err ec_GFp_add_3(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_add_4(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_add_5(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_add_6(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_sub_3(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_sub_4(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_sub_5(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_sub_6(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-\n-mp_err ec_GFp_mod(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GFp_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-mp_err ec_GFp_sqr(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GFp_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                                  const GFMethod *meth);\n-\/* Wrapper functions for generic binary polynomial field arithmetic. *\/\n-mp_err ec_GF2m_add(const mp_int *a, const mp_int *b, mp_int *r,\n-                                   const GFMethod *meth);\n-mp_err ec_GF2m_neg(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GF2m_mod(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GF2m_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                   const GFMethod *meth);\n-mp_err ec_GF2m_sqr(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GF2m_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                                   const GFMethod *meth);\n-\n-\/* Montgomery prime field arithmetic. *\/\n-mp_err ec_GFp_mul_mont(const mp_int *a, const mp_int *b, mp_int *r,\n-                                           const GFMethod *meth);\n-mp_err ec_GFp_sqr_mont(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GFp_div_mont(const mp_int *a, const mp_int *b, mp_int *r,\n-                                           const GFMethod *meth);\n-mp_err ec_GFp_enc_mont(const mp_int *a, mp_int *r, const GFMethod *meth);\n-mp_err ec_GFp_dec_mont(const mp_int *a, mp_int *r, const GFMethod *meth);\n-void ec_GFp_extra_free_mont(GFMethod *meth);\n-\n-\/* point multiplication *\/\n-mp_err ec_pts_mul_basic(const mp_int *k1, const mp_int *k2,\n-                                                const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                mp_int *ry, const ECGroup *group,\n-                                                int timing);\n-mp_err ec_pts_mul_simul_w2(const mp_int *k1, const mp_int *k2,\n-                                                   const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                   mp_int *ry, const ECGroup *group,\n-                                                   int timing);\n-\n-\/* Computes the windowed non-adjacent-form (NAF) of a scalar. Out should\n- * be an array of signed char's to output to, bitsize should be the number\n- * of bits of out, in is the original scalar, and w is the window size.\n- * NAF is discussed in the paper: D. Hankerson, J. Hernandez and A.\n- * Menezes, \"Software implementation of elliptic curve cryptography over\n- * binary fields\", Proc. CHES 2000. *\/\n-mp_err ec_compute_wNAF(signed char *out, int bitsize, const mp_int *in,\n-                                           int w);\n-\n-\/* Optimized field arithmetic *\/\n-mp_err ec_group_set_gfp192(ECGroup *group, ECCurveName);\n-mp_err ec_group_set_gfp224(ECGroup *group, ECCurveName);\n-mp_err ec_group_set_gfp256(ECGroup *group, ECCurveName);\n-mp_err ec_group_set_gfp384(ECGroup *group, ECCurveName);\n-mp_err ec_group_set_gfp521(ECGroup *group, ECCurveName);\n-mp_err ec_group_set_gf2m163(ECGroup *group, ECCurveName name);\n-mp_err ec_group_set_gf2m193(ECGroup *group, ECCurveName name);\n-mp_err ec_group_set_gf2m233(ECGroup *group, ECCurveName name);\n-\n-\/* Optimized floating-point arithmetic *\/\n-#ifdef ECL_USE_FP\n-mp_err ec_group_set_secp160r1_fp(ECGroup *group);\n-mp_err ec_group_set_nistp192_fp(ECGroup *group);\n-mp_err ec_group_set_nistp224_fp(ECGroup *group);\n-#endif\n-\n-#endif \/* _ECL_PRIV_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl-priv.h","additions":0,"deletions":300,"binary":false,"changes":300,"status":"deleted"},{"patch":"@@ -1,454 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"ecl.h\"\n-#include \"ecl-priv.h\"\n-#include \"ec2.h\"\n-#include \"ecp.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#include <string.h>\n-#endif\n-\n-\/* Allocate memory for a new ECGroup object. *\/\n-ECGroup *\n-ECGroup_new(int kmflag)\n-{\n-        mp_err res = MP_OKAY;\n-        ECGroup *group;\n-#ifdef _KERNEL\n-        group = (ECGroup *) kmem_alloc(sizeof(ECGroup), kmflag);\n-#else\n-        group = (ECGroup *) malloc(sizeof(ECGroup));\n-#endif\n-        if (group == NULL)\n-                return NULL;\n-        group->constructed = MP_YES;\n-        group->meth = NULL;\n-        group->text = NULL;\n-        MP_DIGITS(&group->curvea) = 0;\n-        MP_DIGITS(&group->curveb) = 0;\n-        MP_DIGITS(&group->genx) = 0;\n-        MP_DIGITS(&group->geny) = 0;\n-        MP_DIGITS(&group->order) = 0;\n-        group->base_point_mul = NULL;\n-        group->points_mul = NULL;\n-        group->validate_point = NULL;\n-        group->extra1 = NULL;\n-        group->extra2 = NULL;\n-        group->extra_free = NULL;\n-        MP_CHECKOK(mp_init(&group->curvea, kmflag));\n-        MP_CHECKOK(mp_init(&group->curveb, kmflag));\n-        MP_CHECKOK(mp_init(&group->genx, kmflag));\n-        MP_CHECKOK(mp_init(&group->geny, kmflag));\n-        MP_CHECKOK(mp_init(&group->order, kmflag));\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                ECGroup_free(group);\n-                return NULL;\n-        }\n-        return group;\n-}\n-\n-\/* Construct a generic ECGroup for elliptic curves over prime fields. *\/\n-ECGroup *\n-ECGroup_consGFp(const mp_int *irr, const mp_int *curvea,\n-                                const mp_int *curveb, const mp_int *genx,\n-                                const mp_int *geny, const mp_int *order, int cofactor)\n-{\n-        mp_err res = MP_OKAY;\n-        ECGroup *group = NULL;\n-\n-        group = ECGroup_new(FLAG(irr));\n-        if (group == NULL)\n-                return NULL;\n-\n-        group->meth = GFMethod_consGFp(irr);\n-        if (group->meth == NULL) {\n-                res = MP_MEM;\n-                goto CLEANUP;\n-        }\n-        MP_CHECKOK(mp_copy(curvea, &group->curvea));\n-        MP_CHECKOK(mp_copy(curveb, &group->curveb));\n-        MP_CHECKOK(mp_copy(genx, &group->genx));\n-        MP_CHECKOK(mp_copy(geny, &group->geny));\n-        MP_CHECKOK(mp_copy(order, &group->order));\n-        group->cofactor = cofactor;\n-        group->point_add = &ec_GFp_pt_add_aff;\n-        group->point_sub = &ec_GFp_pt_sub_aff;\n-        group->point_dbl = &ec_GFp_pt_dbl_aff;\n-        group->point_mul = &ec_GFp_pt_mul_jm_wNAF;\n-        group->base_point_mul = NULL;\n-        group->points_mul = &ec_GFp_pts_mul_jac;\n-        group->validate_point = &ec_GFp_validate_point;\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                ECGroup_free(group);\n-                return NULL;\n-        }\n-        return group;\n-}\n-\n-\/* Construct a generic ECGroup for elliptic curves over prime fields with\n- * field arithmetic implemented in Montgomery coordinates. *\/\n-ECGroup *\n-ECGroup_consGFp_mont(const mp_int *irr, const mp_int *curvea,\n-                                         const mp_int *curveb, const mp_int *genx,\n-                                         const mp_int *geny, const mp_int *order, int cofactor)\n-{\n-        mp_err res = MP_OKAY;\n-        ECGroup *group = NULL;\n-\n-        group = ECGroup_new(FLAG(irr));\n-        if (group == NULL)\n-                return NULL;\n-\n-        group->meth = GFMethod_consGFp_mont(irr);\n-        if (group->meth == NULL) {\n-                res = MP_MEM;\n-                goto CLEANUP;\n-        }\n-        MP_CHECKOK(group->meth->\n-                           field_enc(curvea, &group->curvea, group->meth));\n-        MP_CHECKOK(group->meth->\n-                           field_enc(curveb, &group->curveb, group->meth));\n-        MP_CHECKOK(group->meth->field_enc(genx, &group->genx, group->meth));\n-        MP_CHECKOK(group->meth->field_enc(geny, &group->geny, group->meth));\n-        MP_CHECKOK(mp_copy(order, &group->order));\n-        group->cofactor = cofactor;\n-        group->point_add = &ec_GFp_pt_add_aff;\n-        group->point_sub = &ec_GFp_pt_sub_aff;\n-        group->point_dbl = &ec_GFp_pt_dbl_aff;\n-        group->point_mul = &ec_GFp_pt_mul_jm_wNAF;\n-        group->base_point_mul = NULL;\n-        group->points_mul = &ec_GFp_pts_mul_jac;\n-        group->validate_point = &ec_GFp_validate_point;\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                ECGroup_free(group);\n-                return NULL;\n-        }\n-        return group;\n-}\n-\n-#ifdef NSS_ECC_MORE_THAN_SUITE_B\n-\/* Construct a generic ECGroup for elliptic curves over binary polynomial\n- * fields. *\/\n-ECGroup *\n-ECGroup_consGF2m(const mp_int *irr, const unsigned int irr_arr[5],\n-                                 const mp_int *curvea, const mp_int *curveb,\n-                                 const mp_int *genx, const mp_int *geny,\n-                                 const mp_int *order, int cofactor)\n-{\n-        mp_err res = MP_OKAY;\n-        ECGroup *group = NULL;\n-\n-        group = ECGroup_new(FLAG(irr));\n-        if (group == NULL)\n-                return NULL;\n-\n-        group->meth = GFMethod_consGF2m(irr, irr_arr);\n-        if (group->meth == NULL) {\n-                res = MP_MEM;\n-                goto CLEANUP;\n-        }\n-        MP_CHECKOK(mp_copy(curvea, &group->curvea));\n-        MP_CHECKOK(mp_copy(curveb, &group->curveb));\n-        MP_CHECKOK(mp_copy(genx, &group->genx));\n-        MP_CHECKOK(mp_copy(geny, &group->geny));\n-        MP_CHECKOK(mp_copy(order, &group->order));\n-        group->cofactor = cofactor;\n-        group->point_add = &ec_GF2m_pt_add_aff;\n-        group->point_sub = &ec_GF2m_pt_sub_aff;\n-        group->point_dbl = &ec_GF2m_pt_dbl_aff;\n-        group->point_mul = &ec_GF2m_pt_mul_mont;\n-        group->base_point_mul = NULL;\n-        group->points_mul = &ec_pts_mul_basic;\n-        group->validate_point = &ec_GF2m_validate_point;\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                ECGroup_free(group);\n-                return NULL;\n-        }\n-        return group;\n-}\n-#endif\n-\n-\/* Construct ECGroup from hex parameters and name, if any. Called by\n- * ECGroup_fromHex and ECGroup_fromName. *\/\n-ECGroup *\n-ecgroup_fromNameAndHex(const ECCurveName name,\n-                                   const ECCurveParams * params, int kmflag)\n-{\n-        mp_int irr, curvea, curveb, genx, geny, order;\n-        int bits;\n-        ECGroup *group = NULL;\n-        mp_err res = MP_OKAY;\n-\n-        \/* initialize values *\/\n-        MP_DIGITS(&irr) = 0;\n-        MP_DIGITS(&curvea) = 0;\n-        MP_DIGITS(&curveb) = 0;\n-        MP_DIGITS(&genx) = 0;\n-        MP_DIGITS(&geny) = 0;\n-        MP_DIGITS(&order) = 0;\n-        MP_CHECKOK(mp_init(&irr, kmflag));\n-        MP_CHECKOK(mp_init(&curvea, kmflag));\n-        MP_CHECKOK(mp_init(&curveb, kmflag));\n-        MP_CHECKOK(mp_init(&genx, kmflag));\n-        MP_CHECKOK(mp_init(&geny, kmflag));\n-        MP_CHECKOK(mp_init(&order, kmflag));\n-        MP_CHECKOK(mp_read_radix(&irr, params->irr, 16));\n-        MP_CHECKOK(mp_read_radix(&curvea, params->curvea, 16));\n-        MP_CHECKOK(mp_read_radix(&curveb, params->curveb, 16));\n-        MP_CHECKOK(mp_read_radix(&genx, params->genx, 16));\n-        MP_CHECKOK(mp_read_radix(&geny, params->geny, 16));\n-        MP_CHECKOK(mp_read_radix(&order, params->order, 16));\n-\n-        \/* determine number of bits *\/\n-        bits = mpl_significant_bits(&irr) - 1;\n-        if (bits < MP_OKAY) {\n-                res = bits;\n-                goto CLEANUP;\n-        }\n-\n-        \/* determine which optimizations (if any) to use *\/\n-        if (params->field == ECField_GFp) {\n-#ifdef NSS_ECC_MORE_THAN_SUITE_B\n-            switch (name) {\n-#ifdef ECL_USE_FP\n-                case ECCurve_SECG_PRIME_160R1:\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_secp160r1_fp(group));\n-                        break;\n-#endif\n-                case ECCurve_SECG_PRIME_192R1:\n-#ifdef ECL_USE_FP\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_nistp192_fp(group));\n-#else\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_gfp192(group, name));\n-#endif\n-                        break;\n-                case ECCurve_SECG_PRIME_224R1:\n-#ifdef ECL_USE_FP\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_nistp224_fp(group));\n-#else\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_gfp224(group, name));\n-#endif\n-                        break;\n-                case ECCurve_SECG_PRIME_256R1:\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_gfp256(group, name));\n-                        break;\n-                case ECCurve_SECG_PRIME_521R1:\n-                        group =\n-                                ECGroup_consGFp(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                        MP_CHECKOK(ec_group_set_gfp521(group, name));\n-                        break;\n-                default:\n-                        \/* use generic arithmetic *\/\n-#endif\n-                        group =\n-                                ECGroup_consGFp_mont(&irr, &curvea, &curveb, &genx, &geny,\n-                                                                         &order, params->cofactor);\n-                        if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-#ifdef NSS_ECC_MORE_THAN_SUITE_B\n-                }\n-        } else if (params->field == ECField_GF2m) {\n-                group = ECGroup_consGF2m(&irr, NULL, &curvea, &curveb, &genx, &geny, &order, params->cofactor);\n-                if (group == NULL) { res = MP_UNDEF; goto CLEANUP; }\n-                if ((name == ECCurve_NIST_K163) ||\n-                    (name == ECCurve_NIST_B163) ||\n-                    (name == ECCurve_SECG_CHAR2_163R1)) {\n-                        MP_CHECKOK(ec_group_set_gf2m163(group, name));\n-                } else if ((name == ECCurve_SECG_CHAR2_193R1) ||\n-                           (name == ECCurve_SECG_CHAR2_193R2)) {\n-                        MP_CHECKOK(ec_group_set_gf2m193(group, name));\n-                } else if ((name == ECCurve_NIST_K233) ||\n-                           (name == ECCurve_NIST_B233)) {\n-                        MP_CHECKOK(ec_group_set_gf2m233(group, name));\n-                }\n-#endif\n-        } else {\n-                res = MP_UNDEF;\n-                goto CLEANUP;\n-        }\n-\n-        \/* set name, if any *\/\n-        if ((group != NULL) && (params->text != NULL)) {\n-#ifdef _KERNEL\n-                int n = strlen(params->text) + 1;\n-\n-                group->text = kmem_alloc(n, kmflag);\n-                if (group->text == NULL) {\n-                        res = MP_MEM;\n-                        goto CLEANUP;\n-                }\n-                bcopy(params->text, group->text, n);\n-                group->text_len = n;\n-#else\n-                group->text = strdup(params->text);\n-                if (group->text == NULL) {\n-                        res = MP_MEM;\n-                }\n-#endif\n-        }\n-\n-  CLEANUP:\n-        mp_clear(&irr);\n-        mp_clear(&curvea);\n-        mp_clear(&curveb);\n-        mp_clear(&genx);\n-        mp_clear(&geny);\n-        mp_clear(&order);\n-        if (res != MP_OKAY) {\n-                ECGroup_free(group);\n-                return NULL;\n-        }\n-        return group;\n-}\n-\n-\/* Construct ECGroup from hexadecimal representations of parameters. *\/\n-ECGroup *\n-ECGroup_fromHex(const ECCurveParams * params, int kmflag)\n-{\n-        return ecgroup_fromNameAndHex(ECCurve_noName, params, kmflag);\n-}\n-\n-\/* Construct ECGroup from named parameters. *\/\n-ECGroup *\n-ECGroup_fromName(const ECCurveName name, int kmflag)\n-{\n-        ECGroup *group = NULL;\n-        ECCurveParams *params = NULL;\n-        mp_err res = MP_OKAY;\n-\n-        params = EC_GetNamedCurveParams(name, kmflag);\n-        if (params == NULL) {\n-                res = MP_UNDEF;\n-                goto CLEANUP;\n-        }\n-\n-        \/* construct actual group *\/\n-        group = ecgroup_fromNameAndHex(name, params, kmflag);\n-        if (group == NULL) {\n-                res = MP_UNDEF;\n-                goto CLEANUP;\n-        }\n-\n-  CLEANUP:\n-        EC_FreeCurveParams(params);\n-        if (res != MP_OKAY) {\n-                ECGroup_free(group);\n-                return NULL;\n-        }\n-        return group;\n-}\n-\n-\/* Validates an EC public key as described in Section 5.2.2 of X9.62. *\/\n-mp_err ECPoint_validate(const ECGroup *group, const mp_int *px, const\n-                                        mp_int *py)\n-{\n-    \/* 1: Verify that publicValue is not the point at infinity *\/\n-    \/* 2: Verify that the coordinates of publicValue are elements\n-     *    of the field.\n-     *\/\n-    \/* 3: Verify that publicValue is on the curve. *\/\n-    \/* 4: Verify that the order of the curve times the publicValue\n-     *    is the point at infinity.\n-     *\/\n-        return group->validate_point(px, py, group);\n-}\n-\n-\/* Free the memory allocated (if any) to an ECGroup object. *\/\n-void\n-ECGroup_free(ECGroup *group)\n-{\n-        if (group == NULL)\n-                return;\n-        GFMethod_free(group->meth);\n-        if (group->constructed == MP_NO)\n-                return;\n-        mp_clear(&group->curvea);\n-        mp_clear(&group->curveb);\n-        mp_clear(&group->genx);\n-        mp_clear(&group->geny);\n-        mp_clear(&group->order);\n-        if (group->text != NULL)\n-#ifdef _KERNEL\n-                kmem_free(group->text, group->text_len);\n-#else\n-                free(group->text);\n-#endif\n-        if (group->extra_free != NULL)\n-                group->extra_free(group);\n-#ifdef _KERNEL\n-        kmem_free(group, sizeof (ECGroup));\n-#else\n-        free(group);\n-#endif\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl.c","additions":0,"deletions":454,"binary":false,"changes":454,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#ifndef _ECL_H\n-#define _ECL_H\n-\n-\/* Although this is not an exported header file, code which uses elliptic\n- * curve point operations will need to include it. *\/\n-\n-#include \"ecl-exp.h\"\n-#include \"mpi.h\"\n-\n-struct ECGroupStr;\n-typedef struct ECGroupStr ECGroup;\n-\n-\/* Construct ECGroup from hexadecimal representations of parameters. *\/\n-ECGroup *ECGroup_fromHex(const ECCurveParams * params, int kmflag);\n-\n-\/* Construct ECGroup from named parameters. *\/\n-ECGroup *ECGroup_fromName(const ECCurveName name, int kmflag);\n-\n-\/* Free an allocated ECGroup. *\/\n-void ECGroup_free(ECGroup *group);\n-\n-\/* Construct ECCurveParams from an ECCurveName *\/\n-ECCurveParams *EC_GetNamedCurveParams(const ECCurveName name, int kmflag);\n-\n-\/* Duplicates an ECCurveParams *\/\n-ECCurveParams *ECCurveParams_dup(const ECCurveParams * params, int kmflag);\n-\n-\/* Free an allocated ECCurveParams *\/\n-void EC_FreeCurveParams(ECCurveParams * params);\n-\n-\/* Elliptic curve scalar-point multiplication. Computes Q(x, y) = k * P(x,\n- * y).  If x, y = NULL, then P is assumed to be the generator (base point)\n- * of the group of points on the elliptic curve. Input and output values\n- * are assumed to be NOT field-encoded. *\/\n-mp_err ECPoint_mul(const ECGroup *group, const mp_int *k, const mp_int *px,\n-                                   const mp_int *py, mp_int *qx, mp_int *qy,\n-                                   int timing);\n-\n-\/* Elliptic curve scalar-point multiplication. Computes Q(x, y) = k1 * G +\n- * k2 * P(x, y), where G is the generator (base point) of the group of\n- * points on the elliptic curve. Input and output values are assumed to\n- * be NOT field-encoded. *\/\n-mp_err ECPoints_mul(const ECGroup *group, const mp_int *k1,\n-                                        const mp_int *k2, const mp_int *px, const mp_int *py,\n-                                        mp_int *qx, mp_int *qy, int timing);\n-\n-\/* Validates an EC public key as described in Section 5.2.2 of X9.62.\n- * Returns MP_YES if the public key is valid, MP_NO if the public key\n- * is invalid, or an error code if the validation could not be\n- * performed. *\/\n-mp_err ECPoint_validate(const ECGroup *group, const mp_int *px, const\n-                                        mp_int *py);\n-\n-#endif \/* _ECL_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl.h","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecl.h\"\n-#include \"ecl-curve.h\"\n-#include \"ecl-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#include <string.h>\n-#endif\n-\n-#define CHECK(func) if ((func) == NULL) { res = 0; goto CLEANUP; }\n-\n-\/* Duplicates an ECCurveParams *\/\n-ECCurveParams *\n-ECCurveParams_dup(const ECCurveParams * params, int kmflag)\n-{\n-        int res = 1;\n-        ECCurveParams *ret = NULL;\n-\n-#ifdef _KERNEL\n-        ret = (ECCurveParams *) kmem_zalloc(sizeof(ECCurveParams), kmflag);\n-#else\n-        CHECK(ret = (ECCurveParams *) calloc(1, sizeof(ECCurveParams)));\n-#endif\n-        if (params->text != NULL) {\n-#ifdef _KERNEL\n-                ret->text = kmem_alloc(strlen(params->text) + 1, kmflag);\n-                bcopy(params->text, ret->text, strlen(params->text) + 1);\n-#else\n-                CHECK(ret->text = strdup(params->text));\n-#endif\n-        }\n-        ret->field = params->field;\n-        ret->size = params->size;\n-        if (params->irr != NULL) {\n-#ifdef _KERNEL\n-                ret->irr = kmem_alloc(strlen(params->irr) + 1, kmflag);\n-                bcopy(params->irr, ret->irr, strlen(params->irr) + 1);\n-#else\n-                CHECK(ret->irr = strdup(params->irr));\n-#endif\n-        }\n-        if (params->curvea != NULL) {\n-#ifdef _KERNEL\n-                ret->curvea = kmem_alloc(strlen(params->curvea) + 1, kmflag);\n-                bcopy(params->curvea, ret->curvea, strlen(params->curvea) + 1);\n-#else\n-                CHECK(ret->curvea = strdup(params->curvea));\n-#endif\n-        }\n-        if (params->curveb != NULL) {\n-#ifdef _KERNEL\n-                ret->curveb = kmem_alloc(strlen(params->curveb) + 1, kmflag);\n-                bcopy(params->curveb, ret->curveb, strlen(params->curveb) + 1);\n-#else\n-                CHECK(ret->curveb = strdup(params->curveb));\n-#endif\n-        }\n-        if (params->genx != NULL) {\n-#ifdef _KERNEL\n-                ret->genx = kmem_alloc(strlen(params->genx) + 1, kmflag);\n-                bcopy(params->genx, ret->genx, strlen(params->genx) + 1);\n-#else\n-                CHECK(ret->genx = strdup(params->genx));\n-#endif\n-        }\n-        if (params->geny != NULL) {\n-#ifdef _KERNEL\n-                ret->geny = kmem_alloc(strlen(params->geny) + 1, kmflag);\n-                bcopy(params->geny, ret->geny, strlen(params->geny) + 1);\n-#else\n-                CHECK(ret->geny = strdup(params->geny));\n-#endif\n-        }\n-        if (params->order != NULL) {\n-#ifdef _KERNEL\n-                ret->order = kmem_alloc(strlen(params->order) + 1, kmflag);\n-                bcopy(params->order, ret->order, strlen(params->order) + 1);\n-#else\n-                CHECK(ret->order = strdup(params->order));\n-#endif\n-        }\n-        ret->cofactor = params->cofactor;\n-\n-  CLEANUP:\n-        if (res != 1) {\n-                EC_FreeCurveParams(ret);\n-                return NULL;\n-        }\n-        return ret;\n-}\n-\n-#undef CHECK\n-\n-\/* Construct ECCurveParams from an ECCurveName *\/\n-ECCurveParams *\n-EC_GetNamedCurveParams(const ECCurveName name, int kmflag)\n-{\n-        if ((name <= ECCurve_noName) || (ECCurve_pastLastCurve <= name) ||\n-                                        (ecCurve_map[name] == NULL)) {\n-                return NULL;\n-        } else {\n-                return ECCurveParams_dup(ecCurve_map[name], kmflag);\n-        }\n-}\n-\n-\/* Free the memory allocated (if any) to an ECCurveParams object. *\/\n-void\n-EC_FreeCurveParams(ECCurveParams * params)\n-{\n-        if (params == NULL)\n-                return;\n-        if (params->text != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->text, strlen(params->text) + 1);\n-#else\n-                free(params->text);\n-#endif\n-        if (params->irr != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->irr, strlen(params->irr) + 1);\n-#else\n-                free(params->irr);\n-#endif\n-        if (params->curvea != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->curvea, strlen(params->curvea) + 1);\n-#else\n-                free(params->curvea);\n-#endif\n-        if (params->curveb != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->curveb, strlen(params->curveb) + 1);\n-#else\n-                free(params->curveb);\n-#endif\n-        if (params->genx != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->genx, strlen(params->genx) + 1);\n-#else\n-                free(params->genx);\n-#endif\n-        if (params->geny != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->geny, strlen(params->geny) + 1);\n-#else\n-                free(params->geny);\n-#endif\n-        if (params->order != NULL)\n-#ifdef _KERNEL\n-                kmem_free(params->order, strlen(params->order) + 1);\n-#else\n-                free(params->order);\n-#endif\n-#ifdef _KERNEL\n-        kmem_free(params, sizeof(ECCurveParams));\n-#else\n-        free(params);\n-#endif\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl_curve.c","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -1,1043 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Stephen Fung <fungstep@hotmail.com> and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#include \"mpi.h\"\n-#include \"mp_gf2m.h\"\n-#include \"ecl-priv.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Allocate memory for a new GFMethod object. *\/\n-GFMethod *\n-GFMethod_new(int kmflag)\n-{\n-        mp_err res = MP_OKAY;\n-        GFMethod *meth;\n-#ifdef _KERNEL\n-        meth = (GFMethod *) kmem_alloc(sizeof(GFMethod), kmflag);\n-#else\n-        meth = (GFMethod *) malloc(sizeof(GFMethod));\n-        if (meth == NULL)\n-                return NULL;\n-#endif\n-        meth->constructed = MP_YES;\n-        MP_DIGITS(&meth->irr) = 0;\n-        meth->extra_free = NULL;\n-        MP_CHECKOK(mp_init(&meth->irr, kmflag));\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                GFMethod_free(meth);\n-                return NULL;\n-        }\n-        return meth;\n-}\n-\n-\/* Construct a generic GFMethod for arithmetic over prime fields with\n- * irreducible irr. *\/\n-GFMethod *\n-GFMethod_consGFp(const mp_int *irr)\n-{\n-        mp_err res = MP_OKAY;\n-        GFMethod *meth = NULL;\n-\n-        meth = GFMethod_new(FLAG(irr));\n-        if (meth == NULL)\n-                return NULL;\n-\n-        MP_CHECKOK(mp_copy(irr, &meth->irr));\n-        meth->irr_arr[0] = mpl_significant_bits(irr);\n-        meth->irr_arr[1] = meth->irr_arr[2] = meth->irr_arr[3] =\n-                meth->irr_arr[4] = 0;\n-        switch(MP_USED(&meth->irr)) {\n-        \/* maybe we need 1 and 2 words here as well?*\/\n-        case 3:\n-                meth->field_add = &ec_GFp_add_3;\n-                meth->field_sub = &ec_GFp_sub_3;\n-                break;\n-        case 4:\n-                meth->field_add = &ec_GFp_add_4;\n-                meth->field_sub = &ec_GFp_sub_4;\n-                break;\n-        case 5:\n-                meth->field_add = &ec_GFp_add_5;\n-                meth->field_sub = &ec_GFp_sub_5;\n-                break;\n-        case 6:\n-                meth->field_add = &ec_GFp_add_6;\n-                meth->field_sub = &ec_GFp_sub_6;\n-                break;\n-        default:\n-                meth->field_add = &ec_GFp_add;\n-                meth->field_sub = &ec_GFp_sub;\n-        }\n-        meth->field_neg = &ec_GFp_neg;\n-        meth->field_mod = &ec_GFp_mod;\n-        meth->field_mul = &ec_GFp_mul;\n-        meth->field_sqr = &ec_GFp_sqr;\n-        meth->field_div = &ec_GFp_div;\n-        meth->field_enc = NULL;\n-        meth->field_dec = NULL;\n-        meth->extra1 = NULL;\n-        meth->extra2 = NULL;\n-        meth->extra_free = NULL;\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                GFMethod_free(meth);\n-                return NULL;\n-        }\n-        return meth;\n-}\n-\n-\/* Construct a generic GFMethod for arithmetic over binary polynomial\n- * fields with irreducible irr that has array representation irr_arr (see\n- * ecl-priv.h for description of the representation).  If irr_arr is NULL,\n- * then it is constructed from the bitstring representation. *\/\n-GFMethod *\n-GFMethod_consGF2m(const mp_int *irr, const unsigned int irr_arr[5])\n-{\n-        mp_err res = MP_OKAY;\n-        int ret;\n-        GFMethod *meth = NULL;\n-\n-        meth = GFMethod_new(FLAG(irr));\n-        if (meth == NULL)\n-                return NULL;\n-\n-        MP_CHECKOK(mp_copy(irr, &meth->irr));\n-        if (irr_arr != NULL) {\n-                \/* Irreducible polynomials are either trinomials or pentanomials. *\/\n-                meth->irr_arr[0] = irr_arr[0];\n-                meth->irr_arr[1] = irr_arr[1];\n-                meth->irr_arr[2] = irr_arr[2];\n-                if (irr_arr[2] > 0) {\n-                        meth->irr_arr[3] = irr_arr[3];\n-                        meth->irr_arr[4] = irr_arr[4];\n-                } else {\n-                        meth->irr_arr[3] = meth->irr_arr[4] = 0;\n-                }\n-        } else {\n-                ret = mp_bpoly2arr(irr, meth->irr_arr, 5);\n-                \/* Irreducible polynomials are either trinomials or pentanomials. *\/\n-                if ((ret != 5) && (ret != 3)) {\n-                        res = MP_UNDEF;\n-                        goto CLEANUP;\n-                }\n-        }\n-        meth->field_add = &ec_GF2m_add;\n-        meth->field_neg = &ec_GF2m_neg;\n-        meth->field_sub = &ec_GF2m_add;\n-        meth->field_mod = &ec_GF2m_mod;\n-        meth->field_mul = &ec_GF2m_mul;\n-        meth->field_sqr = &ec_GF2m_sqr;\n-        meth->field_div = &ec_GF2m_div;\n-        meth->field_enc = NULL;\n-        meth->field_dec = NULL;\n-        meth->extra1 = NULL;\n-        meth->extra2 = NULL;\n-        meth->extra_free = NULL;\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                GFMethod_free(meth);\n-                return NULL;\n-        }\n-        return meth;\n-}\n-\n-\/* Free the memory allocated (if any) to a GFMethod object. *\/\n-void\n-GFMethod_free(GFMethod *meth)\n-{\n-        if (meth == NULL)\n-                return;\n-        if (meth->constructed == MP_NO)\n-                return;\n-        mp_clear(&meth->irr);\n-        if (meth->extra_free != NULL)\n-                meth->extra_free(meth);\n-#ifdef _KERNEL\n-        kmem_free(meth, sizeof(GFMethod));\n-#else\n-        free(meth);\n-#endif\n-}\n-\n-\/* Wrapper functions for generic prime field arithmetic. *\/\n-\n-\/* Add two field elements.  Assumes that 0 <= a, b < meth->irr *\/\n-mp_err\n-ec_GFp_add(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        \/* PRE: 0 <= a, b < p = meth->irr POST: 0 <= r < p, r = a + b (mod p) *\/\n-        mp_err res;\n-\n-        if ((res = mp_add(a, b, r)) != MP_OKAY) {\n-                return res;\n-        }\n-        if (mp_cmp(r, &meth->irr) >= 0) {\n-                return mp_sub(r, &meth->irr, r);\n-        }\n-        return res;\n-}\n-\n-\/* Negates a field element.  Assumes that 0 <= a < meth->irr *\/\n-mp_err\n-ec_GFp_neg(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        \/* PRE: 0 <= a < p = meth->irr POST: 0 <= r < p, r = -a (mod p) *\/\n-\n-        if (mp_cmp_z(a) == 0) {\n-                mp_zero(r);\n-                return MP_OKAY;\n-        }\n-        return mp_sub(&meth->irr, a, r);\n-}\n-\n-\/* Subtracts two field elements.  Assumes that 0 <= a, b < meth->irr *\/\n-mp_err\n-ec_GFp_sub(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        \/* PRE: 0 <= a, b < p = meth->irr POST: 0 <= r < p, r = a - b (mod p) *\/\n-        res = mp_sub(a, b, r);\n-        if (res == MP_RANGE) {\n-                MP_CHECKOK(mp_sub(b, a, r));\n-                if (mp_cmp_z(r) < 0) {\n-                        MP_CHECKOK(mp_add(r, &meth->irr, r));\n-                }\n-                MP_CHECKOK(ec_GFp_neg(r, r, meth));\n-        }\n-        if (mp_cmp_z(r) < 0) {\n-                MP_CHECKOK(mp_add(r, &meth->irr, r));\n-        }\n-  CLEANUP:\n-        return res;\n-}\n-\/*\n- * Inline adds for small curve lengths.\n- *\/\n-\/* 3 words *\/\n-mp_err\n-ec_GFp_add_3(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a0 = 0, a1 = 0, a2 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0;\n-        mp_digit carry;\n-\n-        switch(MP_USED(a)) {\n-        case 3:\n-                a2 = MP_DIGIT(a,2);\n-        case 2:\n-                a1 = MP_DIGIT(a,1);\n-        case 1:\n-                a0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 3:\n-                r2 = MP_DIGIT(b,2);\n-        case 2:\n-                r1 = MP_DIGIT(b,1);\n-        case 1:\n-                r0 = MP_DIGIT(b,0);\n-        }\n-\n-#ifndef MPI_AMD64_ADD\n-        MP_ADD_CARRY_ZERO(a0, r0, r0, carry);\n-        MP_ADD_CARRY(a1, r1, r1, carry, carry);\n-        MP_ADD_CARRY(a2, r2, r2, carry, carry);\n-#else\n-        __asm__ (\n-                \"xorq   %3,%3           \\n\\t\"\n-                \"addq   %4,%0           \\n\\t\"\n-                \"adcq   %5,%1           \\n\\t\"\n-                \"adcq   %6,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(carry)\n-                : \"r\" (a0), \"r\" (a1), \"r\" (a2),\n-                  \"0\" (r0), \"1\" (r1), \"2\" (r2)\n-                : \"%cc\" );\n-#endif\n-\n-        MP_CHECKOK(s_mp_pad(r, 3));\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 3;\n-\n-        \/* Do quick 'subract' if we've gone over\n-         * (add the 2's complement of the curve field) *\/\n-         a2 = MP_DIGIT(&meth->irr,2);\n-        if (carry ||  r2 >  a2 ||\n-                ((r2 == a2) && mp_cmp(r,&meth->irr) != MP_LT)) {\n-                a1 = MP_DIGIT(&meth->irr,1);\n-                a0 = MP_DIGIT(&meth->irr,0);\n-#ifndef MPI_AMD64_ADD\n-                MP_SUB_BORROW(r0, a0, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a1, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a2, r2, carry, carry);\n-#else\n-                __asm__ (\n-                        \"subq   %3,%0           \\n\\t\"\n-                        \"sbbq   %4,%1           \\n\\t\"\n-                        \"sbbq   %5,%2           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2)\n-                        : \"r\" (a0), \"r\" (a1), \"r\" (a2),\n-                          \"0\" (r0), \"1\" (r1), \"2\" (r2)\n-                        : \"%cc\" );\n-#endif\n-                MP_DIGIT(r, 2) = r2;\n-                MP_DIGIT(r, 1) = r1;\n-                MP_DIGIT(r, 0) = r0;\n-        }\n-\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* 4 words *\/\n-mp_err\n-ec_GFp_add_4(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a0 = 0, a1 = 0, a2 = 0, a3 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0, r3 = 0;\n-        mp_digit carry;\n-\n-        switch(MP_USED(a)) {\n-        case 4:\n-                a3 = MP_DIGIT(a,3);\n-        case 3:\n-                a2 = MP_DIGIT(a,2);\n-        case 2:\n-                a1 = MP_DIGIT(a,1);\n-        case 1:\n-                a0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 4:\n-                r3 = MP_DIGIT(b,3);\n-        case 3:\n-                r2 = MP_DIGIT(b,2);\n-        case 2:\n-                r1 = MP_DIGIT(b,1);\n-        case 1:\n-                r0 = MP_DIGIT(b,0);\n-        }\n-\n-#ifndef MPI_AMD64_ADD\n-        MP_ADD_CARRY_ZERO(a0, r0, r0, carry);\n-        MP_ADD_CARRY(a1, r1, r1, carry, carry);\n-        MP_ADD_CARRY(a2, r2, r2, carry, carry);\n-        MP_ADD_CARRY(a3, r3, r3, carry, carry);\n-#else\n-        __asm__ (\n-                \"xorq   %4,%4           \\n\\t\"\n-                \"addq   %5,%0           \\n\\t\"\n-                \"adcq   %6,%1           \\n\\t\"\n-                \"adcq   %7,%2           \\n\\t\"\n-                \"adcq   %8,%3           \\n\\t\"\n-                \"adcq   $0,%4           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(r3), \"=r\"(carry)\n-                : \"r\" (a0), \"r\" (a1), \"r\" (a2), \"r\" (a3),\n-                  \"0\" (r0), \"1\" (r1), \"2\" (r2), \"3\" (r3)\n-                : \"%cc\" );\n-#endif\n-\n-        MP_CHECKOK(s_mp_pad(r, 4));\n-        MP_DIGIT(r, 3) = r3;\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 4;\n-\n-        \/* Do quick 'subract' if we've gone over\n-         * (add the 2's complement of the curve field) *\/\n-         a3 = MP_DIGIT(&meth->irr,3);\n-        if (carry ||  r3 >  a3 ||\n-                ((r3 == a3) && mp_cmp(r,&meth->irr) != MP_LT)) {\n-                a2 = MP_DIGIT(&meth->irr,2);\n-                a1 = MP_DIGIT(&meth->irr,1);\n-                a0 = MP_DIGIT(&meth->irr,0);\n-#ifndef MPI_AMD64_ADD\n-                MP_SUB_BORROW(r0, a0, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a1, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a2, r2, carry, carry);\n-                MP_SUB_BORROW(r3, a3, r3, carry, carry);\n-#else\n-                __asm__ (\n-                        \"subq   %4,%0           \\n\\t\"\n-                        \"sbbq   %5,%1           \\n\\t\"\n-                        \"sbbq   %6,%2           \\n\\t\"\n-                        \"sbbq   %7,%3           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(r3)\n-                        : \"r\" (a0), \"r\" (a1), \"r\" (a2), \"r\" (a3),\n-                          \"0\" (r0), \"1\" (r1), \"2\" (r2), \"3\" (r3)\n-                        : \"%cc\" );\n-#endif\n-                MP_DIGIT(r, 3) = r3;\n-                MP_DIGIT(r, 2) = r2;\n-                MP_DIGIT(r, 1) = r1;\n-                MP_DIGIT(r, 0) = r0;\n-        }\n-\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* 5 words *\/\n-mp_err\n-ec_GFp_add_5(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0, r3 = 0, r4 = 0;\n-        mp_digit carry;\n-\n-        switch(MP_USED(a)) {\n-        case 5:\n-                a4 = MP_DIGIT(a,4);\n-        case 4:\n-                a3 = MP_DIGIT(a,3);\n-        case 3:\n-                a2 = MP_DIGIT(a,2);\n-        case 2:\n-                a1 = MP_DIGIT(a,1);\n-        case 1:\n-                a0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 5:\n-                r4 = MP_DIGIT(b,4);\n-        case 4:\n-                r3 = MP_DIGIT(b,3);\n-        case 3:\n-                r2 = MP_DIGIT(b,2);\n-        case 2:\n-                r1 = MP_DIGIT(b,1);\n-        case 1:\n-                r0 = MP_DIGIT(b,0);\n-        }\n-\n-        MP_ADD_CARRY_ZERO(a0, r0, r0, carry);\n-        MP_ADD_CARRY(a1, r1, r1, carry, carry);\n-        MP_ADD_CARRY(a2, r2, r2, carry, carry);\n-        MP_ADD_CARRY(a3, r3, r3, carry, carry);\n-        MP_ADD_CARRY(a4, r4, r4, carry, carry);\n-\n-        MP_CHECKOK(s_mp_pad(r, 5));\n-        MP_DIGIT(r, 4) = r4;\n-        MP_DIGIT(r, 3) = r3;\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 5;\n-\n-        \/* Do quick 'subract' if we've gone over\n-         * (add the 2's complement of the curve field) *\/\n-         a4 = MP_DIGIT(&meth->irr,4);\n-        if (carry ||  r4 >  a4 ||\n-                ((r4 == a4) && mp_cmp(r,&meth->irr) != MP_LT)) {\n-                a3 = MP_DIGIT(&meth->irr,3);\n-                a2 = MP_DIGIT(&meth->irr,2);\n-                a1 = MP_DIGIT(&meth->irr,1);\n-                a0 = MP_DIGIT(&meth->irr,0);\n-                MP_SUB_BORROW(r0, a0, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a1, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a2, r2, carry, carry);\n-                MP_SUB_BORROW(r3, a3, r3, carry, carry);\n-                MP_SUB_BORROW(r4, a4, r4, carry, carry);\n-                MP_DIGIT(r, 4) = r4;\n-                MP_DIGIT(r, 3) = r3;\n-                MP_DIGIT(r, 2) = r2;\n-                MP_DIGIT(r, 1) = r1;\n-                MP_DIGIT(r, 0) = r0;\n-        }\n-\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* 6 words *\/\n-mp_err\n-ec_GFp_add_6(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a0 = 0, a1 = 0, a2 = 0, a3 = 0, a4 = 0, a5 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0, r3 = 0, r4 = 0, r5 = 0;\n-        mp_digit carry;\n-\n-        switch(MP_USED(a)) {\n-        case 6:\n-                a5 = MP_DIGIT(a,5);\n-        case 5:\n-                a4 = MP_DIGIT(a,4);\n-        case 4:\n-                a3 = MP_DIGIT(a,3);\n-        case 3:\n-                a2 = MP_DIGIT(a,2);\n-        case 2:\n-                a1 = MP_DIGIT(a,1);\n-        case 1:\n-                a0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 6:\n-                r5 = MP_DIGIT(b,5);\n-        case 5:\n-                r4 = MP_DIGIT(b,4);\n-        case 4:\n-                r3 = MP_DIGIT(b,3);\n-        case 3:\n-                r2 = MP_DIGIT(b,2);\n-        case 2:\n-                r1 = MP_DIGIT(b,1);\n-        case 1:\n-                r0 = MP_DIGIT(b,0);\n-        }\n-\n-        MP_ADD_CARRY_ZERO(a0, r0, r0, carry);\n-        MP_ADD_CARRY(a1, r1, r1, carry, carry);\n-        MP_ADD_CARRY(a2, r2, r2, carry, carry);\n-        MP_ADD_CARRY(a3, r3, r3, carry, carry);\n-        MP_ADD_CARRY(a4, r4, r4, carry, carry);\n-        MP_ADD_CARRY(a5, r5, r5, carry, carry);\n-\n-        MP_CHECKOK(s_mp_pad(r, 6));\n-        MP_DIGIT(r, 5) = r5;\n-        MP_DIGIT(r, 4) = r4;\n-        MP_DIGIT(r, 3) = r3;\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 6;\n-\n-        \/* Do quick 'subract' if we've gone over\n-         * (add the 2's complement of the curve field) *\/\n-        a5 = MP_DIGIT(&meth->irr,5);\n-        if (carry ||  r5 >  a5 ||\n-                ((r5 == a5) && mp_cmp(r,&meth->irr) != MP_LT)) {\n-                a4 = MP_DIGIT(&meth->irr,4);\n-                a3 = MP_DIGIT(&meth->irr,3);\n-                a2 = MP_DIGIT(&meth->irr,2);\n-                a1 = MP_DIGIT(&meth->irr,1);\n-                a0 = MP_DIGIT(&meth->irr,0);\n-                MP_SUB_BORROW(r0, a0, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a1, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a2, r2, carry, carry);\n-                MP_SUB_BORROW(r3, a3, r3, carry, carry);\n-                MP_SUB_BORROW(r4, a4, r4, carry, carry);\n-                MP_SUB_BORROW(r5, a5, r5, carry, carry);\n-                MP_DIGIT(r, 5) = r5;\n-                MP_DIGIT(r, 4) = r4;\n-                MP_DIGIT(r, 3) = r3;\n-                MP_DIGIT(r, 2) = r2;\n-                MP_DIGIT(r, 1) = r1;\n-                MP_DIGIT(r, 0) = r0;\n-        }\n-\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/*\n- * The following subraction functions do in-line subractions based\n- * on our curve size.\n- *\n- * ... 3 words\n- *\/\n-mp_err\n-ec_GFp_sub_3(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit b0 = 0, b1 = 0, b2 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0;\n-        mp_digit borrow;\n-\n-        switch(MP_USED(a)) {\n-        case 3:\n-                r2 = MP_DIGIT(a,2);\n-        case 2:\n-                r1 = MP_DIGIT(a,1);\n-        case 1:\n-                r0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 3:\n-                b2 = MP_DIGIT(b,2);\n-        case 2:\n-                b1 = MP_DIGIT(b,1);\n-        case 1:\n-                b0 = MP_DIGIT(b,0);\n-        }\n-\n-#ifndef MPI_AMD64_ADD\n-        MP_SUB_BORROW(r0, b0, r0, 0,     borrow);\n-        MP_SUB_BORROW(r1, b1, r1, borrow, borrow);\n-        MP_SUB_BORROW(r2, b2, r2, borrow, borrow);\n-#else\n-        __asm__ (\n-                \"xorq   %3,%3           \\n\\t\"\n-                \"subq   %4,%0           \\n\\t\"\n-                \"sbbq   %5,%1           \\n\\t\"\n-                \"sbbq   %6,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\" (borrow)\n-                : \"r\" (b0), \"r\" (b1), \"r\" (b2),\n-                  \"0\" (r0), \"1\" (r1), \"2\" (r2)\n-                : \"%cc\" );\n-#endif\n-\n-        \/* Do quick 'add' if we've gone under 0\n-         * (subtract the 2's complement of the curve field) *\/\n-        if (borrow) {\n-                b2 = MP_DIGIT(&meth->irr,2);\n-                b1 = MP_DIGIT(&meth->irr,1);\n-                b0 = MP_DIGIT(&meth->irr,0);\n-#ifndef MPI_AMD64_ADD\n-                MP_ADD_CARRY_ZERO(b0, r0, r0, borrow);\n-                MP_ADD_CARRY(b1, r1, r1, borrow, borrow);\n-                MP_ADD_CARRY(b2, r2, r2, borrow, borrow);\n-#else\n-                __asm__ (\n-                        \"addq   %3,%0           \\n\\t\"\n-                        \"adcq   %4,%1           \\n\\t\"\n-                        \"adcq   %5,%2           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2)\n-                        : \"r\" (b0), \"r\" (b1), \"r\" (b2),\n-                          \"0\" (r0), \"1\" (r1), \"2\" (r2)\n-                        : \"%cc\" );\n-#endif\n-        }\n-\n-#ifdef MPI_AMD64_ADD\n-        \/* compiler fakeout? *\/\n-        if ((r2 == b0) && (r1 == b0) && (r0 == b0)) {\n-                MP_CHECKOK(s_mp_pad(r, 4));\n-        }\n-#endif\n-        MP_CHECKOK(s_mp_pad(r, 3));\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 3;\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* 4 words *\/\n-mp_err\n-ec_GFp_sub_4(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit b0 = 0, b1 = 0, b2 = 0, b3 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0, r3 = 0;\n-        mp_digit borrow;\n-\n-        switch(MP_USED(a)) {\n-        case 4:\n-                r3 = MP_DIGIT(a,3);\n-        case 3:\n-                r2 = MP_DIGIT(a,2);\n-        case 2:\n-                r1 = MP_DIGIT(a,1);\n-        case 1:\n-                r0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 4:\n-                b3 = MP_DIGIT(b,3);\n-        case 3:\n-                b2 = MP_DIGIT(b,2);\n-        case 2:\n-                b1 = MP_DIGIT(b,1);\n-        case 1:\n-                b0 = MP_DIGIT(b,0);\n-        }\n-\n-#ifndef MPI_AMD64_ADD\n-        MP_SUB_BORROW(r0, b0, r0, 0,     borrow);\n-        MP_SUB_BORROW(r1, b1, r1, borrow, borrow);\n-        MP_SUB_BORROW(r2, b2, r2, borrow, borrow);\n-        MP_SUB_BORROW(r3, b3, r3, borrow, borrow);\n-#else\n-        __asm__ (\n-                \"xorq   %4,%4           \\n\\t\"\n-                \"subq   %5,%0           \\n\\t\"\n-                \"sbbq   %6,%1           \\n\\t\"\n-                \"sbbq   %7,%2           \\n\\t\"\n-                \"sbbq   %8,%3           \\n\\t\"\n-                \"adcq   $0,%4           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(r3), \"=r\" (borrow)\n-                : \"r\" (b0), \"r\" (b1), \"r\" (b2), \"r\" (b3),\n-                  \"0\" (r0), \"1\" (r1), \"2\" (r2), \"3\" (r3)\n-                : \"%cc\" );\n-#endif\n-\n-        \/* Do quick 'add' if we've gone under 0\n-         * (subtract the 2's complement of the curve field) *\/\n-        if (borrow) {\n-                b3 = MP_DIGIT(&meth->irr,3);\n-                b2 = MP_DIGIT(&meth->irr,2);\n-                b1 = MP_DIGIT(&meth->irr,1);\n-                b0 = MP_DIGIT(&meth->irr,0);\n-#ifndef MPI_AMD64_ADD\n-                MP_ADD_CARRY_ZERO(b0, r0, r0, borrow);\n-                MP_ADD_CARRY(b1, r1, r1, borrow, borrow);\n-                MP_ADD_CARRY(b2, r2, r2, borrow, borrow);\n-                MP_ADD_CARRY(b3, r3, r3, borrow, borrow);\n-#else\n-                __asm__ (\n-                        \"addq   %4,%0           \\n\\t\"\n-                        \"adcq   %5,%1           \\n\\t\"\n-                        \"adcq   %6,%2           \\n\\t\"\n-                        \"adcq   %7,%3           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(r3)\n-                        : \"r\" (b0), \"r\" (b1), \"r\" (b2), \"r\" (b3),\n-                          \"0\" (r0), \"1\" (r1), \"2\" (r2), \"3\" (r3)\n-                        : \"%cc\" );\n-#endif\n-        }\n-#ifdef MPI_AMD64_ADD\n-        \/* compiler fakeout? *\/\n-        if ((r3 == b0) && (r1 == b0) && (r0 == b0)) {\n-                MP_CHECKOK(s_mp_pad(r, 4));\n-        }\n-#endif\n-        MP_CHECKOK(s_mp_pad(r, 4));\n-        MP_DIGIT(r, 3) = r3;\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 4;\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* 5 words *\/\n-mp_err\n-ec_GFp_sub_5(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0, r3 = 0, r4 = 0;\n-        mp_digit borrow;\n-\n-        switch(MP_USED(a)) {\n-        case 5:\n-                r4 = MP_DIGIT(a,4);\n-        case 4:\n-                r3 = MP_DIGIT(a,3);\n-        case 3:\n-                r2 = MP_DIGIT(a,2);\n-        case 2:\n-                r1 = MP_DIGIT(a,1);\n-        case 1:\n-                r0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 5:\n-                b4 = MP_DIGIT(b,4);\n-        case 4:\n-                b3 = MP_DIGIT(b,3);\n-        case 3:\n-                b2 = MP_DIGIT(b,2);\n-        case 2:\n-                b1 = MP_DIGIT(b,1);\n-        case 1:\n-                b0 = MP_DIGIT(b,0);\n-        }\n-\n-        MP_SUB_BORROW(r0, b0, r0, 0,     borrow);\n-        MP_SUB_BORROW(r1, b1, r1, borrow, borrow);\n-        MP_SUB_BORROW(r2, b2, r2, borrow, borrow);\n-        MP_SUB_BORROW(r3, b3, r3, borrow, borrow);\n-        MP_SUB_BORROW(r4, b4, r4, borrow, borrow);\n-\n-        \/* Do quick 'add' if we've gone under 0\n-         * (subtract the 2's complement of the curve field) *\/\n-        if (borrow) {\n-                b4 = MP_DIGIT(&meth->irr,4);\n-                b3 = MP_DIGIT(&meth->irr,3);\n-                b2 = MP_DIGIT(&meth->irr,2);\n-                b1 = MP_DIGIT(&meth->irr,1);\n-                b0 = MP_DIGIT(&meth->irr,0);\n-                MP_ADD_CARRY_ZERO(b0, r0, r0, borrow);\n-                MP_ADD_CARRY(b1, r1, r1, borrow, borrow);\n-                MP_ADD_CARRY(b2, r2, r2, borrow, borrow);\n-                MP_ADD_CARRY(b3, r3, r3, borrow, borrow);\n-                MP_ADD_CARRY(b4, r4, r4, borrow, borrow);\n-        }\n-        MP_CHECKOK(s_mp_pad(r, 5));\n-        MP_DIGIT(r, 4) = r4;\n-        MP_DIGIT(r, 3) = r3;\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 5;\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* 6 words *\/\n-mp_err\n-ec_GFp_sub_6(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0, r3 = 0, r4 = 0, r5 = 0;\n-        mp_digit borrow;\n-\n-        switch(MP_USED(a)) {\n-        case 6:\n-                r5 = MP_DIGIT(a,5);\n-        case 5:\n-                r4 = MP_DIGIT(a,4);\n-        case 4:\n-                r3 = MP_DIGIT(a,3);\n-        case 3:\n-                r2 = MP_DIGIT(a,2);\n-        case 2:\n-                r1 = MP_DIGIT(a,1);\n-        case 1:\n-                r0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 6:\n-                b5 = MP_DIGIT(b,5);\n-        case 5:\n-                b4 = MP_DIGIT(b,4);\n-        case 4:\n-                b3 = MP_DIGIT(b,3);\n-        case 3:\n-                b2 = MP_DIGIT(b,2);\n-        case 2:\n-                b1 = MP_DIGIT(b,1);\n-        case 1:\n-                b0 = MP_DIGIT(b,0);\n-        }\n-\n-        MP_SUB_BORROW(r0, b0, r0, 0,     borrow);\n-        MP_SUB_BORROW(r1, b1, r1, borrow, borrow);\n-        MP_SUB_BORROW(r2, b2, r2, borrow, borrow);\n-        MP_SUB_BORROW(r3, b3, r3, borrow, borrow);\n-        MP_SUB_BORROW(r4, b4, r4, borrow, borrow);\n-        MP_SUB_BORROW(r5, b5, r5, borrow, borrow);\n-\n-        \/* Do quick 'add' if we've gone under 0\n-         * (subtract the 2's complement of the curve field) *\/\n-        if (borrow) {\n-                b5 = MP_DIGIT(&meth->irr,5);\n-                b4 = MP_DIGIT(&meth->irr,4);\n-                b3 = MP_DIGIT(&meth->irr,3);\n-                b2 = MP_DIGIT(&meth->irr,2);\n-                b1 = MP_DIGIT(&meth->irr,1);\n-                b0 = MP_DIGIT(&meth->irr,0);\n-                MP_ADD_CARRY_ZERO(b0, r0, r0, borrow);\n-                MP_ADD_CARRY(b1, r1, r1, borrow, borrow);\n-                MP_ADD_CARRY(b2, r2, r2, borrow, borrow);\n-                MP_ADD_CARRY(b3, r3, r3, borrow, borrow);\n-                MP_ADD_CARRY(b4, r4, r4, borrow, borrow);\n-                MP_ADD_CARRY(b5, r5, r5, borrow, borrow);\n-        }\n-\n-        MP_CHECKOK(s_mp_pad(r, 6));\n-        MP_DIGIT(r, 5) = r5;\n-        MP_DIGIT(r, 4) = r4;\n-        MP_DIGIT(r, 3) = r3;\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 6;\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\n-\/* Reduces an integer to a field element. *\/\n-mp_err\n-ec_GFp_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        return mp_mod(a, &meth->irr, r);\n-}\n-\n-\/* Multiplies two field elements. *\/\n-mp_err\n-ec_GFp_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        return mp_mulmod(a, b, &meth->irr, r);\n-}\n-\n-\/* Squares a field element. *\/\n-mp_err\n-ec_GFp_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        return mp_sqrmod(a, &meth->irr, r);\n-}\n-\n-\/* Divides two field elements. If a is NULL, then returns the inverse of\n- * b. *\/\n-mp_err\n-ec_GFp_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t;\n-\n-        \/* If a is NULL, then return the inverse of b, otherwise return a\/b. *\/\n-        if (a == NULL) {\n-                return mp_invmod(b, &meth->irr, r);\n-        } else {\n-                \/* MPI doesn't support divmod, so we implement it using invmod and\n-                 * mulmod. *\/\n-                MP_CHECKOK(mp_init(&t, FLAG(b)));\n-                MP_CHECKOK(mp_invmod(b, &meth->irr, &t));\n-                MP_CHECKOK(mp_mulmod(a, &t, &meth->irr, r));\n-          CLEANUP:\n-                mp_clear(&t);\n-                return res;\n-        }\n-}\n-\n-\/* Wrapper functions for generic binary polynomial field arithmetic. *\/\n-\n-\/* Adds two field elements. *\/\n-mp_err\n-ec_GF2m_add(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        return mp_badd(a, b, r);\n-}\n-\n-\/* Negates a field element. Note that for binary polynomial fields, the\n- * negation of a field element is the field element itself. *\/\n-mp_err\n-ec_GF2m_neg(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        if (a == r) {\n-                return MP_OKAY;\n-        } else {\n-                return mp_copy(a, r);\n-        }\n-}\n-\n-\/* Reduces a binary polynomial to a field element. *\/\n-mp_err\n-ec_GF2m_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        return mp_bmod(a, meth->irr_arr, r);\n-}\n-\n-\/* Multiplies two field elements. *\/\n-mp_err\n-ec_GF2m_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        return mp_bmulmod(a, b, meth->irr_arr, r);\n-}\n-\n-\/* Squares a field element. *\/\n-mp_err\n-ec_GF2m_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        return mp_bsqrmod(a, meth->irr_arr, r);\n-}\n-\n-\/* Divides two field elements. If a is NULL, then returns the inverse of\n- * b. *\/\n-mp_err\n-ec_GF2m_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t;\n-\n-        \/* If a is NULL, then return the inverse of b, otherwise return a\/b. *\/\n-        if (a == NULL) {\n-                \/* The GF(2^m) portion of MPI doesn't support invmod, so we\n-                 * compute 1\/b. *\/\n-                MP_CHECKOK(mp_init(&t, FLAG(b)));\n-                MP_CHECKOK(mp_set_int(&t, 1));\n-                MP_CHECKOK(mp_bdivmod(&t, b, &meth->irr, meth->irr_arr, r));\n-          CLEANUP:\n-                mp_clear(&t);\n-                return res;\n-        } else {\n-                return mp_bdivmod(a, b, &meth->irr, meth->irr_arr, r);\n-        }\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl_gf.c","additions":0,"deletions":1043,"binary":false,"changes":1043,"status":"deleted"},{"patch":"@@ -1,362 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"ecl.h\"\n-#include \"ecl-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Elliptic curve scalar-point multiplication. Computes R(x, y) = k * P(x,\n- * y).  If x, y = NULL, then P is assumed to be the generator (base point)\n- * of the group of points on the elliptic curve. Input and output values\n- * are assumed to be NOT field-encoded. *\/\n-mp_err\n-ECPoint_mul(const ECGroup *group, const mp_int *k, const mp_int *px,\n-                        const mp_int *py, mp_int *rx, mp_int *ry,\n-                        int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int kt;\n-\n-        ARGCHK((k != NULL) && (group != NULL), MP_BADARG);\n-        MP_DIGITS(&kt) = 0;\n-\n-        \/* want scalar to be less than or equal to group order *\/\n-        if (mp_cmp(k, &group->order) > 0) {\n-                MP_CHECKOK(mp_init(&kt, FLAG(k)));\n-                MP_CHECKOK(mp_mod(k, &group->order, &kt));\n-        } else {\n-                MP_SIGN(&kt) = MP_ZPOS;\n-                MP_USED(&kt) = MP_USED(k);\n-                MP_ALLOC(&kt) = MP_ALLOC(k);\n-                MP_DIGITS(&kt) = MP_DIGITS(k);\n-        }\n-\n-        if ((px == NULL) || (py == NULL)) {\n-                if (group->base_point_mul) {\n-                        MP_CHECKOK(group->base_point_mul(&kt, rx, ry, group));\n-                } else {\n-                        kt.flag = (mp_sign)0;\n-                        MP_CHECKOK(group->\n-                                           point_mul(&kt, &group->genx, &group->geny, rx, ry,\n-                                                                 group, timing));\n-                }\n-        } else {\n-                kt.flag = (mp_sign)0;\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->field_enc(px, rx, group->meth));\n-                        MP_CHECKOK(group->meth->field_enc(py, ry, group->meth));\n-                        MP_CHECKOK(group->point_mul(&kt, rx, ry, rx, ry, group, timing));\n-                } else {\n-                        MP_CHECKOK(group->point_mul(&kt, px, py, rx, ry, group, timing));\n-                }\n-        }\n-        if (group->meth->field_dec) {\n-                MP_CHECKOK(group->meth->field_dec(rx, rx, group->meth));\n-                MP_CHECKOK(group->meth->field_dec(ry, ry, group->meth));\n-        }\n-\n-  CLEANUP:\n-        if (MP_DIGITS(&kt) != MP_DIGITS(k)) {\n-                mp_clear(&kt);\n-        }\n-        return res;\n-}\n-\n-\/* Elliptic curve scalar-point multiplication. Computes R(x, y) = k1 * G +\n- * k2 * P(x, y), where G is the generator (base point) of the group of\n- * points on the elliptic curve. Allows k1 = NULL or { k2, P } = NULL.\n- * Input and output values are assumed to be NOT field-encoded. *\/\n-mp_err\n-ec_pts_mul_basic(const mp_int *k1, const mp_int *k2, const mp_int *px,\n-                                 const mp_int *py, mp_int *rx, mp_int *ry,\n-                                 const ECGroup *group, int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int sx, sy;\n-\n-        ARGCHK(group != NULL, MP_BADARG);\n-        ARGCHK(!((k1 == NULL)\n-                         && ((k2 == NULL) || (px == NULL)\n-                                 || (py == NULL))), MP_BADARG);\n-\n-        \/* if some arguments are not defined used ECPoint_mul *\/\n-        if (k1 == NULL) {\n-                return ECPoint_mul(group, k2, px, py, rx, ry, timing);\n-        } else if ((k2 == NULL) || (px == NULL) || (py == NULL)) {\n-                return ECPoint_mul(group, k1, NULL, NULL, rx, ry, timing);\n-        }\n-\n-        MP_DIGITS(&sx) = 0;\n-        MP_DIGITS(&sy) = 0;\n-        MP_CHECKOK(mp_init(&sx, FLAG(k1)));\n-        MP_CHECKOK(mp_init(&sy, FLAG(k1)));\n-\n-        MP_CHECKOK(ECPoint_mul(group, k1, NULL, NULL, &sx, &sy, timing));\n-        MP_CHECKOK(ECPoint_mul(group, k2, px, py, rx, ry, timing));\n-\n-        if (group->meth->field_enc) {\n-                MP_CHECKOK(group->meth->field_enc(&sx, &sx, group->meth));\n-                MP_CHECKOK(group->meth->field_enc(&sy, &sy, group->meth));\n-                MP_CHECKOK(group->meth->field_enc(rx, rx, group->meth));\n-                MP_CHECKOK(group->meth->field_enc(ry, ry, group->meth));\n-        }\n-\n-        MP_CHECKOK(group->point_add(&sx, &sy, rx, ry, rx, ry, group));\n-\n-        if (group->meth->field_dec) {\n-                MP_CHECKOK(group->meth->field_dec(rx, rx, group->meth));\n-                MP_CHECKOK(group->meth->field_dec(ry, ry, group->meth));\n-        }\n-\n-  CLEANUP:\n-        mp_clear(&sx);\n-        mp_clear(&sy);\n-        return res;\n-}\n-\n-\/* Elliptic curve scalar-point multiplication. Computes R(x, y) = k1 * G +\n- * k2 * P(x, y), where G is the generator (base point) of the group of\n- * points on the elliptic curve. Allows k1 = NULL or { k2, P } = NULL.\n- * Input and output values are assumed to be NOT field-encoded. Uses\n- * algorithm 15 (simultaneous multiple point multiplication) from Brown,\n- * Hankerson, Lopez, Menezes. Software Implementation of the NIST\n- * Elliptic Curves over Prime Fields. *\/\n-mp_err\n-ec_pts_mul_simul_w2(const mp_int *k1, const mp_int *k2, const mp_int *px,\n-                                        const mp_int *py, mp_int *rx, mp_int *ry,\n-                                        const ECGroup *group, int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int precomp[4][4][2];\n-        const mp_int *a, *b;\n-        int i, j;\n-        int ai, bi, d;\n-\n-        ARGCHK(group != NULL, MP_BADARG);\n-        ARGCHK(!((k1 == NULL)\n-                         && ((k2 == NULL) || (px == NULL)\n-                                 || (py == NULL))), MP_BADARG);\n-\n-        \/* if some arguments are not defined used ECPoint_mul *\/\n-        if (k1 == NULL) {\n-                return ECPoint_mul(group, k2, px, py, rx, ry, timing);\n-        } else if ((k2 == NULL) || (px == NULL) || (py == NULL)) {\n-                return ECPoint_mul(group, k1, NULL, NULL, rx, ry, timing);\n-        }\n-\n-        \/* initialize precomputation table *\/\n-        for (i = 0; i < 4; i++) {\n-                for (j = 0; j < 4; j++) {\n-                        MP_DIGITS(&precomp[i][j][0]) = 0;\n-                        MP_DIGITS(&precomp[i][j][1]) = 0;\n-                }\n-        }\n-        for (i = 0; i < 4; i++) {\n-                for (j = 0; j < 4; j++) {\n-                         MP_CHECKOK( mp_init_size(&precomp[i][j][0],\n-                                         ECL_MAX_FIELD_SIZE_DIGITS, FLAG(k1)) );\n-                         MP_CHECKOK( mp_init_size(&precomp[i][j][1],\n-                                         ECL_MAX_FIELD_SIZE_DIGITS, FLAG(k1)) );\n-                }\n-        }\n-\n-        \/* fill precomputation table *\/\n-        \/* assign {k1, k2} = {a, b} such that len(a) >= len(b) *\/\n-        if (mpl_significant_bits(k1) < mpl_significant_bits(k2)) {\n-                a = k2;\n-                b = k1;\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(px, &precomp[1][0][0], group->meth));\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(py, &precomp[1][0][1], group->meth));\n-                } else {\n-                        MP_CHECKOK(mp_copy(px, &precomp[1][0][0]));\n-                        MP_CHECKOK(mp_copy(py, &precomp[1][0][1]));\n-                }\n-                MP_CHECKOK(mp_copy(&group->genx, &precomp[0][1][0]));\n-                MP_CHECKOK(mp_copy(&group->geny, &precomp[0][1][1]));\n-        } else {\n-                a = k1;\n-                b = k2;\n-                MP_CHECKOK(mp_copy(&group->genx, &precomp[1][0][0]));\n-                MP_CHECKOK(mp_copy(&group->geny, &precomp[1][0][1]));\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(px, &precomp[0][1][0], group->meth));\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(py, &precomp[0][1][1], group->meth));\n-                } else {\n-                        MP_CHECKOK(mp_copy(px, &precomp[0][1][0]));\n-                        MP_CHECKOK(mp_copy(py, &precomp[0][1][1]));\n-                }\n-        }\n-        \/* precompute [*][0][*] *\/\n-        mp_zero(&precomp[0][0][0]);\n-        mp_zero(&precomp[0][0][1]);\n-        MP_CHECKOK(group->\n-                           point_dbl(&precomp[1][0][0], &precomp[1][0][1],\n-                                                 &precomp[2][0][0], &precomp[2][0][1], group));\n-        MP_CHECKOK(group->\n-                           point_add(&precomp[1][0][0], &precomp[1][0][1],\n-                                                 &precomp[2][0][0], &precomp[2][0][1],\n-                                                 &precomp[3][0][0], &precomp[3][0][1], group));\n-        \/* precompute [*][1][*] *\/\n-        for (i = 1; i < 4; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[0][1][0], &precomp[0][1][1],\n-                                                         &precomp[i][0][0], &precomp[i][0][1],\n-                                                         &precomp[i][1][0], &precomp[i][1][1], group));\n-        }\n-        \/* precompute [*][2][*] *\/\n-        MP_CHECKOK(group->\n-                           point_dbl(&precomp[0][1][0], &precomp[0][1][1],\n-                                                 &precomp[0][2][0], &precomp[0][2][1], group));\n-        for (i = 1; i < 4; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[0][2][0], &precomp[0][2][1],\n-                                                         &precomp[i][0][0], &precomp[i][0][1],\n-                                                         &precomp[i][2][0], &precomp[i][2][1], group));\n-        }\n-        \/* precompute [*][3][*] *\/\n-        MP_CHECKOK(group->\n-                           point_add(&precomp[0][1][0], &precomp[0][1][1],\n-                                                 &precomp[0][2][0], &precomp[0][2][1],\n-                                                 &precomp[0][3][0], &precomp[0][3][1], group));\n-        for (i = 1; i < 4; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[0][3][0], &precomp[0][3][1],\n-                                                         &precomp[i][0][0], &precomp[i][0][1],\n-                                                         &precomp[i][3][0], &precomp[i][3][1], group));\n-        }\n-\n-        d = (mpl_significant_bits(a) + 1) \/ 2;\n-\n-        \/* R = inf *\/\n-        mp_zero(rx);\n-        mp_zero(ry);\n-\n-        for (i = d - 1; i >= 0; i--) {\n-                ai = MP_GET_BIT(a, 2 * i + 1);\n-                ai <<= 1;\n-                ai |= MP_GET_BIT(a, 2 * i);\n-                bi = MP_GET_BIT(b, 2 * i + 1);\n-                bi <<= 1;\n-                bi |= MP_GET_BIT(b, 2 * i);\n-                \/* R = 2^2 * R *\/\n-                MP_CHECKOK(group->point_dbl(rx, ry, rx, ry, group));\n-                MP_CHECKOK(group->point_dbl(rx, ry, rx, ry, group));\n-                \/* R = R + (ai * A + bi * B) *\/\n-                MP_CHECKOK(group->\n-                                   point_add(rx, ry, &precomp[ai][bi][0],\n-                                                         &precomp[ai][bi][1], rx, ry, group));\n-        }\n-\n-        if (group->meth->field_dec) {\n-                MP_CHECKOK(group->meth->field_dec(rx, rx, group->meth));\n-                MP_CHECKOK(group->meth->field_dec(ry, ry, group->meth));\n-        }\n-\n-  CLEANUP:\n-        for (i = 0; i < 4; i++) {\n-                for (j = 0; j < 4; j++) {\n-                        mp_clear(&precomp[i][j][0]);\n-                        mp_clear(&precomp[i][j][1]);\n-                }\n-        }\n-        return res;\n-}\n-\n-\/* Elliptic curve scalar-point multiplication. Computes R(x, y) = k1 * G +\n- * k2 * P(x, y), where G is the generator (base point) of the group of\n- * points on the elliptic curve. Allows k1 = NULL or { k2, P } = NULL.\n- * Input and output values are assumed to be NOT field-encoded. *\/\n-mp_err\n-ECPoints_mul(const ECGroup *group, const mp_int *k1, const mp_int *k2,\n-                         const mp_int *px, const mp_int *py, mp_int *rx, mp_int *ry,\n-                         int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int k1t, k2t;\n-        const mp_int *k1p, *k2p;\n-\n-        MP_DIGITS(&k1t) = 0;\n-        MP_DIGITS(&k2t) = 0;\n-\n-        ARGCHK(group != NULL, MP_BADARG);\n-\n-        \/* want scalar to be less than or equal to group order *\/\n-        if (k1 != NULL) {\n-                if (mp_cmp(k1, &group->order) >= 0) {\n-                        MP_CHECKOK(mp_init(&k1t, FLAG(k1)));\n-                        MP_CHECKOK(mp_mod(k1, &group->order, &k1t));\n-                        k1p = &k1t;\n-                } else {\n-                        k1p = k1;\n-                }\n-        } else {\n-                k1p = k1;\n-        }\n-        if (k2 != NULL) {\n-                if (mp_cmp(k2, &group->order) >= 0) {\n-                        MP_CHECKOK(mp_init(&k2t, FLAG(k2)));\n-                        MP_CHECKOK(mp_mod(k2, &group->order, &k2t));\n-                        k2p = &k2t;\n-                } else {\n-                        k2p = k2;\n-                }\n-        } else {\n-                k2p = k2;\n-        }\n-\n-        \/* if points_mul is defined, then use it *\/\n-        if (group->points_mul) {\n-                res = group->points_mul(k1p, k2p, px, py, rx, ry, group, timing);\n-        } else {\n-                res = ec_pts_mul_simul_w2(k1p, k2p, px, py, rx, ry, group, timing);\n-        }\n-\n-  CLEANUP:\n-        mp_clear(&k1t);\n-        mp_clear(&k2t);\n-        return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecl_mult.c","additions":0,"deletions":362,"binary":false,"changes":362,"status":"deleted"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#ifndef _ECP_H\n-#define _ECP_H\n-\n-#include \"ecl-priv.h\"\n-\n-\/* Checks if point P(px, py) is at infinity.  Uses affine coordinates. *\/\n-mp_err ec_GFp_pt_is_inf_aff(const mp_int *px, const mp_int *py);\n-\n-\/* Sets P(px, py) to be the point at infinity.  Uses affine coordinates. *\/\n-mp_err ec_GFp_pt_set_inf_aff(mp_int *px, mp_int *py);\n-\n-\/* Computes R = P + Q where R is (rx, ry), P is (px, py) and Q is (qx,\n- * qy). Uses affine coordinates. *\/\n-mp_err ec_GFp_pt_add_aff(const mp_int *px, const mp_int *py,\n-                                                 const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                                 mp_int *ry, const ECGroup *group);\n-\n-\/* Computes R = P - Q.  Uses affine coordinates. *\/\n-mp_err ec_GFp_pt_sub_aff(const mp_int *px, const mp_int *py,\n-                                                 const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                                 mp_int *ry, const ECGroup *group);\n-\n-\/* Computes R = 2P.  Uses affine coordinates. *\/\n-mp_err ec_GFp_pt_dbl_aff(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                 mp_int *ry, const ECGroup *group);\n-\n-\/* Validates a point on a GFp curve. *\/\n-mp_err ec_GFp_validate_point(const mp_int *px, const mp_int *py, const ECGroup *group);\n-\n-#ifdef ECL_ENABLE_GFP_PT_MUL_AFF\n-\/* Computes R = nP where R is (rx, ry) and P is (px, py). The parameters\n- * a, b and p are the elliptic curve coefficients and the prime that\n- * determines the field GFp.  Uses affine coordinates. *\/\n-mp_err ec_GFp_pt_mul_aff(const mp_int *n, const mp_int *px,\n-                                                 const mp_int *py, mp_int *rx, mp_int *ry,\n-                                                 const ECGroup *group);\n-#endif\n-\n-\/* Converts a point P(px, py) from affine coordinates to Jacobian\n- * projective coordinates R(rx, ry, rz). *\/\n-mp_err ec_GFp_pt_aff2jac(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                                 mp_int *ry, mp_int *rz, const ECGroup *group);\n-\n-\/* Converts a point P(px, py, pz) from Jacobian projective coordinates to\n- * affine coordinates R(rx, ry). *\/\n-mp_err ec_GFp_pt_jac2aff(const mp_int *px, const mp_int *py,\n-                                                 const mp_int *pz, mp_int *rx, mp_int *ry,\n-                                                 const ECGroup *group);\n-\n-\/* Checks if point P(px, py, pz) is at infinity.  Uses Jacobian\n- * coordinates. *\/\n-mp_err ec_GFp_pt_is_inf_jac(const mp_int *px, const mp_int *py,\n-                                                        const mp_int *pz);\n-\n-\/* Sets P(px, py, pz) to be the point at infinity.  Uses Jacobian\n- * coordinates. *\/\n-mp_err ec_GFp_pt_set_inf_jac(mp_int *px, mp_int *py, mp_int *pz);\n-\n-\/* Computes R = P + Q where R is (rx, ry, rz), P is (px, py, pz) and Q is\n- * (qx, qy, qz).  Uses Jacobian coordinates. *\/\n-mp_err ec_GFp_pt_add_jac_aff(const mp_int *px, const mp_int *py,\n-                                                         const mp_int *pz, const mp_int *qx,\n-                                                         const mp_int *qy, mp_int *rx, mp_int *ry,\n-                                                         mp_int *rz, const ECGroup *group);\n-\n-\/* Computes R = 2P.  Uses Jacobian coordinates. *\/\n-mp_err ec_GFp_pt_dbl_jac(const mp_int *px, const mp_int *py,\n-                                                 const mp_int *pz, mp_int *rx, mp_int *ry,\n-                                                 mp_int *rz, const ECGroup *group);\n-\n-#ifdef ECL_ENABLE_GFP_PT_MUL_JAC\n-\/* Computes R = nP where R is (rx, ry) and P is (px, py). The parameters\n- * a, b and p are the elliptic curve coefficients and the prime that\n- * determines the field GFp.  Uses Jacobian coordinates. *\/\n-mp_err ec_GFp_pt_mul_jac(const mp_int *n, const mp_int *px,\n-                                                 const mp_int *py, mp_int *rx, mp_int *ry,\n-                                                 const ECGroup *group);\n-#endif\n-\n-\/* Computes R(x, y) = k1 * G + k2 * P(x, y), where G is the generator\n- * (base point) of the group of points on the elliptic curve. Allows k1 =\n- * NULL or { k2, P } = NULL.  Implemented using mixed Jacobian-affine\n- * coordinates. Input and output values are assumed to be NOT\n- * field-encoded and are in affine form. *\/\n-mp_err\n- ec_GFp_pts_mul_jac(const mp_int *k1, const mp_int *k2, const mp_int *px,\n-                                        const mp_int *py, mp_int *rx, mp_int *ry,\n-                                        const ECGroup *group, int timing);\n-\n-\/* Computes R = nP where R is (rx, ry) and P is the base point. Elliptic\n- * curve points P and R can be identical. Uses mixed Modified-Jacobian\n- * co-ordinates for doubling and Chudnovsky Jacobian coordinates for\n- * additions. Assumes input is already field-encoded using field_enc, and\n- * returns output that is still field-encoded. Uses 5-bit window NAF\n- * method (algorithm 11) for scalar-point multiplication from Brown,\n- * Hankerson, Lopez, Menezes. Software Implementation of the NIST Elliptic\n- * Curves Over Prime Fields. The implementation includes a countermeasure\n- * that attempts to hide the size of n from timing channels. This counter-\n- * measure is enabled using the timing argument. The high-rder bits of timing\n- * must be uniformly random in order for this countermeasure to work. *\/\n-mp_err\n- ec_GFp_pt_mul_jm_wNAF(const mp_int *n, const mp_int *px, const mp_int *py,\n-                                           mp_int *rx, mp_int *ry, const ECGroup *group,\n-                                           int timing);\n-\n-#endif \/* _ECP_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp.h","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -1,517 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-#define ECP192_DIGITS ECL_CURVE_DIGITS(192)\n-\n-\/* Fast modular reduction for p192 = 2^192 - 2^64 - 1.  a can be r. Uses\n- * algorithm 7 from Brown, Hankerson, Lopez, Menezes. Software\n- * Implementation of the NIST Elliptic Curves over Prime Fields. *\/\n-mp_err\n-ec_GFp_nistp192_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_size a_used = MP_USED(a);\n-        mp_digit r3;\n-#ifndef MPI_AMD64_ADD\n-        mp_digit carry;\n-#endif\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit a5a = 0, a5b = 0, a4a = 0, a4b = 0, a3a = 0, a3b = 0;\n-        mp_digit r0a, r0b, r1a, r1b, r2a, r2b;\n-#else\n-        mp_digit a5 = 0, a4 = 0, a3 = 0;\n-        mp_digit r0, r1, r2;\n-#endif\n-\n-        \/* reduction not needed if a is not larger than field size *\/\n-        if (a_used < ECP192_DIGITS) {\n-                if (a == r) {\n-                        return MP_OKAY;\n-                }\n-                return mp_copy(a, r);\n-        }\n-\n-        \/* for polynomials larger than twice the field size, use regular\n-         * reduction *\/\n-        if (a_used > ECP192_DIGITS*2) {\n-                MP_CHECKOK(mp_mod(a, &meth->irr, r));\n-        } else {\n-                \/* copy out upper words of a *\/\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-\n-                \/* in all the math below,\n-                 * nXb is most signifiant, nXa is least significant *\/\n-                switch (a_used) {\n-                case 12:\n-                        a5b = MP_DIGIT(a, 11);\n-                case 11:\n-                        a5a = MP_DIGIT(a, 10);\n-                case 10:\n-                        a4b = MP_DIGIT(a, 9);\n-                case 9:\n-                        a4a = MP_DIGIT(a, 8);\n-                case 8:\n-                        a3b = MP_DIGIT(a, 7);\n-                case 7:\n-                        a3a = MP_DIGIT(a, 6);\n-                }\n-\n-\n-                r2b= MP_DIGIT(a, 5);\n-                r2a= MP_DIGIT(a, 4);\n-                r1b = MP_DIGIT(a, 3);\n-                r1a = MP_DIGIT(a, 2);\n-                r0b = MP_DIGIT(a, 1);\n-                r0a = MP_DIGIT(a, 0);\n-\n-                \/* implement r = (a2,a1,a0)+(a5,a5,a5)+(a4,a4,0)+(0,a3,a3) *\/\n-                MP_ADD_CARRY(r0a, a3a, r0a, 0,    carry);\n-                MP_ADD_CARRY(r0b, a3b, r0b, carry, carry);\n-                MP_ADD_CARRY(r1a, a3a, r1a, carry, carry);\n-                MP_ADD_CARRY(r1b, a3b, r1b, carry, carry);\n-                MP_ADD_CARRY(r2a, a4a, r2a, carry, carry);\n-                MP_ADD_CARRY(r2b, a4b, r2b, carry, carry);\n-                r3 = carry; carry = 0;\n-                MP_ADD_CARRY(r0a, a5a, r0a, 0,     carry);\n-                MP_ADD_CARRY(r0b, a5b, r0b, carry, carry);\n-                MP_ADD_CARRY(r1a, a5a, r1a, carry, carry);\n-                MP_ADD_CARRY(r1b, a5b, r1b, carry, carry);\n-                MP_ADD_CARRY(r2a, a5a, r2a, carry, carry);\n-                MP_ADD_CARRY(r2b, a5b, r2b, carry, carry);\n-                r3 += carry;\n-                MP_ADD_CARRY(r1a, a4a, r1a, 0,     carry);\n-                MP_ADD_CARRY(r1b, a4b, r1b, carry, carry);\n-                MP_ADD_CARRY(r2a,   0, r2a, carry, carry);\n-                MP_ADD_CARRY(r2b,   0, r2b, carry, carry);\n-                r3 += carry;\n-\n-                \/* reduce out the carry *\/\n-                while (r3) {\n-                        MP_ADD_CARRY(r0a, r3, r0a, 0,     carry);\n-                        MP_ADD_CARRY(r0b,  0, r0b, carry, carry);\n-                        MP_ADD_CARRY(r1a, r3, r1a, carry, carry);\n-                        MP_ADD_CARRY(r1b,  0, r1b, carry, carry);\n-                        MP_ADD_CARRY(r2a,  0, r2a, carry, carry);\n-                        MP_ADD_CARRY(r2b,  0, r2b, carry, carry);\n-                        r3 = carry;\n-                }\n-\n-                \/* check for final reduction *\/\n-                \/*\n-                 * our field is 0xffffffffffffffff, 0xfffffffffffffffe,\n-                 * 0xffffffffffffffff. That means we can only be over and need\n-                 * one more reduction\n-                 *  if r2 == 0xffffffffffffffffff (same as r2+1 == 0)\n-                 *     and\n-                 *     r1 == 0xffffffffffffffffff   or\n-                 *     r1 == 0xfffffffffffffffffe and r0 = 0xfffffffffffffffff\n-                 * In all cases, we subtract the field (or add the 2's\n-                 * complement value (1,1,0)).  (r0, r1, r2)\n-                 *\/\n-                if (((r2b == 0xffffffff) && (r2a == 0xffffffff)\n-                        && (r1b == 0xffffffff) ) &&\n-                           ((r1a == 0xffffffff) ||\n-                            (r1a == 0xfffffffe) && (r0a == 0xffffffff) &&\n-                                        (r0b == 0xffffffff)) ) {\n-                        \/* do a quick subtract *\/\n-                        MP_ADD_CARRY(r0a, 1, r0a, 0, carry);\n-                        r0b += carry;\n-                        r1a = r1b = r2a = r2b = 0;\n-                }\n-\n-                \/* set the lower words of r *\/\n-                if (a != r) {\n-                        MP_CHECKOK(s_mp_pad(r, 6));\n-                }\n-                MP_DIGIT(r, 5) = r2b;\n-                MP_DIGIT(r, 4) = r2a;\n-                MP_DIGIT(r, 3) = r1b;\n-                MP_DIGIT(r, 2) = r1a;\n-                MP_DIGIT(r, 1) = r0b;\n-                MP_DIGIT(r, 0) = r0a;\n-                MP_USED(r) = 6;\n-#else\n-                switch (a_used) {\n-                case 6:\n-                        a5 = MP_DIGIT(a, 5);\n-                case 5:\n-                        a4 = MP_DIGIT(a, 4);\n-                case 4:\n-                        a3 = MP_DIGIT(a, 3);\n-                }\n-\n-                r2 = MP_DIGIT(a, 2);\n-                r1 = MP_DIGIT(a, 1);\n-                r0 = MP_DIGIT(a, 0);\n-\n-                \/* implement r = (a2,a1,a0)+(a5,a5,a5)+(a4,a4,0)+(0,a3,a3) *\/\n-#ifndef MPI_AMD64_ADD\n-                MP_ADD_CARRY_ZERO(r0, a3, r0, carry);\n-                MP_ADD_CARRY(r1, a3, r1, carry, carry);\n-                MP_ADD_CARRY(r2, a4, r2, carry, carry);\n-                r3 = carry;\n-                MP_ADD_CARRY_ZERO(r0, a5, r0, carry);\n-                MP_ADD_CARRY(r1, a5, r1, carry, carry);\n-                MP_ADD_CARRY(r2, a5, r2, carry, carry);\n-                r3 += carry;\n-                MP_ADD_CARRY_ZERO(r1, a4, r1, carry);\n-                MP_ADD_CARRY(r2,  0, r2, carry, carry);\n-                r3 += carry;\n-\n-#else\n-                r2 = MP_DIGIT(a, 2);\n-                r1 = MP_DIGIT(a, 1);\n-                r0 = MP_DIGIT(a, 0);\n-\n-                \/* set the lower words of r *\/\n-                __asm__ (\n-                \"xorq   %3,%3           \\n\\t\"\n-                \"addq   %4,%0           \\n\\t\"\n-                \"adcq   %4,%1           \\n\\t\"\n-                \"adcq   %5,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                \"addq   %6,%0           \\n\\t\"\n-                \"adcq   %6,%1           \\n\\t\"\n-                \"adcq   %6,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                \"addq   %5,%1           \\n\\t\"\n-                \"adcq   $0,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(r3), \"=r\"(a3),\n-                  \"=r\"(a4), \"=r\"(a5)\n-                : \"0\" (r0), \"1\" (r1), \"2\" (r2), \"3\" (r3),\n-                  \"4\" (a3), \"5\" (a4), \"6\"(a5)\n-                : \"%cc\" );\n-#endif\n-\n-                \/* reduce out the carry *\/\n-                while (r3) {\n-#ifndef MPI_AMD64_ADD\n-                        MP_ADD_CARRY_ZERO(r0, r3, r0, carry);\n-                        MP_ADD_CARRY(r1, r3, r1, carry, carry);\n-                        MP_ADD_CARRY(r2,  0, r2, carry, carry);\n-                        r3 = carry;\n-#else\n-                        a3=r3;\n-                        __asm__ (\n-                        \"xorq   %3,%3           \\n\\t\"\n-                        \"addq   %4,%0           \\n\\t\"\n-                        \"adcq   %4,%1           \\n\\t\"\n-                        \"adcq   $0,%2           \\n\\t\"\n-                        \"adcq   $0,%3           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(r3), \"=r\"(a3)\n-                        : \"0\" (r0), \"1\" (r1), \"2\" (r2), \"3\" (r3), \"4\"(a3)\n-                        : \"%cc\" );\n-#endif\n-                }\n-\n-                \/* check for final reduction *\/\n-                \/*\n-                 * our field is 0xffffffffffffffff, 0xfffffffffffffffe,\n-                 * 0xffffffffffffffff. That means we can only be over and need\n-                 * one more reduction\n-                 *  if r2 == 0xffffffffffffffffff (same as r2+1 == 0)\n-                 *     and\n-                 *     r1 == 0xffffffffffffffffff   or\n-                 *     r1 == 0xfffffffffffffffffe and r0 = 0xfffffffffffffffff\n-                 * In all cases, we subtract the field (or add the 2's\n-                 * complement value (1,1,0)).  (r0, r1, r2)\n-                 *\/\n-                if (r3 || ((r2 == MP_DIGIT_MAX) &&\n-                      ((r1 == MP_DIGIT_MAX) ||\n-                        ((r1 == (MP_DIGIT_MAX-1)) && (r0 == MP_DIGIT_MAX))))) {\n-                        \/* do a quick subtract *\/\n-                        r0++;\n-                        r1 = r2 = 0;\n-                }\n-                \/* set the lower words of r *\/\n-                if (a != r) {\n-                        MP_CHECKOK(s_mp_pad(r, 3));\n-                }\n-                MP_DIGIT(r, 2) = r2;\n-                MP_DIGIT(r, 1) = r1;\n-                MP_DIGIT(r, 0) = r0;\n-                MP_USED(r) = 3;\n-#endif\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-#ifndef ECL_THIRTY_TWO_BIT\n-\/* Compute the sum of 192 bit curves. Do the work in-line since the\n- * number of words are so small, we don't want to overhead of mp function\n- * calls.  Uses optimized modular reduction for p192.\n- *\/\n-mp_err\n-ec_GFp_nistp192_add(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit a0 = 0, a1 = 0, a2 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0;\n-        mp_digit carry;\n-\n-        switch(MP_USED(a)) {\n-        case 3:\n-                a2 = MP_DIGIT(a,2);\n-        case 2:\n-                a1 = MP_DIGIT(a,1);\n-        case 1:\n-                a0 = MP_DIGIT(a,0);\n-        }\n-        switch(MP_USED(b)) {\n-        case 3:\n-                r2 = MP_DIGIT(b,2);\n-        case 2:\n-                r1 = MP_DIGIT(b,1);\n-        case 1:\n-                r0 = MP_DIGIT(b,0);\n-        }\n-\n-#ifndef MPI_AMD64_ADD\n-        MP_ADD_CARRY_ZERO(a0, r0, r0, carry);\n-        MP_ADD_CARRY(a1, r1, r1, carry, carry);\n-        MP_ADD_CARRY(a2, r2, r2, carry, carry);\n-#else\n-        __asm__ (\n-                \"xorq   %3,%3           \\n\\t\"\n-                \"addq   %4,%0           \\n\\t\"\n-                \"adcq   %5,%1           \\n\\t\"\n-                \"adcq   %6,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(carry)\n-                : \"r\" (a0), \"r\" (a1), \"r\" (a2), \"0\" (r0),\n-                  \"1\" (r1), \"2\" (r2)\n-                : \"%cc\" );\n-#endif\n-\n-        \/* Do quick 'subract' if we've gone over\n-         * (add the 2's complement of the curve field) *\/\n-        if (carry || ((r2 == MP_DIGIT_MAX) &&\n-                      ((r1 == MP_DIGIT_MAX) ||\n-                        ((r1 == (MP_DIGIT_MAX-1)) && (r0 == MP_DIGIT_MAX))))) {\n-#ifndef MPI_AMD64_ADD\n-                MP_ADD_CARRY_ZERO(r0, 1, r0, carry);\n-                MP_ADD_CARRY(r1, 1, r1, carry, carry);\n-                MP_ADD_CARRY(r2, 0, r2, carry, carry);\n-#else\n-                __asm__ (\n-                        \"addq   $1,%0           \\n\\t\"\n-                        \"adcq   $1,%1           \\n\\t\"\n-                        \"adcq   $0,%2           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2)\n-                        : \"0\" (r0), \"1\" (r1), \"2\" (r2)\n-                        : \"%cc\" );\n-#endif\n-        }\n-\n-\n-        MP_CHECKOK(s_mp_pad(r, 3));\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 3;\n-        s_mp_clamp(r);\n-\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the diff of 192 bit curves. Do the work in-line since the\n- * number of words are so small, we don't want to overhead of mp function\n- * calls.  Uses optimized modular reduction for p192.\n- *\/\n-mp_err\n-ec_GFp_nistp192_sub(const mp_int *a, const mp_int *b, mp_int *r,\n-                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_digit b0 = 0, b1 = 0, b2 = 0;\n-        mp_digit r0 = 0, r1 = 0, r2 = 0;\n-        mp_digit borrow;\n-\n-        switch(MP_USED(a)) {\n-        case 3:\n-                r2 = MP_DIGIT(a,2);\n-        case 2:\n-                r1 = MP_DIGIT(a,1);\n-        case 1:\n-                r0 = MP_DIGIT(a,0);\n-        }\n-\n-        switch(MP_USED(b)) {\n-        case 3:\n-                b2 = MP_DIGIT(b,2);\n-        case 2:\n-                b1 = MP_DIGIT(b,1);\n-        case 1:\n-                b0 = MP_DIGIT(b,0);\n-        }\n-\n-#ifndef MPI_AMD64_ADD\n-        MP_SUB_BORROW(r0, b0, r0, 0,     borrow);\n-        MP_SUB_BORROW(r1, b1, r1, borrow, borrow);\n-        MP_SUB_BORROW(r2, b2, r2, borrow, borrow);\n-#else\n-        __asm__ (\n-                \"xorq   %3,%3           \\n\\t\"\n-                \"subq   %4,%0           \\n\\t\"\n-                \"sbbq   %5,%1           \\n\\t\"\n-                \"sbbq   %6,%2           \\n\\t\"\n-                \"adcq   $0,%3           \\n\\t\"\n-                : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2), \"=r\"(borrow)\n-                : \"r\" (b0), \"r\" (b1), \"r\" (b2), \"0\" (r0),\n-                  \"1\" (r1), \"2\" (r2)\n-                : \"%cc\" );\n-#endif\n-\n-        \/* Do quick 'add' if we've gone under 0\n-         * (subtract the 2's complement of the curve field) *\/\n-        if (borrow) {\n-#ifndef MPI_AMD64_ADD\n-                MP_SUB_BORROW(r0, 1, r0, 0,     borrow);\n-                MP_SUB_BORROW(r1, 1, r1, borrow, borrow);\n-                MP_SUB_BORROW(r2,  0, r2, borrow, borrow);\n-#else\n-                __asm__ (\n-                        \"subq   $1,%0           \\n\\t\"\n-                        \"sbbq   $1,%1           \\n\\t\"\n-                        \"sbbq   $0,%2           \\n\\t\"\n-                        : \"=r\"(r0), \"=r\"(r1), \"=r\"(r2)\n-                        : \"0\" (r0), \"1\" (r1), \"2\" (r2)\n-                        : \"%cc\" );\n-#endif\n-        }\n-\n-        MP_CHECKOK(s_mp_pad(r, 3));\n-        MP_DIGIT(r, 2) = r2;\n-        MP_DIGIT(r, 1) = r1;\n-        MP_DIGIT(r, 0) = r0;\n-        MP_SIGN(r) = MP_ZPOS;\n-        MP_USED(r) = 3;\n-        s_mp_clamp(r);\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-#endif\n-\n-\/* Compute the square of polynomial a, reduce modulo p192. Store the\n- * result in r.  r could be a.  Uses optimized modular reduction for p192.\n- *\/\n-mp_err\n-ec_GFp_nistp192_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_sqr(a, r));\n-        MP_CHECKOK(ec_GFp_nistp192_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the product of two polynomials a and b, reduce modulo p192.\n- * Store the result in r.  r could be a or b; a could be b.  Uses\n- * optimized modular reduction for p192. *\/\n-mp_err\n-ec_GFp_nistp192_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_mul(a, b, r));\n-        MP_CHECKOK(ec_GFp_nistp192_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Divides two field elements. If a is NULL, then returns the inverse of\n- * b. *\/\n-mp_err\n-ec_GFp_nistp192_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t;\n-\n-        \/* If a is NULL, then return the inverse of b, otherwise return a\/b. *\/\n-        if (a == NULL) {\n-                return  mp_invmod(b, &meth->irr, r);\n-        } else {\n-                \/* MPI doesn't support divmod, so we implement it using invmod and\n-                 * mulmod. *\/\n-                MP_CHECKOK(mp_init(&t, FLAG(b)));\n-                MP_CHECKOK(mp_invmod(b, &meth->irr, &t));\n-                MP_CHECKOK(mp_mul(a, &t, r));\n-                MP_CHECKOK(ec_GFp_nistp192_mod(r, r, meth));\n-          CLEANUP:\n-                mp_clear(&t);\n-                return res;\n-        }\n-}\n-\n-\/* Wire in fast field arithmetic and precomputation of base point for\n- * named curves. *\/\n-mp_err\n-ec_group_set_gfp192(ECGroup *group, ECCurveName name)\n-{\n-        if (name == ECCurve_NIST_P192) {\n-                group->meth->field_mod = &ec_GFp_nistp192_mod;\n-                group->meth->field_mul = &ec_GFp_nistp192_mul;\n-                group->meth->field_sqr = &ec_GFp_nistp192_sqr;\n-                group->meth->field_div = &ec_GFp_nistp192_div;\n-#ifndef ECL_THIRTY_TWO_BIT\n-                group->meth->field_add = &ec_GFp_nistp192_add;\n-                group->meth->field_sub = &ec_GFp_nistp192_sub;\n-#endif\n-        }\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_192.c","additions":0,"deletions":517,"binary":false,"changes":517,"status":"deleted"},{"patch":"@@ -1,373 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-#define ECP224_DIGITS ECL_CURVE_DIGITS(224)\n-\n-\/* Fast modular reduction for p224 = 2^224 - 2^96 + 1.  a can be r. Uses\n- * algorithm 7 from Brown, Hankerson, Lopez, Menezes. Software\n- * Implementation of the NIST Elliptic Curves over Prime Fields. *\/\n-mp_err\n-ec_GFp_nistp224_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_size a_used = MP_USED(a);\n-\n-        int    r3b;\n-        mp_digit carry;\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit a6a = 0, a6b = 0,\n-                a5a = 0, a5b = 0, a4a = 0, a4b = 0, a3a = 0, a3b = 0;\n-        mp_digit r0a, r0b, r1a, r1b, r2a, r2b, r3a;\n-#else\n-        mp_digit a6 = 0, a5 = 0, a4 = 0, a3b = 0, a5a = 0;\n-        mp_digit a6b = 0, a6a_a5b = 0, a5b = 0, a5a_a4b = 0, a4a_a3b = 0;\n-        mp_digit r0, r1, r2, r3;\n-#endif\n-\n-        \/* reduction not needed if a is not larger than field size *\/\n-        if (a_used < ECP224_DIGITS) {\n-                if (a == r) return MP_OKAY;\n-                return mp_copy(a, r);\n-        }\n-        \/* for polynomials larger than twice the field size, use regular\n-         * reduction *\/\n-        if (a_used > ECL_CURVE_DIGITS(224*2)) {\n-                MP_CHECKOK(mp_mod(a, &meth->irr, r));\n-        } else {\n-#ifdef ECL_THIRTY_TWO_BIT\n-                \/* copy out upper words of a *\/\n-                switch (a_used) {\n-                case 14:\n-                        a6b = MP_DIGIT(a, 13);\n-                case 13:\n-                        a6a = MP_DIGIT(a, 12);\n-                case 12:\n-                        a5b = MP_DIGIT(a, 11);\n-                case 11:\n-                        a5a = MP_DIGIT(a, 10);\n-                case 10:\n-                        a4b = MP_DIGIT(a, 9);\n-                case 9:\n-                        a4a = MP_DIGIT(a, 8);\n-                case 8:\n-                        a3b = MP_DIGIT(a, 7);\n-                }\n-                r3a = MP_DIGIT(a, 6);\n-                r2b= MP_DIGIT(a, 5);\n-                r2a= MP_DIGIT(a, 4);\n-                r1b = MP_DIGIT(a, 3);\n-                r1a = MP_DIGIT(a, 2);\n-                r0b = MP_DIGIT(a, 1);\n-                r0a = MP_DIGIT(a, 0);\n-\n-\n-                \/* implement r = (a3a,a2,a1,a0)\n-                        +(a5a, a4,a3b,  0)\n-                        +(  0, a6,a5b,  0)\n-                        -(  0    0,    0|a6b, a6a|a5b )\n-                        -(  a6b, a6a|a5b, a5a|a4b, a4a|a3b ) *\/\n-                MP_ADD_CARRY (r1b, a3b, r1b, 0,     carry);\n-                MP_ADD_CARRY (r2a, a4a, r2a, carry, carry);\n-                MP_ADD_CARRY (r2b, a4b, r2b, carry, carry);\n-                MP_ADD_CARRY (r3a, a5a, r3a, carry, carry);\n-                r3b = carry;\n-                MP_ADD_CARRY (r1b, a5b, r1b, 0,     carry);\n-                MP_ADD_CARRY (r2a, a6a, r2a, carry, carry);\n-                MP_ADD_CARRY (r2b, a6b, r2b, carry, carry);\n-                MP_ADD_CARRY (r3a,   0, r3a, carry, carry);\n-                r3b += carry;\n-                MP_SUB_BORROW(r0a, a3b, r0a, 0,     carry);\n-                MP_SUB_BORROW(r0b, a4a, r0b, carry, carry);\n-                MP_SUB_BORROW(r1a, a4b, r1a, carry, carry);\n-                MP_SUB_BORROW(r1b, a5a, r1b, carry, carry);\n-                MP_SUB_BORROW(r2a, a5b, r2a, carry, carry);\n-                MP_SUB_BORROW(r2b, a6a, r2b, carry, carry);\n-                MP_SUB_BORROW(r3a, a6b, r3a, carry, carry);\n-                r3b -= carry;\n-                MP_SUB_BORROW(r0a, a5b, r0a, 0,     carry);\n-                MP_SUB_BORROW(r0b, a6a, r0b, carry, carry);\n-                MP_SUB_BORROW(r1a, a6b, r1a, carry, carry);\n-                if (carry) {\n-                        MP_SUB_BORROW(r1b, 0, r1b, carry, carry);\n-                        MP_SUB_BORROW(r2a, 0, r2a, carry, carry);\n-                        MP_SUB_BORROW(r2b, 0, r2b, carry, carry);\n-                        MP_SUB_BORROW(r3a, 0, r3a, carry, carry);\n-                        r3b -= carry;\n-                }\n-\n-                while (r3b > 0) {\n-                        int tmp;\n-                        MP_ADD_CARRY(r1b, r3b, r1b, 0,     carry);\n-                        if (carry) {\n-                                MP_ADD_CARRY(r2a,  0, r2a, carry, carry);\n-                                MP_ADD_CARRY(r2b,  0, r2b, carry, carry);\n-                                MP_ADD_CARRY(r3a,  0, r3a, carry, carry);\n-                        }\n-                        tmp = carry;\n-                        MP_SUB_BORROW(r0a, r3b, r0a, 0,     carry);\n-                        if (carry) {\n-                                MP_SUB_BORROW(r0b, 0, r0b, carry, carry);\n-                                MP_SUB_BORROW(r1a, 0, r1a, carry, carry);\n-                                MP_SUB_BORROW(r1b, 0, r1b, carry, carry);\n-                                MP_SUB_BORROW(r2a, 0, r2a, carry, carry);\n-                                MP_SUB_BORROW(r2b, 0, r2b, carry, carry);\n-                                MP_SUB_BORROW(r3a, 0, r3a, carry, carry);\n-                                tmp -= carry;\n-                        }\n-                        r3b = tmp;\n-                }\n-\n-                while (r3b < 0) {\n-                        mp_digit maxInt = MP_DIGIT_MAX;\n-                        MP_ADD_CARRY (r0a, 1, r0a, 0,     carry);\n-                        MP_ADD_CARRY (r0b, 0, r0b, carry, carry);\n-                        MP_ADD_CARRY (r1a, 0, r1a, carry, carry);\n-                        MP_ADD_CARRY (r1b, maxInt, r1b, carry, carry);\n-                        MP_ADD_CARRY (r2a, maxInt, r2a, carry, carry);\n-                        MP_ADD_CARRY (r2b, maxInt, r2b, carry, carry);\n-                        MP_ADD_CARRY (r3a, maxInt, r3a, carry, carry);\n-                        r3b += carry;\n-                }\n-                \/* check for final reduction *\/\n-                \/* now the only way we are over is if the top 4 words are all ones *\/\n-                if ((r3a == MP_DIGIT_MAX) && (r2b == MP_DIGIT_MAX)\n-                        && (r2a == MP_DIGIT_MAX) && (r1b == MP_DIGIT_MAX) &&\n-                         ((r1a != 0) || (r0b != 0) || (r0a != 0)) ) {\n-                        \/* one last subraction *\/\n-                        MP_SUB_BORROW(r0a, 1, r0a, 0,     carry);\n-                        MP_SUB_BORROW(r0b, 0, r0b, carry, carry);\n-                        MP_SUB_BORROW(r1a, 0, r1a, carry, carry);\n-                        r1b = r2a = r2b = r3a = 0;\n-                }\n-\n-\n-                if (a != r) {\n-                        MP_CHECKOK(s_mp_pad(r, 7));\n-                }\n-                \/* set the lower words of r *\/\n-                MP_SIGN(r) = MP_ZPOS;\n-                MP_USED(r) = 7;\n-                MP_DIGIT(r, 6) = r3a;\n-                MP_DIGIT(r, 5) = r2b;\n-                MP_DIGIT(r, 4) = r2a;\n-                MP_DIGIT(r, 3) = r1b;\n-                MP_DIGIT(r, 2) = r1a;\n-                MP_DIGIT(r, 1) = r0b;\n-                MP_DIGIT(r, 0) = r0a;\n-#else\n-                \/* copy out upper words of a *\/\n-                switch (a_used) {\n-                case 7:\n-                        a6 = MP_DIGIT(a, 6);\n-                        a6b = a6 >> 32;\n-                        a6a_a5b = a6 << 32;\n-                case 6:\n-                        a5 = MP_DIGIT(a, 5);\n-                        a5b = a5 >> 32;\n-                        a6a_a5b |= a5b;\n-                        a5b = a5b << 32;\n-                        a5a_a4b = a5 << 32;\n-                        a5a = a5 & 0xffffffff;\n-                case 5:\n-                        a4 = MP_DIGIT(a, 4);\n-                        a5a_a4b |= a4 >> 32;\n-                        a4a_a3b = a4 << 32;\n-                case 4:\n-                        a3b = MP_DIGIT(a, 3) >> 32;\n-                        a4a_a3b |= a3b;\n-                        a3b = a3b << 32;\n-                }\n-\n-                r3 = MP_DIGIT(a, 3) & 0xffffffff;\n-                r2 = MP_DIGIT(a, 2);\n-                r1 = MP_DIGIT(a, 1);\n-                r0 = MP_DIGIT(a, 0);\n-\n-                \/* implement r = (a3a,a2,a1,a0)\n-                        +(a5a, a4,a3b,  0)\n-                        +(  0, a6,a5b,  0)\n-                        -(  0    0,    0|a6b, a6a|a5b )\n-                        -(  a6b, a6a|a5b, a5a|a4b, a4a|a3b ) *\/\n-                MP_ADD_CARRY_ZERO (r1, a3b, r1, carry);\n-                MP_ADD_CARRY (r2, a4 , r2, carry, carry);\n-                MP_ADD_CARRY (r3, a5a, r3, carry, carry);\n-                MP_ADD_CARRY_ZERO (r1, a5b, r1, carry);\n-                MP_ADD_CARRY (r2, a6 , r2, carry, carry);\n-                MP_ADD_CARRY (r3,   0, r3, carry, carry);\n-\n-                MP_SUB_BORROW(r0, a4a_a3b, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a5a_a4b, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a6a_a5b, r2, carry, carry);\n-                MP_SUB_BORROW(r3, a6b    , r3, carry, carry);\n-                MP_SUB_BORROW(r0, a6a_a5b, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a6b    , r1, carry, carry);\n-                if (carry) {\n-                        MP_SUB_BORROW(r2, 0, r2, carry, carry);\n-                        MP_SUB_BORROW(r3, 0, r3, carry, carry);\n-                }\n-\n-\n-                \/* if the value is negative, r3 has a 2's complement\n-                 * high value *\/\n-                r3b = (int)(r3 >>32);\n-                while (r3b > 0) {\n-                        r3 &= 0xffffffff;\n-                        MP_ADD_CARRY_ZERO(r1,((mp_digit)r3b) << 32, r1, carry);\n-                        if (carry) {\n-                                MP_ADD_CARRY(r2,  0, r2, carry, carry);\n-                                MP_ADD_CARRY(r3,  0, r3, carry, carry);\n-                        }\n-                        MP_SUB_BORROW(r0, r3b, r0, 0, carry);\n-                        if (carry) {\n-                                MP_SUB_BORROW(r1, 0, r1, carry, carry);\n-                                MP_SUB_BORROW(r2, 0, r2, carry, carry);\n-                                MP_SUB_BORROW(r3, 0, r3, carry, carry);\n-                        }\n-                        r3b = (int)(r3 >>32);\n-                }\n-\n-                while (r3b < 0) {\n-                        MP_ADD_CARRY_ZERO (r0, 1, r0, carry);\n-                        MP_ADD_CARRY (r1, MP_DIGIT_MAX <<32, r1, carry, carry);\n-                        MP_ADD_CARRY (r2, MP_DIGIT_MAX, r2, carry, carry);\n-                        MP_ADD_CARRY (r3, MP_DIGIT_MAX >> 32, r3, carry, carry);\n-                        r3b = (int)(r3 >>32);\n-                }\n-                \/* check for final reduction *\/\n-                \/* now the only way we are over is if the top 4 words are all ones *\/\n-                if ((r3 == (MP_DIGIT_MAX >> 32)) && (r2 == MP_DIGIT_MAX)\n-                        && ((r1 & MP_DIGIT_MAX << 32)== MP_DIGIT_MAX << 32) &&\n-                         ((r1 != MP_DIGIT_MAX << 32 ) || (r0 != 0)) ) {\n-                        \/* one last subraction *\/\n-                        MP_SUB_BORROW(r0, 1, r0, 0,     carry);\n-                        MP_SUB_BORROW(r1, 0, r1, carry, carry);\n-                        r2 = r3 = 0;\n-                }\n-\n-\n-                if (a != r) {\n-                        MP_CHECKOK(s_mp_pad(r, 4));\n-                }\n-                \/* set the lower words of r *\/\n-                MP_SIGN(r) = MP_ZPOS;\n-                MP_USED(r) = 4;\n-                MP_DIGIT(r, 3) = r3;\n-                MP_DIGIT(r, 2) = r2;\n-                MP_DIGIT(r, 1) = r1;\n-                MP_DIGIT(r, 0) = r0;\n-#endif\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the square of polynomial a, reduce modulo p224. Store the\n- * result in r.  r could be a.  Uses optimized modular reduction for p224.\n- *\/\n-mp_err\n-ec_GFp_nistp224_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_sqr(a, r));\n-        MP_CHECKOK(ec_GFp_nistp224_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the product of two polynomials a and b, reduce modulo p224.\n- * Store the result in r.  r could be a or b; a could be b.  Uses\n- * optimized modular reduction for p224. *\/\n-mp_err\n-ec_GFp_nistp224_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_mul(a, b, r));\n-        MP_CHECKOK(ec_GFp_nistp224_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Divides two field elements. If a is NULL, then returns the inverse of\n- * b. *\/\n-mp_err\n-ec_GFp_nistp224_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t;\n-\n-        \/* If a is NULL, then return the inverse of b, otherwise return a\/b. *\/\n-        if (a == NULL) {\n-                return  mp_invmod(b, &meth->irr, r);\n-        } else {\n-                \/* MPI doesn't support divmod, so we implement it using invmod and\n-                 * mulmod. *\/\n-                MP_CHECKOK(mp_init(&t, FLAG(b)));\n-                MP_CHECKOK(mp_invmod(b, &meth->irr, &t));\n-                MP_CHECKOK(mp_mul(a, &t, r));\n-                MP_CHECKOK(ec_GFp_nistp224_mod(r, r, meth));\n-          CLEANUP:\n-                mp_clear(&t);\n-                return res;\n-        }\n-}\n-\n-\/* Wire in fast field arithmetic and precomputation of base point for\n- * named curves. *\/\n-mp_err\n-ec_group_set_gfp224(ECGroup *group, ECCurveName name)\n-{\n-        if (name == ECCurve_NIST_P224) {\n-                group->meth->field_mod = &ec_GFp_nistp224_mod;\n-                group->meth->field_mul = &ec_GFp_nistp224_mul;\n-                group->meth->field_sqr = &ec_GFp_nistp224_sqr;\n-                group->meth->field_div = &ec_GFp_nistp224_div;\n-        }\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_224.c","additions":0,"deletions":373,"binary":false,"changes":373,"status":"deleted"},{"patch":"@@ -1,430 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Fast modular reduction for p256 = 2^256 - 2^224 + 2^192+ 2^96 - 1.  a can be r.\n- * Uses algorithm 2.29 from Hankerson, Menezes, Vanstone. Guide to\n- * Elliptic Curve Cryptography. *\/\n-mp_err\n-ec_GFp_nistp256_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_size a_used = MP_USED(a);\n-        int a_bits = mpl_significant_bits(a);\n-        mp_digit carry;\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit a8=0, a9=0, a10=0, a11=0, a12=0, a13=0, a14=0, a15=0;\n-        mp_digit r0, r1, r2, r3, r4, r5, r6, r7;\n-        int r8; \/* must be a signed value ! *\/\n-#else\n-        mp_digit a4=0, a5=0, a6=0, a7=0;\n-        mp_digit a4h, a4l, a5h, a5l, a6h, a6l, a7h, a7l;\n-        mp_digit r0, r1, r2, r3;\n-        int r4; \/* must be a signed value ! *\/\n-#endif\n-        \/* for polynomials larger than twice the field size\n-         * use regular reduction *\/\n-        if (a_bits < 256) {\n-                if (a == r) return MP_OKAY;\n-                return mp_copy(a,r);\n-        }\n-        if (a_bits > 512)  {\n-                MP_CHECKOK(mp_mod(a, &meth->irr, r));\n-        } else {\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-                switch (a_used) {\n-                case 16:\n-                        a15 = MP_DIGIT(a,15);\n-                case 15:\n-                        a14 = MP_DIGIT(a,14);\n-                case 14:\n-                        a13 = MP_DIGIT(a,13);\n-                case 13:\n-                        a12 = MP_DIGIT(a,12);\n-                case 12:\n-                        a11 = MP_DIGIT(a,11);\n-                case 11:\n-                        a10 = MP_DIGIT(a,10);\n-                case 10:\n-                        a9 = MP_DIGIT(a,9);\n-                case 9:\n-                        a8 = MP_DIGIT(a,8);\n-                }\n-\n-                r0 = MP_DIGIT(a,0);\n-                r1 = MP_DIGIT(a,1);\n-                r2 = MP_DIGIT(a,2);\n-                r3 = MP_DIGIT(a,3);\n-                r4 = MP_DIGIT(a,4);\n-                r5 = MP_DIGIT(a,5);\n-                r6 = MP_DIGIT(a,6);\n-                r7 = MP_DIGIT(a,7);\n-\n-                \/* sum 1 *\/\n-                MP_ADD_CARRY(r3, a11, r3, 0,     carry);\n-                MP_ADD_CARRY(r4, a12, r4, carry, carry);\n-                MP_ADD_CARRY(r5, a13, r5, carry, carry);\n-                MP_ADD_CARRY(r6, a14, r6, carry, carry);\n-                MP_ADD_CARRY(r7, a15, r7, carry, carry);\n-                r8 = carry;\n-                MP_ADD_CARRY(r3, a11, r3, 0,     carry);\n-                MP_ADD_CARRY(r4, a12, r4, carry, carry);\n-                MP_ADD_CARRY(r5, a13, r5, carry, carry);\n-                MP_ADD_CARRY(r6, a14, r6, carry, carry);\n-                MP_ADD_CARRY(r7, a15, r7, carry, carry);\n-                r8 += carry;\n-                \/* sum 2 *\/\n-                MP_ADD_CARRY(r3, a12, r3, 0,     carry);\n-                MP_ADD_CARRY(r4, a13, r4, carry, carry);\n-                MP_ADD_CARRY(r5, a14, r5, carry, carry);\n-                MP_ADD_CARRY(r6, a15, r6, carry, carry);\n-                MP_ADD_CARRY(r7,   0, r7, carry, carry);\n-                r8 += carry;\n-                \/* combine last bottom of sum 3 with second sum 2 *\/\n-                MP_ADD_CARRY(r0, a8,  r0, 0,     carry);\n-                MP_ADD_CARRY(r1, a9,  r1, carry, carry);\n-                MP_ADD_CARRY(r2, a10, r2, carry, carry);\n-                MP_ADD_CARRY(r3, a12, r3, carry, carry);\n-                MP_ADD_CARRY(r4, a13, r4, carry, carry);\n-                MP_ADD_CARRY(r5, a14, r5, carry, carry);\n-                MP_ADD_CARRY(r6, a15, r6, carry, carry);\n-                MP_ADD_CARRY(r7, a15, r7, carry, carry); \/* from sum 3 *\/\n-                r8 += carry;\n-                \/* sum 3 (rest of it)*\/\n-                MP_ADD_CARRY(r6, a14, r6, 0,     carry);\n-                MP_ADD_CARRY(r7,   0, r7, carry, carry);\n-                r8 += carry;\n-                \/* sum 4 (rest of it)*\/\n-                MP_ADD_CARRY(r0, a9,  r0, 0,     carry);\n-                MP_ADD_CARRY(r1, a10, r1, carry, carry);\n-                MP_ADD_CARRY(r2, a11, r2, carry, carry);\n-                MP_ADD_CARRY(r3, a13, r3, carry, carry);\n-                MP_ADD_CARRY(r4, a14, r4, carry, carry);\n-                MP_ADD_CARRY(r5, a15, r5, carry, carry);\n-                MP_ADD_CARRY(r6, a13, r6, carry, carry);\n-                MP_ADD_CARRY(r7, a8,  r7, carry, carry);\n-                r8 += carry;\n-                \/* diff 5 *\/\n-                MP_SUB_BORROW(r0, a11, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a12, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a13, r2, carry, carry);\n-                MP_SUB_BORROW(r3,   0, r3, carry, carry);\n-                MP_SUB_BORROW(r4,   0, r4, carry, carry);\n-                MP_SUB_BORROW(r5,   0, r5, carry, carry);\n-                MP_SUB_BORROW(r6, a8,  r6, carry, carry);\n-                MP_SUB_BORROW(r7, a10, r7, carry, carry);\n-                r8 -= carry;\n-                \/* diff 6 *\/\n-                MP_SUB_BORROW(r0, a12, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a13, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a14, r2, carry, carry);\n-                MP_SUB_BORROW(r3, a15, r3, carry, carry);\n-                MP_SUB_BORROW(r4,   0, r4, carry, carry);\n-                MP_SUB_BORROW(r5,   0, r5, carry, carry);\n-                MP_SUB_BORROW(r6, a9,  r6, carry, carry);\n-                MP_SUB_BORROW(r7, a11, r7, carry, carry);\n-                r8 -= carry;\n-                \/* diff 7 *\/\n-                MP_SUB_BORROW(r0, a13, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a14, r1, carry, carry);\n-                MP_SUB_BORROW(r2, a15, r2, carry, carry);\n-                MP_SUB_BORROW(r3, a8,  r3, carry, carry);\n-                MP_SUB_BORROW(r4, a9,  r4, carry, carry);\n-                MP_SUB_BORROW(r5, a10, r5, carry, carry);\n-                MP_SUB_BORROW(r6, 0,   r6, carry, carry);\n-                MP_SUB_BORROW(r7, a12, r7, carry, carry);\n-                r8 -= carry;\n-                \/* diff 8 *\/\n-                MP_SUB_BORROW(r0, a14, r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a15, r1, carry, carry);\n-                MP_SUB_BORROW(r2, 0,   r2, carry, carry);\n-                MP_SUB_BORROW(r3, a9,  r3, carry, carry);\n-                MP_SUB_BORROW(r4, a10, r4, carry, carry);\n-                MP_SUB_BORROW(r5, a11, r5, carry, carry);\n-                MP_SUB_BORROW(r6, 0,   r6, carry, carry);\n-                MP_SUB_BORROW(r7, a13, r7, carry, carry);\n-                r8 -= carry;\n-\n-                \/* reduce the overflows *\/\n-                while (r8 > 0) {\n-                        mp_digit r8_d = r8;\n-                        MP_ADD_CARRY(r0, r8_d,         r0, 0,     carry);\n-                        MP_ADD_CARRY(r1, 0,            r1, carry, carry);\n-                        MP_ADD_CARRY(r2, 0,            r2, carry, carry);\n-                        MP_ADD_CARRY(r3, -r8_d,        r3, carry, carry);\n-                        MP_ADD_CARRY(r4, MP_DIGIT_MAX, r4, carry, carry);\n-                        MP_ADD_CARRY(r5, MP_DIGIT_MAX, r5, carry, carry);\n-                        MP_ADD_CARRY(r6, -(r8_d+1),    r6, carry, carry);\n-                        MP_ADD_CARRY(r7, (r8_d-1),     r7, carry, carry);\n-                        r8 = carry;\n-                }\n-\n-                \/* reduce the underflows *\/\n-                while (r8 < 0) {\n-                        mp_digit r8_d = -r8;\n-                        MP_SUB_BORROW(r0, r8_d,         r0, 0,     carry);\n-                        MP_SUB_BORROW(r1, 0,            r1, carry, carry);\n-                        MP_SUB_BORROW(r2, 0,            r2, carry, carry);\n-                        MP_SUB_BORROW(r3, -r8_d,        r3, carry, carry);\n-                        MP_SUB_BORROW(r4, MP_DIGIT_MAX, r4, carry, carry);\n-                        MP_SUB_BORROW(r5, MP_DIGIT_MAX, r5, carry, carry);\n-                        MP_SUB_BORROW(r6, -(r8_d+1),    r6, carry, carry);\n-                        MP_SUB_BORROW(r7, (r8_d-1),     r7, carry, carry);\n-                        r8 = -carry;\n-                }\n-                if (a != r) {\n-                        MP_CHECKOK(s_mp_pad(r,8));\n-                }\n-                MP_SIGN(r) = MP_ZPOS;\n-                MP_USED(r) = 8;\n-\n-                MP_DIGIT(r,7) = r7;\n-                MP_DIGIT(r,6) = r6;\n-                MP_DIGIT(r,5) = r5;\n-                MP_DIGIT(r,4) = r4;\n-                MP_DIGIT(r,3) = r3;\n-                MP_DIGIT(r,2) = r2;\n-                MP_DIGIT(r,1) = r1;\n-                MP_DIGIT(r,0) = r0;\n-\n-                \/* final reduction if necessary *\/\n-                if ((r7 == MP_DIGIT_MAX) &&\n-                        ((r6 > 1) || ((r6 == 1) &&\n-                        (r5 || r4 || r3 ||\n-                                ((r2 == MP_DIGIT_MAX) && (r1 == MP_DIGIT_MAX)\n-                                  && (r0 == MP_DIGIT_MAX)))))) {\n-                        MP_CHECKOK(mp_sub(r, &meth->irr, r));\n-                }\n-#ifdef notdef\n-\n-\n-                \/* smooth the negatives *\/\n-                while (MP_SIGN(r) != MP_ZPOS) {\n-                        MP_CHECKOK(mp_add(r, &meth->irr, r));\n-                }\n-                while (MP_USED(r) > 8) {\n-                        MP_CHECKOK(mp_sub(r, &meth->irr, r));\n-                }\n-\n-                \/* final reduction if necessary *\/\n-                if (MP_DIGIT(r,7) >= MP_DIGIT(&meth->irr,7)) {\n-                    if (mp_cmp(r,&meth->irr) != MP_LT) {\n-                        MP_CHECKOK(mp_sub(r, &meth->irr, r));\n-                    }\n-                }\n-#endif\n-                s_mp_clamp(r);\n-#else\n-                switch (a_used) {\n-                case 8:\n-                        a7 = MP_DIGIT(a,7);\n-                case 7:\n-                        a6 = MP_DIGIT(a,6);\n-                case 6:\n-                        a5 = MP_DIGIT(a,5);\n-                case 5:\n-                        a4 = MP_DIGIT(a,4);\n-                }\n-                a7l = a7 << 32;\n-                a7h = a7 >> 32;\n-                a6l = a6 << 32;\n-                a6h = a6 >> 32;\n-                a5l = a5 << 32;\n-                a5h = a5 >> 32;\n-                a4l = a4 << 32;\n-                a4h = a4 >> 32;\n-                r3 = MP_DIGIT(a,3);\n-                r2 = MP_DIGIT(a,2);\n-                r1 = MP_DIGIT(a,1);\n-                r0 = MP_DIGIT(a,0);\n-\n-                \/* sum 1 *\/\n-                MP_ADD_CARRY_ZERO(r1, a5h << 32, r1, carry);\n-                MP_ADD_CARRY(r2, a6,        r2, carry, carry);\n-                MP_ADD_CARRY(r3, a7,        r3, carry, carry);\n-                r4 = carry;\n-                MP_ADD_CARRY_ZERO(r1, a5h << 32, r1, carry);\n-                MP_ADD_CARRY(r2, a6,        r2, carry, carry);\n-                MP_ADD_CARRY(r3, a7,        r3, carry, carry);\n-                r4 += carry;\n-                \/* sum 2 *\/\n-                MP_ADD_CARRY_ZERO(r1, a6l,       r1, carry);\n-                MP_ADD_CARRY(r2, a6h | a7l, r2, carry, carry);\n-                MP_ADD_CARRY(r3, a7h,       r3, carry, carry);\n-                r4 += carry;\n-                MP_ADD_CARRY_ZERO(r1, a6l,       r1, carry);\n-                MP_ADD_CARRY(r2, a6h | a7l, r2, carry, carry);\n-                MP_ADD_CARRY(r3, a7h,       r3, carry, carry);\n-                r4 += carry;\n-\n-                \/* sum 3 *\/\n-                MP_ADD_CARRY_ZERO(r0, a4,        r0, carry);\n-                MP_ADD_CARRY(r1, a5l >> 32, r1, carry, carry);\n-                MP_ADD_CARRY(r2, 0,         r2, carry, carry);\n-                MP_ADD_CARRY(r3, a7,        r3, carry, carry);\n-                r4 += carry;\n-                \/* sum 4 *\/\n-                MP_ADD_CARRY_ZERO(r0, a4h | a5l,     r0, carry);\n-                MP_ADD_CARRY(r1, a5h|(a6h<<32), r1, carry, carry);\n-                MP_ADD_CARRY(r2, a7,            r2, carry, carry);\n-                MP_ADD_CARRY(r3, a6h | a4l,     r3, carry, carry);\n-                r4 += carry;\n-                \/* diff 5 *\/\n-                MP_SUB_BORROW(r0, a5h | a6l,    r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a6h,          r1, carry, carry);\n-                MP_SUB_BORROW(r2, 0,            r2, carry, carry);\n-                MP_SUB_BORROW(r3, (a4l>>32)|a5l,r3, carry, carry);\n-                r4 -= carry;\n-                \/* diff 6 *\/\n-                MP_SUB_BORROW(r0, a6,           r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a7,           r1, carry, carry);\n-                MP_SUB_BORROW(r2, 0,            r2, carry, carry);\n-                MP_SUB_BORROW(r3, a4h|(a5h<<32),r3, carry, carry);\n-                r4 -= carry;\n-                \/* diff 7 *\/\n-                MP_SUB_BORROW(r0, a6h|a7l,      r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a7h|a4l,      r1, carry, carry);\n-                MP_SUB_BORROW(r2, a4h|a5l,      r2, carry, carry);\n-                MP_SUB_BORROW(r3, a6l,          r3, carry, carry);\n-                r4 -= carry;\n-                \/* diff 8 *\/\n-                MP_SUB_BORROW(r0, a7,           r0, 0,     carry);\n-                MP_SUB_BORROW(r1, a4h<<32,      r1, carry, carry);\n-                MP_SUB_BORROW(r2, a5,           r2, carry, carry);\n-                MP_SUB_BORROW(r3, a6h<<32,      r3, carry, carry);\n-                r4 -= carry;\n-\n-                \/* reduce the overflows *\/\n-                while (r4 > 0) {\n-                        mp_digit r4_long = r4;\n-                        mp_digit r4l = (r4_long << 32);\n-                        MP_ADD_CARRY_ZERO(r0, r4_long,      r0, carry);\n-                        MP_ADD_CARRY(r1, -r4l,         r1, carry, carry);\n-                        MP_ADD_CARRY(r2, MP_DIGIT_MAX, r2, carry, carry);\n-                        MP_ADD_CARRY(r3, r4l-r4_long-1,r3, carry, carry);\n-                        r4 = carry;\n-                }\n-\n-                \/* reduce the underflows *\/\n-                while (r4 < 0) {\n-                        mp_digit r4_long = -r4;\n-                        mp_digit r4l = (r4_long << 32);\n-                        MP_SUB_BORROW(r0, r4_long,      r0, 0,     carry);\n-                        MP_SUB_BORROW(r1, -r4l,         r1, carry, carry);\n-                        MP_SUB_BORROW(r2, MP_DIGIT_MAX, r2, carry, carry);\n-                        MP_SUB_BORROW(r3, r4l-r4_long-1,r3, carry, carry);\n-                        r4 = -carry;\n-                }\n-\n-                if (a != r) {\n-                        MP_CHECKOK(s_mp_pad(r,4));\n-                }\n-                MP_SIGN(r) = MP_ZPOS;\n-                MP_USED(r) = 4;\n-\n-                MP_DIGIT(r,3) = r3;\n-                MP_DIGIT(r,2) = r2;\n-                MP_DIGIT(r,1) = r1;\n-                MP_DIGIT(r,0) = r0;\n-\n-                \/* final reduction if necessary *\/\n-                if ((r3 > 0xFFFFFFFF00000001ULL) ||\n-                        ((r3 == 0xFFFFFFFF00000001ULL) &&\n-                        (r2 || (r1 >> 32)||\n-                               (r1 == 0xFFFFFFFFULL && r0 == MP_DIGIT_MAX)))) {\n-                        \/* very rare, just use mp_sub *\/\n-                        MP_CHECKOK(mp_sub(r, &meth->irr, r));\n-                }\n-\n-                s_mp_clamp(r);\n-#endif\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the square of polynomial a, reduce modulo p256. Store the\n- * result in r.  r could be a.  Uses optimized modular reduction for p256.\n- *\/\n-mp_err\n-ec_GFp_nistp256_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_sqr(a, r));\n-        MP_CHECKOK(ec_GFp_nistp256_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the product of two polynomials a and b, reduce modulo p256.\n- * Store the result in r.  r could be a or b; a could be b.  Uses\n- * optimized modular reduction for p256. *\/\n-mp_err\n-ec_GFp_nistp256_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_mul(a, b, r));\n-        MP_CHECKOK(ec_GFp_nistp256_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Wire in fast field arithmetic and precomputation of base point for\n- * named curves. *\/\n-mp_err\n-ec_group_set_gfp256(ECGroup *group, ECCurveName name)\n-{\n-        if (name == ECCurve_NIST_P256) {\n-                group->meth->field_mod = &ec_GFp_nistp256_mod;\n-                group->meth->field_mul = &ec_GFp_nistp256_mul;\n-                group->meth->field_sqr = &ec_GFp_nistp256_sqr;\n-        }\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_256.c","additions":0,"deletions":430,"binary":false,"changes":430,"status":"deleted"},{"patch":"@@ -1,294 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Fast modular reduction for p384 = 2^384 - 2^128 - 2^96 + 2^32 - 1.  a can be r.\n- * Uses algorithm 2.30 from Hankerson, Menezes, Vanstone. Guide to\n- * Elliptic Curve Cryptography. *\/\n-mp_err\n-ec_GFp_nistp384_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        int a_bits = mpl_significant_bits(a);\n-        int i;\n-\n-        \/* m1, m2 are statically-allocated mp_int of exactly the size we need *\/\n-        mp_int m[10];\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        mp_digit s[10][12];\n-        for (i = 0; i < 10; i++) {\n-                MP_SIGN(&m[i]) = MP_ZPOS;\n-                MP_ALLOC(&m[i]) = 12;\n-                MP_USED(&m[i]) = 12;\n-                MP_DIGITS(&m[i]) = s[i];\n-        }\n-#else\n-        mp_digit s[10][6];\n-        for (i = 0; i < 10; i++) {\n-                MP_SIGN(&m[i]) = MP_ZPOS;\n-                MP_ALLOC(&m[i]) = 6;\n-                MP_USED(&m[i]) = 6;\n-                MP_DIGITS(&m[i]) = s[i];\n-        }\n-#endif\n-\n-#ifdef ECL_THIRTY_TWO_BIT\n-        \/* for polynomials larger than twice the field size or polynomials\n-         * not using all words, use regular reduction *\/\n-        if ((a_bits > 768) || (a_bits <= 736)) {\n-                MP_CHECKOK(mp_mod(a, &meth->irr, r));\n-        } else {\n-                for (i = 0; i < 12; i++) {\n-                        s[0][i] = MP_DIGIT(a, i);\n-                }\n-                s[1][0] = 0;\n-                s[1][1] = 0;\n-                s[1][2] = 0;\n-                s[1][3] = 0;\n-                s[1][4] = MP_DIGIT(a, 21);\n-                s[1][5] = MP_DIGIT(a, 22);\n-                s[1][6] = MP_DIGIT(a, 23);\n-                s[1][7] = 0;\n-                s[1][8] = 0;\n-                s[1][9] = 0;\n-                s[1][10] = 0;\n-                s[1][11] = 0;\n-                for (i = 0; i < 12; i++) {\n-                        s[2][i] = MP_DIGIT(a, i+12);\n-                }\n-                s[3][0] = MP_DIGIT(a, 21);\n-                s[3][1] = MP_DIGIT(a, 22);\n-                s[3][2] = MP_DIGIT(a, 23);\n-                for (i = 3; i < 12; i++) {\n-                        s[3][i] = MP_DIGIT(a, i+9);\n-                }\n-                s[4][0] = 0;\n-                s[4][1] = MP_DIGIT(a, 23);\n-                s[4][2] = 0;\n-                s[4][3] = MP_DIGIT(a, 20);\n-                for (i = 4; i < 12; i++) {\n-                        s[4][i] = MP_DIGIT(a, i+8);\n-                }\n-                s[5][0] = 0;\n-                s[5][1] = 0;\n-                s[5][2] = 0;\n-                s[5][3] = 0;\n-                s[5][4] = MP_DIGIT(a, 20);\n-                s[5][5] = MP_DIGIT(a, 21);\n-                s[5][6] = MP_DIGIT(a, 22);\n-                s[5][7] = MP_DIGIT(a, 23);\n-                s[5][8] = 0;\n-                s[5][9] = 0;\n-                s[5][10] = 0;\n-                s[5][11] = 0;\n-                s[6][0] = MP_DIGIT(a, 20);\n-                s[6][1] = 0;\n-                s[6][2] = 0;\n-                s[6][3] = MP_DIGIT(a, 21);\n-                s[6][4] = MP_DIGIT(a, 22);\n-                s[6][5] = MP_DIGIT(a, 23);\n-                s[6][6] = 0;\n-                s[6][7] = 0;\n-                s[6][8] = 0;\n-                s[6][9] = 0;\n-                s[6][10] = 0;\n-                s[6][11] = 0;\n-                s[7][0] = MP_DIGIT(a, 23);\n-                for (i = 1; i < 12; i++) {\n-                        s[7][i] = MP_DIGIT(a, i+11);\n-                }\n-                s[8][0] = 0;\n-                s[8][1] = MP_DIGIT(a, 20);\n-                s[8][2] = MP_DIGIT(a, 21);\n-                s[8][3] = MP_DIGIT(a, 22);\n-                s[8][4] = MP_DIGIT(a, 23);\n-                s[8][5] = 0;\n-                s[8][6] = 0;\n-                s[8][7] = 0;\n-                s[8][8] = 0;\n-                s[8][9] = 0;\n-                s[8][10] = 0;\n-                s[8][11] = 0;\n-                s[9][0] = 0;\n-                s[9][1] = 0;\n-                s[9][2] = 0;\n-                s[9][3] = MP_DIGIT(a, 23);\n-                s[9][4] = MP_DIGIT(a, 23);\n-                s[9][5] = 0;\n-                s[9][6] = 0;\n-                s[9][7] = 0;\n-                s[9][8] = 0;\n-                s[9][9] = 0;\n-                s[9][10] = 0;\n-                s[9][11] = 0;\n-\n-                MP_CHECKOK(mp_add(&m[0], &m[1], r));\n-                MP_CHECKOK(mp_add(r, &m[1], r));\n-                MP_CHECKOK(mp_add(r, &m[2], r));\n-                MP_CHECKOK(mp_add(r, &m[3], r));\n-                MP_CHECKOK(mp_add(r, &m[4], r));\n-                MP_CHECKOK(mp_add(r, &m[5], r));\n-                MP_CHECKOK(mp_add(r, &m[6], r));\n-                MP_CHECKOK(mp_sub(r, &m[7], r));\n-                MP_CHECKOK(mp_sub(r, &m[8], r));\n-                MP_CHECKOK(mp_submod(r, &m[9], &meth->irr, r));\n-                s_mp_clamp(r);\n-        }\n-#else\n-        \/* for polynomials larger than twice the field size or polynomials\n-         * not using all words, use regular reduction *\/\n-        if ((a_bits > 768) || (a_bits <= 736)) {\n-                MP_CHECKOK(mp_mod(a, &meth->irr, r));\n-        } else {\n-                for (i = 0; i < 6; i++) {\n-                        s[0][i] = MP_DIGIT(a, i);\n-                }\n-                s[1][0] = 0;\n-                s[1][1] = 0;\n-                s[1][2] = (MP_DIGIT(a, 10) >> 32) | (MP_DIGIT(a, 11) << 32);\n-                s[1][3] = MP_DIGIT(a, 11) >> 32;\n-                s[1][4] = 0;\n-                s[1][5] = 0;\n-                for (i = 0; i < 6; i++) {\n-                        s[2][i] = MP_DIGIT(a, i+6);\n-                }\n-                s[3][0] = (MP_DIGIT(a, 10) >> 32) | (MP_DIGIT(a, 11) << 32);\n-                s[3][1] = (MP_DIGIT(a, 11) >> 32) | (MP_DIGIT(a, 6) << 32);\n-                for (i = 2; i < 6; i++) {\n-                        s[3][i] = (MP_DIGIT(a, i+4) >> 32) | (MP_DIGIT(a, i+5) << 32);\n-                }\n-                s[4][0] = (MP_DIGIT(a, 11) >> 32) << 32;\n-                s[4][1] = MP_DIGIT(a, 10) << 32;\n-                for (i = 2; i < 6; i++) {\n-                        s[4][i] = MP_DIGIT(a, i+4);\n-                }\n-                s[5][0] = 0;\n-                s[5][1] = 0;\n-                s[5][2] = MP_DIGIT(a, 10);\n-                s[5][3] = MP_DIGIT(a, 11);\n-                s[5][4] = 0;\n-                s[5][5] = 0;\n-                s[6][0] = (MP_DIGIT(a, 10) << 32) >> 32;\n-                s[6][1] = (MP_DIGIT(a, 10) >> 32) << 32;\n-                s[6][2] = MP_DIGIT(a, 11);\n-                s[6][3] = 0;\n-                s[6][4] = 0;\n-                s[6][5] = 0;\n-                s[7][0] = (MP_DIGIT(a, 11) >> 32) | (MP_DIGIT(a, 6) << 32);\n-                for (i = 1; i < 6; i++) {\n-                        s[7][i] = (MP_DIGIT(a, i+5) >> 32) | (MP_DIGIT(a, i+6) << 32);\n-                }\n-                s[8][0] = MP_DIGIT(a, 10) << 32;\n-                s[8][1] = (MP_DIGIT(a, 10) >> 32) | (MP_DIGIT(a, 11) << 32);\n-                s[8][2] = MP_DIGIT(a, 11) >> 32;\n-                s[8][3] = 0;\n-                s[8][4] = 0;\n-                s[8][5] = 0;\n-                s[9][0] = 0;\n-                s[9][1] = (MP_DIGIT(a, 11) >> 32) << 32;\n-                s[9][2] = MP_DIGIT(a, 11) >> 32;\n-                s[9][3] = 0;\n-                s[9][4] = 0;\n-                s[9][5] = 0;\n-\n-                MP_CHECKOK(mp_add(&m[0], &m[1], r));\n-                MP_CHECKOK(mp_add(r, &m[1], r));\n-                MP_CHECKOK(mp_add(r, &m[2], r));\n-                MP_CHECKOK(mp_add(r, &m[3], r));\n-                MP_CHECKOK(mp_add(r, &m[4], r));\n-                MP_CHECKOK(mp_add(r, &m[5], r));\n-                MP_CHECKOK(mp_add(r, &m[6], r));\n-                MP_CHECKOK(mp_sub(r, &m[7], r));\n-                MP_CHECKOK(mp_sub(r, &m[8], r));\n-                MP_CHECKOK(mp_submod(r, &m[9], &meth->irr, r));\n-                s_mp_clamp(r);\n-        }\n-#endif\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the square of polynomial a, reduce modulo p384. Store the\n- * result in r.  r could be a.  Uses optimized modular reduction for p384.\n- *\/\n-mp_err\n-ec_GFp_nistp384_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_sqr(a, r));\n-        MP_CHECKOK(ec_GFp_nistp384_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the product of two polynomials a and b, reduce modulo p384.\n- * Store the result in r.  r could be a or b; a could be b.  Uses\n- * optimized modular reduction for p384. *\/\n-mp_err\n-ec_GFp_nistp384_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_mul(a, b, r));\n-        MP_CHECKOK(ec_GFp_nistp384_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Wire in fast field arithmetic and precomputation of base point for\n- * named curves. *\/\n-mp_err\n-ec_group_set_gfp384(ECGroup *group, ECCurveName name)\n-{\n-        if (name == ECCurve_NIST_P384) {\n-                group->meth->field_mod = &ec_GFp_nistp384_mod;\n-                group->meth->field_mul = &ec_GFp_nistp384_mul;\n-                group->meth->field_sqr = &ec_GFp_nistp384_sqr;\n-        }\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_384.c","additions":0,"deletions":294,"binary":false,"changes":294,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>\n- *\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-#define ECP521_DIGITS ECL_CURVE_DIGITS(521)\n-\n-\/* Fast modular reduction for p521 = 2^521 - 1.  a can be r. Uses\n- * algorithm 2.31 from Hankerson, Menezes, Vanstone. Guide to\n- * Elliptic Curve Cryptography. *\/\n-mp_err\n-ec_GFp_nistp521_mod(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        int a_bits = mpl_significant_bits(a);\n-        unsigned int i;\n-\n-        \/* m1, m2 are statically-allocated mp_int of exactly the size we need *\/\n-        mp_int m1;\n-\n-        mp_digit s1[ECP521_DIGITS] = { 0 };\n-\n-        MP_SIGN(&m1) = MP_ZPOS;\n-        MP_ALLOC(&m1) = ECP521_DIGITS;\n-        MP_USED(&m1) = ECP521_DIGITS;\n-        MP_DIGITS(&m1) = s1;\n-\n-        if (a_bits < 521) {\n-                if (a==r) return MP_OKAY;\n-                return mp_copy(a, r);\n-        }\n-        \/* for polynomials larger than twice the field size or polynomials\n-         * not using all words, use regular reduction *\/\n-        if (a_bits > (521*2)) {\n-                MP_CHECKOK(mp_mod(a, &meth->irr, r));\n-        } else {\n-#define FIRST_DIGIT (ECP521_DIGITS-1)\n-                for (i = FIRST_DIGIT; i < MP_USED(a)-1; i++) {\n-                        s1[i-FIRST_DIGIT] = (MP_DIGIT(a, i) >> 9)\n-                                | (MP_DIGIT(a, 1+i) << (MP_DIGIT_BIT-9));\n-                }\n-                s1[i-FIRST_DIGIT] = MP_DIGIT(a, i) >> 9;\n-\n-                if ( a != r ) {\n-                        MP_CHECKOK(s_mp_pad(r,ECP521_DIGITS));\n-                        for (i = 0; i < ECP521_DIGITS; i++) {\n-                                MP_DIGIT(r,i) = MP_DIGIT(a, i);\n-                        }\n-                }\n-                MP_USED(r) = ECP521_DIGITS;\n-                MP_DIGIT(r,FIRST_DIGIT) &=  0x1FF;\n-\n-                MP_CHECKOK(s_mp_add(r, &m1));\n-                if (MP_DIGIT(r, FIRST_DIGIT) & 0x200) {\n-                        MP_CHECKOK(s_mp_add_d(r,1));\n-                        MP_DIGIT(r,FIRST_DIGIT) &=  0x1FF;\n-                }\n-                s_mp_clamp(r);\n-        }\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the square of polynomial a, reduce modulo p521. Store the\n- * result in r.  r could be a.  Uses optimized modular reduction for p521.\n- *\/\n-mp_err\n-ec_GFp_nistp521_sqr(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_sqr(a, r));\n-        MP_CHECKOK(ec_GFp_nistp521_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Compute the product of two polynomials a and b, reduce modulo p521.\n- * Store the result in r.  r could be a or b; a could be b.  Uses\n- * optimized modular reduction for p521. *\/\n-mp_err\n-ec_GFp_nistp521_mul(const mp_int *a, const mp_int *b, mp_int *r,\n-                                        const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        MP_CHECKOK(mp_mul(a, b, r));\n-        MP_CHECKOK(ec_GFp_nistp521_mod(r, r, meth));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Divides two field elements. If a is NULL, then returns the inverse of\n- * b. *\/\n-mp_err\n-ec_GFp_nistp521_div(const mp_int *a, const mp_int *b, mp_int *r,\n-                   const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t;\n-\n-        \/* If a is NULL, then return the inverse of b, otherwise return a\/b. *\/\n-        if (a == NULL) {\n-                return mp_invmod(b, &meth->irr, r);\n-        } else {\n-                \/* MPI doesn't support divmod, so we implement it using invmod and\n-                 * mulmod. *\/\n-                MP_CHECKOK(mp_init(&t, FLAG(b)));\n-                MP_CHECKOK(mp_invmod(b, &meth->irr, &t));\n-                MP_CHECKOK(mp_mul(a, &t, r));\n-                MP_CHECKOK(ec_GFp_nistp521_mod(r, r, meth));\n-          CLEANUP:\n-                mp_clear(&t);\n-                return res;\n-        }\n-}\n-\n-\/* Wire in fast field arithmetic and precomputation of base point for\n- * named curves. *\/\n-mp_err\n-ec_group_set_gfp521(ECGroup *group, ECCurveName name)\n-{\n-        if (name == ECCurve_NIST_P521) {\n-                group->meth->field_mod = &ec_GFp_nistp521_mod;\n-                group->meth->field_mul = &ec_GFp_nistp521_mul;\n-                group->meth->field_sqr = &ec_GFp_nistp521_sqr;\n-                group->meth->field_div = &ec_GFp_nistp521_div;\n-        }\n-        return MP_OKAY;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_521.c","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,360 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang-Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <fungstep@hotmail.com>, and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories.\n- *   Bodo Moeller <moeller@cdc.informatik.tu-darmstadt.de>,\n- *   Nils Larsch <nla@trustcenter.de>, and\n- *   Lenka Fibikova <fibikova@exp-math.uni-essen.de>, the OpenSSL Project\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mplogic.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-\/* Checks if point P(px, py) is at infinity.  Uses affine coordinates. *\/\n-mp_err\n-ec_GFp_pt_is_inf_aff(const mp_int *px, const mp_int *py)\n-{\n-\n-        if ((mp_cmp_z(px) == 0) && (mp_cmp_z(py) == 0)) {\n-                return MP_YES;\n-        } else {\n-                return MP_NO;\n-        }\n-\n-}\n-\n-\/* Sets P(px, py) to be the point at infinity.  Uses affine coordinates. *\/\n-mp_err\n-ec_GFp_pt_set_inf_aff(mp_int *px, mp_int *py)\n-{\n-        mp_zero(px);\n-        mp_zero(py);\n-        return MP_OKAY;\n-}\n-\n-\/* Computes R = P + Q based on IEEE P1363 A.10.1. Elliptic curve points P,\n- * Q, and R can all be identical. Uses affine coordinates. Assumes input\n- * is already field-encoded using field_enc, and returns output that is\n- * still field-encoded. *\/\n-mp_err\n-ec_GFp_pt_add_aff(const mp_int *px, const mp_int *py, const mp_int *qx,\n-                                  const mp_int *qy, mp_int *rx, mp_int *ry,\n-                                  const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int lambda, temp, tempx, tempy;\n-\n-        MP_DIGITS(&lambda) = 0;\n-        MP_DIGITS(&temp) = 0;\n-        MP_DIGITS(&tempx) = 0;\n-        MP_DIGITS(&tempy) = 0;\n-        MP_CHECKOK(mp_init(&lambda, FLAG(px)));\n-        MP_CHECKOK(mp_init(&temp, FLAG(px)));\n-        MP_CHECKOK(mp_init(&tempx, FLAG(px)));\n-        MP_CHECKOK(mp_init(&tempy, FLAG(px)));\n-        \/* if P = inf, then R = Q *\/\n-        if (ec_GFp_pt_is_inf_aff(px, py) == 0) {\n-                MP_CHECKOK(mp_copy(qx, rx));\n-                MP_CHECKOK(mp_copy(qy, ry));\n-                res = MP_OKAY;\n-                goto CLEANUP;\n-        }\n-        \/* if Q = inf, then R = P *\/\n-        if (ec_GFp_pt_is_inf_aff(qx, qy) == 0) {\n-                MP_CHECKOK(mp_copy(px, rx));\n-                MP_CHECKOK(mp_copy(py, ry));\n-                res = MP_OKAY;\n-                goto CLEANUP;\n-        }\n-        \/* if px != qx, then lambda = (py-qy) \/ (px-qx) *\/\n-        if (mp_cmp(px, qx) != 0) {\n-                MP_CHECKOK(group->meth->field_sub(py, qy, &tempy, group->meth));\n-                MP_CHECKOK(group->meth->field_sub(px, qx, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_div(&tempy, &tempx, &lambda, group->meth));\n-        } else {\n-                \/* if py != qy or qy = 0, then R = inf *\/\n-                if (((mp_cmp(py, qy) != 0)) || (mp_cmp_z(qy) == 0)) {\n-                        mp_zero(rx);\n-                        mp_zero(ry);\n-                        res = MP_OKAY;\n-                        goto CLEANUP;\n-                }\n-                \/* lambda = (3qx^2+a) \/ (2qy) *\/\n-                MP_CHECKOK(group->meth->field_sqr(qx, &tempx, group->meth));\n-                MP_CHECKOK(mp_set_int(&temp, 3));\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->field_enc(&temp, &temp, group->meth));\n-                }\n-                MP_CHECKOK(group->meth->\n-                                   field_mul(&tempx, &temp, &tempx, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&tempx, &group->curvea, &tempx, group->meth));\n-                MP_CHECKOK(mp_set_int(&temp, 2));\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->field_enc(&temp, &temp, group->meth));\n-                }\n-                MP_CHECKOK(group->meth->field_mul(qy, &temp, &tempy, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_div(&tempx, &tempy, &lambda, group->meth));\n-        }\n-        \/* rx = lambda^2 - px - qx *\/\n-        MP_CHECKOK(group->meth->field_sqr(&lambda, &tempx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(&tempx, px, &tempx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(&tempx, qx, &tempx, group->meth));\n-        \/* ry = (x1-x2) * lambda - y1 *\/\n-        MP_CHECKOK(group->meth->field_sub(qx, &tempx, &tempy, group->meth));\n-        MP_CHECKOK(group->meth->\n-                           field_mul(&tempy, &lambda, &tempy, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(&tempy, qy, &tempy, group->meth));\n-        MP_CHECKOK(mp_copy(&tempx, rx));\n-        MP_CHECKOK(mp_copy(&tempy, ry));\n-\n-  CLEANUP:\n-        mp_clear(&lambda);\n-        mp_clear(&temp);\n-        mp_clear(&tempx);\n-        mp_clear(&tempy);\n-        return res;\n-}\n-\n-\/* Computes R = P - Q. Elliptic curve points P, Q, and R can all be\n- * identical. Uses affine coordinates. Assumes input is already\n- * field-encoded using field_enc, and returns output that is still\n- * field-encoded. *\/\n-mp_err\n-ec_GFp_pt_sub_aff(const mp_int *px, const mp_int *py, const mp_int *qx,\n-                                  const mp_int *qy, mp_int *rx, mp_int *ry,\n-                                  const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int nqy;\n-\n-        MP_DIGITS(&nqy) = 0;\n-        MP_CHECKOK(mp_init(&nqy, FLAG(px)));\n-        \/* nqy = -qy *\/\n-        MP_CHECKOK(group->meth->field_neg(qy, &nqy, group->meth));\n-        res = group->point_add(px, py, qx, &nqy, rx, ry, group);\n-  CLEANUP:\n-        mp_clear(&nqy);\n-        return res;\n-}\n-\n-\/* Computes R = 2P. Elliptic curve points P and R can be identical. Uses\n- * affine coordinates. Assumes input is already field-encoded using\n- * field_enc, and returns output that is still field-encoded. *\/\n-mp_err\n-ec_GFp_pt_dbl_aff(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                  mp_int *ry, const ECGroup *group)\n-{\n-        return ec_GFp_pt_add_aff(px, py, px, py, rx, ry, group);\n-}\n-\n-\/* by default, this routine is unused and thus doesn't need to be compiled *\/\n-#ifdef ECL_ENABLE_GFP_PT_MUL_AFF\n-\/* Computes R = nP based on IEEE P1363 A.10.3. Elliptic curve points P and\n- * R can be identical. Uses affine coordinates. Assumes input is already\n- * field-encoded using field_enc, and returns output that is still\n- * field-encoded. *\/\n-mp_err\n-ec_GFp_pt_mul_aff(const mp_int *n, const mp_int *px, const mp_int *py,\n-                                  mp_int *rx, mp_int *ry, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int k, k3, qx, qy, sx, sy;\n-        int b1, b3, i, l;\n-\n-        MP_DIGITS(&k) = 0;\n-        MP_DIGITS(&k3) = 0;\n-        MP_DIGITS(&qx) = 0;\n-        MP_DIGITS(&qy) = 0;\n-        MP_DIGITS(&sx) = 0;\n-        MP_DIGITS(&sy) = 0;\n-        MP_CHECKOK(mp_init(&k));\n-        MP_CHECKOK(mp_init(&k3));\n-        MP_CHECKOK(mp_init(&qx));\n-        MP_CHECKOK(mp_init(&qy));\n-        MP_CHECKOK(mp_init(&sx));\n-        MP_CHECKOK(mp_init(&sy));\n-\n-        \/* if n = 0 then r = inf *\/\n-        if (mp_cmp_z(n) == 0) {\n-                mp_zero(rx);\n-                mp_zero(ry);\n-                res = MP_OKAY;\n-                goto CLEANUP;\n-        }\n-        \/* Q = P, k = n *\/\n-        MP_CHECKOK(mp_copy(px, &qx));\n-        MP_CHECKOK(mp_copy(py, &qy));\n-        MP_CHECKOK(mp_copy(n, &k));\n-        \/* if n < 0 then Q = -Q, k = -k *\/\n-        if (mp_cmp_z(n) < 0) {\n-                MP_CHECKOK(group->meth->field_neg(&qy, &qy, group->meth));\n-                MP_CHECKOK(mp_neg(&k, &k));\n-        }\n-#ifdef ECL_DEBUG                                \/* basic double and add method *\/\n-        l = mpl_significant_bits(&k) - 1;\n-        MP_CHECKOK(mp_copy(&qx, &sx));\n-        MP_CHECKOK(mp_copy(&qy, &sy));\n-        for (i = l - 1; i >= 0; i--) {\n-                \/* S = 2S *\/\n-                MP_CHECKOK(group->point_dbl(&sx, &sy, &sx, &sy, group));\n-                \/* if k_i = 1, then S = S + Q *\/\n-                if (mpl_get_bit(&k, i) != 0) {\n-                        MP_CHECKOK(group->\n-                                           point_add(&sx, &sy, &qx, &qy, &sx, &sy, group));\n-                }\n-        }\n-#else                                                   \/* double and add\/subtract method from\n-                                                                 * standard *\/\n-        \/* k3 = 3 * k *\/\n-        MP_CHECKOK(mp_set_int(&k3, 3));\n-        MP_CHECKOK(mp_mul(&k, &k3, &k3));\n-        \/* S = Q *\/\n-        MP_CHECKOK(mp_copy(&qx, &sx));\n-        MP_CHECKOK(mp_copy(&qy, &sy));\n-        \/* l = index of high order bit in binary representation of 3*k *\/\n-        l = mpl_significant_bits(&k3) - 1;\n-        \/* for i = l-1 downto 1 *\/\n-        for (i = l - 1; i >= 1; i--) {\n-                \/* S = 2S *\/\n-                MP_CHECKOK(group->point_dbl(&sx, &sy, &sx, &sy, group));\n-                b3 = MP_GET_BIT(&k3, i);\n-                b1 = MP_GET_BIT(&k, i);\n-                \/* if k3_i = 1 and k_i = 0, then S = S + Q *\/\n-                if ((b3 == 1) && (b1 == 0)) {\n-                        MP_CHECKOK(group->\n-                                           point_add(&sx, &sy, &qx, &qy, &sx, &sy, group));\n-                        \/* if k3_i = 0 and k_i = 1, then S = S - Q *\/\n-                } else if ((b3 == 0) && (b1 == 1)) {\n-                        MP_CHECKOK(group->\n-                                           point_sub(&sx, &sy, &qx, &qy, &sx, &sy, group));\n-                }\n-        }\n-#endif\n-        \/* output S *\/\n-        MP_CHECKOK(mp_copy(&sx, rx));\n-        MP_CHECKOK(mp_copy(&sy, ry));\n-\n-  CLEANUP:\n-        mp_clear(&k);\n-        mp_clear(&k3);\n-        mp_clear(&qx);\n-        mp_clear(&qy);\n-        mp_clear(&sx);\n-        mp_clear(&sy);\n-        return res;\n-}\n-#endif\n-\n-\/* Validates a point on a GFp curve. *\/\n-mp_err\n-ec_GFp_validate_point(const mp_int *px, const mp_int *py, const ECGroup *group)\n-{\n-        mp_err res = MP_NO;\n-        mp_int accl, accr, tmp, pxt, pyt;\n-\n-        MP_DIGITS(&accl) = 0;\n-        MP_DIGITS(&accr) = 0;\n-        MP_DIGITS(&tmp) = 0;\n-        MP_DIGITS(&pxt) = 0;\n-        MP_DIGITS(&pyt) = 0;\n-        MP_CHECKOK(mp_init(&accl, FLAG(px)));\n-        MP_CHECKOK(mp_init(&accr, FLAG(px)));\n-        MP_CHECKOK(mp_init(&tmp, FLAG(px)));\n-        MP_CHECKOK(mp_init(&pxt, FLAG(px)));\n-        MP_CHECKOK(mp_init(&pyt, FLAG(px)));\n-\n-    \/* 1: Verify that publicValue is not the point at infinity *\/\n-        if (ec_GFp_pt_is_inf_aff(px, py) == MP_YES) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-    \/* 2: Verify that the coordinates of publicValue are elements\n-     *    of the field.\n-     *\/\n-        if ((MP_SIGN(px) == MP_NEG) || (mp_cmp(px, &group->meth->irr) >= 0) ||\n-                (MP_SIGN(py) == MP_NEG) || (mp_cmp(py, &group->meth->irr) >= 0)) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-    \/* 3: Verify that publicValue is on the curve. *\/\n-        if (group->meth->field_enc) {\n-                group->meth->field_enc(px, &pxt, group->meth);\n-                group->meth->field_enc(py, &pyt, group->meth);\n-        } else {\n-                mp_copy(px, &pxt);\n-                mp_copy(py, &pyt);\n-        }\n-        \/* left-hand side: y^2  *\/\n-        MP_CHECKOK( group->meth->field_sqr(&pyt, &accl, group->meth) );\n-        \/* right-hand side: x^3 + a*x + b *\/\n-        MP_CHECKOK( group->meth->field_sqr(&pxt, &tmp, group->meth) );\n-        MP_CHECKOK( group->meth->field_mul(&pxt, &tmp, &accr, group->meth) );\n-        MP_CHECKOK( group->meth->field_mul(&group->curvea, &pxt, &tmp, group->meth) );\n-        MP_CHECKOK( group->meth->field_add(&tmp, &accr, &accr, group->meth) );\n-        MP_CHECKOK( group->meth->field_add(&accr, &group->curveb, &accr, group->meth) );\n-        \/* check LHS - RHS == 0 *\/\n-        MP_CHECKOK( group->meth->field_sub(&accl, &accr, &accr, group->meth) );\n-        if (mp_cmp_z(&accr) != 0) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-    \/* 4: Verify that the order of the curve times the publicValue\n-     *    is the point at infinity.\n-     *\/\n-        \/* timing mitigation is not supported *\/\n-        MP_CHECKOK( ECPoint_mul(group, &group->order, px, py, &pxt, &pyt, \/*timing*\/ 0) );\n-        if (ec_GFp_pt_is_inf_aff(&pxt, &pyt) != MP_YES) {\n-                res = MP_NO;\n-                goto CLEANUP;\n-        }\n-\n-        res = MP_YES;\n-\n-CLEANUP:\n-        mp_clear(&accl);\n-        mp_clear(&accr);\n-        mp_clear(&tmp);\n-        mp_clear(&pxt);\n-        mp_clear(&pyt);\n-        return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_aff.c","additions":0,"deletions":360,"binary":false,"changes":360,"status":"deleted"},{"patch":"@@ -1,564 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang-Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <fungstep@hotmail.com>, and\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories.\n- *   Bodo Moeller <moeller@cdc.informatik.tu-darmstadt.de>,\n- *   Nils Larsch <nla@trustcenter.de>, and\n- *   Lenka Fibikova <fibikova@exp-math.uni-essen.de>, the OpenSSL Project\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"mplogic.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-#ifdef ECL_DEBUG\n-#include <assert.h>\n-#endif\n-\n-\/* Converts a point P(px, py) from affine coordinates to Jacobian\n- * projective coordinates R(rx, ry, rz). Assumes input is already\n- * field-encoded using field_enc, and returns output that is still\n- * field-encoded. *\/\n-mp_err\n-ec_GFp_pt_aff2jac(const mp_int *px, const mp_int *py, mp_int *rx,\n-                                  mp_int *ry, mp_int *rz, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        if (ec_GFp_pt_is_inf_aff(px, py) == MP_YES) {\n-                MP_CHECKOK(ec_GFp_pt_set_inf_jac(rx, ry, rz));\n-        } else {\n-                MP_CHECKOK(mp_copy(px, rx));\n-                MP_CHECKOK(mp_copy(py, ry));\n-                MP_CHECKOK(mp_set_int(rz, 1));\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->field_enc(rz, rz, group->meth));\n-                }\n-        }\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Converts a point P(px, py, pz) from Jacobian projective coordinates to\n- * affine coordinates R(rx, ry).  P and R can share x and y coordinates.\n- * Assumes input is already field-encoded using field_enc, and returns\n- * output that is still field-encoded. *\/\n-mp_err\n-ec_GFp_pt_jac2aff(const mp_int *px, const mp_int *py, const mp_int *pz,\n-                                  mp_int *rx, mp_int *ry, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int z1, z2, z3;\n-\n-        MP_DIGITS(&z1) = 0;\n-        MP_DIGITS(&z2) = 0;\n-        MP_DIGITS(&z3) = 0;\n-        MP_CHECKOK(mp_init(&z1, FLAG(px)));\n-        MP_CHECKOK(mp_init(&z2, FLAG(px)));\n-        MP_CHECKOK(mp_init(&z3, FLAG(px)));\n-\n-        \/* if point at infinity, then set point at infinity and exit *\/\n-        if (ec_GFp_pt_is_inf_jac(px, py, pz) == MP_YES) {\n-                MP_CHECKOK(ec_GFp_pt_set_inf_aff(rx, ry));\n-                goto CLEANUP;\n-        }\n-\n-        \/* transform (px, py, pz) into (px \/ pz^2, py \/ pz^3) *\/\n-        if (mp_cmp_d(pz, 1) == 0) {\n-                MP_CHECKOK(mp_copy(px, rx));\n-                MP_CHECKOK(mp_copy(py, ry));\n-        } else {\n-                MP_CHECKOK(group->meth->field_div(NULL, pz, &z1, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(&z1, &z2, group->meth));\n-                MP_CHECKOK(group->meth->field_mul(&z1, &z2, &z3, group->meth));\n-                MP_CHECKOK(group->meth->field_mul(px, &z2, rx, group->meth));\n-                MP_CHECKOK(group->meth->field_mul(py, &z3, ry, group->meth));\n-        }\n-\n-  CLEANUP:\n-        mp_clear(&z1);\n-        mp_clear(&z2);\n-        mp_clear(&z3);\n-        return res;\n-}\n-\n-\/* Checks if point P(px, py, pz) is at infinity. Uses Jacobian\n- * coordinates. *\/\n-mp_err\n-ec_GFp_pt_is_inf_jac(const mp_int *px, const mp_int *py, const mp_int *pz)\n-{\n-        return mp_cmp_z(pz);\n-}\n-\n-\/* Sets P(px, py, pz) to be the point at infinity.  Uses Jacobian\n- * coordinates. *\/\n-mp_err\n-ec_GFp_pt_set_inf_jac(mp_int *px, mp_int *py, mp_int *pz)\n-{\n-        mp_zero(pz);\n-        return MP_OKAY;\n-}\n-\n-\/* Computes R = P + Q where R is (rx, ry, rz), P is (px, py, pz) and Q is\n- * (qx, qy, 1).  Elliptic curve points P, Q, and R can all be identical.\n- * Uses mixed Jacobian-affine coordinates. Assumes input is already\n- * field-encoded using field_enc, and returns output that is still\n- * field-encoded. Uses equation (2) from Brown, Hankerson, Lopez, and\n- * Menezes. Software Implementation of the NIST Elliptic Curves Over Prime\n- * Fields. *\/\n-mp_err\n-ec_GFp_pt_add_jac_aff(const mp_int *px, const mp_int *py, const mp_int *pz,\n-                                          const mp_int *qx, const mp_int *qy, mp_int *rx,\n-                                          mp_int *ry, mp_int *rz, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int A, B, C, D, C2, C3;\n-\n-        MP_DIGITS(&A) = 0;\n-        MP_DIGITS(&B) = 0;\n-        MP_DIGITS(&C) = 0;\n-        MP_DIGITS(&D) = 0;\n-        MP_DIGITS(&C2) = 0;\n-        MP_DIGITS(&C3) = 0;\n-        MP_CHECKOK(mp_init(&A, FLAG(px)));\n-        MP_CHECKOK(mp_init(&B, FLAG(px)));\n-        MP_CHECKOK(mp_init(&C, FLAG(px)));\n-        MP_CHECKOK(mp_init(&D, FLAG(px)));\n-        MP_CHECKOK(mp_init(&C2, FLAG(px)));\n-        MP_CHECKOK(mp_init(&C3, FLAG(px)));\n-\n-        \/* If either P or Q is the point at infinity, then return the other\n-         * point *\/\n-        if (ec_GFp_pt_is_inf_jac(px, py, pz) == MP_YES) {\n-                MP_CHECKOK(ec_GFp_pt_aff2jac(qx, qy, rx, ry, rz, group));\n-                goto CLEANUP;\n-        }\n-        if (ec_GFp_pt_is_inf_aff(qx, qy) == MP_YES) {\n-                MP_CHECKOK(mp_copy(px, rx));\n-                MP_CHECKOK(mp_copy(py, ry));\n-                MP_CHECKOK(mp_copy(pz, rz));\n-                goto CLEANUP;\n-        }\n-\n-        \/* A = qx * pz^2, B = qy * pz^3 *\/\n-        MP_CHECKOK(group->meth->field_sqr(pz, &A, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&A, pz, &B, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&A, qx, &A, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&B, qy, &B, group->meth));\n-\n-        \/*\n-         * Additional checks for point equality and point at infinity\n-         *\/\n-        if (mp_cmp(px, &A) == 0 && mp_cmp(py, &B) == 0) {\n-            \/* POINT_DOUBLE(P) *\/\n-            MP_CHECKOK(ec_GFp_pt_dbl_jac(px, py, pz, rx, ry, rz, group));\n-            goto CLEANUP;\n-        }\n-\n-        \/* C = A - px, D = B - py *\/\n-        MP_CHECKOK(group->meth->field_sub(&A, px, &C, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(&B, py, &D, group->meth));\n-\n-        \/* C2 = C^2, C3 = C^3 *\/\n-        MP_CHECKOK(group->meth->field_sqr(&C, &C2, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&C, &C2, &C3, group->meth));\n-\n-        \/* rz = pz * C *\/\n-        MP_CHECKOK(group->meth->field_mul(pz, &C, rz, group->meth));\n-\n-        \/* C = px * C^2 *\/\n-        MP_CHECKOK(group->meth->field_mul(px, &C2, &C, group->meth));\n-        \/* A = D^2 *\/\n-        MP_CHECKOK(group->meth->field_sqr(&D, &A, group->meth));\n-\n-        \/* rx = D^2 - (C^3 + 2 * (px * C^2)) *\/\n-        MP_CHECKOK(group->meth->field_add(&C, &C, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_add(&C3, rx, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(&A, rx, rx, group->meth));\n-\n-        \/* C3 = py * C^3 *\/\n-        MP_CHECKOK(group->meth->field_mul(py, &C3, &C3, group->meth));\n-\n-        \/* ry = D * (px * C^2 - rx) - py * C^3 *\/\n-        MP_CHECKOK(group->meth->field_sub(&C, rx, ry, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&D, ry, ry, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(ry, &C3, ry, group->meth));\n-\n-  CLEANUP:\n-        mp_clear(&A);\n-        mp_clear(&B);\n-        mp_clear(&C);\n-        mp_clear(&D);\n-        mp_clear(&C2);\n-        mp_clear(&C3);\n-        return res;\n-}\n-\n-\/* Computes R = 2P.  Elliptic curve points P and R can be identical.  Uses\n- * Jacobian coordinates.\n- *\n- * Assumes input is already field-encoded using field_enc, and returns\n- * output that is still field-encoded.\n- *\n- * This routine implements Point Doubling in the Jacobian Projective\n- * space as described in the paper \"Efficient elliptic curve exponentiation\n- * using mixed coordinates\", by H. Cohen, A Miyaji, T. Ono.\n- *\/\n-mp_err\n-ec_GFp_pt_dbl_jac(const mp_int *px, const mp_int *py, const mp_int *pz,\n-                                  mp_int *rx, mp_int *ry, mp_int *rz, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int t0, t1, M, S;\n-\n-        MP_DIGITS(&t0) = 0;\n-        MP_DIGITS(&t1) = 0;\n-        MP_DIGITS(&M) = 0;\n-        MP_DIGITS(&S) = 0;\n-        MP_CHECKOK(mp_init(&t0, FLAG(px)));\n-        MP_CHECKOK(mp_init(&t1, FLAG(px)));\n-        MP_CHECKOK(mp_init(&M, FLAG(px)));\n-        MP_CHECKOK(mp_init(&S, FLAG(px)));\n-\n-        if (ec_GFp_pt_is_inf_jac(px, py, pz) == MP_YES) {\n-                MP_CHECKOK(ec_GFp_pt_set_inf_jac(rx, ry, rz));\n-                goto CLEANUP;\n-        }\n-\n-        if (mp_cmp_d(pz, 1) == 0) {\n-                \/* M = 3 * px^2 + a *\/\n-                MP_CHECKOK(group->meth->field_sqr(px, &t0, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&t0, &t0, &M, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&t0, &M, &t0, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_add(&t0, &group->curvea, &M, group->meth));\n-        } else if (mp_cmp_int(&group->curvea, -3, FLAG(px)) == 0) {\n-                \/* M = 3 * (px + pz^2) * (px - pz^2) *\/\n-                MP_CHECKOK(group->meth->field_sqr(pz, &M, group->meth));\n-                MP_CHECKOK(group->meth->field_add(px, &M, &t0, group->meth));\n-                MP_CHECKOK(group->meth->field_sub(px, &M, &t1, group->meth));\n-                MP_CHECKOK(group->meth->field_mul(&t0, &t1, &M, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&M, &M, &t0, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&t0, &M, &M, group->meth));\n-        } else {\n-                \/* M = 3 * (px^2) + a * (pz^4) *\/\n-                MP_CHECKOK(group->meth->field_sqr(px, &t0, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&t0, &t0, &M, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&t0, &M, &t0, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(pz, &M, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(&M, &M, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_mul(&M, &group->curvea, &M, group->meth));\n-                MP_CHECKOK(group->meth->field_add(&M, &t0, &M, group->meth));\n-        }\n-\n-        \/* rz = 2 * py * pz *\/\n-        \/* t0 = 4 * py^2 *\/\n-        if (mp_cmp_d(pz, 1) == 0) {\n-                MP_CHECKOK(group->meth->field_add(py, py, rz, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(rz, &t0, group->meth));\n-        } else {\n-                MP_CHECKOK(group->meth->field_add(py, py, &t0, group->meth));\n-                MP_CHECKOK(group->meth->field_mul(&t0, pz, rz, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(&t0, &t0, group->meth));\n-        }\n-\n-        \/* S = 4 * px * py^2 = px * (2 * py)^2 *\/\n-        MP_CHECKOK(group->meth->field_mul(px, &t0, &S, group->meth));\n-\n-        \/* rx = M^2 - 2 * S *\/\n-        MP_CHECKOK(group->meth->field_add(&S, &S, &t1, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(&M, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(rx, &t1, rx, group->meth));\n-\n-        \/* ry = M * (S - rx) - 8 * py^4 *\/\n-        MP_CHECKOK(group->meth->field_sqr(&t0, &t1, group->meth));\n-        if (mp_isodd(&t1)) {\n-                MP_CHECKOK(mp_add(&t1, &group->meth->irr, &t1));\n-        }\n-        MP_CHECKOK(mp_div_2(&t1, &t1));\n-        MP_CHECKOK(group->meth->field_sub(&S, rx, &S, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(&M, &S, &M, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(&M, &t1, ry, group->meth));\n-\n-  CLEANUP:\n-        mp_clear(&t0);\n-        mp_clear(&t1);\n-        mp_clear(&M);\n-        mp_clear(&S);\n-        return res;\n-}\n-\n-\/* by default, this routine is unused and thus doesn't need to be compiled *\/\n-#ifdef ECL_ENABLE_GFP_PT_MUL_JAC\n-\/* Computes R = nP where R is (rx, ry) and P is (px, py). The parameters\n- * a, b and p are the elliptic curve coefficients and the prime that\n- * determines the field GFp.  Elliptic curve points P and R can be\n- * identical.  Uses mixed Jacobian-affine coordinates. Assumes input is\n- * already field-encoded using field_enc, and returns output that is still\n- * field-encoded. Uses 4-bit window method. *\/\n-mp_err\n-ec_GFp_pt_mul_jac(const mp_int *n, const mp_int *px, const mp_int *py,\n-                                  mp_int *rx, mp_int *ry, const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int precomp[16][2], rz;\n-        int i, ni, d;\n-\n-        MP_DIGITS(&rz) = 0;\n-        for (i = 0; i < 16; i++) {\n-                MP_DIGITS(&precomp[i][0]) = 0;\n-                MP_DIGITS(&precomp[i][1]) = 0;\n-        }\n-\n-        ARGCHK(group != NULL, MP_BADARG);\n-        ARGCHK((n != NULL) && (px != NULL) && (py != NULL), MP_BADARG);\n-\n-        \/* initialize precomputation table *\/\n-        for (i = 0; i < 16; i++) {\n-                MP_CHECKOK(mp_init(&precomp[i][0]));\n-                MP_CHECKOK(mp_init(&precomp[i][1]));\n-        }\n-\n-        \/* fill precomputation table *\/\n-        mp_zero(&precomp[0][0]);\n-        mp_zero(&precomp[0][1]);\n-        MP_CHECKOK(mp_copy(px, &precomp[1][0]));\n-        MP_CHECKOK(mp_copy(py, &precomp[1][1]));\n-        for (i = 2; i < 16; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[1][0], &precomp[1][1],\n-                                                         &precomp[i - 1][0], &precomp[i - 1][1],\n-                                                         &precomp[i][0], &precomp[i][1], group));\n-        }\n-\n-        d = (mpl_significant_bits(n) + 3) \/ 4;\n-\n-        \/* R = inf *\/\n-        MP_CHECKOK(mp_init(&rz));\n-        MP_CHECKOK(ec_GFp_pt_set_inf_jac(rx, ry, &rz));\n-\n-        for (i = d - 1; i >= 0; i--) {\n-                \/* compute window ni *\/\n-                ni = MP_GET_BIT(n, 4 * i + 3);\n-                ni <<= 1;\n-                ni |= MP_GET_BIT(n, 4 * i + 2);\n-                ni <<= 1;\n-                ni |= MP_GET_BIT(n, 4 * i + 1);\n-                ni <<= 1;\n-                ni |= MP_GET_BIT(n, 4 * i);\n-                \/* R = 2^4 * R *\/\n-                MP_CHECKOK(ec_GFp_pt_dbl_jac(rx, ry, &rz, rx, ry, &rz, group));\n-                MP_CHECKOK(ec_GFp_pt_dbl_jac(rx, ry, &rz, rx, ry, &rz, group));\n-                MP_CHECKOK(ec_GFp_pt_dbl_jac(rx, ry, &rz, rx, ry, &rz, group));\n-                MP_CHECKOK(ec_GFp_pt_dbl_jac(rx, ry, &rz, rx, ry, &rz, group));\n-                \/* R = R + (ni * P) *\/\n-                MP_CHECKOK(ec_GFp_pt_add_jac_aff\n-                                   (rx, ry, &rz, &precomp[ni][0], &precomp[ni][1], rx, ry,\n-                                        &rz, group));\n-        }\n-\n-        \/* convert result S to affine coordinates *\/\n-        MP_CHECKOK(ec_GFp_pt_jac2aff(rx, ry, &rz, rx, ry, group));\n-\n-  CLEANUP:\n-        mp_clear(&rz);\n-        for (i = 0; i < 16; i++) {\n-                mp_clear(&precomp[i][0]);\n-                mp_clear(&precomp[i][1]);\n-        }\n-        return res;\n-}\n-#endif\n-\n-\/* Elliptic curve scalar-point multiplication. Computes R(x, y) = k1 * G +\n- * k2 * P(x, y), where G is the generator (base point) of the group of\n- * points on the elliptic curve. Allows k1 = NULL or { k2, P } = NULL.\n- * Uses mixed Jacobian-affine coordinates. Input and output values are\n- * assumed to be NOT field-encoded. Uses algorithm 15 (simultaneous\n- * multiple point multiplication) from Brown, Hankerson, Lopez, Menezes.\n- * Software Implementation of the NIST Elliptic Curves over Prime Fields. *\/\n-mp_err\n-ec_GFp_pts_mul_jac(const mp_int *k1, const mp_int *k2, const mp_int *px,\n-                                   const mp_int *py, mp_int *rx, mp_int *ry,\n-                                   const ECGroup *group, int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int precomp[4][4][2];\n-        mp_int rz;\n-        const mp_int *a, *b;\n-        int i, j;\n-        int ai, bi, d;\n-\n-        for (i = 0; i < 4; i++) {\n-                for (j = 0; j < 4; j++) {\n-                        MP_DIGITS(&precomp[i][j][0]) = 0;\n-                        MP_DIGITS(&precomp[i][j][1]) = 0;\n-                }\n-        }\n-        MP_DIGITS(&rz) = 0;\n-\n-        ARGCHK(group != NULL, MP_BADARG);\n-        ARGCHK(!((k1 == NULL)\n-                         && ((k2 == NULL) || (px == NULL)\n-                                 || (py == NULL))), MP_BADARG);\n-\n-        \/* if some arguments are not defined used ECPoint_mul *\/\n-        if (k1 == NULL) {\n-                return ECPoint_mul(group, k2, px, py, rx, ry, timing);\n-        } else if ((k2 == NULL) || (px == NULL) || (py == NULL)) {\n-                return ECPoint_mul(group, k1, NULL, NULL, rx, ry, timing);\n-        }\n-\n-        \/* initialize precomputation table *\/\n-        for (i = 0; i < 4; i++) {\n-                for (j = 0; j < 4; j++) {\n-                        MP_CHECKOK(mp_init(&precomp[i][j][0], FLAG(k1)));\n-                        MP_CHECKOK(mp_init(&precomp[i][j][1], FLAG(k1)));\n-                }\n-        }\n-\n-        \/* fill precomputation table *\/\n-        \/* assign {k1, k2} = {a, b} such that len(a) >= len(b) *\/\n-        if (mpl_significant_bits(k1) < mpl_significant_bits(k2)) {\n-                a = k2;\n-                b = k1;\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(px, &precomp[1][0][0], group->meth));\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(py, &precomp[1][0][1], group->meth));\n-                } else {\n-                        MP_CHECKOK(mp_copy(px, &precomp[1][0][0]));\n-                        MP_CHECKOK(mp_copy(py, &precomp[1][0][1]));\n-                }\n-                MP_CHECKOK(mp_copy(&group->genx, &precomp[0][1][0]));\n-                MP_CHECKOK(mp_copy(&group->geny, &precomp[0][1][1]));\n-        } else {\n-                a = k1;\n-                b = k2;\n-                MP_CHECKOK(mp_copy(&group->genx, &precomp[1][0][0]));\n-                MP_CHECKOK(mp_copy(&group->geny, &precomp[1][0][1]));\n-                if (group->meth->field_enc) {\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(px, &precomp[0][1][0], group->meth));\n-                        MP_CHECKOK(group->meth->\n-                                           field_enc(py, &precomp[0][1][1], group->meth));\n-                } else {\n-                        MP_CHECKOK(mp_copy(px, &precomp[0][1][0]));\n-                        MP_CHECKOK(mp_copy(py, &precomp[0][1][1]));\n-                }\n-        }\n-        \/* precompute [*][0][*] *\/\n-        mp_zero(&precomp[0][0][0]);\n-        mp_zero(&precomp[0][0][1]);\n-        MP_CHECKOK(group->\n-                           point_dbl(&precomp[1][0][0], &precomp[1][0][1],\n-                                                 &precomp[2][0][0], &precomp[2][0][1], group));\n-        MP_CHECKOK(group->\n-                           point_add(&precomp[1][0][0], &precomp[1][0][1],\n-                                                 &precomp[2][0][0], &precomp[2][0][1],\n-                                                 &precomp[3][0][0], &precomp[3][0][1], group));\n-        \/* precompute [*][1][*] *\/\n-        for (i = 1; i < 4; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[0][1][0], &precomp[0][1][1],\n-                                                         &precomp[i][0][0], &precomp[i][0][1],\n-                                                         &precomp[i][1][0], &precomp[i][1][1], group));\n-        }\n-        \/* precompute [*][2][*] *\/\n-        MP_CHECKOK(group->\n-                           point_dbl(&precomp[0][1][0], &precomp[0][1][1],\n-                                                 &precomp[0][2][0], &precomp[0][2][1], group));\n-        for (i = 1; i < 4; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[0][2][0], &precomp[0][2][1],\n-                                                         &precomp[i][0][0], &precomp[i][0][1],\n-                                                         &precomp[i][2][0], &precomp[i][2][1], group));\n-        }\n-        \/* precompute [*][3][*] *\/\n-        MP_CHECKOK(group->\n-                           point_add(&precomp[0][1][0], &precomp[0][1][1],\n-                                                 &precomp[0][2][0], &precomp[0][2][1],\n-                                                 &precomp[0][3][0], &precomp[0][3][1], group));\n-        for (i = 1; i < 4; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[0][3][0], &precomp[0][3][1],\n-                                                         &precomp[i][0][0], &precomp[i][0][1],\n-                                                         &precomp[i][3][0], &precomp[i][3][1], group));\n-        }\n-\n-        d = (mpl_significant_bits(a) + 1) \/ 2;\n-\n-        \/* R = inf *\/\n-        MP_CHECKOK(mp_init(&rz, FLAG(k1)));\n-        MP_CHECKOK(ec_GFp_pt_set_inf_jac(rx, ry, &rz));\n-\n-        for (i = d - 1; i >= 0; i--) {\n-                ai = MP_GET_BIT(a, 2 * i + 1);\n-                ai <<= 1;\n-                ai |= MP_GET_BIT(a, 2 * i);\n-                bi = MP_GET_BIT(b, 2 * i + 1);\n-                bi <<= 1;\n-                bi |= MP_GET_BIT(b, 2 * i);\n-                \/* R = 2^2 * R *\/\n-                MP_CHECKOK(ec_GFp_pt_dbl_jac(rx, ry, &rz, rx, ry, &rz, group));\n-                MP_CHECKOK(ec_GFp_pt_dbl_jac(rx, ry, &rz, rx, ry, &rz, group));\n-                \/* R = R + (ai * A + bi * B) *\/\n-                MP_CHECKOK(ec_GFp_pt_add_jac_aff\n-                                   (rx, ry, &rz, &precomp[ai][bi][0], &precomp[ai][bi][1],\n-                                        rx, ry, &rz, group));\n-        }\n-\n-        MP_CHECKOK(ec_GFp_pt_jac2aff(rx, ry, &rz, rx, ry, group));\n-\n-        if (group->meth->field_dec) {\n-                MP_CHECKOK(group->meth->field_dec(rx, rx, group->meth));\n-                MP_CHECKOK(group->meth->field_dec(ry, ry, group->meth));\n-        }\n-\n-  CLEANUP:\n-        mp_clear(&rz);\n-        for (i = 0; i < 4; i++) {\n-                for (j = 0; j < 4; j++) {\n-                        mp_clear(&precomp[i][j][0]);\n-                        mp_clear(&precomp[i][j][1]);\n-                }\n-        }\n-        return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_jac.c","additions":0,"deletions":564,"binary":false,"changes":564,"status":"deleted"},{"patch":"@@ -1,396 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library for prime field curves.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Stephen Fung <fungstep@hotmail.com>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: May 2017\n- *********************************************************************** *\/\n-\n-#include \"ecp.h\"\n-#include \"ecl-priv.h\"\n-#include \"mplogic.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#endif\n-\n-#define MAX_SCRATCH 6\n-\n-\/* Computes R = 2P.  Elliptic curve points P and R can be identical.  Uses\n- * Modified Jacobian coordinates.\n- *\n- * Assumes input is already field-encoded using field_enc, and returns\n- * output that is still field-encoded.\n- *\n- *\/\n-mp_err\n-ec_GFp_pt_dbl_jm(const mp_int *px, const mp_int *py, const mp_int *pz,\n-                                 const mp_int *paz4, mp_int *rx, mp_int *ry, mp_int *rz,\n-                                 mp_int *raz4, mp_int scratch[], const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int *t0, *t1, *M, *S;\n-\n-        t0 = &scratch[0];\n-        t1 = &scratch[1];\n-        M = &scratch[2];\n-        S = &scratch[3];\n-\n-#if MAX_SCRATCH < 4\n-#error \"Scratch array defined too small \"\n-#endif\n-\n-        \/* Check for point at infinity *\/\n-        if (ec_GFp_pt_is_inf_jac(px, py, pz) == MP_YES) {\n-                \/* Set r = pt at infinity by setting rz = 0 *\/\n-\n-                MP_CHECKOK(ec_GFp_pt_set_inf_jac(rx, ry, rz));\n-                goto CLEANUP;\n-        }\n-\n-        \/* M = 3 (px^2) + a*(pz^4) *\/\n-        MP_CHECKOK(group->meth->field_sqr(px, t0, group->meth));\n-        MP_CHECKOK(group->meth->field_add(t0, t0, M, group->meth));\n-        MP_CHECKOK(group->meth->field_add(t0, M, t0, group->meth));\n-        MP_CHECKOK(group->meth->field_add(t0, paz4, M, group->meth));\n-\n-        \/* rz = 2 * py * pz *\/\n-        MP_CHECKOK(group->meth->field_mul(py, pz, S, group->meth));\n-        MP_CHECKOK(group->meth->field_add(S, S, rz, group->meth));\n-\n-        \/* t0 = 2y^2 , t1 = 8y^4 *\/\n-        MP_CHECKOK(group->meth->field_sqr(py, t0, group->meth));\n-        MP_CHECKOK(group->meth->field_add(t0, t0, t0, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(t0, t1, group->meth));\n-        MP_CHECKOK(group->meth->field_add(t1, t1, t1, group->meth));\n-\n-        \/* S = 4 * px * py^2 = 2 * px * t0 *\/\n-        MP_CHECKOK(group->meth->field_mul(px, t0, S, group->meth));\n-        MP_CHECKOK(group->meth->field_add(S, S, S, group->meth));\n-\n-\n-        \/* rx = M^2 - 2S *\/\n-        MP_CHECKOK(group->meth->field_sqr(M, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(rx, S, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(rx, S, rx, group->meth));\n-\n-        \/* ry = M * (S - rx) - t1 *\/\n-        MP_CHECKOK(group->meth->field_sub(S, rx, S, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(S, M, ry, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(ry, t1, ry, group->meth));\n-\n-        \/* ra*z^4 = 2*t1*(apz4) *\/\n-        MP_CHECKOK(group->meth->field_mul(paz4, t1, raz4, group->meth));\n-        MP_CHECKOK(group->meth->field_add(raz4, raz4, raz4, group->meth));\n-\n-\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Computes R = P + Q where R is (rx, ry, rz), P is (px, py, pz) and Q is\n- * (qx, qy, 1).  Elliptic curve points P, Q, and R can all be identical.\n- * Uses mixed Modified_Jacobian-affine coordinates. Assumes input is\n- * already field-encoded using field_enc, and returns output that is still\n- * field-encoded. *\/\n-mp_err\n-ec_GFp_pt_add_jm_aff(const mp_int *px, const mp_int *py, const mp_int *pz,\n-                                         const mp_int *paz4, const mp_int *qx,\n-                                         const mp_int *qy, mp_int *rx, mp_int *ry, mp_int *rz,\n-                                         mp_int *raz4, mp_int scratch[], const ECGroup *group)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int *A, *B, *C, *D, *C2, *C3;\n-\n-        A = &scratch[0];\n-        B = &scratch[1];\n-        C = &scratch[2];\n-        D = &scratch[3];\n-        C2 = &scratch[4];\n-        C3 = &scratch[5];\n-\n-#if MAX_SCRATCH < 6\n-#error \"Scratch array defined too small \"\n-#endif\n-\n-        \/* If either P or Q is the point at infinity, then return the other\n-         * point *\/\n-        if (ec_GFp_pt_is_inf_jac(px, py, pz) == MP_YES) {\n-                MP_CHECKOK(ec_GFp_pt_aff2jac(qx, qy, rx, ry, rz, group));\n-                MP_CHECKOK(group->meth->field_sqr(rz, raz4, group->meth));\n-                MP_CHECKOK(group->meth->field_sqr(raz4, raz4, group->meth));\n-                MP_CHECKOK(group->meth->\n-                                   field_mul(raz4, &group->curvea, raz4, group->meth));\n-                goto CLEANUP;\n-        }\n-        if (ec_GFp_pt_is_inf_aff(qx, qy) == MP_YES) {\n-                MP_CHECKOK(mp_copy(px, rx));\n-                MP_CHECKOK(mp_copy(py, ry));\n-                MP_CHECKOK(mp_copy(pz, rz));\n-                MP_CHECKOK(mp_copy(paz4, raz4));\n-                goto CLEANUP;\n-        }\n-\n-        \/* A = qx * pz^2, B = qy * pz^3 *\/\n-        MP_CHECKOK(group->meth->field_sqr(pz, A, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(A, pz, B, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(A, qx, A, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(B, qy, B, group->meth));\n-\n-        \/*\n-         * Additional checks for point equality and point at infinity\n-         *\/\n-        if (mp_cmp(px, A) == 0 && mp_cmp(py, B) == 0) {\n-            \/* POINT_DOUBLE(P) *\/\n-            MP_CHECKOK(ec_GFp_pt_dbl_jm(px, py, pz, paz4, rx, ry, rz, raz4,\n-                                        scratch, group));\n-            goto CLEANUP;\n-        }\n-\n-        \/* C = A - px, D = B - py *\/\n-        MP_CHECKOK(group->meth->field_sub(A, px, C, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(B, py, D, group->meth));\n-\n-        \/* C2 = C^2, C3 = C^3 *\/\n-        MP_CHECKOK(group->meth->field_sqr(C, C2, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(C, C2, C3, group->meth));\n-\n-        \/* rz = pz * C *\/\n-        MP_CHECKOK(group->meth->field_mul(pz, C, rz, group->meth));\n-\n-        \/* C = px * C^2 *\/\n-        MP_CHECKOK(group->meth->field_mul(px, C2, C, group->meth));\n-        \/* A = D^2 *\/\n-        MP_CHECKOK(group->meth->field_sqr(D, A, group->meth));\n-\n-        \/* rx = D^2 - (C^3 + 2 * (px * C^2)) *\/\n-        MP_CHECKOK(group->meth->field_add(C, C, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_add(C3, rx, rx, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(A, rx, rx, group->meth));\n-\n-        \/* C3 = py * C^3 *\/\n-        MP_CHECKOK(group->meth->field_mul(py, C3, C3, group->meth));\n-\n-        \/* ry = D * (px * C^2 - rx) - py * C^3 *\/\n-        MP_CHECKOK(group->meth->field_sub(C, rx, ry, group->meth));\n-        MP_CHECKOK(group->meth->field_mul(D, ry, ry, group->meth));\n-        MP_CHECKOK(group->meth->field_sub(ry, C3, ry, group->meth));\n-\n-        \/* raz4 = a * rz^4 *\/\n-        MP_CHECKOK(group->meth->field_sqr(rz, raz4, group->meth));\n-        MP_CHECKOK(group->meth->field_sqr(raz4, raz4, group->meth));\n-        MP_CHECKOK(group->meth->\n-                           field_mul(raz4, &group->curvea, raz4, group->meth));\n-CLEANUP:\n-        return res;\n-}\n-\n-\/* Computes R = nP where R is (rx, ry) and P is the base point. Elliptic\n- * curve points P and R can be identical. Uses mixed Modified-Jacobian\n- * co-ordinates for doubling and Chudnovsky Jacobian coordinates for\n- * additions. Assumes input is already field-encoded using field_enc, and\n- * returns output that is still field-encoded. Uses 5-bit window NAF\n- * method (algorithm 11) for scalar-point multiplication from Brown,\n- * Hankerson, Lopez, Menezes. Software Implementation of the NIST Elliptic\n- * Curves Over Prime Fields. *\/\n-mp_err\n-ec_GFp_pt_mul_jm_wNAF(const mp_int *n, const mp_int *px, const mp_int *py,\n-                                          mp_int *rx, mp_int *ry, const ECGroup *group,\n-                                          int timing)\n-{\n-        mp_err res = MP_OKAY;\n-        mp_int precomp[16][2], rz, tpx, tpy, tpz;\n-        mp_int raz4, tpaz4;\n-        mp_int scratch[MAX_SCRATCH];\n-        signed char *naf = NULL;\n-        int i, orderBitSize;\n-        int numDoubles, numAdds, extraDoubles, extraAdds;\n-\n-        MP_DIGITS(&rz) = 0;\n-        MP_DIGITS(&raz4) = 0;\n-        MP_DIGITS(&tpx) = 0;\n-        MP_DIGITS(&tpy) = 0;\n-        MP_DIGITS(&tpz) = 0;\n-        MP_DIGITS(&tpaz4) = 0;\n-        for (i = 0; i < 16; i++) {\n-                MP_DIGITS(&precomp[i][0]) = 0;\n-                MP_DIGITS(&precomp[i][1]) = 0;\n-        }\n-        for (i = 0; i < MAX_SCRATCH; i++) {\n-                MP_DIGITS(&scratch[i]) = 0;\n-        }\n-\n-        ARGCHK(group != NULL, MP_BADARG);\n-        ARGCHK((n != NULL) && (px != NULL) && (py != NULL), MP_BADARG);\n-\n-        \/* initialize precomputation table *\/\n-        MP_CHECKOK(mp_init(&tpx, FLAG(n)));\n-        MP_CHECKOK(mp_init(&tpy, FLAG(n)));\n-        MP_CHECKOK(mp_init(&tpz, FLAG(n)));\n-        MP_CHECKOK(mp_init(&tpaz4, FLAG(n)));\n-        MP_CHECKOK(mp_init(&rz, FLAG(n)));\n-        MP_CHECKOK(mp_init(&raz4, FLAG(n)));\n-\n-        for (i = 0; i < 16; i++) {\n-                MP_CHECKOK(mp_init(&precomp[i][0], FLAG(n)));\n-                MP_CHECKOK(mp_init(&precomp[i][1], FLAG(n)));\n-        }\n-        for (i = 0; i < MAX_SCRATCH; i++) {\n-                MP_CHECKOK(mp_init(&scratch[i], FLAG(n)));\n-        }\n-\n-        \/* Set out[8] = P *\/\n-        MP_CHECKOK(mp_copy(px, &precomp[8][0]));\n-        MP_CHECKOK(mp_copy(py, &precomp[8][1]));\n-\n-        \/* Set (tpx, tpy) = 2P *\/\n-        MP_CHECKOK(group->\n-                           point_dbl(&precomp[8][0], &precomp[8][1], &tpx, &tpy,\n-                                                 group));\n-\n-        \/* Set 3P, 5P, ..., 15P *\/\n-        for (i = 8; i < 15; i++) {\n-                MP_CHECKOK(group->\n-                                   point_add(&precomp[i][0], &precomp[i][1], &tpx, &tpy,\n-                                                         &precomp[i + 1][0], &precomp[i + 1][1],\n-                                                         group));\n-        }\n-\n-        \/* Set -15P, -13P, ..., -P *\/\n-        for (i = 0; i < 8; i++) {\n-                MP_CHECKOK(mp_copy(&precomp[15 - i][0], &precomp[i][0]));\n-                MP_CHECKOK(group->meth->\n-                                   field_neg(&precomp[15 - i][1], &precomp[i][1],\n-                                                         group->meth));\n-        }\n-\n-        \/* R = inf *\/\n-        MP_CHECKOK(ec_GFp_pt_set_inf_jac(rx, ry, &rz));\n-\n-        orderBitSize = mpl_significant_bits(&group->order);\n-\n-        \/* Allocate memory for NAF *\/\n-#ifdef _KERNEL\n-        naf = (signed char *) kmem_alloc((orderBitSize + 1), FLAG(n));\n-#else\n-        naf = (signed char *) malloc(sizeof(signed char) * (orderBitSize + 1));\n-        if (naf == NULL) {\n-                res = MP_MEM;\n-                goto CLEANUP;\n-        }\n-#endif\n-\n-        \/* Compute 5NAF *\/\n-        ec_compute_wNAF(naf, orderBitSize, n, 5);\n-\n-        numAdds = 0;\n-        numDoubles = orderBitSize;\n-        \/* wNAF method *\/\n-        for (i = orderBitSize; i >= 0; i--) {\n-\n-                if (ec_GFp_pt_is_inf_jac(rx, ry, &rz) == MP_YES) {\n-                  numDoubles--;\n-                }\n-\n-                \/* R = 2R *\/\n-                ec_GFp_pt_dbl_jm(rx, ry, &rz, &raz4, rx, ry, &rz,\n-                                             &raz4, scratch, group);\n-\n-                if (naf[i] != 0) {\n-                        ec_GFp_pt_add_jm_aff(rx, ry, &rz, &raz4,\n-                                                                 &precomp[(naf[i] + 15) \/ 2][0],\n-                                                                 &precomp[(naf[i] + 15) \/ 2][1], rx, ry,\n-                                                                 &rz, &raz4, scratch, group);\n-                        numAdds++;\n-                }\n-        }\n-\n-        \/* extra operations to make timing less dependent on secrets *\/\n-        if (timing) {\n-                \/* low-order bit of timing argument contains no entropy *\/\n-                timing >>= 1;\n-\n-                MP_CHECKOK(ec_GFp_pt_set_inf_jac(&tpx, &tpy, &tpz));\n-                mp_zero(&tpaz4);\n-\n-                \/* Set the temp value to a non-infinite point *\/\n-                ec_GFp_pt_add_jm_aff(&tpx, &tpy, &tpz, &tpaz4,\n-                                                                 &precomp[8][0],\n-                                                                 &precomp[8][1], &tpx, &tpy,\n-                                                                 &tpz, &tpaz4, scratch, group);\n-\n-                \/* two bits of extra adds *\/\n-                extraAdds = timing & 0x3;\n-                timing >>= 2;\n-                \/* Window size is 5, so the maximum number of additions is ceil(orderBitSize\/5) *\/\n-                \/* This is the same as (orderBitSize + 4) \/ 5 *\/\n-                for(i = numAdds; i <= (orderBitSize + 4) \/ 5 + extraAdds; i++) {\n-                        ec_GFp_pt_add_jm_aff(&tpx, &tpy, &tpz, &tpaz4,\n-                                                                 &precomp[9 + (i % 3)][0],\n-                                                                 &precomp[9 + (i % 3)][1], &tpx, &tpy,\n-                                                                 &tpz, &tpaz4, scratch, group);\n-                }\n-\n-                \/* two bits of extra doubles *\/\n-                extraDoubles = timing & 0x3;\n-                timing >>= 2;\n-                for(i = numDoubles; i <= orderBitSize + extraDoubles; i++) {\n-                        ec_GFp_pt_dbl_jm(&tpx, &tpy, &tpz, &tpaz4, &tpx, &tpy, &tpz,\n-                                             &tpaz4, scratch, group);\n-                }\n-\n-        }\n-\n-        \/* convert result S to affine coordinates *\/\n-        MP_CHECKOK(ec_GFp_pt_jac2aff(rx, ry, &rz, rx, ry, group));\n-\n-  CLEANUP:\n-        for (i = 0; i < MAX_SCRATCH; i++) {\n-                mp_clear(&scratch[i]);\n-        }\n-        for (i = 0; i < 16; i++) {\n-                mp_clear(&precomp[i][0]);\n-                mp_clear(&precomp[i][1]);\n-        }\n-        mp_clear(&tpx);\n-        mp_clear(&tpy);\n-        mp_clear(&tpz);\n-        mp_clear(&tpaz4);\n-        mp_clear(&rz);\n-        mp_clear(&raz4);\n-#ifdef _KERNEL\n-        kmem_free(naf, (orderBitSize + 1));\n-#else\n-        free(naf);\n-#endif\n-        return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_jm.c","additions":0,"deletions":396,"binary":false,"changes":396,"status":"deleted"},{"patch":"@@ -1,202 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the elliptic curve math library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Douglas Stebila <douglas@stebila.ca>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-\/* Uses Montgomery reduction for field arithmetic.  See mpi\/mpmontg.c for\n- * code implementation. *\/\n-\n-#include \"mpi.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-#include \"ecl-priv.h\"\n-#include \"ecp.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#include <stdio.h>\n-#endif\n-\n-\/* Construct a generic GFMethod for arithmetic over prime fields with\n- * irreducible irr. *\/\n-GFMethod *\n-GFMethod_consGFp_mont(const mp_int *irr)\n-{\n-        mp_err res = MP_OKAY;\n-        int i;\n-        GFMethod *meth = NULL;\n-        mp_mont_modulus *mmm;\n-\n-        meth = GFMethod_consGFp(irr);\n-        if (meth == NULL)\n-                return NULL;\n-\n-#ifdef _KERNEL\n-        mmm = (mp_mont_modulus *) kmem_alloc(sizeof(mp_mont_modulus),\n-            FLAG(irr));\n-#else\n-        mmm = (mp_mont_modulus *) malloc(sizeof(mp_mont_modulus));\n-#endif\n-        if (mmm == NULL) {\n-                res = MP_MEM;\n-                goto CLEANUP;\n-        }\n-\n-        meth->field_mul = &ec_GFp_mul_mont;\n-        meth->field_sqr = &ec_GFp_sqr_mont;\n-        meth->field_div = &ec_GFp_div_mont;\n-        meth->field_enc = &ec_GFp_enc_mont;\n-        meth->field_dec = &ec_GFp_dec_mont;\n-        meth->extra1 = mmm;\n-        meth->extra2 = NULL;\n-        meth->extra_free = &ec_GFp_extra_free_mont;\n-\n-        mmm->N = meth->irr;\n-        i = mpl_significant_bits(&meth->irr);\n-        i += MP_DIGIT_BIT - 1;\n-        mmm->b = i - i % MP_DIGIT_BIT;\n-        mmm->n0prime = 0 - s_mp_invmod_radix(MP_DIGIT(&meth->irr, 0));\n-\n-  CLEANUP:\n-        if (res != MP_OKAY) {\n-                GFMethod_free(meth);\n-                return NULL;\n-        }\n-        return meth;\n-}\n-\n-\/* Wrapper functions for generic prime field arithmetic. *\/\n-\n-\/* Field multiplication using Montgomery reduction. *\/\n-mp_err\n-ec_GFp_mul_mont(const mp_int *a, const mp_int *b, mp_int *r,\n-                                const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-#ifdef MP_MONT_USE_MP_MUL\n-        \/* if MP_MONT_USE_MP_MUL is defined, then the function s_mp_mul_mont\n-         * is not implemented and we have to use mp_mul and s_mp_redc directly\n-         *\/\n-        MP_CHECKOK(mp_mul(a, b, r));\n-        MP_CHECKOK(s_mp_redc(r, (mp_mont_modulus *) meth->extra1));\n-#else\n-        mp_int s;\n-\n-        MP_DIGITS(&s) = 0;\n-        \/* s_mp_mul_mont doesn't allow source and destination to be the same *\/\n-        if ((a == r) || (b == r)) {\n-                MP_CHECKOK(mp_init(&s, FLAG(a)));\n-                MP_CHECKOK(s_mp_mul_mont\n-                                   (a, b, &s, (mp_mont_modulus *) meth->extra1));\n-                MP_CHECKOK(mp_copy(&s, r));\n-                mp_clear(&s);\n-        } else {\n-                return s_mp_mul_mont(a, b, r, (mp_mont_modulus *) meth->extra1);\n-        }\n-#endif\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Field squaring using Montgomery reduction. *\/\n-mp_err\n-ec_GFp_sqr_mont(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        return ec_GFp_mul_mont(a, a, r, meth);\n-}\n-\n-\/* Field division using Montgomery reduction. *\/\n-mp_err\n-ec_GFp_div_mont(const mp_int *a, const mp_int *b, mp_int *r,\n-                                const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        \/* if A=aZ represents a encoded in montgomery coordinates with Z and #\n-         * and \\ respectively represent multiplication and division in\n-         * montgomery coordinates, then A\\B = (a\/b)Z = (A\/B)Z and Binv =\n-         * (1\/b)Z = (1\/B)(Z^2) where B # Binv = Z *\/\n-        MP_CHECKOK(ec_GFp_div(a, b, r, meth));\n-        MP_CHECKOK(ec_GFp_enc_mont(r, r, meth));\n-        if (a == NULL) {\n-                MP_CHECKOK(ec_GFp_enc_mont(r, r, meth));\n-        }\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Encode a field element in Montgomery form. See s_mp_to_mont in\n- * mpi\/mpmontg.c *\/\n-mp_err\n-ec_GFp_enc_mont(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_mont_modulus *mmm;\n-        mp_err res = MP_OKAY;\n-\n-        mmm = (mp_mont_modulus *) meth->extra1;\n-        MP_CHECKOK(mpl_lsh(a, r, mmm->b));\n-        MP_CHECKOK(mp_mod(r, &mmm->N, r));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Decode a field element from Montgomery form. *\/\n-mp_err\n-ec_GFp_dec_mont(const mp_int *a, mp_int *r, const GFMethod *meth)\n-{\n-        mp_err res = MP_OKAY;\n-\n-        if (a != r) {\n-                MP_CHECKOK(mp_copy(a, r));\n-        }\n-        MP_CHECKOK(s_mp_redc(r, (mp_mont_modulus *) meth->extra1));\n-  CLEANUP:\n-        return res;\n-}\n-\n-\/* Free the memory allocated to the extra fields of Montgomery GFMethod\n- * object. *\/\n-void\n-ec_GFp_extra_free_mont(GFMethod *meth)\n-{\n-        if (meth->extra1 != NULL) {\n-#ifdef _KERNEL\n-                kmem_free(meth->extra1, sizeof(mp_mont_modulus));\n-#else\n-                free(meth->extra1);\n-#endif\n-                meth->extra1 = NULL;\n-        }\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecp_mont.c","additions":0,"deletions":202,"binary":false,"changes":202,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Netscape security libraries.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 1994-2000\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _LOGTAB_H\n-#define _LOGTAB_H\n-\n-const float s_logv_2[] = {\n-   0.000000000f, 0.000000000f, 1.000000000f, 0.630929754f,  \/*  0  1  2  3 *\/\n-   0.500000000f, 0.430676558f, 0.386852807f, 0.356207187f,  \/*  4  5  6  7 *\/\n-   0.333333333f, 0.315464877f, 0.301029996f, 0.289064826f,  \/*  8  9 10 11 *\/\n-   0.278942946f, 0.270238154f, 0.262649535f, 0.255958025f,  \/* 12 13 14 15 *\/\n-   0.250000000f, 0.244650542f, 0.239812467f, 0.235408913f,  \/* 16 17 18 19 *\/\n-   0.231378213f, 0.227670249f, 0.224243824f, 0.221064729f,  \/* 20 21 22 23 *\/\n-   0.218104292f, 0.215338279f, 0.212746054f, 0.210309918f,  \/* 24 25 26 27 *\/\n-   0.208014598f, 0.205846832f, 0.203795047f, 0.201849087f,  \/* 28 29 30 31 *\/\n-   0.200000000f, 0.198239863f, 0.196561632f, 0.194959022f,  \/* 32 33 34 35 *\/\n-   0.193426404f, 0.191958720f, 0.190551412f, 0.189200360f,  \/* 36 37 38 39 *\/\n-   0.187901825f, 0.186652411f, 0.185449023f, 0.184288833f,  \/* 40 41 42 43 *\/\n-   0.183169251f, 0.182087900f, 0.181042597f, 0.180031327f,  \/* 44 45 46 47 *\/\n-   0.179052232f, 0.178103594f, 0.177183820f, 0.176291434f,  \/* 48 49 50 51 *\/\n-   0.175425064f, 0.174583430f, 0.173765343f, 0.172969690f,  \/* 52 53 54 55 *\/\n-   0.172195434f, 0.171441601f, 0.170707280f, 0.169991616f,  \/* 56 57 58 59 *\/\n-   0.169293808f, 0.168613099f, 0.167948779f, 0.167300179f,  \/* 60 61 62 63 *\/\n-   0.166666667f\n-};\n-\n-#endif \/* _LOGTAB_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/logtab.h","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Multi-precision Binary Polynomial Arithmetic Library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang Shantz <sheueling.chang@sun.com> and\n- *   Douglas Stebila <douglas@stebila.ca> of Sun Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _MP_GF2M_PRIV_H_\n-#define _MP_GF2M_PRIV_H_\n-\n-#include \"mpi-priv.h\"\n-\n-extern const mp_digit mp_gf2m_sqr_tb[16];\n-\n-#if defined(MP_USE_UINT_DIGIT)\n-#define MP_DIGIT_BITS 32\n-#else\n-#define MP_DIGIT_BITS 64\n-#endif\n-\n-\/* Platform-specific macros for fast binary polynomial squaring. *\/\n-#if MP_DIGIT_BITS == 32\n-#define gf2m_SQR1(w) \\\n-    mp_gf2m_sqr_tb[(w) >> 28 & 0xF] << 24 | mp_gf2m_sqr_tb[(w) >> 24 & 0xF] << 16 | \\\n-    mp_gf2m_sqr_tb[(w) >> 20 & 0xF] <<  8 | mp_gf2m_sqr_tb[(w) >> 16 & 0xF]\n-#define gf2m_SQR0(w) \\\n-    mp_gf2m_sqr_tb[(w) >> 12 & 0xF] << 24 | mp_gf2m_sqr_tb[(w) >>  8 & 0xF] << 16 | \\\n-    mp_gf2m_sqr_tb[(w) >>  4 & 0xF] <<  8 | mp_gf2m_sqr_tb[(w)       & 0xF]\n-#else\n-#define gf2m_SQR1(w) \\\n-    mp_gf2m_sqr_tb[(w) >> 60 & 0xF] << 56 | mp_gf2m_sqr_tb[(w) >> 56 & 0xF] << 48 | \\\n-    mp_gf2m_sqr_tb[(w) >> 52 & 0xF] << 40 | mp_gf2m_sqr_tb[(w) >> 48 & 0xF] << 32 | \\\n-    mp_gf2m_sqr_tb[(w) >> 44 & 0xF] << 24 | mp_gf2m_sqr_tb[(w) >> 40 & 0xF] << 16 | \\\n-    mp_gf2m_sqr_tb[(w) >> 36 & 0xF] <<  8 | mp_gf2m_sqr_tb[(w) >> 32 & 0xF]\n-#define gf2m_SQR0(w) \\\n-    mp_gf2m_sqr_tb[(w) >> 28 & 0xF] << 56 | mp_gf2m_sqr_tb[(w) >> 24 & 0xF] << 48 | \\\n-    mp_gf2m_sqr_tb[(w) >> 20 & 0xF] << 40 | mp_gf2m_sqr_tb[(w) >> 16 & 0xF] << 32 | \\\n-    mp_gf2m_sqr_tb[(w) >> 12 & 0xF] << 24 | mp_gf2m_sqr_tb[(w) >>  8 & 0xF] << 16 | \\\n-    mp_gf2m_sqr_tb[(w) >>  4 & 0xF] <<  8 | mp_gf2m_sqr_tb[(w)       & 0xF]\n-#endif\n-\n-\/* Multiply two binary polynomials mp_digits a, b.\n- * Result is a polynomial with degree < 2 * MP_DIGIT_BITS - 1.\n- * Output in two mp_digits rh, rl.\n- *\/\n-void s_bmul_1x1(mp_digit *rh, mp_digit *rl, const mp_digit a, const mp_digit b);\n-\n-\/* Compute xor-multiply of two binary polynomials  (a1, a0) x (b1, b0)\n- * result is a binary polynomial in 4 mp_digits r[4].\n- * The caller MUST ensure that r has the right amount of space allocated.\n- *\/\n-void s_bmul_2x2(mp_digit *r, const mp_digit a1, const mp_digit a0, const mp_digit b1,\n-        const mp_digit b0);\n-\n-\/* Compute xor-multiply of two binary polynomials  (a2, a1, a0) x (b2, b1, b0)\n- * result is a binary polynomial in 6 mp_digits r[6].\n- * The caller MUST ensure that r has the right amount of space allocated.\n- *\/\n-void s_bmul_3x3(mp_digit *r, const mp_digit a2, const mp_digit a1, const mp_digit a0,\n-        const mp_digit b2, const mp_digit b1, const mp_digit b0);\n-\n-\/* Compute xor-multiply of two binary polynomials  (a3, a2, a1, a0) x (b3, b2, b1, b0)\n- * result is a binary polynomial in 8 mp_digits r[8].\n- * The caller MUST ensure that r has the right amount of space allocated.\n- *\/\n-void s_bmul_4x4(mp_digit *r, const mp_digit a3, const mp_digit a2, const mp_digit a1,\n-        const mp_digit a0, const mp_digit b3, const mp_digit b2, const mp_digit b1,\n-        const mp_digit b0);\n-\n-#endif \/* _MP_GF2M_PRIV_H_ *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mp_gf2m-priv.h","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,603 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Multi-precision Binary Polynomial Arithmetic Library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang Shantz <sheueling.chang@sun.com> and\n- *   Douglas Stebila <douglas@stebila.ca> of Sun Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-#include \"mp_gf2m.h\"\n-#include \"mp_gf2m-priv.h\"\n-#include \"mplogic.h\"\n-#include \"mpi-priv.h\"\n-\n-const mp_digit mp_gf2m_sqr_tb[16] =\n-{\n-      0,     1,     4,     5,    16,    17,    20,    21,\n-     64,    65,    68,    69,    80,    81,    84,    85\n-};\n-\n-\/* Multiply two binary polynomials mp_digits a, b.\n- * Result is a polynomial with degree < 2 * MP_DIGIT_BITS - 1.\n- * Output in two mp_digits rh, rl.\n- *\/\n-#if MP_DIGIT_BITS == 32\n-void\n-s_bmul_1x1(mp_digit *rh, mp_digit *rl, const mp_digit a, const mp_digit b)\n-{\n-    register mp_digit h, l, s;\n-    mp_digit tab[8], top2b = a >> 30;\n-    register mp_digit a1, a2, a4;\n-\n-    a1 = a & (0x3FFFFFFF); a2 = a1 << 1; a4 = a2 << 1;\n-\n-    tab[0] =  0; tab[1] = a1;    tab[2] = a2;    tab[3] = a1^a2;\n-    tab[4] = a4; tab[5] = a1^a4; tab[6] = a2^a4; tab[7] = a1^a2^a4;\n-\n-    s = tab[b       & 0x7]; l  = s;\n-    s = tab[b >>  3 & 0x7]; l ^= s <<  3; h  = s >> 29;\n-    s = tab[b >>  6 & 0x7]; l ^= s <<  6; h ^= s >> 26;\n-    s = tab[b >>  9 & 0x7]; l ^= s <<  9; h ^= s >> 23;\n-    s = tab[b >> 12 & 0x7]; l ^= s << 12; h ^= s >> 20;\n-    s = tab[b >> 15 & 0x7]; l ^= s << 15; h ^= s >> 17;\n-    s = tab[b >> 18 & 0x7]; l ^= s << 18; h ^= s >> 14;\n-    s = tab[b >> 21 & 0x7]; l ^= s << 21; h ^= s >> 11;\n-    s = tab[b >> 24 & 0x7]; l ^= s << 24; h ^= s >>  8;\n-    s = tab[b >> 27 & 0x7]; l ^= s << 27; h ^= s >>  5;\n-    s = tab[b >> 30      ]; l ^= s << 30; h ^= s >>  2;\n-\n-    \/* compensate for the top two bits of a *\/\n-\n-    if (top2b & 01) { l ^= b << 30; h ^= b >> 2; }\n-    if (top2b & 02) { l ^= b << 31; h ^= b >> 1; }\n-\n-    *rh = h; *rl = l;\n-}\n-#else\n-void\n-s_bmul_1x1(mp_digit *rh, mp_digit *rl, const mp_digit a, const mp_digit b)\n-{\n-    register mp_digit h, l, s;\n-    mp_digit tab[16], top3b = a >> 61;\n-    register mp_digit a1, a2, a4, a8;\n-\n-    a1 = a & (0x1FFFFFFFFFFFFFFFULL); a2 = a1 << 1;\n-    a4 = a2 << 1; a8 = a4 << 1;\n-    tab[ 0] = 0;     tab[ 1] = a1;       tab[ 2] = a2;       tab[ 3] = a1^a2;\n-    tab[ 4] = a4;    tab[ 5] = a1^a4;    tab[ 6] = a2^a4;    tab[ 7] = a1^a2^a4;\n-    tab[ 8] = a8;    tab[ 9] = a1^a8;    tab[10] = a2^a8;    tab[11] = a1^a2^a8;\n-    tab[12] = a4^a8; tab[13] = a1^a4^a8; tab[14] = a2^a4^a8; tab[15] = a1^a2^a4^a8;\n-\n-    s = tab[b       & 0xF]; l  = s;\n-    s = tab[b >>  4 & 0xF]; l ^= s <<  4; h  = s >> 60;\n-    s = tab[b >>  8 & 0xF]; l ^= s <<  8; h ^= s >> 56;\n-    s = tab[b >> 12 & 0xF]; l ^= s << 12; h ^= s >> 52;\n-    s = tab[b >> 16 & 0xF]; l ^= s << 16; h ^= s >> 48;\n-    s = tab[b >> 20 & 0xF]; l ^= s << 20; h ^= s >> 44;\n-    s = tab[b >> 24 & 0xF]; l ^= s << 24; h ^= s >> 40;\n-    s = tab[b >> 28 & 0xF]; l ^= s << 28; h ^= s >> 36;\n-    s = tab[b >> 32 & 0xF]; l ^= s << 32; h ^= s >> 32;\n-    s = tab[b >> 36 & 0xF]; l ^= s << 36; h ^= s >> 28;\n-    s = tab[b >> 40 & 0xF]; l ^= s << 40; h ^= s >> 24;\n-    s = tab[b >> 44 & 0xF]; l ^= s << 44; h ^= s >> 20;\n-    s = tab[b >> 48 & 0xF]; l ^= s << 48; h ^= s >> 16;\n-    s = tab[b >> 52 & 0xF]; l ^= s << 52; h ^= s >> 12;\n-    s = tab[b >> 56 & 0xF]; l ^= s << 56; h ^= s >>  8;\n-    s = tab[b >> 60      ]; l ^= s << 60; h ^= s >>  4;\n-\n-    \/* compensate for the top three bits of a *\/\n-\n-    if (top3b & 01) { l ^= b << 61; h ^= b >> 3; }\n-    if (top3b & 02) { l ^= b << 62; h ^= b >> 2; }\n-    if (top3b & 04) { l ^= b << 63; h ^= b >> 1; }\n-\n-    *rh = h; *rl = l;\n-}\n-#endif\n-\n-\/* Compute xor-multiply of two binary polynomials  (a1, a0) x (b1, b0)\n- * result is a binary polynomial in 4 mp_digits r[4].\n- * The caller MUST ensure that r has the right amount of space allocated.\n- *\/\n-void\n-s_bmul_2x2(mp_digit *r, const mp_digit a1, const mp_digit a0, const mp_digit b1,\n-           const mp_digit b0)\n-{\n-    mp_digit m1, m0;\n-    \/* r[3] = h1, r[2] = h0; r[1] = l1; r[0] = l0 *\/\n-    s_bmul_1x1(r+3, r+2, a1, b1);\n-    s_bmul_1x1(r+1, r, a0, b0);\n-    s_bmul_1x1(&m1, &m0, a0 ^ a1, b0 ^ b1);\n-    \/* Correction on m1 ^= l1 ^ h1; m0 ^= l0 ^ h0; *\/\n-    r[2] ^= m1 ^ r[1] ^ r[3];  \/* h0 ^= m1 ^ l1 ^ h1; *\/\n-    r[1]  = r[3] ^ r[2] ^ r[0] ^ m1 ^ m0;  \/* l1 ^= l0 ^ h0 ^ m0; *\/\n-}\n-\n-\/* Compute xor-multiply of two binary polynomials  (a2, a1, a0) x (b2, b1, b0)\n- * result is a binary polynomial in 6 mp_digits r[6].\n- * The caller MUST ensure that r has the right amount of space allocated.\n- *\/\n-void\n-s_bmul_3x3(mp_digit *r, const mp_digit a2, const mp_digit a1, const mp_digit a0,\n-        const mp_digit b2, const mp_digit b1, const mp_digit b0)\n-{\n-        mp_digit zm[4];\n-\n-        s_bmul_1x1(r+5, r+4, a2, b2);         \/* fill top 2 words *\/\n-        s_bmul_2x2(zm, a1, a2^a0, b1, b2^b0); \/* fill middle 4 words *\/\n-        s_bmul_2x2(r, a1, a0, b1, b0);        \/* fill bottom 4 words *\/\n-\n-        zm[3] ^= r[3];\n-        zm[2] ^= r[2];\n-        zm[1] ^= r[1] ^ r[5];\n-        zm[0] ^= r[0] ^ r[4];\n-\n-        r[5]  ^= zm[3];\n-        r[4]  ^= zm[2];\n-        r[3]  ^= zm[1];\n-        r[2]  ^= zm[0];\n-}\n-\n-\/* Compute xor-multiply of two binary polynomials  (a3, a2, a1, a0) x (b3, b2, b1, b0)\n- * result is a binary polynomial in 8 mp_digits r[8].\n- * The caller MUST ensure that r has the right amount of space allocated.\n- *\/\n-void s_bmul_4x4(mp_digit *r, const mp_digit a3, const mp_digit a2, const mp_digit a1,\n-        const mp_digit a0, const mp_digit b3, const mp_digit b2, const mp_digit b1,\n-        const mp_digit b0)\n-{\n-        mp_digit zm[4];\n-\n-        s_bmul_2x2(r+4, a3, a2, b3, b2);            \/* fill top 4 words *\/\n-        s_bmul_2x2(zm, a3^a1, a2^a0, b3^b1, b2^b0); \/* fill middle 4 words *\/\n-        s_bmul_2x2(r, a1, a0, b1, b0);              \/* fill bottom 4 words *\/\n-\n-        zm[3] ^= r[3] ^ r[7];\n-        zm[2] ^= r[2] ^ r[6];\n-        zm[1] ^= r[1] ^ r[5];\n-        zm[0] ^= r[0] ^ r[4];\n-\n-        r[5]  ^= zm[3];\n-        r[4]  ^= zm[2];\n-        r[3]  ^= zm[1];\n-        r[2]  ^= zm[0];\n-}\n-\n-\/* Compute addition of two binary polynomials a and b,\n- * store result in c; c could be a or b, a and b could be equal;\n- * c is the bitwise XOR of a and b.\n- *\/\n-mp_err\n-mp_badd(const mp_int *a, const mp_int *b, mp_int *c)\n-{\n-    mp_digit *pa, *pb, *pc;\n-    mp_size ix;\n-    mp_size used_pa, used_pb;\n-    mp_err res = MP_OKAY;\n-\n-    \/* Add all digits up to the precision of b.  If b had more\n-     * precision than a initially, swap a, b first\n-     *\/\n-    if (MP_USED(a) >= MP_USED(b)) {\n-        pa = MP_DIGITS(a);\n-        pb = MP_DIGITS(b);\n-        used_pa = MP_USED(a);\n-        used_pb = MP_USED(b);\n-    } else {\n-        pa = MP_DIGITS(b);\n-        pb = MP_DIGITS(a);\n-        used_pa = MP_USED(b);\n-        used_pb = MP_USED(a);\n-    }\n-\n-    \/* Make sure c has enough precision for the output value *\/\n-    MP_CHECKOK( s_mp_pad(c, used_pa) );\n-\n-    \/* Do word-by-word xor *\/\n-    pc = MP_DIGITS(c);\n-    for (ix = 0; ix < used_pb; ix++) {\n-        (*pc++) = (*pa++) ^ (*pb++);\n-    }\n-\n-    \/* Finish the rest of digits until we're actually done *\/\n-    for (; ix < used_pa; ++ix) {\n-        *pc++ = *pa++;\n-    }\n-\n-    MP_USED(c) = used_pa;\n-    MP_SIGN(c) = ZPOS;\n-    s_mp_clamp(c);\n-\n-CLEANUP:\n-    return res;\n-}\n-\n-#define s_mp_div2(a) MP_CHECKOK( mpl_rsh((a), (a), 1) );\n-\n-\/* Compute binary polynomial multiply d = a * b *\/\n-static void\n-s_bmul_d(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *d)\n-{\n-    mp_digit a_i, a0b0, a1b1, carry = 0;\n-    while (a_len--) {\n-        a_i = *a++;\n-        s_bmul_1x1(&a1b1, &a0b0, a_i, b);\n-        *d++ = a0b0 ^ carry;\n-        carry = a1b1;\n-    }\n-    *d = carry;\n-}\n-\n-\/* Compute binary polynomial xor multiply accumulate d ^= a * b *\/\n-static void\n-s_bmul_d_add(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *d)\n-{\n-    mp_digit a_i, a0b0, a1b1, carry = 0;\n-    while (a_len--) {\n-        a_i = *a++;\n-        s_bmul_1x1(&a1b1, &a0b0, a_i, b);\n-        *d++ ^= a0b0 ^ carry;\n-        carry = a1b1;\n-    }\n-    *d ^= carry;\n-}\n-\n-\/* Compute binary polynomial xor multiply c = a * b.\n- * All parameters may be identical.\n- *\/\n-mp_err\n-mp_bmul(const mp_int *a, const mp_int *b, mp_int *c)\n-{\n-    mp_digit *pb, b_i;\n-    mp_int tmp;\n-    mp_size ib, a_used, b_used;\n-    mp_err res = MP_OKAY;\n-\n-    MP_DIGITS(&tmp) = 0;\n-\n-    ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-    if (a == c) {\n-        MP_CHECKOK( mp_init_copy(&tmp, a) );\n-        if (a == b)\n-            b = &tmp;\n-        a = &tmp;\n-    } else if (b == c) {\n-        MP_CHECKOK( mp_init_copy(&tmp, b) );\n-        b = &tmp;\n-    }\n-\n-    if (MP_USED(a) < MP_USED(b)) {\n-        const mp_int *xch = b;      \/* switch a and b if b longer *\/\n-        b = a;\n-        a = xch;\n-    }\n-\n-    MP_USED(c) = 1; MP_DIGIT(c, 0) = 0;\n-    MP_CHECKOK( s_mp_pad(c, USED(a) + USED(b)) );\n-\n-    pb = MP_DIGITS(b);\n-    s_bmul_d(MP_DIGITS(a), MP_USED(a), *pb++, MP_DIGITS(c));\n-\n-    \/* Outer loop:  Digits of b *\/\n-    a_used = MP_USED(a);\n-    b_used = MP_USED(b);\n-        MP_USED(c) = a_used + b_used;\n-    for (ib = 1; ib < b_used; ib++) {\n-        b_i = *pb++;\n-\n-        \/* Inner product:  Digits of a *\/\n-        if (b_i)\n-            s_bmul_d_add(MP_DIGITS(a), a_used, b_i, MP_DIGITS(c) + ib);\n-        else\n-            MP_DIGIT(c, ib + a_used) = b_i;\n-    }\n-\n-    s_mp_clamp(c);\n-\n-    SIGN(c) = ZPOS;\n-\n-CLEANUP:\n-    mp_clear(&tmp);\n-    return res;\n-}\n-\n-\n-\/* Compute modular reduction of a and store result in r.\n- * r could be a.\n- * For modular arithmetic, the irreducible polynomial f(t) is represented\n- * as an array of int[], where f(t) is of the form:\n- *     f(t) = t^p[0] + t^p[1] + ... + t^p[k]\n- * where m = p[0] > p[1] > ... > p[k] = 0.\n- *\/\n-mp_err\n-mp_bmod(const mp_int *a, const unsigned int p[], mp_int *r)\n-{\n-    int j, k;\n-    int n, dN, d0, d1;\n-    mp_digit zz, *z, tmp;\n-    mp_size used;\n-    mp_err res = MP_OKAY;\n-\n-    \/* The algorithm does the reduction in place in r,\n-     * if a != r, copy a into r first so reduction can be done in r\n-     *\/\n-    if (a != r) {\n-        MP_CHECKOK( mp_copy(a, r) );\n-    }\n-    z = MP_DIGITS(r);\n-\n-    \/* start reduction *\/\n-    dN = p[0] \/ MP_DIGIT_BITS;\n-    used = MP_USED(r);\n-\n-    for (j = used - 1; j > dN;) {\n-\n-        zz = z[j];\n-        if (zz == 0) {\n-            j--; continue;\n-        }\n-        z[j] = 0;\n-\n-        for (k = 1; p[k] > 0; k++) {\n-            \/* reducing component t^p[k] *\/\n-            n = p[0] - p[k];\n-            d0 = n % MP_DIGIT_BITS;\n-            d1 = MP_DIGIT_BITS - d0;\n-            n \/= MP_DIGIT_BITS;\n-            z[j-n] ^= (zz>>d0);\n-            if (d0)\n-                z[j-n-1] ^= (zz<<d1);\n-        }\n-\n-        \/* reducing component t^0 *\/\n-        n = dN;\n-        d0 = p[0] % MP_DIGIT_BITS;\n-        d1 = MP_DIGIT_BITS - d0;\n-        z[j-n] ^= (zz >> d0);\n-        if (d0)\n-            z[j-n-1] ^= (zz << d1);\n-\n-    }\n-\n-    \/* final round of reduction *\/\n-    while (j == dN) {\n-\n-        d0 = p[0] % MP_DIGIT_BITS;\n-        zz = z[dN] >> d0;\n-        if (zz == 0) break;\n-        d1 = MP_DIGIT_BITS - d0;\n-\n-        \/* clear up the top d1 bits *\/\n-        if (d0) z[dN] = (z[dN] << d1) >> d1;\n-        *z ^= zz; \/* reduction t^0 component *\/\n-\n-        for (k = 1; p[k] > 0; k++) {\n-            \/* reducing component t^p[k]*\/\n-            n = p[k] \/ MP_DIGIT_BITS;\n-            d0 = p[k] % MP_DIGIT_BITS;\n-            d1 = MP_DIGIT_BITS - d0;\n-            z[n] ^= (zz << d0);\n-            tmp = zz >> d1;\n-            if (d0 && tmp)\n-                z[n+1] ^= tmp;\n-        }\n-    }\n-\n-    s_mp_clamp(r);\n-CLEANUP:\n-    return res;\n-}\n-\n-\/* Compute the product of two polynomials a and b, reduce modulo p,\n- * Store the result in r.  r could be a or b; a could be b.\n- *\/\n-mp_err\n-mp_bmulmod(const mp_int *a, const mp_int *b, const unsigned int p[], mp_int *r)\n-{\n-    mp_err res;\n-\n-    if (a == b) return mp_bsqrmod(a, p, r);\n-    if ((res = mp_bmul(a, b, r) ) != MP_OKAY)\n-        return res;\n-    return mp_bmod(r, p, r);\n-}\n-\n-\/* Compute binary polynomial squaring c = a*a mod p .\n- * Parameter r and a can be identical.\n- *\/\n-\n-mp_err\n-mp_bsqrmod(const mp_int *a, const unsigned int p[], mp_int *r)\n-{\n-    mp_digit *pa, *pr, a_i;\n-    mp_int tmp;\n-    mp_size ia, a_used;\n-    mp_err res;\n-\n-    ARGCHK(a != NULL && r != NULL, MP_BADARG);\n-    MP_DIGITS(&tmp) = 0;\n-\n-    if (a == r) {\n-        MP_CHECKOK( mp_init_copy(&tmp, a) );\n-        a = &tmp;\n-    }\n-\n-    MP_USED(r) = 1; MP_DIGIT(r, 0) = 0;\n-    MP_CHECKOK( s_mp_pad(r, 2*USED(a)) );\n-\n-    pa = MP_DIGITS(a);\n-    pr = MP_DIGITS(r);\n-    a_used = MP_USED(a);\n-        MP_USED(r) = 2 * a_used;\n-\n-    for (ia = 0; ia < a_used; ia++) {\n-        a_i = *pa++;\n-        *pr++ = gf2m_SQR0(a_i);\n-        *pr++ = gf2m_SQR1(a_i);\n-    }\n-\n-    MP_CHECKOK( mp_bmod(r, p, r) );\n-    s_mp_clamp(r);\n-    SIGN(r) = ZPOS;\n-\n-CLEANUP:\n-    mp_clear(&tmp);\n-    return res;\n-}\n-\n-\/* Compute binary polynomial y\/x mod p, y divided by x, reduce modulo p.\n- * Store the result in r. r could be x or y, and x could equal y.\n- * Uses algorithm Modular_Division_GF(2^m) from\n- *     Chang-Shantz, S.  \"From Euclid's GCD to Montgomery Multiplication to\n- *     the Great Divide\".\n- *\/\n-int\n-mp_bdivmod(const mp_int *y, const mp_int *x, const mp_int *pp,\n-    const unsigned int p[], mp_int *r)\n-{\n-    mp_int aa, bb, uu;\n-    mp_int *a, *b, *u, *v;\n-    mp_err res = MP_OKAY;\n-\n-    MP_DIGITS(&aa) = 0;\n-    MP_DIGITS(&bb) = 0;\n-    MP_DIGITS(&uu) = 0;\n-\n-    MP_CHECKOK( mp_init_copy(&aa, x) );\n-    MP_CHECKOK( mp_init_copy(&uu, y) );\n-    MP_CHECKOK( mp_init_copy(&bb, pp) );\n-    MP_CHECKOK( s_mp_pad(r, USED(pp)) );\n-    MP_USED(r) = 1; MP_DIGIT(r, 0) = 0;\n-\n-    a = &aa; b= &bb; u=&uu; v=r;\n-    \/* reduce x and y mod p *\/\n-    MP_CHECKOK( mp_bmod(a, p, a) );\n-    MP_CHECKOK( mp_bmod(u, p, u) );\n-\n-    while (!mp_isodd(a)) {\n-        s_mp_div2(a);\n-        if (mp_isodd(u)) {\n-            MP_CHECKOK( mp_badd(u, pp, u) );\n-        }\n-        s_mp_div2(u);\n-    }\n-\n-    do {\n-        if (mp_cmp_mag(b, a) > 0) {\n-            MP_CHECKOK( mp_badd(b, a, b) );\n-            MP_CHECKOK( mp_badd(v, u, v) );\n-            do {\n-                s_mp_div2(b);\n-                if (mp_isodd(v)) {\n-                    MP_CHECKOK( mp_badd(v, pp, v) );\n-                }\n-                s_mp_div2(v);\n-            } while (!mp_isodd(b));\n-        }\n-        else if ((MP_DIGIT(a,0) == 1) && (MP_USED(a) == 1))\n-            break;\n-        else {\n-            MP_CHECKOK( mp_badd(a, b, a) );\n-            MP_CHECKOK( mp_badd(u, v, u) );\n-            do {\n-                s_mp_div2(a);\n-                if (mp_isodd(u)) {\n-                    MP_CHECKOK( mp_badd(u, pp, u) );\n-                }\n-                s_mp_div2(u);\n-            } while (!mp_isodd(a));\n-        }\n-    } while (1);\n-\n-    MP_CHECKOK( mp_copy(u, r) );\n-\n-CLEANUP:\n-    \/* XXX this appears to be a memory leak in the NSS code *\/\n-    mp_clear(&aa);\n-    mp_clear(&bb);\n-    mp_clear(&uu);\n-    return res;\n-\n-}\n-\n-\/* Convert the bit-string representation of a polynomial a into an array\n- * of integers corresponding to the bits with non-zero coefficient.\n- * Up to max elements of the array will be filled.  Return value is total\n- * number of coefficients that would be extracted if array was large enough.\n- *\/\n-int\n-mp_bpoly2arr(const mp_int *a, unsigned int p[], int max)\n-{\n-    int i, j, k;\n-    mp_digit top_bit, mask;\n-\n-    top_bit = 1;\n-    top_bit <<= MP_DIGIT_BIT - 1;\n-\n-    for (k = 0; k < max; k++) p[k] = 0;\n-    k = 0;\n-\n-    for (i = MP_USED(a) - 1; i >= 0; i--) {\n-        mask = top_bit;\n-        for (j = MP_DIGIT_BIT - 1; j >= 0; j--) {\n-            if (MP_DIGITS(a)[i] & mask) {\n-                if (k < max) p[k] = MP_DIGIT_BIT * i + j;\n-                k++;\n-            }\n-            mask >>= 1;\n-        }\n-    }\n-\n-    return k;\n-}\n-\n-\/* Convert the coefficient array representation of a polynomial to a\n- * bit-string.  The array must be terminated by 0.\n- *\/\n-mp_err\n-mp_barr2poly(const unsigned int p[], mp_int *a)\n-{\n-\n-    mp_err res = MP_OKAY;\n-    int i;\n-\n-    mp_zero(a);\n-    for (i = 0; p[i] > 0; i++) {\n-        MP_CHECKOK( mpl_set_bit(a, p[i], 1) );\n-    }\n-    MP_CHECKOK( mpl_set_bit(a, 0, 1) );\n-\n-CLEANUP:\n-    return res;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mp_gf2m.c","additions":0,"deletions":603,"binary":false,"changes":603,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Multi-precision Binary Polynomial Arithmetic Library.\n- *\n- * The Initial Developer of the Original Code is\n- * Sun Microsystems, Inc.\n- * Portions created by the Initial Developer are Copyright (C) 2003\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang Shantz <sheueling.chang@sun.com> and\n- *   Douglas Stebila <douglas@stebila.ca> of Sun Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _MP_GF2M_H_\n-#define _MP_GF2M_H_\n-\n-#include \"mpi.h\"\n-\n-mp_err mp_badd(const mp_int *a, const mp_int *b, mp_int *c);\n-mp_err mp_bmul(const mp_int *a, const mp_int *b, mp_int *c);\n-\n-\/* For modular arithmetic, the irreducible polynomial f(t) is represented\n- * as an array of int[], where f(t) is of the form:\n- *     f(t) = t^p[0] + t^p[1] + ... + t^p[k]\n- * where m = p[0] > p[1] > ... > p[k] = 0.\n- *\/\n-mp_err mp_bmod(const mp_int *a, const unsigned int p[], mp_int *r);\n-mp_err mp_bmulmod(const mp_int *a, const mp_int *b, const unsigned int p[],\n-    mp_int *r);\n-mp_err mp_bsqrmod(const mp_int *a, const unsigned int p[], mp_int *r);\n-mp_err mp_bdivmod(const mp_int *y, const mp_int *x, const mp_int *pp,\n-    const unsigned int p[], mp_int *r);\n-\n-int mp_bpoly2arr(const mp_int *a, unsigned int p[], int max);\n-mp_err mp_barr2poly(const unsigned int p[], mp_int *a);\n-\n-#endif \/* _MP_GF2M_H_ *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mp_gf2m.h","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1997\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Netscape Communications Corporation\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _MPI_CONFIG_H\n-#define _MPI_CONFIG_H\n-\n-\/* $Id: mpi-config.h,v 1.5 2004\/04\/25 15:03:10 gerv%gerv.net Exp $ *\/\n-\n-\/*\n-  For boolean options,\n-  0 = no\n-  1 = yes\n-\n-  Other options are documented individually.\n-\n- *\/\n-\n-#ifndef MP_IOFUNC\n-#define MP_IOFUNC     0  \/* include mp_print() ?                *\/\n-#endif\n-\n-#ifndef MP_MODARITH\n-#define MP_MODARITH   1  \/* include modular arithmetic ?        *\/\n-#endif\n-\n-#ifndef MP_NUMTH\n-#define MP_NUMTH      1  \/* include number theoretic functions? *\/\n-#endif\n-\n-#ifndef MP_LOGTAB\n-#define MP_LOGTAB     1  \/* use table of logs instead of log()? *\/\n-#endif\n-\n-#ifndef MP_MEMSET\n-#define MP_MEMSET     1  \/* use memset() to zero buffers?       *\/\n-#endif\n-\n-#ifndef MP_MEMCPY\n-#define MP_MEMCPY     1  \/* use memcpy() to copy buffers?       *\/\n-#endif\n-\n-#ifndef MP_CRYPTO\n-#define MP_CRYPTO     1  \/* erase memory on free?               *\/\n-#endif\n-\n-#ifndef MP_ARGCHK\n-\/*\n-  0 = no parameter checks\n-  1 = runtime checks, continue execution and return an error to caller\n-  2 = assertions; dump core on parameter errors\n- *\/\n-#ifdef DEBUG\n-#define MP_ARGCHK     2  \/* how to check input arguments        *\/\n-#else\n-#define MP_ARGCHK     1  \/* how to check input arguments        *\/\n-#endif\n-#endif\n-\n-#ifndef MP_DEBUG\n-#define MP_DEBUG      0  \/* print diagnostic output?            *\/\n-#endif\n-\n-#ifndef MP_DEFPREC\n-#define MP_DEFPREC    64 \/* default precision, in digits        *\/\n-#endif\n-\n-#ifndef MP_MACRO\n-#define MP_MACRO      0  \/* use macros for frequent calls?      *\/\n-#endif\n-\n-#ifndef MP_SQUARE\n-#define MP_SQUARE     1  \/* use separate squaring code?         *\/\n-#endif\n-\n-#endif \/* _MPI_CONFIG_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mpi-config.h","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,320 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1998\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Netscape Communications Corporation\n- *\n- *********************************************************************** *\/\n-\n-\/*  Arbitrary precision integer arithmetic library\n- *\n- *  NOTE WELL: the content of this header file is NOT part of the \"public\"\n- *  API for the MPI library, and may change at any time.\n- *  Application programs that use libmpi should NOT include this header file.\n- *\/\n-\n-#ifndef _MPI_PRIV_H\n-#define _MPI_PRIV_H\n-\n-\/* $Id: mpi-priv.h,v 1.20 2005\/11\/22 07:16:43 relyea%netscape.com Exp $ *\/\n-\n-#include \"mpi.h\"\n-#ifndef _KERNEL\n-#include <stdlib.h>\n-#include <string.h>\n-#include <ctype.h>\n-#endif \/* _KERNEL *\/\n-\n-#if MP_DEBUG\n-#include <stdio.h>\n-\n-#define DIAG(T,V) {fprintf(stderr,T);mp_print(V,stderr);fputc('\\n',stderr);}\n-#else\n-#define DIAG(T,V)\n-#endif\n-\n-\/* If we aren't using a wired-in logarithm table, we need to include\n-   the math library to get the log() function\n- *\/\n-\n-\/* {{{ s_logv_2[] - log table for 2 in various bases *\/\n-\n-#if MP_LOGTAB\n-\/*\n-  A table of the logs of 2 for various bases (the 0 and 1 entries of\n-  this table are meaningless and should not be referenced).\n-\n-  This table is used to compute output lengths for the mp_toradix()\n-  function.  Since a number n in radix r takes up about log_r(n)\n-  digits, we estimate the output size by taking the least integer\n-  greater than log_r(n), where:\n-\n-  log_r(n) = log_2(n) * log_r(2)\n-\n-  This table, therefore, is a table of log_r(2) for 2 <= r <= 36,\n-  which are the output bases supported.\n- *\/\n-\n-extern const float s_logv_2[];\n-#define LOG_V_2(R)  s_logv_2[(R)]\n-\n-#else\n-\n-\/*\n-   If MP_LOGTAB is not defined, use the math library to compute the\n-   logarithms on the fly.  Otherwise, use the table.\n-   Pick which works best for your system.\n- *\/\n-\n-#include <math.h>\n-#define LOG_V_2(R)  (log(2.0)\/log(R))\n-\n-#endif \/* if MP_LOGTAB *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ Digit arithmetic macros *\/\n-\n-\/*\n-  When adding and multiplying digits, the results can be larger than\n-  can be contained in an mp_digit.  Thus, an mp_word is used.  These\n-  macros mask off the upper and lower digits of the mp_word (the\n-  mp_word may be more than 2 mp_digits wide, but we only concern\n-  ourselves with the low-order 2 mp_digits)\n- *\/\n-\n-#define  CARRYOUT(W)  (mp_digit)((W)>>DIGIT_BIT)\n-#define  ACCUM(W)     (mp_digit)(W)\n-\n-#define MP_MIN(a,b)   (((a) < (b)) ? (a) : (b))\n-#define MP_MAX(a,b)   (((a) > (b)) ? (a) : (b))\n-#define MP_HOWMANY(a,b) (((a) + (b) - 1)\/(b))\n-#define MP_ROUNDUP(a,b) (MP_HOWMANY(a,b) * (b))\n-\n-\/* }}} *\/\n-\n-\/* {{{ Comparison constants *\/\n-\n-#define  MP_LT       -1\n-#define  MP_EQ        0\n-#define  MP_GT        1\n-\n-\/* }}} *\/\n-\n-\/* {{{ private function declarations *\/\n-\n-\/*\n-   If MP_MACRO is false, these will be defined as actual functions;\n-   otherwise, suitable macro definitions will be used.  This works\n-   around the fact that ANSI C89 doesn't support an 'inline' keyword\n-   (although I hear C9x will ... about bloody time).  At present, the\n-   macro definitions are identical to the function bodies, but they'll\n-   expand in place, instead of generating a function call.\n-\n-   I chose these particular functions to be made into macros because\n-   some profiling showed they are called a lot on a typical workload,\n-   and yet they are primarily housekeeping.\n- *\/\n-#if MP_MACRO == 0\n- void     s_mp_setz(mp_digit *dp, mp_size count); \/* zero digits           *\/\n- void     s_mp_copy(const mp_digit *sp, mp_digit *dp, mp_size count); \/* copy *\/\n- void    *s_mp_alloc(size_t nb, size_t ni, int flag); \/* general allocator    *\/\n- void     s_mp_free(void *ptr, mp_size);          \/* general free function *\/\n-extern unsigned long mp_allocs;\n-extern unsigned long mp_frees;\n-extern unsigned long mp_copies;\n-#else\n-\n- \/* Even if these are defined as macros, we need to respect the settings\n-    of the MP_MEMSET and MP_MEMCPY configuration options...\n-  *\/\n- #if MP_MEMSET == 0\n-  #define  s_mp_setz(dp, count) \\\n-       {int ix;for(ix=0;ix<(count);ix++)(dp)[ix]=0;}\n- #else\n-  #define  s_mp_setz(dp, count) memset(dp, 0, (count) * sizeof(mp_digit))\n- #endif \/* MP_MEMSET *\/\n-\n- #if MP_MEMCPY == 0\n-  #define  s_mp_copy(sp, dp, count) \\\n-       {int ix;for(ix=0;ix<(count);ix++)(dp)[ix]=(sp)[ix];}\n- #else\n-  #define  s_mp_copy(sp, dp, count) memcpy(dp, sp, (count) * sizeof(mp_digit))\n- #endif \/* MP_MEMCPY *\/\n-\n- #define  s_mp_alloc(nb, ni)  calloc(nb, ni)\n- #define  s_mp_free(ptr) {if(ptr) free(ptr);}\n-#endif \/* MP_MACRO *\/\n-\n-mp_err   s_mp_grow(mp_int *mp, mp_size min);   \/* increase allocated size *\/\n-mp_err   s_mp_pad(mp_int *mp, mp_size min);    \/* left pad with zeroes    *\/\n-\n-#if MP_MACRO == 0\n- void     s_mp_clamp(mp_int *mp);               \/* clip leading zeroes     *\/\n-#else\n- #define  s_mp_clamp(mp)\\\n-  { mp_size used = MP_USED(mp); \\\n-    while (used > 1 && DIGIT(mp, used - 1) == 0) --used; \\\n-    MP_USED(mp) = used; \\\n-  }\n-#endif \/* MP_MACRO *\/\n-\n-void     s_mp_exch(mp_int *a, mp_int *b);      \/* swap a and b in place   *\/\n-\n-mp_err   s_mp_lshd(mp_int *mp, mp_size p);     \/* left-shift by p digits  *\/\n-void     s_mp_rshd(mp_int *mp, mp_size p);     \/* right-shift by p digits *\/\n-mp_err   s_mp_mul_2d(mp_int *mp, mp_digit d);  \/* multiply by 2^d in place *\/\n-void     s_mp_div_2d(mp_int *mp, mp_digit d);  \/* divide by 2^d in place  *\/\n-void     s_mp_mod_2d(mp_int *mp, mp_digit d);  \/* modulo 2^d in place     *\/\n-void     s_mp_div_2(mp_int *mp);               \/* divide by 2 in place    *\/\n-mp_err   s_mp_mul_2(mp_int *mp);               \/* multiply by 2 in place  *\/\n-mp_err   s_mp_norm(mp_int *a, mp_int *b, mp_digit *pd);\n-                                               \/* normalize for division  *\/\n-mp_err   s_mp_add_d(mp_int *mp, mp_digit d);   \/* unsigned digit addition *\/\n-mp_err   s_mp_sub_d(mp_int *mp, mp_digit d);   \/* unsigned digit subtract *\/\n-mp_err   s_mp_mul_d(mp_int *mp, mp_digit d);   \/* unsigned digit multiply *\/\n-mp_err   s_mp_div_d(mp_int *mp, mp_digit d, mp_digit *r);\n-                                               \/* unsigned digit divide   *\/\n-mp_err   s_mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu);\n-                                               \/* Barrett reduction       *\/\n-mp_err   s_mp_add(mp_int *a, const mp_int *b); \/* magnitude addition      *\/\n-mp_err   s_mp_add_3arg(const mp_int *a, const mp_int *b, mp_int *c);\n-mp_err   s_mp_sub(mp_int *a, const mp_int *b); \/* magnitude subtract      *\/\n-mp_err   s_mp_sub_3arg(const mp_int *a, const mp_int *b, mp_int *c);\n-mp_err   s_mp_add_offset(mp_int *a, mp_int *b, mp_size offset);\n-                                               \/* a += b * RADIX^offset   *\/\n-mp_err   s_mp_mul(mp_int *a, const mp_int *b); \/* magnitude multiply      *\/\n-#if MP_SQUARE\n-mp_err   s_mp_sqr(mp_int *a);                  \/* magnitude square        *\/\n-#else\n-#define  s_mp_sqr(a) s_mp_mul(a, a)\n-#endif\n-mp_err   s_mp_div(mp_int *rem, mp_int *div, mp_int *quot); \/* magnitude div *\/\n-mp_err   s_mp_exptmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c);\n-mp_err   s_mp_2expt(mp_int *a, mp_digit k);    \/* a = 2^k                 *\/\n-int      s_mp_cmp(const mp_int *a, const mp_int *b); \/* magnitude comparison *\/\n-int      s_mp_cmp_d(const mp_int *a, mp_digit d); \/* magnitude digit compare *\/\n-int      s_mp_ispow2(const mp_int *v);         \/* is v a power of 2?      *\/\n-int      s_mp_ispow2d(mp_digit d);             \/* is d a power of 2?      *\/\n-\n-int      s_mp_tovalue(char ch, int r);          \/* convert ch to value    *\/\n-char     s_mp_todigit(mp_digit val, int r, int low); \/* convert val to digit *\/\n-int      s_mp_outlen(int bits, int r);          \/* output length in bytes *\/\n-mp_digit s_mp_invmod_radix(mp_digit P);   \/* returns (P ** -1) mod RADIX *\/\n-mp_err   s_mp_invmod_odd_m( const mp_int *a, const mp_int *m, mp_int *c);\n-mp_err   s_mp_invmod_2d(    const mp_int *a, mp_size k,       mp_int *c);\n-mp_err   s_mp_invmod_even_m(const mp_int *a, const mp_int *m, mp_int *c);\n-\n-#ifdef NSS_USE_COMBA\n-\n-#define IS_POWER_OF_2(a) ((a) && !((a) & ((a)-1)))\n-\n-void s_mp_mul_comba_4(const mp_int *A, const mp_int *B, mp_int *C);\n-void s_mp_mul_comba_8(const mp_int *A, const mp_int *B, mp_int *C);\n-void s_mp_mul_comba_16(const mp_int *A, const mp_int *B, mp_int *C);\n-void s_mp_mul_comba_32(const mp_int *A, const mp_int *B, mp_int *C);\n-\n-void s_mp_sqr_comba_4(const mp_int *A, mp_int *B);\n-void s_mp_sqr_comba_8(const mp_int *A, mp_int *B);\n-void s_mp_sqr_comba_16(const mp_int *A, mp_int *B);\n-void s_mp_sqr_comba_32(const mp_int *A, mp_int *B);\n-\n-#endif \/* end NSS_USE_COMBA *\/\n-\n-\/* ------ mpv functions, operate on arrays of digits, not on mp_int's ------ *\/\n-#if defined (__OS2__) && defined (__IBMC__)\n-#define MPI_ASM_DECL __cdecl\n-#else\n-#define MPI_ASM_DECL\n-#endif\n-\n-#ifdef MPI_AMD64\n-\n-mp_digit MPI_ASM_DECL s_mpv_mul_set_vec64(mp_digit*, mp_digit *, mp_size, mp_digit);\n-mp_digit MPI_ASM_DECL s_mpv_mul_add_vec64(mp_digit*, const mp_digit*, mp_size, mp_digit);\n-\n-\/* c = a * b *\/\n-#define s_mpv_mul_d(a, a_len, b, c) \\\n-        ((unsigned long*)c)[a_len] = s_mpv_mul_set_vec64(c, a, a_len, b)\n-\n-\/* c += a * b *\/\n-#define s_mpv_mul_d_add(a, a_len, b, c) \\\n-        ((unsigned long*)c)[a_len] = s_mpv_mul_add_vec64(c, a, a_len, b)\n-\n-#else\n-\n-void     MPI_ASM_DECL s_mpv_mul_d(const mp_digit *a, mp_size a_len,\n-                                        mp_digit b, mp_digit *c);\n-void     MPI_ASM_DECL s_mpv_mul_d_add(const mp_digit *a, mp_size a_len,\n-                                            mp_digit b, mp_digit *c);\n-\n-#endif\n-\n-void     MPI_ASM_DECL s_mpv_mul_d_add_prop(const mp_digit *a,\n-                                                mp_size a_len, mp_digit b,\n-                                                mp_digit *c);\n-void     MPI_ASM_DECL s_mpv_sqr_add_prop(const mp_digit *a,\n-                                                mp_size a_len,\n-                                                mp_digit *sqrs);\n-\n-mp_err   MPI_ASM_DECL s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo,\n-                            mp_digit divisor, mp_digit *quot, mp_digit *rem);\n-\n-\/* c += a * b * (MP_RADIX ** offset);  *\/\n-#define s_mp_mul_d_add_offset(a, b, c, off) \\\n-(s_mpv_mul_d_add_prop(MP_DIGITS(a), MP_USED(a), b, MP_DIGITS(c) + off), MP_OKAY)\n-\n-typedef struct {\n-  mp_int       N;       \/* modulus N *\/\n-  mp_digit     n0prime; \/* n0' = - (n0 ** -1) mod MP_RADIX *\/\n-  mp_size      b;       \/* R == 2 ** b,  also b = # significant bits in N *\/\n-} mp_mont_modulus;\n-\n-mp_err s_mp_mul_mont(const mp_int *a, const mp_int *b, mp_int *c,\n-                       mp_mont_modulus *mmm);\n-mp_err s_mp_redc(mp_int *T, mp_mont_modulus *mmm);\n-\n-\/*\n- * s_mpi_getProcessorLineSize() returns the size in bytes of the cache line\n- * if a cache exists, or zero if there is no cache. If more than one\n- * cache line exists, it should return the smallest line size (which is\n- * usually the L1 cache).\n- *\n- * mp_modexp uses this information to make sure that private key information\n- * isn't being leaked through the cache.\n- *\n- * see mpcpucache.c for the implementation.\n- *\/\n-unsigned long s_mpi_getProcessorLineSize();\n-\n-\/* }}} *\/\n-#endif \/* _MPI_PRIV_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mpi-priv.h","additions":0,"deletions":320,"binary":false,"changes":320,"status":"deleted"},{"patch":"@@ -1,4871 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1998\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Netscape Communications Corporation\n- *   Douglas Stebila <douglas@stebila.ca> of Sun Laboratories.\n- *\n- * Last Modified Date from the Original Code: Nov 2019\n- *********************************************************************** *\/\n-\n-\/*  Arbitrary precision integer arithmetic library *\/\n-\n-#include \"mpi-priv.h\"\n-#if defined(OSF1)\n-#include <c_asm.h>\n-#endif\n-\n-#if MP_LOGTAB\n-\/*\n-  A table of the logs of 2 for various bases (the 0 and 1 entries of\n-  this table are meaningless and should not be referenced).\n-\n-  This table is used to compute output lengths for the mp_toradix()\n-  function.  Since a number n in radix r takes up about log_r(n)\n-  digits, we estimate the output size by taking the least integer\n-  greater than log_r(n), where:\n-\n-  log_r(n) = log_2(n) * log_r(2)\n-\n-  This table, therefore, is a table of log_r(2) for 2 <= r <= 36,\n-  which are the output bases supported.\n- *\/\n-#include \"logtab.h\"\n-#endif\n-\n-\/* {{{ Constant strings *\/\n-\n-\/* Constant strings returned by mp_strerror() *\/\n-static const char *mp_err_string[] = {\n-  \"unknown result code\",     \/* say what?            *\/\n-  \"boolean true\",            \/* MP_OKAY, MP_YES      *\/\n-  \"boolean false\",           \/* MP_NO                *\/\n-  \"out of memory\",           \/* MP_MEM               *\/\n-  \"argument out of range\",   \/* MP_RANGE             *\/\n-  \"invalid input parameter\", \/* MP_BADARG            *\/\n-  \"result is undefined\"      \/* MP_UNDEF             *\/\n-};\n-\n-\/* Value to digit maps for radix conversion   *\/\n-\n-\/* s_dmap_1 - standard digits and letters *\/\n-static const char *s_dmap_1 =\n-  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+\/\";\n-\n-\/* }}} *\/\n-\n-unsigned long mp_allocs;\n-unsigned long mp_frees;\n-unsigned long mp_copies;\n-\n-\/* {{{ Default precision manipulation *\/\n-\n-\/* Default precision for newly created mp_int's      *\/\n-static mp_size s_mp_defprec = MP_DEFPREC;\n-\n-mp_size mp_get_prec(void)\n-{\n-  return s_mp_defprec;\n-\n-} \/* end mp_get_prec() *\/\n-\n-void         mp_set_prec(mp_size prec)\n-{\n-  if(prec == 0)\n-    s_mp_defprec = MP_DEFPREC;\n-  else\n-    s_mp_defprec = prec;\n-\n-} \/* end mp_set_prec() *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ mp_init(mp, kmflag) *\/\n-\n-\/*\n-  mp_init(mp, kmflag)\n-\n-  Initialize a new zero-valued mp_int.  Returns MP_OKAY if successful,\n-  MP_MEM if memory could not be allocated for the structure.\n- *\/\n-\n-mp_err mp_init(mp_int *mp, int kmflag)\n-{\n-  return mp_init_size(mp, s_mp_defprec, kmflag);\n-\n-} \/* end mp_init() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_init_size(mp, prec, kmflag) *\/\n-\n-\/*\n-  mp_init_size(mp, prec, kmflag)\n-\n-  Initialize a new zero-valued mp_int with at least the given\n-  precision; returns MP_OKAY if successful, or MP_MEM if memory could\n-  not be allocated for the structure.\n- *\/\n-\n-mp_err mp_init_size(mp_int *mp, mp_size prec, int kmflag)\n-{\n-  ARGCHK(mp != NULL && prec > 0, MP_BADARG);\n-\n-  prec = MP_ROUNDUP(prec, s_mp_defprec);\n-  if((DIGITS(mp) = s_mp_alloc(prec, sizeof(mp_digit), kmflag)) == NULL)\n-    return MP_MEM;\n-\n-  SIGN(mp) = ZPOS;\n-  USED(mp) = 1;\n-  ALLOC(mp) = prec;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_init_size() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_init_copy(mp, from) *\/\n-\n-\/*\n-  mp_init_copy(mp, from)\n-\n-  Initialize mp as an exact copy of from.  Returns MP_OKAY if\n-  successful, MP_MEM if memory could not be allocated for the new\n-  structure.\n- *\/\n-\n-mp_err mp_init_copy(mp_int *mp, const mp_int *from)\n-{\n-  ARGCHK(mp != NULL && from != NULL, MP_BADARG);\n-\n-  if(mp == from)\n-    return MP_OKAY;\n-\n-  if((DIGITS(mp) = s_mp_alloc(ALLOC(from), sizeof(mp_digit), FLAG(from))) == NULL)\n-    return MP_MEM;\n-\n-  s_mp_copy(DIGITS(from), DIGITS(mp), USED(from));\n-  USED(mp) = USED(from);\n-  ALLOC(mp) = ALLOC(from);\n-  SIGN(mp) = SIGN(from);\n-\n-#ifndef _WIN32\n-  FLAG(mp) = FLAG(from);\n-#endif \/* _WIN32 *\/\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_init_copy() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_copy(from, to) *\/\n-\n-\/*\n-  mp_copy(from, to)\n-\n-  Copies the mp_int 'from' to the mp_int 'to'.  It is presumed that\n-  'to' has already been initialized (if not, use mp_init_copy()\n-  instead). If 'from' and 'to' are identical, nothing happens.\n- *\/\n-\n-mp_err mp_copy(const mp_int *from, mp_int *to)\n-{\n-  ARGCHK(from != NULL && to != NULL, MP_BADARG);\n-\n-  if(from == to)\n-    return MP_OKAY;\n-\n-  ++mp_copies;\n-  { \/* copy *\/\n-    mp_digit   *tmp;\n-\n-    \/*\n-      If the allocated buffer in 'to' already has enough space to hold\n-      all the used digits of 'from', we'll re-use it to avoid hitting\n-      the memory allocater more than necessary; otherwise, we'd have\n-      to grow anyway, so we just allocate a hunk and make the copy as\n-      usual\n-     *\/\n-    if(ALLOC(to) >= USED(from)) {\n-      s_mp_setz(DIGITS(to) + USED(from), ALLOC(to) - USED(from));\n-      s_mp_copy(DIGITS(from), DIGITS(to), USED(from));\n-\n-    } else {\n-      if((tmp = s_mp_alloc(ALLOC(from), sizeof(mp_digit), FLAG(from))) == NULL)\n-        return MP_MEM;\n-\n-      s_mp_copy(DIGITS(from), tmp, USED(from));\n-\n-      if(DIGITS(to) != NULL) {\n-#if MP_CRYPTO\n-        s_mp_setz(DIGITS(to), ALLOC(to));\n-#endif\n-        s_mp_free(DIGITS(to), ALLOC(to));\n-      }\n-\n-      DIGITS(to) = tmp;\n-      ALLOC(to) = ALLOC(from);\n-    }\n-\n-    \/* Copy the precision and sign from the original *\/\n-    USED(to) = USED(from);\n-    SIGN(to) = SIGN(from);\n-  } \/* end copy *\/\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_copy() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_exch(mp1, mp2) *\/\n-\n-\/*\n-  mp_exch(mp1, mp2)\n-\n-  Exchange mp1 and mp2 without allocating any intermediate memory\n-  (well, unless you count the stack space needed for this call and the\n-  locals it creates...).  This cannot fail.\n- *\/\n-\n-void mp_exch(mp_int *mp1, mp_int *mp2)\n-{\n-#if MP_ARGCHK == 2\n-  assert(mp1 != NULL && mp2 != NULL);\n-#else\n-  if(mp1 == NULL || mp2 == NULL)\n-    return;\n-#endif\n-\n-  s_mp_exch(mp1, mp2);\n-\n-} \/* end mp_exch() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_clear(mp) *\/\n-\n-\/*\n-  mp_clear(mp)\n-\n-  Release the storage used by an mp_int, and void its fields so that\n-  if someone calls mp_clear() again for the same int later, we won't\n-  get tollchocked.\n- *\/\n-\n-void   mp_clear(mp_int *mp)\n-{\n-  if(mp == NULL)\n-    return;\n-\n-  if(DIGITS(mp) != NULL) {\n-#if MP_CRYPTO\n-    s_mp_setz(DIGITS(mp), ALLOC(mp));\n-#endif\n-    s_mp_free(DIGITS(mp), ALLOC(mp));\n-    DIGITS(mp) = NULL;\n-  }\n-\n-  USED(mp) = 0;\n-  ALLOC(mp) = 0;\n-\n-} \/* end mp_clear() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_zero(mp) *\/\n-\n-\/*\n-  mp_zero(mp)\n-\n-  Set mp to zero.  Does not change the allocated size of the structure,\n-  and therefore cannot fail (except on a bad argument, which we ignore)\n- *\/\n-void   mp_zero(mp_int *mp)\n-{\n-  if(mp == NULL)\n-    return;\n-\n-  s_mp_setz(DIGITS(mp), ALLOC(mp));\n-  USED(mp) = 1;\n-  SIGN(mp) = ZPOS;\n-\n-} \/* end mp_zero() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_set(mp, d) *\/\n-\n-void   mp_set(mp_int *mp, mp_digit d)\n-{\n-  if(mp == NULL)\n-    return;\n-\n-  mp_zero(mp);\n-  DIGIT(mp, 0) = d;\n-\n-} \/* end mp_set() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_set_int(mp, z) *\/\n-\n-mp_err mp_set_int(mp_int *mp, long z)\n-{\n-  int            ix;\n-  unsigned long  v = labs(z);\n-  mp_err         res;\n-\n-  ARGCHK(mp != NULL, MP_BADARG);\n-\n-  mp_zero(mp);\n-  if(z == 0)\n-    return MP_OKAY;  \/* shortcut for zero *\/\n-\n-  if (sizeof v <= sizeof(mp_digit)) {\n-    DIGIT(mp,0) = v;\n-  } else {\n-    for (ix = sizeof(long) - 1; ix >= 0; ix--) {\n-      if ((res = s_mp_mul_d(mp, (UCHAR_MAX + 1))) != MP_OKAY)\n-        return res;\n-\n-      res = s_mp_add_d(mp, (mp_digit)((v >> (ix * CHAR_BIT)) & UCHAR_MAX));\n-      if (res != MP_OKAY)\n-        return res;\n-    }\n-  }\n-  if(z < 0)\n-    SIGN(mp) = NEG;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_set_int() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_set_ulong(mp, z) *\/\n-\n-mp_err mp_set_ulong(mp_int *mp, unsigned long z)\n-{\n-  int            ix;\n-  mp_err         res;\n-\n-  ARGCHK(mp != NULL, MP_BADARG);\n-\n-  mp_zero(mp);\n-  if(z == 0)\n-    return MP_OKAY;  \/* shortcut for zero *\/\n-\n-  if (sizeof z <= sizeof(mp_digit)) {\n-    DIGIT(mp,0) = z;\n-  } else {\n-    for (ix = sizeof(long) - 1; ix >= 0; ix--) {\n-      if ((res = s_mp_mul_d(mp, (UCHAR_MAX + 1))) != MP_OKAY)\n-        return res;\n-\n-      res = s_mp_add_d(mp, (mp_digit)((z >> (ix * CHAR_BIT)) & UCHAR_MAX));\n-      if (res != MP_OKAY)\n-        return res;\n-    }\n-  }\n-  return MP_OKAY;\n-} \/* end mp_set_ulong() *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ Digit arithmetic *\/\n-\n-\/* {{{ mp_add_d(a, d, b) *\/\n-\n-\/*\n-  mp_add_d(a, d, b)\n-\n-  Compute the sum b = a + d, for a single digit d.  Respects the sign of\n-  its primary addend (single digits are unsigned anyway).\n- *\/\n-\n-mp_err mp_add_d(const mp_int *a, mp_digit d, mp_int *b)\n-{\n-  mp_int   tmp;\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if((res = mp_init_copy(&tmp, a)) != MP_OKAY)\n-    return res;\n-\n-  if(SIGN(&tmp) == ZPOS) {\n-    if((res = s_mp_add_d(&tmp, d)) != MP_OKAY)\n-      goto CLEANUP;\n-  } else if(s_mp_cmp_d(&tmp, d) >= 0) {\n-    if((res = s_mp_sub_d(&tmp, d)) != MP_OKAY)\n-      goto CLEANUP;\n-  } else {\n-    mp_neg(&tmp, &tmp);\n-\n-    DIGIT(&tmp, 0) = d - DIGIT(&tmp, 0);\n-  }\n-\n-  if(s_mp_cmp_d(&tmp, 0) == 0)\n-    SIGN(&tmp) = ZPOS;\n-\n-  s_mp_exch(&tmp, b);\n-\n-CLEANUP:\n-  mp_clear(&tmp);\n-  return res;\n-\n-} \/* end mp_add_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_sub_d(a, d, b) *\/\n-\n-\/*\n-  mp_sub_d(a, d, b)\n-\n-  Compute the difference b = a - d, for a single digit d.  Respects the\n-  sign of its subtrahend (single digits are unsigned anyway).\n- *\/\n-\n-mp_err mp_sub_d(const mp_int *a, mp_digit d, mp_int *b)\n-{\n-  mp_int   tmp;\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if((res = mp_init_copy(&tmp, a)) != MP_OKAY)\n-    return res;\n-\n-  if(SIGN(&tmp) == NEG) {\n-    if((res = s_mp_add_d(&tmp, d)) != MP_OKAY)\n-      goto CLEANUP;\n-  } else if(s_mp_cmp_d(&tmp, d) >= 0) {\n-    if((res = s_mp_sub_d(&tmp, d)) != MP_OKAY)\n-      goto CLEANUP;\n-  } else {\n-    mp_neg(&tmp, &tmp);\n-\n-    DIGIT(&tmp, 0) = d - DIGIT(&tmp, 0);\n-    SIGN(&tmp) = NEG;\n-  }\n-\n-  if(s_mp_cmp_d(&tmp, 0) == 0)\n-    SIGN(&tmp) = ZPOS;\n-\n-  s_mp_exch(&tmp, b);\n-\n-CLEANUP:\n-  mp_clear(&tmp);\n-  return res;\n-\n-} \/* end mp_sub_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_mul_d(a, d, b) *\/\n-\n-\/*\n-  mp_mul_d(a, d, b)\n-\n-  Compute the product b = a * d, for a single digit d.  Respects the sign\n-  of its multiplicand (single digits are unsigned anyway)\n- *\/\n-\n-mp_err mp_mul_d(const mp_int *a, mp_digit d, mp_int *b)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if(d == 0) {\n-    mp_zero(b);\n-    return MP_OKAY;\n-  }\n-\n-  if((res = mp_copy(a, b)) != MP_OKAY)\n-    return res;\n-\n-  res = s_mp_mul_d(b, d);\n-\n-  return res;\n-\n-} \/* end mp_mul_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_mul_2(a, c) *\/\n-\n-mp_err mp_mul_2(const mp_int *a, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_copy(a, c)) != MP_OKAY)\n-    return res;\n-\n-  return s_mp_mul_2(c);\n-\n-} \/* end mp_mul_2() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_div_d(a, d, q, r) *\/\n-\n-\/*\n-  mp_div_d(a, d, q, r)\n-\n-  Compute the quotient q = a \/ d and remainder r = a mod d, for a\n-  single digit d.  Respects the sign of its divisor (single digits are\n-  unsigned anyway).\n- *\/\n-\n-mp_err mp_div_d(const mp_int *a, mp_digit d, mp_int *q, mp_digit *r)\n-{\n-  mp_err   res;\n-  mp_int   qp;\n-  mp_digit rem;\n-  int      pow;\n-\n-  ARGCHK(a != NULL, MP_BADARG);\n-\n-  if(d == 0)\n-    return MP_RANGE;\n-\n-  \/* Shortcut for powers of two ... *\/\n-  if((pow = s_mp_ispow2d(d)) >= 0) {\n-    mp_digit  mask;\n-\n-    mask = ((mp_digit)1 << pow) - 1;\n-    rem = DIGIT(a, 0) & mask;\n-\n-    if(q) {\n-      mp_copy(a, q);\n-      s_mp_div_2d(q, pow);\n-    }\n-\n-    if(r)\n-      *r = rem;\n-\n-    return MP_OKAY;\n-  }\n-\n-  if((res = mp_init_copy(&qp, a)) != MP_OKAY)\n-    return res;\n-\n-  res = s_mp_div_d(&qp, d, &rem);\n-\n-  if(s_mp_cmp_d(&qp, 0) == 0)\n-    SIGN(q) = ZPOS;\n-\n-  if(r)\n-    *r = rem;\n-\n-  if(q)\n-    s_mp_exch(&qp, q);\n-\n-  mp_clear(&qp);\n-  return res;\n-\n-} \/* end mp_div_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_div_2(a, c) *\/\n-\n-\/*\n-  mp_div_2(a, c)\n-\n-  Compute c = a \/ 2, disregarding the remainder.\n- *\/\n-\n-mp_err mp_div_2(const mp_int *a, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_copy(a, c)) != MP_OKAY)\n-    return res;\n-\n-  s_mp_div_2(c);\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_div_2() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_expt_d(a, d, b) *\/\n-\n-mp_err mp_expt_d(const mp_int *a, mp_digit d, mp_int *c)\n-{\n-  mp_int   s, x;\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_init(&s, FLAG(a))) != MP_OKAY)\n-    return res;\n-  if((res = mp_init_copy(&x, a)) != MP_OKAY)\n-    goto X;\n-\n-  DIGIT(&s, 0) = 1;\n-\n-  while(d != 0) {\n-    if(d & 1) {\n-      if((res = s_mp_mul(&s, &x)) != MP_OKAY)\n-        goto CLEANUP;\n-    }\n-\n-    d \/= 2;\n-\n-    if((res = s_mp_sqr(&x)) != MP_OKAY)\n-      goto CLEANUP;\n-  }\n-\n-  s.flag = (mp_sign)0;\n-  s_mp_exch(&s, c);\n-\n-CLEANUP:\n-  mp_clear(&x);\n-X:\n-  mp_clear(&s);\n-\n-  return res;\n-\n-} \/* end mp_expt_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ Full arithmetic *\/\n-\n-\/* {{{ mp_abs(a, b) *\/\n-\n-\/*\n-  mp_abs(a, b)\n-\n-  Compute b = |a|.  'a' and 'b' may be identical.\n- *\/\n-\n-mp_err mp_abs(const mp_int *a, mp_int *b)\n-{\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if((res = mp_copy(a, b)) != MP_OKAY)\n-    return res;\n-\n-  SIGN(b) = ZPOS;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_abs() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_neg(a, b) *\/\n-\n-\/*\n-  mp_neg(a, b)\n-\n-  Compute b = -a.  'a' and 'b' may be identical.\n- *\/\n-\n-mp_err mp_neg(const mp_int *a, mp_int *b)\n-{\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if((res = mp_copy(a, b)) != MP_OKAY)\n-    return res;\n-\n-  if(s_mp_cmp_d(b, 0) == MP_EQ)\n-    SIGN(b) = ZPOS;\n-  else\n-    SIGN(b) = (SIGN(b) == NEG) ? ZPOS : NEG;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_neg() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_add(a, b, c) *\/\n-\n-\/*\n-  mp_add(a, b, c)\n-\n-  Compute c = a + b.  All parameters may be identical.\n- *\/\n-\n-mp_err mp_add(const mp_int *a, const mp_int *b, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if(SIGN(a) == SIGN(b)) { \/* same sign:  add values, keep sign *\/\n-    MP_CHECKOK( s_mp_add_3arg(a, b, c) );\n-  } else if(s_mp_cmp(a, b) >= 0) {  \/* different sign: |a| >= |b|   *\/\n-    MP_CHECKOK( s_mp_sub_3arg(a, b, c) );\n-  } else {                          \/* different sign: |a|  < |b|   *\/\n-    MP_CHECKOK( s_mp_sub_3arg(b, a, c) );\n-  }\n-\n-  if (s_mp_cmp_d(c, 0) == MP_EQ)\n-    SIGN(c) = ZPOS;\n-\n-CLEANUP:\n-  return res;\n-\n-} \/* end mp_add() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_sub(a, b, c) *\/\n-\n-\/*\n-  mp_sub(a, b, c)\n-\n-  Compute c = a - b.  All parameters may be identical.\n- *\/\n-\n-mp_err mp_sub(const mp_int *a, const mp_int *b, mp_int *c)\n-{\n-  mp_err  res;\n-  int     magDiff;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if (a == b) {\n-    mp_zero(c);\n-    return MP_OKAY;\n-  }\n-\n-  if (MP_SIGN(a) != MP_SIGN(b)) {\n-    MP_CHECKOK( s_mp_add_3arg(a, b, c) );\n-  } else if (!(magDiff = s_mp_cmp(a, b))) {\n-    mp_zero(c);\n-    res = MP_OKAY;\n-  } else if (magDiff > 0) {\n-    MP_CHECKOK( s_mp_sub_3arg(a, b, c) );\n-  } else {\n-    MP_CHECKOK( s_mp_sub_3arg(b, a, c) );\n-    MP_SIGN(c) = !MP_SIGN(a);\n-  }\n-\n-  if (s_mp_cmp_d(c, 0) == MP_EQ)\n-    MP_SIGN(c) = MP_ZPOS;\n-\n-CLEANUP:\n-  return res;\n-\n-} \/* end mp_sub() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_mul(a, b, c) *\/\n-\n-\/*\n-  mp_mul(a, b, c)\n-\n-  Compute c = a * b.  All parameters may be identical.\n- *\/\n-mp_err   mp_mul(const mp_int *a, const mp_int *b, mp_int * c)\n-{\n-  mp_digit *pb;\n-  mp_int   tmp;\n-  mp_err   res;\n-  mp_size  ib;\n-  mp_size  useda, usedb;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if (a == c) {\n-    if ((res = mp_init_copy(&tmp, a)) != MP_OKAY)\n-      return res;\n-    if (a == b)\n-      b = &tmp;\n-    a = &tmp;\n-  } else if (b == c) {\n-    if ((res = mp_init_copy(&tmp, b)) != MP_OKAY)\n-      return res;\n-    b = &tmp;\n-  } else {\n-    MP_DIGITS(&tmp) = 0;\n-  }\n-\n-  if (MP_USED(a) < MP_USED(b)) {\n-    const mp_int *xch = b;      \/* switch a and b, to do fewer outer loops *\/\n-    b = a;\n-    a = xch;\n-  }\n-\n-  MP_USED(c) = 1; MP_DIGIT(c, 0) = 0;\n-  if((res = s_mp_pad(c, USED(a) + USED(b))) != MP_OKAY)\n-    goto CLEANUP;\n-\n-#ifdef NSS_USE_COMBA\n-  if ((MP_USED(a) == MP_USED(b)) && IS_POWER_OF_2(MP_USED(b))) {\n-      if (MP_USED(a) == 4) {\n-          s_mp_mul_comba_4(a, b, c);\n-          goto CLEANUP;\n-      }\n-      if (MP_USED(a) == 8) {\n-          s_mp_mul_comba_8(a, b, c);\n-          goto CLEANUP;\n-      }\n-      if (MP_USED(a) == 16) {\n-          s_mp_mul_comba_16(a, b, c);\n-          goto CLEANUP;\n-      }\n-      if (MP_USED(a) == 32) {\n-          s_mp_mul_comba_32(a, b, c);\n-          goto CLEANUP;\n-      }\n-  }\n-#endif\n-\n-  pb = MP_DIGITS(b);\n-  s_mpv_mul_d(MP_DIGITS(a), MP_USED(a), *pb++, MP_DIGITS(c));\n-\n-  \/* Outer loop:  Digits of b *\/\n-  useda = MP_USED(a);\n-  usedb = MP_USED(b);\n-  for (ib = 1; ib < usedb; ib++) {\n-    mp_digit b_i    = *pb++;\n-\n-    \/* Inner product:  Digits of a *\/\n-    if (b_i)\n-      s_mpv_mul_d_add(MP_DIGITS(a), useda, b_i, MP_DIGITS(c) + ib);\n-    else\n-      MP_DIGIT(c, ib + useda) = b_i;\n-  }\n-\n-  s_mp_clamp(c);\n-\n-  if(SIGN(a) == SIGN(b) || s_mp_cmp_d(c, 0) == MP_EQ)\n-    SIGN(c) = ZPOS;\n-  else\n-    SIGN(c) = NEG;\n-\n-CLEANUP:\n-  mp_clear(&tmp);\n-  return res;\n-} \/* end mp_mul() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_sqr(a, sqr) *\/\n-\n-#if MP_SQUARE\n-\/*\n-  Computes the square of a.  This can be done more\n-  efficiently than a general multiplication, because many of the\n-  computation steps are redundant when squaring.  The inner product\n-  step is a bit more complicated, but we save a fair number of\n-  iterations of the multiplication loop.\n- *\/\n-\n-\/* sqr = a^2;   Caller provides both a and tmp; *\/\n-mp_err   mp_sqr(const mp_int *a, mp_int *sqr)\n-{\n-  mp_digit *pa;\n-  mp_digit d;\n-  mp_err   res;\n-  mp_size  ix;\n-  mp_int   tmp;\n-  int      count;\n-\n-  ARGCHK(a != NULL && sqr != NULL, MP_BADARG);\n-\n-  if (a == sqr) {\n-    if((res = mp_init_copy(&tmp, a)) != MP_OKAY)\n-      return res;\n-    a = &tmp;\n-  } else {\n-    DIGITS(&tmp) = 0;\n-    res = MP_OKAY;\n-  }\n-\n-  ix = 2 * MP_USED(a);\n-  if (ix > MP_ALLOC(sqr)) {\n-    MP_USED(sqr) = 1;\n-    MP_CHECKOK( s_mp_grow(sqr, ix) );\n-  }\n-  MP_USED(sqr) = ix;\n-  MP_DIGIT(sqr, 0) = 0;\n-\n-#ifdef NSS_USE_COMBA\n-  if (IS_POWER_OF_2(MP_USED(a))) {\n-      if (MP_USED(a) == 4) {\n-          s_mp_sqr_comba_4(a, sqr);\n-          goto CLEANUP;\n-      }\n-      if (MP_USED(a) == 8) {\n-          s_mp_sqr_comba_8(a, sqr);\n-          goto CLEANUP;\n-      }\n-      if (MP_USED(a) == 16) {\n-          s_mp_sqr_comba_16(a, sqr);\n-          goto CLEANUP;\n-      }\n-      if (MP_USED(a) == 32) {\n-          s_mp_sqr_comba_32(a, sqr);\n-          goto CLEANUP;\n-      }\n-  }\n-#endif\n-\n-  pa = MP_DIGITS(a);\n-  count = MP_USED(a) - 1;\n-  if (count > 0) {\n-    d = *pa++;\n-    s_mpv_mul_d(pa, count, d, MP_DIGITS(sqr) + 1);\n-    for (ix = 3; --count > 0; ix += 2) {\n-      d = *pa++;\n-      s_mpv_mul_d_add(pa, count, d, MP_DIGITS(sqr) + ix);\n-    } \/* for(ix ...) *\/\n-    MP_DIGIT(sqr, MP_USED(sqr)-1) = 0; \/* above loop stopped short of this. *\/\n-\n-    \/* now sqr *= 2 *\/\n-    s_mp_mul_2(sqr);\n-  } else {\n-    MP_DIGIT(sqr, 1) = 0;\n-  }\n-\n-  \/* now add the squares of the digits of a to sqr. *\/\n-  s_mpv_sqr_add_prop(MP_DIGITS(a), MP_USED(a), MP_DIGITS(sqr));\n-\n-  SIGN(sqr) = ZPOS;\n-  s_mp_clamp(sqr);\n-\n-CLEANUP:\n-  mp_clear(&tmp);\n-  return res;\n-\n-} \/* end mp_sqr() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_div(a, b, q, r) *\/\n-\n-\/*\n-  mp_div(a, b, q, r)\n-\n-  Compute q = a \/ b and r = a mod b.  Input parameters may be re-used\n-  as output parameters.  If q or r is NULL, that portion of the\n-  computation will be discarded (although it will still be computed)\n- *\/\n-mp_err mp_div(const mp_int *a, const mp_int *b, mp_int *q, mp_int *r)\n-{\n-  mp_err   res;\n-  mp_int   *pQ, *pR;\n-  mp_int   qtmp, rtmp, btmp;\n-  int      cmp;\n-  mp_sign  signA;\n-  mp_sign  signB;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  signA = MP_SIGN(a);\n-  signB = MP_SIGN(b);\n-\n-  if(mp_cmp_z(b) == MP_EQ)\n-    return MP_RANGE;\n-\n-  DIGITS(&qtmp) = 0;\n-  DIGITS(&rtmp) = 0;\n-  DIGITS(&btmp) = 0;\n-\n-  \/* Set up some temporaries... *\/\n-  if (!r || r == a || r == b) {\n-    MP_CHECKOK( mp_init_copy(&rtmp, a) );\n-    pR = &rtmp;\n-  } else {\n-    MP_CHECKOK( mp_copy(a, r) );\n-    pR = r;\n-  }\n-\n-  if (!q || q == a || q == b) {\n-    MP_CHECKOK( mp_init_size(&qtmp, MP_USED(a), FLAG(a)) );\n-    pQ = &qtmp;\n-  } else {\n-    MP_CHECKOK( s_mp_pad(q, MP_USED(a)) );\n-    pQ = q;\n-    mp_zero(pQ);\n-  }\n-\n-  \/*\n-    If |a| <= |b|, we can compute the solution without division;\n-    otherwise, we actually do the work required.\n-   *\/\n-  if ((cmp = s_mp_cmp(a, b)) <= 0) {\n-    if (cmp) {\n-      \/* r was set to a above. *\/\n-      mp_zero(pQ);\n-    } else {\n-      mp_set(pQ, 1);\n-      mp_zero(pR);\n-    }\n-  } else {\n-    MP_CHECKOK( mp_init_copy(&btmp, b) );\n-    MP_CHECKOK( s_mp_div(pR, &btmp, pQ) );\n-  }\n-\n-  \/* Compute the signs for the output  *\/\n-  MP_SIGN(pR) = signA;   \/* Sr = Sa              *\/\n-  \/* Sq = ZPOS if Sa == Sb *\/ \/* Sq = NEG if Sa != Sb *\/\n-  MP_SIGN(pQ) = (signA == signB) ? ZPOS : NEG;\n-\n-  if(s_mp_cmp_d(pQ, 0) == MP_EQ)\n-    SIGN(pQ) = ZPOS;\n-  if(s_mp_cmp_d(pR, 0) == MP_EQ)\n-    SIGN(pR) = ZPOS;\n-\n-  \/* Copy output, if it is needed      *\/\n-  if(q && q != pQ)\n-    s_mp_exch(pQ, q);\n-\n-  if(r && r != pR)\n-    s_mp_exch(pR, r);\n-\n-CLEANUP:\n-  mp_clear(&btmp);\n-  mp_clear(&rtmp);\n-  mp_clear(&qtmp);\n-\n-  return res;\n-\n-} \/* end mp_div() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_div_2d(a, d, q, r) *\/\n-\n-mp_err mp_div_2d(const mp_int *a, mp_digit d, mp_int *q, mp_int *r)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL, MP_BADARG);\n-\n-  if(q) {\n-    if((res = mp_copy(a, q)) != MP_OKAY)\n-      return res;\n-  }\n-  if(r) {\n-    if((res = mp_copy(a, r)) != MP_OKAY)\n-      return res;\n-  }\n-  if(q) {\n-    s_mp_div_2d(q, d);\n-  }\n-  if(r) {\n-    s_mp_mod_2d(r, d);\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_div_2d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_expt(a, b, c) *\/\n-\n-\/*\n-  mp_expt(a, b, c)\n-\n-  Compute c = a ** b, that is, raise a to the b power.  Uses a\n-  standard iterative square-and-multiply technique.\n- *\/\n-\n-mp_err mp_expt(mp_int *a, mp_int *b, mp_int *c)\n-{\n-  mp_int   s, x;\n-  mp_err   res;\n-  mp_digit d;\n-  unsigned int      dig, bit;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if(mp_cmp_z(b) < 0)\n-    return MP_RANGE;\n-\n-  if((res = mp_init(&s, FLAG(a))) != MP_OKAY)\n-    return res;\n-\n-  mp_set(&s, 1);\n-\n-  if((res = mp_init_copy(&x, a)) != MP_OKAY)\n-    goto X;\n-\n-  \/* Loop over low-order digits in ascending order *\/\n-  for(dig = 0; dig < (USED(b) - 1); dig++) {\n-    d = DIGIT(b, dig);\n-\n-    \/* Loop over bits of each non-maximal digit *\/\n-    for(bit = 0; bit < DIGIT_BIT; bit++) {\n-      if(d & 1) {\n-        if((res = s_mp_mul(&s, &x)) != MP_OKAY)\n-          goto CLEANUP;\n-      }\n-\n-      d >>= 1;\n-\n-      if((res = s_mp_sqr(&x)) != MP_OKAY)\n-        goto CLEANUP;\n-    }\n-  }\n-\n-  \/* Consider now the last digit... *\/\n-  d = DIGIT(b, dig);\n-\n-  while(d) {\n-    if(d & 1) {\n-      if((res = s_mp_mul(&s, &x)) != MP_OKAY)\n-        goto CLEANUP;\n-    }\n-\n-    d >>= 1;\n-\n-    if((res = s_mp_sqr(&x)) != MP_OKAY)\n-      goto CLEANUP;\n-  }\n-\n-  if(mp_iseven(b))\n-    SIGN(&s) = SIGN(a);\n-\n-  res = mp_copy(&s, c);\n-\n-CLEANUP:\n-  mp_clear(&x);\n-X:\n-  mp_clear(&s);\n-\n-  return res;\n-\n-} \/* end mp_expt() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_2expt(a, k) *\/\n-\n-\/* Compute a = 2^k *\/\n-\n-mp_err mp_2expt(mp_int *a, mp_digit k)\n-{\n-  ARGCHK(a != NULL, MP_BADARG);\n-\n-  return s_mp_2expt(a, k);\n-\n-} \/* end mp_2expt() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_mod(a, m, c) *\/\n-\n-\/*\n-  mp_mod(a, m, c)\n-\n-  Compute c = a (mod m).  Result will always be 0 <= c < m.\n- *\/\n-\n-mp_err mp_mod(const mp_int *a, const mp_int *m, mp_int *c)\n-{\n-  mp_err  res;\n-  int     mag;\n-\n-  ARGCHK(a != NULL && m != NULL && c != NULL, MP_BADARG);\n-\n-  if(SIGN(m) == NEG)\n-    return MP_RANGE;\n-\n-  \/*\n-     If |a| > m, we need to divide to get the remainder and take the\n-     absolute value.\n-\n-     If |a| < m, we don't need to do any division, just copy and adjust\n-     the sign (if a is negative).\n-\n-     If |a| == m, we can simply set the result to zero.\n-\n-     This order is intended to minimize the average path length of the\n-     comparison chain on common workloads -- the most frequent cases are\n-     that |a| != m, so we do those first.\n-   *\/\n-  if((mag = s_mp_cmp(a, m)) > 0) {\n-    if((res = mp_div(a, m, NULL, c)) != MP_OKAY)\n-      return res;\n-\n-    if(SIGN(c) == NEG) {\n-      if((res = mp_add(c, m, c)) != MP_OKAY)\n-        return res;\n-    }\n-\n-  } else if(mag < 0) {\n-    if((res = mp_copy(a, c)) != MP_OKAY)\n-      return res;\n-\n-    if(mp_cmp_z(a) < 0) {\n-      if((res = mp_add(c, m, c)) != MP_OKAY)\n-        return res;\n-\n-    }\n-\n-  } else {\n-    mp_zero(c);\n-\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_mod() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_mod_d(a, d, c) *\/\n-\n-\/*\n-  mp_mod_d(a, d, c)\n-\n-  Compute c = a (mod d).  Result will always be 0 <= c < d\n- *\/\n-mp_err mp_mod_d(const mp_int *a, mp_digit d, mp_digit *c)\n-{\n-  mp_err   res;\n-  mp_digit rem;\n-\n-  ARGCHK(a != NULL && c != NULL, MP_BADARG);\n-\n-  if(s_mp_cmp_d(a, d) > 0) {\n-    if((res = mp_div_d(a, d, NULL, &rem)) != MP_OKAY)\n-      return res;\n-\n-  } else {\n-    if(SIGN(a) == NEG)\n-      rem = d - DIGIT(a, 0);\n-    else\n-      rem = DIGIT(a, 0);\n-  }\n-\n-  if(c)\n-    *c = rem;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_mod_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_sqrt(a, b) *\/\n-\n-\/*\n-  mp_sqrt(a, b)\n-\n-  Compute the integer square root of a, and store the result in b.\n-  Uses an integer-arithmetic version of Newton's iterative linear\n-  approximation technique to determine this value; the result has the\n-  following two properties:\n-\n-     b^2 <= a\n-     (b+1)^2 >= a\n-\n-  It is a range error to pass a negative value.\n- *\/\n-mp_err mp_sqrt(const mp_int *a, mp_int *b)\n-{\n-  mp_int   x, t;\n-  mp_err   res;\n-  mp_size  used;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  \/* Cannot take square root of a negative value *\/\n-  if(SIGN(a) == NEG)\n-    return MP_RANGE;\n-\n-  \/* Special cases for zero and one, trivial     *\/\n-  if(mp_cmp_d(a, 1) <= 0)\n-    return mp_copy(a, b);\n-\n-  \/* Initialize the temporaries we'll use below  *\/\n-  if((res = mp_init_size(&t, USED(a), FLAG(a))) != MP_OKAY)\n-    return res;\n-\n-  \/* Compute an initial guess for the iteration as a itself *\/\n-  if((res = mp_init_copy(&x, a)) != MP_OKAY)\n-    goto X;\n-\n-  used = MP_USED(&x);\n-  if (used > 1) {\n-    s_mp_rshd(&x, used \/ 2);\n-  }\n-\n-  for(;;) {\n-    \/* t = (x * x) - a *\/\n-    mp_copy(&x, &t);      \/* can't fail, t is big enough for original x *\/\n-    if((res = mp_sqr(&t, &t)) != MP_OKAY ||\n-       (res = mp_sub(&t, a, &t)) != MP_OKAY)\n-      goto CLEANUP;\n-\n-    \/* t = t \/ 2x       *\/\n-    s_mp_mul_2(&x);\n-    if((res = mp_div(&t, &x, &t, NULL)) != MP_OKAY)\n-      goto CLEANUP;\n-    s_mp_div_2(&x);\n-\n-    \/* Terminate the loop, if the quotient is zero *\/\n-    if(mp_cmp_z(&t) == MP_EQ)\n-      break;\n-\n-    \/* x = x - t       *\/\n-    if((res = mp_sub(&x, &t, &x)) != MP_OKAY)\n-      goto CLEANUP;\n-\n-  }\n-\n-  \/* Copy result to output parameter *\/\n-  mp_sub_d(&x, 1, &x);\n-  s_mp_exch(&x, b);\n-\n- CLEANUP:\n-  mp_clear(&x);\n- X:\n-  mp_clear(&t);\n-\n-  return res;\n-\n-} \/* end mp_sqrt() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ Modular arithmetic *\/\n-\n-#if MP_MODARITH\n-\/* {{{ mp_addmod(a, b, m, c) *\/\n-\n-\/*\n-  mp_addmod(a, b, m, c)\n-\n-  Compute c = (a + b) mod m\n- *\/\n-\n-mp_err mp_addmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_add(a, b, c)) != MP_OKAY)\n-    return res;\n-  if((res = mp_mod(c, m, c)) != MP_OKAY)\n-    return res;\n-\n-  return MP_OKAY;\n-\n-}\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_submod(a, b, m, c) *\/\n-\n-\/*\n-  mp_submod(a, b, m, c)\n-\n-  Compute c = (a - b) mod m\n- *\/\n-\n-mp_err mp_submod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_sub(a, b, c)) != MP_OKAY)\n-    return res;\n-  if((res = mp_mod(c, m, c)) != MP_OKAY)\n-    return res;\n-\n-  return MP_OKAY;\n-\n-}\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_mulmod(a, b, m, c) *\/\n-\n-\/*\n-  mp_mulmod(a, b, m, c)\n-\n-  Compute c = (a * b) mod m\n- *\/\n-\n-mp_err mp_mulmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && b != NULL && m != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_mul(a, b, c)) != MP_OKAY)\n-    return res;\n-  if((res = mp_mod(c, m, c)) != MP_OKAY)\n-    return res;\n-\n-  return MP_OKAY;\n-\n-}\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_sqrmod(a, m, c) *\/\n-\n-#if MP_SQUARE\n-mp_err mp_sqrmod(const mp_int *a, const mp_int *m, mp_int *c)\n-{\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && m != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_sqr(a, c)) != MP_OKAY)\n-    return res;\n-  if((res = mp_mod(c, m, c)) != MP_OKAY)\n-    return res;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_sqrmod() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_exptmod(a, b, m, c) *\/\n-\n-\/*\n-  s_mp_exptmod(a, b, m, c)\n-\n-  Compute c = (a ** b) mod m.  Uses a standard square-and-multiply\n-  method with modular reductions at each step. (This is basically the\n-  same code as mp_expt(), except for the addition of the reductions)\n-\n-  The modular reductions are done using Barrett's algorithm (see\n-  s_mp_reduce() below for details)\n- *\/\n-\n-mp_err s_mp_exptmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c)\n-{\n-  mp_int   s, x, mu;\n-  mp_err   res;\n-  mp_digit d;\n-  unsigned int      dig, bit;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if(mp_cmp_z(b) < 0 || mp_cmp_z(m) <= 0)\n-    return MP_RANGE;\n-\n-  if((res = mp_init(&s, FLAG(a))) != MP_OKAY)\n-    return res;\n-  if((res = mp_init_copy(&x, a)) != MP_OKAY ||\n-     (res = mp_mod(&x, m, &x)) != MP_OKAY)\n-    goto X;\n-  if((res = mp_init(&mu, FLAG(a))) != MP_OKAY)\n-    goto MU;\n-\n-  mp_set(&s, 1);\n-\n-  \/* mu = b^2k \/ m *\/\n-  s_mp_add_d(&mu, 1);\n-  s_mp_lshd(&mu, 2 * USED(m));\n-  if((res = mp_div(&mu, m, &mu, NULL)) != MP_OKAY)\n-    goto CLEANUP;\n-\n-  \/* Loop over digits of b in ascending order, except highest order *\/\n-  for(dig = 0; dig < (USED(b) - 1); dig++) {\n-    d = DIGIT(b, dig);\n-\n-    \/* Loop over the bits of the lower-order digits *\/\n-    for(bit = 0; bit < DIGIT_BIT; bit++) {\n-      if(d & 1) {\n-        if((res = s_mp_mul(&s, &x)) != MP_OKAY)\n-          goto CLEANUP;\n-        if((res = s_mp_reduce(&s, m, &mu)) != MP_OKAY)\n-          goto CLEANUP;\n-      }\n-\n-      d >>= 1;\n-\n-      if((res = s_mp_sqr(&x)) != MP_OKAY)\n-        goto CLEANUP;\n-      if((res = s_mp_reduce(&x, m, &mu)) != MP_OKAY)\n-        goto CLEANUP;\n-    }\n-  }\n-\n-  \/* Now do the last digit... *\/\n-  d = DIGIT(b, dig);\n-\n-  while(d) {\n-    if(d & 1) {\n-      if((res = s_mp_mul(&s, &x)) != MP_OKAY)\n-        goto CLEANUP;\n-      if((res = s_mp_reduce(&s, m, &mu)) != MP_OKAY)\n-        goto CLEANUP;\n-    }\n-\n-    d >>= 1;\n-\n-    if((res = s_mp_sqr(&x)) != MP_OKAY)\n-      goto CLEANUP;\n-    if((res = s_mp_reduce(&x, m, &mu)) != MP_OKAY)\n-      goto CLEANUP;\n-  }\n-\n-  s_mp_exch(&s, c);\n-\n- CLEANUP:\n-  mp_clear(&mu);\n- MU:\n-  mp_clear(&x);\n- X:\n-  mp_clear(&s);\n-\n-  return res;\n-\n-} \/* end s_mp_exptmod() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_exptmod_d(a, d, m, c) *\/\n-\n-mp_err mp_exptmod_d(const mp_int *a, mp_digit d, const mp_int *m, mp_int *c)\n-{\n-  mp_int   s, x;\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && c != NULL, MP_BADARG);\n-\n-  if((res = mp_init(&s, FLAG(a))) != MP_OKAY)\n-    return res;\n-  if((res = mp_init_copy(&x, a)) != MP_OKAY)\n-    goto X;\n-\n-  mp_set(&s, 1);\n-\n-  while(d != 0) {\n-    if(d & 1) {\n-      if((res = s_mp_mul(&s, &x)) != MP_OKAY ||\n-         (res = mp_mod(&s, m, &s)) != MP_OKAY)\n-        goto CLEANUP;\n-    }\n-\n-    d \/= 2;\n-\n-    if((res = s_mp_sqr(&x)) != MP_OKAY ||\n-       (res = mp_mod(&x, m, &x)) != MP_OKAY)\n-      goto CLEANUP;\n-  }\n-\n-  s.flag = (mp_sign)0;\n-  s_mp_exch(&s, c);\n-\n-CLEANUP:\n-  mp_clear(&x);\n-X:\n-  mp_clear(&s);\n-\n-  return res;\n-\n-} \/* end mp_exptmod_d() *\/\n-\n-\/* }}} *\/\n-#endif \/* if MP_MODARITH *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ Comparison functions *\/\n-\n-\/* {{{ mp_cmp_z(a) *\/\n-\n-\/*\n-  mp_cmp_z(a)\n-\n-  Compare a <=> 0.  Returns <0 if a<0, 0 if a=0, >0 if a>0.\n- *\/\n-\n-int    mp_cmp_z(const mp_int *a)\n-{\n-  if(SIGN(a) == NEG)\n-    return MP_LT;\n-  else if(USED(a) == 1 && DIGIT(a, 0) == 0)\n-    return MP_EQ;\n-  else\n-    return MP_GT;\n-\n-} \/* end mp_cmp_z() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_cmp_d(a, d) *\/\n-\n-\/*\n-  mp_cmp_d(a, d)\n-\n-  Compare a <=> d.  Returns <0 if a<d, 0 if a=d, >0 if a>d\n- *\/\n-\n-int    mp_cmp_d(const mp_int *a, mp_digit d)\n-{\n-  ARGCHK(a != NULL, MP_EQ);\n-\n-  if(SIGN(a) == NEG)\n-    return MP_LT;\n-\n-  return s_mp_cmp_d(a, d);\n-\n-} \/* end mp_cmp_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_cmp(a, b) *\/\n-\n-int    mp_cmp(const mp_int *a, const mp_int *b)\n-{\n-  ARGCHK(a != NULL && b != NULL, MP_EQ);\n-\n-  if(SIGN(a) == SIGN(b)) {\n-    int  mag;\n-\n-    if((mag = s_mp_cmp(a, b)) == MP_EQ)\n-      return MP_EQ;\n-\n-    if(SIGN(a) == ZPOS)\n-      return mag;\n-    else\n-      return -mag;\n-\n-  } else if(SIGN(a) == ZPOS) {\n-    return MP_GT;\n-  } else {\n-    return MP_LT;\n-  }\n-\n-} \/* end mp_cmp() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_cmp_mag(a, b) *\/\n-\n-\/*\n-  mp_cmp_mag(a, b)\n-\n-  Compares |a| <=> |b|, and returns an appropriate comparison result\n- *\/\n-\n-int    mp_cmp_mag(mp_int *a, mp_int *b)\n-{\n-  ARGCHK(a != NULL && b != NULL, MP_EQ);\n-\n-  return s_mp_cmp(a, b);\n-\n-} \/* end mp_cmp_mag() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_cmp_int(a, z, kmflag) *\/\n-\n-\/*\n-  This just converts z to an mp_int, and uses the existing comparison\n-  routines.  This is sort of inefficient, but it's not clear to me how\n-  frequently this wil get used anyway.  For small positive constants,\n-  you can always use mp_cmp_d(), and for zero, there is mp_cmp_z().\n- *\/\n-int    mp_cmp_int(const mp_int *a, long z, int kmflag)\n-{\n-  mp_int  tmp;\n-  int     out;\n-\n-  ARGCHK(a != NULL, MP_EQ);\n-\n-  mp_init(&tmp, kmflag); mp_set_int(&tmp, z);\n-  out = mp_cmp(a, &tmp);\n-  mp_clear(&tmp);\n-\n-  return out;\n-\n-} \/* end mp_cmp_int() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_isodd(a) *\/\n-\n-\/*\n-  mp_isodd(a)\n-\n-  Returns a true (non-zero) value if a is odd, false (zero) otherwise.\n- *\/\n-int    mp_isodd(const mp_int *a)\n-{\n-  ARGCHK(a != NULL, 0);\n-\n-  return (int)(DIGIT(a, 0) & 1);\n-\n-} \/* end mp_isodd() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_iseven(a) *\/\n-\n-int    mp_iseven(const mp_int *a)\n-{\n-  return !mp_isodd(a);\n-\n-} \/* end mp_iseven() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ Number theoretic functions *\/\n-\n-#if MP_NUMTH\n-\/* {{{ mp_gcd(a, b, c) *\/\n-\n-\/*\n-  Like the old mp_gcd() function, except computes the GCD using the\n-  binary algorithm due to Josef Stein in 1961 (via Knuth).\n- *\/\n-mp_err mp_gcd(mp_int *a, mp_int *b, mp_int *c)\n-{\n-  mp_err   res;\n-  mp_int   u, v, t;\n-  mp_size  k = 0;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if(mp_cmp_z(a) == MP_EQ && mp_cmp_z(b) == MP_EQ)\n-      return MP_RANGE;\n-  if(mp_cmp_z(a) == MP_EQ) {\n-    return mp_copy(b, c);\n-  } else if(mp_cmp_z(b) == MP_EQ) {\n-    return mp_copy(a, c);\n-  }\n-\n-  if((res = mp_init(&t, FLAG(a))) != MP_OKAY)\n-    return res;\n-  if((res = mp_init_copy(&u, a)) != MP_OKAY)\n-    goto U;\n-  if((res = mp_init_copy(&v, b)) != MP_OKAY)\n-    goto V;\n-\n-  SIGN(&u) = ZPOS;\n-  SIGN(&v) = ZPOS;\n-\n-  \/* Divide out common factors of 2 until at least 1 of a, b is even *\/\n-  while(mp_iseven(&u) && mp_iseven(&v)) {\n-    s_mp_div_2(&u);\n-    s_mp_div_2(&v);\n-    ++k;\n-  }\n-\n-  \/* Initialize t *\/\n-  if(mp_isodd(&u)) {\n-    if((res = mp_copy(&v, &t)) != MP_OKAY)\n-      goto CLEANUP;\n-\n-    \/* t = -v *\/\n-    if(SIGN(&v) == ZPOS)\n-      SIGN(&t) = NEG;\n-    else\n-      SIGN(&t) = ZPOS;\n-\n-  } else {\n-    if((res = mp_copy(&u, &t)) != MP_OKAY)\n-      goto CLEANUP;\n-\n-  }\n-\n-  for(;;) {\n-    while(mp_iseven(&t)) {\n-      s_mp_div_2(&t);\n-    }\n-\n-    if(mp_cmp_z(&t) == MP_GT) {\n-      if((res = mp_copy(&t, &u)) != MP_OKAY)\n-        goto CLEANUP;\n-\n-    } else {\n-      if((res = mp_copy(&t, &v)) != MP_OKAY)\n-        goto CLEANUP;\n-\n-      \/* v = -t *\/\n-      if(SIGN(&t) == ZPOS)\n-        SIGN(&v) = NEG;\n-      else\n-        SIGN(&v) = ZPOS;\n-    }\n-\n-    if((res = mp_sub(&u, &v, &t)) != MP_OKAY)\n-      goto CLEANUP;\n-\n-    if(s_mp_cmp_d(&t, 0) == MP_EQ)\n-      break;\n-  }\n-\n-  s_mp_2expt(&v, k);       \/* v = 2^k   *\/\n-  res = mp_mul(&u, &v, c); \/* c = u * v *\/\n-\n- CLEANUP:\n-  mp_clear(&v);\n- V:\n-  mp_clear(&u);\n- U:\n-  mp_clear(&t);\n-\n-  return res;\n-\n-} \/* end mp_gcd() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_lcm(a, b, c) *\/\n-\n-\/* We compute the least common multiple using the rule:\n-\n-   ab = [a, b](a, b)\n-\n-   ... by computing the product, and dividing out the gcd.\n- *\/\n-\n-mp_err mp_lcm(mp_int *a, mp_int *b, mp_int *c)\n-{\n-  mp_int  gcd, prod;\n-  mp_err  res;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  \/* Set up temporaries *\/\n-  if((res = mp_init(&gcd, FLAG(a))) != MP_OKAY)\n-    return res;\n-  if((res = mp_init(&prod, FLAG(a))) != MP_OKAY)\n-    goto GCD;\n-\n-  if((res = mp_mul(a, b, &prod)) != MP_OKAY)\n-    goto CLEANUP;\n-  if((res = mp_gcd(a, b, &gcd)) != MP_OKAY)\n-    goto CLEANUP;\n-\n-  res = mp_div(&prod, &gcd, c, NULL);\n-\n- CLEANUP:\n-  mp_clear(&prod);\n- GCD:\n-  mp_clear(&gcd);\n-\n-  return res;\n-\n-} \/* end mp_lcm() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_xgcd(a, b, g, x, y) *\/\n-\n-\/*\n-  mp_xgcd(a, b, g, x, y)\n-\n-  Compute g = (a, b) and values x and y satisfying Bezout's identity\n-  (that is, ax + by = g).  This uses the binary extended GCD algorithm\n-  based on the Stein algorithm used for mp_gcd()\n-  See algorithm 14.61 in Handbook of Applied Cryptogrpahy.\n- *\/\n-\n-mp_err mp_xgcd(const mp_int *a, const mp_int *b, mp_int *g, mp_int *x, mp_int *y)\n-{\n-  mp_int   gx, xc, yc, u, v, A, B, C, D;\n-  mp_int  *clean[9];\n-  mp_err   res;\n-  int      last = -1;\n-\n-  if(mp_cmp_z(b) == 0)\n-    return MP_RANGE;\n-\n-  \/* Initialize all these variables we need *\/\n-  MP_CHECKOK( mp_init(&u, FLAG(a)) );\n-  clean[++last] = &u;\n-  MP_CHECKOK( mp_init(&v, FLAG(a)) );\n-  clean[++last] = &v;\n-  MP_CHECKOK( mp_init(&gx, FLAG(a)) );\n-  clean[++last] = &gx;\n-  MP_CHECKOK( mp_init(&A, FLAG(a)) );\n-  clean[++last] = &A;\n-  MP_CHECKOK( mp_init(&B, FLAG(a)) );\n-  clean[++last] = &B;\n-  MP_CHECKOK( mp_init(&C, FLAG(a)) );\n-  clean[++last] = &C;\n-  MP_CHECKOK( mp_init(&D, FLAG(a)) );\n-  clean[++last] = &D;\n-  MP_CHECKOK( mp_init_copy(&xc, a) );\n-  clean[++last] = &xc;\n-  mp_abs(&xc, &xc);\n-  MP_CHECKOK( mp_init_copy(&yc, b) );\n-  clean[++last] = &yc;\n-  mp_abs(&yc, &yc);\n-\n-  mp_set(&gx, 1);\n-\n-  \/* Divide by two until at least one of them is odd *\/\n-  while(mp_iseven(&xc) && mp_iseven(&yc)) {\n-    mp_size nx = mp_trailing_zeros(&xc);\n-    mp_size ny = mp_trailing_zeros(&yc);\n-    mp_size n  = MP_MIN(nx, ny);\n-    s_mp_div_2d(&xc,n);\n-    s_mp_div_2d(&yc,n);\n-    MP_CHECKOK( s_mp_mul_2d(&gx,n) );\n-  }\n-\n-  mp_copy(&xc, &u);\n-  mp_copy(&yc, &v);\n-  mp_set(&A, 1); mp_set(&D, 1);\n-\n-  \/* Loop through binary GCD algorithm *\/\n-  do {\n-    while(mp_iseven(&u)) {\n-      s_mp_div_2(&u);\n-\n-      if(mp_iseven(&A) && mp_iseven(&B)) {\n-        s_mp_div_2(&A); s_mp_div_2(&B);\n-      } else {\n-        MP_CHECKOK( mp_add(&A, &yc, &A) );\n-        s_mp_div_2(&A);\n-        MP_CHECKOK( mp_sub(&B, &xc, &B) );\n-        s_mp_div_2(&B);\n-      }\n-    }\n-\n-    while(mp_iseven(&v)) {\n-      s_mp_div_2(&v);\n-\n-      if(mp_iseven(&C) && mp_iseven(&D)) {\n-        s_mp_div_2(&C); s_mp_div_2(&D);\n-      } else {\n-        MP_CHECKOK( mp_add(&C, &yc, &C) );\n-        s_mp_div_2(&C);\n-        MP_CHECKOK( mp_sub(&D, &xc, &D) );\n-        s_mp_div_2(&D);\n-      }\n-    }\n-\n-    if(mp_cmp(&u, &v) >= 0) {\n-      MP_CHECKOK( mp_sub(&u, &v, &u) );\n-      MP_CHECKOK( mp_sub(&A, &C, &A) );\n-      MP_CHECKOK( mp_sub(&B, &D, &B) );\n-    } else {\n-      MP_CHECKOK( mp_sub(&v, &u, &v) );\n-      MP_CHECKOK( mp_sub(&C, &A, &C) );\n-      MP_CHECKOK( mp_sub(&D, &B, &D) );\n-    }\n-  } while (mp_cmp_z(&u) != 0);\n-\n-  \/* copy results to output *\/\n-  if(x)\n-    MP_CHECKOK( mp_copy(&C, x) );\n-\n-  if(y)\n-    MP_CHECKOK( mp_copy(&D, y) );\n-\n-  if(g)\n-    MP_CHECKOK( mp_mul(&gx, &v, g) );\n-\n- CLEANUP:\n-  while(last >= 0)\n-    mp_clear(clean[last--]);\n-\n-  return res;\n-\n-} \/* end mp_xgcd() *\/\n-\n-\/* }}} *\/\n-\n-mp_size mp_trailing_zeros(const mp_int *mp)\n-{\n-  mp_digit d;\n-  mp_size  n = 0;\n-  unsigned int      ix;\n-\n-  if (!mp || !MP_DIGITS(mp) || !mp_cmp_z(mp))\n-    return n;\n-\n-  for (ix = 0; !(d = MP_DIGIT(mp,ix)) && (ix < MP_USED(mp)); ++ix)\n-    n += MP_DIGIT_BIT;\n-  if (!d)\n-    return 0;   \/* shouldn't happen, but ... *\/\n-#if !defined(MP_USE_UINT_DIGIT)\n-  if (!(d & 0xffffffffU)) {\n-    d >>= 32;\n-    n  += 32;\n-  }\n-#endif\n-  if (!(d & 0xffffU)) {\n-    d >>= 16;\n-    n  += 16;\n-  }\n-  if (!(d & 0xffU)) {\n-    d >>= 8;\n-    n  += 8;\n-  }\n-  if (!(d & 0xfU)) {\n-    d >>= 4;\n-    n  += 4;\n-  }\n-  if (!(d & 0x3U)) {\n-    d >>= 2;\n-    n  += 2;\n-  }\n-  if (!(d & 0x1U)) {\n-    d >>= 1;\n-    n  += 1;\n-  }\n-#if MP_ARGCHK == 2\n-  assert(0 != (d & 1));\n-#endif\n-  return n;\n-}\n-\n-\/* Given a and prime p, computes c and k such that a*c == 2**k (mod p).\n-** Returns k (positive) or error (negative).\n-** This technique from the paper \"Fast Modular Reciprocals\" (unpublished)\n-** by Richard Schroeppel (a.k.a. Captain Nemo).\n-*\/\n-mp_err s_mp_almost_inverse(const mp_int *a, const mp_int *p, mp_int *c)\n-{\n-  mp_err res;\n-  mp_err k    = 0;\n-  mp_int d, f, g;\n-\n-  ARGCHK(a && p && c, MP_BADARG);\n-\n-  MP_DIGITS(&d) = 0;\n-  MP_DIGITS(&f) = 0;\n-  MP_DIGITS(&g) = 0;\n-  MP_CHECKOK( mp_init(&d, FLAG(a)) );\n-  MP_CHECKOK( mp_init_copy(&f, a) );    \/* f = a *\/\n-  MP_CHECKOK( mp_init_copy(&g, p) );    \/* g = p *\/\n-\n-  mp_set(c, 1);\n-  mp_zero(&d);\n-\n-  if (mp_cmp_z(&f) == 0) {\n-    res = MP_UNDEF;\n-  } else\n-  for (;;) {\n-    int diff_sign;\n-    while (mp_iseven(&f)) {\n-      mp_size n = mp_trailing_zeros(&f);\n-      if (!n) {\n-        res = MP_UNDEF;\n-        goto CLEANUP;\n-      }\n-      s_mp_div_2d(&f, n);\n-      MP_CHECKOK( s_mp_mul_2d(&d, n) );\n-      k += n;\n-    }\n-    if (mp_cmp_d(&f, 1) == MP_EQ) {     \/* f == 1 *\/\n-      res = k;\n-      break;\n-    }\n-    diff_sign = mp_cmp(&f, &g);\n-    if (diff_sign < 0) {                \/* f < g *\/\n-      s_mp_exch(&f, &g);\n-      s_mp_exch(c, &d);\n-    } else if (diff_sign == 0) {                \/* f == g *\/\n-      res = MP_UNDEF;           \/* a and p are not relatively prime *\/\n-      break;\n-    }\n-    if ((MP_DIGIT(&f,0) % 4) == (MP_DIGIT(&g,0) % 4)) {\n-      MP_CHECKOK( mp_sub(&f, &g, &f) ); \/* f = f - g *\/\n-      MP_CHECKOK( mp_sub(c,  &d,  c) ); \/* c = c - d *\/\n-    } else {\n-      MP_CHECKOK( mp_add(&f, &g, &f) ); \/* f = f + g *\/\n-      MP_CHECKOK( mp_add(c,  &d,  c) ); \/* c = c + d *\/\n-    }\n-  }\n-  if (res >= 0) {\n-    if (s_mp_cmp(c, p) >= 0) {\n-      MP_CHECKOK( mp_div(c, p, NULL, c));\n-    }\n-    if (MP_SIGN(c) != MP_ZPOS) {\n-      MP_CHECKOK( mp_add(c, p, c) );\n-    }\n-    res = k;\n-  }\n-\n-CLEANUP:\n-  mp_clear(&d);\n-  mp_clear(&f);\n-  mp_clear(&g);\n-  return res;\n-}\n-\n-\/* Compute T = (P ** -1) mod MP_RADIX.  Also works for 16-bit mp_digits.\n-** This technique from the paper \"Fast Modular Reciprocals\" (unpublished)\n-** by Richard Schroeppel (a.k.a. Captain Nemo).\n-*\/\n-mp_digit  s_mp_invmod_radix(mp_digit P)\n-{\n-  mp_digit T = P;\n-  T *= 2 - (P * T);\n-  T *= 2 - (P * T);\n-  T *= 2 - (P * T);\n-  T *= 2 - (P * T);\n-#if !defined(MP_USE_UINT_DIGIT)\n-  T *= 2 - (P * T);\n-  T *= 2 - (P * T);\n-#endif\n-  return T;\n-}\n-\n-\/* Given c, k, and prime p, where a*c == 2**k (mod p),\n-** Compute x = (a ** -1) mod p.  This is similar to Montgomery reduction.\n-** This technique from the paper \"Fast Modular Reciprocals\" (unpublished)\n-** by Richard Schroeppel (a.k.a. Captain Nemo).\n-*\/\n-mp_err  s_mp_fixup_reciprocal(const mp_int *c, const mp_int *p, int k, mp_int *x)\n-{\n-  int      k_orig = k;\n-  mp_digit r;\n-  mp_size  ix;\n-  mp_err   res;\n-\n-  if (mp_cmp_z(c) < 0) {                \/* c < 0 *\/\n-    MP_CHECKOK( mp_add(c, p, x) );      \/* x = c + p *\/\n-  } else {\n-    MP_CHECKOK( mp_copy(c, x) );        \/* x = c *\/\n-  }\n-\n-  \/* make sure x is large enough *\/\n-  ix = MP_HOWMANY(k, MP_DIGIT_BIT) + MP_USED(p) + 1;\n-  ix = MP_MAX(ix, MP_USED(x));\n-  MP_CHECKOK( s_mp_pad(x, ix) );\n-\n-  r = 0 - s_mp_invmod_radix(MP_DIGIT(p,0));\n-\n-  for (ix = 0; k > 0; ix++) {\n-    int      j = MP_MIN(k, MP_DIGIT_BIT);\n-    mp_digit v = r * MP_DIGIT(x, ix);\n-    if (j < MP_DIGIT_BIT) {\n-      v &= ((mp_digit)1 << j) - 1;      \/* v = v mod (2 ** j) *\/\n-    }\n-    s_mp_mul_d_add_offset(p, v, x, ix); \/* x += p * v * (RADIX ** ix) *\/\n-    k -= j;\n-  }\n-  s_mp_clamp(x);\n-  s_mp_div_2d(x, k_orig);\n-  res = MP_OKAY;\n-\n-CLEANUP:\n-  return res;\n-}\n-\n-\/* compute mod inverse using Schroeppel's method, only if m is odd *\/\n-mp_err s_mp_invmod_odd_m(const mp_int *a, const mp_int *m, mp_int *c)\n-{\n-  int k;\n-  mp_err  res;\n-  mp_int  x;\n-\n-  ARGCHK(a && m && c, MP_BADARG);\n-\n-  if(mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)\n-    return MP_RANGE;\n-  if (mp_iseven(m))\n-    return MP_UNDEF;\n-\n-  MP_DIGITS(&x) = 0;\n-\n-  if (a == c) {\n-    if ((res = mp_init_copy(&x, a)) != MP_OKAY)\n-      return res;\n-    if (a == m)\n-      m = &x;\n-    a = &x;\n-  } else if (m == c) {\n-    if ((res = mp_init_copy(&x, m)) != MP_OKAY)\n-      return res;\n-    m = &x;\n-  } else {\n-    MP_DIGITS(&x) = 0;\n-  }\n-\n-  MP_CHECKOK( s_mp_almost_inverse(a, m, c) );\n-  k = res;\n-  MP_CHECKOK( s_mp_fixup_reciprocal(c, m, k, c) );\n-CLEANUP:\n-  mp_clear(&x);\n-  return res;\n-}\n-\n-\/* Known good algorithm for computing modular inverse.  But slow. *\/\n-mp_err mp_invmod_xgcd(const mp_int *a, const mp_int *m, mp_int *c)\n-{\n-  mp_int  g, x;\n-  mp_err  res;\n-\n-  ARGCHK(a && m && c, MP_BADARG);\n-\n-  if(mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)\n-    return MP_RANGE;\n-\n-  MP_DIGITS(&g) = 0;\n-  MP_DIGITS(&x) = 0;\n-  MP_CHECKOK( mp_init(&x, FLAG(a)) );\n-  MP_CHECKOK( mp_init(&g, FLAG(a)) );\n-\n-  MP_CHECKOK( mp_xgcd(a, m, &g, &x, NULL) );\n-\n-  if (mp_cmp_d(&g, 1) != MP_EQ) {\n-    res = MP_UNDEF;\n-    goto CLEANUP;\n-  }\n-\n-  res = mp_mod(&x, m, c);\n-  SIGN(c) = SIGN(a);\n-\n-CLEANUP:\n-  mp_clear(&x);\n-  mp_clear(&g);\n-\n-  return res;\n-}\n-\n-\/* modular inverse where modulus is 2**k. *\/\n-\/* c = a**-1 mod 2**k *\/\n-mp_err s_mp_invmod_2d(const mp_int *a, mp_size k, mp_int *c)\n-{\n-  mp_err res;\n-  mp_size ix = k + 4;\n-  mp_int t0, t1, val, tmp, two2k;\n-\n-  static const mp_digit d2 = 2;\n-  static const mp_int two = { 0, MP_ZPOS, 1, 1, (mp_digit *)&d2 };\n-\n-  if (mp_iseven(a))\n-    return MP_UNDEF;\n-  if (k <= MP_DIGIT_BIT) {\n-    mp_digit i = s_mp_invmod_radix(MP_DIGIT(a,0));\n-    if (k < MP_DIGIT_BIT)\n-      i &= ((mp_digit)1 << k) - (mp_digit)1;\n-    mp_set(c, i);\n-    return MP_OKAY;\n-  }\n-  MP_DIGITS(&t0) = 0;\n-  MP_DIGITS(&t1) = 0;\n-  MP_DIGITS(&val) = 0;\n-  MP_DIGITS(&tmp) = 0;\n-  MP_DIGITS(&two2k) = 0;\n-  MP_CHECKOK( mp_init_copy(&val, a) );\n-  s_mp_mod_2d(&val, k);\n-  MP_CHECKOK( mp_init_copy(&t0, &val) );\n-  MP_CHECKOK( mp_init_copy(&t1, &t0)  );\n-  MP_CHECKOK( mp_init(&tmp, FLAG(a)) );\n-  MP_CHECKOK( mp_init(&two2k, FLAG(a)) );\n-  MP_CHECKOK( s_mp_2expt(&two2k, k) );\n-  do {\n-    MP_CHECKOK( mp_mul(&val, &t1, &tmp)  );\n-    MP_CHECKOK( mp_sub(&two, &tmp, &tmp) );\n-    MP_CHECKOK( mp_mul(&t1, &tmp, &t1)   );\n-    s_mp_mod_2d(&t1, k);\n-    while (MP_SIGN(&t1) != MP_ZPOS) {\n-      MP_CHECKOK( mp_add(&t1, &two2k, &t1) );\n-    }\n-    if (mp_cmp(&t1, &t0) == MP_EQ)\n-      break;\n-    MP_CHECKOK( mp_copy(&t1, &t0) );\n-  } while (--ix > 0);\n-  if (!ix) {\n-    res = MP_UNDEF;\n-  } else {\n-    mp_exch(c, &t1);\n-  }\n-\n-CLEANUP:\n-  mp_clear(&t0);\n-  mp_clear(&t1);\n-  mp_clear(&val);\n-  mp_clear(&tmp);\n-  mp_clear(&two2k);\n-  return res;\n-}\n-\n-mp_err s_mp_invmod_even_m(const mp_int *a, const mp_int *m, mp_int *c)\n-{\n-  mp_err res;\n-  mp_size k;\n-  mp_int oddFactor, evenFactor; \/* factors of the modulus *\/\n-  mp_int oddPart, evenPart;     \/* parts to combine via CRT. *\/\n-  mp_int C2, tmp1, tmp2;\n-\n-  \/*static const mp_digit d1 = 1; *\/\n-  \/*static const mp_int one = { MP_ZPOS, 1, 1, (mp_digit *)&d1 }; *\/\n-\n-  if ((res = s_mp_ispow2(m)) >= 0) {\n-    k = res;\n-    return s_mp_invmod_2d(a, k, c);\n-  }\n-  MP_DIGITS(&oddFactor) = 0;\n-  MP_DIGITS(&evenFactor) = 0;\n-  MP_DIGITS(&oddPart) = 0;\n-  MP_DIGITS(&evenPart) = 0;\n-  MP_DIGITS(&C2)     = 0;\n-  MP_DIGITS(&tmp1)   = 0;\n-  MP_DIGITS(&tmp2)   = 0;\n-\n-  MP_CHECKOK( mp_init_copy(&oddFactor, m) );    \/* oddFactor = m *\/\n-  MP_CHECKOK( mp_init(&evenFactor, FLAG(m)) );\n-  MP_CHECKOK( mp_init(&oddPart, FLAG(m)) );\n-  MP_CHECKOK( mp_init(&evenPart, FLAG(m)) );\n-  MP_CHECKOK( mp_init(&C2, FLAG(m))     );\n-  MP_CHECKOK( mp_init(&tmp1, FLAG(m))   );\n-  MP_CHECKOK( mp_init(&tmp2, FLAG(m))   );\n-\n-  k = mp_trailing_zeros(m);\n-  s_mp_div_2d(&oddFactor, k);\n-  MP_CHECKOK( s_mp_2expt(&evenFactor, k) );\n-\n-  \/* compute a**-1 mod oddFactor. *\/\n-  MP_CHECKOK( s_mp_invmod_odd_m(a, &oddFactor, &oddPart) );\n-  \/* compute a**-1 mod evenFactor, where evenFactor == 2**k. *\/\n-  MP_CHECKOK( s_mp_invmod_2d(   a,       k,    &evenPart) );\n-\n-  \/* Use Chinese Remainer theorem to compute a**-1 mod m. *\/\n-  \/* let m1 = oddFactor,  v1 = oddPart,\n-   * let m2 = evenFactor, v2 = evenPart.\n-   *\/\n-\n-  \/* Compute C2 = m1**-1 mod m2. *\/\n-  MP_CHECKOK( s_mp_invmod_2d(&oddFactor, k,    &C2) );\n-\n-  \/* compute u = (v2 - v1)*C2 mod m2 *\/\n-  MP_CHECKOK( mp_sub(&evenPart, &oddPart,   &tmp1) );\n-  MP_CHECKOK( mp_mul(&tmp1,     &C2,        &tmp2) );\n-  s_mp_mod_2d(&tmp2, k);\n-  while (MP_SIGN(&tmp2) != MP_ZPOS) {\n-    MP_CHECKOK( mp_add(&tmp2, &evenFactor, &tmp2) );\n-  }\n-\n-  \/* compute answer = v1 + u*m1 *\/\n-  MP_CHECKOK( mp_mul(&tmp2,     &oddFactor, c) );\n-  MP_CHECKOK( mp_add(&oddPart,  c,          c) );\n-  \/* not sure this is necessary, but it's low cost if not. *\/\n-  MP_CHECKOK( mp_mod(c,         m,          c) );\n-\n-CLEANUP:\n-  mp_clear(&oddFactor);\n-  mp_clear(&evenFactor);\n-  mp_clear(&oddPart);\n-  mp_clear(&evenPart);\n-  mp_clear(&C2);\n-  mp_clear(&tmp1);\n-  mp_clear(&tmp2);\n-  return res;\n-}\n-\n-\n-\/* {{{ mp_invmod(a, m, c) *\/\n-\n-\/*\n-  mp_invmod(a, m, c)\n-\n-  Compute c = a^-1 (mod m), if there is an inverse for a (mod m).\n-  This is equivalent to the question of whether (a, m) = 1.  If not,\n-  MP_UNDEF is returned, and there is no inverse.\n- *\/\n-\n-mp_err mp_invmod(const mp_int *a, const mp_int *m, mp_int *c)\n-{\n-\n-  ARGCHK(a && m && c, MP_BADARG);\n-\n-  if(mp_cmp_z(a) == 0 || mp_cmp_z(m) == 0)\n-    return MP_RANGE;\n-\n-  if (mp_isodd(m)) {\n-    return s_mp_invmod_odd_m(a, m, c);\n-  }\n-  if (mp_iseven(a))\n-    return MP_UNDEF;    \/* not invertable *\/\n-\n-  return s_mp_invmod_even_m(a, m, c);\n-\n-} \/* end mp_invmod() *\/\n-\n-\/* }}} *\/\n-#endif \/* if MP_NUMTH *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ mp_print(mp, ofp) *\/\n-\n-#if MP_IOFUNC\n-\/*\n-  mp_print(mp, ofp)\n-\n-  Print a textual representation of the given mp_int on the output\n-  stream 'ofp'.  Output is generated using the internal radix.\n- *\/\n-\n-void   mp_print(mp_int *mp, FILE *ofp)\n-{\n-  int   ix;\n-\n-  if(mp == NULL || ofp == NULL)\n-    return;\n-\n-  fputc((SIGN(mp) == NEG) ? '-' : '+', ofp);\n-\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    fprintf(ofp, DIGIT_FMT, DIGIT(mp, ix));\n-  }\n-\n-} \/* end mp_print() *\/\n-\n-#endif \/* if MP_IOFUNC *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* {{{ More I\/O Functions *\/\n-\n-\/* {{{ mp_read_raw(mp, str, len) *\/\n-\n-\/*\n-   mp_read_raw(mp, str, len)\n-\n-   Read in a raw value (base 256) into the given mp_int\n- *\/\n-\n-mp_err  mp_read_raw(mp_int *mp, char *str, int len)\n-{\n-  int            ix;\n-  mp_err         res;\n-  unsigned char *ustr = (unsigned char *)str;\n-\n-  ARGCHK(mp != NULL && str != NULL && len > 0, MP_BADARG);\n-\n-  mp_zero(mp);\n-\n-  \/* Get sign from first byte *\/\n-  if(ustr[0])\n-    SIGN(mp) = NEG;\n-  else\n-    SIGN(mp) = ZPOS;\n-\n-  \/* Read the rest of the digits *\/\n-  for(ix = 1; ix < len; ix++) {\n-    if((res = mp_mul_d(mp, 256, mp)) != MP_OKAY)\n-      return res;\n-    if((res = mp_add_d(mp, ustr[ix], mp)) != MP_OKAY)\n-      return res;\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_read_raw() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_raw_size(mp) *\/\n-\n-int    mp_raw_size(mp_int *mp)\n-{\n-  ARGCHK(mp != NULL, 0);\n-\n-  return (USED(mp) * sizeof(mp_digit)) + 1;\n-\n-} \/* end mp_raw_size() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_toraw(mp, str) *\/\n-\n-mp_err mp_toraw(mp_int *mp, char *str)\n-{\n-  int  ix, jx, pos = 1;\n-\n-  ARGCHK(mp != NULL && str != NULL, MP_BADARG);\n-\n-  str[0] = (char)SIGN(mp);\n-\n-  \/* Iterate over each digit... *\/\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    mp_digit  d = DIGIT(mp, ix);\n-\n-    \/* Unpack digit bytes, high order first *\/\n-    for(jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {\n-      str[pos++] = (char)(d >> (jx * CHAR_BIT));\n-    }\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_toraw() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_read_radix(mp, str, radix) *\/\n-\n-\/*\n-  mp_read_radix(mp, str, radix)\n-\n-  Read an integer from the given string, and set mp to the resulting\n-  value.  The input is presumed to be in base 10.  Leading non-digit\n-  characters are ignored, and the function reads until a non-digit\n-  character or the end of the string.\n- *\/\n-\n-mp_err  mp_read_radix(mp_int *mp, const char *str, int radix)\n-{\n-  int     ix = 0, val = 0;\n-  mp_err  res;\n-  mp_sign sig = ZPOS;\n-\n-  ARGCHK(mp != NULL && str != NULL && radix >= 2 && radix <= MAX_RADIX,\n-         MP_BADARG);\n-\n-  mp_zero(mp);\n-\n-  \/* Skip leading non-digit characters until a digit or '-' or '+' *\/\n-  while(str[ix] &&\n-        (s_mp_tovalue(str[ix], radix) < 0) &&\n-        str[ix] != '-' &&\n-        str[ix] != '+') {\n-    ++ix;\n-  }\n-\n-  if(str[ix] == '-') {\n-    sig = NEG;\n-    ++ix;\n-  } else if(str[ix] == '+') {\n-    sig = ZPOS; \/* this is the default anyway... *\/\n-    ++ix;\n-  }\n-\n-  while((val = s_mp_tovalue(str[ix], radix)) >= 0) {\n-    if((res = s_mp_mul_d(mp, radix)) != MP_OKAY)\n-      return res;\n-    if((res = s_mp_add_d(mp, val)) != MP_OKAY)\n-      return res;\n-    ++ix;\n-  }\n-\n-  if(s_mp_cmp_d(mp, 0) == MP_EQ)\n-    SIGN(mp) = ZPOS;\n-  else\n-    SIGN(mp) = sig;\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_read_radix() *\/\n-\n-mp_err mp_read_variable_radix(mp_int *a, const char * str, int default_radix)\n-{\n-  int     radix = default_radix;\n-  int     cx;\n-  mp_sign sig   = ZPOS;\n-  mp_err  res;\n-\n-  \/* Skip leading non-digit characters until a digit or '-' or '+' *\/\n-  while ((cx = *str) != 0 &&\n-        (s_mp_tovalue(cx, radix) < 0) &&\n-        cx != '-' &&\n-        cx != '+') {\n-    ++str;\n-  }\n-\n-  if (cx == '-') {\n-    sig = NEG;\n-    ++str;\n-  } else if (cx == '+') {\n-    sig = ZPOS; \/* this is the default anyway... *\/\n-    ++str;\n-  }\n-\n-  if (str[0] == '0') {\n-    if ((str[1] | 0x20) == 'x') {\n-      radix = 16;\n-      str += 2;\n-    } else {\n-      radix = 8;\n-      str++;\n-    }\n-  }\n-  res = mp_read_radix(a, str, radix);\n-  if (res == MP_OKAY) {\n-    MP_SIGN(a) = (s_mp_cmp_d(a, 0) == MP_EQ) ? ZPOS : sig;\n-  }\n-  return res;\n-}\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_radix_size(mp, radix) *\/\n-\n-int    mp_radix_size(mp_int *mp, int radix)\n-{\n-  int  bits;\n-\n-  if(!mp || radix < 2 || radix > MAX_RADIX)\n-    return 0;\n-\n-  bits = USED(mp) * DIGIT_BIT - 1;\n-\n-  return s_mp_outlen(bits, radix);\n-\n-} \/* end mp_radix_size() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_toradix(mp, str, radix) *\/\n-\n-mp_err mp_toradix(mp_int *mp, char *str, int radix)\n-{\n-  int  ix, pos = 0;\n-\n-  ARGCHK(mp != NULL && str != NULL, MP_BADARG);\n-  ARGCHK(radix > 1 && radix <= MAX_RADIX, MP_RANGE);\n-\n-  if(mp_cmp_z(mp) == MP_EQ) {\n-    str[0] = '0';\n-    str[1] = '\\0';\n-  } else {\n-    mp_err   res;\n-    mp_int   tmp;\n-    mp_sign  sgn;\n-    mp_digit rem, rdx = (mp_digit)radix;\n-    char     ch;\n-\n-    if((res = mp_init_copy(&tmp, mp)) != MP_OKAY)\n-      return res;\n-\n-    \/* Save sign for later, and take absolute value *\/\n-    sgn = SIGN(&tmp); SIGN(&tmp) = ZPOS;\n-\n-    \/* Generate output digits in reverse order      *\/\n-    while(mp_cmp_z(&tmp) != 0) {\n-      if((res = mp_div_d(&tmp, rdx, &tmp, &rem)) != MP_OKAY) {\n-        mp_clear(&tmp);\n-        return res;\n-      }\n-\n-      \/* Generate digits, use capital letters *\/\n-      ch = s_mp_todigit(rem, radix, 0);\n-\n-      str[pos++] = ch;\n-    }\n-\n-    \/* Add - sign if original value was negative *\/\n-    if(sgn == NEG)\n-      str[pos++] = '-';\n-\n-    \/* Add trailing NUL to end the string        *\/\n-    str[pos--] = '\\0';\n-\n-    \/* Reverse the digits and sign indicator     *\/\n-    ix = 0;\n-    while(ix < pos) {\n-      char tmp = str[ix];\n-\n-      str[ix] = str[pos];\n-      str[pos] = tmp;\n-      ++ix;\n-      --pos;\n-    }\n-\n-    mp_clear(&tmp);\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end mp_toradix() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_tovalue(ch, r) *\/\n-\n-int    mp_tovalue(char ch, int r)\n-{\n-  return s_mp_tovalue(ch, r);\n-\n-} \/* end mp_tovalue() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_strerror(ec) *\/\n-\n-\/*\n-  mp_strerror(ec)\n-\n-  Return a string describing the meaning of error code 'ec'.  The\n-  string returned is allocated in static memory, so the caller should\n-  not attempt to modify or free the memory associated with this\n-  string.\n- *\/\n-const char  *mp_strerror(mp_err ec)\n-{\n-  int   aec = (ec < 0) ? -ec : ec;\n-\n-  \/* Code values are negative, so the senses of these comparisons\n-     are accurate *\/\n-  if(ec < MP_LAST_CODE || ec > MP_OKAY) {\n-    return mp_err_string[0];  \/* unknown error code *\/\n-  } else {\n-    return mp_err_string[aec + 1];\n-  }\n-\n-} \/* end mp_strerror() *\/\n-\n-\/* }}} *\/\n-\n-\/*========================================================================*\/\n-\/*------------------------------------------------------------------------*\/\n-\/* Static function definitions (internal use only)                        *\/\n-\n-\/* {{{ Memory management *\/\n-\n-\/* {{{ s_mp_grow(mp, min) *\/\n-\n-\/* Make sure there are at least 'min' digits allocated to mp              *\/\n-mp_err   s_mp_grow(mp_int *mp, mp_size min)\n-{\n-  if(min > ALLOC(mp)) {\n-    mp_digit   *tmp;\n-\n-    \/* Set min to next nearest default precision block size *\/\n-    min = MP_ROUNDUP(min, s_mp_defprec);\n-\n-    if((tmp = s_mp_alloc(min, sizeof(mp_digit), FLAG(mp))) == NULL)\n-      return MP_MEM;\n-\n-    s_mp_copy(DIGITS(mp), tmp, USED(mp));\n-\n-#if MP_CRYPTO\n-    s_mp_setz(DIGITS(mp), ALLOC(mp));\n-#endif\n-    s_mp_free(DIGITS(mp), ALLOC(mp));\n-    DIGITS(mp) = tmp;\n-    ALLOC(mp) = min;\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end s_mp_grow() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_pad(mp, min) *\/\n-\n-\/* Make sure the used size of mp is at least 'min', growing if needed     *\/\n-mp_err   s_mp_pad(mp_int *mp, mp_size min)\n-{\n-  if(min > USED(mp)) {\n-    mp_err  res;\n-\n-    \/* Make sure there is room to increase precision  *\/\n-    if (min > ALLOC(mp)) {\n-      if ((res = s_mp_grow(mp, min)) != MP_OKAY)\n-        return res;\n-    } else {\n-      s_mp_setz(DIGITS(mp) + USED(mp), min - USED(mp));\n-    }\n-\n-    \/* Increase precision; should already be 0-filled *\/\n-    USED(mp) = min;\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end s_mp_pad() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_setz(dp, count) *\/\n-\n-#if MP_MACRO == 0\n-\/* Set 'count' digits pointed to by dp to be zeroes                       *\/\n-void s_mp_setz(mp_digit *dp, mp_size count)\n-{\n-#if MP_MEMSET == 0\n-  int  ix;\n-\n-  for(ix = 0; ix < count; ix++)\n-    dp[ix] = 0;\n-#else\n-  memset(dp, 0, count * sizeof(mp_digit));\n-#endif\n-\n-} \/* end s_mp_setz() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_copy(sp, dp, count) *\/\n-\n-#if MP_MACRO == 0\n-\/* Copy 'count' digits from sp to dp                                      *\/\n-void s_mp_copy(const mp_digit *sp, mp_digit *dp, mp_size count)\n-{\n-#if MP_MEMCPY == 0\n-  int  ix;\n-\n-  for(ix = 0; ix < count; ix++)\n-    dp[ix] = sp[ix];\n-#else\n-  memcpy(dp, sp, count * sizeof(mp_digit));\n-#endif\n-\n-} \/* end s_mp_copy() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_alloc(nb, ni, kmflag) *\/\n-\n-#if MP_MACRO == 0\n-\/* Allocate ni records of nb bytes each, and return a pointer to that     *\/\n-void    *s_mp_alloc(size_t nb, size_t ni, int kmflag)\n-{\n-  ++mp_allocs;\n-#ifdef _KERNEL\n-  mp_int *mp;\n-  mp = kmem_zalloc(nb * ni, kmflag);\n-  if (mp != NULL)\n-    FLAG(mp) = kmflag;\n-  return (mp);\n-#else\n-  return calloc(nb, ni);\n-#endif\n-\n-} \/* end s_mp_alloc() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_free(ptr) *\/\n-\n-#if MP_MACRO == 0\n-\/* Free the memory pointed to by ptr                                      *\/\n-void     s_mp_free(void *ptr, mp_size alloc)\n-{\n-  if(ptr) {\n-    ++mp_frees;\n-#ifdef _KERNEL\n-    kmem_free(ptr, alloc * sizeof (mp_digit));\n-#else\n-    free(ptr);\n-#endif\n-  }\n-} \/* end s_mp_free() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_clamp(mp) *\/\n-\n-#if MP_MACRO == 0\n-\/* Remove leading zeroes from the given value                             *\/\n-void     s_mp_clamp(mp_int *mp)\n-{\n-  mp_size used = MP_USED(mp);\n-  while (used > 1 && DIGIT(mp, used - 1) == 0)\n-    --used;\n-  MP_USED(mp) = used;\n-} \/* end s_mp_clamp() *\/\n-#endif\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_exch(a, b) *\/\n-\n-\/* Exchange the data for a and b; (b, a) = (a, b)                         *\/\n-void     s_mp_exch(mp_int *a, mp_int *b)\n-{\n-  mp_int   tmp;\n-\n-  tmp = *a;\n-  *a = *b;\n-  *b = tmp;\n-\n-} \/* end s_mp_exch() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ Arithmetic helpers *\/\n-\n-\/* {{{ s_mp_lshd(mp, p) *\/\n-\n-\/*\n-   Shift mp leftward by p digits, growing if needed, and zero-filling\n-   the in-shifted digits at the right end.  This is a convenient\n-   alternative to multiplication by powers of the radix\n-   The value of USED(mp) must already have been set to the value for\n-   the shifted result.\n- *\/\n-\n-mp_err   s_mp_lshd(mp_int *mp, mp_size p)\n-{\n-  mp_err  res;\n-  mp_size pos;\n-  int     ix;\n-\n-  if(p == 0)\n-    return MP_OKAY;\n-\n-  if (MP_USED(mp) == 1 && MP_DIGIT(mp, 0) == 0)\n-    return MP_OKAY;\n-\n-  if((res = s_mp_pad(mp, USED(mp) + p)) != MP_OKAY)\n-    return res;\n-\n-  pos = USED(mp) - 1;\n-\n-  \/* Shift all the significant figures over as needed *\/\n-  for(ix = pos - p; ix >= 0; ix--)\n-    DIGIT(mp, ix + p) = DIGIT(mp, ix);\n-\n-  \/* Fill the bottom digits with zeroes *\/\n-  for(ix = 0; ix < p; ix++)\n-    DIGIT(mp, ix) = 0;\n-\n-  return MP_OKAY;\n-\n-} \/* end s_mp_lshd() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_mul_2d(mp, d) *\/\n-\n-\/*\n-  Multiply the integer by 2^d, where d is a number of bits.  This\n-  amounts to a bitwise shift of the value.\n- *\/\n-mp_err   s_mp_mul_2d(mp_int *mp, mp_digit d)\n-{\n-  mp_err   res;\n-  mp_digit dshift, bshift;\n-  mp_digit mask;\n-\n-  ARGCHK(mp != NULL,  MP_BADARG);\n-\n-  dshift = d \/ MP_DIGIT_BIT;\n-  bshift = d % MP_DIGIT_BIT;\n-  \/* bits to be shifted out of the top word *\/\n-  mask   = ((mp_digit)~0 << (MP_DIGIT_BIT - bshift));\n-  mask  &= MP_DIGIT(mp, MP_USED(mp) - 1);\n-\n-  if (MP_OKAY != (res = s_mp_pad(mp, MP_USED(mp) + dshift + (mask != 0) )))\n-    return res;\n-\n-  if (dshift && MP_OKAY != (res = s_mp_lshd(mp, dshift)))\n-    return res;\n-\n-  if (bshift) {\n-    mp_digit *pa = MP_DIGITS(mp);\n-    mp_digit *alim = pa + MP_USED(mp);\n-    mp_digit  prev = 0;\n-\n-    for (pa += dshift; pa < alim; ) {\n-      mp_digit x = *pa;\n-      *pa++ = (x << bshift) | prev;\n-      prev = x >> (DIGIT_BIT - bshift);\n-    }\n-  }\n-\n-  s_mp_clamp(mp);\n-  return MP_OKAY;\n-} \/* end s_mp_mul_2d() *\/\n-\n-\/* {{{ s_mp_rshd(mp, p) *\/\n-\n-\/*\n-   Shift mp rightward by p digits.  Maintains the invariant that\n-   digits above the precision are all zero.  Digits shifted off the\n-   end are lost.  Cannot fail.\n- *\/\n-\n-void     s_mp_rshd(mp_int *mp, mp_size p)\n-{\n-  mp_size  ix;\n-  mp_digit *src, *dst;\n-\n-  if(p == 0)\n-    return;\n-\n-  \/* Shortcut when all digits are to be shifted off *\/\n-  if(p >= USED(mp)) {\n-    s_mp_setz(DIGITS(mp), ALLOC(mp));\n-    USED(mp) = 1;\n-    SIGN(mp) = ZPOS;\n-    return;\n-  }\n-\n-  \/* Shift all the significant figures over as needed *\/\n-  dst = MP_DIGITS(mp);\n-  src = dst + p;\n-  for (ix = USED(mp) - p; ix > 0; ix--)\n-    *dst++ = *src++;\n-\n-  MP_USED(mp) -= p;\n-  \/* Fill the top digits with zeroes *\/\n-  while (p-- > 0)\n-    *dst++ = 0;\n-\n-#if 0\n-  \/* Strip off any leading zeroes    *\/\n-  s_mp_clamp(mp);\n-#endif\n-\n-} \/* end s_mp_rshd() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_div_2(mp) *\/\n-\n-\/* Divide by two -- take advantage of radix properties to do it fast      *\/\n-void     s_mp_div_2(mp_int *mp)\n-{\n-  s_mp_div_2d(mp, 1);\n-\n-} \/* end s_mp_div_2() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_mul_2(mp) *\/\n-\n-mp_err s_mp_mul_2(mp_int *mp)\n-{\n-  mp_digit *pd;\n-  unsigned int      ix, used;\n-  mp_digit kin = 0;\n-\n-  \/* Shift digits leftward by 1 bit *\/\n-  used = MP_USED(mp);\n-  pd = MP_DIGITS(mp);\n-  for (ix = 0; ix < used; ix++) {\n-    mp_digit d = *pd;\n-    *pd++ = (d << 1) | kin;\n-    kin = (d >> (DIGIT_BIT - 1));\n-  }\n-\n-  \/* Deal with rollover from last digit *\/\n-  if (kin) {\n-    if (ix >= ALLOC(mp)) {\n-      mp_err res;\n-      if((res = s_mp_grow(mp, ALLOC(mp) + 1)) != MP_OKAY)\n-        return res;\n-    }\n-\n-    DIGIT(mp, ix) = kin;\n-    USED(mp) += 1;\n-  }\n-\n-  return MP_OKAY;\n-\n-} \/* end s_mp_mul_2() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_mod_2d(mp, d) *\/\n-\n-\/*\n-  Remainder the integer by 2^d, where d is a number of bits.  This\n-  amounts to a bitwise AND of the value, and does not require the full\n-  division code\n- *\/\n-void     s_mp_mod_2d(mp_int *mp, mp_digit d)\n-{\n-  mp_size  ndig = (d \/ DIGIT_BIT), nbit = (d % DIGIT_BIT);\n-  mp_size  ix;\n-  mp_digit dmask;\n-\n-  if(ndig >= USED(mp))\n-    return;\n-\n-  \/* Flush all the bits above 2^d in its digit *\/\n-  dmask = ((mp_digit)1 << nbit) - 1;\n-  DIGIT(mp, ndig) &= dmask;\n-\n-  \/* Flush all digits above the one with 2^d in it *\/\n-  for(ix = ndig + 1; ix < USED(mp); ix++)\n-    DIGIT(mp, ix) = 0;\n-\n-  s_mp_clamp(mp);\n-\n-} \/* end s_mp_mod_2d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_div_2d(mp, d) *\/\n-\n-\/*\n-  Divide the integer by 2^d, where d is a number of bits.  This\n-  amounts to a bitwise shift of the value, and does not require the\n-  full division code (used in Barrett reduction, see below)\n- *\/\n-void     s_mp_div_2d(mp_int *mp, mp_digit d)\n-{\n-  int       ix;\n-  mp_digit  save, next, mask;\n-\n-  s_mp_rshd(mp, d \/ DIGIT_BIT);\n-  d %= DIGIT_BIT;\n-  if (d) {\n-    mask = ((mp_digit)1 << d) - 1;\n-    save = 0;\n-    for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-      next = DIGIT(mp, ix) & mask;\n-      DIGIT(mp, ix) = (DIGIT(mp, ix) >> d) | (save << (DIGIT_BIT - d));\n-      save = next;\n-    }\n-  }\n-  s_mp_clamp(mp);\n-\n-} \/* end s_mp_div_2d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_norm(a, b, *d) *\/\n-\n-\/*\n-  s_mp_norm(a, b, *d)\n-\n-  Normalize a and b for division, where b is the divisor.  In order\n-  that we might make good guesses for quotient digits, we want the\n-  leading digit of b to be at least half the radix, which we\n-  accomplish by multiplying a and b by a power of 2.  The exponent\n-  (shift count) is placed in *pd, so that the remainder can be shifted\n-  back at the end of the division process.\n- *\/\n-\n-mp_err   s_mp_norm(mp_int *a, mp_int *b, mp_digit *pd)\n-{\n-  mp_digit  d;\n-  mp_digit  mask;\n-  mp_digit  b_msd;\n-  mp_err    res    = MP_OKAY;\n-\n-  d = 0;\n-  mask  = DIGIT_MAX & ~(DIGIT_MAX >> 1);        \/* mask is msb of digit *\/\n-  b_msd = DIGIT(b, USED(b) - 1);\n-  while (!(b_msd & mask)) {\n-    b_msd <<= 1;\n-    ++d;\n-  }\n-\n-  if (d) {\n-    MP_CHECKOK( s_mp_mul_2d(a, d) );\n-    MP_CHECKOK( s_mp_mul_2d(b, d) );\n-  }\n-\n-  *pd = d;\n-CLEANUP:\n-  return res;\n-\n-} \/* end s_mp_norm() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ Primitive digit arithmetic *\/\n-\n-\/* {{{ s_mp_add_d(mp, d) *\/\n-\n-\/* Add d to |mp| in place                                                 *\/\n-mp_err   s_mp_add_d(mp_int *mp, mp_digit d)    \/* unsigned digit addition *\/\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  mp_word   w, k = 0;\n-  mp_size   ix = 1;\n-\n-  w = (mp_word)DIGIT(mp, 0) + d;\n-  DIGIT(mp, 0) = ACCUM(w);\n-  k = CARRYOUT(w);\n-\n-  while(ix < USED(mp) && k) {\n-    w = (mp_word)DIGIT(mp, ix) + k;\n-    DIGIT(mp, ix) = ACCUM(w);\n-    k = CARRYOUT(w);\n-    ++ix;\n-  }\n-\n-  if(k != 0) {\n-    mp_err  res;\n-\n-    if((res = s_mp_pad(mp, USED(mp) + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(mp, ix) = (mp_digit)k;\n-  }\n-\n-  return MP_OKAY;\n-#else\n-  mp_digit * pmp = MP_DIGITS(mp);\n-  mp_digit sum, mp_i, carry = 0;\n-  mp_err   res = MP_OKAY;\n-  int used = (int)MP_USED(mp);\n-\n-  mp_i = *pmp;\n-  *pmp++ = sum = d + mp_i;\n-  carry = (sum < d);\n-  while (carry && --used > 0) {\n-    mp_i = *pmp;\n-    *pmp++ = sum = carry + mp_i;\n-    carry = !sum;\n-  }\n-  if (carry && !used) {\n-    \/* mp is growing *\/\n-    used = MP_USED(mp);\n-    MP_CHECKOK( s_mp_pad(mp, used + 1) );\n-    MP_DIGIT(mp, used) = carry;\n-  }\n-CLEANUP:\n-  return res;\n-#endif\n-} \/* end s_mp_add_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_sub_d(mp, d) *\/\n-\n-\/* Subtract d from |mp| in place, assumes |mp| > d                        *\/\n-mp_err   s_mp_sub_d(mp_int *mp, mp_digit d)    \/* unsigned digit subtract *\/\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-  mp_word   w, b = 0;\n-  mp_size   ix = 1;\n-\n-  \/* Compute initial subtraction    *\/\n-  w = (RADIX + (mp_word)DIGIT(mp, 0)) - d;\n-  b = CARRYOUT(w) ? 0 : 1;\n-  DIGIT(mp, 0) = ACCUM(w);\n-\n-  \/* Propagate borrows leftward     *\/\n-  while(b && ix < USED(mp)) {\n-    w = (RADIX + (mp_word)DIGIT(mp, ix)) - b;\n-    b = CARRYOUT(w) ? 0 : 1;\n-    DIGIT(mp, ix) = ACCUM(w);\n-    ++ix;\n-  }\n-\n-  \/* Remove leading zeroes          *\/\n-  s_mp_clamp(mp);\n-\n-  \/* If we have a borrow out, it's a violation of the input invariant *\/\n-  if(b)\n-    return MP_RANGE;\n-  else\n-    return MP_OKAY;\n-#else\n-  mp_digit *pmp = MP_DIGITS(mp);\n-  mp_digit mp_i, diff, borrow;\n-  mp_size  used = MP_USED(mp);\n-\n-  mp_i = *pmp;\n-  *pmp++ = diff = mp_i - d;\n-  borrow = (diff > mp_i);\n-  while (borrow && --used) {\n-    mp_i = *pmp;\n-    *pmp++ = diff = mp_i - borrow;\n-    borrow = (diff > mp_i);\n-  }\n-  s_mp_clamp(mp);\n-  return (borrow && !used) ? MP_RANGE : MP_OKAY;\n-#endif\n-} \/* end s_mp_sub_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_mul_d(a, d) *\/\n-\n-\/* Compute a = a * d, single digit multiplication                         *\/\n-mp_err   s_mp_mul_d(mp_int *a, mp_digit d)\n-{\n-  mp_err  res;\n-  mp_size used;\n-  int     pow;\n-\n-  if (!d) {\n-    mp_zero(a);\n-    return MP_OKAY;\n-  }\n-  if (d == 1)\n-    return MP_OKAY;\n-  if (0 <= (pow = s_mp_ispow2d(d))) {\n-    return s_mp_mul_2d(a, (mp_digit)pow);\n-  }\n-\n-  used = MP_USED(a);\n-  MP_CHECKOK( s_mp_pad(a, used + 1) );\n-\n-  s_mpv_mul_d(MP_DIGITS(a), used, d, MP_DIGITS(a));\n-\n-  s_mp_clamp(a);\n-\n-CLEANUP:\n-  return res;\n-\n-} \/* end s_mp_mul_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_div_d(mp, d, r) *\/\n-\n-\/*\n-  s_mp_div_d(mp, d, r)\n-\n-  Compute the quotient mp = mp \/ d and remainder r = mp mod d, for a\n-  single digit d.  If r is null, the remainder will be discarded.\n- *\/\n-\n-mp_err   s_mp_div_d(mp_int *mp, mp_digit d, mp_digit *r)\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)\n-  mp_word   w = 0, q;\n-#else\n-  mp_digit  w = 0, q;\n-#endif\n-  int       ix;\n-  mp_err    res;\n-  mp_int    quot;\n-  mp_int    rem;\n-\n-  if(d == 0)\n-    return MP_RANGE;\n-  if (d == 1) {\n-    if (r)\n-      *r = 0;\n-    return MP_OKAY;\n-  }\n-  \/* could check for power of 2 here, but mp_div_d does that. *\/\n-  if (MP_USED(mp) == 1) {\n-    mp_digit n   = MP_DIGIT(mp,0);\n-    mp_digit rem;\n-\n-    q   = n \/ d;\n-    rem = n % d;\n-    MP_DIGIT(mp,0) = q;\n-    if (r)\n-      *r = rem;\n-    return MP_OKAY;\n-  }\n-\n-  MP_DIGITS(&rem)  = 0;\n-  MP_DIGITS(&quot) = 0;\n-  \/* Make room for the quotient *\/\n-  MP_CHECKOK( mp_init_size(&quot, USED(mp), FLAG(mp)) );\n-\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    w = (w << DIGIT_BIT) | DIGIT(mp, ix);\n-\n-    if(w >= d) {\n-      q = w \/ d;\n-      w = w % d;\n-    } else {\n-      q = 0;\n-    }\n-\n-    s_mp_lshd(&quot, 1);\n-    DIGIT(&quot, 0) = (mp_digit)q;\n-  }\n-#else\n-  {\n-    mp_digit p;\n-#if !defined(MP_ASSEMBLY_DIV_2DX1D)\n-    mp_digit norm;\n-#endif\n-\n-    MP_CHECKOK( mp_init_copy(&rem, mp) );\n-\n-#if !defined(MP_ASSEMBLY_DIV_2DX1D)\n-    MP_DIGIT(&quot, 0) = d;\n-    MP_CHECKOK( s_mp_norm(&rem, &quot, &norm) );\n-    if (norm)\n-      d <<= norm;\n-    MP_DIGIT(&quot, 0) = 0;\n-#endif\n-\n-    p = 0;\n-    for (ix = USED(&rem) - 1; ix >= 0; ix--) {\n-      w = DIGIT(&rem, ix);\n-\n-      if (p) {\n-        MP_CHECKOK( s_mpv_div_2dx1d(p, w, d, &q, &w) );\n-      } else if (w >= d) {\n-        q = w \/ d;\n-        w = w % d;\n-      } else {\n-        q = 0;\n-      }\n-\n-      MP_CHECKOK( s_mp_lshd(&quot, 1) );\n-      DIGIT(&quot, 0) = q;\n-      p = w;\n-    }\n-#if !defined(MP_ASSEMBLY_DIV_2DX1D)\n-    if (norm)\n-      w >>= norm;\n-#endif\n-  }\n-#endif\n-\n-  \/* Deliver the remainder, if desired *\/\n-  if(r)\n-    *r = (mp_digit)w;\n-\n-  s_mp_clamp(&quot);\n-  mp_exch(&quot, mp);\n-CLEANUP:\n-  mp_clear(&quot);\n-  mp_clear(&rem);\n-\n-  return res;\n-} \/* end s_mp_div_d() *\/\n-\n-\/* }}} *\/\n-\n-\n-\/* }}} *\/\n-\n-\/* {{{ Primitive full arithmetic *\/\n-\n-\/* {{{ s_mp_add(a, b) *\/\n-\n-\/* Compute a = |a| + |b|                                                  *\/\n-mp_err   s_mp_add(mp_int *a, const mp_int *b)  \/* magnitude addition      *\/\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  mp_word   w = 0;\n-#else\n-  mp_digit  d, sum, carry = 0;\n-#endif\n-  mp_digit *pa, *pb;\n-  mp_size   ix;\n-  mp_size   used;\n-  mp_err    res;\n-\n-  \/* Make sure a has enough precision for the output value *\/\n-  if((USED(b) > USED(a)) && (res = s_mp_pad(a, USED(b))) != MP_OKAY)\n-    return res;\n-\n-  \/*\n-    Add up all digits up to the precision of b.  If b had initially\n-    the same precision as a, or greater, we took care of it by the\n-    padding step above, so there is no problem.  If b had initially\n-    less precision, we'll have to make sure the carry out is duly\n-    propagated upward among the higher-order digits of the sum.\n-   *\/\n-  pa = MP_DIGITS(a);\n-  pb = MP_DIGITS(b);\n-  used = MP_USED(b);\n-  for(ix = 0; ix < used; ix++) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-    w = w + *pa + *pb++;\n-    *pa++ = ACCUM(w);\n-    w = CARRYOUT(w);\n-#else\n-    d = *pa;\n-    sum = d + *pb++;\n-    d = (sum < d);                      \/* detect overflow *\/\n-    *pa++ = sum += carry;\n-    carry = d + (sum < carry);          \/* detect overflow *\/\n-#endif\n-  }\n-\n-  \/* If we run out of 'b' digits before we're actually done, make\n-     sure the carries get propagated upward...\n-   *\/\n-  used = MP_USED(a);\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  while (w && ix < used) {\n-    w = w + *pa;\n-    *pa++ = ACCUM(w);\n-    w = CARRYOUT(w);\n-    ++ix;\n-  }\n-#else\n-  while (carry && ix < used) {\n-    sum = carry + *pa;\n-    *pa++ = sum;\n-    carry = !sum;\n-    ++ix;\n-  }\n-#endif\n-\n-  \/* If there's an overall carry out, increase precision and include\n-     it.  We could have done this initially, but why touch the memory\n-     allocator unless we're sure we have to?\n-   *\/\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  if (w) {\n-    if((res = s_mp_pad(a, used + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(a, ix) = (mp_digit)w;\n-  }\n-#else\n-  if (carry) {\n-    if((res = s_mp_pad(a, used + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(a, used) = carry;\n-  }\n-#endif\n-\n-  return MP_OKAY;\n-} \/* end s_mp_add() *\/\n-\n-\/* }}} *\/\n-\n-\/* Compute c = |a| + |b|         *\/ \/* magnitude addition      *\/\n-mp_err   s_mp_add_3arg(const mp_int *a, const mp_int *b, mp_int *c)\n-{\n-  mp_digit *pa, *pb, *pc;\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  mp_word   w = 0;\n-#else\n-  mp_digit  sum, carry = 0, d;\n-#endif\n-  mp_size   ix;\n-  mp_size   used;\n-  mp_err    res;\n-\n-  MP_SIGN(c) = MP_SIGN(a);\n-  if (MP_USED(a) < MP_USED(b)) {\n-    const mp_int *xch = a;\n-    a = b;\n-    b = xch;\n-  }\n-\n-  \/* Make sure a has enough precision for the output value *\/\n-  if (MP_OKAY != (res = s_mp_pad(c, MP_USED(a))))\n-    return res;\n-\n-  \/*\n-    Add up all digits up to the precision of b.  If b had initially\n-    the same precision as a, or greater, we took care of it by the\n-    exchange step above, so there is no problem.  If b had initially\n-    less precision, we'll have to make sure the carry out is duly\n-    propagated upward among the higher-order digits of the sum.\n-   *\/\n-  pa = MP_DIGITS(a);\n-  pb = MP_DIGITS(b);\n-  pc = MP_DIGITS(c);\n-  used = MP_USED(b);\n-  for (ix = 0; ix < used; ix++) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-    w = w + *pa++ + *pb++;\n-    *pc++ = ACCUM(w);\n-    w = CARRYOUT(w);\n-#else\n-    d = *pa++;\n-    sum = d + *pb++;\n-    d = (sum < d);                      \/* detect overflow *\/\n-    *pc++ = sum += carry;\n-    carry = d + (sum < carry);          \/* detect overflow *\/\n-#endif\n-  }\n-\n-  \/* If we run out of 'b' digits before we're actually done, make\n-     sure the carries get propagated upward...\n-   *\/\n-  for (used = MP_USED(a); ix < used; ++ix) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-    w = w + *pa++;\n-    *pc++ = ACCUM(w);\n-    w = CARRYOUT(w);\n-#else\n-    *pc++ = sum = carry + *pa++;\n-    carry = (sum < carry);\n-#endif\n-  }\n-\n-  \/* If there's an overall carry out, increase precision and include\n-     it.  We could have done this initially, but why touch the memory\n-     allocator unless we're sure we have to?\n-   *\/\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  if (w) {\n-    if((res = s_mp_pad(c, used + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(c, used) = (mp_digit)w;\n-    ++used;\n-  }\n-#else\n-  if (carry) {\n-    if((res = s_mp_pad(c, used + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(c, used) = carry;\n-    ++used;\n-  }\n-#endif\n-  MP_USED(c) = used;\n-  return MP_OKAY;\n-}\n-\/* {{{ s_mp_add_offset(a, b, offset) *\/\n-\n-\/* Compute a = |a| + ( |b| * (RADIX ** offset) )             *\/\n-mp_err   s_mp_add_offset(mp_int *a, mp_int *b, mp_size offset)\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  mp_word   w, k = 0;\n-#else\n-  mp_digit  d, sum, carry = 0;\n-#endif\n-  mp_size   ib;\n-  mp_size   ia;\n-  mp_size   lim;\n-  mp_err    res;\n-\n-  \/* Make sure a has enough precision for the output value *\/\n-  lim = MP_USED(b) + offset;\n-  if((lim > USED(a)) && (res = s_mp_pad(a, lim)) != MP_OKAY)\n-    return res;\n-\n-  \/*\n-    Add up all digits up to the precision of b.  If b had initially\n-    the same precision as a, or greater, we took care of it by the\n-    padding step above, so there is no problem.  If b had initially\n-    less precision, we'll have to make sure the carry out is duly\n-    propagated upward among the higher-order digits of the sum.\n-   *\/\n-  lim = USED(b);\n-  for(ib = 0, ia = offset; ib < lim; ib++, ia++) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-    w = (mp_word)DIGIT(a, ia) + DIGIT(b, ib) + k;\n-    DIGIT(a, ia) = ACCUM(w);\n-    k = CARRYOUT(w);\n-#else\n-    d = MP_DIGIT(a, ia);\n-    sum = d + MP_DIGIT(b, ib);\n-    d = (sum < d);\n-    MP_DIGIT(a,ia) = sum += carry;\n-    carry = d + (sum < carry);\n-#endif\n-  }\n-\n-  \/* If we run out of 'b' digits before we're actually done, make\n-     sure the carries get propagated upward...\n-   *\/\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  for (lim = MP_USED(a); k && (ia < lim); ++ia) {\n-    w = (mp_word)DIGIT(a, ia) + k;\n-    DIGIT(a, ia) = ACCUM(w);\n-    k = CARRYOUT(w);\n-  }\n-#else\n-  for (lim = MP_USED(a); carry && (ia < lim); ++ia) {\n-    d = MP_DIGIT(a, ia);\n-    MP_DIGIT(a,ia) = sum = d + carry;\n-    carry = (sum < d);\n-  }\n-#endif\n-\n-  \/* If there's an overall carry out, increase precision and include\n-     it.  We could have done this initially, but why touch the memory\n-     allocator unless we're sure we have to?\n-   *\/\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_ADD_WORD)\n-  if(k) {\n-    if((res = s_mp_pad(a, USED(a) + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(a, ia) = (mp_digit)k;\n-  }\n-#else\n-  if (carry) {\n-    if((res = s_mp_pad(a, lim + 1)) != MP_OKAY)\n-      return res;\n-\n-    DIGIT(a, lim) = carry;\n-  }\n-#endif\n-  s_mp_clamp(a);\n-\n-  return MP_OKAY;\n-\n-} \/* end s_mp_add_offset() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_sub(a, b) *\/\n-\n-\/* Compute a = |a| - |b|, assumes |a| >= |b|                              *\/\n-mp_err   s_mp_sub(mp_int *a, const mp_int *b)  \/* magnitude subtract      *\/\n-{\n-  mp_digit *pa, *pb, *limit;\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-  mp_sword  w = 0;\n-#else\n-  mp_digit  d, diff, borrow = 0;\n-#endif\n-\n-  \/*\n-    Subtract and propagate borrow.  Up to the precision of b, this\n-    accounts for the digits of b; after that, we just make sure the\n-    carries get to the right place.  This saves having to pad b out to\n-    the precision of a just to make the loops work right...\n-   *\/\n-  pa = MP_DIGITS(a);\n-  pb = MP_DIGITS(b);\n-  limit = pb + MP_USED(b);\n-  while (pb < limit) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-    w = w + *pa - *pb++;\n-    *pa++ = ACCUM(w);\n-    w >>= MP_DIGIT_BIT;\n-#else\n-    d = *pa;\n-    diff = d - *pb++;\n-    d = (diff > d);                             \/* detect borrow *\/\n-    if (borrow && --diff == MP_DIGIT_MAX)\n-      ++d;\n-    *pa++ = diff;\n-    borrow = d;\n-#endif\n-  }\n-  limit = MP_DIGITS(a) + MP_USED(a);\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-  while (w && pa < limit) {\n-    w = w + *pa;\n-    *pa++ = ACCUM(w);\n-    w >>= MP_DIGIT_BIT;\n-  }\n-#else\n-  while (borrow && pa < limit) {\n-    d = *pa;\n-    *pa++ = diff = d - borrow;\n-    borrow = (diff > d);\n-  }\n-#endif\n-\n-  \/* Clobber any leading zeroes we created    *\/\n-  s_mp_clamp(a);\n-\n-  \/*\n-     If there was a borrow out, then |b| > |a| in violation\n-     of our input invariant.  We've already done the work,\n-     but we'll at least complain about it...\n-   *\/\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-  return w ? MP_RANGE : MP_OKAY;\n-#else\n-  return borrow ? MP_RANGE : MP_OKAY;\n-#endif\n-} \/* end s_mp_sub() *\/\n-\n-\/* }}} *\/\n-\n-\/* Compute c = |a| - |b|, assumes |a| >= |b| *\/ \/* magnitude subtract      *\/\n-mp_err   s_mp_sub_3arg(const mp_int *a, const mp_int *b, mp_int *c)\n-{\n-  mp_digit *pa, *pb, *pc;\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-  mp_sword  w = 0;\n-#else\n-  mp_digit  d, diff, borrow = 0;\n-#endif\n-  int       ix, limit;\n-  mp_err    res;\n-\n-  MP_SIGN(c) = MP_SIGN(a);\n-\n-  \/* Make sure a has enough precision for the output value *\/\n-  if (MP_OKAY != (res = s_mp_pad(c, MP_USED(a))))\n-    return res;\n-\n-  \/*\n-    Subtract and propagate borrow.  Up to the precision of b, this\n-    accounts for the digits of b; after that, we just make sure the\n-    carries get to the right place.  This saves having to pad b out to\n-    the precision of a just to make the loops work right...\n-   *\/\n-  pa = MP_DIGITS(a);\n-  pb = MP_DIGITS(b);\n-  pc = MP_DIGITS(c);\n-  limit = MP_USED(b);\n-  for (ix = 0; ix < limit; ++ix) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-    w = w + *pa++ - *pb++;\n-    *pc++ = ACCUM(w);\n-    w >>= MP_DIGIT_BIT;\n-#else\n-    d = *pa++;\n-    diff = d - *pb++;\n-    d = (diff > d);\n-    if (borrow && --diff == MP_DIGIT_MAX)\n-      ++d;\n-    *pc++ = diff;\n-    borrow = d;\n-#endif\n-  }\n-  for (limit = MP_USED(a); ix < limit; ++ix) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-    w = w + *pa++;\n-    *pc++ = ACCUM(w);\n-    w >>= MP_DIGIT_BIT;\n-#else\n-    d = *pa++;\n-    *pc++ = diff = d - borrow;\n-    borrow = (diff > d);\n-#endif\n-  }\n-\n-  \/* Clobber any leading zeroes we created    *\/\n-  MP_USED(c) = ix;\n-  s_mp_clamp(c);\n-\n-  \/*\n-     If there was a borrow out, then |b| > |a| in violation\n-     of our input invariant.  We've already done the work,\n-     but we'll at least complain about it...\n-   *\/\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_SUB_WORD)\n-  return w ? MP_RANGE : MP_OKAY;\n-#else\n-  return borrow ? MP_RANGE : MP_OKAY;\n-#endif\n-}\n-\/* {{{ s_mp_mul(a, b) *\/\n-\n-\/* Compute a = |a| * |b|                                                  *\/\n-mp_err   s_mp_mul(mp_int *a, const mp_int *b)\n-{\n-  return mp_mul(a, b, a);\n-} \/* end s_mp_mul() *\/\n-\n-\/* }}} *\/\n-\n-#if defined(MP_USE_UINT_DIGIT) && defined(MP_USE_LONG_LONG_MULTIPLY)\n-\/* This trick works on Sparc V8 CPUs with the Workshop compilers. *\/\n-#define MP_MUL_DxD(a, b, Phi, Plo) \\\n-  { unsigned long long product = (unsigned long long)a * b; \\\n-    Plo = (mp_digit)product; \\\n-    Phi = (mp_digit)(product >> MP_DIGIT_BIT); }\n-#elif defined(OSF1)\n-#define MP_MUL_DxD(a, b, Phi, Plo) \\\n-  { Plo = asm (\"mulq %a0, %a1, %v0\", a, b);\\\n-    Phi = asm (\"umulh %a0, %a1, %v0\", a, b); }\n-#else\n-#define MP_MUL_DxD(a, b, Phi, Plo) \\\n-  { mp_digit a0b1, a1b0; \\\n-    Plo = (a & MP_HALF_DIGIT_MAX) * (b & MP_HALF_DIGIT_MAX); \\\n-    Phi = (a >> MP_HALF_DIGIT_BIT) * (b >> MP_HALF_DIGIT_BIT); \\\n-    a0b1 = (a & MP_HALF_DIGIT_MAX) * (b >> MP_HALF_DIGIT_BIT); \\\n-    a1b0 = (a >> MP_HALF_DIGIT_BIT) * (b & MP_HALF_DIGIT_MAX); \\\n-    a1b0 += a0b1; \\\n-    Phi += a1b0 >> MP_HALF_DIGIT_BIT; \\\n-    if (a1b0 < a0b1)  \\\n-      Phi += MP_HALF_RADIX; \\\n-    a1b0 <<= MP_HALF_DIGIT_BIT; \\\n-    Plo += a1b0; \\\n-    if (Plo < a1b0) \\\n-      ++Phi; \\\n-  }\n-#endif\n-\n-#if !defined(MP_ASSEMBLY_MULTIPLY)\n-\/* c = a * b *\/\n-void s_mpv_mul_d(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *c)\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)\n-  mp_digit   d = 0;\n-\n-  \/* Inner product:  Digits of a *\/\n-  while (a_len--) {\n-    mp_word w = ((mp_word)b * *a++) + d;\n-    *c++ = ACCUM(w);\n-    d = CARRYOUT(w);\n-  }\n-  *c = d;\n-#else\n-  mp_digit carry = 0;\n-  while (a_len--) {\n-    mp_digit a_i = *a++;\n-    mp_digit a0b0, a1b1;\n-\n-    MP_MUL_DxD(a_i, b, a1b1, a0b0);\n-\n-    a0b0 += carry;\n-    if (a0b0 < carry)\n-      ++a1b1;\n-    *c++ = a0b0;\n-    carry = a1b1;\n-  }\n-  *c = carry;\n-#endif\n-}\n-\n-\/* c += a * b *\/\n-void s_mpv_mul_d_add(const mp_digit *a, mp_size a_len, mp_digit b,\n-                              mp_digit *c)\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)\n-  mp_digit   d = 0;\n-\n-  \/* Inner product:  Digits of a *\/\n-  while (a_len--) {\n-    mp_word w = ((mp_word)b * *a++) + *c + d;\n-    *c++ = ACCUM(w);\n-    d = CARRYOUT(w);\n-  }\n-  *c = d;\n-#else\n-  mp_digit carry = 0;\n-  while (a_len--) {\n-    mp_digit a_i = *a++;\n-    mp_digit a0b0, a1b1;\n-\n-    MP_MUL_DxD(a_i, b, a1b1, a0b0);\n-\n-    a0b0 += carry;\n-    if (a0b0 < carry)\n-      ++a1b1;\n-    a0b0 += a_i = *c;\n-    if (a0b0 < a_i)\n-      ++a1b1;\n-    *c++ = a0b0;\n-    carry = a1b1;\n-  }\n-  *c = carry;\n-#endif\n-}\n-\n-\/* Presently, this is only used by the Montgomery arithmetic code. *\/\n-\/* c += a * b *\/\n-void s_mpv_mul_d_add_prop(const mp_digit *a, mp_size a_len, mp_digit b, mp_digit *c)\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)\n-  mp_digit   d = 0;\n-\n-  \/* Inner product:  Digits of a *\/\n-  while (a_len--) {\n-    mp_word w = ((mp_word)b * *a++) + *c + d;\n-    *c++ = ACCUM(w);\n-    d = CARRYOUT(w);\n-  }\n-\n-  while (d) {\n-    mp_word w = (mp_word)*c + d;\n-    *c++ = ACCUM(w);\n-    d = CARRYOUT(w);\n-  }\n-#else\n-  mp_digit carry = 0;\n-  while (a_len--) {\n-    mp_digit a_i = *a++;\n-    mp_digit a0b0, a1b1;\n-\n-    MP_MUL_DxD(a_i, b, a1b1, a0b0);\n-\n-    a0b0 += carry;\n-    if (a0b0 < carry)\n-      ++a1b1;\n-\n-    a0b0 += a_i = *c;\n-    if (a0b0 < a_i)\n-      ++a1b1;\n-\n-    *c++ = a0b0;\n-    carry = a1b1;\n-  }\n-  while (carry) {\n-    mp_digit c_i = *c;\n-    carry += c_i;\n-    *c++ = carry;\n-    carry = carry < c_i;\n-  }\n-#endif\n-}\n-#endif\n-\n-#if defined(MP_USE_UINT_DIGIT) && defined(MP_USE_LONG_LONG_MULTIPLY)\n-\/* This trick works on Sparc V8 CPUs with the Workshop compilers. *\/\n-#define MP_SQR_D(a, Phi, Plo) \\\n-  { unsigned long long square = (unsigned long long)a * a; \\\n-    Plo = (mp_digit)square; \\\n-    Phi = (mp_digit)(square >> MP_DIGIT_BIT); }\n-#elif defined(OSF1)\n-#define MP_SQR_D(a, Phi, Plo) \\\n-  { Plo = asm (\"mulq  %a0, %a0, %v0\", a);\\\n-    Phi = asm (\"umulh %a0, %a0, %v0\", a); }\n-#else\n-#define MP_SQR_D(a, Phi, Plo) \\\n-  { mp_digit Pmid; \\\n-    Plo  = (a  & MP_HALF_DIGIT_MAX) * (a  & MP_HALF_DIGIT_MAX); \\\n-    Phi  = (a >> MP_HALF_DIGIT_BIT) * (a >> MP_HALF_DIGIT_BIT); \\\n-    Pmid = (a  & MP_HALF_DIGIT_MAX) * (a >> MP_HALF_DIGIT_BIT); \\\n-    Phi += Pmid >> (MP_HALF_DIGIT_BIT - 1);  \\\n-    Pmid <<= (MP_HALF_DIGIT_BIT + 1);  \\\n-    Plo += Pmid;  \\\n-    if (Plo < Pmid)  \\\n-      ++Phi;  \\\n-  }\n-#endif\n-\n-#if !defined(MP_ASSEMBLY_SQUARE)\n-\/* Add the squares of the digits of a to the digits of b. *\/\n-void s_mpv_sqr_add_prop(const mp_digit *pa, mp_size a_len, mp_digit *ps)\n-{\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_MUL_WORD)\n-  mp_word  w;\n-  mp_digit d;\n-  mp_size  ix;\n-\n-  w  = 0;\n-#define ADD_SQUARE(n) \\\n-    d = pa[n]; \\\n-    w += (d * (mp_word)d) + ps[2*n]; \\\n-    ps[2*n] = ACCUM(w); \\\n-    w = (w >> DIGIT_BIT) + ps[2*n+1]; \\\n-    ps[2*n+1] = ACCUM(w); \\\n-    w = (w >> DIGIT_BIT)\n-\n-  for (ix = a_len; ix >= 4; ix -= 4) {\n-    ADD_SQUARE(0);\n-    ADD_SQUARE(1);\n-    ADD_SQUARE(2);\n-    ADD_SQUARE(3);\n-    pa += 4;\n-    ps += 8;\n-  }\n-  if (ix) {\n-    ps += 2*ix;\n-    pa += ix;\n-    switch (ix) {\n-    case 3: ADD_SQUARE(-3); \/* FALLTHRU *\/\n-    case 2: ADD_SQUARE(-2); \/* FALLTHRU *\/\n-    case 1: ADD_SQUARE(-1); \/* FALLTHRU *\/\n-    case 0: break;\n-    }\n-  }\n-  while (w) {\n-    w += *ps;\n-    *ps++ = ACCUM(w);\n-    w = (w >> DIGIT_BIT);\n-  }\n-#else\n-  mp_digit carry = 0;\n-  while (a_len--) {\n-    mp_digit a_i = *pa++;\n-    mp_digit a0a0, a1a1;\n-\n-    MP_SQR_D(a_i, a1a1, a0a0);\n-\n-    \/* here a1a1 and a0a0 constitute a_i ** 2 *\/\n-    a0a0 += carry;\n-    if (a0a0 < carry)\n-      ++a1a1;\n-\n-    \/* now add to ps *\/\n-    a0a0 += a_i = *ps;\n-    if (a0a0 < a_i)\n-      ++a1a1;\n-    *ps++ = a0a0;\n-    a1a1 += a_i = *ps;\n-    carry = (a1a1 < a_i);\n-    *ps++ = a1a1;\n-  }\n-  while (carry) {\n-    mp_digit s_i = *ps;\n-    carry += s_i;\n-    *ps++ = carry;\n-    carry = carry < s_i;\n-  }\n-#endif\n-}\n-#endif\n-\n-#if (defined(MP_NO_MP_WORD) || defined(MP_NO_DIV_WORD)) \\\n-&& !defined(MP_ASSEMBLY_DIV_2DX1D)\n-\/*\n-** Divide 64-bit (Nhi,Nlo) by 32-bit divisor, which must be normalized\n-** so its high bit is 1.   This code is from NSPR.\n-*\/\n-mp_err s_mpv_div_2dx1d(mp_digit Nhi, mp_digit Nlo, mp_digit divisor,\n-                       mp_digit *qp, mp_digit *rp)\n-{\n-    mp_digit d1, d0, q1, q0;\n-    mp_digit r1, r0, m;\n-\n-    d1 = divisor >> MP_HALF_DIGIT_BIT;\n-    d0 = divisor & MP_HALF_DIGIT_MAX;\n-    r1 = Nhi % d1;\n-    q1 = Nhi \/ d1;\n-    m = q1 * d0;\n-    r1 = (r1 << MP_HALF_DIGIT_BIT) | (Nlo >> MP_HALF_DIGIT_BIT);\n-    if (r1 < m) {\n-        q1--, r1 += divisor;\n-        if (r1 >= divisor && r1 < m) {\n-            q1--, r1 += divisor;\n-        }\n-    }\n-    r1 -= m;\n-    r0 = r1 % d1;\n-    q0 = r1 \/ d1;\n-    m = q0 * d0;\n-    r0 = (r0 << MP_HALF_DIGIT_BIT) | (Nlo & MP_HALF_DIGIT_MAX);\n-    if (r0 < m) {\n-        q0--, r0 += divisor;\n-        if (r0 >= divisor && r0 < m) {\n-            q0--, r0 += divisor;\n-        }\n-    }\n-    if (qp)\n-        *qp = (q1 << MP_HALF_DIGIT_BIT) | q0;\n-    if (rp)\n-        *rp = r0 - m;\n-    return MP_OKAY;\n-}\n-#endif\n-\n-#if MP_SQUARE\n-\/* {{{ s_mp_sqr(a) *\/\n-\n-mp_err   s_mp_sqr(mp_int *a)\n-{\n-  mp_err   res;\n-  mp_int   tmp;\n-  tmp.flag = (mp_sign)0;\n-\n-  if((res = mp_init_size(&tmp, 2 * USED(a), FLAG(a))) != MP_OKAY)\n-    return res;\n-  res = mp_sqr(a, &tmp);\n-  if (res == MP_OKAY) {\n-    s_mp_exch(&tmp, a);\n-  }\n-  mp_clear(&tmp);\n-  return res;\n-}\n-\n-\/* }}} *\/\n-#endif\n-\n-\/* {{{ s_mp_div(a, b) *\/\n-\n-\/*\n-  s_mp_div(a, b)\n-\n-  Compute a = a \/ b and b = a mod b.  Assumes b > a.\n- *\/\n-\n-mp_err   s_mp_div(mp_int *rem,  \/* i: dividend, o: remainder *\/\n-                  mp_int *div,  \/* i: divisor                *\/\n-                  mp_int *quot) \/* i: 0;        o: quotient  *\/\n-{\n-  mp_int   part, t;\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)\n-  mp_word  q_msd;\n-#else\n-  mp_digit q_msd;\n-#endif\n-  mp_err   res;\n-  mp_digit d;\n-  mp_digit div_msd;\n-  int      ix;\n-\n-  t.dp = (mp_digit *)NULL;\n-\n-  if(mp_cmp_z(div) == 0)\n-    return MP_RANGE;\n-\n-  \/* Shortcut if divisor is power of two *\/\n-  if((ix = s_mp_ispow2(div)) >= 0) {\n-    MP_CHECKOK( mp_copy(rem, quot) );\n-    s_mp_div_2d(quot, (mp_digit)ix);\n-    s_mp_mod_2d(rem,  (mp_digit)ix);\n-\n-    return MP_OKAY;\n-  }\n-\n-  DIGITS(&t) = 0;\n-  MP_SIGN(rem) = ZPOS;\n-  MP_SIGN(div) = ZPOS;\n-\n-  \/* A working temporary for division     *\/\n-  MP_CHECKOK( mp_init_size(&t, MP_ALLOC(rem), FLAG(rem)));\n-\n-  \/* Normalize to optimize guessing       *\/\n-  MP_CHECKOK( s_mp_norm(rem, div, &d) );\n-\n-  part = *rem;\n-\n-  \/* Perform the division itself...woo!   *\/\n-  MP_USED(quot) = MP_ALLOC(quot);\n-\n-  \/* Find a partial substring of rem which is at least div *\/\n-  \/* If we didn't find one, we're finished dividing    *\/\n-  while (MP_USED(rem) > MP_USED(div) || s_mp_cmp(rem, div) >= 0) {\n-    int i;\n-    int unusedRem;\n-\n-    unusedRem = MP_USED(rem) - MP_USED(div);\n-    MP_DIGITS(&part) = MP_DIGITS(rem) + unusedRem;\n-    MP_ALLOC(&part)  = MP_ALLOC(rem)  - unusedRem;\n-    MP_USED(&part)   = MP_USED(div);\n-    if (s_mp_cmp(&part, div) < 0) {\n-      -- unusedRem;\n-#if MP_ARGCHK == 2\n-      assert(unusedRem >= 0);\n-#endif\n-      -- MP_DIGITS(&part);\n-      ++ MP_USED(&part);\n-      ++ MP_ALLOC(&part);\n-    }\n-\n-    \/* Compute a guess for the next quotient digit       *\/\n-    q_msd = MP_DIGIT(&part, MP_USED(&part) - 1);\n-    div_msd = MP_DIGIT(div, MP_USED(div) - 1);\n-    if (q_msd >= div_msd) {\n-      q_msd = 1;\n-    } else if (MP_USED(&part) > 1) {\n-#if !defined(MP_NO_MP_WORD) && !defined(MP_NO_DIV_WORD)\n-      q_msd = (q_msd << MP_DIGIT_BIT) | MP_DIGIT(&part, MP_USED(&part) - 2);\n-      q_msd \/= div_msd;\n-      if (q_msd == RADIX)\n-        --q_msd;\n-#else\n-      mp_digit r;\n-      MP_CHECKOK( s_mpv_div_2dx1d(q_msd, MP_DIGIT(&part, MP_USED(&part) - 2),\n-                                  div_msd, &q_msd, &r) );\n-#endif\n-    } else {\n-      q_msd = 0;\n-    }\n-#if MP_ARGCHK == 2\n-    assert(q_msd > 0); \/* This case should never occur any more. *\/\n-#endif\n-    if (q_msd <= 0)\n-      break;\n-\n-    \/* See what that multiplies out to                   *\/\n-    mp_copy(div, &t);\n-    MP_CHECKOK( s_mp_mul_d(&t, (mp_digit)q_msd) );\n-\n-    \/*\n-       If it's too big, back it off.  We should not have to do this\n-       more than once, or, in rare cases, twice.  Knuth describes a\n-       method by which this could be reduced to a maximum of once, but\n-       I didn't implement that here.\n-     * When using s_mpv_div_2dx1d, we may have to do this 3 times.\n-     *\/\n-    for (i = 4; s_mp_cmp(&t, &part) > 0 && i > 0; --i) {\n-      --q_msd;\n-      s_mp_sub(&t, div);        \/* t -= div *\/\n-    }\n-    if (i < 0) {\n-      res = MP_RANGE;\n-      goto CLEANUP;\n-    }\n-\n-    \/* At this point, q_msd should be the right next digit   *\/\n-    MP_CHECKOK( s_mp_sub(&part, &t) );  \/* part -= t *\/\n-    s_mp_clamp(rem);\n-\n-    \/*\n-      Include the digit in the quotient.  We allocated enough memory\n-      for any quotient we could ever possibly get, so we should not\n-      have to check for failures here\n-     *\/\n-    MP_DIGIT(quot, unusedRem) = (mp_digit)q_msd;\n-  }\n-\n-  \/* Denormalize remainder                *\/\n-  if (d) {\n-    s_mp_div_2d(rem, d);\n-  }\n-\n-  s_mp_clamp(quot);\n-\n-CLEANUP:\n-  mp_clear(&t);\n-\n-  return res;\n-\n-} \/* end s_mp_div() *\/\n-\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_2expt(a, k) *\/\n-\n-mp_err   s_mp_2expt(mp_int *a, mp_digit k)\n-{\n-  mp_err    res;\n-  mp_size   dig, bit;\n-\n-  dig = k \/ DIGIT_BIT;\n-  bit = k % DIGIT_BIT;\n-\n-  mp_zero(a);\n-  if((res = s_mp_pad(a, dig + 1)) != MP_OKAY)\n-    return res;\n-\n-  DIGIT(a, dig) |= ((mp_digit)1 << bit);\n-\n-  return MP_OKAY;\n-\n-} \/* end s_mp_2expt() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_reduce(x, m, mu) *\/\n-\n-\/*\n-  Compute Barrett reduction, x (mod m), given a precomputed value for\n-  mu = b^2k \/ m, where b = RADIX and k = #digits(m).  This should be\n-  faster than straight division, when many reductions by the same\n-  value of m are required (such as in modular exponentiation).  This\n-  can nearly halve the time required to do modular exponentiation,\n-  as compared to using the full integer divide to reduce.\n-\n-  This algorithm was derived from the _Handbook of Applied\n-  Cryptography_ by Menezes, Oorschot and VanStone, Ch. 14,\n-  pp. 603-604.\n- *\/\n-\n-mp_err   s_mp_reduce(mp_int *x, const mp_int *m, const mp_int *mu)\n-{\n-  mp_int   q;\n-  mp_err   res;\n-\n-  if((res = mp_init_copy(&q, x)) != MP_OKAY)\n-    return res;\n-\n-  s_mp_rshd(&q, USED(m) - 1);  \/* q1 = x \/ b^(k-1)  *\/\n-  s_mp_mul(&q, mu);            \/* q2 = q1 * mu      *\/\n-  s_mp_rshd(&q, USED(m) + 1);  \/* q3 = q2 \/ b^(k+1) *\/\n-\n-  \/* x = x mod b^(k+1), quick (no division) *\/\n-  s_mp_mod_2d(x, DIGIT_BIT * (USED(m) + 1));\n-\n-  \/* q = q * m mod b^(k+1), quick (no division) *\/\n-  s_mp_mul(&q, m);\n-  s_mp_mod_2d(&q, DIGIT_BIT * (USED(m) + 1));\n-\n-  \/* x = x - q *\/\n-  if((res = mp_sub(x, &q, x)) != MP_OKAY)\n-    goto CLEANUP;\n-\n-  \/* If x < 0, add b^(k+1) to it *\/\n-  if(mp_cmp_z(x) < 0) {\n-    mp_set(&q, 1);\n-    if((res = s_mp_lshd(&q, USED(m) + 1)) != MP_OKAY)\n-      goto CLEANUP;\n-    if((res = mp_add(x, &q, x)) != MP_OKAY)\n-      goto CLEANUP;\n-  }\n-\n-  \/* Back off if it's too big *\/\n-  while(mp_cmp(x, m) >= 0) {\n-    if((res = s_mp_sub(x, m)) != MP_OKAY)\n-      break;\n-  }\n-\n- CLEANUP:\n-  mp_clear(&q);\n-\n-  return res;\n-\n-} \/* end s_mp_reduce() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ Primitive comparisons *\/\n-\n-\/* {{{ s_mp_cmp(a, b) *\/\n-\n-\/* Compare |a| <=> |b|, return 0 if equal, <0 if a<b, >0 if a>b           *\/\n-int      s_mp_cmp(const mp_int *a, const mp_int *b)\n-{\n-  mp_size used_a = MP_USED(a);\n-  {\n-    mp_size used_b = MP_USED(b);\n-\n-    if (used_a > used_b)\n-      goto IS_GT;\n-    if (used_a < used_b)\n-      goto IS_LT;\n-  }\n-  {\n-    mp_digit *pa, *pb;\n-    mp_digit da = 0, db = 0;\n-\n-#define CMP_AB(n) if ((da = pa[n]) != (db = pb[n])) goto done\n-\n-    pa = MP_DIGITS(a) + used_a;\n-    pb = MP_DIGITS(b) + used_a;\n-    while (used_a >= 4) {\n-      pa     -= 4;\n-      pb     -= 4;\n-      used_a -= 4;\n-      CMP_AB(3);\n-      CMP_AB(2);\n-      CMP_AB(1);\n-      CMP_AB(0);\n-    }\n-    while (used_a-- > 0 && ((da = *--pa) == (db = *--pb)))\n-      \/* do nothing *\/;\n-done:\n-    if (da > db)\n-      goto IS_GT;\n-    if (da < db)\n-      goto IS_LT;\n-  }\n-  return MP_EQ;\n-IS_LT:\n-  return MP_LT;\n-IS_GT:\n-  return MP_GT;\n-} \/* end s_mp_cmp() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_cmp_d(a, d) *\/\n-\n-\/* Compare |a| <=> d, return 0 if equal, <0 if a<d, >0 if a>d             *\/\n-int      s_mp_cmp_d(const mp_int *a, mp_digit d)\n-{\n-  if(USED(a) > 1)\n-    return MP_GT;\n-\n-  if(DIGIT(a, 0) < d)\n-    return MP_LT;\n-  else if(DIGIT(a, 0) > d)\n-    return MP_GT;\n-  else\n-    return MP_EQ;\n-\n-} \/* end s_mp_cmp_d() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_ispow2(v) *\/\n-\n-\/*\n-  Returns -1 if the value is not a power of two; otherwise, it returns\n-  k such that v = 2^k, i.e. lg(v).\n- *\/\n-int      s_mp_ispow2(const mp_int *v)\n-{\n-  mp_digit d;\n-  int      extra = 0, ix;\n-\n-  ix = MP_USED(v) - 1;\n-  d = MP_DIGIT(v, ix); \/* most significant digit of v *\/\n-\n-  extra = s_mp_ispow2d(d);\n-  if (extra < 0 || ix == 0)\n-    return extra;\n-\n-  while (--ix >= 0) {\n-    if (DIGIT(v, ix) != 0)\n-      return -1; \/* not a power of two *\/\n-    extra += MP_DIGIT_BIT;\n-  }\n-\n-  return extra;\n-\n-} \/* end s_mp_ispow2() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_ispow2d(d) *\/\n-\n-int      s_mp_ispow2d(mp_digit d)\n-{\n-  if ((d != 0) && ((d & (d-1)) == 0)) { \/* d is a power of 2 *\/\n-    int pow = 0;\n-#if defined (MP_USE_UINT_DIGIT)\n-    if (d & 0xffff0000U)\n-      pow += 16;\n-    if (d & 0xff00ff00U)\n-      pow += 8;\n-    if (d & 0xf0f0f0f0U)\n-      pow += 4;\n-    if (d & 0xccccccccU)\n-      pow += 2;\n-    if (d & 0xaaaaaaaaU)\n-      pow += 1;\n-#elif defined(MP_USE_LONG_LONG_DIGIT)\n-    if (d & 0xffffffff00000000ULL)\n-      pow += 32;\n-    if (d & 0xffff0000ffff0000ULL)\n-      pow += 16;\n-    if (d & 0xff00ff00ff00ff00ULL)\n-      pow += 8;\n-    if (d & 0xf0f0f0f0f0f0f0f0ULL)\n-      pow += 4;\n-    if (d & 0xccccccccccccccccULL)\n-      pow += 2;\n-    if (d & 0xaaaaaaaaaaaaaaaaULL)\n-      pow += 1;\n-#elif defined(MP_USE_LONG_DIGIT)\n-    if (d & 0xffffffff00000000UL)\n-      pow += 32;\n-    if (d & 0xffff0000ffff0000UL)\n-      pow += 16;\n-    if (d & 0xff00ff00ff00ff00UL)\n-      pow += 8;\n-    if (d & 0xf0f0f0f0f0f0f0f0UL)\n-      pow += 4;\n-    if (d & 0xccccccccccccccccUL)\n-      pow += 2;\n-    if (d & 0xaaaaaaaaaaaaaaaaUL)\n-      pow += 1;\n-#else\n-#error \"unknown type for mp_digit\"\n-#endif\n-    return pow;\n-  }\n-  return -1;\n-\n-} \/* end s_mp_ispow2d() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ Primitive I\/O helpers *\/\n-\n-\/* {{{ s_mp_tovalue(ch, r) *\/\n-\n-\/*\n-  Convert the given character to its digit value, in the given radix.\n-  If the given character is not understood in the given radix, -1 is\n-  returned.  Otherwise the digit's numeric value is returned.\n-\n-  The results will be odd if you use a radix < 2 or > 62, you are\n-  expected to know what you're up to.\n- *\/\n-int      s_mp_tovalue(char ch, int r)\n-{\n-  int    val, xch;\n-\n-  if(r > 36)\n-    xch = ch;\n-  else\n-    xch = toupper(ch);\n-\n-  if(isdigit(xch))\n-    val = xch - '0';\n-  else if(isupper(xch))\n-    val = xch - 'A' + 10;\n-  else if(islower(xch))\n-    val = xch - 'a' + 36;\n-  else if(xch == '+')\n-    val = 62;\n-  else if(xch == '\/')\n-    val = 63;\n-  else\n-    return -1;\n-\n-  if(val < 0 || val >= r)\n-    return -1;\n-\n-  return val;\n-\n-} \/* end s_mp_tovalue() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_todigit(val, r, low) *\/\n-\n-\/*\n-  Convert val to a radix-r digit, if possible.  If val is out of range\n-  for r, returns zero.  Otherwise, returns an ASCII character denoting\n-  the value in the given radix.\n-\n-  The results may be odd if you use a radix < 2 or > 64, you are\n-  expected to know what you're doing.\n- *\/\n-\n-char     s_mp_todigit(mp_digit val, int r, int low)\n-{\n-  char   ch;\n-\n-  if(val >= (unsigned int)r)\n-    return 0;\n-\n-  ch = s_dmap_1[val];\n-\n-  if(r <= 36 && low)\n-    ch = tolower(ch);\n-\n-  return ch;\n-\n-} \/* end s_mp_todigit() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ s_mp_outlen(bits, radix) *\/\n-\n-\/*\n-   Return an estimate for how long a string is needed to hold a radix\n-   r representation of a number with 'bits' significant bits, plus an\n-   extra for a zero terminator (assuming C style strings here)\n- *\/\n-int      s_mp_outlen(int bits, int r)\n-{\n-  return (int)((double)bits * LOG_V_2(r) + 1.5) + 1;\n-\n-} \/* end s_mp_outlen() *\/\n-\n-\/* }}} *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mp_read_unsigned_octets(mp, str, len) *\/\n-\/* mp_read_unsigned_octets(mp, str, len)\n-   Read in a raw value (base 256) into the given mp_int\n-   No sign bit, number is positive.  Leading zeros ignored.\n- *\/\n-\n-mp_err\n-mp_read_unsigned_octets(mp_int *mp, const unsigned char *str, mp_size len)\n-{\n-  int            count;\n-  mp_err         res;\n-  mp_digit       d;\n-\n-  ARGCHK(mp != NULL && str != NULL && len > 0, MP_BADARG);\n-\n-  mp_zero(mp);\n-\n-  count = len % sizeof(mp_digit);\n-  if (count) {\n-    for (d = 0; count-- > 0; --len) {\n-      d = (d << 8) | *str++;\n-    }\n-    MP_DIGIT(mp, 0) = d;\n-  }\n-\n-  \/* Read the rest of the digits *\/\n-  for(; len > 0; len -= sizeof(mp_digit)) {\n-    for (d = 0, count = sizeof(mp_digit); count > 0; --count) {\n-      d = (d << 8) | *str++;\n-    }\n-    if (MP_EQ == mp_cmp_z(mp)) {\n-      if (!d)\n-        continue;\n-    } else {\n-      if((res = s_mp_lshd(mp, 1)) != MP_OKAY)\n-        return res;\n-    }\n-    MP_DIGIT(mp, 0) = d;\n-  }\n-  return MP_OKAY;\n-} \/* end mp_read_unsigned_octets() *\/\n-\/* }}} *\/\n-\n-\/* {{{ mp_unsigned_octet_size(mp) *\/\n-int\n-mp_unsigned_octet_size(const mp_int *mp)\n-{\n-  int  bytes;\n-  int  ix;\n-  mp_digit  d = 0;\n-\n-  ARGCHK(mp != NULL, MP_BADARG);\n-  ARGCHK(MP_ZPOS == SIGN(mp), MP_BADARG);\n-\n-  bytes = (USED(mp) * sizeof(mp_digit));\n-\n-  \/* subtract leading zeros. *\/\n-  \/* Iterate over each digit... *\/\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    d = DIGIT(mp, ix);\n-    if (d)\n-        break;\n-    bytes -= sizeof(d);\n-  }\n-  if (!bytes)\n-    return 1;\n-\n-  \/* Have MSD, check digit bytes, high order first *\/\n-  for(ix = sizeof(mp_digit) - 1; ix >= 0; ix--) {\n-    unsigned char x = (unsigned char)(d >> (ix * CHAR_BIT));\n-    if (x)\n-        break;\n-    --bytes;\n-  }\n-  return bytes;\n-} \/* end mp_unsigned_octet_size() *\/\n-\/* }}} *\/\n-\n-\/* {{{ mp_to_unsigned_octets(mp, str) *\/\n-\/* output a buffer of big endian octets no longer than specified. *\/\n-mp_err\n-mp_to_unsigned_octets(const mp_int *mp, unsigned char *str, mp_size maxlen)\n-{\n-  int  ix, pos = 0;\n-  unsigned int  bytes;\n-\n-  ARGCHK(mp != NULL && str != NULL && !SIGN(mp), MP_BADARG);\n-\n-  bytes = mp_unsigned_octet_size(mp);\n-  ARGCHK(bytes <= maxlen, MP_BADARG);\n-\n-  \/* Iterate over each digit... *\/\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    mp_digit  d = DIGIT(mp, ix);\n-    int       jx;\n-\n-    \/* Unpack digit bytes, high order first *\/\n-    for(jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {\n-      unsigned char x = (unsigned char)(d >> (jx * CHAR_BIT));\n-      if (!pos && !x)   \/* suppress leading zeros *\/\n-        continue;\n-      str[pos++] = x;\n-    }\n-  }\n-  if (!pos)\n-    str[pos++] = 0;\n-  return pos;\n-} \/* end mp_to_unsigned_octets() *\/\n-\/* }}} *\/\n-\n-\/* {{{ mp_to_signed_octets(mp, str) *\/\n-\/* output a buffer of big endian octets no longer than specified. *\/\n-mp_err\n-mp_to_signed_octets(const mp_int *mp, unsigned char *str, mp_size maxlen)\n-{\n-  int  ix, pos = 0;\n-  unsigned int  bytes;\n-\n-  ARGCHK(mp != NULL && str != NULL && !SIGN(mp), MP_BADARG);\n-\n-  bytes = mp_unsigned_octet_size(mp);\n-  ARGCHK(bytes <= maxlen, MP_BADARG);\n-\n-  \/* Iterate over each digit... *\/\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    mp_digit  d = DIGIT(mp, ix);\n-    int       jx;\n-\n-    \/* Unpack digit bytes, high order first *\/\n-    for(jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {\n-      unsigned char x = (unsigned char)(d >> (jx * CHAR_BIT));\n-      if (!pos) {\n-        if (!x)         \/* suppress leading zeros *\/\n-          continue;\n-        if (x & 0x80) { \/* add one leading zero to make output positive.  *\/\n-          ARGCHK(bytes + 1 <= maxlen, MP_BADARG);\n-          if (bytes + 1 > maxlen)\n-            return MP_BADARG;\n-          str[pos++] = 0;\n-        }\n-      }\n-      str[pos++] = x;\n-    }\n-  }\n-  if (!pos)\n-    str[pos++] = 0;\n-  return pos;\n-} \/* end mp_to_signed_octets() *\/\n-\/* }}} *\/\n-\n-\/* {{{ mp_to_fixlen_octets(mp, str) *\/\n-\/* output a buffer of big endian octets exactly as long as requested. *\/\n-mp_err\n-mp_to_fixlen_octets(const mp_int *mp, unsigned char *str, mp_size length)\n-{\n-  int  ix, pos = 0;\n-  unsigned int  bytes;\n-\n-  ARGCHK(mp != NULL && str != NULL && !SIGN(mp), MP_BADARG);\n-\n-  bytes = mp_unsigned_octet_size(mp);\n-  ARGCHK(bytes <= length, MP_BADARG);\n-\n-  \/* place any needed leading zeros *\/\n-  for (;length > bytes; --length) {\n-        *str++ = 0;\n-  }\n-\n-  \/* Iterate over each digit... *\/\n-  for(ix = USED(mp) - 1; ix >= 0; ix--) {\n-    mp_digit  d = DIGIT(mp, ix);\n-    int       jx;\n-\n-    \/* Unpack digit bytes, high order first *\/\n-    for(jx = sizeof(mp_digit) - 1; jx >= 0; jx--) {\n-      unsigned char x = (unsigned char)(d >> (jx * CHAR_BIT));\n-      if (!pos && !x)   \/* suppress leading zeros *\/\n-        continue;\n-      str[pos++] = x;\n-    }\n-  }\n-  if (!pos)\n-    str[pos++] = 0;\n-  return MP_OKAY;\n-} \/* end mp_to_fixlen_octets() *\/\n-\/* }}} *\/\n-\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* HERE THERE BE DRAGONS                                                  *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mpi.c","additions":0,"deletions":4871,"binary":false,"changes":4871,"status":"deleted"},{"patch":"@@ -1,387 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1998\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Netscape Communications Corporation\n- *\n- *********************************************************************** *\/\n-\n-\/*  Arbitrary precision integer arithmetic library *\/\n-\n-#ifndef _MPI_H\n-#define _MPI_H\n-\n-\/* $Id: mpi.h,v 1.22 2004\/04\/27 23:04:36 gerv%gerv.net Exp $ *\/\n-\n-#include \"mpi-config.h\"\n-\n-#ifndef _WIN32\n-#include <sys\/param.h>\n-#endif \/* _WIN32 *\/\n-\n-#ifdef _KERNEL\n-#include <sys\/debug.h>\n-#include <sys\/systm.h>\n-#define assert ASSERT\n-#define labs(a) (a >= 0 ? a : -a)\n-#define UCHAR_MAX 255\n-#define memset(s, c, n) bzero(s, n)\n-#define memcpy(a,b,c) bcopy((caddr_t)b, (caddr_t)a, c)\n-\/*\n- * Generic #define's to cover missing things in the kernel\n- *\/\n-#ifndef isdigit\n-#define isdigit(x)      ((x) >= '0' && (x) <= '9')\n-#endif\n-#ifndef isupper\n-#define isupper(x)      (((unsigned)(x) >= 'A') && ((unsigned)(x) <= 'Z'))\n-#endif\n-#ifndef islower\n-#define islower(x)      (((unsigned)(x) >= 'a') && ((unsigned)(x) <= 'z'))\n-#endif\n-#ifndef isalpha\n-#define isalpha(x)      (isupper(x) || islower(x))\n-#endif\n-#ifndef toupper\n-#define toupper(x)      (islower(x) ? (x) - 'a' + 'A' : (x))\n-#endif\n-#ifndef tolower\n-#define tolower(x)      (isupper(x) ? (x) + 'a' - 'A' : (x))\n-#endif\n-#ifndef isspace\n-#define isspace(x)      (((x) == ' ') || ((x) == '\\r') || ((x) == '\\n') || \\\n-                         ((x) == '\\t') || ((x) == '\\b'))\n-#endif\n-#endif \/* _KERNEL *\/\n-\n-#if MP_DEBUG\n-#undef MP_IOFUNC\n-#define MP_IOFUNC 1\n-#endif\n-\n-#if MP_IOFUNC\n-#include <stdio.h>\n-#include <ctype.h>\n-#endif\n-\n-#ifndef _KERNEL\n-#include <limits.h>\n-#endif\n-\n-#if defined(BSDI)\n-#undef ULLONG_MAX\n-#endif\n-\n-#if defined( macintosh )\n-#include <Types.h>\n-#elif defined( _WIN32_WCE)\n-\/* #include <sys\/types.h> What do we need here ?? *\/\n-#else\n-#include <sys\/types.h>\n-#endif\n-\n-#define  MP_NEG    1\n-#define  MP_ZPOS   0\n-\n-#define  MP_OKAY          0 \/* no error, all is well *\/\n-#define  MP_YES           0 \/* yes (boolean result)  *\/\n-#define  MP_NO           -1 \/* no (boolean result)   *\/\n-#define  MP_MEM          -2 \/* out of memory         *\/\n-#define  MP_RANGE        -3 \/* argument out of range *\/\n-#define  MP_BADARG       -4 \/* invalid parameter     *\/\n-#define  MP_UNDEF        -5 \/* answer is undefined   *\/\n-#define  MP_LAST_CODE    MP_UNDEF\n-\n-typedef unsigned int      mp_sign;\n-typedef unsigned int      mp_size;\n-typedef int               mp_err;\n-typedef int               mp_flag;\n-\n-#define MP_32BIT_MAX 4294967295U\n-\n-#if !defined(ULONG_MAX)\n-#error \"ULONG_MAX not defined\"\n-#elif !defined(UINT_MAX)\n-#error \"UINT_MAX not defined\"\n-#elif !defined(USHRT_MAX)\n-#error \"USHRT_MAX not defined\"\n-#endif\n-\n-#if defined(ULONG_LONG_MAX)                     \/* GCC, HPUX *\/\n-#define MP_ULONG_LONG_MAX ULONG_LONG_MAX\n-#elif defined(ULLONG_MAX)                       \/* Solaris *\/\n-#define MP_ULONG_LONG_MAX ULLONG_MAX\n-\/* MP_ULONG_LONG_MAX was defined to be ULLONG_MAX *\/\n-#elif defined(ULONGLONG_MAX)                    \/* IRIX, AIX *\/\n-#define MP_ULONG_LONG_MAX ULONGLONG_MAX\n-#endif\n-\n-\/* We only use unsigned long for mp_digit iff long is more than 32 bits. *\/\n-#if !defined(MP_USE_UINT_DIGIT) && ULONG_MAX > MP_32BIT_MAX\n-typedef unsigned long     mp_digit;\n-#define MP_DIGIT_MAX      ULONG_MAX\n-#define MP_DIGIT_FMT      \"%016lX\"   \/* printf() format for 1 digit *\/\n-#define MP_HALF_DIGIT_MAX UINT_MAX\n-#undef  MP_NO_MP_WORD\n-#define MP_NO_MP_WORD 1\n-#undef  MP_USE_LONG_DIGIT\n-#define MP_USE_LONG_DIGIT 1\n-#undef  MP_USE_LONG_LONG_DIGIT\n-\n-#elif !defined(MP_USE_UINT_DIGIT) && defined(MP_ULONG_LONG_MAX)\n-typedef unsigned long long mp_digit;\n-#define MP_DIGIT_MAX       MP_ULONG_LONG_MAX\n-#define MP_DIGIT_FMT      \"%016llX\"  \/* printf() format for 1 digit *\/\n-#define MP_HALF_DIGIT_MAX  UINT_MAX\n-#undef  MP_NO_MP_WORD\n-#define MP_NO_MP_WORD 1\n-#undef  MP_USE_LONG_LONG_DIGIT\n-#define MP_USE_LONG_LONG_DIGIT 1\n-#undef  MP_USE_LONG_DIGIT\n-\n-#else\n-typedef unsigned int      mp_digit;\n-#define MP_DIGIT_MAX      UINT_MAX\n-#define MP_DIGIT_FMT      \"%08X\"     \/* printf() format for 1 digit *\/\n-#define MP_HALF_DIGIT_MAX USHRT_MAX\n-#undef  MP_USE_UINT_DIGIT\n-#define MP_USE_UINT_DIGIT 1\n-#undef  MP_USE_LONG_LONG_DIGIT\n-#undef  MP_USE_LONG_DIGIT\n-#endif\n-\n-#if !defined(MP_NO_MP_WORD)\n-#if  defined(MP_USE_UINT_DIGIT) && \\\n-    (defined(MP_ULONG_LONG_MAX) || (ULONG_MAX > UINT_MAX))\n-\n-#if (ULONG_MAX > UINT_MAX)\n-typedef unsigned long     mp_word;\n-typedef          long     mp_sword;\n-#define MP_WORD_MAX       ULONG_MAX\n-\n-#else\n-typedef unsigned long long mp_word;\n-typedef          long long mp_sword;\n-#define MP_WORD_MAX       MP_ULONG_LONG_MAX\n-#endif\n-\n-#else\n-#define MP_NO_MP_WORD 1\n-#endif\n-#endif \/* !defined(MP_NO_MP_WORD) *\/\n-\n-#if !defined(MP_WORD_MAX) && defined(MP_DEFINE_SMALL_WORD)\n-typedef unsigned int      mp_word;\n-typedef          int      mp_sword;\n-#define MP_WORD_MAX       UINT_MAX\n-#endif\n-\n-#ifndef CHAR_BIT\n-#define CHAR_BIT 8\n-#endif\n-\n-#define MP_DIGIT_BIT      (CHAR_BIT*sizeof(mp_digit))\n-#define MP_WORD_BIT       (CHAR_BIT*sizeof(mp_word))\n-#define MP_RADIX          (1+(mp_word)MP_DIGIT_MAX)\n-\n-#define MP_HALF_DIGIT_BIT (MP_DIGIT_BIT\/2)\n-#define MP_HALF_RADIX     (1+(mp_digit)MP_HALF_DIGIT_MAX)\n-\/* MP_HALF_RADIX really ought to be called MP_SQRT_RADIX, but it's named\n-** MP_HALF_RADIX because it's the radix for MP_HALF_DIGITs, and it's\n-** consistent with the other _HALF_ names.\n-*\/\n-\n-\n-\/* Macros for accessing the mp_int internals           *\/\n-#define  MP_FLAG(MP)     ((MP)->flag)\n-#define  MP_SIGN(MP)     ((MP)->sign)\n-#define  MP_USED(MP)     ((MP)->used)\n-#define  MP_ALLOC(MP)    ((MP)->alloc)\n-#define  MP_DIGITS(MP)   ((MP)->dp)\n-#define  MP_DIGIT(MP,N)  (MP)->dp[(N)]\n-\n-\/* This defines the maximum I\/O base (minimum is 2)   *\/\n-#define MP_MAX_RADIX         64\n-\n-typedef struct {\n-  mp_sign       flag;    \/* KM_SLEEP\/KM_NOSLEEP        *\/\n-  mp_sign       sign;    \/* sign of this quantity      *\/\n-  mp_size       alloc;   \/* how many digits allocated  *\/\n-  mp_size       used;    \/* how many digits used       *\/\n-  mp_digit     *dp;      \/* the digits themselves      *\/\n-} mp_int;\n-\n-\/* Default precision       *\/\n-mp_size mp_get_prec(void);\n-void    mp_set_prec(mp_size prec);\n-\n-\/* Memory management       *\/\n-mp_err mp_init(mp_int *mp, int kmflag);\n-mp_err mp_init_size(mp_int *mp, mp_size prec, int kmflag);\n-mp_err mp_init_copy(mp_int *mp, const mp_int *from);\n-mp_err mp_copy(const mp_int *from, mp_int *to);\n-void   mp_exch(mp_int *mp1, mp_int *mp2);\n-void   mp_clear(mp_int *mp);\n-void   mp_zero(mp_int *mp);\n-void   mp_set(mp_int *mp, mp_digit d);\n-mp_err mp_set_int(mp_int *mp, long z);\n-#define mp_set_long(mp,z) mp_set_int(mp,z)\n-mp_err mp_set_ulong(mp_int *mp, unsigned long z);\n-\n-\/* Single digit arithmetic *\/\n-mp_err mp_add_d(const mp_int *a, mp_digit d, mp_int *b);\n-mp_err mp_sub_d(const mp_int *a, mp_digit d, mp_int *b);\n-mp_err mp_mul_d(const mp_int *a, mp_digit d, mp_int *b);\n-mp_err mp_mul_2(const mp_int *a, mp_int *c);\n-mp_err mp_div_d(const mp_int *a, mp_digit d, mp_int *q, mp_digit *r);\n-mp_err mp_div_2(const mp_int *a, mp_int *c);\n-mp_err mp_expt_d(const mp_int *a, mp_digit d, mp_int *c);\n-\n-\/* Sign manipulations      *\/\n-mp_err mp_abs(const mp_int *a, mp_int *b);\n-mp_err mp_neg(const mp_int *a, mp_int *b);\n-\n-\/* Full arithmetic         *\/\n-mp_err mp_add(const mp_int *a, const mp_int *b, mp_int *c);\n-mp_err mp_sub(const mp_int *a, const mp_int *b, mp_int *c);\n-mp_err mp_mul(const mp_int *a, const mp_int *b, mp_int *c);\n-#if MP_SQUARE\n-mp_err mp_sqr(const mp_int *a, mp_int *b);\n-#else\n-#define mp_sqr(a, b) mp_mul(a, a, b)\n-#endif\n-mp_err mp_div(const mp_int *a, const mp_int *b, mp_int *q, mp_int *r);\n-mp_err mp_div_2d(const mp_int *a, mp_digit d, mp_int *q, mp_int *r);\n-mp_err mp_expt(mp_int *a, mp_int *b, mp_int *c);\n-mp_err mp_2expt(mp_int *a, mp_digit k);\n-mp_err mp_sqrt(const mp_int *a, mp_int *b);\n-\n-\/* Modular arithmetic      *\/\n-#if MP_MODARITH\n-mp_err mp_mod(const mp_int *a, const mp_int *m, mp_int *c);\n-mp_err mp_mod_d(const mp_int *a, mp_digit d, mp_digit *c);\n-mp_err mp_addmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c);\n-mp_err mp_submod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c);\n-mp_err mp_mulmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c);\n-#if MP_SQUARE\n-mp_err mp_sqrmod(const mp_int *a, const mp_int *m, mp_int *c);\n-#else\n-#define mp_sqrmod(a, m, c) mp_mulmod(a, a, m, c)\n-#endif\n-mp_err mp_exptmod(const mp_int *a, const mp_int *b, const mp_int *m, mp_int *c);\n-mp_err mp_exptmod_d(const mp_int *a, mp_digit d, const mp_int *m, mp_int *c);\n-#endif \/* MP_MODARITH *\/\n-\n-\/* Comparisons             *\/\n-int    mp_cmp_z(const mp_int *a);\n-int    mp_cmp_d(const mp_int *a, mp_digit d);\n-int    mp_cmp(const mp_int *a, const mp_int *b);\n-int    mp_cmp_mag(mp_int *a, mp_int *b);\n-int    mp_cmp_int(const mp_int *a, long z, int kmflag);\n-int    mp_isodd(const mp_int *a);\n-int    mp_iseven(const mp_int *a);\n-\n-\/* Number theoretic        *\/\n-#if MP_NUMTH\n-mp_err mp_gcd(mp_int *a, mp_int *b, mp_int *c);\n-mp_err mp_lcm(mp_int *a, mp_int *b, mp_int *c);\n-mp_err mp_xgcd(const mp_int *a, const mp_int *b, mp_int *g, mp_int *x, mp_int *y);\n-mp_err mp_invmod(const mp_int *a, const mp_int *m, mp_int *c);\n-mp_err mp_invmod_xgcd(const mp_int *a, const mp_int *m, mp_int *c);\n-#endif \/* end MP_NUMTH *\/\n-\n-\/* Input and output        *\/\n-#if MP_IOFUNC\n-void   mp_print(mp_int *mp, FILE *ofp);\n-#endif \/* end MP_IOFUNC *\/\n-\n-\/* Base conversion         *\/\n-mp_err mp_read_raw(mp_int *mp, char *str, int len);\n-int    mp_raw_size(mp_int *mp);\n-mp_err mp_toraw(mp_int *mp, char *str);\n-mp_err mp_read_radix(mp_int *mp, const char *str, int radix);\n-mp_err mp_read_variable_radix(mp_int *a, const char * str, int default_radix);\n-int    mp_radix_size(mp_int *mp, int radix);\n-mp_err mp_toradix(mp_int *mp, char *str, int radix);\n-int    mp_tovalue(char ch, int r);\n-\n-#define mp_tobinary(M, S)  mp_toradix((M), (S), 2)\n-#define mp_tooctal(M, S)   mp_toradix((M), (S), 8)\n-#define mp_todecimal(M, S) mp_toradix((M), (S), 10)\n-#define mp_tohex(M, S)     mp_toradix((M), (S), 16)\n-\n-\/* Error strings           *\/\n-const  char  *mp_strerror(mp_err ec);\n-\n-\/* Octet string conversion functions *\/\n-mp_err mp_read_unsigned_octets(mp_int *mp, const unsigned char *str, mp_size len);\n-int    mp_unsigned_octet_size(const mp_int *mp);\n-mp_err mp_to_unsigned_octets(const mp_int *mp, unsigned char *str, mp_size maxlen);\n-mp_err mp_to_signed_octets(const mp_int *mp, unsigned char *str, mp_size maxlen);\n-mp_err mp_to_fixlen_octets(const mp_int *mp, unsigned char *str, mp_size len);\n-\n-\/* Miscellaneous *\/\n-mp_size mp_trailing_zeros(const mp_int *mp);\n-\n-#define MP_CHECKOK(x)  if (MP_OKAY > (res = (x))) goto CLEANUP\n-#define MP_CHECKERR(x) if (MP_OKAY > (res = (x))) goto CLEANUP\n-\n-#if defined(MP_API_COMPATIBLE)\n-#define NEG             MP_NEG\n-#define ZPOS            MP_ZPOS\n-#define DIGIT_MAX       MP_DIGIT_MAX\n-#define DIGIT_BIT       MP_DIGIT_BIT\n-#define DIGIT_FMT       MP_DIGIT_FMT\n-#define RADIX           MP_RADIX\n-#define MAX_RADIX       MP_MAX_RADIX\n-#define FLAG(MP)        MP_FLAG(MP)\n-#define SIGN(MP)        MP_SIGN(MP)\n-#define USED(MP)        MP_USED(MP)\n-#define ALLOC(MP)       MP_ALLOC(MP)\n-#define DIGITS(MP)      MP_DIGITS(MP)\n-#define DIGIT(MP,N)     MP_DIGIT(MP,N)\n-\n-#if MP_ARGCHK == 1\n-#define  ARGCHK(X,Y)  {if(!(X)){return (Y);}}\n-#elif MP_ARGCHK == 2\n-#ifdef _KERNEL\n-#define  ARGCHK(X,Y)  ASSERT(X)\n-#else\n-#include <assert.h>\n-#define  ARGCHK(X,Y)  assert(X)\n-#endif\n-#else\n-#define  ARGCHK(X,Y)  \/*  *\/\n-#endif\n-#endif \/* defined MP_API_COMPATIBLE *\/\n-\n-#endif \/* _MPI_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mpi.h","additions":0,"deletions":387,"binary":false,"changes":387,"status":"deleted"},{"patch":"@@ -1,218 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1998\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *\n- *********************************************************************** *\/\n-\n-\/*  Bitwise logical operations on MPI values *\/\n-\n-#include \"mpi-priv.h\"\n-#include \"mplogic.h\"\n-\n-\/* {{{ Lookup table for population count *\/\n-\n-static unsigned char bitc[] = {\n-   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n-   1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n-   2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n-   3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n-   4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n-};\n-\n-\/* }}} *\/\n-\n-\/*\n-  mpl_rsh(a, b, d)     - b = a >> d\n-  mpl_lsh(a, b, d)     - b = a << d\n- *\/\n-\n-\/* {{{ mpl_rsh(a, b, d) *\/\n-\n-mp_err mpl_rsh(const mp_int *a, mp_int *b, mp_digit d)\n-{\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if((res = mp_copy(a, b)) != MP_OKAY)\n-    return res;\n-\n-  s_mp_div_2d(b, d);\n-\n-  return MP_OKAY;\n-\n-} \/* end mpl_rsh() *\/\n-\n-\/* }}} *\/\n-\n-\/* {{{ mpl_lsh(a, b, d) *\/\n-\n-mp_err mpl_lsh(const mp_int *a, mp_int *b, mp_digit d)\n-{\n-  mp_err   res;\n-\n-  ARGCHK(a != NULL && b != NULL, MP_BADARG);\n-\n-  if((res = mp_copy(a, b)) != MP_OKAY)\n-    return res;\n-\n-  return s_mp_mul_2d(b, d);\n-\n-} \/* end mpl_lsh() *\/\n-\n-\/* }}} *\/\n-\n-\/*------------------------------------------------------------------------*\/\n-\/*\n-  mpl_set_bit\n-\n-  Returns MP_OKAY or some error code.\n-  Grows a if needed to set a bit to 1.\n- *\/\n-mp_err mpl_set_bit(mp_int *a, mp_size bitNum, mp_size value)\n-{\n-  mp_size      ix;\n-  mp_err       rv;\n-  mp_digit     mask;\n-\n-  ARGCHK(a != NULL, MP_BADARG);\n-\n-  ix = bitNum \/ MP_DIGIT_BIT;\n-  if (ix + 1 > MP_USED(a)) {\n-    rv = s_mp_pad(a, ix + 1);\n-    if (rv != MP_OKAY)\n-      return rv;\n-  }\n-\n-  bitNum = bitNum % MP_DIGIT_BIT;\n-  mask = (mp_digit)1 << bitNum;\n-  if (value)\n-    MP_DIGIT(a,ix) |= mask;\n-  else\n-    MP_DIGIT(a,ix) &= ~mask;\n-  s_mp_clamp(a);\n-  return MP_OKAY;\n-}\n-\n-\/*\n-  mpl_get_bit\n-\n-  returns 0 or 1 or some (negative) error code.\n- *\/\n-mp_err mpl_get_bit(const mp_int *a, mp_size bitNum)\n-{\n-  mp_size      bit, ix;\n-  mp_err       rv;\n-\n-  ARGCHK(a != NULL, MP_BADARG);\n-\n-  ix = bitNum \/ MP_DIGIT_BIT;\n-  ARGCHK(ix <= MP_USED(a) - 1, MP_RANGE);\n-\n-  bit   = bitNum % MP_DIGIT_BIT;\n-  rv = (mp_err)(MP_DIGIT(a, ix) >> bit) & 1;\n-  return rv;\n-}\n-\n-\/*\n-  mpl_get_bits\n-  - Extracts numBits bits from a, where the least significant extracted bit\n-  is bit lsbNum.  Returns a negative value if error occurs.\n-  - Because sign bit is used to indicate error, maximum number of bits to\n-  be returned is the lesser of (a) the number of bits in an mp_digit, or\n-  (b) one less than the number of bits in an mp_err.\n-  - lsbNum + numbits can be greater than the number of significant bits in\n-  integer a, as long as bit lsbNum is in the high order digit of a.\n- *\/\n-mp_err mpl_get_bits(const mp_int *a, mp_size lsbNum, mp_size numBits)\n-{\n-  mp_size    rshift = (lsbNum % MP_DIGIT_BIT);\n-  mp_size    lsWndx = (lsbNum \/ MP_DIGIT_BIT);\n-  mp_digit * digit  = MP_DIGITS(a) + lsWndx;\n-  mp_digit   mask   = ((1 << numBits) - 1);\n-\n-  ARGCHK(numBits < CHAR_BIT * sizeof mask, MP_BADARG);\n-  ARGCHK(MP_HOWMANY(lsbNum, MP_DIGIT_BIT) <= MP_USED(a), MP_RANGE);\n-\n-  if ((numBits + lsbNum % MP_DIGIT_BIT <= MP_DIGIT_BIT) ||\n-      (lsWndx + 1 >= MP_USED(a))) {\n-    mask &= (digit[0] >> rshift);\n-  } else {\n-    mask &= ((digit[0] >> rshift) | (digit[1] << (MP_DIGIT_BIT - rshift)));\n-  }\n-  return (mp_err)mask;\n-}\n-\n-\/*\n-  mpl_significant_bits\n-  returns number of significnant bits in abs(a).\n-  returns 1 if value is zero.\n- *\/\n-mp_err mpl_significant_bits(const mp_int *a)\n-{\n-  mp_err bits   = 0;\n-  int    ix;\n-\n-  ARGCHK(a != NULL, MP_BADARG);\n-\n-  ix = MP_USED(a);\n-  for (ix = MP_USED(a); ix > 0; ) {\n-    mp_digit d;\n-    d = MP_DIGIT(a, --ix);\n-    if (d) {\n-      while (d) {\n-        ++bits;\n-        d >>= 1;\n-      }\n-      break;\n-    }\n-  }\n-  bits += ix * MP_DIGIT_BIT;\n-  if (!bits)\n-    bits = 1;\n-  return bits;\n-}\n-\n-\/*------------------------------------------------------------------------*\/\n-\/* HERE THERE BE DRAGONS                                                  *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mplogic.c","additions":0,"deletions":218,"binary":false,"changes":218,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1998\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *\n- *********************************************************************** *\/\n-\n-\/*  Bitwise logical operations on MPI values *\/\n-\n-#ifndef _MPLOGIC_H\n-#define _MPLOGIC_H\n-\n-\/* $Id: mplogic.h,v 1.7 2004\/04\/27 23:04:36 gerv%gerv.net Exp $ *\/\n-\n-#include \"mpi.h\"\n-\n-\/*\n-  The logical operations treat an mp_int as if it were a bit vector,\n-  without regard to its sign (an mp_int is represented in a signed\n-  magnitude format).  Values are treated as if they had an infinite\n-  string of zeros left of the most-significant bit.\n- *\/\n-\n-\/* Parity results                    *\/\n-\n-#define MP_EVEN       MP_YES\n-#define MP_ODD        MP_NO\n-\n-\/* Bitwise functions                 *\/\n-\n-mp_err mpl_not(mp_int *a, mp_int *b);            \/* one's complement  *\/\n-mp_err mpl_and(mp_int *a, mp_int *b, mp_int *c); \/* bitwise AND       *\/\n-mp_err mpl_or(mp_int *a, mp_int *b, mp_int *c);  \/* bitwise OR        *\/\n-mp_err mpl_xor(mp_int *a, mp_int *b, mp_int *c); \/* bitwise XOR       *\/\n-\n-\/* Shift functions                   *\/\n-\n-mp_err mpl_rsh(const mp_int *a, mp_int *b, mp_digit d);   \/* right shift    *\/\n-mp_err mpl_lsh(const mp_int *a, mp_int *b, mp_digit d);   \/* left shift     *\/\n-\n-\/* Bit count and parity              *\/\n-\n-mp_err mpl_num_set(mp_int *a, int *num);         \/* count set bits    *\/\n-mp_err mpl_num_clear(mp_int *a, int *num);       \/* count clear bits  *\/\n-mp_err mpl_parity(mp_int *a);                    \/* determine parity  *\/\n-\n-\/* Get & Set the value of a bit *\/\n-\n-mp_err mpl_set_bit(mp_int *a, mp_size bitNum, mp_size value);\n-mp_err mpl_get_bit(const mp_int *a, mp_size bitNum);\n-mp_err mpl_get_bits(const mp_int *a, mp_size lsbNum, mp_size numBits);\n-mp_err mpl_significant_bits(const mp_int *a);\n-\n-#endif \/* _MPLOGIC_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mplogic.h","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Netscape security libraries.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 2000\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Sheueling Chang Shantz <sheueling.chang@sun.com>,\n- *   Stephen Fung <stephen.fung@sun.com>, and\n- *   Douglas Stebila <douglas@stebila.ca> of Sun Laboratories.\n- *\n- *********************************************************************** *\/\n-\n-\/* This file implements moduluar exponentiation using Montgomery's\n- * method for modular reduction.  This file implements the method\n- * described as \"Improvement 1\" in the paper \"A Cryptogrpahic Library for\n- * the Motorola DSP56000\" by Stephen R. Dusse' and Burton S. Kaliski Jr.\n- * published in \"Advances in Cryptology: Proceedings of EUROCRYPT '90\"\n- * \"Lecture Notes in Computer Science\" volume 473, 1991, pg 230-244,\n- * published by Springer Verlag.\n- *\/\n-\n-#define MP_USING_CACHE_SAFE_MOD_EXP 1\n-#ifndef _KERNEL\n-#include <string.h>\n-#include <stddef.h> \/* ptrdiff_t *\/\n-#endif\n-#include \"mpi-priv.h\"\n-#include \"mplogic.h\"\n-#include \"mpprime.h\"\n-#ifdef MP_USING_MONT_MULF\n-#include \"montmulf.h\"\n-#endif\n-\n-\/* if MP_CHAR_STORE_SLOW is defined, we  *\/\n-\/* need to know endianness of this platform. *\/\n-#ifdef MP_CHAR_STORE_SLOW\n-#if !defined(MP_IS_BIG_ENDIAN) && !defined(MP_IS_LITTLE_ENDIAN)\n-#error \"You must define MP_IS_BIG_ENDIAN or MP_IS_LITTLE_ENDIAN\\n\" \\\n-       \"  if you define MP_CHAR_STORE_SLOW.\"\n-#endif\n-#endif\n-\n-#ifndef STATIC\n-#define STATIC\n-#endif\n-\n-#define MAX_ODD_INTS    32   \/* 2 ** (WINDOW_BITS - 1) *\/\n-\n-#ifndef _KERNEL\n-#if defined(_WIN32_WCE)\n-#define ABORT  res = MP_UNDEF; goto CLEANUP\n-#else\n-#define ABORT abort()\n-#endif\n-#else\n-#define ABORT  res = MP_UNDEF; goto CLEANUP\n-#endif \/* _KERNEL *\/\n-\n-\/* computes T = REDC(T), 2^b == R *\/\n-mp_err s_mp_redc(mp_int *T, mp_mont_modulus *mmm)\n-{\n-  mp_err res;\n-  mp_size i;\n-\n-  i = MP_USED(T) + MP_USED(&mmm->N) + 2;\n-  MP_CHECKOK( s_mp_pad(T, i) );\n-  for (i = 0; i < MP_USED(&mmm->N); ++i ) {\n-    mp_digit m_i = MP_DIGIT(T, i) * mmm->n0prime;\n-    \/* T += N * m_i * (MP_RADIX ** i); *\/\n-    MP_CHECKOK( s_mp_mul_d_add_offset(&mmm->N, m_i, T, i) );\n-  }\n-  s_mp_clamp(T);\n-\n-  \/* T \/= R *\/\n-  s_mp_div_2d(T, mmm->b);\n-\n-  if ((res = s_mp_cmp(T, &mmm->N)) >= 0) {\n-    \/* T = T - N *\/\n-    MP_CHECKOK( s_mp_sub(T, &mmm->N) );\n-#ifdef DEBUG\n-    if ((res = mp_cmp(T, &mmm->N)) >= 0) {\n-      res = MP_UNDEF;\n-      goto CLEANUP;\n-    }\n-#endif\n-  }\n-  res = MP_OKAY;\n-CLEANUP:\n-  return res;\n-}\n-\n-#if !defined(MP_ASSEMBLY_MUL_MONT) && !defined(MP_MONT_USE_MP_MUL)\n-mp_err s_mp_mul_mont(const mp_int *a, const mp_int *b, mp_int *c,\n-                   mp_mont_modulus *mmm)\n-{\n-  mp_digit *pb;\n-  mp_digit m_i;\n-  mp_err   res;\n-  mp_size  ib;\n-  mp_size  useda, usedb;\n-\n-  ARGCHK(a != NULL && b != NULL && c != NULL, MP_BADARG);\n-\n-  if (MP_USED(a) < MP_USED(b)) {\n-    const mp_int *xch = b;      \/* switch a and b, to do fewer outer loops *\/\n-    b = a;\n-    a = xch;\n-  }\n-\n-  MP_USED(c) = 1; MP_DIGIT(c, 0) = 0;\n-  ib = MP_USED(a) + MP_MAX(MP_USED(b), MP_USED(&mmm->N)) + 2;\n-  if((res = s_mp_pad(c, ib)) != MP_OKAY)\n-    goto CLEANUP;\n-\n-  useda = MP_USED(a);\n-  pb = MP_DIGITS(b);\n-  s_mpv_mul_d(MP_DIGITS(a), useda, *pb++, MP_DIGITS(c));\n-  s_mp_setz(MP_DIGITS(c) + useda + 1, ib - (useda + 1));\n-  m_i = MP_DIGIT(c, 0) * mmm->n0prime;\n-  s_mp_mul_d_add_offset(&mmm->N, m_i, c, 0);\n-\n-  \/* Outer loop:  Digits of b *\/\n-  usedb = MP_USED(b);\n-  for (ib = 1; ib < usedb; ib++) {\n-    mp_digit b_i    = *pb++;\n-\n-    \/* Inner product:  Digits of a *\/\n-    if (b_i)\n-      s_mpv_mul_d_add_prop(MP_DIGITS(a), useda, b_i, MP_DIGITS(c) + ib);\n-    m_i = MP_DIGIT(c, ib) * mmm->n0prime;\n-    s_mp_mul_d_add_offset(&mmm->N, m_i, c, ib);\n-  }\n-  if (usedb < MP_USED(&mmm->N)) {\n-    for (usedb = MP_USED(&mmm->N); ib < usedb; ++ib ) {\n-      m_i = MP_DIGIT(c, ib) * mmm->n0prime;\n-      s_mp_mul_d_add_offset(&mmm->N, m_i, c, ib);\n-    }\n-  }\n-  s_mp_clamp(c);\n-  s_mp_div_2d(c, mmm->b);\n-  if (s_mp_cmp(c, &mmm->N) >= 0) {\n-    MP_CHECKOK( s_mp_sub(c, &mmm->N) );\n-  }\n-  res = MP_OKAY;\n-\n-CLEANUP:\n-  return res;\n-}\n-#endif\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mpmontg.c","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the MPI Arbitrary Precision Integer Arithmetic library.\n- *\n- * The Initial Developer of the Original Code is\n- * Michael J. Fromberger.\n- * Portions created by the Initial Developer are Copyright (C) 1997\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *\n- *********************************************************************** *\/\n-\n-\/*  Utilities for finding and working with prime and pseudo-prime integers *\/\n-\n-#ifndef _MP_PRIME_H\n-#define _MP_PRIME_H\n-\n-#include \"mpi.h\"\n-\n-extern const int prime_tab_size;   \/* number of primes available *\/\n-extern const mp_digit prime_tab[];\n-\n-\/* Tests for divisibility    *\/\n-mp_err  mpp_divis(mp_int *a, mp_int *b);\n-mp_err  mpp_divis_d(mp_int *a, mp_digit d);\n-\n-\/* Random selection          *\/\n-mp_err  mpp_random(mp_int *a);\n-mp_err  mpp_random_size(mp_int *a, mp_size prec);\n-\n-\/* Pseudo-primality testing  *\/\n-mp_err  mpp_divis_vector(mp_int *a, const mp_digit *vec, int size, int *which);\n-mp_err  mpp_divis_primes(mp_int *a, mp_digit *np);\n-mp_err  mpp_fermat(mp_int *a, mp_digit w);\n-mp_err mpp_fermat_list(mp_int *a, const mp_digit *primes, mp_size nPrimes);\n-mp_err  mpp_pprime(mp_int *a, int nt);\n-mp_err mpp_sieve(mp_int *trial, const mp_digit *primes, mp_size nPrimes,\n-                 unsigned char *sieve, mp_size nSieve);\n-mp_err mpp_make_prime(mp_int *start, mp_size nBits, mp_size strong,\n-                      unsigned long * nTries);\n-\n-#endif \/* _MP_PRIME_H *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/mpprime.h","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,538 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Netscape security libraries.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 1994-2000\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com>, Sun Microsystems Laboratories\n- *\n- * Last Modified Date from the Original Code: March 2012\n- *********************************************************************** *\/\n-\n-#include <sys\/types.h>\n-\n-#ifndef _WIN32\n-#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)\n-#include <sys\/systm.h>\n-#endif \/* __linux__ || _ALLBSD_SOURCE *\/\n-#include <sys\/param.h>\n-#endif \/* _WIN32 *\/\n-\n-#ifdef _KERNEL\n-#include <sys\/kmem.h>\n-#else\n-#include <string.h>\n-#endif\n-#include \"ec.h\"\n-#include \"ecl-curve.h\"\n-#include \"ecc_impl.h\"\n-#include \"secoidt.h\"\n-\n-#define CERTICOM_OID            0x2b, 0x81, 0x04\n-#define SECG_OID                CERTICOM_OID, 0x00\n-\n-#define ANSI_X962_OID           0x2a, 0x86, 0x48, 0xce, 0x3d\n-#define ANSI_X962_CURVE_OID     ANSI_X962_OID, 0x03\n-#define ANSI_X962_GF2m_OID      ANSI_X962_CURVE_OID, 0x00\n-#define ANSI_X962_GFp_OID       ANSI_X962_CURVE_OID, 0x01\n-\n-#define TELETRUST_ALGO_OID             0x2b, 0x24, 0x03\n-#define ECC_BRAINPOOL                  TELETRUST_ALGO_OID, 0x03, 0x02, 0x08\n-#define ECC_BRAINPOOL_EC_V1            ECC_BRAINPOOL, 0x01, 0x01\n-\n-#define CONST_OID static const unsigned char\n-\n-\/* ANSI X9.62 prime curve OIDs *\/\n-\/* NOTE: prime192v1 is the same as secp192r1, prime256v1 is the\n- * same as secp256r1\n- *\/\n-CONST_OID ansiX962prime192v1[] = { ANSI_X962_GFp_OID, 0x01 };\n-CONST_OID ansiX962prime192v2[] = { ANSI_X962_GFp_OID, 0x02 };\n-CONST_OID ansiX962prime192v3[] = { ANSI_X962_GFp_OID, 0x03 };\n-CONST_OID ansiX962prime239v1[] = { ANSI_X962_GFp_OID, 0x04 };\n-CONST_OID ansiX962prime239v2[] = { ANSI_X962_GFp_OID, 0x05 };\n-CONST_OID ansiX962prime239v3[] = { ANSI_X962_GFp_OID, 0x06 };\n-CONST_OID ansiX962prime256v1[] = { ANSI_X962_GFp_OID, 0x07 };\n-\n-\/* SECG prime curve OIDs *\/\n-CONST_OID secgECsecp112r1[] = { SECG_OID, 0x06 };\n-CONST_OID secgECsecp112r2[] = { SECG_OID, 0x07 };\n-CONST_OID secgECsecp128r1[] = { SECG_OID, 0x1c };\n-CONST_OID secgECsecp128r2[] = { SECG_OID, 0x1d };\n-CONST_OID secgECsecp160k1[] = { SECG_OID, 0x09 };\n-CONST_OID secgECsecp160r1[] = { SECG_OID, 0x08 };\n-CONST_OID secgECsecp160r2[] = { SECG_OID, 0x1e };\n-CONST_OID secgECsecp192k1[] = { SECG_OID, 0x1f };\n-CONST_OID secgECsecp224k1[] = { SECG_OID, 0x20 };\n-CONST_OID secgECsecp224r1[] = { SECG_OID, 0x21 };\n-CONST_OID secgECsecp256k1[] = { SECG_OID, 0x0a };\n-CONST_OID secgECsecp384r1[] = { SECG_OID, 0x22 };\n-CONST_OID secgECsecp521r1[] = { SECG_OID, 0x23 };\n-\n-\/* SECG characterisitic two curve OIDs *\/\n-CONST_OID secgECsect113r1[] = {SECG_OID, 0x04 };\n-CONST_OID secgECsect113r2[] = {SECG_OID, 0x05 };\n-CONST_OID secgECsect131r1[] = {SECG_OID, 0x16 };\n-CONST_OID secgECsect131r2[] = {SECG_OID, 0x17 };\n-CONST_OID secgECsect163k1[] = {SECG_OID, 0x01 };\n-CONST_OID secgECsect163r1[] = {SECG_OID, 0x02 };\n-CONST_OID secgECsect163r2[] = {SECG_OID, 0x0f };\n-CONST_OID secgECsect193r1[] = {SECG_OID, 0x18 };\n-CONST_OID secgECsect193r2[] = {SECG_OID, 0x19 };\n-CONST_OID secgECsect233k1[] = {SECG_OID, 0x1a };\n-CONST_OID secgECsect233r1[] = {SECG_OID, 0x1b };\n-CONST_OID secgECsect239k1[] = {SECG_OID, 0x03 };\n-CONST_OID secgECsect283k1[] = {SECG_OID, 0x10 };\n-CONST_OID secgECsect283r1[] = {SECG_OID, 0x11 };\n-CONST_OID secgECsect409k1[] = {SECG_OID, 0x24 };\n-CONST_OID secgECsect409r1[] = {SECG_OID, 0x25 };\n-CONST_OID secgECsect571k1[] = {SECG_OID, 0x26 };\n-CONST_OID secgECsect571r1[] = {SECG_OID, 0x27 };\n-\n-\/* ANSI X9.62 characteristic two curve OIDs *\/\n-CONST_OID ansiX962c2pnb163v1[] = { ANSI_X962_GF2m_OID, 0x01 };\n-CONST_OID ansiX962c2pnb163v2[] = { ANSI_X962_GF2m_OID, 0x02 };\n-CONST_OID ansiX962c2pnb163v3[] = { ANSI_X962_GF2m_OID, 0x03 };\n-CONST_OID ansiX962c2pnb176v1[] = { ANSI_X962_GF2m_OID, 0x04 };\n-CONST_OID ansiX962c2tnb191v1[] = { ANSI_X962_GF2m_OID, 0x05 };\n-CONST_OID ansiX962c2tnb191v2[] = { ANSI_X962_GF2m_OID, 0x06 };\n-CONST_OID ansiX962c2tnb191v3[] = { ANSI_X962_GF2m_OID, 0x07 };\n-CONST_OID ansiX962c2onb191v4[] = { ANSI_X962_GF2m_OID, 0x08 };\n-CONST_OID ansiX962c2onb191v5[] = { ANSI_X962_GF2m_OID, 0x09 };\n-CONST_OID ansiX962c2pnb208w1[] = { ANSI_X962_GF2m_OID, 0x0a };\n-CONST_OID ansiX962c2tnb239v1[] = { ANSI_X962_GF2m_OID, 0x0b };\n-CONST_OID ansiX962c2tnb239v2[] = { ANSI_X962_GF2m_OID, 0x0c };\n-CONST_OID ansiX962c2tnb239v3[] = { ANSI_X962_GF2m_OID, 0x0d };\n-CONST_OID ansiX962c2onb239v4[] = { ANSI_X962_GF2m_OID, 0x0e };\n-CONST_OID ansiX962c2onb239v5[] = { ANSI_X962_GF2m_OID, 0x0f };\n-CONST_OID ansiX962c2pnb272w1[] = { ANSI_X962_GF2m_OID, 0x10 };\n-CONST_OID ansiX962c2pnb304w1[] = { ANSI_X962_GF2m_OID, 0x11 };\n-CONST_OID ansiX962c2tnb359v1[] = { ANSI_X962_GF2m_OID, 0x12 };\n-CONST_OID ansiX962c2pnb368w1[] = { ANSI_X962_GF2m_OID, 0x13 };\n-CONST_OID ansiX962c2tnb431r1[] = { ANSI_X962_GF2m_OID, 0x14 };\n-\n-\/* TeleTrusT ECC Brainpool prime curve OIDs *\/\n-CONST_OID brainpoolP160r1[] = { ECC_BRAINPOOL_EC_V1, 0x01 };\n-CONST_OID brainpoolP160t1[] = { ECC_BRAINPOOL_EC_V1, 0x02 };\n-CONST_OID brainpoolP192r1[] = { ECC_BRAINPOOL_EC_V1, 0x03 };\n-CONST_OID brainpoolP192t1[] = { ECC_BRAINPOOL_EC_V1, 0x04 };\n-CONST_OID brainpoolP224r1[] = { ECC_BRAINPOOL_EC_V1, 0x05 };\n-CONST_OID brainpoolP224t1[] = { ECC_BRAINPOOL_EC_V1, 0x06 };\n-CONST_OID brainpoolP256r1[] = { ECC_BRAINPOOL_EC_V1, 0x07 };\n-CONST_OID brainpoolP256t1[] = { ECC_BRAINPOOL_EC_V1, 0x08 };\n-CONST_OID brainpoolP320r1[] = { ECC_BRAINPOOL_EC_V1, 0x09 };\n-CONST_OID brainpoolP320t1[] = { ECC_BRAINPOOL_EC_V1, 0x0a };\n-CONST_OID brainpoolP384r1[] = { ECC_BRAINPOOL_EC_V1, 0x0b };\n-CONST_OID brainpoolP384t1[] = { ECC_BRAINPOOL_EC_V1, 0x0c };\n-CONST_OID brainpoolP512r1[] = { ECC_BRAINPOOL_EC_V1, 0x0d };\n-CONST_OID brainpoolP512t1[] = { ECC_BRAINPOOL_EC_V1, 0x0e };\n-\n-#define OI(x) { siDEROID, (unsigned char *)x, sizeof x }\n-#ifndef SECOID_NO_STRINGS\n-#define OD(oid,tag,desc,mech,ext) { OI(oid), tag, desc, mech, ext }\n-#else\n-#define OD(oid,tag,desc,mech,ext) { OI(oid), tag, 0, mech, ext }\n-#endif\n-\n-#define CKM_INVALID_MECHANISM 0xffffffffUL\n-\n-\/* XXX this is incorrect *\/\n-#define INVALID_CERT_EXTENSION 1\n-\n-#define CKM_ECDSA                      0x00001041\n-#define CKM_ECDSA_SHA1                 0x00001042\n-#define CKM_ECDH1_DERIVE               0x00001050\n-\n-static SECOidData ANSI_prime_oids[] = {\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-\n-    OD( ansiX962prime192v1, ECCurve_NIST_P192,\n-        \"ANSI X9.62 elliptic curve prime192v1 (aka secp192r1, NIST P-192)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962prime192v2, ECCurve_X9_62_PRIME_192V2,\n-        \"ANSI X9.62 elliptic curve prime192v2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962prime192v3, ECCurve_X9_62_PRIME_192V3,\n-        \"ANSI X9.62 elliptic curve prime192v3\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962prime239v1, ECCurve_X9_62_PRIME_239V1,\n-        \"ANSI X9.62 elliptic curve prime239v1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962prime239v2, ECCurve_X9_62_PRIME_239V2,\n-        \"ANSI X9.62 elliptic curve prime239v2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962prime239v3, ECCurve_X9_62_PRIME_239V3,\n-        \"ANSI X9.62 elliptic curve prime239v3\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962prime256v1, ECCurve_NIST_P256,\n-        \"ANSI X9.62 elliptic curve prime256v1 (aka secp256r1, NIST P-256)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION )\n-};\n-\n-static SECOidData SECG_oids[] = {\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-\n-    OD( secgECsect163k1, ECCurve_NIST_K163,\n-        \"SECG elliptic curve sect163k1 (aka NIST K-163)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect163r1, ECCurve_SECG_CHAR2_163R1,\n-        \"SECG elliptic curve sect163r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect239k1, ECCurve_SECG_CHAR2_239K1,\n-        \"SECG elliptic curve sect239k1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect113r1, ECCurve_SECG_CHAR2_113R1,\n-        \"SECG elliptic curve sect113r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect113r2, ECCurve_SECG_CHAR2_113R2,\n-        \"SECG elliptic curve sect113r2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp112r1, ECCurve_SECG_PRIME_112R1,\n-        \"SECG elliptic curve secp112r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp112r2, ECCurve_SECG_PRIME_112R2,\n-        \"SECG elliptic curve secp112r2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp160r1, ECCurve_SECG_PRIME_160R1,\n-        \"SECG elliptic curve secp160r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp160k1, ECCurve_SECG_PRIME_160K1,\n-        \"SECG elliptic curve secp160k1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp256k1, ECCurve_SECG_PRIME_256K1,\n-        \"SECG elliptic curve secp256k1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( secgECsect163r2, ECCurve_NIST_B163,\n-        \"SECG elliptic curve sect163r2 (aka NIST B-163)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect283k1, ECCurve_NIST_K283,\n-        \"SECG elliptic curve sect283k1 (aka NIST K-283)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect283r1, ECCurve_NIST_B283,\n-        \"SECG elliptic curve sect283r1 (aka NIST B-283)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( secgECsect131r1, ECCurve_SECG_CHAR2_131R1,\n-        \"SECG elliptic curve sect131r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect131r2, ECCurve_SECG_CHAR2_131R2,\n-        \"SECG elliptic curve sect131r2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect193r1, ECCurve_SECG_CHAR2_193R1,\n-        \"SECG elliptic curve sect193r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect193r2, ECCurve_SECG_CHAR2_193R2,\n-        \"SECG elliptic curve sect193r2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect233k1, ECCurve_NIST_K233,\n-        \"SECG elliptic curve sect233k1 (aka NIST K-233)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect233r1, ECCurve_NIST_B233,\n-        \"SECG elliptic curve sect233r1 (aka NIST B-233)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp128r1, ECCurve_SECG_PRIME_128R1,\n-        \"SECG elliptic curve secp128r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp128r2, ECCurve_SECG_PRIME_128R2,\n-        \"SECG elliptic curve secp128r2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp160r2, ECCurve_SECG_PRIME_160R2,\n-        \"SECG elliptic curve secp160r2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp192k1, ECCurve_SECG_PRIME_192K1,\n-        \"SECG elliptic curve secp192k1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp224k1, ECCurve_SECG_PRIME_224K1,\n-        \"SECG elliptic curve secp224k1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp224r1, ECCurve_NIST_P224,\n-        \"SECG elliptic curve secp224r1 (aka NIST P-224)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp384r1, ECCurve_NIST_P384,\n-        \"SECG elliptic curve secp384r1 (aka NIST P-384)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsecp521r1, ECCurve_NIST_P521,\n-        \"SECG elliptic curve secp521r1 (aka NIST P-521)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect409k1, ECCurve_NIST_K409,\n-        \"SECG elliptic curve sect409k1 (aka NIST K-409)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect409r1, ECCurve_NIST_B409,\n-        \"SECG elliptic curve sect409r1 (aka NIST B-409)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect571k1, ECCurve_NIST_K571,\n-        \"SECG elliptic curve sect571k1 (aka NIST K-571)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( secgECsect571r1, ECCurve_NIST_B571,\n-        \"SECG elliptic curve sect571r1 (aka NIST B-571)\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION )\n-};\n-\n-static SECOidData ANSI_oids[] = {\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-\n-    \/* ANSI X9.62 named elliptic curves (characteristic two field) *\/\n-    OD( ansiX962c2pnb163v1, ECCurve_X9_62_CHAR2_PNB163V1,\n-        \"ANSI X9.62 elliptic curve c2pnb163v1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2pnb163v2, ECCurve_X9_62_CHAR2_PNB163V2,\n-        \"ANSI X9.62 elliptic curve c2pnb163v2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2pnb163v3, ECCurve_X9_62_CHAR2_PNB163V3,\n-        \"ANSI X9.62 elliptic curve c2pnb163v3\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2pnb176v1, ECCurve_X9_62_CHAR2_PNB176V1,\n-        \"ANSI X9.62 elliptic curve c2pnb176v1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb191v1, ECCurve_X9_62_CHAR2_TNB191V1,\n-        \"ANSI X9.62 elliptic curve c2tnb191v1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb191v2, ECCurve_X9_62_CHAR2_TNB191V2,\n-        \"ANSI X9.62 elliptic curve c2tnb191v2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb191v3, ECCurve_X9_62_CHAR2_TNB191V3,\n-        \"ANSI X9.62 elliptic curve c2tnb191v3\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( ansiX962c2pnb208w1, ECCurve_X9_62_CHAR2_PNB208W1,\n-        \"ANSI X9.62 elliptic curve c2pnb208w1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb239v1, ECCurve_X9_62_CHAR2_TNB239V1,\n-        \"ANSI X9.62 elliptic curve c2tnb239v1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb239v2, ECCurve_X9_62_CHAR2_TNB239V2,\n-        \"ANSI X9.62 elliptic curve c2tnb239v2\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb239v3, ECCurve_X9_62_CHAR2_TNB239V3,\n-        \"ANSI X9.62 elliptic curve c2tnb239v3\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( ansiX962c2pnb272w1, ECCurve_X9_62_CHAR2_PNB272W1,\n-        \"ANSI X9.62 elliptic curve c2pnb272w1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2pnb304w1, ECCurve_X9_62_CHAR2_PNB304W1,\n-        \"ANSI X9.62 elliptic curve c2pnb304w1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb359v1, ECCurve_X9_62_CHAR2_TNB359V1,\n-        \"ANSI X9.62 elliptic curve c2tnb359v1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2pnb368w1, ECCurve_X9_62_CHAR2_PNB368W1,\n-        \"ANSI X9.62 elliptic curve c2pnb368w1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    OD( ansiX962c2tnb431r1, ECCurve_X9_62_CHAR2_TNB431R1,\n-        \"ANSI X9.62 elliptic curve c2tnb431r1\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION )\n-};\n-\n-static SECOidData BRAINPOOL_oids[] = {\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-\n-    \/* RFC 5639 Brainpool named elliptic curves *\/\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( brainpoolP256r1, ECCurve_BrainpoolP256r1,\n-        \"brainpoolP256r1 domain parameter set\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( brainpoolP320r1, ECCurve_BrainpoolP320r1,\n-        \"brainpoolP320r1 domain parameter set\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( brainpoolP384r1, ECCurve_BrainpoolP384r1,\n-        \"brainpoolP384r1 domain parameter set\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM, INVALID_CERT_EXTENSION },\n-    OD( brainpoolP512r1, ECCurve_BrainpoolP512r1,\n-        \"brainpoolP512r1 domain parameter set\",\n-        CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION ),\n-    { { siDEROID, NULL, 0 }, ECCurve_noName,\n-        \"Unknown OID\", CKM_INVALID_MECHANISM,\n-        INVALID_CERT_EXTENSION }\n-};\n-\n-int\n-oideql(unsigned char *reqoid, unsigned char *foundoid, size_t reqlen, size_t foundlen)\n-{\n-    if (!reqoid || !foundoid) {\n-        return 0;\n-    }\n-\n-    if (reqlen != foundlen) {\n-        return 0;\n-    }\n-\n-    return memcmp(reqoid, foundoid, reqlen) == 0;\n-}\n-\n-SECOidData *\n-SECOID_FindOID(const SECItem *oid)\n-{\n-    SECOidData *po;\n-    SECOidData *ret = NULL;\n-    int reqlen = oid->len;\n-\n-    if (reqlen == 8) {\n-        if (oid->data[6] == 0x00) {\n-            \/* XXX bounds check *\/\n-            po = &ANSI_oids[oid->data[7]];\n-            if (oideql(oid->data, po->oid.data, reqlen, po->oid.len)) {\n-                ret = po;\n-            }\n-        }\n-        if (oid->data[6] == 0x01) {\n-            \/* XXX bounds check *\/\n-            po = &ANSI_prime_oids[oid->data[7]];\n-            if (oideql(oid->data, po->oid.data, reqlen, po->oid.len)) {\n-                ret = po;\n-            }\n-        }\n-    } else if (reqlen == 5) {\n-        \/* XXX bounds check *\/\n-        po = &SECG_oids[oid->data[4]];\n-        if (oideql(oid->data, po->oid.data, reqlen, po->oid.len)) {\n-            ret = po;\n-        }\n-    } else if (reqlen == 9) {\n-        \/* XXX bounds check *\/\n-        po = &BRAINPOOL_oids[oid->data[8]];\n-        if (oideql(oid->data, po->oid.data, reqlen, po->oid.len)) {\n-           ret = po;\n-        }\n-    }\n-    return(ret);\n-}\n-\n-ECCurveName\n-SECOID_FindOIDTag(const SECItem *oid)\n-{\n-    SECOidData *oiddata;\n-\n-    oiddata = SECOID_FindOID (oid);\n-    if (oiddata == NULL)\n-        return ECCurve_noName;\n-\n-    return oiddata->offset;\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/oid.c","additions":0,"deletions":538,"binary":false,"changes":538,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Netscape security libraries.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 1994-2000\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *\n- * Last Modified Date from the Original Code: March 2012\n- *********************************************************************** *\/\n-\n-\/*\n- * Support routines for SECItem data structure.\n- *\n- * $Id: secitem.c,v 1.14 2006\/05\/22 22:24:34 wtchang%redhat.com Exp $\n- *\/\n-\n-#include <sys\/types.h>\n-\n-#ifndef _WIN32\n-#if !defined(__linux__) && !defined(_ALLBSD_SOURCE)\n-#include <sys\/systm.h>\n-#endif \/* __linux__ || _ALLBSD_SOURCE *\/\n-#include <sys\/param.h>\n-#endif \/* _WIN32 *\/\n-\n-#ifdef _KERNEL\n-#include <sys\/kmem.h>\n-#else\n-#include <string.h>\n-\n-#ifndef _WIN32\n-#include <strings.h>\n-#endif \/* _WIN32 *\/\n-\n-#include <assert.h>\n-#endif\n-#include \"ec.h\"\n-#include \"ecl-curve.h\"\n-#include \"ecc_impl.h\"\n-\n-void SECITEM_FreeItem(SECItem *, PRBool);\n-\n-SECItem *\n-SECITEM_AllocItem(PRArenaPool *arena, SECItem *item, unsigned int len,\n-    int kmflag)\n-{\n-    SECItem *result = NULL;\n-    void *mark = NULL;\n-\n-    if (arena != NULL) {\n-        mark = PORT_ArenaMark(arena);\n-    }\n-\n-    if (item == NULL) {\n-        if (arena != NULL) {\n-            result = PORT_ArenaZAlloc(arena, sizeof(SECItem), kmflag);\n-        } else {\n-            result = PORT_ZAlloc(sizeof(SECItem), kmflag);\n-        }\n-        if (result == NULL) {\n-            goto loser;\n-        }\n-    } else {\n-        PORT_Assert(item->data == NULL);\n-        result = item;\n-    }\n-\n-    result->len = len;\n-    if (len) {\n-        if (arena != NULL) {\n-            result->data = PORT_ArenaAlloc(arena, len, kmflag);\n-        } else {\n-            result->data = PORT_Alloc(len, kmflag);\n-        }\n-        if (result->data == NULL) {\n-            goto loser;\n-        }\n-    } else {\n-        result->data = NULL;\n-    }\n-\n-    if (mark) {\n-        PORT_ArenaUnmark(arena, mark);\n-    }\n-    return(result);\n-\n-loser:\n-    if ( arena != NULL ) {\n-        if (mark) {\n-            PORT_ArenaRelease(arena, mark);\n-        }\n-        if (item != NULL) {\n-            item->data = NULL;\n-            item->len = 0;\n-        }\n-    } else {\n-        if (result != NULL) {\n-            SECITEM_FreeItem(result, (item == NULL) ? PR_TRUE : PR_FALSE);\n-        }\n-        \/*\n-         * If item is not NULL, the above has set item->data and\n-         * item->len to 0.\n-         *\/\n-    }\n-    return(NULL);\n-}\n-\n-SECStatus\n-SECITEM_CopyItem(PRArenaPool *arena, SECItem *to, const SECItem *from,\n-   int kmflag)\n-{\n-    to->type = from->type;\n-    if (from->data && from->len) {\n-        if ( arena ) {\n-            to->data = (unsigned char*) PORT_ArenaAlloc(arena, from->len,\n-                kmflag);\n-        } else {\n-            to->data = (unsigned char*) PORT_Alloc(from->len, kmflag);\n-        }\n-\n-        if (!to->data) {\n-            return SECFailure;\n-        }\n-        PORT_Memcpy(to->data, from->data, from->len);\n-        to->len = from->len;\n-    } else {\n-        to->data = 0;\n-        to->len = 0;\n-    }\n-    return SECSuccess;\n-}\n-\n-void\n-SECITEM_FreeItem(SECItem *zap, PRBool freeit)\n-{\n-    if (zap) {\n-#ifdef _KERNEL\n-        kmem_free(zap->data, zap->len);\n-#else\n-        free(zap->data);\n-#endif\n-        zap->data = 0;\n-        zap->len = 0;\n-        if (freeit) {\n-#ifdef _KERNEL\n-            kmem_free(zap, sizeof (SECItem));\n-#else\n-            free(zap);\n-#endif\n-        }\n-    }\n-}\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/secitem.c","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2007, 2011, Oracle and\/or its affiliates. All rights reserved.\n- * Use is subject to license terms.\n- *\n- * This library is free software; you can redistribute it and\/or\n- * modify it under the terms of the GNU Lesser General Public\n- * License as published by the Free Software Foundation; either\n- * version 2.1 of the License, or (at your option) any later version.\n- *\n- * This library is distributed in the hope that it will be useful,\n- * but WITHOUT ANY WARRANTY; without even the implied warranty of\n- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n- * Lesser General Public License for more details.\n- *\n- * You should have received a copy of the GNU Lesser General Public License\n- * along with this library; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* *********************************************************************\n- *\n- * The Original Code is the Netscape security libraries.\n- *\n- * The Initial Developer of the Original Code is\n- * Netscape Communications Corporation.\n- * Portions created by the Initial Developer are Copyright (C) 1994-2000\n- * the Initial Developer. All Rights Reserved.\n- *\n- * Contributor(s):\n- *   Dr Vipul Gupta <vipul.gupta@sun.com>, Sun Microsystems Laboratories\n- *\n- *********************************************************************** *\/\n-\n-#ifndef _SECOIDT_H_\n-#define _SECOIDT_H_\n-\n-\/*\n- * secoidt.h - public data structures for ASN.1 OID functions\n- *\n- * $Id: secoidt.h,v 1.23 2007\/05\/05 22:45:16 nelson%bolyard.com Exp $\n- *\/\n-\n-typedef struct SECOidDataStr SECOidData;\n-typedef struct SECAlgorithmIDStr SECAlgorithmID;\n-\n-\/*\n-** An X.500 algorithm identifier\n-*\/\n-struct SECAlgorithmIDStr {\n-    SECItem algorithm;\n-    SECItem parameters;\n-};\n-\n-#define SEC_OID_SECG_EC_SECP192R1 SEC_OID_ANSIX962_EC_PRIME192V1\n-#define SEC_OID_SECG_EC_SECP256R1 SEC_OID_ANSIX962_EC_PRIME256V1\n-#define SEC_OID_PKCS12_KEY_USAGE  SEC_OID_X509_KEY_USAGE\n-\n-\/* fake OID for DSS sign\/verify *\/\n-#define SEC_OID_SHA SEC_OID_MISS_DSS\n-\n-typedef enum {\n-    INVALID_CERT_EXTENSION = 0,\n-    UNSUPPORTED_CERT_EXTENSION = 1,\n-    SUPPORTED_CERT_EXTENSION = 2\n-} SECSupportExtenTag;\n-\n-struct SECOidDataStr {\n-    SECItem            oid;\n-    ECCurveName        offset;\n-    const char *       desc;\n-    unsigned long      mechanism;\n-    SECSupportExtenTag supportedExtension;\n-                                \/* only used for x.509 v3 extensions, so\n-                                   that we can print the names of those\n-                                   extensions that we don't even support *\/\n-};\n-\n-#endif \/* _SECOIDT_H_ *\/\n","filename":"src\/jdk.crypto.ec\/share\/native\/libsunec\/impl\/secoidt.h","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -34,2 +34,0 @@\n- * @run main\/othervm -Djdk.sunec.disableNative=false KeyAgreementTest\n- *     ECDHNative EC SunEC\n@@ -59,4 +57,0 @@\n-        \/\/ Switch kaAlgo to ECDH as it is used for algorithm names\n-        if (kaAlgo.equals(\"ECDHNative\")) {\n-            kaAlgo = \"ECDH\";\n-        }\n@@ -77,20 +71,1 @@\n-        \/\/ and\n-        \/\/ \"jdk.crypto.ec\/share\/native\/libsunec\/impl\/ecdecode.c\"\n-        ECDHNative(\n-                \/\/ SEC2 prime curves\n-                \"secp112r1\", \"secp112r2\", \"secp128r1\", \"secp128r2\", \"secp160k1\",\n-                \"secp160r1\", \"secp192k1\", \"secp192r1\", \"secp224k1\", \"secp224r1\",\n-                \"secp256k1\", \"secp256r1\", \"secp384r1\", \"secp521r1\", \"SECP521R1\",\n-                \/\/ ANSI X9.62 prime curves\n-                \"X9.62 prime192v2\", \"X9.62 prime192v3\", \"X9.62 prime239v1\",\n-                \"X9.62 prime239v2\", \"X9.62 prime239v3\",\n-                \/\/ SEC2 binary curves\n-                \"sect113r1\", \"sect113r2\", \"sect131r1\", \"sect131r2\", \"sect163k1\",\n-                \"sect163r1\", \"sect163r2\", \"sect193r1\", \"sect193r2\", \"sect233k1\",\n-                \"sect233r1\", \"sect239k1\", \"sect283k1\", \"sect283r1\", \"sect409k1\",\n-                \"sect409r1\", \"sect571k1\", \"sect571r1\",\n-                \/\/ ANSI X9.62 binary curves\n-                \"X9.62 c2tnb191v1\", \"X9.62 c2tnb191v2\", \"X9.62 c2tnb191v3\",\n-                \"X9.62 c2tnb239v1\", \"X9.62 c2tnb239v2\", \"X9.62 c2tnb239v3\",\n-                \"X9.62 c2tnb359v1\", \"X9.62 c2tnb431r1\"\n-        ),\n+\n@@ -108,1 +83,0 @@\n-                    case \"ECDHNative\":\n@@ -131,1 +105,1 @@\n-     * Perform KeyAgreement operation using native as well as JCE provider.\n+     * Perform KeyAgreement operation\n","filename":"test\/jdk\/java\/security\/KeyAgreement\/KeyAgreementTest.java","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n- * @run main\/othervm -Djdk.sunec.disableNative=false KeySizeTest ECDH SunEC EC 128\n- * @run main\/othervm -Djdk.sunec.disableNative=false KeySizeTest ECDH SunEC EC 192\n@@ -43,0 +41,2 @@\n+ * @run main\/othervm KeySizeTest ECDH SunEC EC 384\n+ * @run main\/othervm KeySizeTest ECDH SunEC EC 521\n","filename":"test\/jdk\/java\/security\/KeyAgreement\/KeySizeTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -375,1 +375,0 @@\n-            Cert.CA_ECDSA_SECT283R1,\n@@ -382,1 +381,0 @@\n-            Cert.EE_ECDSA_SECT283R1,\n@@ -708,26 +706,0 @@\n-         CA_ECDSA_SECT283R1(\n-                \"EC\",\n-                \/\/ SHA1withECDSA, curve sect283r1\n-                \/\/ Validity\n-                \/\/     Not Before: May 26 06:06:52 2020 GMT\n-                \/\/     Not After : May 21 06:06:52 2040 GMT\n-                \/\/ Subject Key Identifier:\n-                \/\/     CF:A3:99:ED:4C:6E:04:41:09:21:31:33:B6:80:D5:A7:BF:2B:98:04\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIIB8TCCAY+gAwIBAgIJANQFsBngZ3iMMAsGByqGSM49BAEFADBdMQswCQYDVQQG\\n\" +\n-                \"EwJVUzELMAkGA1UECBMCQ0ExCzAJBgNVBAcTAlNBMQ8wDQYDVQQKEwZPcmFjbGUx\\n\" +\n-                \"DzANBgNVBAsTBkpQR1NRRTESMBAGA1UEAxMJc2VjdDI4M3IxMB4XDTIwMDUyNjE4\\n\" +\n-                \"MDY1MloXDTQwMDUyMTE4MDY1MlowXTELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNB\\n\" +\n-                \"MQswCQYDVQQHEwJTQTEPMA0GA1UEChMGT3JhY2xlMQ8wDQYDVQQLEwZKUEdTUUUx\\n\" +\n-                \"EjAQBgNVBAMTCXNlY3QyODNyMTBeMBAGByqGSM49AgEGBSuBBAARA0oABALatmDt\\n\" +\n-                \"QIhjpK4vJjv4GgC8CUH\/VAWLUSQRU7yGGQ3NF8rVBARv0aehiII0nzjDVX5KrP\/A\\n\" +\n-                \"w\/DmW7q8PfEAIktuaA\/tcKv\/OKMyMDAwHQYDVR0OBBYEFM+jme1MbgRBCSExM7aA\\n\" +\n-                \"1ae\/K5gEMA8GA1UdEwEB\/wQFMAMBAf8wCwYHKoZIzj0EAQUAA08AMEwCJAGHsAP8\\n\" +\n-                \"HlcVqszra+fxq35juTxHJIfxTKIr7f54Ywtz7AJowgIkAxydv8g+dkuniOUAj0Xt\\n\" +\n-                \"FnGVp6HzKX5KM1zLpfqmix8ZPP\/A\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIGQAgEAMBAGByqGSM49AgEGBSuBBAARBHkwdwIBAQQkAdcyn\/FxiNvuTsSgDehq\\n\" +\n-                \"SGFiTxAKNMMJfmsO6GHekzszFqjPoUwDSgAEAtq2YO1AiGOkri8mO\/gaALwJQf9U\\n\" +\n-                \"BYtRJBFTvIYZDc0XytUEBG\/Rp6GIgjSfOMNVfkqs\/8DD8OZburw98QAiS25oD+1w\\n\" +\n-                \"q\/84\"),\n-\n@@ -920,27 +892,0 @@\n-        EE_ECDSA_SECT283R1(\n-                \"EC\",\n-                \/\/ SHA1withECDSA, curve sect283r1\n-                \/\/ Validity\n-                \/\/     Not Before: May 26 06:08:15 2020 GMT\n-                \/\/     Not After : May 21 06:08:15 2040 GMT\n-                \/\/ Authority Key Identifier:\n-                \/\/     CF:A3:99:ED:4C:6E:04:41:09:21:31:33:B6:80:D5:A7:BF:2B:98:04\n-                \"-----BEGIN CERTIFICATE-----\\n\" +\n-                \"MIICFTCCAbOgAwIBAgIJAM0Dd9zxR9CeMAsGByqGSM49BAEFADBdMQswCQYDVQQG\\n\" +\n-                \"EwJVUzELMAkGA1UECBMCQ0ExCzAJBgNVBAcTAlNBMQ8wDQYDVQQKEwZPcmFjbGUx\\n\" +\n-                \"DzANBgNVBAsTBkpQR1NRRTESMBAGA1UEAxMJc2VjdDI4M3IxMB4XDTIwMDUyNjE4\\n\" +\n-                \"MDgxNVoXDTQwMDUyMTE4MDgxNVowYDELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNB\\n\" +\n-                \"MQswCQYDVQQHEwJTQTEPMA0GA1UEChMGT3JhY2xlMQ8wDQYDVQQLEwZKUEdTUUUx\\n\" +\n-                \"FTATBgNVBAMMDHNlY3QyODNyMV9lZTBeMBAGByqGSM49AgEGBSuBBAARA0oABAMP\\n\" +\n-                \"oaMP2lIiCrNaFSePtZA8nBnqJXSGCz8kosKeYTqz\/SPE1AN6BvM4xl0kPQZvJWMz\\n\" +\n-                \"fyTcm2Ar0PdbIh8f22vJfO+0JpfhnqNTMFEwHQYDVR0OBBYEFOzDGNWQhslU5ei4\\n\" +\n-                \"SYda\/ro9DickMA8GA1UdEwQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUz6OZ7UxuBEEJ\\n\" +\n-                \"ITEztoDVp78rmAQwCwYHKoZIzj0EAQUAA08AMEwCJALYBWSYdbhRiW4mNulQh6\/v\\n\" +\n-                \"dfHG3y\/oMjzJEmT\/A0WYl96ohgIkAbDC0Ke632RXtCZ4xa2FrmzP41Vb80mSH1iY\\n\" +\n-                \"FCJ3LVoTEUgN\\n\" +\n-                \"-----END CERTIFICATE-----\",\n-                \"MIGQAgEAMBAGByqGSM49AgEGBSuBBAARBHkwdwIBAQQkAXq9LPYU+XSrImPzgO1e\\n\" +\n-                \"hsgjfTBXlWGveFUtn0OHPtbp7hzpoUwDSgAEAw+how\/aUiIKs1oVJ4+1kDycGeol\\n\" +\n-                \"dIYLPySiwp5hOrP9I8TUA3oG8zjGXSQ9Bm8lYzN\/JNybYCvQ91siHx\/ba8l877Qm\\n\" +\n-                \"l+Ge\"),\n-\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/SSLSocketTemplate.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n- * @run main\/othervm -Djdk.sunec.disableNative=false Spec\n+ * @run main\/othervm Spec\n@@ -193,1 +193,1 @@\n-        kpg.initialize(192);\n+        kpg.initialize(256);\n@@ -201,1 +201,1 @@\n-        kpg.initialize(571);\n+        kpg.initialize(521);\n","filename":"test\/jdk\/jdk\/security\/jarsigner\/Spec.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -69,4 +69,1 @@\n-            \"secp128r1\", \"secp256k1\", \"secp256r1\", \"secp384r1\", \"secp521r1\"};\n-\n-    static final List<String> ALL_JAVA_CURVES\n-            = List.of(\"secp256r1\", \"secp384r1\", \"secp521r1\");\n+            \"secp256r1\", \"secp384r1\", \"secp521r1\"};\n@@ -103,2 +100,1 @@\n-                \"-cp \" + System.getProperty(\"test.classes\") +\n-                \" -Djdk.sunec.disableNative=false\");\n+                \"-cp \" + System.getProperty(\"test.classes\"));\n@@ -120,1 +116,1 @@\n-                char caller = ALL_JAVA_CURVES.contains(curve) ? 'J' : 'N';\n+                char caller = 'J';\n@@ -153,3 +149,0 @@\n-                            case \"verifySignedDigest\": \/\/ the native impl\n-                                result[pos] = expected[pos] != 'N' ? 'x' : 'v';\n-                                break;\n","filename":"test\/jdk\/sun\/security\/ec\/ECDSAJavaVerify.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n- * @run main\/othervm -Djdk.sunec.disableNative=false SignatureDigestTruncate\n+ * @run main\/othervm SignatureDigestTruncate\n@@ -120,1 +120,1 @@\n-        runTest(\"SHA384withECDSAinP1363Format\", \"sect283r1\",\n+        runTest(\"SHA384withECDSAinP1363Format\", \"secp256r1\",\n@@ -123,4 +123,4 @@\n-            \"1e1f20212223\",\n-            \"01d7544b5d3935216bd45e2f8042537e1e0296a11e0eb96666199281b409\" +\n-            \"42abccd5358a035de8a314d3e6c2a97614daebf5fb1313540eec3f9a3272\" +\n-            \"068aa10922ccae87d255c84c\");\n+                \"1e1f20212223\",\n+            \"d83534beccde787f9a4c6b0408337d9b9ca2e0a0259228526c15cc17a1d6\" +\n+                \"4da6b34bf21b3bc4488c591d8ac9c33d93c7c6137e2ab4c503a42da7\" +\n+                \"2fe0b6dda4c4\");\n","filename":"test\/jdk\/sun\/security\/ec\/SignatureDigestTruncate.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * NOTE: the following 6 files were copied here from the PKCS11 EC Test area\n+ * NOTE: the following 5 files were copied here from the PKCS11 EC Test area\n@@ -57,1 +57,0 @@\n- *           ..\/pkcs11\/ec\/pkcs12\/sect193r1server-rsa1024ca.p12\n@@ -102,0 +101,1 @@\n+        System.out.println(\"TestECDH\");\n@@ -103,0 +103,1 @@\n+        System.out.println(\"TestECDSA\");\n@@ -104,0 +105,1 @@\n+        System.out.println(\"TestCurves\");\n@@ -105,0 +107,1 @@\n+        System.out.println(\"TestKeyFactory\");\n@@ -106,0 +109,1 @@\n+        System.out.println(\"TestECGenSpec\");\n@@ -107,0 +111,1 @@\n+        System.out.println(\"ReadPKCS12\");\n@@ -108,0 +113,1 @@\n+        System.out.println(\"ReadCertificate\");\n@@ -109,1 +115,1 @@\n-\n+        System.out.println(\"ClientJSSEServerJSSE\");\n","filename":"test\/jdk\/sun\/security\/ec\/TestEC.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"filename":"test\/jdk\/sun\/security\/ec\/keystore","binary":true,"status":"modified"},{"filename":"test\/jdk\/sun\/security\/ec\/pkcs12\/sect193r1server-rsa1024ca.p12","binary":true,"status":"deleted"},{"patch":"@@ -32,3 +32,3 @@\n- * @modules jdk.crypto.cryptoki\n- * @run main\/othervm -Djdk.sunec.disableNative=false ReadPKCS12\n- * @run main\/othervm -Djdk.sunec.disableNative=false ReadPKCS12 sm policy\n+ * @modules jdk.crypto.cryptoki jdk.crypto.ec\/sun.security.ec\n+ * @run main\/othervm ReadPKCS12\n+ * @run main\/othervm ReadPKCS12 sm policy\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/ReadPKCS12.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,3 +127,6 @@\n-        test(p, pub192a, priv192a, pub192b, priv192b, secret192);\n-        test(p, pub163a, priv163a, pub163b, priv163b, secret163);\n-\n+        if (getSupportedECParameterSpec(\"secp192r1\", p).isPresent()) {\n+            test(p, pub192a, priv192a, pub192b, priv192b, secret192);\n+        }\n+        if (getSupportedECParameterSpec(\"sect163r1\", p).isPresent()) {\n+            test(p, pub163a, priv163a, pub163b, priv163b, secret163);\n+        }\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/TestECDH.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-        if (getNSSECC() != ECCState.Basic) {\n+        if (getSupportedECParameterSpec(\"secp192r1\", provider).isPresent()) {\n@@ -161,0 +161,2 @@\n+        }\n+        if (getSupportedECParameterSpec(\"sect163r1\", provider).isPresent()) {\n@@ -162,0 +164,2 @@\n+        }\n+        if (getSupportedECParameterSpec(\"sect571r1\", provider).isPresent()) {\n@@ -163,2 +167,0 @@\n-        } else {\n-            System.out.println(\"ECC Basic only, skipping 192, 163 and 571.\");\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/TestECDSA.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,6 +133,1 @@\n-        int[] keyLengths = {192, 163, 409, 521};\n-        int len = 0;\n-        if (getNSSECC() == ECCState.Basic) {\n-            System.out.println(\"NSS Basic ECC only. Skipping 192, 163, & 409\");\n-            len = 3;\n-        }\n+        int[] keyLengths = {256, 521};\n@@ -140,2 +135,2 @@\n-        for (; keyLengths.length > len ; len++) {\n-            System.out.println(\"Length \"+keyLengths[len]);\n+        for (int len : keyLengths) {\n+            System.out.println(\"Length \" + len);\n@@ -143,1 +138,1 @@\n-            kpg.initialize(keyLengths[len]);\n+            kpg.initialize(len);\n","filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/TestKeyFactory.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"filename":"test\/jdk\/sun\/security\/pkcs11\/ec\/pkcs12\/sect193r1server-rsa1024ca.p12","binary":true,"status":"deleted"},{"filename":"test\/jdk\/sun\/security\/pkcs11\/sslecc\/keystore","binary":true,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,2 +55,0 @@\n-            put(\"eckeystore2\",\n-                new KeyStore.PasswordProtection(\"password\".toCharArray()));\n@@ -72,2 +70,0 @@\n-            put(\"eckeystore2\",\n-                new KeyStore.PasswordProtection(\"wrong\".toCharArray()));\n@@ -157,1 +153,1 @@\n-        expected = 2 + 1 + 1 + 1;\n+        expected = 2 + 1 + 1;\n","filename":"test\/jdk\/sun\/security\/provider\/KeyStore\/DKSTest.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-            keystoreURI=\"${test.src}\/..\/..\/pkcs11\/ec\/pkcs12\/sect193r1server-rsa1024ca.p12\";\n-        keystore eckeystore2 \n@@ -43,2 +41,0 @@\n-            keystoreURI=\"${user.dir}\/sect193r1server-rsa1024ca.p12_tmp\";\n-        keystore eckeystore2 \n","filename":"test\/jdk\/sun\/security\/provider\/KeyStore\/domains.cfg","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run main\/othervm -Djdk.tls.namedGroups=\"sect283r1\"\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"secp384r1\"\n@@ -30,2 +30,2 @@\n- * @run main\/othervm -Djdk.tls.namedGroups=\"sect283r1\"\n-        DisabledCurve sect283r1 FAIL\n+ * @run main\/othervm -Djdk.tls.namedGroups=\"secp384r1\"\n+        DisabledCurve secp384r1 FAIL\n@@ -52,1 +52,1 @@\n-                        SSLSocketTemplate.Cert.CA_ECDSA_SECT283R1 },\n+                        SSLSocketTemplate.Cert.CA_ECDSA_SECP384R1 },\n@@ -54,1 +54,1 @@\n-                        SSLSocketTemplate.Cert.EE_ECDSA_SECT283R1 },\n+                        SSLSocketTemplate.Cert.EE_ECDSA_SECP384R1 },\n@@ -61,1 +61,1 @@\n-                        SSLSocketTemplate.Cert.CA_ECDSA_SECT283R1 },\n+                        SSLSocketTemplate.Cert.CA_ECDSA_SECP384R1 },\n@@ -63,1 +63,1 @@\n-                        SSLSocketTemplate.Cert.EE_ECDSA_SECT283R1 },\n+                        SSLSocketTemplate.Cert.EE_ECDSA_SECP384R1 },\n@@ -92,0 +92,1 @@\n+        boolean disabled = false;\n@@ -94,0 +95,3 @@\n+        } else {\n+            disabled = true;\n+            Security.setProperty(\"jdk.certpath.disabledAlgorithms\", \"secp384r1\");\n@@ -95,1 +99,0 @@\n-        System.setProperty(\"jdk.sunec.disableNative\", \"false\");\n@@ -102,1 +105,1 @@\n-                            \"The test case should not reach here\");\n+                            \"Expected test to fail, but it passed\");\n@@ -105,3 +108,1 @@\n-                if ((expected.equals(\"FAIL\"))\n-                        && Security.getProperty(\"jdk.disabled.namedCurves\")\n-                                .contains(disabledName)) {\n+                if (expected.equals(\"FAIL\") && disabled) {\n","filename":"test\/jdk\/sun\/security\/ssl\/CipherSuite\/DisabledCurve.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -96,5 +96,0 @@\n-\n-        System.out.println(\"\\nTesting Native Curve:\"\n-                + \" include jdk.disabled.namedCurves\\n\");\n-        test(\"EC\", \"SHA256withECDSA\", \"curve\", \"SHA256\", true,\n-                \"-groupname\", \"secp112r1\");\n@@ -126,2 +121,1 @@\n-                \"-alias\", alias,\n-                \"-J-Djdk.sunec.disableNative=false\");\n+                \"-alias\", alias);\n@@ -150,2 +144,1 @@\n-                alias,\n-                \"-J-Djdk.sunec.disableNative=false\");\n+                alias);\n@@ -165,2 +158,1 @@\n-                SIGNED_JARFILE,\n-                \"-J-Djdk.sunec.disableNative=false\");\n+                SIGNED_JARFILE);\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/RestrictedAlgo.java","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -68,5 +68,0 @@\n-        gen(\"f\", \"-J-Djdk.sunec.disableNative=false -keyalg EC -groupname brainpoolP256r1\")\n-                .shouldHaveExitValue(0)\n-                .shouldNotContain(\"Specifying -keysize for generating EC keys is deprecated\");\n-        checkCurveName(\"f\", \"brainpoolP256r1\");\n-\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/GroupName.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,4 +44,0 @@\n-        keytool(\"-genkeypair -alias e -dname CN=e \" +\n-                \"-J-Djdk.sunec.disableNative=false -keyalg EC \" +\n-                        \"-groupname brainpoolP256r1\")\n-                .shouldContain(\"Generating 256 bit EC (brainpoolP256r1) key pair\");\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/KeyAlg.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-        check(\"EC\", 192, null, \"SHA256withECDSA\");\n@@ -60,1 +59,0 @@\n-        check(\"EC\", 571, null, \"SHA512withECDSA\");\n@@ -62,1 +60,1 @@\n-        check(\"EC\", 571, \"SHA256withECDSA\", \"SHA256withECDSA\");\n+        check(\"EC\", 384, \"SHA256withECDSA\", \"SHA256withECDSA\");\n@@ -85,2 +83,1 @@\n-        String patchArg = \"-J-Djdk.sunec.disableNative=false \" +\n-                \"-J--patch-module=java.base=\"\n+        String patchArg = \"-J--patch-module=java.base=\"\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/DefaultSignatureAlgorithm.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,8 +61,0 @@\n-            case 192:\n-                s = new BigInteger(\"144089953963995451666433763881605261867377\"\n-                        + \"0287449914970417\");\n-                x = new BigInteger(\"527580219290493448707803038403444129676461\"\n-                        + \"560927008883862\");\n-                y = new BigInteger(\"171489247081620145247240656640887886126295\"\n-                        + \"376102134763235\");\n-                break;\n@@ -80,14 +72,0 @@\n-            case 571:\n-                s = new BigInteger(\"102950007413729156017516513076331886543538\"\n-                        + \"947044937190140406420556321983301533699021909556189\"\n-                        + \"150601557539520495361099574425100081169640300555562\"\n-                        + \"4280643194744140660275077121\");\n-                x = new BigInteger(\"640598847385582251482893323029655037929442\"\n-                        + \"593800810090252942944624854811134311418807076811195\"\n-                        + \"132373308708007447666896675761104237802118413642543\"\n-                        + \"8277858107132017492037336593\");\n-                y = new BigInteger(\"254271270803422773271985083014247202480077\"\n-                        + \"131823713050110789460550383275777195766342550786766\"\n-                        + \"080401402424961690914429074822281551140068729472439\"\n-                        + \"477216613432839953714415981\");\n-                break;\n@@ -95,1 +73,3 @@\n-                throw new AssertionError(\"Unsupported keysize \" + keySize);\n+                throw new AssertionError(\"SunEC ECKeyPairGenerator\" +\n+                    \"has been patched. Key size \" + keySize +\n+                    \" is not supported\");\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/jdk.crypto.ec\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":4,"deletions":24,"binary":false,"changes":28,"status":"modified"}]}