{"files":[{"patch":"@@ -1782,2 +1782,0 @@\n-  G1CMOopClosure _cm_cl;\n-  MarkingCodeBlobClosure _code_cl;\n@@ -1789,2 +1787,0 @@\n-    _cm_cl(g1h, task),\n-    _code_cl(&_cm_cl, !CodeBlobToOopClosure::FixRelocations, true \/* keepalive nmethods *\/),\n@@ -1797,9 +1793,0 @@\n-      if (thread->is_Java_thread()) {\n-        \/\/ In theory it should not be necessary to explicitly walk the nmethods to find roots for concurrent marking\n-        \/\/ however the liveness of oops reachable from nmethods have very complex lifecycles:\n-        \/\/ * Alive if on the stack of an executing method\n-        \/\/ * Weakly reachable otherwise\n-        \/\/ Some objects reachable from nmethods, such as the class loader (or klass_holder) of the receiver should be\n-        \/\/ live by the SATB invariant but other oops recorded in nmethods may behave differently.\n-        JavaThread::cast(thread)->nmethods_do(&_code_cl);\n-      }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -60,2 +60,3 @@\n-    \/\/ The GC needs nmethod entry barriers to deal with continuations\n-    \/\/ and code cache unloading\n+    \/\/ The GC needs nmethod entry barriers for code cache unloading (recently\n+    \/\/ used heuristics) and, if it's a SATB GC, to keep alive constant objects\n+    \/\/ of nmethods because they are weakly referenced.\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSet.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"}]}