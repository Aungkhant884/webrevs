{"files":[{"patch":"@@ -2985,1 +2985,1 @@\n-    __ asm_assert(Assembler::bcondNotEqual, \"unexpected null obj\", __LINE__);\n+    __ asm_assert(Assembler::bcondNotZero, \"unexpected null obj\", __LINE__);\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    __ asm_assert(Assembler::bcondNotEqual, \"null oop not allowed (G1 pre)\", 0x321); \/\/ Checked by caller.\n+    __ asm_assert(Assembler::bcondNotZero, \"null oop not allowed (G1 pre)\", 0x321); \/\/ Checked by caller.\n@@ -292,1 +292,1 @@\n-    __ asm_assert(Assembler::bcondNotEqual, \"null oop not allowed (G1 post)\", 0x322); \/\/ Checked by caller.\n+    __ asm_assert(Assembler::bcondNotZero, \"null oop not allowed (G1 post)\", 0x322); \/\/ Checked by caller.\n","filename":"src\/hotspot\/cpu\/s390\/gc\/g1\/g1BarrierSetAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018 SAP SE. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5316,0 +5316,48 @@\n+void MacroAssembler::asm_assert(branch_condition cond, const char* msg, int id, bool is_static) {\n+#ifdef ASSERT\n+  Label ok;\n+  z_brc(cond, ok);\n+  is_static ? stop_static(msg, id) : stop(msg, id);\n+  bind(ok);\n+#endif \/\/ ASSERT\n+}\n+\n+\/\/ Assert if CC indicates \"not equal\" (check_equal==true) or \"equal\" (check_equal==false).\n+void MacroAssembler::asm_assert(bool check_equal, const char *msg, int id) {\n+#ifdef ASSERT\n+  asm_assert(check_equal ? bcondEqual : bcondNotEqual, msg, id);\n+#endif \/\/ ASSERT\n+}\n+\n+void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n+                                          Register mem_base, const char* msg, int id) {\n+#ifdef ASSERT\n+  switch (size) {\n+    case 4:\n+      load_and_test_int(Z_R0, Address(mem_base, mem_offset));\n+      break;\n+    case 8:\n+      load_and_test_long(Z_R0,  Address(mem_base, mem_offset));\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n+  \/\/ if relocation is not allowed then stop_static() will be called otherwise call stop()\n+  asm_assert(check_equal ? bcondEqual : bcondNotEqual, msg, id, !allow_relocation);\n+#endif \/\/ ASSERT\n+}\n+\n+\/\/ Check the condition\n+\/\/   expected_size == FP - SP\n+\/\/ after transformation:\n+\/\/   expected_size - FP + SP == 0\n+\/\/ Destroys Register expected_size if no tmp register is passed.\n+void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {\n+#ifdef ASSERT\n+  lgr_if_needed(tmp, expected_size);\n+  z_algr(tmp, Z_SP);\n+  z_slg(tmp, 0, Z_R0, Z_SP);\n+  asm_assert(bcondEqual, msg, id);\n+#endif \/\/ ASSERT\n+}\n+\n@@ -5435,2 +5483,2 @@\n-  z_illtrap(); \/\/ Illegal instruction.\n-  z_illtrap(); \/\/ Illegal instruction.\n+  z_illtrap(id); \/\/ Illegal instruction.\n+  z_illtrap(id); \/\/ Illegal instruction.\n@@ -5475,1 +5523,1 @@\n-    z_illtrap(); \/\/ Illegal instruction as emergency stop, should the above call return.\n+    z_illtrap(id); \/\/ Illegal instruction as emergency stop, should the above call return.\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":51,"deletions":3,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -867,6 +867,2 @@\n-  inline void asm_assert(branch_condition cond, const char* msg, int id, bool is_static=true);\n-\n-  \/\/ Assert if CC indicates \"not equal\" (check_equal==true) or \"equal\" (check_equal==false).\n-  inline void asm_assert(bool check_equal, const char* msg, int id) {\n-    asm_assert(check_equal ? bcondEqual : bcondNotEqual, msg, id);\n-  }\n+  void asm_assert(branch_condition cond, const char* msg, int id, bool is_static=true);\n+  void asm_assert(bool check_equal, const char* msg, int id);\n@@ -876,1 +872,1 @@\n-  inline void asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n+  void asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n@@ -904,1 +900,1 @@\n-  inline void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id);\n+  void asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016 SAP SE. All rights reserved.\n@@ -314,47 +314,0 @@\n-inline void MacroAssembler::asm_assert(branch_condition cond, const char* msg, int id, bool is_static) {\n-#ifdef ASSERT\n-  Label ok;\n-  z_brc(cond, ok);\n-  is_static ? stop_static(msg, id) : stop(msg, id);\n-  bind(ok);\n-#endif \/\/ ASSERT\n-}\n-\n-inline void MacroAssembler::asm_assert_mems_zero(bool check_equal, bool allow_relocation, int size, int64_t mem_offset,\n-                                          Register mem_base, const char* msg, int id) {\n-#ifdef ASSERT\n-  switch (size) {\n-    case 4:\n-      load_and_test_int(Z_R0, Address(mem_base, mem_offset));\n-      break;\n-    case 8:\n-      load_and_test_long(Z_R0,  Address(mem_base, mem_offset));\n-      break;\n-    default:\n-      ShouldNotReachHere();\n-  }\n-  \/\/ if relocation is not allowed then stop_static() will be called otherwise call stop()\n-  asm_assert(check_equal ? bcondEqual : bcondNotEqual, msg, id, !allow_relocation);\n-#endif \/\/ ASSERT\n-}\n-\n-\/\/ Check the condition\n-\/\/   expected_size == FP - SP\n-\/\/ after transformation:\n-\/\/   expected_size - FP + SP == 0\n-\/\/ Destroys Register expected_size if no tmp register is passed.\n-inline void MacroAssembler::asm_assert_frame_size(Register expected_size, Register tmp, const char* msg, int id) {\n-#ifdef ASSERT\n-  if (tmp == noreg) {\n-    tmp = expected_size;\n-  } else {\n-    if (tmp != expected_size) {\n-      z_lgr(tmp, expected_size);\n-    }\n-    z_algr(tmp, Z_SP);\n-    z_slg(tmp, 0, Z_R0, Z_SP);\n-    asm_assert(bcondEqual, msg, id);\n-  }\n-#endif \/\/ ASSERT\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.inline.hpp","additions":2,"deletions":49,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016 SAP SE. All rights reserved.\n@@ -31,1 +31,1 @@\n-#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/cpu\/s390\/nativeInst_s390.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-  __ asm_assert(Assembler::bcondNotEqual, \"handler must not be NULL\", 0x852);\n+  __ asm_assert(Assembler::bcondNotZero, \"handler must not be NULL\", 0x852);\n","filename":"src\/hotspot\/cpu\/s390\/runtime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2479,1 +2479,1 @@\n-  __ asm_assert(Assembler::bcondNotEqual, \"array_size must be > 0\", 0x205);\n+  __ asm_assert(Assembler::bcondNotZero, \"array_size must be > 0\", 0x205);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -738,1 +738,1 @@\n-    __ asm_assert(Assembler::bcondEqual, \"missing zero extend\", 0xAFFE);\n+    __ asm_assert(Assembler::bcondZero, \"missing zero extend\", 0xAFFE);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-    __ z_illtrap();\n@@ -60,0 +59,1 @@\n+    __ z_illtrap();\n@@ -68,1 +68,0 @@\n-    __ z_illtrap();\n@@ -70,0 +69,1 @@\n+    __ z_illtrap();\n@@ -103,1 +103,0 @@\n-      __ z_illtrap();\n@@ -105,0 +104,1 @@\n+      __ z_illtrap();\n@@ -113,1 +113,0 @@\n-      __ z_illtrap();\n@@ -115,0 +114,1 @@\n+      __ z_illtrap();\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \"asm\/macroAssembler.inline.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n","filename":"src\/hotspot\/share\/interpreter\/interp_masm.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}