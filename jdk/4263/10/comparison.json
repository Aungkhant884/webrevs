{"files":[{"patch":"@@ -56,1 +56,1 @@\n-    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+    private static final int DEFAULT_BUFFER_SIZE = 16 * 8192;\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import sun.nio.ch.ChannelOutputStream;\n@@ -66,34 +67,0 @@\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     * If the channel is selectable then it must be configured blocking.\n-     *\/\n-    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        while (bb.remaining() > 0) {\n-            int n = ch.write(bb);\n-            if (n <= 0)\n-                throw new RuntimeException(\"no bytes written\");\n-        }\n-    }\n-\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     *\n-     * @throws  IllegalBlockingModeException\n-     *          If the channel is selectable and configured non-blocking.\n-     *\/\n-    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        if (ch instanceof SelectableChannel sc) {\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                writeFullyImpl(ch, bb);\n-            }\n-        } else {\n-            writeFullyImpl(ch, bb);\n-        }\n-    }\n-\n@@ -139,41 +106,1 @@\n-\n-        return new OutputStream() {\n-\n-            private ByteBuffer bb;\n-            private byte[] bs;       \/\/ Invoker's previous array\n-            private byte[] b1;\n-\n-            @Override\n-            public synchronized void write(int b) throws IOException {\n-                if (b1 == null)\n-                    b1 = new byte[1];\n-                b1[0] = (byte) b;\n-                this.write(b1);\n-            }\n-\n-            @Override\n-            public synchronized void write(byte[] bs, int off, int len)\n-                    throws IOException\n-            {\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n-                    return;\n-                }\n-                ByteBuffer bb = ((this.bs == bs)\n-                                 ? this.bb\n-                                 : ByteBuffer.wrap(bs));\n-                bb.limit(Math.min(off + len, bb.capacity()));\n-                bb.position(off);\n-                this.bb = bb;\n-                this.bs = bs;\n-                Channels.writeFully(ch, bb);\n-            }\n-\n-            @Override\n-            public void close() throws IOException {\n-                ch.close();\n-            }\n-\n-        };\n+        return new ChannelOutputStream(ch);\n@@ -219,4 +146,2 @@\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n+                Objects.checkFromIndexSize(off, len, bs.length);\n+                if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":4,"deletions":79,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,105 @@\n+    private static final int TRANSFER_SIZE = 8192;\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        Objects.requireNonNull(out, \"out\");\n+\n+        if (out instanceof ChannelOutputStream cos) {\n+            WritableByteChannel wbc = cos.channel();\n+\n+            if (ch instanceof FileChannel fc) {\n+                return transfer(fc, wbc);\n+            }\n+\n+            if (wbc instanceof FileChannel fc) {\n+                if (ch instanceof SelectableChannel sc) {\n+                    synchronized (sc.blockingLock()) {\n+                        boolean bm = sc.isBlocking();\n+                        if (!bm)\n+                            throw new IllegalBlockingModeException();\n+\n+                        if (ch instanceof SeekableByteChannel sbc) {\n+                            return transfer(sbc, fc);\n+\n+                        return transfer(ch, fc);}\n+                    } else {\n+                        if (ch instanceof SeekableByteChannel sbc) {\n+                            return transfer(sbc, fc);\n+\n+                        return transfer(ch, fc);}\n+                    }\n+            }\n+\n+            return transfer(ch, wbc);\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n+    private static long transfer(FileChannel src, WritableByteChannel dst) throws IOException {\n+        long bytesWritten = 0L;\n+        long srcPos = src.position();\n+        try {\n+            while (srcPos + bytesWritten < src.size()) {\n+                bytesWritten += src.transferTo(srcPos + bytesWritten, Long.MAX_VALUE, dst);\n+            }\n+            return bytesWritten;\n+        } finally {\n+            src.position(srcPos + bytesWritten);\n+        }\n+    }\n+\n+    private static long transfer(SeekableByteChannel src, FileChannel dst) throws IOException {\n+        long bytesWritten = 0L;\n+        long dstPos = dst.position();\n+        long srcPos = src.position();\n+        try {\n+            while (srcPos + bytesWritten < src.size()) {\n+                bytesWritten += dst.transferFrom(src, dstPos + bytesWritten, Long.MAX_VALUE);\n+            }\n+            return bytesWritten;\n+        } finally {\n+            dst.position(dstPos + bytesWritten);\n+        }\n+    }\n+\n+    private static long transfer(ReadableByteChannel src, FileChannel dst) throws IOException {\n+        long bytesWritten = 0L;\n+        long dstPos = dst.position();\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(TRANSFER_SIZE);\n+        try {\n+            int bytesRead;\n+            do {\n+                bytesWritten += dst.transferFrom(src, dstPos + bytesWritten, Long.MAX_VALUE);\n+                bytesRead = src.read(bb); \/\/ detect end-of-stream\n+                if (bytesRead > -1) {\n+                    bb.flip();\n+                    while (bb.hasRemaining())\n+                        dst.write(bb);\n+                    bb.clear();\n+                    bytesWritten += bytesRead;\n+                }\n+            } while (bytesRead > -1);\n+            return bytesWritten;\n+        } finally {\n+            dst.position(dstPos + bytesWritten);\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+    }\n+\n+    private static long transfer(ReadableByteChannel src, WritableByteChannel dst) throws IOException {\n+        long bytesWritten = 0L;\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(TRANSFER_SIZE);\n+        try {\n+            for (int bytesRead = src.read(bb); bytesRead > -1; bytesRead = src.read(bb)) {\n+                bb.flip();\n+                while (bb.hasRemaining())\n+                    dst.write(bb);\n+                bb.clear();\n+                bytesWritten += bytesRead;\n+            }\n+            return bytesWritten;\n+        } finally {\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":106,"deletions":1,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.nio.channels.spi.*;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is defined here rather than in java.nio.channels.Channels\n+ * so that it will be visible to java.nio.channels.Channels and\n+ * sun.nio.ch.ChannelInputStream but not be part of the java.base module API.\n+ *\n+ *\n+ * @author Mark Reinhold\n+ * @author Mike McCloskey\n+ * @author JSR-51 Expert Group\n+ * @since 18\n+ *\/\n+public class ChannelOutputStream extends OutputStream {\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     * If the channel is selectable then it must be configured blocking.\n+     *\/\n+    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        while (bb.remaining() > 0) {\n+            int n = ch.write(bb);\n+            if (n <= 0)\n+                throw new RuntimeException(\"no bytes written\");\n+        }\n+    }\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     *\n+     * @throws  IllegalBlockingModeException\n+     *          If the channel is selectable and configured non-blocking.\n+     *\/\n+    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                writeFullyImpl(ch, bb);\n+            }\n+        } else {\n+            writeFullyImpl(ch, bb);\n+        }\n+    }\n+\n+    private final WritableByteChannel ch;\n+    private ByteBuffer bb;\n+    private byte[] bs;       \/\/ Invoker's previous array\n+    private byte[] b1;\n+\n+    \/**\n+     * @param ch The channel wrapped by this stream.\n+     *\/\n+    public ChannelOutputStream(WritableByteChannel ch) {\n+        this.ch = ch;\n+    }\n+\n+    \/**\n+     * @return The channel wrapped by this stream.\n+     *\/\n+    WritableByteChannel channel() {\n+        return ch;\n+    }\n+\n+    @Override\n+    public synchronized void write(int b) throws IOException {\n+        if (b1 == null)\n+            b1 = new byte[1];\n+        b1[0] = (byte) b;\n+        this.write(b1);\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] bs, int off, int len)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, bs.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        ByteBuffer bb = ((this.bs == bs)\n+                         ? this.bb\n+                         : ByteBuffer.wrap(bs));\n+        bb.limit(Math.min(off + len, bb.capacity()));\n+        bb.position(off);\n+        this.bb = bb;\n+        this.bs = bs;\n+        writeFully(ch, bb);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        ch.close();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2014, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.String.format;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+\/*\n+ * @test\n+ * @bug 8265891\n+ * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n+ *          InputStream.transferTo contract defined in the javadoc\n+ * @key randomness\n+ *\/\n+public class TransferTo {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(fileChannelInput(), writableByteChannelOutput());\n+        test(seekableByteChannelInput(), fileChannelOutput());\n+        test(readableByteChannelInput(), fileChannelOutput());\n+        test(readableByteChannelInput(), writableByteChannelOutput());\n+        test(readableByteChannelInput(), defaultOutput());\n+    }\n+\n+    private static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n+            throws Exception {\n+        ifOutIsNullThenNpeIsThrown(inputStreamProvider);\n+        contents(inputStreamProvider, outputStreamProvider);\n+    }\n+\n+    private static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n+        try (InputStream in = inputStreamProvider.input()) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+\n+        try (InputStream in = inputStreamProvider.input((byte) 1)) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+\n+        try (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+    }\n+\n+    private static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n+            throws Exception {\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+        \/\/ to span through several batches\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+    }\n+\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n+        AtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+        try (InputStream in = inputStreamProvider.input(inBytes);\n+                OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            in.transferTo(out);\n+\n+            byte[] outBytes = recorder.get().get();\n+\n+            if (!Arrays.equals(inBytes, outBytes))\n+                throw new AssertionError(\n+                        format(\"bytes.length=%s, outBytes.length=%s\", inBytes.length, outBytes.length));\n+        }\n+    }\n+\n+    private static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+        Random rnd = new Random();\n+        byte[] bytes = new byte[min + rnd.nextInt(maxRandomAdditive)];\n+        rnd.nextBytes(bytes);\n+        return bytes;\n+    }\n+\n+    private static interface InputStreamProvider {\n+        InputStream input(byte... bytes) throws Exception;\n+    }\n+\n+    private static interface OutputStreamProvider {\n+        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+    }\n+\n+    private static OutputStreamProvider defaultOutput() {\n+        return new OutputStreamProvider() {\n+            @Override\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return outputStream;\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider fileChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                Files.write(path, bytes);\n+                FileChannel fileChannel = FileChannel.open(path);\n+                return Channels.newInputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider seekableByteChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                Path temporaryJarFile = Files.createTempFile(null, \".zip\");\n+                try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(temporaryJarFile))) {\n+                    JarEntry jarEntry = new JarEntry(\"raw-bytes\");\n+                    out.putNextEntry(jarEntry);\n+                    out.write(bytes);\n+                    out.closeEntry();\n+                }\n+                FileSystem zipFileSystem = FileSystems.newFileSystem(new URI(\"jar\",\n+                        URLDecoder.decode(temporaryJarFile.toUri().toString(), StandardCharsets.UTF_8), null),\n+                        Collections.emptyMap(), null);\n+                SeekableByteChannel sbc = zipFileSystem.provider().newByteChannel(zipFileSystem.getPath(\"raw-bytes\"),\n+                        Collections.singleton(StandardOpenOption.READ));\n+                return Channels.newInputStream(sbc);\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider readableByteChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                return Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider fileChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+                spy.accept(() -> {\n+                    try {\n+                        return Files.readAllBytes(path);\n+                    } catch (IOException e) {\n+                        return null;\n+                    }\n+                });\n+                return Channels.newOutputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider writableByteChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return Channels.newOutputStream(Channels.newChannel(outputStream));\n+            }\n+        };\n+    }\n+\n+    public interface Thrower {\n+        public void run() throws Throwable;\n+    }\n+\n+    public static void assertThrowsNPE(Thrower thrower, String message) {\n+        assertThrows(thrower, NullPointerException.class, message);\n+    }\n+\n+    public static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n+        Throwable thrown;\n+        try {\n+            thrower.run();\n+            thrown = null;\n+        } catch (Throwable caught) {\n+            thrown = caught;\n+        }\n+\n+        if (!throwable.isInstance(thrown)) {\n+            String caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n+            throw new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n+        }\n+\n+        if (thrown != null && !message.equals(thrown.getMessage())) {\n+            throw new AssertionError(\n+                    format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"}]}