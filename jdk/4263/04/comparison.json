{"files":[{"patch":"@@ -56,1 +56,1 @@\n-    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+    private static final int DEFAULT_BUFFER_SIZE = 16 * 8192;\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import sun.nio.ch.ChannelOutputStream;\n@@ -66,34 +67,0 @@\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     * If the channel is selectable then it must be configured blocking.\n-     *\/\n-    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        while (bb.remaining() > 0) {\n-            int n = ch.write(bb);\n-            if (n <= 0)\n-                throw new RuntimeException(\"no bytes written\");\n-        }\n-    }\n-\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     *\n-     * @throws  IllegalBlockingModeException\n-     *          If the channel is selectable and configured non-blocking.\n-     *\/\n-    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        if (ch instanceof SelectableChannel sc) {\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                writeFullyImpl(ch, bb);\n-            }\n-        } else {\n-            writeFullyImpl(ch, bb);\n-        }\n-    }\n-\n@@ -139,41 +106,1 @@\n-\n-        return new OutputStream() {\n-\n-            private ByteBuffer bb;\n-            private byte[] bs;       \/\/ Invoker's previous array\n-            private byte[] b1;\n-\n-            @Override\n-            public synchronized void write(int b) throws IOException {\n-                if (b1 == null)\n-                    b1 = new byte[1];\n-                b1[0] = (byte) b;\n-                this.write(b1);\n-            }\n-\n-            @Override\n-            public synchronized void write(byte[] bs, int off, int len)\n-                    throws IOException\n-            {\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n-                    return;\n-                }\n-                ByteBuffer bb = ((this.bs == bs)\n-                                 ? this.bb\n-                                 : ByteBuffer.wrap(bs));\n-                bb.limit(Math.min(off + len, bb.capacity()));\n-                bb.position(off);\n-                this.bb = bb;\n-                this.bs = bs;\n-                Channels.writeFully(ch, bb);\n-            }\n-\n-            @Override\n-            public void close() throws IOException {\n-                ch.close();\n-            }\n-\n-        };\n+        return new ChannelOutputStream(ch);\n@@ -219,4 +146,2 @@\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n+                Objects.checkFromIndexSize(off, len, bs.length);\n+                if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":4,"deletions":79,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,94 @@\n+    private static final int TRANSFER_SIZE = 8192;\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        Objects.requireNonNull(out, \"out\");\n+\n+        if (out instanceof ChannelOutputStream cos) {\n+            WritableByteChannel oc = cos.channel();\n+\n+            if (ch instanceof FileChannel fc) {\n+                return transfer(fc, oc);\n+            }\n+\n+            if (oc instanceof FileChannel fc) {\n+                if (ch instanceof SeekableByteChannel sbc) {\n+                    return transfer(sbc, fc);\n+                }\n+\n+                return transfer(ch, fc);\n+            }\n+\n+            return transfer(ch, oc);\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n+    private static long transfer(FileChannel src, WritableByteChannel dest) throws IOException {\n+        long bytesWritten = 0L;\n+        long srcPos = src.position();\n+        long srcSize = src.size();\n+        try {\n+            for (long n = srcSize - srcPos; bytesWritten < n;)\n+                bytesWritten += src.transferTo(srcPos + bytesWritten, Long.MAX_VALUE, dest);\n+            return bytesWritten;\n+        } finally {\n+            src.position(srcPos + bytesWritten);\n+        }\n+    }\n+\n+    private static long transfer(SeekableByteChannel src, FileChannel dest) throws IOException {\n+        long bytesWritten = 0L;\n+        long destPos = dest.position();\n+        long srcPos = src.position();\n+        long srcSize = src.size();\n+        try {\n+            for (long n = srcSize - srcPos; bytesWritten < n;)\n+                bytesWritten += dest.transferFrom(src, destPos + bytesWritten, Long.MAX_VALUE);\n+            return bytesWritten;\n+        } finally {\n+            dest.position(destPos + bytesWritten);\n+        }\n+    }\n+\n+    private static long transfer(ReadableByteChannel src, FileChannel dest) throws IOException {\n+        long bytesWritten = 0L;\n+        long destPos = dest.position();\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(TRANSFER_SIZE);\n+        try {\n+            int r;\n+            do {\n+                bytesWritten += dest.transferFrom(src, destPos + bytesWritten, Long.MAX_VALUE);\n+                r = src.read(bb); \/\/ detect end-of-stream\n+                if (r > -1) {\n+                    bb.flip();\n+                    while (bb.hasRemaining())\n+                        dest.write(bb);\n+                    bb.clear();\n+                    bytesWritten += r;\n+                }\n+            } while (r > -1);\n+            return bytesWritten;\n+        } finally {\n+            dest.position(destPos + bytesWritten);\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+    }\n+\n+    private static long transfer(ReadableByteChannel src, WritableByteChannel dest) throws IOException {\n+        long bytesWritten = 0L;\n+        ByteBuffer bb = Util.getTemporaryDirectBuffer(TRANSFER_SIZE);\n+        try {\n+            for (int r = src.read(bb); r > -1; r = src.read(bb)) {\n+                bb.flip();\n+                while (bb.hasRemaining())\n+                    dest.write(bb);\n+                bb.clear();\n+                bytesWritten += r;\n+            }\n+            return bytesWritten;\n+        } finally {\n+            Util.releaseTemporaryDirectBuffer(bb);\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":95,"deletions":1,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.nio.channels.spi.*;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is defined here rather than in java.nio.channels.Channels\n+ * so that it will be visible to java.nio.channels.Channels and\n+ * sun.nio.ch.ChannelInputStream but not be part of the java.base module API.\n+ *\n+ *\n+ * @author Mark Reinhold\n+ * @author Mike McCloskey\n+ * @author JSR-51 Expert Group\n+ * @since 18\n+ *\/\n+public class ChannelOutputStream extends OutputStream {\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     * If the channel is selectable then it must be configured blocking.\n+     *\/\n+    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        while (bb.remaining() > 0) {\n+            int n = ch.write(bb);\n+            if (n <= 0)\n+                throw new RuntimeException(\"no bytes written\");\n+        }\n+    }\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     *\n+     * @throws  IllegalBlockingModeException\n+     *          If the channel is selectable and configured non-blocking.\n+     *\/\n+    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                writeFullyImpl(ch, bb);\n+            }\n+        } else {\n+            writeFullyImpl(ch, bb);\n+        }\n+    }\n+\n+    private final WritableByteChannel ch;\n+    private ByteBuffer bb;\n+    private byte[] bs;       \/\/ Invoker's previous array\n+    private byte[] b1;\n+\n+    \/**\n+     * @param ch The channel wrapped by this stream.\n+     *\/\n+    public ChannelOutputStream(WritableByteChannel ch) {\n+        this.ch = ch;\n+    }\n+\n+    \/**\n+     * @return The channel wrapped by this stream.\n+     *\/\n+    WritableByteChannel channel() {\n+        return ch;\n+    }\n+\n+    @Override\n+    public synchronized void write(int b) throws IOException {\n+        if (b1 == null)\n+            b1 = new byte[1];\n+        b1[0] = (byte) b;\n+        this.write(b1);\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] bs, int off, int len)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, bs.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        ByteBuffer bb = ((this.bs == bs)\n+                         ? this.bb\n+                         : ByteBuffer.wrap(bs));\n+        bb.limit(Math.min(off + len, bb.capacity()));\n+        bb.position(off);\n+        this.bb = bb;\n+        this.bs = bs;\n+        writeFully(ch, bb);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        ch.close();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2014, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import static java.lang.String.format;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.URLDecoder;\n+import java.nio.channels.Channels;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystems;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarOutputStream;\n+\n+\/*\n+ * @test\n+ * @bug 8265891\n+ * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\n+ *          InputStream.transferTo contract defined in the javadoc\n+ * @key randomness\n+ *\/\n+public class TransferTo {\n+\n+\tpublic static void main(String[] args) throws Exception {\n+\t\ttest(fileChannelInput(), writableByteChannelOutput());\n+\t\ttest(seekableByteChannelInput(), fileChannelOutput());\n+\t\ttest(readableByteChannelInput(), fileChannelOutput());\n+\t\ttest(readableByteChannelInput(), writableByteChannelOutput());\n+\t\ttest(readableByteChannelInput(), defaultOutput());\n+\t}\n+\n+\tprivate static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n+\t\tifOutIsNullThenNpeIsThrown(inputStreamProvider);\n+\t\tcontents(inputStreamProvider, outputStreamProvider);\n+\t}\n+\n+\tprivate static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n+\t\ttry (InputStream in = inputStreamProvider.input()) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1)) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n+\t\t}\n+\t}\n+\n+\tprivate static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+\t\t\/\/ to span through several batches\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+\t}\n+\n+\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes)\n+\t\t\tthrows Exception {\n+\t\tAtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+\t\ttry (InputStream in = inputStreamProvider.input(inBytes); OutputStream out = outputStreamProvider.output(recorder::set)) {\n+\t\t\tin.transferTo(out);\n+\n+\t\t\tbyte[] outBytes = recorder.get().get();\n+\n+\t\t\tif (!Arrays.equals(inBytes, outBytes))\n+\t\t\t\tthrow new AssertionError(format(\"bytes.length=%s, outBytes.length=%s\", inBytes.length, outBytes.length));\n+\t\t}\n+\t}\n+\n+\tprivate static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+\t\tRandom rnd = new Random();\n+\t\tbyte[] bytes = new byte[min + rnd.nextInt(maxRandomAdditive)];\n+\t\trnd.nextBytes(bytes);\n+\t\treturn bytes;\n+\t}\n+\n+\tprivate static interface InputStreamProvider {\n+\t\tInputStream input(byte... bytes) throws Exception;\n+\t}\n+\n+\tprivate static interface OutputStreamProvider {\n+\t\tOutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+\t}\n+\n+\tprivate static OutputStreamProvider defaultOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\t\t\t\tspy.accept(outputStream::toByteArray);\n+\t\t\t\treturn outputStream;\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider fileChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\tPath path = Files.createTempFile(null, null);\n+\t\t\t\tFiles.write(path, bytes);\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path);\n+\t\t\t\treturn Channels.newInputStream(fileChannel);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider seekableByteChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\tPath temporaryJarFile = Files.createTempFile(null, \".zip\");\n+\t\t\t\ttry (JarOutputStream out = new JarOutputStream(Files.newOutputStream(temporaryJarFile))) {\n+\t\t\t\t\tJarEntry jarEntry = new JarEntry(\"raw-bytes\");\n+\t\t\t\t\tout.putNextEntry(jarEntry);\n+\t\t\t\t\tout.write(bytes);\n+\t\t\t\t\tout.closeEntry();\n+\t\t\t\t}\n+\t\t\t\tFileSystem zipFileSystem = FileSystems.newFileSystem(\n+\t\t\t\t\t\tnew URI(\"jar\", URLDecoder.decode(temporaryJarFile.toUri().toString(), StandardCharsets.UTF_8), null), Collections.emptyMap(), null);\n+\t\t\t\tSeekableByteChannel sbc = zipFileSystem.provider().newByteChannel(zipFileSystem.getPath(\"raw-bytes\"),\n+\t\t\t\t\t\tCollections.singleton(StandardOpenOption.READ));\n+\t\t\t\treturn Channels.newInputStream(sbc);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static InputStreamProvider readableByteChannelInput() {\n+\t\treturn new InputStreamProvider() {\n+\t\t\t@Override\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n+\t\t\t\treturn Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider fileChannelOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tPath path = Files.createTempFile(null, null);\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+\t\t\t\tspy.accept(() -> {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\treturn Files.readAllBytes(path);\n+\t\t\t\t\t} catch (IOException e) {\n+\t\t\t\t\t\treturn null;\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\t\t\treturn Channels.newOutputStream(fileChannel);\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tprivate static OutputStreamProvider writableByteChannelOutput() {\n+\t\treturn new OutputStreamProvider() {\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+\t\t\t\tspy.accept(outputStream::toByteArray);\n+\t\t\t\treturn Channels.newOutputStream(Channels.newChannel(outputStream));\n+\t\t\t}\n+\t\t};\n+\t}\n+\n+\tpublic interface Thrower {\n+\t\tpublic void run() throws Throwable;\n+\t}\n+\n+\tpublic static void assertThrowsNPE(Thrower thrower, String message) {\n+\t\tassertThrows(thrower, NullPointerException.class, message);\n+\t}\n+\n+\tpublic static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n+\t\tThrowable thrown;\n+\t\ttry {\n+\t\t\tthrower.run();\n+\t\t\tthrown = null;\n+\t\t} catch (Throwable caught) {\n+\t\t\tthrown = caught;\n+\t\t}\n+\n+\t\tif (!throwable.isInstance(thrown)) {\n+\t\t\tString caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n+\t\t\tthrow new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n+\t\t}\n+\n+\t\tif (thrown != null && !message.equals(thrown.getMessage())) {\n+\t\t\tthrow new AssertionError(format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n+\t\t}\n+\t}\n+}\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"}]}