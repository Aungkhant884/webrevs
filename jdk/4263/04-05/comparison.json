{"files":[{"patch":"@@ -60,167 +60,173 @@\n-\tpublic static void main(String[] args) throws Exception {\n-\t\ttest(fileChannelInput(), writableByteChannelOutput());\n-\t\ttest(seekableByteChannelInput(), fileChannelOutput());\n-\t\ttest(readableByteChannelInput(), fileChannelOutput());\n-\t\ttest(readableByteChannelInput(), writableByteChannelOutput());\n-\t\ttest(readableByteChannelInput(), defaultOutput());\n-\t}\n-\n-\tprivate static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n-\t\tifOutIsNullThenNpeIsThrown(inputStreamProvider);\n-\t\tcontents(inputStreamProvider, outputStreamProvider);\n-\t}\n-\n-\tprivate static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n-\t\ttry (InputStream in = inputStreamProvider.input()) {\n-\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n-\t\t}\n-\n-\t\ttry (InputStream in = inputStreamProvider.input((byte) 1)) {\n-\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n-\t\t}\n-\n-\t\ttry (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n-\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\n-\t\t}\n-\t}\n-\n-\tprivate static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\n-\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n-\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n-\t\t\/\/ to span through several batches\n-\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n-\t}\n-\n-\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes)\n-\t\t\tthrows Exception {\n-\t\tAtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n-\t\ttry (InputStream in = inputStreamProvider.input(inBytes); OutputStream out = outputStreamProvider.output(recorder::set)) {\n-\t\t\tin.transferTo(out);\n-\n-\t\t\tbyte[] outBytes = recorder.get().get();\n-\n-\t\t\tif (!Arrays.equals(inBytes, outBytes))\n-\t\t\t\tthrow new AssertionError(format(\"bytes.length=%s, outBytes.length=%s\", inBytes.length, outBytes.length));\n-\t\t}\n-\t}\n-\n-\tprivate static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n-\t\tRandom rnd = new Random();\n-\t\tbyte[] bytes = new byte[min + rnd.nextInt(maxRandomAdditive)];\n-\t\trnd.nextBytes(bytes);\n-\t\treturn bytes;\n-\t}\n-\n-\tprivate static interface InputStreamProvider {\n-\t\tInputStream input(byte... bytes) throws Exception;\n-\t}\n-\n-\tprivate static interface OutputStreamProvider {\n-\t\tOutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n-\t}\n-\n-\tprivate static OutputStreamProvider defaultOutput() {\n-\t\treturn new OutputStreamProvider() {\n-\t\t\t@Override\n-\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) {\n-\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-\t\t\t\tspy.accept(outputStream::toByteArray);\n-\t\t\t\treturn outputStream;\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\tprivate static InputStreamProvider fileChannelInput() {\n-\t\treturn new InputStreamProvider() {\n-\t\t\t@Override\n-\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n-\t\t\t\tPath path = Files.createTempFile(null, null);\n-\t\t\t\tFiles.write(path, bytes);\n-\t\t\t\tFileChannel fileChannel = FileChannel.open(path);\n-\t\t\t\treturn Channels.newInputStream(fileChannel);\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\tprivate static InputStreamProvider seekableByteChannelInput() {\n-\t\treturn new InputStreamProvider() {\n-\t\t\t@Override\n-\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n-\t\t\t\tPath temporaryJarFile = Files.createTempFile(null, \".zip\");\n-\t\t\t\ttry (JarOutputStream out = new JarOutputStream(Files.newOutputStream(temporaryJarFile))) {\n-\t\t\t\t\tJarEntry jarEntry = new JarEntry(\"raw-bytes\");\n-\t\t\t\t\tout.putNextEntry(jarEntry);\n-\t\t\t\t\tout.write(bytes);\n-\t\t\t\t\tout.closeEntry();\n-\t\t\t\t}\n-\t\t\t\tFileSystem zipFileSystem = FileSystems.newFileSystem(\n-\t\t\t\t\t\tnew URI(\"jar\", URLDecoder.decode(temporaryJarFile.toUri().toString(), StandardCharsets.UTF_8), null), Collections.emptyMap(), null);\n-\t\t\t\tSeekableByteChannel sbc = zipFileSystem.provider().newByteChannel(zipFileSystem.getPath(\"raw-bytes\"),\n-\t\t\t\t\t\tCollections.singleton(StandardOpenOption.READ));\n-\t\t\t\treturn Channels.newInputStream(sbc);\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\tprivate static InputStreamProvider readableByteChannelInput() {\n-\t\treturn new InputStreamProvider() {\n-\t\t\t@Override\n-\t\t\tpublic InputStream input(byte... bytes) throws Exception {\n-\t\t\t\treturn Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\tprivate static OutputStreamProvider fileChannelOutput() {\n-\t\treturn new OutputStreamProvider() {\n-\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n-\t\t\t\tPath path = Files.createTempFile(null, null);\n-\t\t\t\tFileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n-\t\t\t\tspy.accept(() -> {\n-\t\t\t\t\ttry {\n-\t\t\t\t\t\treturn Files.readAllBytes(path);\n-\t\t\t\t\t} catch (IOException e) {\n-\t\t\t\t\t\treturn null;\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\treturn Channels.newOutputStream(fileChannel);\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\tprivate static OutputStreamProvider writableByteChannelOutput() {\n-\t\treturn new OutputStreamProvider() {\n-\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n-\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n-\t\t\t\tspy.accept(outputStream::toByteArray);\n-\t\t\t\treturn Channels.newOutputStream(Channels.newChannel(outputStream));\n-\t\t\t}\n-\t\t};\n-\t}\n-\n-\tpublic interface Thrower {\n-\t\tpublic void run() throws Throwable;\n-\t}\n-\n-\tpublic static void assertThrowsNPE(Thrower thrower, String message) {\n-\t\tassertThrows(thrower, NullPointerException.class, message);\n-\t}\n-\n-\tpublic static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n-\t\tThrowable thrown;\n-\t\ttry {\n-\t\t\tthrower.run();\n-\t\t\tthrown = null;\n-\t\t} catch (Throwable caught) {\n-\t\t\tthrown = caught;\n-\t\t}\n-\n-\t\tif (!throwable.isInstance(thrown)) {\n-\t\t\tString caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n-\t\t\tthrow new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n-\t\t}\n-\n-\t\tif (thrown != null && !message.equals(thrown.getMessage())) {\n-\t\t\tthrow new AssertionError(format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n-\t\t}\n-\t}\n+    public static void main(String[] args) throws Exception {\n+        test(fileChannelInput(), writableByteChannelOutput());\n+        test(seekableByteChannelInput(), fileChannelOutput());\n+        test(readableByteChannelInput(), fileChannelOutput());\n+        test(readableByteChannelInput(), writableByteChannelOutput());\n+        test(readableByteChannelInput(), defaultOutput());\n+    }\n+\n+    private static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n+            throws Exception {\n+        ifOutIsNullThenNpeIsThrown(inputStreamProvider);\n+        contents(inputStreamProvider, outputStreamProvider);\n+    }\n+\n+    private static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\n+        try (InputStream in = inputStreamProvider.input()) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+\n+        try (InputStream in = inputStreamProvider.input((byte) 1)) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+\n+        try (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\n+            assertThrowsNPE(() -> in.transferTo(null), \"out\");\n+        }\n+    }\n+\n+    private static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider)\n+            throws Exception {\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\n+        \/\/ to span through several batches\n+        checkTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\n+    }\n+\n+    private static void checkTransferredContents(InputStreamProvider inputStreamProvider,\n+            OutputStreamProvider outputStreamProvider, byte[] inBytes) throws Exception {\n+        AtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\n+        try (InputStream in = inputStreamProvider.input(inBytes);\n+                OutputStream out = outputStreamProvider.output(recorder::set)) {\n+            in.transferTo(out);\n+\n+            byte[] outBytes = recorder.get().get();\n+\n+            if (!Arrays.equals(inBytes, outBytes))\n+                throw new AssertionError(\n+                        format(\"bytes.length=%s, outBytes.length=%s\", inBytes.length, outBytes.length));\n+        }\n+    }\n+\n+    private static byte[] createRandomBytes(int min, int maxRandomAdditive) {\n+        Random rnd = new Random();\n+        byte[] bytes = new byte[min + rnd.nextInt(maxRandomAdditive)];\n+        rnd.nextBytes(bytes);\n+        return bytes;\n+    }\n+\n+    private static interface InputStreamProvider {\n+        InputStream input(byte... bytes) throws Exception;\n+    }\n+\n+    private static interface OutputStreamProvider {\n+        OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\n+    }\n+\n+    private static OutputStreamProvider defaultOutput() {\n+        return new OutputStreamProvider() {\n+            @Override\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return outputStream;\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider fileChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                Files.write(path, bytes);\n+                FileChannel fileChannel = FileChannel.open(path);\n+                return Channels.newInputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider seekableByteChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                Path temporaryJarFile = Files.createTempFile(null, \".zip\");\n+                try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(temporaryJarFile))) {\n+                    JarEntry jarEntry = new JarEntry(\"raw-bytes\");\n+                    out.putNextEntry(jarEntry);\n+                    out.write(bytes);\n+                    out.closeEntry();\n+                }\n+                FileSystem zipFileSystem = FileSystems.newFileSystem(new URI(\"jar\",\n+                        URLDecoder.decode(temporaryJarFile.toUri().toString(), StandardCharsets.UTF_8), null),\n+                        Collections.emptyMap(), null);\n+                SeekableByteChannel sbc = zipFileSystem.provider().newByteChannel(zipFileSystem.getPath(\"raw-bytes\"),\n+                        Collections.singleton(StandardOpenOption.READ));\n+                return Channels.newInputStream(sbc);\n+            }\n+        };\n+    }\n+\n+    private static InputStreamProvider readableByteChannelInput() {\n+        return new InputStreamProvider() {\n+            @Override\n+            public InputStream input(byte... bytes) throws Exception {\n+                return Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider fileChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                Path path = Files.createTempFile(null, null);\n+                FileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\n+                spy.accept(() -> {\n+                    try {\n+                        return Files.readAllBytes(path);\n+                    } catch (IOException e) {\n+                        return null;\n+                    }\n+                });\n+                return Channels.newOutputStream(fileChannel);\n+            }\n+        };\n+    }\n+\n+    private static OutputStreamProvider writableByteChannelOutput() {\n+        return new OutputStreamProvider() {\n+            public OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\n+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n+                spy.accept(outputStream::toByteArray);\n+                return Channels.newOutputStream(Channels.newChannel(outputStream));\n+            }\n+        };\n+    }\n+\n+    public interface Thrower {\n+        public void run() throws Throwable;\n+    }\n+\n+    public static void assertThrowsNPE(Thrower thrower, String message) {\n+        assertThrows(thrower, NullPointerException.class, message);\n+    }\n+\n+    public static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\n+        Throwable thrown;\n+        try {\n+            thrower.run();\n+            thrown = null;\n+        } catch (Throwable caught) {\n+            thrown = caught;\n+        }\n+\n+        if (!throwable.isInstance(thrown)) {\n+            String caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\n+            throw new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\n+        }\n+\n+        if (thrown != null && !message.equals(thrown.getMessage())) {\n+            throw new AssertionError(\n+                    format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\n+        }\n+    }\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":173,"deletions":167,"binary":false,"changes":340,"status":"modified"}]}