{"files":[{"patch":"@@ -149,0 +149,2 @@\n+        Objects.requireNonNull(out, \"out\");\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\r\n+ * Copyright (c) 2014, 2021 Oracle and\/or its affiliates. All rights reserved.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+import static java.lang.String.format;\r\n+\r\n+import java.io.ByteArrayInputStream;\r\n+import java.io.ByteArrayOutputStream;\r\n+import java.io.IOException;\r\n+import java.io.InputStream;\r\n+import java.io.OutputStream;\r\n+import java.net.URI;\r\n+import java.net.URLDecoder;\r\n+import java.nio.channels.Channels;\r\n+import java.nio.channels.FileChannel;\r\n+import java.nio.channels.SeekableByteChannel;\r\n+import java.nio.charset.StandardCharsets;\r\n+import java.nio.file.FileSystem;\r\n+import java.nio.file.FileSystems;\r\n+import java.nio.file.Files;\r\n+import java.nio.file.Path;\r\n+import java.nio.file.StandardOpenOption;\r\n+import java.util.Arrays;\r\n+import java.util.Collections;\r\n+import java.util.Random;\r\n+import java.util.concurrent.atomic.AtomicReference;\r\n+import java.util.function.Consumer;\r\n+import java.util.function.Supplier;\r\n+import java.util.jar.JarEntry;\r\n+import java.util.jar.JarOutputStream;\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @bug 8265891\r\n+ * @summary tests whether sun.nio.ChannelInputStream.transferTo conforms to the\r\n+ *          InputStream.transferTo contract defined in the javadoc\r\n+ * @key randomness\r\n+ *\/\r\n+public class TransferTo {\r\n+\r\n+\tpublic static void main(String[] args) throws Exception {\r\n+\t\ttest(fileChannelInput(), writableByteChannelOutput());\r\n+\t\ttest(seekableByteChannelInput(), fileChannelOutput());\r\n+\t\ttest(readableByteChannelInput(), fileChannelOutput());\r\n+\t\ttest(readableByteChannelInput(), writableByteChannelOutput());\r\n+\t\ttest(readableByteChannelInput(), defaultOutput());\r\n+\t}\r\n+\r\n+\tprivate static void test(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\r\n+\t\tifOutIsNullThenNpeIsThrown(inputStreamProvider);\r\n+\t\tcontents(inputStreamProvider, outputStreamProvider);\r\n+\t}\r\n+\r\n+\tprivate static void ifOutIsNullThenNpeIsThrown(InputStreamProvider inputStreamProvider) throws Exception {\r\n+\t\ttry (InputStream in = inputStreamProvider.input()) {\r\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\r\n+\t\t}\r\n+\r\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1)) {\r\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\r\n+\t\t}\r\n+\r\n+\t\ttry (InputStream in = inputStreamProvider.input((byte) 1, (byte) 2)) {\r\n+\t\t\tassertThrowsNPE(() -> in.transferTo(null), \"out\");\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tprivate static void contents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider) throws Exception {\r\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, new byte[0]);\r\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(1024, 4096));\r\n+\t\t\/\/ to span through several batches\r\n+\t\tcheckTransferredContents(inputStreamProvider, outputStreamProvider, createRandomBytes(16384, 16384));\r\n+\t}\r\n+\r\n+\tprivate static void checkTransferredContents(InputStreamProvider inputStreamProvider, OutputStreamProvider outputStreamProvider, byte[] inBytes)\r\n+\t\t\tthrows Exception {\r\n+\t\tAtomicReference<Supplier<byte[]>> recorder = new AtomicReference<>();\r\n+\t\ttry (InputStream in = inputStreamProvider.input(inBytes); OutputStream out = outputStreamProvider.output(recorder::set)) {\r\n+\t\t\tin.transferTo(out);\r\n+\r\n+\t\t\tbyte[] outBytes = recorder.get().get();\r\n+\r\n+\t\t\tif (!Arrays.equals(inBytes, outBytes))\r\n+\t\t\t\tthrow new AssertionError(format(\"bytes.length=%s, outBytes.length=%s\", inBytes.length, outBytes.length));\r\n+\t\t}\r\n+\t}\r\n+\r\n+\tprivate static byte[] createRandomBytes(int min, int maxRandomAdditive) {\r\n+\t\tRandom rnd = new Random();\r\n+\t\tbyte[] bytes = new byte[min + rnd.nextInt(maxRandomAdditive)];\r\n+\t\trnd.nextBytes(bytes);\r\n+\t\treturn bytes;\r\n+\t}\r\n+\r\n+\tprivate static interface InputStreamProvider {\r\n+\t\tInputStream input(byte... bytes) throws Exception;\r\n+\t}\r\n+\r\n+\tprivate static interface OutputStreamProvider {\r\n+\t\tOutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception;\r\n+\t}\r\n+\r\n+\tprivate static OutputStreamProvider defaultOutput() {\r\n+\t\treturn new OutputStreamProvider() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) {\r\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n+\t\t\t\tspy.accept(outputStream::toByteArray);\r\n+\t\t\t\treturn outputStream;\r\n+\t\t\t}\r\n+\t\t};\r\n+\t}\r\n+\r\n+\tprivate static InputStreamProvider fileChannelInput() {\r\n+\t\treturn new InputStreamProvider() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\r\n+\t\t\t\tPath path = Files.createTempFile(null, null);\r\n+\t\t\t\tFiles.write(path, bytes);\r\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path);\r\n+\t\t\t\treturn Channels.newInputStream(fileChannel);\r\n+\t\t\t}\r\n+\t\t};\r\n+\t}\r\n+\r\n+\tprivate static InputStreamProvider seekableByteChannelInput() {\r\n+\t\treturn new InputStreamProvider() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\r\n+\t\t\t\tPath temporaryJarFile = Files.createTempFile(null, \".zip\");\r\n+\t\t\t\ttry (JarOutputStream out = new JarOutputStream(Files.newOutputStream(temporaryJarFile))) {\r\n+\t\t\t\t\tJarEntry jarEntry = new JarEntry(\"raw-bytes\");\r\n+\t\t\t\t\tout.putNextEntry(jarEntry);\r\n+\t\t\t\t\tout.write(bytes);\r\n+\t\t\t\t\tout.closeEntry();\r\n+\t\t\t\t}\r\n+\t\t\t\tFileSystem zipFileSystem = FileSystems.newFileSystem(\r\n+\t\t\t\t\t\tnew URI(\"jar\", URLDecoder.decode(temporaryJarFile.toUri().toString(), StandardCharsets.UTF_8), null), Collections.emptyMap(), null);\r\n+\t\t\t\tSeekableByteChannel sbc = zipFileSystem.provider().newByteChannel(zipFileSystem.getPath(\"raw-bytes\"),\r\n+\t\t\t\t\t\tCollections.singleton(StandardOpenOption.READ));\r\n+\t\t\t\treturn Channels.newInputStream(sbc);\r\n+\t\t\t}\r\n+\t\t};\r\n+\t}\r\n+\r\n+\tprivate static InputStreamProvider readableByteChannelInput() {\r\n+\t\treturn new InputStreamProvider() {\r\n+\t\t\t@Override\r\n+\t\t\tpublic InputStream input(byte... bytes) throws Exception {\r\n+\t\t\t\treturn Channels.newInputStream(Channels.newChannel(new ByteArrayInputStream(bytes)));\r\n+\t\t\t}\r\n+\t\t};\r\n+\t}\r\n+\r\n+\tprivate static OutputStreamProvider fileChannelOutput() {\r\n+\t\treturn new OutputStreamProvider() {\r\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\r\n+\t\t\t\tPath path = Files.createTempFile(null, null);\r\n+\t\t\t\tFileChannel fileChannel = FileChannel.open(path, StandardOpenOption.WRITE);\r\n+\t\t\t\tspy.accept(() -> {\r\n+\t\t\t\t\ttry {\r\n+\t\t\t\t\t\treturn Files.readAllBytes(path);\r\n+\t\t\t\t\t} catch (IOException e) {\r\n+\t\t\t\t\t\treturn null;\r\n+\t\t\t\t\t}\r\n+\t\t\t\t});\r\n+\t\t\t\treturn Channels.newOutputStream(fileChannel);\r\n+\t\t\t}\r\n+\t\t};\r\n+\t}\r\n+\r\n+\tprivate static OutputStreamProvider writableByteChannelOutput() {\r\n+\t\treturn new OutputStreamProvider() {\r\n+\t\t\tpublic OutputStream output(Consumer<Supplier<byte[]>> spy) throws Exception {\r\n+\t\t\t\tByteArrayOutputStream outputStream = new ByteArrayOutputStream();\r\n+\t\t\t\tspy.accept(outputStream::toByteArray);\r\n+\t\t\t\treturn Channels.newOutputStream(Channels.newChannel(outputStream));\r\n+\t\t\t}\r\n+\t\t};\r\n+\t}\r\n+\r\n+\tpublic interface Thrower {\r\n+\t\tpublic void run() throws Throwable;\r\n+\t}\r\n+\r\n+\tpublic static void assertThrowsNPE(Thrower thrower, String message) {\r\n+\t\tassertThrows(thrower, NullPointerException.class, message);\r\n+\t}\r\n+\r\n+\tpublic static <T extends Throwable> void assertThrows(Thrower thrower, Class<T> throwable, String message) {\r\n+\t\tThrowable thrown;\r\n+\t\ttry {\r\n+\t\t\tthrower.run();\r\n+\t\t\tthrown = null;\r\n+\t\t} catch (Throwable caught) {\r\n+\t\t\tthrown = caught;\r\n+\t\t}\r\n+\r\n+\t\tif (!throwable.isInstance(thrown)) {\r\n+\t\t\tString caught = thrown == null ? \"nothing\" : thrown.getClass().getCanonicalName();\r\n+\t\t\tthrow new AssertionError(format(\"Expected to catch %s, but caught %s\", throwable, caught), thrown);\r\n+\t\t}\r\n+\r\n+\t\tif (thrown != null && !message.equals(thrown.getMessage())) {\r\n+\t\t\tthrow new AssertionError(format(\"Expected exception message to be '%s', but it's '%s'\", message, thrown.getMessage()));\r\n+\t\t}\r\n+\t}\r\n+}\r\n","filename":"test\/jdk\/sun\/nio\/ch\/ChannelInputStream\/TransferTo.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"}]}