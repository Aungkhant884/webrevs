{"files":[{"patch":"@@ -56,1 +56,1 @@\n-    private static final int DEFAULT_BUFFER_SIZE = 8192;\n+    private static final int DEFAULT_BUFFER_SIZE = 16 * 8192;\n","filename":"src\/java.base\/share\/classes\/java\/io\/InputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import sun.nio.ch.ChannelOutputStream;\n@@ -66,34 +67,0 @@\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     * If the channel is selectable then it must be configured blocking.\n-     *\/\n-    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        while (bb.remaining() > 0) {\n-            int n = ch.write(bb);\n-            if (n <= 0)\n-                throw new RuntimeException(\"no bytes written\");\n-        }\n-    }\n-\n-    \/**\n-     * Write all remaining bytes in buffer to the given channel.\n-     *\n-     * @throws  IllegalBlockingModeException\n-     *          If the channel is selectable and configured non-blocking.\n-     *\/\n-    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n-        throws IOException\n-    {\n-        if (ch instanceof SelectableChannel sc) {\n-            synchronized (sc.blockingLock()) {\n-                if (!sc.isBlocking())\n-                    throw new IllegalBlockingModeException();\n-                writeFullyImpl(ch, bb);\n-            }\n-        } else {\n-            writeFullyImpl(ch, bb);\n-        }\n-    }\n-\n@@ -139,41 +106,1 @@\n-\n-        return new OutputStream() {\n-\n-            private ByteBuffer bb;\n-            private byte[] bs;       \/\/ Invoker's previous array\n-            private byte[] b1;\n-\n-            @Override\n-            public synchronized void write(int b) throws IOException {\n-                if (b1 == null)\n-                    b1 = new byte[1];\n-                b1[0] = (byte) b;\n-                this.write(b1);\n-            }\n-\n-            @Override\n-            public synchronized void write(byte[] bs, int off, int len)\n-                    throws IOException\n-            {\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n-                    return;\n-                }\n-                ByteBuffer bb = ((this.bs == bs)\n-                                 ? this.bb\n-                                 : ByteBuffer.wrap(bs));\n-                bb.limit(Math.min(off + len, bb.capacity()));\n-                bb.position(off);\n-                this.bb = bb;\n-                this.bs = bs;\n-                Channels.writeFully(ch, bb);\n-            }\n-\n-            @Override\n-            public void close() throws IOException {\n-                ch.close();\n-            }\n-\n-        };\n+        return new ChannelOutputStream(ch);\n@@ -219,4 +146,2 @@\n-                if ((off < 0) || (off > bs.length) || (len < 0) ||\n-                    ((off + len) > bs.length) || ((off + len) < 0)) {\n-                    throw new IndexOutOfBoundsException();\n-                } else if (len == 0) {\n+                Objects.checkFromIndexSize(off, len, bs.length);\n+                if (len == 0) {\n","filename":"src\/java.base\/share\/classes\/java\/nio\/channels\/Channels.java","additions":4,"deletions":79,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,74 @@\n+    private static final int TRANSFER_SIZE = 8192;\n+\n+    @Override\n+    public long transferTo(OutputStream out) throws IOException {\n+        if (out instanceof ChannelOutputStream cos) {\n+            WritableByteChannel oc = cos.channel();\n+            long i = 0L;\n+\n+            if (ch instanceof FileChannel fc) {\n+                long pos = fc.position();\n+                long size = fc.size();\n+                try {\n+                    for (long n = size - pos; i < n;)\n+                        i += fc.transferTo(pos + i, Long.MAX_VALUE, oc);\n+                    return i;\n+                } finally {\n+                    fc.position(pos + i);\n+                }\n+            }\n+\n+            if (oc instanceof FileChannel fc) {\n+                long fcpos = fc.position();\n+\n+                if (ch instanceof SeekableByteChannel sbc) {\n+                    long pos = sbc.position();\n+                    long size = sbc.size();\n+                    try {\n+                        for (long n = size - pos; i < n;)\n+                            i += fc.transferFrom(ch, fcpos + i, Long.MAX_VALUE);\n+                        return i;\n+                    } finally {\n+                        fc.position(fcpos + i);\n+                    }\n+                }\n+\n+                ByteBuffer bb = Util.getTemporaryDirectBuffer(TRANSFER_SIZE);\n+                try {\n+                    int r;\n+                    do {\n+                        i += fc.transferFrom(ch, fcpos + i, Long.MAX_VALUE);\n+                        r = ch.read(bb); \/\/ detect end-of-stream\n+                        if (r > -1) {\n+                            bb.flip();\n+                            while (bb.hasRemaining())\n+                                oc.write(bb);\n+                            bb.clear();\n+                            i += r;\n+                        }\n+                    } while (r > -1);\n+                    return i;\n+                } finally {\n+                    fc.position(fcpos + i);\n+                    Util.releaseTemporaryDirectBuffer(bb);\n+                }\n+            }\n+\n+            ByteBuffer bb = Util.getTemporaryDirectBuffer(TRANSFER_SIZE);\n+            try {\n+                for (int r = ch.read(bb); r > -1; r = ch.read(bb)) {\n+                    bb.flip();\n+                    while (bb.hasRemaining())\n+                        oc.write(bb);\n+                    bb.clear();\n+                    i += r;\n+                }\n+                return i;\n+            } finally {\n+                Util.releaseTemporaryDirectBuffer(bb);\n+            }\n+        }\n+\n+        return super.transferTo(out);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelInputStream.java","additions":75,"deletions":1,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.ch;\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.nio.channels.spi.*;\n+import java.util.Objects;\n+\n+\/**\n+ * This class is defined here rather than in java.nio.channels.Channels\n+ * so that it will be visible to java.nio.channels.Channels and\n+ * sun.nio.ch.ChannelInputStream but not be part of the java.base module API.\n+ *\n+ *\n+ * @author Mark Reinhold\n+ * @author Mike McCloskey\n+ * @author JSR-51 Expert Group\n+ * @since 18\n+ *\/\n+public class ChannelOutputStream extends OutputStream {\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     * If the channel is selectable then it must be configured blocking.\n+     *\/\n+    private static void writeFullyImpl(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        while (bb.remaining() > 0) {\n+            int n = ch.write(bb);\n+            if (n <= 0)\n+                throw new RuntimeException(\"no bytes written\");\n+        }\n+    }\n+\n+    \/**\n+     * Write all remaining bytes in buffer to the given channel.\n+     *\n+     * @throws  IllegalBlockingModeException\n+     *          If the channel is selectable and configured non-blocking.\n+     *\/\n+    private static void writeFully(WritableByteChannel ch, ByteBuffer bb)\n+        throws IOException\n+    {\n+        if (ch instanceof SelectableChannel sc) {\n+            synchronized (sc.blockingLock()) {\n+                if (!sc.isBlocking())\n+                    throw new IllegalBlockingModeException();\n+                writeFullyImpl(ch, bb);\n+            }\n+        } else {\n+            writeFullyImpl(ch, bb);\n+        }\n+    }\n+\n+    private final WritableByteChannel ch;\n+    private ByteBuffer bb;\n+    private byte[] bs;       \/\/ Invoker's previous array\n+    private byte[] b1;\n+\n+    \/**\n+     * @param ch The channel wrapped by this stream.\n+     *\/\n+    public ChannelOutputStream(WritableByteChannel ch) {\n+        this.ch = ch;\n+    }\n+\n+    \/**\n+     * @return The channel wrapped by this stream.\n+     *\/\n+    WritableByteChannel channel() {\n+        return ch;\n+    }\n+\n+    @Override\n+    public synchronized void write(int b) throws IOException {\n+        if (b1 == null)\n+            b1 = new byte[1];\n+        b1[0] = (byte) b;\n+        this.write(b1);\n+    }\n+\n+    @Override\n+    public synchronized void write(byte[] bs, int off, int len)\n+        throws IOException {\n+        Objects.checkFromIndexSize(off, len, bs.length);\n+        if (len == 0) {\n+            return;\n+        }\n+        ByteBuffer bb = ((this.bs == bs)\n+                         ? this.bb\n+                         : ByteBuffer.wrap(bs));\n+        bb.limit(Math.min(off + len, bb.capacity()));\n+        bb.position(off);\n+        this.bb = bb;\n+        this.bs = bs;\n+        writeFully(ch, bb);\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        ch.close();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/ChannelOutputStream.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"}]}