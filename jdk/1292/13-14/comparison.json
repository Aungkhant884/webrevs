{"files":[{"patch":"@@ -271,2 +271,45 @@\n-     * Returns a pseudorandom {@code int} value between zero (inclusive)\n-     * and the specified bound (exclusive).\n+     * Returns a pseudorandom, uniformly distributed {@code int} value\n+     * between 0 (inclusive) and the specified value (exclusive), drawn from\n+     * this random number generator's sequence.  The general contract of\n+     * {@code nextInt} is that one {@code int} value in the specified range\n+     * is pseudorandomly generated and returned.  All {@code bound} possible\n+     * {@code int} values are produced with (approximately) equal\n+     * probability.  The method {@code nextInt(int bound)} is implemented by\n+     * class {@code Random} as if by:\n+     *  <pre> {@code\n+     * public int nextInt(int bound) {\n+     *   if (bound <= 0)\n+     *     throw new IllegalArgumentException(\"bound must be positive\");\n+     *\n+     *   if ((bound & -bound) == bound)  \/\/ i.e., bound is a power of 2\n+     *     return (int)((bound * (long)next(31)) >> 31);\n+     *\n+     *   int bits, val;\n+     *   do {\n+     *       bits = next(31);\n+     *       val = bits % bound;\n+     *   } while (bits - val + (bound-1) < 0);\n+     *   return val;\n+     * }}<\/pre>\n+     *\n+     * <p>The hedge \"approximately\" is used in the foregoing description only\n+     * because the next method is only approximately an unbiased source of\n+     * independently chosen bits.  If it were a perfect source of randomly\n+     * chosen bits, then the algorithm shown would choose {@code int}\n+     * values from the stated range with perfect uniformity.\n+     * <p>\n+     * The algorithm is slightly tricky.  It rejects values that would result\n+     * in an uneven distribution (due to the fact that 2^31 is not divisible\n+     * by n). The probability of a value being rejected depends on n.  The\n+     * worst case is n=2^30+1, for which the probability of a reject is 1\/2,\n+     * and the expected number of iterations before the loop terminates is 2.\n+     * <p>\n+     * The algorithm treats the case where n is a power of two specially: it\n+     * returns the correct number of high-order bits from the underlying\n+     * pseudo-random number generator.  In the absence of special treatment,\n+     * the correct number of <i>low-order<\/i> bits would be returned.  Linear\n+     * congruential pseudo-random number generators such as the one\n+     * implemented by this class are known to have short periods in the\n+     * sequence of values of their low-order bits.  Thus, this special case\n+     * greatly increases the length of the sequence of values returned by\n+     * successive calls to this method if n is a small power of two.\n@@ -275,3 +318,5 @@\n-     * @return a pseudorandom {@code int} value between zero\n-     *         (inclusive) and the bound (exclusive)\n-     * @throws IllegalArgumentException if {@code bound} is not positive\n+     * @return the next pseudorandom, uniformly distributed {@code int}\n+     *         value between zero (inclusive) and {@code bound} (exclusive)\n+     *         from this random number generator's sequence\n+     * @throws IllegalArgumentException if bound is not positive\n+     * @since 1.2\n@@ -586,0 +631,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -591,0 +641,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -596,0 +651,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -601,0 +661,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -606,0 +671,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -611,0 +681,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -616,0 +691,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -621,0 +701,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -626,0 +711,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -631,0 +721,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -636,0 +731,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n@@ -641,0 +741,5 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @since 1.8\n+     *\/\n","filename":"src\/java.base\/share\/classes\/java\/util\/Random.java","additions":110,"deletions":5,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -287,95 +287,0 @@\n-\n-    @Override\n-    public Spliterator.OfInt makeIntsSpliterator(long index, long fence, int origin, int bound) {\n-        return super.makeIntsSpliterator(index, fence, origin, bound);\n-    }\n-\n-    @Override\n-    public Spliterator.OfLong makeLongsSpliterator(long index, long fence, long origin, long bound) {\n-        return super.makeLongsSpliterator(index, fence, origin, bound);\n-    }\n-\n-    @Override\n-    public Spliterator.OfDouble makeDoublesSpliterator(long index, long fence, double origin, double bound) {\n-        return super.makeDoublesSpliterator(index, fence, origin, bound);\n-    }\n-\n-    @Override\n-    public Stream<SplittableGenerator> splits() {\n-        return super.splits();\n-    }\n-\n-    @Override\n-    public Stream<SplittableGenerator> splits(long streamSize) {\n-        return super.splits(streamSize);\n-    }\n-\n-    @Override\n-    public Stream<SplittableGenerator> splits(SplittableGenerator source) {\n-        return super.splits(source);\n-    }\n-\n-    @Override\n-    public Stream<SplittableGenerator> splits(long streamSize, SplittableGenerator source) {\n-        return super.splits(streamSize, source);\n-    }\n-\n-    @Override\n-    public IntStream ints(long streamSize) {\n-        return super.ints(streamSize);\n-    }\n-\n-    @Override\n-    public IntStream ints() {\n-        return super.ints();\n-    }\n-\n-    @Override\n-    public IntStream ints(long streamSize, int randomNumberOrigin, int randomNumberBound) {\n-        return super.ints(streamSize, randomNumberOrigin, randomNumberBound);\n-    }\n-\n-    @Override\n-    public IntStream ints(int randomNumberOrigin, int randomNumberBound) {\n-        return super.ints(randomNumberOrigin, randomNumberBound);\n-    }\n-\n-    @Override\n-    public LongStream longs(long streamSize) {\n-        return super.longs(streamSize);\n-    }\n-\n-    @Override\n-    public LongStream longs() {\n-        return super.longs();\n-    }\n-\n-    @Override\n-    public LongStream longs(long streamSize, long randomNumberOrigin, long randomNumberBound) {\n-        return super.longs(streamSize, randomNumberOrigin, randomNumberBound);\n-    }\n-\n-    @Override\n-    public LongStream longs(long randomNumberOrigin, long randomNumberBound) {\n-        return super.longs(randomNumberOrigin, randomNumberBound);\n-    }\n-\n-    @Override\n-    public DoubleStream doubles(long streamSize) {\n-        return super.doubles(streamSize);\n-    }\n-\n-    @Override\n-    public DoubleStream doubles() {\n-        return super.doubles();\n-    }\n-\n-    @Override\n-    public DoubleStream doubles(long streamSize, double randomNumberOrigin, double randomNumberBound) {\n-        return super.doubles(streamSize, randomNumberOrigin, randomNumberBound);\n-    }\n-\n-    @Override\n-    public DoubleStream doubles(double randomNumberOrigin, double randomNumberBound) {\n-        return super.doubles(randomNumberOrigin, randomNumberBound);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/SplittableRandom.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -423,11 +423,0 @@\n-    \/**\n-     * Returns a {@code RandomGenerator} object that uses {@code ThreadLocalRandom}.\n-     * This object is threadsafe (methods of this object may be called by threads\n-     * other than the current one).\n-     *\n-     * @return a {@code RandomGenerator} object that uses {@code ThreadLocalRandom}\n-     *\/\n-    public static RandomGenerator proxy() {\n-        return ThreadLocalRandomProxy.proxy;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n- * @since   17\n+ * @since 17\n@@ -125,30 +125,0 @@\n-    \/**\n-     * Returns a {@link RandomGeneratorFactory} that can produce instances of\n-     * {@link RandomGenerator} that utilize the {@code name} algorithm.\n-     *\n-     * @param name  Name of random number generator algorithm\n-     *\n-     * @return {@link RandomGeneratorFactory} of {@link RandomGenerator}\n-     *\n-     * @throws NullPointerException if name is null\n-     * @throws IllegalArgumentException if the named algorithm is not found\n-     *\/\n-    static RandomGeneratorFactory<RandomGenerator> factoryOf(String name) {\n-        Objects.requireNonNull(name);\n-\n-        return RandomGeneratorFactory.factoryOf(name, RandomGenerator.class);\n-    }\n-\n-    \/**\n-     * Returns a {@link RandomGeneratorFactory} meeting the minimal requirement\n-     * of having an algorithm whose state bits are greater than or equal 64.\n-     *\n-     * @implNote  Since algorithms will improve over time, there is no\n-     * guarantee that this method will return the same algorithm each time.\n-     *\n-     * @return a {@link RandomGeneratorFactory}\n-     *\/\n-    static RandomGeneratorFactory<RandomGenerator> getDefaultFactory() {\n-        return factoryOf(\"L32X64MixRandom\");\n-    }\n-\n@@ -159,2 +129,2 @@\n-     * @implNote  Since algorithms will improve over time, there is no\n-     * guarantee that this method will return the same algorithm each time.\n+     * @implSpec  Since algorithms will improve over time, there is no\n+     * guarantee that this method will return the same algorithm over time.\n@@ -171,0 +141,3 @@\n+     * @implNote Availability is determined by RandomGeneratorFactory using the\n+     * service provider API to locate implementations of the RandomGenerator interface.\n+     *\n@@ -767,20 +740,0 @@\n-    \/**\n-     * The property returned by {@link RandomGeneratorFactory#period() period}()\n-     * if the period is unknown.\n-     *\/\n-    BigInteger UNKNOWN_PERIOD = BigInteger.ZERO;\n-\n-    \/**\n-     * The (negative) value returned by the\n-     * {@link RandomGeneratorFactory#period() period}() if this generator has no\n-     * period because it is truly random rather than just pseudorandom.\n-     *\/\n-    BigInteger TRULY_RANDOM = BigInteger.valueOf(-1);\n-\n-    \/**\n-     * The (negative) value that may be returned by the\n-     * {@link RandomGeneratorFactory#period() period}() if this generator has a\n-     * huge period (larger than 2**(2**16)).\n-     *\/\n-    BigInteger HUGE_PERIOD = BigInteger.valueOf(-2);\n-\n@@ -821,0 +774,4 @@\n+         * @implNote Availability is determined by RandomGeneratorFactory using the\n+         * service provider API to locate implementations of the RandomGenerator\n+         * interface and filtering on the StreamableGenerator interface.\n+         *\n@@ -844,18 +801,0 @@\n-        \/**\n-         * Returns a {@link RandomGeneratorFactory} that can produce instances\n-         * of {@link StreamableGenerator} that utilize the {@code name}\n-         * algorithm.\n-         *\n-         * @param name  Name of random number generator algorithm\n-         *\n-         * @return {@link RandomGeneratorFactory} of {@link StreamableGenerator}\n-         *\n-         * @throws NullPointerException if name is null\n-         * @throws IllegalArgumentException if the named algorithm is not found\n-         *\/\n-        static RandomGeneratorFactory<StreamableGenerator> factoryOf(String name) {\n-            Objects.requireNonNull(name);\n-\n-            return RandomGeneratorFactory.factoryOf(name, StreamableGenerator.class);\n-        }\n-\n@@ -941,0 +880,4 @@\n+         * @implNote Availability is determined by RandomGeneratorFactory using the\n+         * service provider API to locate implementations of the RandomGenerator\n+         * interface and filtering on the SplittableGenerator interface.\n+         *\n@@ -954,18 +897,0 @@\n-        \/**\n-         * Returns a {@link RandomGeneratorFactory} that can produce instances\n-         * of {@link SplittableGenerator} that utilize the {@code name}\n-         * algorithm.\n-         *\n-         * @param name  Name of random number generator algorithm\n-         *\n-         * @return {@link RandomGeneratorFactory} of {@link SplittableGenerator}\n-         *\n-         * @throws NullPointerException if name is null\n-         * @throws IllegalArgumentException if the named algorithm is not found\n-         *\/\n-        static RandomGeneratorFactory<SplittableGenerator> factoryOf(String name) {\n-            Objects.requireNonNull(name);\n-\n-            return RandomGeneratorFactory.factoryOf(name, SplittableGenerator.class);\n-        }\n-\n@@ -1148,0 +1073,4 @@\n+         * @implNote Availability is determined by RandomGeneratorFactory using the\n+         * service provider API to locate implementations of the RandomGenerator\n+         * interface and filtering on the JumpableGenerator interface.\n+         *\n@@ -1171,17 +1100,0 @@\n-        \/**\n-         * Returns a {@link RandomGeneratorFactory} that can produce instances\n-         * of {@link JumpableGenerator} that utilize the {@code name} algorithm.\n-         *\n-         * @param name  Name of random number generator algorithm\n-         *\n-         * @return {@link RandomGeneratorFactory} of {@link JumpableGenerator}\n-         *\n-         * @throws NullPointerException if name is null\n-         * @throws IllegalArgumentException if the named algorithm is not found\n-         *\/\n-        static RandomGeneratorFactory<JumpableGenerator> factoryOf(String name) {\n-            Objects.requireNonNull(name);\n-\n-            return RandomGeneratorFactory.factoryOf(name, JumpableGenerator.class);\n-        }\n-\n@@ -1345,0 +1257,4 @@\n+         * @implNote Availability is determined by RandomGeneratorFactory using the\n+         * service provider API to locate implementations of the RandomGenerator\n+         * interface and filtering on the LeapableGenerator interface.\n+         *\n@@ -1368,17 +1284,0 @@\n-        \/**\n-         * Returns a {@link RandomGeneratorFactory} that can produce instances\n-         * of {@link LeapableGenerator} that utilize the {@code name} algorithm.\n-         *\n-         * @param name  Name of random number generator algorithm\n-         *\n-         * @return {@link RandomGeneratorFactory} of {@link LeapableGenerator}\n-         *\n-         * @throws NullPointerException if name is null\n-         * @throws IllegalArgumentException if the named algorithm is not found\n-         *\/\n-        static RandomGeneratorFactory<LeapableGenerator> factoryOf(String name) {\n-            Objects.requireNonNull(name);\n-\n-            return RandomGeneratorFactory.factoryOf(name, LeapableGenerator.class);\n-        }\n-\n@@ -1509,0 +1408,4 @@\n+         * @implNote Availability is determined by RandomGeneratorFactory using the\n+         * service provider API to locate implementations of the RandomGenerator\n+         * interface and filtering on the ArbitrarilyJumpableGenerator interface.\n+         *\n@@ -1533,18 +1436,0 @@\n-        \/**\n-         * Returns a {@link RandomGeneratorFactory} that can produce instances\n-         * of {@link ArbitrarilyJumpableGenerator} that utilize the {@code name}\n-         * algorithm.\n-         *\n-         * @param name  Name of random number generator algorithm\n-         *\n-         * @return {@link RandomGeneratorFactory} of {@link ArbitrarilyJumpableGenerator}\n-         *\n-         * @throws NullPointerException if name is null\n-         * @throws IllegalArgumentException if the named algorithm is not found\n-         *\/\n-        static RandomGeneratorFactory<ArbitrarilyJumpableGenerator> factoryOf(String name) {\n-            Objects.requireNonNull(name);\n-\n-            return RandomGeneratorFactory.factoryOf(name, ArbitrarilyJumpableGenerator.class);\n-        }\n-\n@@ -1580,1 +1465,1 @@\n-         * @throws IllegalArgumentException if {@code distance} is Nan, negative, or greater than the\n+         * @throws IllegalArgumentException if {@code distance} is NaN, negative, or greater than the\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":27,"deletions":142,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n- * @since   17\n+ * @since 17\n@@ -344,0 +344,45 @@\n+    \/**\n+     * Returns a {@link RandomGeneratorFactory} that can produce instances of\n+     * {@link RandomGenerator} that utilize the {@code name} algorithm.\n+     *\n+     * @implNote Availability is determined by RandomGeneratorFactory using the\n+     * service provider API to locate implementations of the RandomGenerator interface.\n+     *\n+     * @param name  Name of random number generator algorithm\n+     *\n+     * @return {@link RandomGeneratorFactory} of {@link RandomGenerator}\n+     *\n+     * @throws NullPointerException if name is null\n+     * @throws IllegalArgumentException if the named algorithm is not found\n+     *\/\n+    public static RandomGeneratorFactory<RandomGenerator> of(String name) {\n+        Objects.requireNonNull(name);\n+\n+        return factoryOf(name, RandomGenerator.class);\n+    }\n+\n+    \/**\n+     * Returns a {@link RandomGeneratorFactory} meeting the minimal requirement\n+     * of having an algorithm whose state bits are greater than or equal 64.\n+     *\n+     * @implSpec  Since algorithms will improve over time, there is no\n+     * guarantee that this method will return the same algorithm over time.\n+     *\n+     * @return a {@link RandomGeneratorFactory}\n+     *\/\n+    public static RandomGeneratorFactory<RandomGenerator> getDefault() {\n+        return factoryOf(\"L32X64MixRandom\", RandomGenerator.class);\n+    }\n+\n+    \/**\n+     * Returns a stream of all available {@link RandomGeneratorFactory RandomGeneratorFactory(s)}.\n+     *\n+     * @implNote Availability is determined by RandomGeneratorFactory using the service provider API\n+     * to locate implementations of the RandomGenerator interface.\n+     *\n+     * @return Stream of all available {@link RandomGeneratorFactory RandomGeneratorFactory(s)}.\n+     *\/\n+    public static Stream<RandomGeneratorFactory<RandomGenerator>> all() {\n+        return all(RandomGenerator.class);\n+    }\n+\n@@ -386,0 +431,1 @@\n+     * Returns BigInteger.ZERO if period is not determinable.\n@@ -396,1 +442,1 @@\n-            return RandomGenerator.HUGE_PERIOD;\n+            return BigInteger.ZERO;\n@@ -403,1 +449,2 @@\n-     * Return true if random generator is statistical.\n+     * Return true if random generator is computed using an arithmetic algorithm\n+     * and is statistically deterministic.\n@@ -412,1 +459,2 @@\n-     * Return true if random generator is stochastic.\n+     * Return true if random generator is computed using external or entropic\n+     * sources as inputs.\n@@ -421,1 +469,2 @@\n-     * Return true if random generator is generated by hardware.\n+     * Return true if random generator uses a hardware device (HRNG) to produce\n+     * entropic input.\n@@ -430,1 +479,2 @@\n-     * Return true if random generator is arbitrarily jumpable.\n+     * Return true if random generator can jump an arbitrarily specified distant\n+     * point in the state cycle.\n@@ -435,1 +485,1 @@\n-        return isSubclass(ArbitrarilyJumpableGenerator.class);\n+        return provider instanceof ArbitrarilyJumpableGenerator;\n@@ -439,1 +489,2 @@\n-     * Return true if random generator is jumpable.\n+     * Return true if random generator can jump a specified distant point in\n+     * the state cycle.\n@@ -444,1 +495,1 @@\n-        return isSubclass(JumpableGenerator.class);\n+        return provider instanceof JumpableGenerator;\n@@ -448,1 +499,2 @@\n-     * Return true if random generator is leapable.\n+     * Return true if random generator is jumpable and can leap to a very distant\n+     * point in the state cycle.\n@@ -453,1 +505,1 @@\n-        return isSubclass(LeapableGenerator.class);\n+        return provider instanceof LeapableGenerator;\n@@ -457,1 +509,2 @@\n-     * Return true if random generator is splittable.\n+     * Return true if random generator can be cloned into a separate object with\n+     * the same properties but positioned further in the state cycle.\n@@ -462,1 +515,1 @@\n-        return isSubclass(SplittableGenerator.class);\n+        return provider instanceof SplittableGenerator;\n@@ -466,1 +519,2 @@\n-     * Return true if random generator is streamable.\n+     * Return true if random generator can be used to create\n+     * {@link java.util.stream.Stream Streams} of random numbers.\n@@ -471,1 +525,1 @@\n-        return isSubclass(StreamableGenerator.class);\n+        return provider instanceof StreamableGenerator;\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGeneratorFactory.java","additions":69,"deletions":15,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n- * <p> The principal supporting class is {@link RandomGenertatorFactory}. This\n+ * <p> The principal supporting class is {@link RandomGeneratorFactory}. This\n@@ -53,1 +53,3 @@\n- * selecting random number generator algorithms.\n+ * selecting random number generator algorithms. RandomGeneratorFactory\n+ * registers implementations of {@link RandomGenerator} interface using the\n+ * service provider API.\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n- * @since   16\n+ * @since 17\n@@ -1431,1 +1431,1 @@\n-     * @since   16\n+     * @since 17\n@@ -1522,0 +1522,3 @@\n+         * <p>The (pseudo)random {@code int} values are generated as if it's the result of\n+         * calling the method {@link #nextInt()}.\n+         *\n@@ -1537,0 +1540,3 @@\n+         * <p>The (pseudo)random {@code int} values are generated as if the result of\n+         * calling the method {@link #nextInt()}.\n+         *\n@@ -1553,0 +1559,17 @@\n+         * <p>The (pseudo)random {@code int} values are generated as if the result of\n+         * calling the following method with the origin and bound:\n+         * <pre> {@code\n+         * int nextInt(int origin, int bound) {\n+         *   int n = bound - origin;\n+         *   if (n > 0) {\n+         *     return nextInt(n) + origin;\n+         *   }\n+         *   else {  \/\/ range not representable as int\n+         *     int r;\n+         *     do {\n+         *       r = nextInt();\n+         *     } while (r < origin || r >= bound);\n+         *     return r;\n+         *   }\n+         * }}<\/pre>\n+         *\n@@ -1575,0 +1598,20 @@\n+         * <p>The (pseudo)random {@code int} values are generated as if the result of\n+         * calling the following method with the origin and bound:\n+         * <pre> {@code\n+         * int nextInt(int origin, int bound) {\n+         *   int n = bound - origin;\n+         *   if (n > 0) {\n+         *     return nextInt(n) + origin;\n+         *   }\n+         *   else {  \/\/ range not representable as int\n+         *     int r;\n+         *     do {\n+         *       r = nextInt();\n+         *     } while (r < origin || r >= bound);\n+         *     return r;\n+         *   }\n+         * }}<\/pre>\n+         *\n+         * @implNote This method is implemented to be equivalent to {@code\n+         * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+         *\n@@ -1583,3 +1626,0 @@\n-         *\n-         * @implNote This method is implemented to be equivalent to {@code ints(Long.MAX_VALUE,\n-         *         randomNumberOrigin, randomNumberBound)}.\n@@ -1597,0 +1637,3 @@\n+         * <p>The (pseudo)random {@code long} values are generated as if the result\n+         * of calling the method {@link #nextLong()}.\n+         *\n@@ -1612,0 +1655,3 @@\n+         * <p>The (pseudo)random {@code long} values are generated as if the result\n+         * of calling the method {@link #nextLong()}.\n+         *\n@@ -1627,0 +1673,22 @@\n+         * <p>The (pseudo)random {@code long} values are generated as if the result\n+         * of calling the following method with the origin and bound:\n+         * <pre> {@code\n+         * long nextLong(long origin, long bound) {\n+         *   long r = nextLong();\n+         *   long n = bound - origin, m = n - 1;\n+         *   if ((n & m) == 0L)  \/\/ power of two\n+         *     r = (r & m) + origin;\n+         *   else if (n > 0L) {  \/\/ reject over-represented candidates\n+         *     for (long u = r >>> 1;            \/\/ ensure nonnegative\n+         *          u + m - (r = u % n) < 0L;    \/\/ rejection check\n+         *          u = nextLong() >>> 1) \/\/ retry\n+         *         ;\n+         *     r += origin;\n+         *   }\n+         *   else {              \/\/ range not representable as long\n+         *     while (r < origin || r >= bound)\n+         *       r = nextLong();\n+         *   }\n+         *   return r;\n+         * }}<\/pre>\n+         *\n@@ -1651,0 +1719,25 @@\n+         * <p>The (pseudo)random {@code long} values are generated as if the result\n+         * of calling the following method with the origin and bound:\n+         * <pre> {@code\n+         * long nextLong(long origin, long bound) {\n+         *   long r = nextLong();\n+         *   long n = bound - origin, m = n - 1;\n+         *   if ((n & m) == 0L)  \/\/ power of two\n+         *     r = (r & m) + origin;\n+         *   else if (n > 0L) {  \/\/ reject over-represented candidates\n+         *     for (long u = r >>> 1;            \/\/ ensure nonnegative\n+         *          u + m - (r = u % n) < 0L;    \/\/ rejection check\n+         *          u = nextLong() >>> 1) \/\/ retry\n+         *         ;\n+         *     r += origin;\n+         *   }\n+         *   else {              \/\/ range not representable as long\n+         *     while (r < origin || r >= bound)\n+         *       r = nextLong();\n+         *   }\n+         *   return r;\n+         * }}<\/pre>\n+         *\n+         * @implNote This method is implemented to be equivalent to {@code\n+         * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+         *\n@@ -1659,3 +1752,0 @@\n-         *\n-         * @implNote This method is implemented to be equivalent to {@code longs(Long.MAX_VALUE,\n-         *         randomNumberOrigin, randomNumberBound)}.\n@@ -1676,0 +1766,3 @@\n+         * <p>The pseudorandom {@code double} values are generated as ifs the result\n+         * of calling the method {@link #nextDouble()}.\n+         *\n@@ -1692,1 +1785,2 @@\n-         * @return a stream of (pseudo)random {@code double} values\n+         * <p>The (pseudo)random {@code double} values are generated as if the result\n+         * of calling the method {@link #nextDouble()}.\n@@ -1695,1 +1789,3 @@\n-         *         doubles(Long.MAX_VALUE)}.\n+         * doubles(Long.MAX_VALUE)}.\n+         *\n+         * @return a stream of (pseudo)random {@code double} values\n@@ -1707,0 +1803,11 @@\n+         * <p>The (pseudo)random {@code double} values are generated as if the result\n+         * of calling the following method with the origin and bound:\n+         * <pre> {@code\n+         * double nextDouble(double origin, double bound) {\n+         *   double r = nextDouble();\n+         *   r = r * (bound - origin) + origin;\n+         *   if (r >= bound) \/\/ correct for rounding\n+         *     r = Math.nextDown(bound);\n+         *   return r;\n+         * }}<\/pre>\n+         *\n@@ -1730,0 +1837,14 @@\n+         * <p>The (pseudo)random {@code double} values are generated as if the result\n+         * of calling the following method with the origin and bound:\n+         * <pre> {@code\n+         * double nextDouble(double origin, double bound) {\n+         *   double r = nextDouble();\n+         *   r = r * (bound - origin) + origin;\n+         *   if (r >= bound) \/\/ correct for rounding\n+         *     r = Math.nextDown(bound);\n+         *   return r;\n+         * }}<\/pre>\n+         *\n+         * @implNote This method is implemented to be equivalent to {@code\n+         * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+         *\n@@ -1738,3 +1859,0 @@\n-         *\n-         * @implNote This method is implemented to be equivalent to {@code\n-         *         doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n@@ -1798,1 +1916,1 @@\n-     * @since   16\n+     * @since 17\n@@ -2317,1 +2435,1 @@\n-     * @since   16\n+     * @since 17\n@@ -2668,1 +2786,1 @@\n-     * @since   16\n+     * @since 17\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":134,"deletions":16,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-        coverFactory(RandomGenerator.factoryOf(name));\n+        coverFactory(RandomGeneratorFactory.of(name));\n@@ -138,1 +138,1 @@\n-            RandomGenerator.getDefaultFactory();\n+            RandomGeneratorFactory.getDefault();\n","filename":"test\/jdk\/java\/util\/Random\/RandomTestCoverage.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}