{"files":[{"patch":"@@ -134,4 +134,5 @@\n-     * <p>The invocation {@code new Random(seed)} is equivalent to:\n-     *  <pre> {@code\n-     * Random rnd = new Random();\n-     * rnd.setSeed(seed);}<\/pre>\n+     * @implNote <p>The invocation {@code new Random(seed)} is equivalent to:\n+     *           <pre>{@code\n+     *           Random rnd = new Random();\n+     *           rnd.setSeed(seed);\n+     *           }<\/pre>\n@@ -220,9 +221,9 @@\n-     * <p>The method {@code nextBytes} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n-     * public void nextBytes(byte[] bytes) {\n-     *   for (int i = 0; i < bytes.length; )\n-     *     for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);\n-     *          n-- > 0; rnd >>= 8)\n-     *       bytes[i++] = (byte)rnd;\n-     * }}<\/pre>\n+     * @implNote <p>The method {@code nextBytes} is\n+     *           implemented by class {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public void nextBytes(byte[] bytes) {\n+     *             for (int i = 0; i < bytes.length; )\n+     *               for (int rnd = nextInt(), n = Math.min(bytes.length - i, 4);\n+     *                    n-- > 0; rnd >>= 8)\n+     *                 bytes[i++] = (byte)rnd;\n+     *           }}<\/pre>\n@@ -250,6 +251,6 @@\n-     * <p>The method {@code nextInt} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n-     * public int nextInt() {\n-     *   return next(32);\n-     * }}<\/pre>\n+     * @implNote <p>The method {@code nextInt} is\n+     *           implemented by class {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public int nextInt() {\n+     *             return next(32);\n+     *           }}<\/pre>\n@@ -272,17 +273,19 @@\n-     * probability.  The method {@code nextInt(int bound)} is implemented by\n-     * class {@code Random} as if by:\n-     *  <pre> {@code\n-     * public int nextInt(int bound) {\n-     *   if (bound <= 0)\n-     *     throw new IllegalArgumentException(\"bound must be positive\");\n-     *\n-     *   if ((bound & -bound) == bound)  \/\/ i.e., bound is a power of 2\n-     *     return (int)((bound * (long)next(31)) >> 31);\n-     *\n-     *   int bits, val;\n-     *   do {\n-     *       bits = next(31);\n-     *       val = bits % bound;\n-     *   } while (bits - val + (bound-1) < 0);\n-     *   return val;\n-     * }}<\/pre>\n+     * probability.\n+     *\n+     * @implNote <p>The method {@code nextInt(int bound)} is implemented by\n+     *           class {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public int nextInt(int bound) {\n+     *             if (bound <= 0)\n+     *               throw new IllegalArgumentException(\"bound must be positive\");\n+     *\n+     *             if ((bound & -bound) == bound)  \/\/ i.e., bound is a power of 2\n+     *               return (int)((bound * (long)next(31)) >> 31);\n+     *\n+     *             int bits, val;\n+     *             do {\n+     *                 bits = next(31);\n+     *                 val = bits % bound;\n+     *             } while (bits - val + (bound-1) < 0);\n+     *             return val;\n+     *           }}<\/pre>\n@@ -341,6 +344,6 @@\n-     * <p>The method {@code nextLong} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n-     * public long nextLong() {\n-     *   return ((long)next(32) << 32) + next(32);\n-     * }}<\/pre>\n+     * @implNote <p>The method {@code nextLong} is implemented by class {@code Random}\n+     *           {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public long nextLong() {\n+     *             return ((long)next(32) << 32) + next(32);\n+     *           }}<\/pre>\n@@ -368,6 +371,6 @@\n-     * <p>The method {@code nextBoolean} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n-     * public boolean nextBoolean() {\n-     *   return next(1) != 0;\n-     * }}<\/pre>\n+     * @implNote <p>The method {@code nextBoolean} is implemented by class\n+     *           {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public boolean nextBoolean() {\n+     *             return next(1) != 0;\n+     *           }}<\/pre>\n@@ -398,19 +401,18 @@\n-     * <p>The method {@code nextFloat} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n-     * public float nextFloat() {\n-     *   return next(24) \/ ((float)(1 << 24));\n-     * }}<\/pre>\n-     *\n-     * <p>The hedge \"approximately\" is used in the foregoing description only\n-     * because the next method is only approximately an unbiased source of\n-     * independently chosen bits. If it were a perfect source of randomly\n-     * chosen bits, then the algorithm shown would choose {@code float}\n-     * values from the stated range with perfect uniformity.<p>\n-     * [In early versions of Java, the result was incorrectly calculated as:\n-     *  <pre> {@code\n-     *   return next(30) \/ ((float)(1 << 30));}<\/pre>\n-     * This might seem to be equivalent, if not better, but in fact it\n-     * introduced a slight nonuniformity because of the bias in the rounding\n-     * of floating-point numbers: it was slightly more likely that the\n-     * low-order bit of the significand would be 0 than that it would be 1.]\n+     * @implNote <p>The method {@code nextFloat} is implemented by class\n+     *           {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public float nextFloat() {\n+     *             return next(24) \/ ((float)(1 << 24));\n+     *           }}<\/pre>\n+     *\n+     *           <p>The hedge \"approximately\" is used in the foregoing description only\n+     *           because the next method is only approximately an unbiased source of\n+     *           independently chosen bits. If it were a perfect source of randomly\n+     *           chosen bits, then the algorithm shown would choose {@code float}\n+     *           values from the stated range with perfect uniformity.<p>\n+     *           [In early versions of Java, the result was incorrectly calculated as:\n+     *            <pre> {@code return next(30) \/ ((float)(1 << 30));}<\/pre>\n+     *           This might seem to be equivalent, if not better, but in fact it\n+     *           introduced a slight nonuniformity because of the bias in the rounding\n+     *           of floating-point numbers: it was slightly more likely that the\n+     *           low-order bit of the significand would be 0 than that it would be 1.]\n@@ -437,23 +439,20 @@\n-     * <p>The method {@code nextDouble} is implemented by class {@code Random}\n-     * as if by:\n-     *  <pre> {@code\n-     * public double nextDouble() {\n-     *   return (((long)next(26) << 27) + next(27))\n-     *     \/ (double)(1L << 53);\n-     * }}<\/pre>\n-     *\n-     * <p>The hedge \"approximately\" is used in the foregoing description only\n-     * because the {@code next} method is only approximately an unbiased\n-     * source of independently chosen bits. If it were a perfect source of\n-     * randomly chosen bits, then the algorithm shown would choose\n-     * {@code double} values from the stated range with perfect uniformity.\n-     * <p>[In early versions of Java, the result was incorrectly calculated as:\n-     *  <pre> {@code\n-     *   return (((long)next(27) << 27) + next(27))\n-     *     \/ (double)(1L << 54);}<\/pre>\n-     * This might seem to be equivalent, if not better, but in fact it\n-     * introduced a large nonuniformity because of the bias in the rounding\n-     * of floating-point numbers: it was three times as likely that the\n-     * low-order bit of the significand would be 0 than that it would be 1!\n-     * This nonuniformity probably doesn't matter much in practice, but we\n-     * strive for perfection.]\n+     * @implNote <p>The method {@code nextDouble} is implemented by class\n+     *           {@code Random} as if by:\n+     *           <pre>{@code\n+     *           public double nextDouble() {\n+     *             return (((long)next(26) << 27) + next(27))\n+     *               \/ (double)(1L << 53);\n+     *           }}<\/pre>\n+     *           <p>The hedge \"approximately\" is used in the foregoing description only\n+     *           because the {@code next} method is only approximately an unbiased source\n+     *           of independently chosen bits. If it were a perfect source of randomly\n+     *           chosen bits, then the algorithm shown would choose {@code double} values\n+     *           from the stated range with perfect uniformity.\n+     *           <p>[In early versions of Java, the result was incorrectly calculated as:\n+     *           <pre> {@code return (((long)next(27) << 27) + next(27)) \/ (double)(1L << 54);}<\/pre>\n+     *           This might seem to be equivalent, if not better, but in fact it\n+     *           introduced a large nonuniformity because of the bias in the rounding of\n+     *           floating-point numbers: it was three times as likely that the low-order\n+     *           bit of the significand would be 0 than that it would be 1! This\n+     *           nonuniformity probably doesn't matter much in practice, but we strive\n+     *           for perfection.]\n@@ -484,29 +483,30 @@\n-     * <p>The method {@code nextGaussian} is implemented by class\n-     * {@code Random} as if by a threadsafe version of the following:\n-     *  <pre> {@code\n-     * private double nextNextGaussian;\n-     * private boolean haveNextNextGaussian = false;\n-     *\n-     * public double nextGaussian() {\n-     *   if (haveNextNextGaussian) {\n-     *     haveNextNextGaussian = false;\n-     *     return nextNextGaussian;\n-     *   } else {\n-     *     double v1, v2, s;\n-     *     do {\n-     *       v1 = 2 * nextDouble() - 1;   \/\/ between -1.0 and 1.0\n-     *       v2 = 2 * nextDouble() - 1;   \/\/ between -1.0 and 1.0\n-     *       s = v1 * v1 + v2 * v2;\n-     *     } while (s >= 1 || s == 0);\n-     *     double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)\/s);\n-     *     nextNextGaussian = v2 * multiplier;\n-     *     haveNextNextGaussian = true;\n-     *     return v1 * multiplier;\n-     *   }\n-     * }}<\/pre>\n-     * This uses the <i>polar method<\/i> of G. E. P. Box, M. E. Muller, and\n-     * G. Marsaglia, as described by Donald E. Knuth in <cite>The Art of\n-     * Computer Programming, Volume 2, third edition: Seminumerical Algorithms<\/cite>,\n-     * section 3.4.1, subsection C, algorithm P. Note that it generates two\n-     * independent values at the cost of only one call to {@code StrictMath.log}\n-     * and one call to {@code StrictMath.sqrt}.\n+     * @implNote <p>The method {@code nextGaussian} is implemented by class\n+     *           {@code Random} as if by a threadsafe version of the following:\n+     *           <pre>{@code\n+     *           private double nextNextGaussian;\n+     *           private boolean haveNextNextGaussian = false;\n+     *\n+     *           public double nextGaussian() {\n+     *             if (haveNextNextGaussian) {\n+     *               haveNextNextGaussian = false;\n+     *               return nextNextGaussian;\n+     *             } else {\n+     *               double v1, v2, s;\n+     *               do {\n+     *                 v1 = 2 * nextDouble() - 1;   \/\/ between -1.0 and 1.0\n+     *                 v2 = 2 * nextDouble() - 1;   \/\/ between -1.0 and 1.0\n+     *                 s = v1 * v1 + v2 * v2;\n+     *               } while (s >= 1 || s == 0);\n+     *               double multiplier = StrictMath.sqrt(-2 * StrictMath.log(s)\/s);\n+     *               nextNextGaussian = v2 * multiplier;\n+     *               haveNextNextGaussian = true;\n+     *               return v1 * multiplier;\n+     *             }\n+     *           }}<\/pre>\n+     *\n+     *           This uses the <i>polar method<\/i> of G. E. P. Box, M. E. Muller, and G.\n+     *           Marsaglia, as described by Donald E. Knuth in <cite>The Art of Computer\n+     *           Programming, Volume 2, third edition: Seminumerical Algorithms<\/cite>,\n+     *           section 3.4.1, subsection C, algorithm P. Note that it generates two\n+     *           independent values at the cost of only one call to {@code\n+     *           StrictMath.log} and one call to {@code StrictMath.sqrt}.\n@@ -640,1 +640,0 @@\n-     * @implNote  {@inheritDoc}\n@@ -643,0 +642,1 @@\n+     * @implNote  {@inheritDoc}\n","filename":"src\/java.base\/share\/classes\/java\/util\/Random.java","additions":120,"deletions":120,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -287,0 +287,15 @@\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @throws NullPointerException {@inheritDoc}\n+     *\n+     * implNote {@inheritDoc}\n+     *\n+     * @since 10\n+     *\/\n+    @Override\n+    public  void nextBytes(byte[] bytes) {\n+        super.nextBytes(bytes);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/SplittableRandom.java","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -448,2 +448,0 @@\n-     *\n-     * @since 1.7\n@@ -458,2 +456,0 @@\n-     *\n-     * @since 1.7\n@@ -469,1 +465,0 @@\n-     * @since 1.7\n@@ -481,1 +476,0 @@\n-     * @since 1.7\n@@ -492,2 +486,0 @@\n-     *\n-     * @since 1.7\n@@ -502,2 +494,0 @@\n-     *\n-     * @since 1.7\n@@ -514,2 +504,0 @@\n-     *\n-     * @since 1.7\n@@ -527,2 +515,0 @@\n-     *\n-     * @since 1.7\n@@ -537,2 +523,0 @@\n-     *\n-     * @since 1.7\n@@ -549,2 +533,0 @@\n-     *\n-     * @since 1.7\n@@ -561,2 +543,0 @@\n-     *\n-     * @since 1.7\n@@ -571,2 +551,0 @@\n-     *\n-     * @since 1.7\n@@ -583,2 +561,0 @@\n-     *\n-     * @since 1.7\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ThreadLocalRandom.java","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -119,0 +119,2 @@\n+     *\n+     * @since 17\n@@ -135,0 +137,2 @@\n+     *\n+     * @since 17\n@@ -151,0 +155,2 @@\n+     *\n+     * @since 17\n@@ -176,0 +182,2 @@\n+     *\n+     * @since 17\n@@ -196,0 +204,2 @@\n+     *\n+     * @since 17\n@@ -223,0 +233,2 @@\n+     *\n+     * @since 17\n@@ -243,0 +255,2 @@\n+     *\n+     * @since 17\n@@ -267,0 +281,2 @@\n+     *\n+     * @since 17\n@@ -287,0 +303,2 @@\n+     *\n+     * @since 17\n@@ -312,0 +330,2 @@\n+     *\n+     * @since 17\n@@ -332,0 +352,2 @@\n+     *\n+     * @since 17\n@@ -356,0 +378,2 @@\n+     *\n+     * @since 17\n@@ -376,0 +400,2 @@\n+     *\n+     * @since 17\n@@ -401,0 +427,2 @@\n+     *\n+     * @since 17\n@@ -420,0 +448,2 @@\n+     *\n+     * @since 17\n@@ -429,13 +459,15 @@\n-     * <pre>{@code\n-     * default void nextBytes(byte[] bytes) {\n-     *     int i = 0;\n-     *     int len = bytes.length;\n-     *     for (int words = len >> 3; words--> 0; ) {\n-     *         long rnd = nextLong();\n-     *         for (int n = 8; n--> 0; rnd >>>= Byte.SIZE)\n-     *             bytes[i++] = (byte)rnd;\n-     *     }\n-     *     if (i < len)\n-     *         for (long rnd = nextLong(); i < len; rnd >>>= Byte.SIZE)\n-     *             bytes[i++] = (byte)rnd;\n-     * }}<\/pre>\n+     *\n+     * @implNote Algorithm used to fill the byte array;\n+     *           <pre>{@code\n+     *           void nextBytes(byte[] bytes) {\n+     *               int i = 0;\n+     *               int len = bytes.length;\n+     *               for (int words = len >> 3; words--> 0; ) {\n+     *                   long rnd = nextLong();\n+     *                   for (int n = 8; n--> 0; rnd >>>= Byte.SIZE)\n+     *                       bytes[i++] = (byte)rnd;\n+     *               }\n+     *               if (i < len)\n+     *                   for (long rnd = nextLong(); i < len; rnd >>>= Byte.SIZE)\n+     *                       bytes[i++] = (byte)rnd;\n+     *           }}<\/pre>\n@@ -445,0 +477,2 @@\n+     *\n+     * @since 17\n@@ -467,0 +501,2 @@\n+     *\n+     * @since 17\n@@ -488,0 +524,2 @@\n+     *\n+     * @since 17\n@@ -512,0 +550,2 @@\n+     *\n+     * @since 17\n@@ -528,0 +568,2 @@\n+     *\n+     * @since 17\n@@ -549,0 +591,2 @@\n+     *\n+     * @since 17\n@@ -573,0 +617,2 @@\n+     *\n+     * @since 17\n@@ -587,0 +633,2 @@\n+     *\n+     * @since 17\n@@ -606,0 +654,2 @@\n+     *\n+     * @since 17\n@@ -629,0 +679,2 @@\n+     *\n+     * @since 17\n@@ -657,0 +709,2 @@\n+     *\n+     * @since 17\n@@ -681,0 +735,1 @@\n+     * @since 17\n@@ -694,0 +749,2 @@\n+     *\n+     * @since 17\n@@ -712,0 +769,2 @@\n+     *\n+     * @since 17\n@@ -725,0 +784,2 @@\n+     *\n+     * @since 17\n@@ -772,0 +833,2 @@\n+         *\n+         * @since 17\n@@ -791,0 +854,2 @@\n+         *\n+         * @since 17\n@@ -810,0 +875,2 @@\n+         *\n+         * @since 17\n@@ -862,0 +929,2 @@\n+         *\n+         * @since 17\n@@ -879,0 +948,2 @@\n+         *\n+         * @since 17\n@@ -893,0 +964,2 @@\n+         *\n+         * @since 17\n@@ -909,0 +982,2 @@\n+         *\n+         * @since 17\n@@ -928,0 +1003,2 @@\n+         *\n+         * @since 17\n@@ -945,0 +1022,2 @@\n+         *\n+         * @since 17\n@@ -962,0 +1041,2 @@\n+         *\n+         * @since 17\n@@ -974,0 +1055,2 @@\n+         *\n+         * @since 17\n@@ -993,0 +1076,2 @@\n+         *\n+         * @since 17\n@@ -1002,2 +1087,2 @@\n-     * furthermore can easily <i>jump<\/i> forward (by a fixed amount) to a\n-     * distant point in the state cycle.\n+     * furthermore can easily <i>jump<\/i> forward, by a moderate amount (ex.\n+     * 2<sup>64<\/sup>) to a distant point in the state cycle.\n@@ -1053,0 +1138,2 @@\n+         *\n+         * @since 17\n@@ -1066,0 +1153,2 @@\n+         *\n+         * @since 17\n@@ -1073,0 +1162,2 @@\n+         *\n+         * @since 17\n@@ -1082,0 +1173,2 @@\n+         *\n+         * @since 17\n@@ -1098,0 +1191,2 @@\n+         *\n+         * @since 17\n@@ -1117,0 +1212,2 @@\n+         *\n+         * @since 17\n@@ -1131,0 +1228,2 @@\n+         *\n+         * @since 17\n@@ -1149,0 +1248,2 @@\n+         *\n+         * @since 17\n@@ -1159,0 +1260,2 @@\n+         *\n+         * @since 17\n@@ -1173,1 +1276,2 @@\n-     * <i>leap<\/i> to a very distant point in the state cycle.\n+     * <i>leap<\/i> forward, by a large amount (ex. 2<sup>128<\/sup>), to a\n+     * very distant point in the state cycle.\n@@ -1225,0 +1329,2 @@\n+         *\n+         * @since 17\n@@ -1238,0 +1344,2 @@\n+         *\n+         * @since 17\n@@ -1245,0 +1353,2 @@\n+         *\n+         * @since 17\n@@ -1254,0 +1364,2 @@\n+         *\n+         * @since 17\n@@ -1270,0 +1382,2 @@\n+         *\n+         * @since 17\n@@ -1289,0 +1403,2 @@\n+         *\n+         * @since 17\n@@ -1299,0 +1415,2 @@\n+         *\n+         * @since 17\n@@ -1311,2 +1429,2 @@\n-     * furthermore can easily <i>jump<\/i> to an arbitrarily specified distant\n-     * point in the state cycle.\n+     * furthermore can easily <i>jump<\/i> forward, by an arbitrary amount, to a\n+     * distant point in the state cycle.\n@@ -1363,0 +1481,2 @@\n+         *\n+         * @since 17\n@@ -1376,0 +1496,2 @@\n+         *\n+         * @since 17\n@@ -1390,0 +1512,2 @@\n+         *\n+         * @since 17\n@@ -1402,0 +1526,2 @@\n+         *\n+         * @since 17\n@@ -1410,0 +1536,2 @@\n+         *\n+         * @since 17\n@@ -1431,0 +1559,2 @@\n+         *\n+         * @since 17\n@@ -1452,0 +1582,2 @@\n+         *\n+         * @since 17\n@@ -1463,0 +1595,2 @@\n+         *\n+         * @since 17\n@@ -1477,0 +1611,2 @@\n+         *\n+         * @since 17\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGenerator.java","additions":154,"deletions":18,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.lang.reflect.Method;\n@@ -55,1 +54,1 @@\n- * {@link RandomGenerator#factoryOf(String)} method, where the argument string\n+ * {@link RandomGeneratorFactory#factoryOf(String)} method, where the argument string\n@@ -108,5 +107,0 @@\n-    \/**\n-     * Map of provider classes.\n-     *\/\n-    private static volatile Map<String, Provider<? extends RandomGenerator>> factoryMap;\n-\n@@ -231,2 +225,10 @@\n-        if (!isSubclass(category, provider)) {\n-            throw new IllegalArgumentException(name + \" is an unknown random number generator\");\n+        if (provider == null) {\n+            throw new IllegalArgumentException(\"No implementation of the random number generator algorithm \\\"\" +\n+                                                name +\n+                                                \"\\\" is available\");\n+        } else if (!isSubclass(category, provider)) {\n+            throw new IllegalArgumentException(\"The random number generator algorithm \\\"\" +\n+                                                name +\n+                                                \"\\\" is not implemented with the interface \\\"\" +\n+                                                category.getSimpleName() +\n+                                                \"\\\"\");\n@@ -258,1 +260,1 @@\n-     * of {@link RandomGenerator} that utilizes the {@code name} algorithm.\n+     * of {@link RandomGenerator} that utilizes the named algorithm.\n@@ -600,1 +602,1 @@\n-            return ctorBytes.newInstance((Object)seed);\n+            return ctorBytes.newInstance(seed);\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/RandomGeneratorFactory.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -131,3 +131,19 @@\n- * If an application requires a random number generator algorithm that is\n- * cryptographically secure, then it should use an instance of the class\n- * {@link java.security.SecureRandom}.\n+ * <p> There are three groups of random number generator algorithm provided\n+ * in Java; Legacy group, LXM group and Xoroshiro\/Xoshiro group.\n+ *\n+ * <p> The legacy group includes random number generators that existed\n+ * before JDK 17; Random, ThreadLocalRandom, SplittableRandom and\n+ * SecureRandom. Random (LCG) is the weakest of available algorithms and it\n+ * is recommended that users migrate to newer algorithms. If an application\n+ * requires a random number generator algorithm that is cryptographically\n+ * secure, then it should continue to use an instance of the class {@link\n+ * java.security.SecureRandom}.\n+ *\n+ * <p> The algorithms in the LXM group use a similar algorithm. The parameters\n+ * of the algorithm can be found in algorithm name. The numbers indicate the\n+ * number of bits in the lower and upper state bits respectively. Mix indicates\n+ * the algorithm uses mix congruency. StarStar indicates use a double\n+ * multiplier.\n+ *\n+ * <p> The algorithms in the Xoroshiro\/Xoshiro are more traditional algorithms\n+ * where the number in the name indicates the period.\n","filename":"src\/java.base\/share\/classes\/java\/util\/random\/package-info.java","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -1545,16 +1545,17 @@\n-         * <p>The (pseudo)random {@code int} values are generated as if the result of\n-         * calling the following method with the origin and bound:\n-         * <pre> {@code\n-         * int nextInt(int origin, int bound) {\n-         *   int n = bound - origin;\n-         *   if (n > 0) {\n-         *     return nextInt(n) + origin;\n-         *   }\n-         *   else {  \/\/ range not representable as int\n-         *     int r;\n-         *     do {\n-         *       r = nextInt();\n-         *     } while (r < origin || r >= bound);\n-         *     return r;\n-         *   }\n-         * }}<\/pre>\n+         * @implNote <p>The (pseudo)random {@code int} values are generated as\n+         *           if the result of calling the following method with the\n+         *           origin and bound:\n+         *           <pre>{@code\n+         *           int nextInt(int origin, int bound) {\n+         *             int n = bound - origin;\n+         *             if (n > 0) {\n+         *               return nextInt(n) + origin;\n+         *             }\n+         *             else {  \/\/ range not representable as int\n+         *               int r;\n+         *               do {\n+         *                 r = nextInt();\n+         *               } while (r < origin || r >= bound);\n+         *               return r;\n+         *             }\n+         *           }}<\/pre>\n@@ -1585,19 +1586,2 @@\n-         * <p>The (pseudo)random {@code int} values are generated as if the result of\n-         * calling the following method with the origin and bound:\n-         * <pre> {@code\n-         * int nextInt(int origin, int bound) {\n-         *   int n = bound - origin;\n-         *   if (n > 0) {\n-         *     return nextInt(n) + origin;\n-         *   }\n-         *   else {  \/\/ range not representable as int\n-         *     int r;\n-         *     do {\n-         *       r = nextInt();\n-         *     } while (r < origin || r >= bound);\n-         *     return r;\n-         *   }\n-         * }}<\/pre>\n-         *\n-         * @implNote This method is implemented to be equivalent to {@code\n-         * ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+         * @implNote <p>TThis method is implemented to be equivalent to {@code\n+         *           ints(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n@@ -1663,21 +1647,22 @@\n-         * <p>The (pseudo)random {@code long} values are generated as if the result\n-         * of calling the following method with the origin and bound:\n-         * <pre> {@code\n-         * long nextLong(long origin, long bound) {\n-         *   long r = nextLong();\n-         *   long n = bound - origin, m = n - 1;\n-         *   if ((n & m) == 0L)  \/\/ power of two\n-         *     r = (r & m) + origin;\n-         *   else if (n > 0L) {  \/\/ reject over-represented candidates\n-         *     for (long u = r >>> 1;            \/\/ ensure nonnegative\n-         *          u + m - (r = u % n) < 0L;    \/\/ rejection check\n-         *          u = nextLong() >>> 1) \/\/ retry\n-         *         ;\n-         *     r += origin;\n-         *   }\n-         *   else {              \/\/ range not representable as long\n-         *     while (r < origin || r >= bound)\n-         *       r = nextLong();\n-         *   }\n-         *   return r;\n-         * }}<\/pre>\n+         * @implNote <p>The (pseudo)random {@code long} values are generated as\n+         *           if the result of calling the following method with the\n+         *           origin and bound:\n+         *           <pre>{@code\n+         *           long nextLong(long origin, long bound) {\n+         *             long r = nextLong();\n+         *             long n = bound - origin, m = n - 1;\n+         *             if ((n & m) == 0L)  \/\/ power of two\n+         *               r = (r & m) + origin;\n+         *             else if (n > 0L) {  \/\/ reject over-represented candidates\n+         *               for (long u = r >>> 1;            \/\/ ensure nonnegative\n+         *                    u + m - (r = u % n) < 0L;    \/\/ rejection check\n+         *                    u = nextLong() >>> 1) \/\/ retry\n+         *                   ;\n+         *               r += origin;\n+         *             }\n+         *             else {              \/\/ range not representable as long\n+         *               while (r < origin || r >= bound)\n+         *                 r = nextLong();\n+         *             }\n+         *             return r;\n+         *           }}<\/pre>\n@@ -1710,22 +1695,0 @@\n-         * <p>The (pseudo)random {@code long} values are generated as if the result\n-         * of calling the following method with the origin and bound:\n-         * <pre> {@code\n-         * long nextLong(long origin, long bound) {\n-         *   long r = nextLong();\n-         *   long n = bound - origin, m = n - 1;\n-         *   if ((n & m) == 0L)  \/\/ power of two\n-         *     r = (r & m) + origin;\n-         *   else if (n > 0L) {  \/\/ reject over-represented candidates\n-         *     for (long u = r >>> 1;            \/\/ ensure nonnegative\n-         *          u + m - (r = u % n) < 0L;    \/\/ rejection check\n-         *          u = nextLong() >>> 1) \/\/ retry\n-         *         ;\n-         *     r += origin;\n-         *   }\n-         *   else {              \/\/ range not representable as long\n-         *     while (r < origin || r >= bound)\n-         *       r = nextLong();\n-         *   }\n-         *   return r;\n-         * }}<\/pre>\n-         *\n@@ -1733,1 +1696,1 @@\n-         * longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+         *           longs(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n@@ -1797,10 +1760,11 @@\n-         * <p>The (pseudo)random {@code double} values are generated as if the result\n-         * of calling the following method with the origin and bound:\n-         * <pre> {@code\n-         * double nextDouble(double origin, double bound) {\n-         *   double r = nextDouble();\n-         *   r = r * (bound - origin) + origin;\n-         *   if (r >= bound) \/\/ correct for rounding\n-         *     r = Math.nextDown(bound);\n-         *   return r;\n-         * }}<\/pre>\n+         * @implNote <p>The (pseudo)random {@code double} values are generated\n+         *           as if the result of calling the following method with the\n+         *           origin and bound:\n+         *           <pre>{@code\n+         *           double nextDouble(double origin, double bound) {\n+         *             double r = nextDouble();\n+         *             r = r * (bound - origin) + origin;\n+         *             if (r >= bound) \/\/ correct for rounding\n+         *               r = Math.nextDown(bound);\n+         *             return r;\n+         *           }}<\/pre>\n@@ -1832,11 +1796,0 @@\n-         * <p>The (pseudo)random {@code double} values are generated as if the result\n-         * of calling the following method with the origin and bound:\n-         * <pre> {@code\n-         * double nextDouble(double origin, double bound) {\n-         *   double r = nextDouble();\n-         *   r = r * (bound - origin) + origin;\n-         *   if (r >= bound) \/\/ correct for rounding\n-         *     r = Math.nextDown(bound);\n-         *   return r;\n-         * }}<\/pre>\n-         *\n@@ -1844,1 +1797,1 @@\n-         * doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n+         *           doubles(Long.MAX_VALUE, randomNumberOrigin, randomNumberBound)}.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/random\/RandomSupport.java","additions":54,"deletions":101,"binary":false,"changes":155,"status":"modified"}]}