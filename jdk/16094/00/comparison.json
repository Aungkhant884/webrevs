{"files":[{"patch":"@@ -51,0 +51,4 @@\n+    \/**\n+     * @param bitIndex the bit index to test\n+     * @return true if the bit is in the range of the BitSet and the bit is set, otherwise false\n+     *\/\n@@ -53,2 +57,3 @@\n-        if (bitIndex < 0)\n-            throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n+        if (bitIndex < 0) {\n+            return false;\n+        }\n@@ -56,1 +61,1 @@\n-        int wordIndex = wordIndex(bitIndex);\n+        int wordIndex = bitIndex >> 6;\n@@ -61,7 +66,0 @@\n-    \/**\n-     * Given a bit index, return word index containing it.\n-     *\/\n-    private static int wordIndex(int bitIndex) {\n-        return bitIndex >> 6;\n-    }\n-\n@@ -82,0 +80,6 @@\n+        if (original.size() <= 128) {\n+            long[] array = original.toLongArray();\n+            return new SmallImmutableBitSetPredicate(\n+                    array.length > 0 ? array[0] : 0L,\n+                    array.length > 1 ? array[1] : 0L);\n+        }\n@@ -85,0 +89,25 @@\n+    \/**\n+     * Specialization for small sets of 128 bits or less\n+     * @param first - bits index 0 through 63, inclusive\n+     * @param second - bits index 64 through 127, inclusive\n+     *\/\n+    public record SmallImmutableBitSetPredicate(long first, long second) implements IntPredicate {\n+\n+        \/**\n+         * @param bitIndex the bit index to test\n+         * @return true if the bit is in the range of the BitSet and the bit is set, otherwise false\n+         *\/\n+        @Override\n+        public boolean test(int bitIndex) {\n+            if (bitIndex < 0) {\n+                return false;\n+            }\n+\n+            int wordIndex = bitIndex >> 6;\n+            if (wordIndex > 1) {\n+                return false;\n+            }\n+            long bits = wordIndex == 0 ? first : second;\n+            return (bits & (1L << bitIndex)) != 0;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ImmutableBitSetPredicate.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.util.stream.IntStream;\n@@ -53,3 +54,7 @@\n-        assertThrows(IndexOutOfBoundsException.class, () -> {\n-            ibs.test(-1);\n-        });\n+        assertFalse(ibs.test(-1));\n+        assertFalse(ibs.test(Integer.MIN_VALUE));\n+\n+        bs = new BitSet(1024);\n+        ibs = ImmutableBitSetPredicate.of(bs);\n+        assertFalse(ibs.test(-1));\n+        assertFalse(ibs.test(Integer.MIN_VALUE));\n@@ -60,1 +65,5 @@\n-        BitSet bs = createReference(147);\n+        IntStream.of(0, 16, 143, 4711).forEach(k -> basic(k));\n+    }\n+\n+    void basic(int length) {\n+        BitSet bs = createReference(length);\n@@ -67,4 +76,8 @@\n-        for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n-            BitSet bs = createReference(i);\n-            for (int j = bs.length() - 1; j > Long.BYTES - 1; j++) {\n-                bs.clear(j);\n+        IntStream.of(0, 143, 4711).forEach(k -> {\n+            for (int i = Long.BYTES - 1; i < Long.BYTES + 2; i++) {\n+                BitSet bs = createReference(k + i);\n+                for (int j = bs.length() - 1; j > Long.BYTES - 1; j++) {\n+                    bs.clear(j);\n+                }\n+                IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n+                test(bs, ibs);\n@@ -72,3 +85,1 @@\n-            IntPredicate ibs = ImmutableBitSetPredicate.of(bs);\n-            test(bs, ibs);\n-        }\n+        });\n","filename":"test\/jdk\/java\/util\/BitSet\/ImmutableBitSet.java","additions":22,"deletions":11,"binary":false,"changes":33,"status":"modified"}]}