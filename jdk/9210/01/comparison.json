{"files":[{"patch":"@@ -880,0 +880,26 @@\n+            } else {\n+                String CDATA = \"[CDATA[\";  \/\/ full prefix is <![CDATA[\n+                for (int i = 0; i < CDATA.length(); i++) {\n+                    if (ch == CDATA.charAt(i)) {\n+                        nextChar();\n+                    } else {\n+                        return erroneous(\"dc.invalid.html\", p);\n+                    }\n+                }\n+                \/\/ suffix is ]]>\n+                while (bp < buflen) {\n+                    if (ch == ']') {\n+                        int n = 0;\n+                        while (bp < buflen && ch == ']') {\n+                            n++;\n+                            nextChar();\n+                        }\n+                        if (n >= 2 && ch == '>') {\n+                            nextChar();\n+                            return m.at(p).newTextTree(newString(p, bp));\n+                        }\n+                    } else {\n+                        nextChar();\n+                    }\n+                }\n+                return erroneous(\"dc.invalid.html\", p);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/DocCommentParser.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -3342,0 +3342,3 @@\n+compiler.err.dc.invalid.html=\\\n+    invalid HTML\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-            var title = new RawHtml(doctitle);\n+            var title = RawHtml.of(doctitle);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractOverviewIndexWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -503,1 +503,1 @@\n-                .add(new RawHtml(replaceDocRootDir(options.top())))\n+                .add(RawHtml.of(replaceDocRootDir(options.top())))\n@@ -518,1 +518,1 @@\n-                .setUserHeader(new RawHtml(replaceDocRootDir(options.header())));\n+                .setUserHeader(RawHtml.of(replaceDocRootDir(options.header())));\n@@ -535,1 +535,1 @@\n-                                    new RawHtml(replaceDocRootDir(bottom)))));\n+                                    RawHtml.of(replaceDocRootDir(bottom)))));\n@@ -1007,1 +1007,1 @@\n-                        return new RawHtml(replaceDocRootDir(removeTrailingSlash(seeText)));\n+                        return RawHtml.of(replaceDocRootDir(removeTrailingSlash(seeText)));\n@@ -1487,1 +1487,0 @@\n-        \/\/ Array of all possible inline tags for this javadoc run\n@@ -1514,1 +1513,1 @@\n-            boolean allDone = new SimpleDocTreeVisitor<Boolean, Content>() {\n+            var docTreeVisitor = new SimpleDocTreeVisitor<Boolean, Content>() {\n@@ -1517,9 +1516,5 @@\n-                    if (utils.isStartElement(tag)) {\n-                        StartElementTree st = (StartElementTree)tag;\n-                        Name name = st.getName();\n-                        if (name != null) {\n-                            HtmlTag htag = HtmlTag.get(name);\n-                            return htag != null && htag.equals(HtmlTag.A);\n-                        }\n-                    }\n-                    return false;\n+                    return (tag instanceof StartElementTree st) && equalsIgnoreCase(st.getName(), \"a\");\n+                }\n+\n+                private boolean equalsIgnoreCase(Name name, String s) {\n+                    return name != null && name.toString().equalsIgnoreCase(s);\n@@ -1529,2 +1524,5 @@\n-                public Boolean visitAttribute(AttributeTree node, Content c) {\n-                    StringBuilder sb = new StringBuilder(SPACER).append(node.getName().toString());\n+                public Boolean visitAttribute(AttributeTree node, Content content) {\n+                    if (!content.isEmpty()) {\n+                        content.add(\" \");\n+                    }\n+                    content.add(node.getName());\n@@ -1532,1 +1530,0 @@\n-                        result.add(sb);\n@@ -1535,1 +1532,1 @@\n-                    sb.append(\"=\");\n+                    content.add(\"=\");\n@@ -1541,5 +1538,14 @@\n-                    sb.append(quote);\n-                    result.add(sb);\n-                    Content docRootContent = new ContentBuilder();\n-\n-                    boolean isHRef = inAnAtag() && node.getName().toString().equalsIgnoreCase(\"href\");\n+                    content.add(quote);\n+\n+                    \/* In the following code for an attribute value:\n+                     * 1. {@docRoot} followed by text beginning \"\/..\" is replaced by the value\n+                     *    of the docrootParent option, followed by the remainder of the text\n+                     * 2. in the value of an \"href\" attribute in a <a> tag, an initial text\n+                     *    value will have a relative link redirected.\n+                     * Note that, realistically, it only makes sense to ever use {@docRoot}\n+                     * at the beginning of a URL in an attribute value, but this is not\n+                     * required or enforced.\n+                     *\/\n+                    boolean isHRef = inAnAtag() && equalsIgnoreCase(node.getName(), \"href\");\n+                    boolean first = true;\n+                    DocRootTree pendingDocRoot = null;\n@@ -1547,11 +1553,9 @@\n-                        if (utils.isText(dt) && isHRef) {\n-                            String text = ((TextTree) dt).getBody();\n-                            if (text.startsWith(\"\/..\") && !options.docrootParent().isEmpty()) {\n-                                result.add(options.docrootParent());\n-                                docRootContent = new ContentBuilder();\n-                                result.add(textCleanup(text.substring(3), isLastNode));\n-                            } else {\n-                                if (!docRootContent.isEmpty()) {\n-                                    docRootContent = copyDocRootContent(docRootContent);\n-                                } else {\n-                                    text = redirectRelativeLinks(element, (TextTree) dt);\n+                        if (pendingDocRoot != null) {\n+                            if (dt instanceof TextTree tt) {\n+                                String text = tt.getBody();\n+                                if (text.startsWith(\"\/..\") && !options.docrootParent().isEmpty()) {\n+                                    content.add(options.docrootParent());\n+                                    content.add(textCleanup(text.substring(3), isLastNode));\n+                                    pendingDocRoot = null;\n+                                    first = false;\n+                                    continue;\n@@ -1559,1 +1563,0 @@\n-                                result.add(textCleanup(text, isLastNode));\n@@ -1561,0 +1564,14 @@\n+                            pendingDocRoot.accept(this, content);\n+                            pendingDocRoot = null;\n+                            first = false;\n+                        }\n+\n+                        if (dt instanceof TextTree tt){\n+                            String text = tt.getBody();\n+                            if (first && isHRef) {\n+                                text = redirectRelativeLinks(element, (TextTree) dt);\n+                            }\n+                            content.add(textCleanup(text, isLastNode));\n+                        } else if (dt instanceof DocRootTree drt) {\n+                            \/\/ defer until we see what, if anything, follows this node\n+                            pendingDocRoot = drt;\n@@ -1562,2 +1579,1 @@\n-                            docRootContent = copyDocRootContent(docRootContent);\n-                            dt.accept(this, docRootContent);\n+                            dt.accept(this, content);\n@@ -1565,0 +1581,4 @@\n+                        first = false;\n+                    }\n+                    if (pendingDocRoot != null) {\n+                        pendingDocRoot.accept(this, content);\n@@ -1566,2 +1586,2 @@\n-                    copyDocRootContent(docRootContent);\n-                    result.add(quote);\n+\n+                    content.add(quote);\n@@ -1572,2 +1592,2 @@\n-                public Boolean visitComment(CommentTree node, Content c) {\n-                    result.add(new RawHtml(node.getBody()));\n+                public Boolean visitComment(CommentTree node, Content content) {\n+                    content.add(RawHtml.comment(node.getBody()));\n@@ -1577,8 +1597,0 @@\n-                private Content copyDocRootContent(Content content) {\n-                    if (!content.isEmpty()) {\n-                        result.add(content);\n-                        return new ContentBuilder();\n-                    }\n-                    return content;\n-                }\n-\n@@ -1586,7 +1598,2 @@\n-                public Boolean visitDocRoot(DocRootTree node, Content c) {\n-                    Content docRootContent = getInlineTagOutput(element, node, context);\n-                    if (c != null) {\n-                        c.add(docRootContent);\n-                    } else {\n-                        result.add(docRootContent);\n-                    }\n+                public Boolean visitDocRoot(DocRootTree node, Content content) {\n+                    content.add(getInlineTagOutput(element, node, context));\n@@ -1597,3 +1604,2 @@\n-                public Boolean visitEndElement(EndElementTree node, Content c) {\n-                    RawHtml rawHtml = new RawHtml(\"<\/\" + node.getName() + \">\");\n-                    result.add(rawHtml);\n+                public Boolean visitEndElement(EndElementTree node, Content content) {\n+                    content.add(RawHtml.endElement(node.getName()));\n@@ -1604,2 +1610,2 @@\n-                public Boolean visitEntity(EntityTree node, Content c) {\n-                    result.add(new RawHtml(node.toString()));\n+                public Boolean visitEntity(EntityTree node, Content content) {\n+                    content.add(Entity.of(node.getName()));\n@@ -1610,1 +1616,1 @@\n-                public Boolean visitErroneous(ErroneousTree node, Content c) {\n+                public Boolean visitErroneous(ErroneousTree node, Content content) {\n@@ -1620,1 +1626,1 @@\n-                            result.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", body),\n+                            content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid_input\", body),\n@@ -1624,1 +1630,1 @@\n-                            result.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n+                            content.add(invalidTagOutput(resources.getText(\"doclet.tag.invalid\", tagName),\n@@ -1632,1 +1638,1 @@\n-                public Boolean visitInheritDoc(InheritDocTree node, Content c) {\n+                public Boolean visitInheritDoc(InheritDocTree node, Content content) {\n@@ -1634,1 +1640,1 @@\n-                    result.add(output);\n+                    content.add(output);\n@@ -1640,1 +1646,1 @@\n-                public Boolean visitIndex(IndexTree node, Content p) {\n+                public Boolean visitIndex(IndexTree node, Content content) {\n@@ -1643,1 +1649,1 @@\n-                        result.add(output);\n+                        content.add(output);\n@@ -1649,1 +1655,1 @@\n-                public Boolean visitLink(LinkTree node, Content c) {\n+                public Boolean visitLink(LinkTree node, Content content) {\n@@ -1660,1 +1666,1 @@\n-                        result.add(label);\n+                        content.add(label);\n@@ -1662,2 +1668,2 @@\n-                        Content content = seeTagToContent(element, node, context.within(node));\n-                        result.add(content);\n+                        Content c = seeTagToContent(element, node, context.within(node));\n+                        content.add(c);\n@@ -1669,1 +1675,1 @@\n-                public Boolean visitLiteral(LiteralTree node, Content c) {\n+                public Boolean visitLiteral(LiteralTree node, Content content) {\n@@ -1671,4 +1677,2 @@\n-                    Content content = Text.of(utils.normalizeNewlines(s));\n-                    if (node.getKind() == CODE)\n-                        content = HtmlTree.CODE(content);\n-                    result.add(content);\n+                    Content t = Text.of(utils.normalizeNewlines(s));\n+                    content.add(node.getKind() == CODE ? HtmlTree.CODE(t) : t);\n@@ -1679,2 +1683,2 @@\n-                public Boolean visitSee(SeeTree node, Content c) {\n-                    result.add(seeTagToContent(element, node, context));\n+                public Boolean visitSee(SeeTree node, Content content) {\n+                    content.add(seeTagToContent(element, node, context));\n@@ -1685,5 +1689,2 @@\n-                public Boolean visitStartElement(StartElementTree node, Content c) {\n-                    String text = \"<\" + node.getName();\n-                    RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));\n-                    result.add(rawHtml);\n-\n+                public Boolean visitStartElement(StartElementTree node, Content content) {\n+                    Content attrs = new ContentBuilder();\n@@ -1691,1 +1692,1 @@\n-                        dt.accept(this, null);\n+                        dt.accept(this, attrs);\n@@ -1693,1 +1694,1 @@\n-                    result.add(new RawHtml(node.isSelfClosing() ? \"\/>\" : \">\"));\n+                    content.add(RawHtml.startElement(node.getName(), attrs, node.isSelfClosing()));\n@@ -1698,1 +1699,1 @@\n-                public Boolean visitSummary(SummaryTree node, Content c) {\n+                public Boolean visitSummary(SummaryTree node, Content content) {\n@@ -1700,1 +1701,1 @@\n-                    result.add(output);\n+                    content.add(output);\n@@ -1705,1 +1706,1 @@\n-                public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {\n+                public Boolean visitSystemProperty(SystemPropertyTree node, Content content) {\n@@ -1708,1 +1709,1 @@\n-                        result.add(output);\n+                        content.add(output);\n@@ -1731,1 +1732,1 @@\n-                public Boolean visitText(TextTree node, Content c) {\n+                public Boolean visitText(TextTree node, Content content) {\n@@ -1733,1 +1734,3 @@\n-                    result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));\n+                    result.add(text.startsWith(\"<![CDATA[\")\n+                            ? RawHtml.cdata(text)\n+                            : Text.of(textCleanup(text, isLastNode, commentRemoved)));\n@@ -1738,1 +1741,1 @@\n-                protected Boolean defaultAction(DocTree node, Content c) {\n+                protected Boolean defaultAction(DocTree node, Content content) {\n@@ -1741,1 +1744,1 @@\n-                        result.add(output);\n+                        content.add(output);\n@@ -1746,1 +1749,3 @@\n-            }.visit(tag, null);\n+            };\n+\n+            boolean allDone = docTreeVisitor.visit(tag, result);\n@@ -1748,0 +1753,1 @@\n+\n@@ -1900,9 +1906,0 @@\n-    \/**\n-     * According to\n-     * <cite>The Java Language Specification<\/cite>,\n-     * all the outer classes and static nested classes are core classes.\n-     *\/\n-    public boolean isCoreClass(TypeElement typeElement) {\n-        return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);\n-    }\n-\n@@ -2169,0 +2166,1 @@\n+\n@@ -2178,0 +2176,1 @@\n+\n@@ -2182,0 +2181,1 @@\n+\n@@ -2193,0 +2193,1 @@\n+\n@@ -2277,4 +2278,0 @@\n-    Script getMainBodyScript() {\n-        return mainBodyScript;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":106,"deletions":109,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -137,1 +137,1 @@\n-            Content serialFieldContent = new RawHtml(ch.getText(description));\n+            Content serialFieldContent = RawHtml.of(ch.getText(description)); \/\/ should interpret tags\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlSerialFieldWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-            \/\/ depending of combined length of type parameters and return type.\n+            \/\/ depending on the combined length of type parameters and return type.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Signatures.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import com.sun.source.doctree.TextTree;\n@@ -310,1 +311,1 @@\n-        Content content = htmlWriter.commentTagsToContent(element, desc , context.within(returnTag));\n+        Content content = htmlWriter.commentTagsToContent(element, desc, context.within(returnTag));\n@@ -374,1 +375,1 @@\n-                HtmlTree.DT(new RawHtml(header)),\n+                HtmlTree.DT(RawHtml.of(header)),\n@@ -507,1 +508,1 @@\n-            excName = new RawHtml(ch.getExceptionName(throwsTag).toString());\n+            excName = Text.of(ch.getExceptionName(throwsTag).toString());\n@@ -509,1 +510,1 @@\n-            excName = new RawHtml(utils.getFullyQualifiedName(exception));\n+            excName = Text.of(utils.getFullyQualifiedName(exception));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -44,0 +44,10 @@\n+    \/**\n+     * Creates an entity with a given name or numeric value.\n+     *\n+     * @param name the name, or numeric value\n+     * @return the entity\n+     *\/\n+    public static Entity of(CharSequence name) {\n+        return new Entity(\"&\" + name + \";\");\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Entity.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,78 @@\n-    private final String rawHtmlContent;\n+    protected final String rawHtmlContent;\n+\n+    \/**\n+     * Creates HTML for an arbitrary string of HTML.\n+     * The string is accepted as-is and is not validated in any way.\n+     * It should be syntactically well-formed and contain matching {@code <} and {@code >},\n+     * and matching quotes for attributes.\n+     *\n+     * @param rawHtml the string\n+     * @return the HTML\n+     *\/\n+    public static RawHtml of(CharSequence rawHtml) {\n+        return new RawHtml(rawHtml) {\n+            @Override\n+            public int charCount() {\n+                return charCount(rawHtmlContent);\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Creates HTML for the start of an element.\n+     *\n+     * @param name the name of the element\n+     * @param attrs content containing any attributes\n+     * @param selfClosing whether this is a self-closing element.\n+     * @return the HTML\n+     *\/\n+    public static RawHtml startElement(CharSequence name, Content attrs, boolean selfClosing) {\n+        StringBuilder sb = new StringBuilder(\"<\" + name);\n+        if (!attrs.isEmpty()) {\n+            sb.append(\" \");\n+            sb.append(attrs);\n+        }\n+        sb.append(selfClosing ? \"\/>\" : \">\");\n+        return new RawHtml(sb);\n+    }\n+\n+    \/**\n+     * Creates HTML for the end of an element.\n+     *\n+     * @param name the name of the element\n+     * @return the HTML\n+     *\/\n+    public static RawHtml endElement(CharSequence name) {\n+        return new RawHtml(\"<\/\" + name + \">\");\n+    }\n+\n+    \/**\n+     * Creates HTML for an HTML comment.\n+     *\n+     * The body will be enclosed in {@code <!--} and {@code -->} if it does not\n+     * already begin and end with those sequences.\n+     *\n+     * @param body the body of the comment\n+     *\n+     * @return the HTML\n+     *\/\n+    public static RawHtml comment(String body) {\n+        return section(\"<!--\", body, \"-->\");\n+    }\n+    \/**\n+     * Creates HTML for an HTML CDATA section.\n+     *\n+     * The body will be enclosed in {@code <![CDATA]} and {@code ]]>} if it does not\n+     * already begin and end with those sequences.\n+     *\n+     * @param body the body of the CDATA section\n+     *\n+     * @return the HTML\n+     *\/\n+    public static RawHtml cdata(String body) {\n+        return section(\"<![CDATA[\", body, \"]]>\");\n+    }\n+\n+    private static RawHtml section(String prefix, String body, String suffix) {\n+        return new RawHtml(body.startsWith(prefix) && body.endsWith(suffix) ? body : prefix + body + suffix);\n+    }\n@@ -46,1 +123,1 @@\n-    public RawHtml(CharSequence rawHtml) {\n+    private RawHtml(CharSequence rawHtml) {\n@@ -62,6 +139,1 @@\n-    @Override\n-    public int charCount() {\n-        return charCount(rawHtmlContent);\n-    }\n-\n-    static int charCount(CharSequence htmlText) {\n+    protected static int charCount(CharSequence htmlText) {\n@@ -83,1 +155,0 @@\n-                        case '\\n':\n@@ -85,1 +156,5 @@\n-                            \/\/ Ignore line separators to get consistent results across platforms.\n+                            \/\/ Skip the \"\\r\" to get consistent results across platforms.\n+                            if (i + 1 < htmlText.length() && htmlText.charAt(i + 1) == '\\n') {\n+                                i++;\n+                            }\n+                            count++;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/RawHtml.java","additions":85,"deletions":10,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+ * Any special HTML characters will be escaped if and when the content is written out.\n@@ -58,1 +59,1 @@\n-        string = Entity.escapeHtmlChars(content);\n+        string = content.toString();\n@@ -68,1 +69,14 @@\n-        return RawHtml.charCount(string);\n+        return charCount(string);\n+    }\n+\n+    static int charCount(CharSequence cs) {\n+        int count = 0;\n+        for (int i = 0; i < cs.length(); i++) {\n+            \/\/ Windows uses \"\\r\\n\" as line separator while UNIX uses \"\\n\".\n+            \/\/ Skip the \"\\r\" to get consistent results across platforms.\n+            if (cs.charAt(i) == '\\r' && (i + 1 < cs.length()) && cs.charAt(i + 1) == '\\n') {\n+                i++;\n+            }\n+            count++;\n+        }\n+        return count;\n@@ -78,1 +92,1 @@\n-        out.write(string);\n+        out.write(Entity.escapeHtmlChars(string));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Text.java","additions":17,"deletions":3,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+ * Any special HTML characters will be escaped if and when the content is written out.\n@@ -55,2 +56,1 @@\n-        stringBuilder = new StringBuilder();\n-        Entity.escapeHtmlChars(initialContent, stringBuilder);\n+        stringBuilder = new StringBuilder(initialContent);\n@@ -60,2 +60,1 @@\n-     * Adds content for the StringContent object.  The method escapes\n-     * HTML characters for the string content that is added.\n+     * Adds content for the StringContent object.\n@@ -67,1 +66,1 @@\n-        Entity.escapeHtmlChars(strContent, stringBuilder);\n+        stringBuilder.append(strContent);\n@@ -78,1 +77,1 @@\n-        return RawHtml.charCount(stringBuilder.toString());\n+        return Text.charCount(stringBuilder);\n@@ -88,1 +87,1 @@\n-        String s = stringBuilder.toString();\n+        String s = Entity.escapeHtmlChars(stringBuilder);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/TextBuilder.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -131,0 +131,34 @@\n+\n+    \/**\n+     * Parses a string, looking for simple embedded HTML.\n+     * @param s the string\n+     * @return the list of parsed {@code DocTree} nodes\n+     *\/\n+    private List<DocTree> parse(String s) {\n+        List<DocTree> list = null;\n+        Pattern p = Pattern.compile(\"(?i)<(\/)?([a-z0-9]+)(\/)?>\");\n+        Matcher m = p.matcher(s);\n+        int start = 0;\n+        while (m.find()) {\n+            if (list == null) {\n+                list = new ArrayList<>();\n+            }\n+            if (m.start() > 0) {\n+                list.add(treeFactory.newTextTree(s.substring(start, m.start())));\n+            }\n+            Name name = elementUtils.getName(m.group(2));\n+            list.add(m.group(1) == null\n+                    ? treeFactory.newStartElementTree(name, List.of(), m.group(3) != null)\n+                    : treeFactory.newEndElementTree(name));\n+            start = m.end();\n+        }\n+        if (list == null) {\n+            return List.of(treeFactory.newTextTree(s));\n+        } else {\n+            if (start < s.length()) {\n+                list.add(treeFactory.newTextTree(s.substring(start, s.length())));\n+            }\n+            return list;\n+        }\n+    }\n+\n@@ -145,2 +179,1 @@\n-        List<DocTree> fullBody = new ArrayList<>();\n-        fullBody.add(treeFactory.newTextTree(resources.getText(\"doclet.enum_valueof_doc.fullbody\")));\n+        List<DocTree> fullBody = parse(resources.getText(\"doclet.enum_valueof_doc.fullbody\"));\n@@ -245,1 +278,1 @@\n-                contents.add(treeFactory.newTextTree(body.substring(start, m.start())));\n+                contents.addAll(parse(body.substring(start, m.start())));\n@@ -248,1 +281,1 @@\n-            List<DocTree> descr = List.of(treeFactory.newTextTree(m.group(2).trim())) ;\n+            List<DocTree> descr = parse(m.group(2).trim());\n@@ -253,1 +286,1 @@\n-            contents.add(treeFactory.newTextTree(body.substring(start)));\n+            contents.addAll(parse(body.substring(start)));\n@@ -488,1 +521,1 @@\n-            return List.of(treeFactory.newTextTree(text));\n+            return parse(text);\n@@ -491,7 +524,7 @@\n-            return List.of(\n-                    treeFactory.newTextTree(text.substring(0, index)),\n-                    treeFactory.newStartElementTree(CODE, List.of(), false),\n-                    treeFactory.newTextTree(name.toString()),\n-                    treeFactory.newEndElementTree(CODE),\n-                    treeFactory.newTextTree(text.substring(index + 3))\n-            );\n+            var list = new ArrayList<DocTree>();\n+            list.addAll(parse(text.substring(0, index)));\n+            list.add(treeFactory.newStartElementTree(CODE, List.of(), false));\n+            list.add(treeFactory.newTextTree(name.toString()))   ;\n+            list.add(treeFactory.newEndElementTree(CODE));\n+            list.addAll(parse(text.substring(index + 3)));\n+            return list;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/CommentUtils.java","additions":46,"deletions":13,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -136,3 +136,1 @@\n-     * Return the number of characters of plain text content in this object\n-     * (optional operation.)\n-     * @return the number of characters of plain text content in this\n+     * {@return the number of characters of plain text content in this object}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/Content.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-        output.add(new RawHtml(userTaglet.toString(List.of(tag), element)));\n+        output.add(RawHtml.of(userTaglet.toString(List.of(tag), element)));\n@@ -122,1 +122,1 @@\n-                output.add(new RawHtml(tagString));\n+                output.add(RawHtml.of(tagString));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/UserTaglet.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-                        .filter(utils::isText)\n+                        .filter(dt -> dt.getKind() == DocTree.Kind.TEXT)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2179,12 +2179,0 @@\n-    public boolean isStartElement(DocTree doctree) {\n-        return isKind(doctree, START_ELEMENT);\n-    }\n-\n-    public boolean isText(DocTree doctree) {\n-        return isKind(doctree, TEXT);\n-    }\n-\n-    private boolean isKind(DocTree doctree, DocTree.Kind match) {\n-        return  doctree.getKind() == match;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+                \"-Xdoclint:none\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeAnnotations\/TestTypeAnnotations.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-\/\/ key: compiler.err.dc.bad.entity\n+\/\/ key: compiler.err.dc.invalid.html\n@@ -30,2 +30,2 @@\n-\/** & *\/\n-class BadEntity { }\n+\/** <![CDATA[ *\/\n+class InvalidHtml { }\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/InvalidHtml.java","additions":3,"deletions":3,"binary":false,"changes":6,"previous_filename":"test\/langtools\/tools\/javac\/diags\/examples\/BadEntity.java","status":"copied"}]}