[{"commit":{"message":"Remove dead uses of is_concrete"},"files":[{"filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp"},{"filename":"src\/hotspot\/share\/opto\/buildOopMap.cpp"}],"sha":"d9875679dbf75c64b2d6c6f2c84161edd3f6c47b"},{"commit":{"message":"8275847: Scheduling fails with \"too many D-U pinch points\" on small method\n\nSince around JDK 16 the following method cannot be compiled by C2 on\nAArch64:\n\n  public double mergeSync() { return Math.log(Math.sin(value)); }\n\n(Reduced from a slightly larger benchmark.)\n\n  811 416 ! 3 Test::mergeSync (61 bytes)\n  813 417 ! 4 Test::mergeSync (61 bytes)\n  816 417 ! 4 Test::mergeSync (61 bytes) COMPILE SKIPPED: too many D-U pinch points (retry at different tier)\n  816 418 ! 1 Test::mergeSync (61 bytes)\n\nScheduling::anti_do_def() will create temporary Nodes for each OptoReg\nkilled by the MachProjs from the two runtime leaf calls.  After SVE\nsupport was added these runtime calls kill more registers, and the\nnumber of new Nodes added by anti_do_def exceeds an internal\nlimit (which is based on the LRG map size and roughly proportional to\nthe method size).\n\nX86 has the same problem if OptoScheduling is enabled because of the\nwide AVX registers.\n\nThe fix here is to ignore OptoRegs which correspond to the high slots of\nwide vectors (i.e. slots above 64 bits).  The scheduler doesn't run on\nmethods where C->max_vector_size() > 8, so we know these kills can't\naffect the scheduling result.\n\nThe added test fails on the current JDK with:\n\n  compiler.lib.ir_framework.shared.TestRunException: Could not compile public double\n  compiler.c2.irTests.TestScheduleSmallMethod.testSmallMethodTwoRuntimeCalls(double) at level C2\n  after 10s. Last compilation level: 3"},"files":[{"filename":"src\/hotspot\/cpu\/x86\/vmreg_x86.hpp"},{"filename":"src\/hotspot\/share\/opto\/output.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestScheduleSmallMethod.java"}],"sha":"dfa783f1036b4d3e8dc79d5600b41d861828b8fd"}]