{"files":[{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8292217\n+ * @summary Test co-located events (CLE) for MethodEntry, SingleStep, and Breakpoint events.\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g CLETest.java\n+ * @run driver CLETest\n+ *\/\n+\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+import java.util.*;\n+\n+class t1 {\n+    public static void foo() {\n+    }\n+}\n+class t2 {\n+    public static void foo() {\n+    }\n+}\n+\n+\/*\n+ * The debuggee has a large number of breakpoints pre-setup to help control the test.\n+ * They are each hit just once, and in the order of their number. No instructions in the\n+ * debuggee are ever executed more than once.\n+ *\n+ * NOTE: the breakpoints are sensitive to the their line number within the method.\n+ * If that changes, then the \"breakpoints\" table needs to be updated.\n+ *\/\n+class CLEDebugee {\n+    public static void main(String[] args) {\n+        runTests();\n+    }\n+\n+    public static void runTests() {\n+        test1();\n+        test2();\n+        test3(); \/\/ BREAKPOINT_3\n+        test4(); \/\/ BREAKPOINT_5\n+        test5(); \/\/ BREAKPOINT_7\n+        test6(); \/\/ BREAKPOINT_9\n+    }\n+\n+    \/\/ test1 and test2 are testing for the bug described in 8292217. For this test MethodEntry\n+    \/\/ events are enabled when we hit the breakpoint, and we single step OVER (test1) or\n+    \/\/ INTO (test2) an instruction with an unresolved contant pool entry. The Debugger will\n+    \/\/ verify that the generated MethodEntry events during class loading are not improperly\n+    \/\/ co-located as described the the CR.\n+    public static void test1() {\n+        t1.foo();  \/\/ BREAKPOINT_1\n+    }\n+    public static void test2() {\n+        t2.foo();  \/\/ BREAKPOINT_2\n+    }\n+\n+    \/\/ Tests that MethodEntry, Step, and Breakpoint events that occur at the same\n+    \/\/ location are properly co-located in the same EventSet. MethodEntry and Step\n+    \/\/ are enabled when we hit BREAKPOINT_3 above. When the BreakpointEvent for\n+    \/\/ BREAKPOINT_4 is generated, the EventSet should also include a StepEvent\n+    \/\/ and a MethodEntryEvent.\n+    public static void test3() {\n+        int x = 1;   \/\/ BREAKPOINT_4\n+    }\n+\n+    \/\/ Same as test3 but only check for co-located MethodEntry and Breakpoint events.\n+    \/\/ MethodEntry is enabled when we hit BREAKPOINT_5 above. StepEvent is not enabled.\n+    \/\/ When the BreakpointEvent for BREAKPOINT_6 is generated, the EventSet should also\n+    \/\/ include a MethodEntryEvent.\n+    public static void test4() {\n+        int x = 1;   \/\/ BREAKPOINT_6\n+    }\n+\n+    \/\/ Same as test3 but only check for co-located Step and Breakpoint events.\n+    \/\/ StepEvents are enabled when we hit BREAKPOINT_7 above. When the BreakpointEvent\n+    \/\/ for BREAKPOINT_8 is generated, the EventSet should also include a StepEvent,\n+    public static void test5() {\n+        int x = 1;    \/\/ BREAKPOINT_8\n+    }\n+\n+    \/\/ Same as test3 but only check for co-located MethodEntry and Step events.\n+    \/\/ MethodEntry and Step events are enabled when we hit BREAKPOINT_9 above. When\n+    \/\/ the StepEvent is received, the EventSet should also include the MethodEntryEvent.\n+    public static void test6() {\n+        int x = 1;\n+    }\n+}\n+\n+public class CLETest extends TestScaffold {\n+    ClassType targetClass;\n+    EventRequestManager erm;\n+    StepRequest stepRequest;\n+    MethodEntryRequest entryRequest;\n+    MethodExitRequest exitRequest;\n+    int methodEntryCount = 0;\n+    int breakpointCount = 0;\n+    boolean testFailed = false;\n+    boolean testcaseFailed = false;\n+    int testcase = 0;\n+\n+    CLETest(String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        CLETest cle = new CLETest(args);\n+        cle.startTests();\n+    }\n+\n+    static class MethodBreakpointData {\n+        final String method;\n+        final String signature;\n+        final int lineNumber;\n+        public MethodBreakpointData(String method, String signature, int lineNumber) {\n+            this.method     = method;\n+            this.signature  = signature;\n+            this.lineNumber = lineNumber;\n+        }\n+    }\n+\n+    \/\/ Table of all breakpoints based on method name and sig, plus the line number within the method.\n+    static MethodBreakpointData[] breakpoints = new MethodBreakpointData[] {\n+        new MethodBreakpointData(\"runTests\", \"()V\", 3), \/\/ BREAKPOINT_3\n+        new MethodBreakpointData(\"runTests\", \"()V\", 4), \/\/ BREAKPOINT_5\n+        new MethodBreakpointData(\"runTests\", \"()V\", 5), \/\/ BREAKPOINT_7\n+        new MethodBreakpointData(\"runTests\", \"()V\", 6), \/\/ BREAKPOINT_9\n+        new MethodBreakpointData(\"test1\", \"()V\", 1), \/\/ BREAKPOINT_1\n+        new MethodBreakpointData(\"test2\", \"()V\", 1), \/\/ BREAKPOINT_2\n+        new MethodBreakpointData(\"test3\", \"()V\", 1), \/\/ BREAKPOINT_4\n+        new MethodBreakpointData(\"test4\", \"()V\", 1), \/\/ BREAKPOINT_6\n+        new MethodBreakpointData(\"test5\", \"()V\", 1)  \/\/ BREAKPOINT_8\n+    };\n+\n+    public static void printStack(ThreadReference thread) {\n+        try {\n+            List<StackFrame> frames = thread.frames();\n+            Iterator<StackFrame> iter = frames.iterator();\n+            while (iter.hasNext()) {\n+                StackFrame frame = iter.next();\n+                System.out.println(getLocationString(frame.location()));\n+            }\n+        } catch (Exception e) {\n+            System.out.println(\"printStack: exception \" + e);\n+        }\n+    }\n+\n+    public static String getLocationString(Location loc) {\n+        return\n+            loc.declaringType().name() + \".\" +\n+            loc.method().name() + \":\" +\n+            loc.lineNumber();\n+    }\n+\n+    \/*\n+     * Returns true if the specified event types are all co-located in this EventSet,\n+     * and no other events are included. Note that the order of the events (when present)\n+     * is required to be: MethodEntryEvent, StepEvent, BreakpointEvent.\n+     *\/\n+    public boolean isColocated(EventSet set, boolean needEntry, boolean needStep, boolean needBreakpoint) {\n+        int expectedSize = (needEntry ? 1 : 0) + (needStep ? 1 : 0) + (needBreakpoint ? 1 : 0);\n+        if (set.size() != expectedSize) {\n+            return false;\n+        }\n+        EventIterator iter = set.eventIterator();\n+        if (needEntry) {\n+            Event meEvent = iter.next();\n+            if (!(meEvent instanceof MethodEntryEvent)) {\n+                return false;\n+            }\n+        }\n+        if (needStep) {\n+            Event ssEvent = iter.next();\n+            if (!(ssEvent instanceof StepEvent)) {\n+                return false;\n+            }\n+        }\n+        if (needBreakpoint) {\n+            Event bpEvent = iter.next();\n+            if (!(bpEvent instanceof BreakpointEvent)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public void eventSetReceived(EventSet set) {\n+        System.out.println(\"\\nEventSet for test case #\" + testcase + \": \" + set);\n+        switch (testcase) {\n+        case 1:\n+        case 2: {\n+            \/\/ During the first two test cases we should never receive an EventSet with\n+            \/\/ more than one Event in it.\n+            if (set.size() != 1) {\n+                testcaseFailed = true;\n+                \/\/ For now, we expect these two test cases to fail due to 8292217,\n+                \/\/ so don't fail the overall test run as a result of these failures.\n+                \/\/ testFailed = true;\n+                System.out.println(\"TESTCASE #\" + testcase + \" FAILED (ignoring): too many events in EventSet: \" + set.size());\n+            }\n+            break;\n+        }\n+        case 3: {\n+            \/\/ At some point during test3 we should receive co-located MethodEntry, Step, and Breakpoint events.\n+            if (isColocated(set, true, true, true)) {\n+                testcaseFailed = false;\n+            }\n+            break;\n+        }\n+        case 4: {\n+            \/\/ At some point during test4 we should receive co-located MethodEntry and Breakpoint events.\n+            if (isColocated(set, true, false, true)) {\n+                testcaseFailed = false;\n+            }\n+            break;\n+        }\n+        case 5: {\n+            \/\/ At some point during test5 we should receive co-located Step and Breakpoint events.\n+            if (isColocated(set, false, true, true)) {\n+                testcaseFailed = false;\n+            }\n+            break;\n+        }\n+        case 6: {\n+            \/\/ At some point during test6 we should receive co-located MethodEntry and Step events.\n+            if (isColocated(set, true, true, false)) {\n+                testcaseFailed = false;\n+            }\n+            break;\n+        }\n+        }\n+    }\n+\n+    \/*\n+     * Most of the control flow of the test is handled via breakpoints. There is one at the start\n+     * of each test case that is used to enable other events that we check for during the test case.\n+     * In some cases there is an additional Breakpoint enabled for the test cases that is\n+     * also used to determine when the test case is complete. Other test cases are completed\n+     * when a Step or MethodEntry event arrives.\n+     *\/\n+    public void breakpointReached(BreakpointEvent event) {\n+        \/\/ Make sure this breakpoint is at the expected location.\n+        MethodBreakpointData bpData = breakpoints[breakpointCount];\n+        try {\n+            Location loc = findMethodLocation(targetClass, bpData.method,\n+                                              bpData.signature, bpData.lineNumber);\n+            if (!loc.equals(event.location())) {\n+                throw new RuntimeException(\"Unexpected Breakpoint reached\");\n+            }\n+        } catch (AbsentInformationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        breakpointCount++;\n+        if (breakpointCount != 4 && breakpointCount != 6 && breakpointCount != 8) {\n+            testcase++;\n+        }\n+        System.out.println(\"Got BreakpointEvent(\" + breakpointCount + \"): \" + getLocationString(event.location()));\n+        event.request().disable();\n+\n+        \/\/ Setup test1. Completion is checked for in stepCompleted().\n+        if (breakpointCount == 1) {\n+            testcaseFailed = false; \/\/ assume passing unless error detected\n+            entryRequest.enable();\n+            exitRequest.enable();\n+            stepRequest = erm.createStepRequest(mainThread,\n+                                                StepRequest.STEP_LINE,\n+                                                StepRequest.STEP_OVER);\n+            stepRequest.addCountFilter(1);\n+            stepRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+            stepRequest.enable();\n+        }\n+\n+        \/\/ Setup test2. Completion is checked for in stepCompleted().\n+        if (breakpointCount == 2) {\n+            testcaseFailed = false; \/\/ assume passing unless error detected\n+            entryRequest.enable();\n+            exitRequest.enable();\n+            stepRequest = erm.createStepRequest(mainThread,\n+                                                StepRequest.STEP_LINE,\n+                                                StepRequest.STEP_INTO);\n+            stepRequest.addCountFilter(1);\n+            stepRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+            stepRequest.enable();\n+        }\n+\n+        \/\/ Setup test3: MethodEntry, Step, and Breakpoint co-located events.\n+        \/\/ Completion is handled by the next breakpoint being hit.\n+        if (breakpointCount == 3) {\n+            testcaseFailed = true; \/\/ assume failing unless pass detected\n+            entryRequest.enable();\n+            stepRequest = erm.createStepRequest(mainThread,\n+                                                StepRequest.STEP_LINE,\n+                                                StepRequest.STEP_INTO);\n+            stepRequest.addCountFilter(1);\n+            stepRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+            stepRequest.enable();\n+        }\n+        \/\/ Complete test3. We fail if we never saw the expected co-located events.\n+        if (breakpointCount == 4) {\n+            if (testcaseFailed) {\n+                testFailed = true;\n+                System.out.println(\"TESTCASE #3 FAILED: did not get MethodEntry, Step, and Breakpoint co-located events\");\n+            } else {\n+                System.out.println(\"TESTCASE #3 PASSED\");\n+            }\n+        }\n+\n+        \/\/ Setup test4: MethodEntry and Breakpoint co-located events.\n+        \/\/ Completion is handled by the next breakpoint being hit.\n+        if (breakpointCount == 5) {\n+            testcaseFailed = true; \/\/ assume failing unless pass detected\n+            entryRequest.enable();\n+        }\n+        \/\/ Complete test4. We fail if we never saw the expected co-located events.\n+        if (breakpointCount == 6) {\n+            entryRequest.disable();\n+            if (testcaseFailed) {\n+                testFailed = true;\n+                System.out.println(\"TESTCASE #4 FAILED: did not get MethodEntry and Breakpoint co-located events\");\n+            } else {\n+                System.out.println(\"TESTCASE #4 PASSED\");\n+            }\n+        }\n+\n+        \/\/ Setup test5: Step and Breakpoint co-located events.\n+        \/\/ Completion is handled by the next breakpoint being hit.\n+        if (breakpointCount == 7) {\n+            testcaseFailed = true; \/\/ assume failing unless pass detected\n+            stepRequest = erm.createStepRequest(mainThread,\n+                                                StepRequest.STEP_LINE,\n+                                                StepRequest.STEP_INTO);\n+            stepRequest.addCountFilter(1);\n+            stepRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+            stepRequest.enable();\n+        }\n+        \/\/ Complete test5. We fail if we never saw the expected co-located events.\n+        if (breakpointCount == 8) {\n+            if (testcaseFailed) {\n+                testFailed = true;\n+                System.out.println(\"TESTCASE #5 FAILED: did not get Step and Breakpoint co-located events\");\n+            } else {\n+                System.out.println(\"TESTCASE #5 PASSED\");\n+            }\n+        }\n+\n+        \/\/ Setup test: MethodEntry and Step co-located events\n+        \/\/ Completion is handled by the stepCompleted() since there is no additional breakpoint.\n+        if (breakpointCount == 9) {\n+            testcaseFailed = true; \/\/ assume failing unless pass detected\n+            entryRequest.enable();\n+            stepRequest = erm.createStepRequest(mainThread,\n+                                                StepRequest.STEP_LINE,\n+                                                StepRequest.STEP_INTO);\n+            stepRequest.addCountFilter(1);\n+            stepRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+            stepRequest.enable();\n+        }\n+    }\n+\n+    public void stepCompleted(StepEvent event) {\n+        System.out.println(\"Got StepEvent: \" + getLocationString(event.location()));\n+        event.request().disable();\n+        entryRequest.disable();\n+        if (testcase == 6 && testcaseFailed) {\n+            testFailed = true;\n+            System.out.println(\"TESTCASE #6 FAILED: did not get MethodEntry and Step co-located events\");\n+        }\n+        if (testcase == 1 || testcase == 2 || testcase == 6) {\n+            exitRequest.disable();\n+            if (!testcaseFailed) {  \/\/ We already did a println if the test failed.\n+                System.out.println(\"TESTCASE #\" + testcase + \" PASSED\");\n+            }\n+        }\n+    }\n+\n+    public void methodEntered(MethodEntryEvent event) {\n+        System.out.println(\"Got MethodEntryEvent: \" + getLocationString(event.location()));\n+        if (methodEntryCount++ == 25) {\n+            entryRequest.disable(); \/\/ Just in case the test loses control.\n+        }\n+    }\n+\n+    public void methodExited(MethodExitEvent event) {\n+        System.out.println(\"Got MethodExitEvent: \" + getLocationString(event.location()));\n+        \/\/printStack(event.thread());\n+        exitRequest.disable();\n+        entryRequest.disable();\n+    }\n+\n+    protected void runTests() throws Exception {\n+        System.out.println(\"Starting CLETest\");\n+        BreakpointEvent bpe = startToMain(\"CLEDebugee\");\n+        targetClass = (ClassType)bpe.location().declaringType();\n+        mainThread = bpe.thread();\n+        System.out.println(\"Got main thread: \" + mainThread);\n+        erm = eventRequestManager();\n+\n+        try {\n+            \/\/ Setup all breakpoints\n+            for (MethodBreakpointData bpData : breakpoints) {\n+                Location loc = findMethodLocation(targetClass, bpData.method,\n+                                                  bpData.signature, bpData.lineNumber);\n+                BreakpointRequest req = erm.createBreakpointRequest(loc);\n+                req.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+                req.enable();\n+            }\n+\n+            \/\/ Ask for method entry events\n+            entryRequest = erm.createMethodEntryRequest();\n+            entryRequest.addThreadFilter(mainThread);\n+            entryRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+\n+            \/\/ Ask for method exit events\n+            exitRequest = erm.createMethodExitRequest();\n+            exitRequest.addThreadFilter(mainThread);\n+            exitRequest.setSuspendPolicy(EventRequest.SUSPEND_ALL);\n+\n+            System.out.println(\"Waiting for events: \");\n+\n+            listenUntilVMDisconnect();\n+            System.out.println(\"All done...\");\n+        } catch (Exception ex){\n+            ex.printStackTrace();\n+            testFailed = true;\n+        }\n+\n+        if (!testFailed) {\n+            println(\"CLETest: passed\");\n+        } else {\n+            throw new Exception(\"CLETest: failed\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/CLETest.java","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"@@ -850,0 +850,8 @@\n+    public Location findMethodLocation(ReferenceType rt, String methodName,\n+                                       String methodSignature, int methodLineNumber)\n+        throws AbsentInformationException {\n+        Method m = findMethod(rt, methodName, methodSignature);\n+        int lineNumber = m.location().lineNumber() + methodLineNumber - 1;\n+        return findLocation(rt, lineNumber);\n+    }\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/TestScaffold.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}