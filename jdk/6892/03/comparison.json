{"files":[{"patch":"@@ -1445,1 +1445,2 @@\n-  Node *remix_address_expressions( Node *n );\n+  Node* remix_address_expressions(Node* n);\n+  Node* remix_address_expressions_add_left_shift(Node* n, IdealLoopTree* n_loop, Node* n_ctrl, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -356,35 +356,3 @@\n-\/\/------------------------------remix_address_expressions----------------------\n-\/\/ Rework addressing expressions to get the most loop-invariant stuff\n-\/\/ moved out.  We'd like to do all associative operators, but it's especially\n-\/\/ important (common) to do address expressions.\n-Node *PhaseIdealLoop::remix_address_expressions( Node *n ) {\n-  if (!has_ctrl(n))  return NULL;\n-  Node *n_ctrl = get_ctrl(n);\n-  IdealLoopTree *n_loop = get_loop(n_ctrl);\n-\n-  \/\/ See if 'n' mixes loop-varying and loop-invariant inputs and\n-  \/\/ itself is loop-varying.\n-\n-  \/\/ Only interested in binary ops (and AddP)\n-  if( n->req() < 3 || n->req() > 4 ) return NULL;\n-\n-  Node *n1_ctrl = get_ctrl(n->in(                    1));\n-  Node *n2_ctrl = get_ctrl(n->in(                    2));\n-  Node *n3_ctrl = get_ctrl(n->in(n->req() == 3 ? 2 : 3));\n-  IdealLoopTree *n1_loop = get_loop( n1_ctrl );\n-  IdealLoopTree *n2_loop = get_loop( n2_ctrl );\n-  IdealLoopTree *n3_loop = get_loop( n3_ctrl );\n-\n-  \/\/ Does one of my inputs spin in a tighter loop than self?\n-  if( (n_loop->is_member( n1_loop ) && n_loop != n1_loop) ||\n-      (n_loop->is_member( n2_loop ) && n_loop != n2_loop) ||\n-      (n_loop->is_member( n3_loop ) && n_loop != n3_loop) )\n-    return NULL;                \/\/ Leave well enough alone\n-\n-  \/\/ Is at least one of my inputs loop-invariant?\n-  if( n1_loop == n_loop &&\n-      n2_loop == n_loop &&\n-      n3_loop == n_loop )\n-    return NULL;                \/\/ No loop-invariant inputs\n-\n-\n+\/\/ Replace expressions like ((V+I) << 2) with (V<<2 + I<<2).\n+Node* PhaseIdealLoop::remix_address_expressions_add_left_shift(Node* n, IdealLoopTree* n_loop, Node* n_ctrl, BasicType bt) {\n+  assert(bt == T_INT || bt == T_LONG, \"only for integers\");\n@@ -393,2 +361,1 @@\n-  \/\/ Replace expressions like ((V+I) << 2) with (V<<2 + I<<2).\n-  if( n_op == Op_LShiftI ) {\n+  if (n_op == Op_LShift(bt)) {\n@@ -396,4 +363,4 @@\n-    Node *scale = n->in(2);\n-    Node *scale_ctrl = get_ctrl(scale);\n-    IdealLoopTree *scale_loop = get_loop(scale_ctrl );\n-    if( n_loop == scale_loop || !scale_loop->is_member( n_loop ) )\n+    Node* scale = n->in(2);\n+    Node* scale_ctrl = get_ctrl(scale);\n+    IdealLoopTree* scale_loop = get_loop(scale_ctrl);\n+    if (n_loop == scale_loop || !scale_loop->is_member(n_loop)) {\n@@ -401,2 +368,3 @@\n-    const TypeInt *scale_t = scale->bottom_type()->isa_int();\n-    if( scale_t && scale_t->is_con() && scale_t->get_con() >= 16 )\n+    }\n+    const TypeInt* scale_t = scale->bottom_type()->isa_int();\n+    if (scale_t != NULL && scale_t->is_con() && scale_t->get_con() >= 16) {\n@@ -404,0 +372,1 @@\n+    }\n@@ -405,5 +374,6 @@\n-    Node *add = n->in(1);\n-    Node *add_ctrl = get_ctrl(add);\n-    IdealLoopTree *add_loop = get_loop(add_ctrl);\n-    \/\/assert( n_loop == add_loop, \"\" );\n-    if( n_loop != add_loop ) return NULL;  \/\/ happens w\/ evil ZKM loops\n+    Node* add = n->in(1);\n+    Node* add_ctrl = get_ctrl(add);\n+    IdealLoopTree* add_loop = get_loop(add_ctrl);\n+    if (n_loop != add_loop) {\n+      return NULL;  \/\/ happens w\/ evil ZKM loops\n+    }\n@@ -412,3 +382,4 @@\n-    if( add->Opcode() == Op_SubI &&\n-        _igvn.type( add->in(1) ) != TypeInt::ZERO ) {\n-      Node *zero = _igvn.intcon(0);\n+    if (add->Opcode() == Op_Sub(bt) &&\n+        _igvn.type(add->in(1)) != TypeInteger::zero(bt)) {\n+      assert(add->Opcode() == Op_SubI || add->Opcode() == Op_SubL, \"\");\n+      Node* zero = _igvn.integercon(0, bt);\n@@ -416,4 +387,4 @@\n-      Node *neg = new SubINode( _igvn.intcon(0), add->in(2) );\n-      register_new_node( neg, get_ctrl(add->in(2) ) );\n-      add = new AddINode( add->in(1), neg );\n-      register_new_node( add, add_ctrl );\n+      Node* neg = SubNode::make(zero, add->in(2), bt);\n+      register_new_node(neg, get_ctrl(add->in(2)));\n+      add = AddNode::make(add->in(1), neg, bt);\n+      register_new_node(add, add_ctrl);\n@@ -421,1 +392,2 @@\n-    if( add->Opcode() != Op_AddI ) return NULL;\n+    if (add->Opcode() != Op_Add(bt)) return NULL;\n+    assert(add->Opcode() == Op_AddI || add->Opcode() == Op_AddL, \"\");\n@@ -423,8 +395,7 @@\n-    Node *add_var = add->in(1);\n-    Node *add_var_ctrl = get_ctrl(add_var);\n-    IdealLoopTree *add_var_loop = get_loop(add_var_ctrl );\n-    Node *add_invar = add->in(2);\n-    Node *add_invar_ctrl = get_ctrl(add_invar);\n-    IdealLoopTree *add_invar_loop = get_loop(add_invar_ctrl );\n-    if( add_var_loop == n_loop ) {\n-    } else if( add_invar_loop == n_loop ) {\n+    Node* add_var = add->in(1);\n+    Node* add_var_ctrl = get_ctrl(add_var);\n+    IdealLoopTree* add_var_loop = get_loop(add_var_ctrl);\n+    Node* add_invar = add->in(2);\n+    Node* add_invar_ctrl = get_ctrl(add_invar);\n+    IdealLoopTree* add_invar_loop = get_loop(add_invar_ctrl);\n+    if (add_invar_loop == n_loop) {\n@@ -436,3 +407,1 @@\n-      Node *add_var_ctrl = get_ctrl(add_var);\n-      IdealLoopTree *add_var_loop = get_loop(add_var_ctrl );\n-    } else                      \/\/ Else neither input is loop invariant\n+    } else if (add_var_loop != n_loop) { \/\/ Else neither input is loop invariant\n@@ -440,1 +409,2 @@\n-    if( n_loop == add_invar_loop || !add_invar_loop->is_member( n_loop ) )\n+    }\n+    if (n_loop == add_invar_loop || !add_invar_loop->is_member(n_loop)) {\n@@ -442,0 +412,1 @@\n+    }\n@@ -444,10 +415,10 @@\n-    Node *inv_scale = new LShiftINode( add_invar, scale );\n-    Node *inv_scale_ctrl =\n-      dom_depth(add_invar_ctrl) > dom_depth(scale_ctrl) ?\n-      add_invar_ctrl : scale_ctrl;\n-    register_new_node( inv_scale, inv_scale_ctrl );\n-    Node *var_scale = new LShiftINode( add_var, scale );\n-    register_new_node( var_scale, n_ctrl );\n-    Node *var_add = new AddINode( var_scale, inv_scale );\n-    register_new_node( var_add, n_ctrl );\n-    _igvn.replace_node( n, var_add );\n+    Node* inv_scale = LShiftNode::make(add_invar, scale, bt);\n+    Node* inv_scale_ctrl =\n+            dom_depth(add_invar_ctrl) > dom_depth(scale_ctrl) ?\n+            add_invar_ctrl : scale_ctrl;\n+    register_new_node(inv_scale, inv_scale_ctrl);\n+    Node* var_scale = LShiftNode::make(add_var, scale, bt);\n+    register_new_node(var_scale, n_ctrl);\n+    Node* var_add = AddNode::make(var_scale, inv_scale, bt);\n+    register_new_node(var_add, n_ctrl);\n+    _igvn.replace_node(n, var_add);\n@@ -456,0 +427,38 @@\n+  return NULL;\n+}\n+\n+\/\/------------------------------remix_address_expressions----------------------\n+\/\/ Rework addressing expressions to get the most loop-invariant stuff\n+\/\/ moved out.  We'd like to do all associative operators, but it's especially\n+\/\/ important (common) to do address expressions.\n+Node* PhaseIdealLoop::remix_address_expressions(Node* n) {\n+  if (!has_ctrl(n))  return NULL;\n+  Node* n_ctrl = get_ctrl(n);\n+  IdealLoopTree* n_loop = get_loop(n_ctrl);\n+\n+  \/\/ See if 'n' mixes loop-varying and loop-invariant inputs and\n+  \/\/ itself is loop-varying.\n+\n+  \/\/ Only interested in binary ops (and AddP)\n+  if (n->req() < 3 || n->req() > 4) return NULL;\n+\n+  Node* n1_ctrl = get_ctrl(n->in(                    1));\n+  Node* n2_ctrl = get_ctrl(n->in(                    2));\n+  Node* n3_ctrl = get_ctrl(n->in(n->req() == 3 ? 2 : 3));\n+  IdealLoopTree* n1_loop = get_loop(n1_ctrl);\n+  IdealLoopTree* n2_loop = get_loop(n2_ctrl);\n+  IdealLoopTree* n3_loop = get_loop(n3_ctrl);\n+\n+  \/\/ Does one of my inputs spin in a tighter loop than self?\n+  if ((n_loop->is_member(n1_loop) && n_loop != n1_loop) ||\n+      (n_loop->is_member(n2_loop) && n_loop != n2_loop) ||\n+      (n_loop->is_member(n3_loop) && n_loop != n3_loop)) {\n+    return NULL;                \/\/ Leave well enough alone\n+  }\n+\n+  \/\/ Is at least one of my inputs loop-invariant?\n+  if (n1_loop == n_loop &&\n+      n2_loop == n_loop &&\n+      n3_loop == n_loop) {\n+    return NULL;                \/\/ No loop-invariant inputs\n+  }\n@@ -457,0 +466,10 @@\n+  Node* res = remix_address_expressions_add_left_shift(n, n_loop, n_ctrl, T_INT);\n+  if (res != NULL) {\n+    return res;\n+  }\n+  res = remix_address_expressions_add_left_shift(n, n_loop, n_ctrl, T_LONG);\n+  if (res != NULL) {\n+    return res;\n+  }\n+\n+  int n_op = n->Opcode();\n@@ -458,1 +477,1 @@\n-  if( n_op == Op_AddI ||\n+  if (n_op == Op_AddI ||\n@@ -465,3 +484,3 @@\n-      n_op == Op_MulD ) {\n-    if( n2_loop == n_loop ) {\n-      assert( n1_loop != n_loop, \"\" );\n+      n_op == Op_MulD) {\n+    if (n2_loop == n_loop) {\n+      assert(n1_loop != n_loop, \"\");\n@@ -474,10 +493,10 @@\n-  if( n_op == Op_AddP ) {\n-    if( n2_loop == n_loop && n3_loop != n_loop ) {\n-      if( n->in(2)->Opcode() == Op_AddP && !n->in(3)->is_Con() ) {\n-        Node *n22_ctrl = get_ctrl(n->in(2)->in(2));\n-        Node *n23_ctrl = get_ctrl(n->in(2)->in(3));\n-        IdealLoopTree *n22loop = get_loop( n22_ctrl );\n-        IdealLoopTree *n23_loop = get_loop( n23_ctrl );\n-        if( n22loop != n_loop && n22loop->is_member(n_loop) &&\n-            n23_loop == n_loop ) {\n-          Node *add1 = new AddPNode( n->in(1), n->in(2)->in(2), n->in(3) );\n+  if (n_op == Op_AddP) {\n+    if (n2_loop == n_loop && n3_loop != n_loop) {\n+      if (n->in(2)->Opcode() == Op_AddP && !n->in(3)->is_Con()) {\n+        Node* n22_ctrl = get_ctrl(n->in(2)->in(2));\n+        Node* n23_ctrl = get_ctrl(n->in(2)->in(3));\n+        IdealLoopTree* n22loop = get_loop(n22_ctrl);\n+        IdealLoopTree* n23_loop = get_loop(n23_ctrl);\n+        if (n22loop != n_loop && n22loop->is_member(n_loop) &&\n+            n23_loop == n_loop) {\n+          Node* add1 = new AddPNode(n->in(1), n->in(2)->in(2), n->in(3));\n@@ -485,4 +504,4 @@\n-          register_new_node( add1, n_loop->_head->in(LoopNode::EntryControl) );\n-          Node *add2 = new AddPNode( n->in(1), add1, n->in(2)->in(3) );\n-          register_new_node( add2, n_ctrl );\n-          _igvn.replace_node( n, add2 );\n+          register_new_node(add1, n_loop->_head->in(LoopNode::EntryControl));\n+          Node* add2 = new AddPNode(n->in(1), add1, n->in(2)->in(3));\n+          register_new_node(add2, n_ctrl);\n+          _igvn.replace_node(n, add2);\n@@ -497,2 +516,2 @@\n-        Node *V = n->in(3)->in(1);\n-        Node *I = n->in(3)->in(2);\n+        Node* V = n->in(3)->in(1);\n+        Node* I = n->in(3)->in(2);\n@@ -504,1 +523,1 @@\n-          Node *add1 = new AddPNode(n->in(1), n->in(2), I);\n+          Node* add1 = new AddPNode(n->in(1), n->in(2), I);\n@@ -507,1 +526,1 @@\n-          Node *add2 = new AddPNode(n->in(1), add1, V);\n+          Node* add2 = new AddPNode(n->in(1), add1, V);\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":119,"deletions":100,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -741,0 +741,12 @@\n+LShiftNode* LShiftNode::make(Node* in1, Node* in2, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new LShiftINode(in1, in2);\n+    case T_LONG:\n+      return new LShiftLNode(in1, in2);\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -231,0 +231,2 @@\n+\n+  static LShiftNode* make(Node* in1, Node* in2, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8278784\n+ * @summary C2: Refactor PhaseIdealLoop::remix_address_expressions() so it operates on longs\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestRemixAddressExpressions\n+ *\/\n+\n+public class TestRemixAddressExpressions {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public static float invPlusVarLshiftInt(int inv, int scale) {\n+        float res = 0;\n+        for (int i = 1; i < 100; i *= 11) {\n+            res += (i + inv) << scale;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"1\", IRNode.LSHIFT_L, \"2\" })\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public static float invPlusVarLshiftLong(long inv, int scale) {\n+        float res = 0;\n+        for (long i = 1; i < 100; i *= 11) {\n+            res += (i + inv) << scale;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.SUB_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public static float invMinusVarLshiftInt(int inv, int scale) {\n+        float res = 0;\n+        for (int i = 1; i < 100; i *= 11) {\n+            res += (inv - i) << scale;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"1\", IRNode.SUB_L, \"1\", IRNode.LSHIFT_L, \"2\" })\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public static float invMinusVarLshiftLong(long inv, int scale) {\n+        float res = 0;\n+        for (long i = 1; i < 100; i *= 11) {\n+            res += (inv - i) << scale;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_I, \"1\", IRNode.SUB_I, \"1\", IRNode.LSHIFT_I, \"2\" })\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public static float varMinusInvLshiftInt(int inv, int scale) {\n+        float res = 0;\n+        for (int i = 1; i < 100; i *= 11) {\n+            res += (i - inv) << scale;\n+        }\n+        return res;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.ADD_L, \"1\", IRNode.SUB_L, \"1\", IRNode.LSHIFT_L, \"2\" })\n+    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n+    public static float varMinusInvLshiftLong(long inv, int scale) {\n+        float res = 0;\n+        for (long i = 1; i < 100; i *= 11) {\n+            res += (i - inv) << scale;\n+        }\n+        return res;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestRemixAddressExpressions.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}