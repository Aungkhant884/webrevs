{"files":[{"patch":"@@ -794,45 +794,0 @@\n-HeapWord* MutableNUMASpace::allocate(size_t size) {\n-  Thread* thr = Thread::current();\n-  int lgrp_id = thr->lgrp_id();\n-  if (lgrp_id == -1 || !os::numa_has_group_homing()) {\n-    lgrp_id = os::numa_get_group_id();\n-    thr->set_lgrp_id(lgrp_id);\n-  }\n-\n-  int i = lgrp_spaces()->find(&lgrp_id, LGRPSpace::equals);\n-\n-  \/\/ It is possible that a new CPU has been hotplugged and\n-  \/\/ we haven't reshaped the space accordingly.\n-  if (i == -1) {\n-    i = os::random() % lgrp_spaces()->length();\n-  }\n-\n-  LGRPSpace* ls = lgrp_spaces()->at(i);\n-  MutableSpace *s = ls->space();\n-  HeapWord *p = s->allocate(size);\n-\n-  if (p != NULL) {\n-    size_t remainder = s->free_in_words();\n-    if (remainder < CollectedHeap::min_fill_size() && remainder > 0) {\n-      s->set_top(s->top() - size);\n-      p = NULL;\n-    }\n-  }\n-  if (p != NULL) {\n-    if (top() < s->top()) { \/\/ Keep _top updated.\n-      MutableSpace::set_top(s->top());\n-    }\n-  }\n-  \/\/ Make the page allocation happen here if there is no static binding..\n-  if (p != NULL && !os::numa_has_static_binding()) {\n-    for (HeapWord *i = p; i < p + size; i += os::vm_page_size() >> LogHeapWordSize) {\n-      *(int*)i = 0;\n-    }\n-  }\n-  if (p == NULL) {\n-    ls->set_allocation_failed();\n-  }\n-  return p;\n-}\n-\n-\/\/ This version is lock-free.\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":0,"deletions":45,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,0 @@\n-  virtual HeapWord* allocate(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,19 +176,0 @@\n-\/\/ This version requires locking. *\/\n-HeapWord* MutableSpace::allocate(size_t size) {\n-  assert(Heap_lock->owned_by_self() ||\n-         (SafepointSynchronize::is_at_safepoint() &&\n-          Thread::current()->is_VM_thread()),\n-         \"not locked\");\n-  HeapWord* obj = top();\n-  if (pointer_delta(end(), obj) >= size) {\n-    HeapWord* new_top = obj + size;\n-    set_top(new_top);\n-    assert(is_object_aligned(obj) && is_object_aligned(new_top),\n-           \"checking alignment\");\n-    return obj;\n-  } else {\n-    return NULL;\n-  }\n-}\n-\n-\/\/ This version is lock-free.\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.cpp","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,0 @@\n-  virtual HeapWord* allocate(size_t word_size);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableSpace.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,0 @@\n-class AdjoiningGenerations;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -150,19 +150,0 @@\n-\/\/ Allocation. We report all successful allocations to the size policy\n-\/\/ Note that the perm gen does not use this method, and should not!\n-HeapWord* PSOldGen::allocate(size_t word_size) {\n-  assert_locked_or_safepoint(Heap_lock);\n-  HeapWord* res = allocate_noexpand(word_size);\n-\n-  if (res == NULL) {\n-    res = expand_and_allocate(word_size);\n-  }\n-\n-  \/\/ Allocations in the old generation need to be reported\n-  if (res != NULL) {\n-    ParallelScavengeHeap* heap = ParallelScavengeHeap::heap();\n-    heap->size_policy()->tenured_allocation(word_size * HeapWordSize);\n-  }\n-\n-  return res;\n-}\n-\n@@ -201,8 +182,0 @@\n-HeapWord* PSOldGen::expand_and_allocate(size_t word_size) {\n-  expand(word_size*HeapWordSize);\n-  if (GCExpandToAllocateDelayMillis > 0) {\n-    os::naked_sleep(GCExpandToAllocateDelayMillis);\n-  }\n-  return allocate_noexpand(word_size);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":1,"deletions":28,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,3 +37,0 @@\n-  friend class PSPromotionManager; \/\/ Uses the cas_allocate methods\n-  friend class ParallelScavengeHeap;\n-  friend class AdjoiningGenerations;\n@@ -75,14 +72,0 @@\n-  HeapWord* allocate_noexpand(size_t word_size) {\n-    \/\/ We assume the heap lock is held here.\n-    assert_locked_or_safepoint(Heap_lock);\n-    HeapWord* res = object_space()->allocate(word_size);\n-    if (res != NULL) {\n-      DEBUG_ONLY(assert_block_in_covered_region(MemRegion(res, word_size)));\n-      _start_array.allocate_block(res);\n-    }\n-    return res;\n-  }\n-\n-  \/\/ Support for MT garbage collection. CAS allocation is lower overhead than grabbing\n-  \/\/ and releasing the heap lock, which is held during gc's anyway. This method is not\n-  \/\/ safe for use at the same time as allocate_noexpand()!\n@@ -90,1 +73,1 @@\n-    assert(SafepointSynchronize::is_at_safepoint(), \"Must only be called at safepoint\");\n+    assert_locked_or_safepoint(Heap_lock);\n@@ -99,7 +82,0 @@\n-  \/\/ Support for MT garbage collection. See above comment.\n-  HeapWord* cas_allocate(size_t word_size) {\n-    HeapWord* res = cas_allocate_noexpand(word_size);\n-    return (res == NULL) ? expand_and_cas_allocate(word_size) : res;\n-  }\n-\n-  HeapWord* expand_and_allocate(size_t word_size);\n@@ -161,3 +137,4 @@\n-  \/\/ Allocation. We report all successful allocations to the size policy\n-  \/\/ Note that the perm gen does not use this method, and should not!\n-  HeapWord* allocate(size_t word_size);\n+  HeapWord* allocate(size_t word_size) {\n+    HeapWord* res = cas_allocate_noexpand(word_size);\n+    return (res == NULL) ? expand_and_cas_allocate(word_size) : res;\n+  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -197,1 +197,1 @@\n-            new_obj = (oop)old_gen()->cas_allocate(new_obj_size);\n+            new_obj = (oop)old_gen()->allocate(new_obj_size);\n@@ -203,1 +203,1 @@\n-            HeapWord* lab_base = old_gen()->cas_allocate(OldPLABSize);\n+            HeapWord* lab_base = old_gen()->allocate(OldPLABSize);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,0 @@\n-  friend class AdjoiningGenerations;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}