{"files":[{"patch":"@@ -103,0 +103,6 @@\n+static void update_garbage_words_in_hr(HeapRegion* hr, size_t garbage_words) {\n+  if (garbage_words != 0) {\n+    hr->note_self_forward_chunk_done(garbage_words * HeapWordSize);\n+  }\n+}\n+\n@@ -107,43 +113,0 @@\n-\/\/ Caches the currently accumulated number of garbage words found in this heap region.\n-\/\/ Avoids direct (frequent) atomic operations on the HeapRegion's garbage counter.\n-class G1RemoveSelfForwardsTask::RegionGarbageWordsCache {\n-  G1CollectedHeap* _g1h;\n-  const uint _uninitialized_idx;\n-  uint _region_idx;\n-  size_t _garbage_words;\n-\n-  void note_self_forwarding_removal_end_par() {\n-    _g1h->region_at(_region_idx)->note_self_forwarding_removal_end_par(_garbage_words * HeapWordSize);\n-  }\n-\n-  void flush() {\n-    if (_region_idx != _uninitialized_idx) {\n-      note_self_forwarding_removal_end_par();\n-    }\n-  }\n-\n-public:\n-  RegionGarbageWordsCache(G1CollectedHeap* g1h):\n-    _g1h(g1h),\n-    _uninitialized_idx(_g1h->max_regions()),\n-    _region_idx(_uninitialized_idx),\n-    _garbage_words(0) { }\n-\n-  ~RegionGarbageWordsCache() {\n-    flush();\n-  }\n-\n-  void add(uint region_idx, size_t garbage_words) {\n-    if (_region_idx == _uninitialized_idx) {\n-      _region_idx = region_idx;\n-      _garbage_words = garbage_words;\n-    } else if (_region_idx == region_idx) {\n-      _garbage_words += garbage_words;\n-    } else {\n-      note_self_forwarding_removal_end_par();\n-      _region_idx = region_idx;\n-      _garbage_words = garbage_words;\n-    }\n-  }\n-};\n-\n@@ -151,2 +114,1 @@\n-                                                     uint chunk_idx,\n-                                                     RegionGarbageWordsCache* cache) {\n+                                             uint chunk_idx) {\n@@ -180,1 +142,1 @@\n-    cache->add(region_idx, garbage_words);\n+    update_garbage_words_in_hr(hr, garbage_words);\n@@ -223,1 +185,2 @@\n-  cache->add(region_idx, garbage_words);\n+\n+  update_garbage_words_in_hr(hr, garbage_words);\n@@ -238,2 +201,0 @@\n-  RegionGarbageWordsCache region_marked_words_cache(_g1h);\n-\n@@ -243,1 +204,1 @@\n-      process_chunk(worker_id, chunk_idx, &region_marked_words_cache);\n+      process_chunk(worker_id, chunk_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":11,"deletions":50,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-  class RegionGarbageWordsCache;\n-  void process_chunk(uint worker_id, uint chunk_idx, RegionGarbageWordsCache* cache);\n+  void process_chunk(uint worker_id, uint chunk_idx);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    hr->note_self_forwarding_removal_start(state->in_concurrent_start_gc());\n+    hr->note_evacuation_failure(state->in_concurrent_start_gc());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureRegions.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -108,1 +108,4 @@\n-    _evac_failure_regions(evac_failure_regions) { }\n+    _evac_failure_regions(evac_failure_regions) {\n+\n+    _task.initialize();\n+  }\n@@ -112,1 +115,3 @@\n-    return _evac_failure_regions->num_regions_failed_evacuation() * G1PerRetainedRegionThreads;\n+\n+    return ((double)G1CollectedHeap::get_chunks_per_region() \/ G1RestoreRetainedRegionChunksPerWorker) *\n+      _evac_failure_regions->num_regions_failed_evacuation();\n@@ -118,4 +123,0 @@\n-\n-  void initialize() {\n-    _task.initialize();\n-  }\n@@ -139,2 +140,0 @@\n-\n-    restore_retained_regions_task->initialize();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -375,5 +375,4 @@\n-  product(uint, G1PerRetainedRegionThreads, 2, DIAGNOSTIC,                  \\\n-          \"The number of worker threads used for each retained \"            \\\n-          \"(evacuation failure) region, subject to ParallelGCThreads \"      \\\n-          \"constraint.\")                                                    \\\n-          range(1, 16)                                                      \\\n+  product(uint, G1RestoreRetainedRegionChunksPerWorker, 16, DIAGNOSTIC,     \\\n+          \"The number of chunks assigned per worker thread for \"            \\\n+          \"retained region restore purposes.\")                              \\\n+          range(1, 256)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/g1\/g1_globals.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-void HeapRegion::note_self_forwarding_removal_start(bool during_concurrent_start) {\n+void HeapRegion::note_evacuation_failure(bool during_concurrent_start) {\n@@ -294,1 +294,1 @@\n-void HeapRegion::note_self_forwarding_removal_end_par(size_t garbage_bytes) {\n+void HeapRegion::note_self_forward_chunk_done(size_t garbage_bytes) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -507,3 +507,3 @@\n-  \/\/ Notify the region that we are about to start processing\n-  \/\/ self-forwarded objects during evac failure handling.\n-  void note_self_forwarding_removal_start(bool during_concurrent_start);\n+  \/\/ Notify the region that an evacuation failure occurred for an object within this\n+  \/\/ region.\n+  void note_evacuation_failure(bool during_concurrent_start);\n@@ -513,1 +513,1 @@\n-  void note_self_forwarding_removal_end_par(size_t garbage_bytes);\n+  void note_self_forward_chunk_done(size_t garbage_bytes);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}