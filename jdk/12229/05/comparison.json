{"files":[{"patch":"@@ -222,0 +222,3 @@\n+# LeakSanitizer\n+JDKOPT_SETUP_LEAK_SANITIZER\n+\n","filename":"make\/autoconf\/configure.ac","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -443,0 +443,33 @@\n+###############################################################################\n+#\n+# LeakSanitizer\n+#\n+AC_DEFUN_ONCE([JDKOPT_SETUP_LEAK_SANITIZER],\n+[\n+  UTIL_ARG_ENABLE(NAME: lsan, DEFAULT: false, RESULT: LSAN_ENABLED,\n+      DESC: [enable LeakSanitizer],\n+      CHECK_AVAILABLE: [\n+        AC_MSG_CHECKING([if LeakSanitizer (lsan) is available])\n+        if test \"x$TOOLCHAIN_TYPE\" = \"xgcc\" ||\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+          AC_MSG_RESULT([yes])\n+        else\n+          AC_MSG_RESULT([no])\n+          AVAILABLE=false\n+        fi\n+      ],\n+      IF_ENABLED: [\n+        LSAN_CFLAGS=\"-fsanitize=leak -fno-omit-frame-pointer -DLEAK_SANITIZER\"\n+        LSAN_LDFLAGS=\"-fsanitize=leak\"\n+        JVM_CFLAGS=\"$JVM_CFLAGS $LSAN_CFLAGS\"\n+        JVM_LDFLAGS=\"$JVM_LDFLAGS $LSAN_LDFLAGS\"\n+        CFLAGS_JDKLIB=\"$CFLAGS_JDKLIB $LSAN_CFLAGS\"\n+        CFLAGS_JDKEXE=\"$CFLAGS_JDKEXE $LSAN_CFLAGS\"\n+        CXXFLAGS_JDKLIB=\"$CXXFLAGS_JDKLIB $LSAN_CFLAGS\"\n+        CXXFLAGS_JDKEXE=\"$CXXFLAGS_JDKEXE $LSAN_CFLAGS\"\n+        LDFLAGS_JDKLIB=\"$LDFLAGS_JDKLIB $LSAN_LDFLAGS\"\n+        LDFLAGS_JDKEXE=\"$LDFLAGS_JDKEXE $LSAN_LDFLAGS\"\n+      ])\n+  AC_SUBST(LSAN_ENABLED)\n+])\n+\n","filename":"make\/autoconf\/jdk-options.m4","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -451,0 +451,3 @@\n+# LeakSanitizer\n+LSAN_ENABLED:=@LSAN_ENABLED@\n+\n","filename":"make\/autoconf\/spec.gmk.in","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -153,0 +153,4 @@\n+  ifeq ($(LSAN_ENABLED), true)\n+    $1_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n+  endif\n+\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,5 @@\n-#ifndef LEAK_SANITIZER\n+#ifdef LEAK_SANITIZER\n+    \"leak_check_at_exit=0,\"\n+#else\n+    \/\/ ASan bundles LSan, however we only support LSan when it is explicitly requested during\n+    \/\/ configuration. Thus we disable it to match if it was not requested.\n@@ -56,1 +60,5 @@\n-    \"handle_segv=0\";\n+    \"print_suppressions=0,\"\n+    \"handle_segv=0,\"\n+    \/\/ See https:\/\/github.com\/google\/sanitizers\/issues\/1322. Hopefully this is resolved\n+    \/\/ at some point and we can remove this option.\n+    \"intercept_tls_get_addr=0\";\n","filename":"make\/data\/asan\/asan_default_options.c","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n","filename":"make\/data\/asan\/asan_default_options.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef LEAK_SANITIZER\n+#error \"Build misconfigured, preprocessor macro LEAK_SANITIZER should be defined\"\n+#endif\n+\n+#ifndef __has_attribute\n+#define __has_attribute(x) 0\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(visibility)\n+#define ATTRIBUTE_DEFAULT_VISIBILITY __attribute__((visibility(\"default\")))\n+#else\n+#define ATTRIBUTE_DEFAULT_VISIBILITY\n+#endif\n+\n+#if (defined(__GNUC__) && !defined(__clang__)) || __has_attribute(used)\n+#define ATTRIBUTE_USED __attribute__((used))\n+#else\n+#define ATTRIBUTE_USED\n+#endif\n+\n+\/\/ Override weak symbol exposed by LSan to override default options. This is called by LSan\n+\/\/ extremely early during library loading, before main is called.  We need to override the default\n+\/\/ options because LSan will perform leak checking at program exit. Unfortunately Hotspot does not\n+\/\/ shutdown cleanly at the moment and some leaks occur, we want to ignore these. Instead we\n+\/\/ explicitly perform leak checking early during JVM shutdown.\n+ATTRIBUTE_DEFAULT_VISIBILITY ATTRIBUTE_USED const char* __lsan_default_options() {\n+  return\n+    \"print_suppressions=0,\"\n+    \"leak_check_at_exit=0,\"\n+    \/\/ See https:\/\/github.com\/google\/sanitizers\/issues\/1322. Hopefully this is resolved\n+    \/\/ at some point and we can remove this option.\n+    \"intercept_tls_get_addr=0\";\n+}\n+\n+\/\/ Override weak symbol exposed by LSan to override default suppressions. This is called by LSan\n+\/\/ extremely early during library loading, before main is called.\n+ATTRIBUTE_DEFAULT_VISIBILITY ATTRIBUTE_USED const char* __lsan_default_suppressions() {\n+  return\n+    \/\/ Remove after JDK-8297688 is resolved.\n+    \"leak:^JLI_MemAlloc$\\n\"\n+    \"leak:^JLI_StringDup$\\n\";\n+}\n","filename":"make\/data\/lsan\/lsan_default_options.c","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#include \".\/asan_default_options.c\"\n+#include \".\/lsan_default_options.c\"\n","filename":"make\/data\/lsan\/lsan_default_options.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"make\/data\/asan\/asan_default_options.cpp","status":"copied"},{"patch":"@@ -35,0 +35,4 @@\n+ifeq ($(LSAN_ENABLED), true)\n+  GTEST_LAUNCHER_SRC += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.cpp\n+endif\n+\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1524,1 +1524,7 @@\n-  BUILD_HOTSPOT_JTREG_EXTRA_FILES := $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+  BUILD_HOTSPOT_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+endif\n+\n+ifeq ($(LSAN_ENABLED), true)\n+  # Any executable which launches the JVM and uses a custom launcher needs to explicitly link in the\n+  # default LSan options.\n+  BUILD_HOTSPOT_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -138,1 +138,7 @@\n-  BUILD_JDK_JTREG_EXTRA_FILES := $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+  BUILD_JDK_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/asan\/asan_default_options.c\n+endif\n+\n+ifeq ($(LSAN_ENABLED), true)\n+  # Any executable which launches the JVM and uses a custom launcher needs to explicitly link in the\n+  # default LSan options.\n+  BUILD_JDK_JTREG_EXTRA_FILES += $(TOPDIR)\/make\/data\/lsan\/lsan_default_options.c\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -53,0 +54,2 @@\n+  \/\/ Ignore leaked arena, it is used by ValueType and Interval during initialization.\n+  LSAN_IGNORE_OBJECT(arena);\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -993,0 +994,2 @@\n+    \/\/ Register CDS memory region with LSan.\n+    LSAN_REGISTER_ROOT_REGION(cds_base, cds_end - cds_base);\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -332,0 +333,3 @@\n+  \/\/ Register CodeHeaps with LSan as we sometimes embed pointers to malloc memory.\n+  LSAN_REGISTER_ROOT_REGION(rs.base(), rs.size());\n+\n@@ -1197,0 +1201,2 @@\n+    \/\/ Register CodeHeaps with LSan as we sometimes embed pointers to malloc memory.\n+    LSAN_REGISTER_ROOT_REGION(rs.base(), rs.size());\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -275,0 +276,3 @@\n+    \/\/ LSan appears unable to follow malloc-based memory consistently when embedded as an immediate\n+    \/\/ in generated machine code. So we have to ignore it.\n+    LSAN_IGNORE_OBJECT(holder);\n@@ -445,0 +449,3 @@\n+      \/\/ LSan appears unable to follow malloc-based memory consistently when embedded as an\n+      \/\/ immediate in generated machine code. So we have to ignore it.\n+      LSAN_IGNORE_OBJECT(holder);\n","filename":"src\/hotspot\/share\/code\/compiledIC.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -242,0 +243,4 @@\n+\n+  \/\/ Register memory region related to Metaspace. The Metaspace contains lots of pointers to malloc\n+  \/\/ memory.\n+  LSAN_REGISTER_ROOT_REGION(rs.base(), rs.size());\n@@ -273,0 +278,3 @@\n+  \/\/ Unregister memory region related to Metaspace.\n+  LSAN_UNREGISTER_ROOT_REGION(_rs.base(), _rs.size());\n+\n@@ -278,0 +286,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/virtualSpaceNode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -78,0 +78,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -754,1 +755,5 @@\n-  CompiledICProtectionBehaviour::set_current(new DefaultICProtectionBehaviour());\n+  DefaultICProtectionBehaviour* protection_behavior = new DefaultICProtectionBehaviour();\n+  \/\/ Ignore leak of DefaultICProtectionBehaviour. It is overriden by some GC implementations and the\n+  \/\/ pointer is leaked once.\n+  LSAN_IGNORE_OBJECT(protection_behavior);\n+  CompiledICProtectionBehaviour::set_current(protection_behavior);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -986,0 +987,2 @@\n+    \/\/ LSan appears unable to keep track of qname, ignore it.\n+    LSAN_IGNORE_OBJECT(qname);\n","filename":"src\/hotspot\/share\/prims\/methodHandles.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/gcHeapSummary.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -126,0 +128,8 @@\n+#ifdef LEAK_SANITIZER\n+  {\n+    \/\/ Register the Java heap with LSan.\n+    VirtualSpaceSummary summary = Universe::heap()->create_heap_space_summary();\n+    LSAN_REGISTER_ROOT_REGION(summary.start(), summary.reserved_size());\n+  }\n+#endif \/\/ LEAK_SANITIZER\n+\n@@ -186,0 +196,7 @@\n+#ifdef LEAK_SANITIZER\n+    {\n+      \/\/ Unregister the Java heap with LSan.\n+      VirtualSpaceSummary summary = Universe::heap()->create_heap_space_summary();\n+      LSAN_UNREGISTER_ROOT_REGION(summary.start(), summary.reserved_size());\n+    }\n+#endif \/\/ LEAK_SANITIZER\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -419,0 +420,24 @@\n+  \/\/ At this point only one thread is executing this logic. Any other threads\n+  \/\/ attempting to invoke before_exit() will wait above and return early once\n+  \/\/ this thread finishes before_exit().\n+\n+  \/\/ Do not add any additional shutdown logic between the above mutex logic and\n+  \/\/ leak sanitizer logic below. Any additional shutdown code which performs some\n+  \/\/ cleanup should be added after the leak sanitizer logic below.\n+\n+#ifdef LEAK_SANITIZER\n+  \/\/ If we are built with LSan, we need to perform leak checking. If we are\n+  \/\/ terminating normally, not halting and no VM error, we perform a normal\n+  \/\/ leak check which terminates if leaks are found. If we are not terminating\n+  \/\/ normally, halting or VM error, we perform a recoverable leak check which\n+  \/\/ prints leaks but will not terminate.\n+  if (!halt && !VMError::is_error_reported()) {\n+    LSAN_DO_LEAK_CHECK();\n+  } else {\n+    \/\/ Ignore the return value.\n+    static_cast<void>(LSAN_DO_RECOVERABLE_LEAK_CHECK());\n+  }\n+#endif\n+\n+  \/\/ Actual shutdown logic begins here.\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"sanitizers\/leak.hpp\"\n@@ -288,0 +289,1 @@\n+    LSAN_IGNORE_OBJECT(_watcher_thread);\n","filename":"src\/hotspot\/share\/runtime\/nonJavaThread.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2023, Google and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_SANITIZERS_LEAK_HPP\n+#define SHARE_SANITIZERS_LEAK_HPP\n+\n+#ifdef LEAK_SANITIZER\n+#include <sanitizer\/lsan_interface.h>\n+#endif\n+\n+\/\/ LSAN_REGISTER_ROOT_REGION()\/LSAN_UNREGISTER_ROOT_REGION()\n+\/\/\n+\/\/ Register\/unregister regions of memory with LSan. LSan scans these regions looking for\n+\/\/ pointers to malloc memory. This is only necessary when pointers to malloc memory are\n+\/\/ located in memory that is not returned by malloc, such as mapped memory. LSan will\n+\/\/ skip inaccessible parts of the region, such as those that are not readable.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_REGISTER_ROOT_REGION(addr, size) __lsan_register_root_region((addr), (size))\n+#define LSAN_UNREGISTER_ROOT_REGION(addr, size) __lsan_unregister_root_region((addr), (size))\n+#else\n+#define LSAN_REGISTER_ROOT_REGION(addr, size) \\\n+  do {                                        \\\n+    if (false) {                              \\\n+      ((void) (addr));                        \\\n+      ((void) (size));                        \\\n+    }                                         \\\n+  } while (false)\n+#define LSAN_UNREGISTER_ROOT_REGION(addr, size) \\\n+  do {                                          \\\n+    if (false) {                                \\\n+      ((void) (addr));                          \\\n+      ((void) (size));                          \\\n+    }                                           \\\n+  } while (false)\n+#endif\n+\n+\/\/ LSAN_IGNORE_OBJECT()\n+\/\/\n+\/\/ Causes LSan to ignore any leaks related to the object. Should only be used\n+\/\/ in cases where leaks are intentional or where LSan will be unable to discover\n+\/\/ pointers to object, for example due to pointers being stored unaligned.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_IGNORE_OBJECT(object) __lsan_ignore_object(object)\n+#else\n+#define LSAN_IGNORE_OBJECT(object) \\\n+  do {                             \\\n+    if (false) {                   \\\n+      ((void) (object));           \\\n+    }                              \\\n+  } while (false)\n+#endif\n+\n+\/\/ LSAN_DO_LEAK_CHECK()\n+\/\/\n+\/\/ Perform a leak check, terminating the process if leaks are found. LSan will\n+\/\/ skip performing leak checks at process exit and further calls will be ignored.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_DO_LEAK_CHECK() __lsan_do_leak_check()\n+#else\n+#define LSAN_DO_LEAK_CHECK() ((void) 0)\n+#endif\n+\n+\/\/ LSAN_DO_RECOVERABLE_LEAK_CHECK()\n+\/\/\n+\/\/ Perform a leak check without terminating if leaks are found.\n+#ifdef LEAK_SANITIZER\n+#define LSAN_DO_RECOVERABLE_LEAK_CHECK() __lsan_do_recoverable_leak_check()\n+#else\n+#define LSAN_DO_RECOVERABLE_LEAK_CHECK() ((int) 0)\n+#endif\n+\n+#endif \/\/ SHARE_SANITIZERS_ADDRESS_HPP\n","filename":"src\/hotspot\/share\/sanitizers\/leak.hpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"}]}