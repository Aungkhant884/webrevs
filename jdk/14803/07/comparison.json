{"files":[{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/arena.hpp\"\n@@ -46,3 +47,0 @@\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ ChunkPool implementation\n-\n@@ -52,3 +50,0 @@\n-  Chunk*       _first;        \/\/ first cached Chunk; its first word points to next chunk\n-  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n-\n@@ -56,1 +51,1 @@\n-  static const int _num_pools = 4;\n+  static constexpr int _num_pools = 4;\n@@ -59,2 +54,2 @@\n- public:\n-  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n+  Chunk*       _first;\n+  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n@@ -62,2 +57,2 @@\n-  \/\/ Allocate a chunk from the pool; returns null if pool is empty.\n-  Chunk* allocate() {\n+  \/\/ Returns null if pool is empty.\n+  Chunk* take_from_pool() {\n@@ -71,3 +66,1 @@\n-\n-  \/\/ Return a chunk to the pool\n-  void free(Chunk* chunk) {\n+  void return_to_pool(Chunk* chunk) {\n@@ -80,1 +73,1 @@\n-  \/\/ Prune the pool\n+  \/\/ Clear this pool of all contained chunks\n@@ -95,7 +88,0 @@\n-  static void clean() {\n-    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n-    for (int i = 0; i < _num_pools; i++) {\n-      _pools[i].prune();\n-    }\n-  }\n-\n@@ -112,7 +98,2 @@\n-};\n-\n-ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n-\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ ChunkPoolCleaner implementation\n-\/\/\n+public:\n+  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n@@ -120,2 +101,6 @@\n-class ChunkPoolCleaner : public PeriodicTask {\n-  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n+  static void clean() {\n+    NativeHeapTrimmer::SuspendMark sm(\"chunk pool cleaner\");\n+    for (int i = 0; i < _num_pools; i++) {\n+      _pools[i].prune();\n+    }\n+  }\n@@ -123,5 +108,3 @@\n- public:\n-   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n-   void task() {\n-     ChunkPool::clean();\n-   }\n+  \/\/ Returns an initialized and null-terminated Chunk of requested size\n+  static Chunk* allocate_chunk(size_t length, AllocFailType alloc_failmode);\n+  static void deallocate_chunk(Chunk* p);\n@@ -130,4 +113,1 @@\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ Chunk implementation\n-\n-void* Chunk::operator new (size_t sizeofChunk, AllocFailType alloc_failmode, size_t length) throw() {\n+Chunk* ChunkPool::allocate_chunk(size_t length, AllocFailType alloc_failmode) {\n@@ -152,1 +132,0 @@\n-  assert(sizeofChunk == sizeof(Chunk), \"weird request size\");\n@@ -157,0 +136,1 @@\n+  Chunk* chunk = nullptr;\n@@ -158,1 +138,1 @@\n-    Chunk* c = pool->allocate();\n+    Chunk* c = pool->take_from_pool();\n@@ -161,1 +141,1 @@\n-      return c;\n+      chunk = c;\n@@ -164,5 +144,8 @@\n-  \/\/ Either the pool was empty, or this is a non-standard length. Allocate a new Chunk from C-heap.\n-  size_t bytes = ARENA_ALIGN(sizeofChunk) + length;\n-  void* p = os::malloc(bytes, mtChunk, CALLER_PC);\n-  if (p == nullptr && alloc_failmode == AllocFailStrategy::EXIT_OOM) {\n-    vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, \"Chunk::new\");\n+  if (chunk == nullptr) {\n+    \/\/ Either the pool was empty, or this is a non-standard length. Allocate a new Chunk from C-heap.\n+    size_t bytes = ARENA_ALIGN(sizeof(Chunk)) + length;\n+    void* p = os::malloc(bytes, mtChunk, CALLER_PC);\n+    if (p == nullptr && alloc_failmode == AllocFailStrategy::EXIT_OOM) {\n+      vm_exit_out_of_memory(bytes, OOM_MALLOC_ERROR, \"Chunk::new\");\n+    }\n+    chunk = (Chunk*)p;\n@@ -170,0 +153,1 @@\n+  ::new(chunk) Chunk(length);\n@@ -171,2 +155,2 @@\n-  assert(is_aligned(p, ARENA_AMALLOC_ALIGNMENT), \"Chunk start address misaligned.\");\n-  return p;\n+  assert(is_aligned(chunk, ARENA_AMALLOC_ALIGNMENT), \"Chunk start address misaligned.\");\n+  return chunk;\n@@ -175,1 +159,1 @@\n-void Chunk::operator delete(void* p) {\n+void ChunkPool::deallocate_chunk(Chunk* c) {\n@@ -177,1 +161,0 @@\n-  Chunk* c = (Chunk*)p;\n@@ -180,1 +163,1 @@\n-    pool->free(c);\n+    pool->return_to_pool(c);\n@@ -187,3 +170,1 @@\n-Chunk::Chunk(size_t length) : _len(length) {\n-  _next = nullptr;         \/\/ Chain on the linked list\n-}\n+ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n@@ -191,10 +172,2 @@\n-void Chunk::chop() {\n-  Chunk *k = this;\n-  while( k ) {\n-    Chunk *tmp = k->next();\n-    \/\/ clear out this chunk (to detect allocation bugs)\n-    if (ZapResourceArea) memset(k->bottom(), badResourceValue, k->length());\n-    delete k;                   \/\/ Free chunk (was malloc'd)\n-    k = tmp;\n-  }\n-}\n+class ChunkPoolCleaner : public PeriodicTask {\n+  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n@@ -202,4 +175,6 @@\n-void Chunk::next_chop() {\n-  _next->chop();\n-  _next = nullptr;\n-}\n+ public:\n+   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n+   void task() {\n+     ChunkPool::clean();\n+   }\n+};\n@@ -207,1 +182,1 @@\n-void Chunk::start_chunk_pool_cleaner_task() {\n+void Arena::start_chunk_pool_cleaner_task() {\n@@ -217,1 +192,19 @@\n-\/\/------------------------------Arena------------------------------------------\n+Chunk::Chunk(size_t length) : _len(length) {\n+  _next = nullptr;         \/\/ Chain on the linked list\n+}\n+\n+void Chunk::chop(Chunk* k) {\n+  while (k != nullptr) {\n+    Chunk* tmp = k->next();\n+    \/\/ clear out this chunk (to detect allocation bugs)\n+    if (ZapResourceArea) memset(k->bottom(), badResourceValue, k->length());\n+    ChunkPool::deallocate_chunk(k);\n+    k = tmp;\n+  }\n+}\n+\n+void Chunk::next_chop(Chunk* k) {\n+  assert(k != nullptr && k->_next != nullptr, \"must be non-null\");\n+  Chunk::chop(k->_next);\n+  k->_next = nullptr;\n+}\n@@ -221,1 +214,2 @@\n-  _first = _chunk = new (AllocFailStrategy::EXIT_OOM, init_size) Chunk(init_size);\n+  _chunk = ChunkPool::allocate_chunk(init_size, AllocFailStrategy::EXIT_OOM);\n+  _first = _chunk;\n@@ -229,1 +223,2 @@\n-  _first = _chunk = new (AllocFailStrategy::EXIT_OOM, Chunk::init_size) Chunk(Chunk::init_size);\n+  _chunk = ChunkPool::allocate_chunk(Chunk::init_size, AllocFailStrategy::EXIT_OOM);\n+  _first = _chunk;\n@@ -247,1 +242,1 @@\n-    _first->chop();\n+    Chunk::chop(_first);\n@@ -265,1 +260,1 @@\n-  Chunk *k = _first;\n+  Chunk* k = _first;\n@@ -283,2 +278,2 @@\n-  Chunk *k = _chunk;            \/\/ Get filled-up chunk address\n-  _chunk = new (alloc_failmode, len) Chunk(len);\n+  Chunk* k = _chunk;            \/\/ Get filled-up chunk address\n+  _chunk = ChunkPool::allocate_chunk(len, alloc_failmode);\n@@ -290,2 +285,6 @@\n-  if (k) k->set_next(_chunk);   \/\/ Append new chunk to end of linked list\n-  else _first = _chunk;\n+\n+  if (k != nullptr) {\n+    k->set_next(_chunk);        \/\/ Append new chunk to end of linked list\n+  } else {\n+    _first = _chunk;\n+  }\n@@ -346,1 +345,1 @@\n-  for (Chunk *c = _first; c; c = c->next()) {\n+  for (Chunk* c = _first; c; c = c->next()) {\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":80,"deletions":81,"binary":false,"changes":161,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/------------------------------Chunk------------------------------------------\n+\n@@ -42,1 +42,1 @@\n-class Chunk: CHeapObj<mtChunk> {\n+class Chunk {\n@@ -47,3 +47,6 @@\n- public:\n-  void* operator new(size_t size, AllocFailType alloc_failmode, size_t length) throw();\n-  void  operator delete(void* p);\n+public:\n+  NONCOPYABLE(Chunk);\n+\n+  void operator delete(void*) = delete;\n+  void* operator new(size_t) = delete;\n+\n@@ -70,2 +73,2 @@\n-  void chop();                  \/\/ Chop this chunk\n-  void next_chop();             \/\/ Chop next chunk\n+  static void chop(Chunk* chunk);                  \/\/ Chop this chunk\n+  static void next_chop(Chunk* chunk);             \/\/ Chop next chunk\n@@ -82,3 +85,0 @@\n-\n-  \/\/ Start the chunk_pool cleaner task\n-  static void start_chunk_pool_cleaner_task();\n@@ -87,1 +87,0 @@\n-\/\/------------------------------Arena------------------------------------------\n@@ -97,3 +96,4 @@\n-  Chunk *_first;                \/\/ First chunk\n-  Chunk *_chunk;                \/\/ current chunk\n-  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n+  Chunk* _first;                \/\/ First chunk\n+  Chunk* _chunk;                \/\/ current chunk\n+  char* _hwm;                   \/\/ High water mark\n+  char* _max;                   \/\/ and max in current chunk\n@@ -116,0 +116,3 @@\n+  \/\/ Start the chunk_pool cleaner task\n+  static void start_chunk_pool_cleaner_task();\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-      state._chunk->next_chop();\n+      Chunk::next_chop(state._chunk);\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  _chunk->next_chop();\n+  Chunk::next_chop(_chunk);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -683,1 +683,1 @@\n-  Chunk::start_chunk_pool_cleaner_task();\n+  Arena::start_chunk_pool_cleaner_task();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}