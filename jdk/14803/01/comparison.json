{"files":[{"patch":"@@ -45,3 +45,0 @@\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ ChunkPool implementation\n-\n@@ -51,3 +48,0 @@\n-  Chunk*       _first;        \/\/ first cached Chunk; its first word points to next chunk\n-  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n-\n@@ -58,2 +52,2 @@\n- public:\n-  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n+  Chunk*       _first;        \/\/ first cached Chunk; its first word points to next chunk\n+  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n@@ -62,9 +56,1 @@\n-  Chunk* allocate() {\n-    ThreadCritical tc;\n-    Chunk* c = _first;\n-    if (_first != nullptr) {\n-      _first = _first->next();\n-    }\n-    return c;\n-  }\n-\n+  Chunk* take_from_pool();\n@@ -72,7 +58,1 @@\n-  void free(Chunk* chunk) {\n-    assert(chunk->length() == _size, \"wrong pool for this chunk\");\n-    ThreadCritical tc;\n-    chunk->set_next(_first);\n-    _first = chunk;\n-  }\n-\n+  void return_to_pool(Chunk* chunk);\n@@ -80,19 +60,1 @@\n-  void prune() {\n-    \/\/ Free all chunks while in ThreadCritical lock\n-    \/\/ so NMT adjustment is stable.\n-    ThreadCritical tc;\n-    Chunk* cur = _first;\n-    Chunk* next = nullptr;\n-    while (cur != nullptr) {\n-      next = cur->next();\n-      os::free(cur);\n-      cur = next;\n-    }\n-    _first = nullptr;\n-  }\n-\n-  static void clean() {\n-    for (int i = 0; i < _num_pools; i++) {\n-      _pools[i].prune();\n-    }\n-  }\n+  void prune();\n@@ -101,8 +63,1 @@\n-  static ChunkPool* get_pool_for_size(size_t size) {\n-    for (int i = 0; i < _num_pools; i++) {\n-      if (_pools[i]._size == size) {\n-        return _pools + i;\n-      }\n-    }\n-    return nullptr;\n-  }\n+  static ChunkPool* get_pool_for_size(size_t size);\n@@ -110,0 +65,6 @@\n+public:\n+  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n+\n+  static void clean();\n+  static Chunk* allocate_chunk(AllocFailType alloc_failmode, size_t length);\n+  static void deallocate_chunk(Chunk* p);\n@@ -112,1 +73,0 @@\n-ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n@@ -114,3 +74,8 @@\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ ChunkPoolCleaner implementation\n-\/\/\n+Chunk* ChunkPool::take_from_pool() {\n+  ThreadCritical tc;\n+  Chunk* c = _first;\n+  if (_first != nullptr) {\n+    _first = _first->next();\n+  }\n+  return c;\n+}\n@@ -118,2 +83,6 @@\n-class ChunkPoolCleaner : public PeriodicTask {\n-  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n+void ChunkPool::return_to_pool(Chunk* chunk) {\n+  assert(chunk->length() == _size, \"wrong pool for this chunk\");\n+  ThreadCritical tc;\n+  chunk->set_next(_first);\n+  _first = chunk;\n+}\n@@ -121,6 +90,8 @@\n- public:\n-   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n-   void task() {\n-     ChunkPool::clean();\n-   }\n-};\n+ChunkPool* ChunkPool::get_pool_for_size(size_t size) {\n+  for (int i = 0; i < _num_pools; i++) {\n+    if (_pools[i]._size == size) {\n+      return _pools + i;\n+    }\n+  }\n+  return nullptr;\n+}\n@@ -128,2 +99,19 @@\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ Chunk implementation\n+void ChunkPool::prune() {\n+  \/\/ Free all chunks while in ThreadCritical lock\n+  \/\/ so NMT adjustment is stable.\n+  ThreadCritical tc;\n+  Chunk* cur = _first;\n+  Chunk* next = nullptr;\n+  while (cur != nullptr) {\n+    next = cur->next();\n+    os::free(cur);\n+    cur = next;\n+  }\n+  _first = nullptr;\n+}\n+\n+void ChunkPool::clean() {\n+  for (int i = 0; i < _num_pools; i++) {\n+    _pools[i].prune();\n+  }\n+}\n@@ -131,1 +119,1 @@\n-void* Chunk::operator new (size_t sizeofChunk, AllocFailType alloc_failmode, size_t length) throw() {\n+Chunk* ChunkPool::allocate_chunk(AllocFailType alloc_failmode, size_t length) {\n@@ -150,1 +138,0 @@\n-  assert(sizeofChunk == sizeof(Chunk), \"weird request size\");\n@@ -156,1 +143,1 @@\n-    Chunk* c = pool->allocate();\n+    Chunk* c = pool->take_from_pool();\n@@ -163,1 +150,1 @@\n-  size_t bytes = ARENA_ALIGN(sizeofChunk) + length;\n+  size_t bytes = ARENA_ALIGN(sizeof(Chunk)) + length;\n@@ -168,0 +155,1 @@\n+  Chunk* chunk = ::new(p) Chunk(length);\n@@ -170,1 +158,1 @@\n-  return p;\n+  return chunk;\n@@ -173,1 +161,1 @@\n-void Chunk::operator delete(void* p) {\n+void ChunkPool::deallocate_chunk(Chunk* p) {\n@@ -178,1 +166,1 @@\n-    pool->free(c);\n+    pool->return_to_pool(c);\n@@ -185,3 +173,1 @@\n-Chunk::Chunk(size_t length) : _len(length) {\n-  _next = nullptr;         \/\/ Chain on the linked list\n-}\n+ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n@@ -189,10 +175,2 @@\n-void Chunk::chop() {\n-  Chunk *k = this;\n-  while( k ) {\n-    Chunk *tmp = k->next();\n-    \/\/ clear out this chunk (to detect allocation bugs)\n-    if (ZapResourceArea) memset(k->bottom(), badResourceValue, k->length());\n-    delete k;                   \/\/ Free chunk (was malloc'd)\n-    k = tmp;\n-  }\n-}\n+class ChunkPoolCleaner : public PeriodicTask {\n+  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n@@ -200,4 +178,6 @@\n-void Chunk::next_chop() {\n-  _next->chop();\n-  _next = nullptr;\n-}\n+ public:\n+   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n+   void task() {\n+     ChunkPool::clean();\n+   }\n+};\n@@ -205,1 +185,1 @@\n-void Chunk::start_chunk_pool_cleaner_task() {\n+void Arena::start_chunk_pool_cleaner_task() {\n@@ -215,1 +195,19 @@\n-\/\/------------------------------Arena------------------------------------------\n+Chunk::Chunk(size_t length) : _len(length) {\n+  _next = nullptr;         \/\/ Chain on the linked list\n+}\n+\n+void Chunk::chop(Chunk* k) {\n+  while (k != nullptr) {\n+    Chunk *tmp = k->next();\n+    \/\/ clear out this chunk (to detect allocation bugs)\n+    if (ZapResourceArea) memset(k->bottom(), badResourceValue, k->length());\n+    ChunkPool::deallocate_chunk(k);\n+    k = tmp;\n+  }\n+}\n+\n+void Chunk::next_chop(Chunk* k) {\n+  assert(k != nullptr && k->_next != nullptr, \"must be non-null\");\n+  Chunk::chop(k->_next);\n+  k->_next = nullptr;\n+}\n@@ -219,1 +217,1 @@\n-  _first = _chunk = new (AllocFailStrategy::EXIT_OOM, init_size) Chunk(init_size);\n+  _first = _chunk = ChunkPool::allocate_chunk(AllocFailStrategy::EXIT_OOM, init_size);\n@@ -227,1 +225,1 @@\n-  _first = _chunk = new (AllocFailStrategy::EXIT_OOM, Chunk::init_size) Chunk(Chunk::init_size);\n+  _first = _chunk = ChunkPool::allocate_chunk(AllocFailStrategy::EXIT_OOM, Chunk::init_size);\n@@ -245,1 +243,1 @@\n-    _first->chop();\n+    Chunk::chop(_first);\n@@ -282,1 +280,1 @@\n-  _chunk = new (alloc_failmode, len) Chunk(len);\n+  _chunk = ChunkPool::allocate_chunk(alloc_failmode, len);\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":93,"deletions":95,"binary":false,"changes":188,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/------------------------------Chunk------------------------------------------\n+\n@@ -42,1 +42,1 @@\n-class Chunk: CHeapObj<mtChunk> {\n+class Chunk {\n@@ -48,2 +48,0 @@\n-  void* operator new(size_t size, AllocFailType alloc_failmode, size_t length) throw();\n-  void  operator delete(void* p);\n@@ -70,2 +68,2 @@\n-  void chop();                  \/\/ Chop this chunk\n-  void next_chop();             \/\/ Chop next chunk\n+  static void chop(Chunk* chunk);                  \/\/ Chop this chunk\n+  static void next_chop(Chunk* chunk);             \/\/ Chop next chunk\n@@ -82,3 +80,0 @@\n-\n-  \/\/ Start the chunk_pool cleaner task\n-  static void start_chunk_pool_cleaner_task();\n@@ -87,1 +82,0 @@\n-\/\/------------------------------Arena------------------------------------------\n@@ -97,3 +91,4 @@\n-  Chunk *_first;                \/\/ First chunk\n-  Chunk *_chunk;                \/\/ current chunk\n-  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n+  Chunk* _first;                \/\/ First chunk\n+  Chunk* _chunk;                \/\/ current chunk\n+  char* _hwm;                   \/\/ High water mark\n+  char* _max;                   \/\/ and max in current chunk\n@@ -116,0 +111,3 @@\n+  \/\/ Start the chunk_pool cleaner task\n+  static void start_chunk_pool_cleaner_task();\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-      state._chunk->next_chop();\n+      Chunk::next_chop(state._chunk);\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  _chunk->next_chop();\n+  Chunk::next_chop(_chunk);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-  Chunk::start_chunk_pool_cleaner_task();\n+  Arena::start_chunk_pool_cleaner_task();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}