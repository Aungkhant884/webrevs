{"files":[{"patch":"@@ -45,24 +45,5 @@\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ ChunkPool implementation\n-\n-\/\/ MT-safe pool of same-sized chunks to reduce malloc\/free thrashing\n-\/\/ NB: not using Mutex because pools are used before Threads are initialized\n-class ChunkPool {\n-  Chunk*       _first;        \/\/ first cached Chunk; its first word points to next chunk\n-  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n-\n-  \/\/ Our four static pools\n-  static const int _num_pools = 4;\n-  static ChunkPool _pools[_num_pools];\n-\n- public:\n-  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n-\n-  \/\/ Allocate a chunk from the pool; returns null if pool is empty.\n-  Chunk* allocate() {\n-    ThreadCritical tc;\n-    Chunk* c = _first;\n-    if (_first != nullptr) {\n-      _first = _first->next();\n-    }\n-    return c;\n+Chunk* ChunkPool::take_from_pool() {\n+  ThreadCritical tc;\n+  Chunk* c = _first;\n+  if (_first != nullptr) {\n+    _first = _first->next();\n@@ -70,0 +51,2 @@\n+  return c;\n+}\n@@ -71,7 +54,6 @@\n-  \/\/ Return a chunk to the pool\n-  void free(Chunk* chunk) {\n-    assert(chunk->length() == _size, \"wrong pool for this chunk\");\n-    ThreadCritical tc;\n-    chunk->set_next(_first);\n-    _first = chunk;\n-  }\n+void ChunkPool::return_to_pool(Chunk* chunk) {\n+  assert(chunk->length() == _size, \"wrong pool for this chunk\");\n+  ThreadCritical tc;\n+  chunk->set_next(_first);\n+  _first = chunk;\n+}\n@@ -79,11 +61,4 @@\n-  \/\/ Prune the pool\n-  void prune() {\n-    \/\/ Free all chunks while in ThreadCritical lock\n-    \/\/ so NMT adjustment is stable.\n-    ThreadCritical tc;\n-    Chunk* cur = _first;\n-    Chunk* next = nullptr;\n-    while (cur != nullptr) {\n-      next = cur->next();\n-      os::free(cur);\n-      cur = next;\n+ChunkPool* ChunkPool::get_pool_for_size(size_t size) {\n+  for (int i = 0; i < _num_pools; i++) {\n+    if (_pools[i]._size == size) {\n+      return _pools + i;\n@@ -91,1 +66,0 @@\n-    _first = nullptr;\n@@ -93,0 +67,2 @@\n+  return nullptr;\n+}\n@@ -94,4 +70,10 @@\n-  static void clean() {\n-    for (int i = 0; i < _num_pools; i++) {\n-      _pools[i].prune();\n-    }\n+void ChunkPool::prune() {\n+  \/\/ Free all chunks while in ThreadCritical lock\n+  \/\/ so NMT adjustment is stable.\n+  ThreadCritical tc;\n+  Chunk* cur = _first;\n+  Chunk* next = nullptr;\n+  while (cur != nullptr) {\n+    next = cur->next();\n+    os::free(cur);\n+    cur = next;\n@@ -99,0 +81,2 @@\n+  _first = nullptr;\n+}\n@@ -100,8 +84,3 @@\n-  \/\/ Given a (inner payload) size, return the pool responsible for it, or null if the size is non-standard\n-  static ChunkPool* get_pool_for_size(size_t size) {\n-    for (int i = 0; i < _num_pools; i++) {\n-      if (_pools[i]._size == size) {\n-        return _pools + i;\n-      }\n-    }\n-    return nullptr;\n+void ChunkPool::clean() {\n+  for (int i = 0; i < _num_pools; i++) {\n+    _pools[i].prune();\n@@ -109,0 +88,1 @@\n+}\n@@ -110,22 +90,1 @@\n-};\n-\n-ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n-\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ ChunkPoolCleaner implementation\n-\/\/\n-\n-class ChunkPoolCleaner : public PeriodicTask {\n-  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n-\n- public:\n-   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n-   void task() {\n-     ChunkPool::clean();\n-   }\n-};\n-\n-\/\/--------------------------------------------------------------------------------------\n-\/\/ Chunk implementation\n-\n-void* Chunk::operator new (size_t sizeofChunk, AllocFailType alloc_failmode, size_t length) throw() {\n+Chunk* ChunkPool::allocate_chunk(AllocFailType alloc_failmode, size_t length) {\n@@ -150,1 +109,0 @@\n-  assert(sizeofChunk == sizeof(Chunk), \"weird request size\");\n@@ -156,1 +114,1 @@\n-    Chunk* c = pool->allocate();\n+    Chunk* c = pool->take_from_pool();\n@@ -163,1 +121,1 @@\n-  size_t bytes = ARENA_ALIGN(sizeofChunk) + length;\n+  size_t bytes = ARENA_ALIGN(sizeof(Chunk)) + length;\n@@ -168,0 +126,1 @@\n+  Chunk* chunk = ::new(p) Chunk(length);\n@@ -170,1 +129,1 @@\n-  return p;\n+  return chunk;\n@@ -173,1 +132,1 @@\n-void Chunk::operator delete(void* p) {\n+void ChunkPool::deallocate_chunk(Chunk* p) {\n@@ -178,1 +137,1 @@\n-    pool->free(c);\n+    pool->return_to_pool(c);\n@@ -185,3 +144,1 @@\n-Chunk::Chunk(size_t length) : _len(length) {\n-  _next = nullptr;         \/\/ Chain on the linked list\n-}\n+ChunkPool ChunkPool::_pools[] = { Chunk::size, Chunk::medium_size, Chunk::init_size, Chunk::tiny_size };\n@@ -189,10 +146,2 @@\n-void Chunk::chop() {\n-  Chunk *k = this;\n-  while( k ) {\n-    Chunk *tmp = k->next();\n-    \/\/ clear out this chunk (to detect allocation bugs)\n-    if (ZapResourceArea) memset(k->bottom(), badResourceValue, k->length());\n-    delete k;                   \/\/ Free chunk (was malloc'd)\n-    k = tmp;\n-  }\n-}\n+class ChunkPoolCleaner : public PeriodicTask {\n+  static const int cleaning_interval = 5000; \/\/ cleaning interval in ms\n@@ -200,4 +149,6 @@\n-void Chunk::next_chop() {\n-  _next->chop();\n-  _next = nullptr;\n-}\n+ public:\n+   ChunkPoolCleaner() : PeriodicTask(cleaning_interval) {}\n+   void task() {\n+     ChunkPool::clean();\n+   }\n+};\n@@ -205,1 +156,1 @@\n-void Chunk::start_chunk_pool_cleaner_task() {\n+void ChunkPool::start_chunk_pool_cleaner_task() {\n@@ -215,1 +166,19 @@\n-\/\/------------------------------Arena------------------------------------------\n+Chunk::Chunk(size_t length) : _len(length) {\n+  _next = nullptr;         \/\/ Chain on the linked list\n+}\n+\n+void Chunk::chop(Chunk* k) {\n+  while (k != nullptr) {\n+    Chunk *tmp = k->next();\n+    \/\/ clear out this chunk (to detect allocation bugs)\n+    if (ZapResourceArea) memset(k->bottom(), badResourceValue, k->length());\n+    ChunkPool::deallocate_chunk(k);\n+    k = tmp;\n+  }\n+}\n+\n+void Chunk::next_chop(Chunk* k) {\n+  assert(k != nullptr && k->_next != nullptr, \"must be non-null\");\n+  Chunk::chop(k->_next);\n+  k->_next = nullptr;\n+}\n@@ -219,1 +188,1 @@\n-  _first = _chunk = new (AllocFailStrategy::EXIT_OOM, init_size) Chunk(init_size);\n+  _first = _chunk = ChunkPool::allocate_chunk(AllocFailStrategy::EXIT_OOM, init_size);\n@@ -227,1 +196,1 @@\n-  _first = _chunk = new (AllocFailStrategy::EXIT_OOM, Chunk::init_size) Chunk(Chunk::init_size);\n+  _first = _chunk = ChunkPool::allocate_chunk(AllocFailStrategy::EXIT_OOM, Chunk::init_size);\n@@ -245,1 +214,1 @@\n-    _first->chop();\n+    Chunk::chop(_first);\n@@ -282,1 +251,1 @@\n-  _chunk = new (alloc_failmode, len) Chunk(len);\n+  _chunk = ChunkPool::allocate_chunk(alloc_failmode, len);\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":75,"deletions":106,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-\/\/------------------------------Chunk------------------------------------------\n+\n@@ -42,1 +42,1 @@\n-class Chunk: CHeapObj<mtChunk> {\n+class Chunk {\n@@ -48,2 +48,0 @@\n-  void* operator new(size_t size, AllocFailType alloc_failmode, size_t length) throw();\n-  void  operator delete(void* p);\n@@ -70,2 +68,2 @@\n-  void chop();                  \/\/ Chop this chunk\n-  void next_chop();             \/\/ Chop next chunk\n+  static void chop(Chunk* chunk);                  \/\/ Chop this chunk\n+  static void next_chop(Chunk* chunk);             \/\/ Chop next chunk\n@@ -82,0 +80,28 @@\n+};\n+\n+\/\/ MT-safe pool of same-sized chunks to reduce malloc\/free thrashing\n+\/\/ NB: not using Mutex because pools are used before Threads are initialized\n+class ChunkPool {\n+  \/\/ Our four static pools\n+  static const int _num_pools = 4;\n+  static ChunkPool _pools[_num_pools];\n+\n+  Chunk*       _first;        \/\/ first cached Chunk; its first word points to next chunk\n+  const size_t _size;         \/\/ (inner payload) size of the chunks this pool serves\n+\n+  \/\/ Allocate a chunk from the pool; returns null if pool is empty.\n+  Chunk* take_from_pool();\n+  \/\/ Return a chunk to the pool\n+  void return_to_pool(Chunk* chunk);\n+  \/\/ Prune the pool\n+  void prune();\n+\n+  \/\/ Given a (inner payload) size, return the pool responsible for it, or null if the size is non-standard\n+  static ChunkPool* get_pool_for_size(size_t size);\n+\n+public:\n+  ChunkPool(size_t size) : _first(nullptr), _size(size) {}\n+\n+  static void clean();\n+  static Chunk* allocate_chunk(AllocFailType alloc_failmode, size_t length);\n+  static void deallocate_chunk(Chunk* p);\n@@ -87,1 +113,1 @@\n-\/\/------------------------------Arena------------------------------------------\n+\n@@ -97,3 +123,4 @@\n-  Chunk *_first;                \/\/ First chunk\n-  Chunk *_chunk;                \/\/ current chunk\n-  char *_hwm, *_max;            \/\/ High water mark and max in current chunk\n+  Chunk* _first;                \/\/ First chunk\n+  Chunk* _chunk;                \/\/ current chunk\n+  char* _hwm;                   \/\/ High water mark\n+  char* _max;                   \/\/ and max in current chunk\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":37,"deletions":10,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-      state._chunk->next_chop();\n+      Chunk::next_chop(state._chunk);\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -165,1 +165,1 @@\n-  _chunk->next_chop();\n+  Chunk::next_chop(_chunk);\n","filename":"src\/hotspot\/share\/runtime\/handles.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -678,1 +678,1 @@\n-  Chunk::start_chunk_pool_cleaner_task();\n+  ChunkPool::start_chunk_pool_cleaner_task();\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}