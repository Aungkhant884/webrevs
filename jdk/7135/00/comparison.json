{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,0 @@\n-import java.util.Properties;\n@@ -644,103 +643,0 @@\n-    \/\/ A FileInputStream that supports the deferment of the actual close\n-    \/\/ operation until the last pending I\/O operation on the stream has\n-    \/\/ finished.  This is required on Solaris because we must close the stdin\n-    \/\/ and stdout streams in the destroy method in order to reclaim the\n-    \/\/ underlying file descriptors.  Doing so, however, causes any thread\n-    \/\/ currently blocked in a read on one of those streams to receive an\n-    \/\/ IOException(\"Bad file number\"), which is incompatible with historical\n-    \/\/ behavior.  By deferring the close we allow any pending reads to see -1\n-    \/\/ (EOF) as they did before.\n-    \/\/\n-    private static class DeferredCloseInputStream extends PipeInputStream {\n-        DeferredCloseInputStream(FileDescriptor fd) {\n-            super(fd);\n-        }\n-\n-        private Object lock = new Object();     \/\/ For the following fields\n-        private boolean closePending = false;\n-        private int useCount = 0;\n-        private InputStream streamToClose;\n-\n-        private void raise() {\n-            synchronized (lock) {\n-                useCount++;\n-            }\n-        }\n-\n-        private void lower() throws IOException {\n-            synchronized (lock) {\n-                useCount--;\n-                if (useCount == 0 && closePending) {\n-                    streamToClose.close();\n-                }\n-            }\n-        }\n-\n-        \/\/ stc is the actual stream to be closed; it might be this object, or\n-        \/\/ it might be an upstream object for which this object is downstream.\n-        \/\/\n-        private void closeDeferred(InputStream stc) throws IOException {\n-            synchronized (lock) {\n-                if (useCount == 0) {\n-                    stc.close();\n-                } else {\n-                    closePending = true;\n-                    streamToClose = stc;\n-                }\n-            }\n-        }\n-\n-        public void close() throws IOException {\n-            synchronized (lock) {\n-                useCount = 0;\n-                closePending = false;\n-            }\n-            super.close();\n-        }\n-\n-        public int read() throws IOException {\n-            raise();\n-            try {\n-                return super.read();\n-            } finally {\n-                lower();\n-            }\n-        }\n-\n-        public int read(byte[] b) throws IOException {\n-            raise();\n-            try {\n-                return super.read(b);\n-            } finally {\n-                lower();\n-            }\n-        }\n-\n-        public int read(byte[] b, int off, int len) throws IOException {\n-            raise();\n-            try {\n-                return super.read(b, off, len);\n-            } finally {\n-                lower();\n-            }\n-        }\n-\n-        public long skip(long n) throws IOException {\n-            raise();\n-            try {\n-                return super.skip(n);\n-            } finally {\n-                lower();\n-            }\n-        }\n-\n-        public int available() throws IOException {\n-            raise();\n-            try {\n-                return super.available();\n-            } finally {\n-                lower();\n-            }\n-        }\n-    }\n-\n@@ -760,1 +656,1 @@\n-     * with the DeferredCloseInputStream approach used on Solaris. This means\n+     * with the deferring 'close' of InputStream. This means\n","filename":"src\/java.base\/unix\/classes\/java\/lang\/ProcessImpl.java","additions":2,"deletions":106,"binary":false,"changes":108,"status":"modified"}]}