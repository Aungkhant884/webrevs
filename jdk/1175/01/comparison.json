{"files":[{"patch":"@@ -2519,5 +2519,0 @@\n-\/\/ AES support not yet implemented\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1044,5 +1044,0 @@\n-\/\/ ARM doesn't support AES intrinsics\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2203,5 +2203,0 @@\n-\/\/ PPC AES support not yet implemented\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1591,5 +1591,0 @@\n-\/\/ Not yet ported to z\/Architecture.\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1902,6 +1902,0 @@\n-\/\/ x86 AES instructions are compatible with SunJCE expanded\n-\/\/ keys, hence we do not need to pass the original key to stubs\n-const bool Matcher::pass_original_key_for_aes() {\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5615,16 +5615,4 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    \/\/ on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to\n-    \/\/ compatibility issues between Java key expansion and SPARC crypto instructions\n-    Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);\n-    if (original_k_start == NULL) return false;\n-\n-    \/\/ Call the stub.\n-    make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),\n-                      stubAddr, stubName, TypePtr::BOTTOM,\n-                      src_start, dest_start, k_start, original_k_start);\n-  } else {\n-    \/\/ Call the stub.\n-    make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),\n-                      stubAddr, stubName, TypePtr::BOTTOM,\n-                      src_start, dest_start, k_start);\n-  }\n+  \/\/ Call the stub.\n+  make_runtime_call(RC_LEAF|RC_NO_FP, OptoRuntime::aescrypt_block_Type(),\n+                    stubAddr, stubName, TypePtr::BOTTOM,\n+                    src_start, dest_start, k_start);\n@@ -5713,19 +5701,5 @@\n-  Node* cbcCrypt;\n-  if (Matcher::pass_original_key_for_aes()) {\n-    \/\/ on SPARC we need to pass the original key since key expansion needs to happen in intrinsics due to\n-    \/\/ compatibility issues between Java key expansion and SPARC crypto instructions\n-    Node* original_k_start = get_original_key_start_from_aescrypt_object(aescrypt_object);\n-    if (original_k_start == NULL) return false;\n-\n-    \/\/ Call the stub, passing src_start, dest_start, k_start, r_start, src_len and original_k_start\n-    cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                                 OptoRuntime::cipherBlockChaining_aescrypt_Type(),\n-                                 stubAddr, stubName, TypePtr::BOTTOM,\n-                                 src_start, dest_start, k_start, r_start, len, original_k_start);\n-  } else {\n-    \/\/ Call the stub, passing src_start, dest_start, k_start, r_start and src_len\n-    cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                                 OptoRuntime::cipherBlockChaining_aescrypt_Type(),\n-                                 stubAddr, stubName, TypePtr::BOTTOM,\n-                                 src_start, dest_start, k_start, r_start, len);\n-  }\n+  \/\/ Call the stub, passing src_start, dest_start, k_start, r_start and src_len\n+  Node* cbcCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                     OptoRuntime::cipherBlockChaining_aescrypt_Type(),\n+                                     stubAddr, stubName, TypePtr::BOTTOM,\n+                                     src_start, dest_start, k_start, r_start, len);\n@@ -5810,5 +5784,0 @@\n-  Node* ecbCrypt;\n-  if (Matcher::pass_original_key_for_aes()) {\n-    \/\/ no SPARC version for AES\/ECB intrinsics now.\n-    return false;\n-  }\n@@ -5816,4 +5785,4 @@\n-  ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,\n-                               OptoRuntime::electronicCodeBook_aescrypt_Type(),\n-                               stubAddr, stubName, TypePtr::BOTTOM,\n-                               src_start, dest_start, k_start, len);\n+  Node* ecbCrypt = make_runtime_call(RC_LEAF | RC_NO_FP,\n+                                     OptoRuntime::electronicCodeBook_aescrypt_Type(),\n+                                     stubAddr, stubName, TypePtr::BOTTOM,\n+                                     src_start, dest_start, k_start, len);\n@@ -5894,5 +5863,0 @@\n-  Node* ctrCrypt;\n-  if (Matcher::pass_original_key_for_aes()) {\n-    \/\/ no SPARC version for AES\/CTR intrinsics now.\n-    return false;\n-  }\n@@ -5900,4 +5864,4 @@\n-  ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n-                               OptoRuntime::counterMode_aescrypt_Type(),\n-                               stubAddr, stubName, TypePtr::BOTTOM,\n-                               src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);\n+  Node* ctrCrypt = make_runtime_call(RC_LEAF|RC_NO_FP,\n+                                     OptoRuntime::counterMode_aescrypt_Type(),\n+                                     stubAddr, stubName, TypePtr::BOTTOM,\n+                                     src_start, dest_start, k_start, cnt_start, len, saved_encCounter_start, used);\n@@ -5935,11 +5899,0 @@\n-\/\/------------------------------get_original_key_start_from_aescrypt_object-----------------------\n-Node * LibraryCallKit::get_original_key_start_from_aescrypt_object(Node *aescrypt_object) {\n-  Node* objAESCryptKey = load_field_from_object(aescrypt_object, \"lastKey\", \"[B\", \/*is_exact*\/ false);\n-  assert (objAESCryptKey != NULL, \"wrong version of com.sun.crypto.provider.AESCrypt\");\n-  if (objAESCryptKey == NULL) return (Node *) NULL;\n-\n-  \/\/ now have the array, need to get the start address of the lastKey array\n-  Node* original_k_start = array_element_address(objAESCryptKey, intcon(0), T_BYTE);\n-  return original_k_start;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":17,"deletions":64,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -276,1 +276,0 @@\n-  Node* get_original_key_start_from_aescrypt_object(Node* aescrypt_object);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -354,3 +354,0 @@\n-  \/\/ Should original key array reference be passed to AES stubs\n-  static const bool pass_original_key_for_aes();\n-\n","filename":"src\/hotspot\/share\/opto\/matcher.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -788,3 +788,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 4;\n-  }\n@@ -797,3 +794,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -881,3 +875,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 6;\n-  }\n@@ -892,3 +883,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -909,3 +897,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-     num_args = 5;\n-  }\n@@ -919,3 +904,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-     fields[argp++] = TypePtr::NOTNULL;    \/\/ original k array\n-  }\n@@ -936,3 +918,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    num_args = 8;\n-  }\n@@ -949,3 +928,0 @@\n-  if (Matcher::pass_original_key_for_aes()) {\n-    fields[argp++] = TypePtr::NOTNULL; \/\/ original k array\n-  }\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":0,"deletions":24,"binary":false,"changes":24,"status":"modified"}]}