{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -91,0 +92,1 @@\n+    private String[] signatureSchemes = new String[0];\n@@ -699,0 +701,71 @@\n+\n+    \/**\n+     * Returns a prioritized array of signature scheme names that can be used\n+     * over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * The returned array includes {@code String} names from the list of\n+     * standard signature schemes in the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#signature-schemes\">\n+     * Signature Schemes<\/a> section of the Java Cryptography\n+     * Architecture Standard Algorithm Name Documentation, and may also\n+     * include other signature schemes that the provider supports.\n+     * <p>\n+     * The array could be empty (zero-length), in which case the underlying\n+     * provider-specific default signature schemes will be used.\n+     *\n+     * @implSpec\n+     * This method will return a new array each time it is invoked.\n+     *\n+     * @return a non-null, possibly zero-length array of signature scheme\n+     *         {@code String}s.  The array is placed in descending order of\n+     *         signature scheme preference.\n+     * @see #setSignatureSchemes\n+     *\n+     * @since 19\n+     *\/\n+    public String[] getSignatureSchemes() {\n+        return signatureSchemes.clone();\n+    }\n+\n+    \/**\n+     * Sets the prioritized array of signature scheme names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of signature scheme names may be found in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#signature-schemes\">\n+     * Signature Schemes<\/a> section of the Java Cryptography\n+     * Architecture Standard Algorithm Name Documentation.  Providers\n+     * may support signature schemes not found in this list or might not\n+     * use the recommended name for a certain signature scheme.\n+     *\n+     * @implSpec\n+     * This method will make a copy of the {@code signatureSchemes} array.\n+     *\n+     * @param signatureSchemes an ordered array of signature scheme names,\n+     *        with the first entry being the most preferred. If the array\n+     *        is empty (zero-length), the prodiver-specific default signature\n+     *        schemes will be used for the SSL\/TLS\/DTLS connection.\n+     * @throws IllegalArgumentException if signatureSchemes is null, or if\n+     *        any element in a non-empty array is null or an\n+     *        empty (zero-length) string.\n+     *\n+     * @see #getSignatureSchemes\n+     *\n+     * @since 19\n+     *\/\n+    public void setSignatureSchemes(String[] signatureSchemes) {\n+        if (signatureSchemes == null) {\n+            throw new IllegalArgumentException(\"signatureSchemes was null\");\n+        }\n+\n+        String[] tempSchemes = signatureSchemes.clone();\n+        for (String scheme : tempSchemes) {\n+            if (scheme == null || scheme.isEmpty()) {\n+                throw new IllegalArgumentException(\n+                        \"An element of signatureSchemes was null\/empty\");\n+            }\n+        }\n+\n+        this.signatureSchemes = tempSchemes;\n+    }\n@@ -700,0 +773,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -32,5 +33,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n+import java.util.*;\n@@ -69,1 +66,1 @@\n-    List<SignatureScheme>       signatureSchemes;\n+    String[]                   signatureSchemes;\n@@ -207,0 +204,1 @@\n+        params.setSignatureSchemes(this.signatureSchemes);\n@@ -264,0 +262,5 @@\n+        String[] ss = params.getSignatureSchemes();\n+        if (ss != null && ss.length != 0) {\n+            this.signatureSchemes = ss;\n+        }   \/\/ Otherwise, use the default values\n+\n@@ -406,4 +409,9 @@\n-        \/\/ reset the signature schemes\n-        this.signatureSchemes = isClientMode ?\n-                CustomizedClientSignatureSchemes.signatureSchemes :\n-                CustomizedServerSignatureSchemes.signatureSchemes;\n+        \/\/ Reset the signature schemes, if it was configured with SSLParameters.\n+        if (Arrays.equals(signatureSchemes,\n+                CustomizedClientSignatureSchemes.signatureSchemes) ||\n+            Arrays.equals(signatureSchemes,\n+                    CustomizedServerSignatureSchemes.signatureSchemes)) {\n+            this.signatureSchemes = isClientMode ?\n+                    CustomizedClientSignatureSchemes.signatureSchemes :\n+                    CustomizedServerSignatureSchemes.signatureSchemes;\n+        }\n@@ -437,1 +445,1 @@\n-        private static final List<SignatureScheme> signatureSchemes =\n+        private static final String[] signatureSchemes =\n@@ -445,1 +453,1 @@\n-        private static final List<SignatureScheme> signatureSchemes =\n+        private static final String[] signatureSchemes =\n@@ -453,3 +461,1 @@\n-    private static List<SignatureScheme> getCustomizedSignatureScheme(\n-            String propertyName) {\n-\n+    private static String[] getCustomizedSignatureScheme(String propertyName) {\n@@ -460,1 +466,1 @@\n-                    property + \"'\");\n+                            property + \"'\");\n@@ -472,5 +478,5 @@\n-            List<SignatureScheme> signatureSchemes =\n-                        new ArrayList<>(signatureSchemeNames.length);\n-            for (int i = 0; i < signatureSchemeNames.length; i++) {\n-                signatureSchemeNames[i] = signatureSchemeNames[i].trim();\n-                if (signatureSchemeNames[i].isEmpty()) {\n+            List<String> signatureSchemes =\n+                    new ArrayList<>(signatureSchemeNames.length);\n+            for (String schemeName : signatureSchemeNames) {\n+                schemeName = schemeName.trim();\n+                if (schemeName.isEmpty()) {\n@@ -480,2 +486,2 @@\n-                SignatureScheme scheme =\n-                    SignatureScheme.nameOf(signatureSchemeNames[i]);\n+                \/\/ Check the availability\n+                SignatureScheme scheme = SignatureScheme.nameOf(schemeName);\n@@ -483,1 +489,1 @@\n-                    signatureSchemes.add(scheme);\n+                    signatureSchemes.add(schemeName);\n@@ -487,3 +493,2 @@\n-                                \"The current installed providers do not \" +\n-                                \"support signature scheme: \" +\n-                                signatureSchemeNames[i]);\n+                        \"The current installed providers do not \" +\n+                              \"support signature scheme: \" + schemeName);\n@@ -494,1 +499,1 @@\n-            return signatureSchemes;\n+            return signatureSchemes.toArray(new String[0]);\n@@ -497,1 +502,1 @@\n-        return Collections.emptyList();\n+        return new String[0];\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":34,"deletions":29,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n@@ -184,1 +185,1 @@\n-    static enum SigAlgParamSpec {   \/\/ support RSASSA-PSS only now\n+    enum SigAlgParamSpec {   \/\/ support RSASSA-PSS only now\n@@ -227,1 +228,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -233,1 +234,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -241,1 +242,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -250,1 +251,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -259,1 +260,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -379,5 +380,0 @@\n-        \/\/ If config.signatureSchemes is non-empty then it means that\n-        \/\/ it was defined by a System property.  Per\n-        \/\/ SSLConfiguration.getCustomizedSignatureScheme() the list will\n-        \/\/ only contain schemes that are in the enum.\n-        \/\/ Otherwise, use the enum constants (converted to a List).\n@@ -385,1 +381,2 @@\n-                config.signatureSchemes.isEmpty() ?\n+                config.signatureSchemes == null ||\n+                        config.signatureSchemes.length == 0 ?\n@@ -387,1 +384,1 @@\n-                    config.signatureSchemes;\n+                    namesOfAvailable(config.signatureSchemes);\n@@ -440,2 +437,4 @@\n-                    (config.signatureSchemes.isEmpty() ||\n-                        config.signatureSchemes.contains(ss)) &&\n+                    (config.signatureSchemes == null ||\n+                        config.signatureSchemes.length == 0 ||\n+                        Arrays.asList(config.signatureSchemes)\n+                              .contains(ss.name)) &&\n@@ -566,0 +565,27 @@\n+    private static List<SignatureScheme> namesOfAvailable(\n+                String[] signatureSchemes) {\n+\n+        if (signatureSchemes == null ||  signatureSchemes.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<SignatureScheme> sss = new ArrayList<>(signatureSchemes.length);\n+        for (String ss : signatureSchemes) {\n+            SignatureScheme scheme = SignatureScheme.nameOf(ss);\n+            if (scheme == null || !scheme.isAvailable) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Ignore the signature algorithm (\" + ss\n+                          + \"), unsupported or unavailable\");\n+                }\n+\n+                continue;\n+            }\n+\n+            sss.add(scheme);\n+        }\n+\n+        return Collections.unmodifiableList(sss);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":41,"deletions":15,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify\n+ * it under the terms of the GNU General Public License version 2 as\n+ * published by the Free Software Foundation. THL A29 Limited designates\n+ * this particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * GNU General Public License version 2 for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License along\n+ * with this program; if not, write to the Free Software Foundation, Inc.,\n+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8280494\n+ * @summary (D)TLS signature schemes\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm SignatureSchemes\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.SocketException;\n+import java.security.Security;\n+\n+import javax.net.ssl.*;\n+\n+public class SignatureSchemes extends SSLSocketTemplate {\n+    private final String[] serverSignatureSchemes;\n+    private final String[] clientSignatureSchemes;\n+    private final boolean exceptionExpected;\n+\n+    public SignatureSchemes(String[] serverSignatureSchemes,\n+                            String[] clientSignatureSchemes,\n+                            boolean exceptionExpected) {\n+        this.serverSignatureSchemes = serverSignatureSchemes;\n+        this.clientSignatureSchemes = clientSignatureSchemes;\n+        this.exceptionExpected = exceptionExpected;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setSignatureSchemes(serverSignatureSchemes);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setSignatureSchemes(clientSignatureSchemes);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        try {\n+            super.runServerApplication(socket);\n+        } catch (Exception ex) {\n+            \/\/ Just ignore, let the client handle the failure information.\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        try {\n+            super.runClientApplication(sslSocket);\n+            if (exceptionExpected) {\n+                throw new RuntimeException(\"Unexpected success!\");\n+            }\n+        } catch (Exception ex) {\n+            if (!exceptionExpected) {\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[0],\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_shaNA\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverSignatureSchemes,\n+                                String[] clientSignatureSchemes,\n+                                boolean exceptionExpected) throws Exception {\n+        new SignatureSchemes(serverSignatureSchemes,\n+                clientSignatureSchemes, exceptionExpected).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/SignatureSchemes.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"}]}