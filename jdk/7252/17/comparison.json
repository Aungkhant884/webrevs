{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,2 +42,3 @@\n- * the maximum network packet size, the algorithm constraints and whether\n- * SSL\/TLS\/DTLS servers should request or require client authentication, etc.\n+ * the maximum network packet size, the algorithm constraints, the signature\n+ * schemes and whether SSL\/TLS\/DTLS servers should request or require client\n+ * authentication, etc.\n@@ -45,3 +46,3 @@\n- * SSLParameters can be created via the constructors in this class.\n- * Objects can also be obtained using the {@code getSSLParameters()}\n- * methods in\n+ * {@code SSLParameter} objects can be created via the constructors in this\n+ * class, and can be described as pre-populated objects. {@code SSLParameter}\n+ * objects can also be obtained using the {@code getSSLParameters()} methods in\n@@ -53,1 +54,2 @@\n- * methods in {@code SSLContext}.\n+ * methods in {@code SSLContext}, and can be described as connection populated\n+ * objects.\n@@ -91,0 +93,1 @@\n+    private String[] signatureSchemes = null;\n@@ -96,5 +99,5 @@\n-     * constraints, endpoint identification algorithm, server names and\n-     * server name matchers are set to {@code null}; useCipherSuitesOrder,\n-     * wantClientAuth and needClientAuth are set to {@code false};\n-     * enableRetransmissions is set to {@code true}; maximum network packet\n-     * size is set to {@code 0}.\n+     * constraints, endpoint identification algorithm, signature schemes,\n+     * server names and server name matchers are set to {@code null};\n+     * useCipherSuitesOrder, wantClientAuth and needClientAuth are set\n+     * to {@code false}; enableRetransmissions is set to {@code true};\n+     * maximum network packet size is set to {@code 0}.\n@@ -369,1 +372,1 @@\n-     * In the following examples, the server name could be represented by an\n+     * In the following examples, the server name may be represented by an\n@@ -699,0 +702,121 @@\n+\n+    \/**\n+     * Returns a prioritized array of signature scheme names that can be used\n+     * over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of signature scheme names are defined in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#signature-schemes\">\n+     * Signature Schemes<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support signature schemes not defined\n+     * in this list or may not use the recommended name for a certain\n+     * signature scheme.\n+     * <p>\n+     * The set of signature schemes that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the returned array of this method and the\n+     * underlying provider-specific default signature schemes.\n+     * <p>\n+     * If the returned array is {@code null}, then the underlying\n+     * provider-specific default signature schemes will be used over the\n+     * SSL\/TLS\/DTLS connections.\n+     * <p>\n+     * If the returned array is empty (zero-length), then the signature scheme\n+     * negotiation mechanism is turned off for SSL\/TLS\/DTLS protocols, and\n+     * the connections may not be able to be established if the negotiation\n+     * mechanism is required by a certain SSL\/TLS\/DTLS protocol.  This\n+     * parameter will override the underlying provider-specific default\n+     * signature schemes.\n+     * <p>\n+     * If the returned array is not {@code null} or empty (zero-length),\n+     * then the signature schemes in the returned array will be used over\n+     * the SSL\/TLS\/DTLS connections.  This parameter will override the\n+     * underlying provider-specific default signature schemes.\n+     * <p>\n+     * This method returns the most recent value passed to\n+     * {@link #setSignatureSchemes} if that method has been called and\n+     * otherwise returns the default signature schemes for connection\n+     * populated objects, or {@code null} for pre-populated objects.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may return {@code null} instead of the default\n+     * signature schemes for connection populated objects.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @implNote\n+     * Note that applications may use the\n+     * {@systemProperty jdk.tls.client.SignatureSchemes} and\/or\n+     * {@systemProperty jdk.tls.server.SignatureSchemes} system properties\n+     * with the SunJSSE provider to override the provider-specific default\n+     * signature schemes.\n+     *\n+     * @return an array of signature scheme {@code Strings} or {@code null} if\n+     *         none have been set.  For non-null returns, this method will\n+     *         return a new array each time it is invoked.  The array is\n+     *         ordered based on signature scheme preference, with the first\n+     *         entry being the most preferred.  Providers should ignore unknown\n+     *         signature scheme names while establishing the SSL\/TLS\/DTLS\n+     *         connections.\n+     * @see #setSignatureSchemes\n+     *\n+     * @since 19\n+     *\/\n+    public String[] getSignatureSchemes() {\n+        return clone(signatureSchemes);\n+    }\n+\n+    \/**\n+     * Sets the prioritized array of signature scheme names that\n+     * can be used over the SSL\/TLS\/DTLS protocols.\n+     * <p>\n+     * Note that the standard list of signature scheme names are defined in\n+     * the <a href=\n+     * \"{@docRoot}\/..\/specs\/security\/standard-names.html#signature-schemes\">\n+     * Signature Schemes<\/a> section of the Java Security Standard Algorithm\n+     * Names Specification.  Providers may support signature schemes not\n+     * defined in this list or may not use the recommended name for a certain\n+     * signature scheme.\n+     * <p>\n+     * The set of signature schemes that will be used over the SSL\/TLS\/DTLS\n+     * connections is determined by the input parameter {@code signatureSchemes}\n+     * array and the underlying provider-specific default signature schemes.\n+     * See {@link #getSignatureSchemes} for specific details on how the\n+     * parameters are used in SSL\/TLS\/DTLS connections.\n+     *\n+     * @apiNote\n+     * Note that a provider may not have been updated to support this method\n+     * and in that case may ignore the schemes that are set.\n+     *\n+     * @implNote\n+     * The SunJSSE provider supports this method.\n+     *\n+     * @param signatureSchemes an ordered array of signature scheme names with\n+     *        the first entry being the most preferred, or {@code null}.  This\n+     *        method will make a copy of this array.  Providers should ignore\n+     *        unknown signature scheme names while establishing the\n+     *        SSL\/TLS\/DTLS connections.\n+     * @throws IllegalArgumentException if any element in the\n+     *        {@code signatureSchemes} array is {@code null} or\n+     *        {@linkplain String#isBlank() blank}.\n+     *\n+     * @see #getSignatureSchemes\n+     *\n+     * @since 19\n+     *\/\n+    public void setSignatureSchemes(String[] signatureSchemes) {\n+        String[] tempSchemes = null;\n+\n+        if (signatureSchemes != null) {\n+            tempSchemes = signatureSchemes.clone();\n+            for (String scheme : tempSchemes) {\n+                if (scheme == null || scheme.isBlank()) {\n+                    throw new IllegalArgumentException(\n+                        \"An element of signatureSchemes is null or blank\");\n+                }\n+            }\n+        }\n+\n+        this.signatureSchemes = tempSchemes;\n+    }\n","filename":"src\/java.base\/share\/classes\/javax\/net\/ssl\/SSLParameters.java","additions":137,"deletions":13,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,5 +32,1 @@\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n+import java.util.*;\n@@ -69,1 +65,1 @@\n-    List<SignatureScheme>       signatureSchemes;\n+    String[]                   signatureSchemes;\n@@ -207,0 +203,1 @@\n+        params.setSignatureSchemes(this.signatureSchemes);\n@@ -264,0 +261,7 @@\n+        String[] ss = params.getSignatureSchemes();\n+        if (ss != null) {\n+            \/\/ Note if 'ss' is empty, then no signature schemes should be\n+            \/\/ specified over the connections.\n+            this.signatureSchemes = ss;\n+        }   \/\/ Otherwise, use the default values\n+\n@@ -406,4 +410,9 @@\n-        \/\/ reset the signature schemes\n-        this.signatureSchemes = isClientMode ?\n-                CustomizedClientSignatureSchemes.signatureSchemes :\n-                CustomizedServerSignatureSchemes.signatureSchemes;\n+        \/\/ Reset the signature schemes, if it was configured with SSLParameters.\n+        if (Arrays.equals(signatureSchemes,\n+                CustomizedClientSignatureSchemes.signatureSchemes) ||\n+            Arrays.equals(signatureSchemes,\n+                    CustomizedServerSignatureSchemes.signatureSchemes)) {\n+            this.signatureSchemes = isClientMode ?\n+                    CustomizedClientSignatureSchemes.signatureSchemes :\n+                    CustomizedServerSignatureSchemes.signatureSchemes;\n+        }\n@@ -437,1 +446,1 @@\n-        private static final List<SignatureScheme> signatureSchemes =\n+        private static final String[] signatureSchemes =\n@@ -445,1 +454,1 @@\n-        private static final List<SignatureScheme> signatureSchemes =\n+        private static final String[] signatureSchemes =\n@@ -453,3 +462,1 @@\n-    private static List<SignatureScheme> getCustomizedSignatureScheme(\n-            String propertyName) {\n-\n+    private static String[] getCustomizedSignatureScheme(String propertyName) {\n@@ -460,1 +467,1 @@\n-                    property + \"'\");\n+                            property + \"'\");\n@@ -472,5 +479,5 @@\n-            List<SignatureScheme> signatureSchemes =\n-                        new ArrayList<>(signatureSchemeNames.length);\n-            for (int i = 0; i < signatureSchemeNames.length; i++) {\n-                signatureSchemeNames[i] = signatureSchemeNames[i].trim();\n-                if (signatureSchemeNames[i].isEmpty()) {\n+            List<String> signatureSchemes =\n+                    new ArrayList<>(signatureSchemeNames.length);\n+            for (String schemeName : signatureSchemeNames) {\n+                schemeName = schemeName.trim();\n+                if (schemeName.isEmpty()) {\n@@ -480,2 +487,2 @@\n-                SignatureScheme scheme =\n-                    SignatureScheme.nameOf(signatureSchemeNames[i]);\n+                \/\/ Check the availability\n+                SignatureScheme scheme = SignatureScheme.nameOf(schemeName);\n@@ -483,1 +490,1 @@\n-                    signatureSchemes.add(scheme);\n+                    signatureSchemes.add(schemeName);\n@@ -487,3 +494,2 @@\n-                                \"The current installed providers do not \" +\n-                                \"support signature scheme: \" +\n-                                signatureSchemeNames[i]);\n+                        \"The current installed providers do not \" +\n+                              \"support signature scheme: \" + schemeName);\n@@ -494,1 +500,5 @@\n-            return signatureSchemes;\n+            \/\/ Note that if the System Property value is not defined (JDK\n+            \/\/ default value) or empty, the provider-specific default is used.\n+            if (!signatureSchemes.isEmpty()) {\n+                return signatureSchemes.toArray(new String[0]);\n+            }\n@@ -497,1 +507,3 @@\n-        return Collections.emptyList();\n+        \/\/ Note that if the System Property value is not defined (JDK\n+        \/\/ default value) or empty, the provider-specific default is used.\n+        return null;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":42,"deletions":30,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-    static enum SigAlgParamSpec {   \/\/ support RSASSA-PSS only now\n+    enum SigAlgParamSpec {   \/\/ support RSASSA-PSS only now\n@@ -227,1 +227,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -233,1 +233,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -241,1 +241,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -250,1 +250,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -259,1 +259,1 @@\n-    private SignatureScheme(int id, String name,\n+    SignatureScheme(int id, String name,\n@@ -379,5 +379,0 @@\n-        \/\/ If config.signatureSchemes is non-empty then it means that\n-        \/\/ it was defined by a System property.  Per\n-        \/\/ SSLConfiguration.getCustomizedSignatureScheme() the list will\n-        \/\/ only contain schemes that are in the enum.\n-        \/\/ Otherwise, use the enum constants (converted to a List).\n@@ -385,1 +380,1 @@\n-                config.signatureSchemes.isEmpty() ?\n+                config.signatureSchemes == null ?\n@@ -387,1 +382,1 @@\n-                    config.signatureSchemes;\n+                    namesOfAvailable(config.signatureSchemes);\n@@ -440,2 +435,2 @@\n-                    (config.signatureSchemes.isEmpty() ||\n-                        config.signatureSchemes.contains(ss)) &&\n+                    (config.signatureSchemes == null ||\n+                        Utilities.contains(config.signatureSchemes, ss.name)) &&\n@@ -566,0 +561,27 @@\n+    private static List<SignatureScheme> namesOfAvailable(\n+                String[] signatureSchemes) {\n+\n+        if (signatureSchemes == null ||  signatureSchemes.length == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<SignatureScheme> sss = new ArrayList<>(signatureSchemes.length);\n+        for (String ss : signatureSchemes) {\n+            SignatureScheme scheme = SignatureScheme.nameOf(ss);\n+            if (scheme == null || !scheme.isAvailable) {\n+                if (SSLLogger.isOn &&\n+                        SSLLogger.isOn(\"ssl,handshake,verbose\")) {\n+                    SSLLogger.finest(\n+                            \"Ignore the signature algorithm (\" + ss\n+                          + \"), unsupported or unavailable\");\n+                }\n+\n+                continue;\n+            }\n+\n+            sss.add(scheme);\n+        }\n+\n+        return sss;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SignatureScheme.java","additions":38,"deletions":16,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -227,0 +227,10 @@\n+    static <T> boolean contains(T[] array, T item) {\n+        for (T t : array) {\n+            if (item.equals(t)) {\n+                return true;\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Utilities.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (C) 2022 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\n+\/*\n+ * @test\n+ * @bug 8280494\n+ * @summary (D)TLS signature schemes\n+ * @library \/javax\/net\/ssl\/templates\n+ * @run main\/othervm SignatureSchemes\n+ *\/\n+\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLSocket;\n+import java.security.Security;\n+\n+public class SignatureSchemes extends SSLSocketTemplate {\n+    private final String[] serverSignatureSchemes;\n+    private final String[] clientSignatureSchemes;\n+    private final boolean exceptionExpected;\n+\n+    public SignatureSchemes(String[] serverSignatureSchemes,\n+                            String[] clientSignatureSchemes,\n+                            boolean exceptionExpected) {\n+        this.serverSignatureSchemes = serverSignatureSchemes;\n+        this.clientSignatureSchemes = clientSignatureSchemes;\n+        this.exceptionExpected = exceptionExpected;\n+    }\n+\n+    @Override\n+    protected void configureServerSocket(SSLServerSocket sslServerSocket) {\n+        SSLParameters sslParameters = sslServerSocket.getSSLParameters();\n+        sslParameters.setSignatureSchemes(serverSignatureSchemes);\n+        sslServerSocket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void configureClientSocket(SSLSocket socket) {\n+        SSLParameters sslParameters = socket.getSSLParameters();\n+        sslParameters.setSignatureSchemes(clientSignatureSchemes);\n+        socket.setSSLParameters(sslParameters);\n+    }\n+\n+    @Override\n+    protected void runServerApplication(SSLSocket socket) throws Exception {\n+        try {\n+            super.runServerApplication(socket);\n+        } catch (Exception ex) {\n+            \/\/ Just ignore, let the client handle the failure information.\n+        }\n+    }\n+\n+    @Override\n+    protected void runClientApplication(SSLSocket sslSocket) throws Exception {\n+        try {\n+            super.runClientApplication(sslSocket);\n+            if (exceptionExpected) {\n+                throw new RuntimeException(\"Unexpected success!\");\n+            }\n+        } catch (Exception ex) {\n+            if (!exceptionExpected) {\n+                throw ex;\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        Security.setProperty(\"jdk.tls.disabledAlgorithms\", \"\");\n+\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\",\n+                        \"ed25519\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(null,\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                false);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                null,\n+                false);\n+        runTest(new String[0],\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                new String[0],\n+                true);\n+        runTest(new String[] {\n+                        \"ecdsa_secp256r1_shaNA\"\n+                },\n+                new String[] {\n+                        \"ecdsa_secp256r1_sha256\"\n+                },\n+                true);\n+    }\n+\n+    private static void runTest(String[] serverSignatureSchemes,\n+                                String[] clientSignatureSchemes,\n+                                boolean exceptionExpected) throws Exception {\n+        new SignatureSchemes(serverSignatureSchemes,\n+                clientSignatureSchemes, exceptionExpected).run();\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLParameters\/SignatureSchemes.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"}]}