{"files":[{"patch":"@@ -340,9 +340,0 @@\n-    MTTFHAR_OPCODE   = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 0 << SPR_0_4_SHIFT),\n-    MFTFHAR_OPCODE   = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 0 << SPR_0_4_SHIFT),\n-    MTTFIAR_OPCODE   = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 1 << SPR_0_4_SHIFT),\n-    MFTFIAR_OPCODE   = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 1 << SPR_0_4_SHIFT),\n-    MTTEXASR_OPCODE  = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 2 << SPR_0_4_SHIFT),\n-    MFTEXASR_OPCODE  = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 2 << SPR_0_4_SHIFT),\n-    MTTEXASRU_OPCODE = (MTSPR_OPCODE | 4 << SPR_5_9_SHIFT | 3 << SPR_0_4_SHIFT),\n-    MFTEXASRU_OPCODE = (MFSPR_OPCODE | 4 << SPR_5_9_SHIFT | 3 << SPR_0_4_SHIFT),\n-\n@@ -769,11 +760,0 @@\n-    \/\/ Transactional Memory instructions (introduced with Power 8)\n-    TBEGIN_OPCODE    = (31u << OPCODE_SHIFT |  654u << 1),\n-    TEND_OPCODE      = (31u << OPCODE_SHIFT |  686u << 1),\n-    TABORT_OPCODE    = (31u << OPCODE_SHIFT |  910u << 1),\n-    TABORTWC_OPCODE  = (31u << OPCODE_SHIFT |  782u << 1),\n-    TABORTWCI_OPCODE = (31u << OPCODE_SHIFT |  846u << 1),\n-    TABORTDC_OPCODE  = (31u << OPCODE_SHIFT |  814u << 1),\n-    TABORTDCI_OPCODE = (31u << OPCODE_SHIFT |  878u << 1),\n-    TSR_OPCODE       = (31u << OPCODE_SHIFT |  750u << 1),\n-    TCHECK_OPCODE    = (31u << OPCODE_SHIFT |  718u << 1),\n-\n@@ -1817,27 +1797,0 @@\n-  \/\/ Transactional Memory Registers\n-  inline void mftfhar(Register d);\n-  inline void mftfiar(Register d);\n-  inline void mftexasr(Register d);\n-  inline void mftexasru(Register d);\n-\n-  \/\/ TEXASR bit description\n-  enum transaction_failure_reason {\n-    \/\/ Upper half (TEXASRU):\n-    tm_failure_code       =  0, \/\/ The Failure Code is copied from tabort or treclaim operand.\n-    tm_failure_persistent =  7, \/\/ The failure is likely to recur on each execution.\n-    tm_disallowed         =  8, \/\/ The instruction is not permitted.\n-    tm_nesting_of         =  9, \/\/ The maximum transaction level was exceeded.\n-    tm_footprint_of       = 10, \/\/ The tracking limit for transactional storage accesses was exceeded.\n-    tm_self_induced_cf    = 11, \/\/ A self-induced conflict occurred in Suspended state.\n-    tm_non_trans_cf       = 12, \/\/ A conflict occurred with a non-transactional access by another processor.\n-    tm_trans_cf           = 13, \/\/ A conflict occurred with another transaction.\n-    tm_translation_cf     = 14, \/\/ A conflict occurred with a TLB invalidation.\n-    tm_inst_fetch_cf      = 16, \/\/ An instruction fetch was performed from a block that was previously written transactionally.\n-    tm_tabort             = 31, \/\/ Termination was caused by the execution of an abort instruction.\n-    \/\/ Lower half:\n-    tm_suspended          = 32, \/\/ Failure was recorded in Suspended state.\n-    tm_failure_summary    = 36, \/\/ Failure has been detected and recorded.\n-    tm_tfiar_exact        = 37, \/\/ Value in the TFIAR is exact.\n-    tm_rot                = 38, \/\/ Rollback-only transaction.\n-    tm_transaction_level  = 52, \/\/ Transaction level (nesting depth + 1).\n-  };\n@@ -2455,19 +2408,0 @@\n-  \/\/ Transactional Memory instructions (introduced with Power 8)\n-  inline void tbegin_();    \/\/ R=0\n-  inline void tbeginrot_(); \/\/ R=1 Rollback-Only Transaction\n-  inline void tend_();    \/\/ A=0\n-  inline void tendall_(); \/\/ A=1\n-  inline void tabort_();\n-  inline void tabort_(Register a);\n-  inline void tabortwc_(int t, Register a, Register b);\n-  inline void tabortwci_(int t, Register a, int si);\n-  inline void tabortdc_(int t, Register a, Register b);\n-  inline void tabortdci_(int t, Register a, int si);\n-  inline void tsuspend_(); \/\/ tsr with L=0\n-  inline void tresume_();  \/\/ tsr with L=1\n-  inline void tcheck(int f);\n-\n-  static bool is_tbegin(int x) {\n-    return TBEGIN_OPCODE == (x & (0x3f << OPCODE_SHIFT | 0x3ff << 1));\n-  }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":0,"deletions":66,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -436,5 +436,0 @@\n-\/\/ Transactional Memory Registers\n-inline void Assembler::mftfhar(Register d )       { emit_int32(MFTFHAR_OPCODE   | rt(d)); }\n-inline void Assembler::mftfiar(Register d )       { emit_int32(MFTFIAR_OPCODE   | rt(d)); }\n-inline void Assembler::mftexasr(Register d )      { emit_int32(MFTEXASR_OPCODE  | rt(d)); }\n-inline void Assembler::mftexasru(Register d )     { emit_int32(MFTEXASRU_OPCODE | rt(d)); }\n@@ -442,1 +437,0 @@\n-\/\/ SAP JVM 2006-02-13 PPC branch instruction.\n@@ -1051,15 +1045,0 @@\n-\/\/ Transactional Memory instructions (introduced with Power 8)\n-inline void Assembler::tbegin_()                                { emit_int32( TBEGIN_OPCODE | rc(1)); }\n-inline void Assembler::tbeginrot_()                             { emit_int32( TBEGIN_OPCODE | \/*R=1*\/ 1u << (31-10) | rc(1)); }\n-inline void Assembler::tend_()                                  { emit_int32( TEND_OPCODE | rc(1)); }\n-inline void Assembler::tendall_()                               { emit_int32( TEND_OPCODE | \/*A=1*\/ 1u << (31-6) | rc(1)); }\n-inline void Assembler::tabort_()                                { emit_int32( TABORT_OPCODE | rc(1)); }\n-inline void Assembler::tabort_(Register a)                      { assert(a != R0, \"r0 not allowed\"); emit_int32( TABORT_OPCODE | ra(a) | rc(1)); }\n-inline void Assembler::tabortwc_(int t, Register a, Register b) { emit_int32( TABORTWC_OPCODE | to(t) | ra(a) | rb(b) | rc(1)); }\n-inline void Assembler::tabortwci_(int t, Register a, int si)    { emit_int32( TABORTWCI_OPCODE | to(t) | ra(a) | sh1620(si) | rc(1)); }\n-inline void Assembler::tabortdc_(int t, Register a, Register b) { emit_int32( TABORTDC_OPCODE | to(t) | ra(a) | rb(b) | rc(1)); }\n-inline void Assembler::tabortdci_(int t, Register a, int si)    { emit_int32( TABORTDCI_OPCODE | to(t) | ra(a) | sh1620(si) | rc(1)); }\n-inline void Assembler::tsuspend_()                              { emit_int32( TSR_OPCODE | rc(1)); }\n-inline void Assembler::tresume_()                               { emit_int32( TSR_OPCODE | \/*L=1*\/ 1u << (31-10) | rc(1)); }\n-inline void Assembler::tcheck(int f)                            { emit_int32( TCHECK_OPCODE | bf(f)); }\n-\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.inline.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -48,8 +48,0 @@\n-#if defined(LINUX) && defined(VM_LITTLE_ENDIAN)\n-#include <sys\/auxv.h>\n-\n-#ifndef PPC_FEATURE2_HTM_NOSC\n-#define PPC_FEATURE2_HTM_NOSC (1 << 24)\n-#endif\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,11 +56,7 @@\n-            try {\n-                \/\/ verify that we get an error when use +UseRTMLocking\n-                \/\/ on unsupported CPU\n-                CommandLineOptionTest.verifySameJVMStartup(\n-                        new String[] { errorMessage },\n-                        new String[] { unrecognizedOption }, shouldFailMessage,\n-                        shouldFailMessage + \". Error message should be shown.\",\n-                        ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n-            } catch (Throwable e) {\n-                throw e; \/\/ checking unsupported OS error is not necessary\n-            }\n+            \/\/ verify that we get an error when use +UseRTMLocking\n+            \/\/ on unsupported CPU\n+            CommandLineOptionTest.verifySameJVMStartup(\n+                    new String[] { errorMessage },\n+                    new String[] { unrecognizedOption }, shouldFailMessage,\n+                    shouldFailMessage + \". Error message should be shown.\",\n+                    ExitCode.FAIL, \"-XX:+UseRTMLocking\");\n","filename":"test\/hotspot\/jtreg\/compiler\/rtm\/cli\/TestUseRTMLockingOptionOnUnsupportedCPU.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}