{"files":[{"patch":"@@ -283,1 +283,1 @@\n-  inline HeapWord* oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* pb, Closure* cl);\n+  inline HeapWord* oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -405,2 +405,1 @@\n-inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* const pb, Closure* cl) {\n-  \/\/ Cache the boundaries of the area to scan in some locals.\n+inline HeapWord* HeapRegion::oops_on_memregion_iterate_in_unparsable(MemRegion mr, HeapWord* block_start, Closure* cl) {\n@@ -409,1 +408,1 @@\n-  HeapWord* const end = MIN2(mr.end(), pb);\n+  HeapWord* const end = mr.end();\n@@ -412,17 +411,0 @@\n-  \/\/ Find the obj that extends onto mr.start().\n-  \/\/\n-  \/\/ The BOT itself is stable enough to be read at any time as\n-  \/\/\n-  \/\/ * during refinement the individual elements of the BOT are read and written\n-  \/\/   atomically and any visible mix of new and old BOT entries will eventually lead\n-  \/\/   to some (possibly outdated) object start.\n-  \/\/   The result of block_start() during concurrent refinement may be outdated - the\n-  \/\/   scrubbing may have written a (partial) filler object header exactly crossing\n-  \/\/   that perceived object start. So we have to advance to the next live object\n-  \/\/   (using the bitmap) to be able to start the following iteration.\n-  \/\/\n-  \/\/ * during GC the BOT does not change while reading, and the objects corresponding\n-  \/\/   to these block starts are valid as \"holes\" are filled atomically wrt to\n-  \/\/   safepoints.\n-  \/\/\n-  HeapWord* cur = block_start(start, pb);\n@@ -430,0 +412,6 @@\n+  HeapWord* cur = block_start;\n+  \/\/ The passed block_start may point at a dead block - during the concurrent phase the scrubbing\n+  \/\/ may have written a (partial) filler object header exactly crossing that perceived object\n+  \/\/ start; during GC pause this might just be a dead object that we should not read from.\n+  \/\/ So we have to advance to the next live object (using the bitmap) to be able to start\n+  \/\/ the following iteration over the objects.\n@@ -476,6 +464,18 @@\n-  \/\/ Find the obj that extends onto mr.start()\n-  HeapWord* cur;\n-  if (obj_in_parsable_area(start, pb)) {\n-    cur = block_start(start, pb);\n-  } else {\n-    cur = oops_on_memregion_iterate_in_unparsable<Closure>(mr, pb, cl);\n+  \/\/ Find the obj that extends onto mr.start().\n+  \/\/\n+  \/\/ The BOT itself is stable enough to be read at any time as\n+  \/\/\n+  \/\/ * during refinement the individual elements of the BOT are read and written\n+  \/\/   atomically and any visible mix of new and old BOT entries will eventually lead\n+  \/\/   to some (possibly outdated) object start.\n+  \/\/\n+  \/\/ * during GC the BOT does not change while reading, and the objects corresponding\n+  \/\/   to these block starts are valid as \"holes\" are filled atomically wrt to\n+  \/\/   safepoints.\n+  \/\/\n+  HeapWord* cur = block_start(start, pb);\n+  if (!obj_in_parsable_area(start, pb)) {\n+    \/\/ Limit the MemRegion to the part of the area to scan to the unparsable one as using the bitmap\n+    \/\/ is slower than blindly iterating the objects.\n+    MemRegion mr_in_unparsable(mr.start(), MIN2(mr.end(), pb));\n+    cur = oops_on_memregion_iterate_in_unparsable<Closure>(mr_in_unparsable, cur, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":26,"deletions":26,"binary":false,"changes":52,"status":"modified"}]}