{"files":[{"patch":"@@ -1282,1 +1282,1 @@\n-    return MacroAssembler::far_branch_size();\n+    return MacroAssembler::far_codestub_branch_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return (MacroAssembler::far_branches() ? 6 : 4) * NativeInstruction::instruction_size;\n+  return (MacroAssembler::codecache_branch_needs_far_jump() ? 6 : 4) * NativeInstruction::instruction_size;\n@@ -55,1 +55,1 @@\n-  __ far_jump(ExternalAddress(entry_point));\n+  __ far_jump(ExternalAddress(entry_point), NULL, rscratch1, true);\n","filename":"src\/hotspot\/cpu\/aarch64\/icBuffer_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -393,1 +393,2 @@\n-  if (far_branches()) {\n+  assert(CodeCache::is_non_nmethod(entry.target()), \"must be a call to the code stub\");\n+  if (codestub_branch_needs_far_jump()) {\n@@ -407,1 +408,14 @@\n-void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {\n+static inline bool target_needs_far_branch(address addr) {\n+  \/\/ codecache size <= 128M\n+  if (!MacroAssembler::codecache_branch_needs_far_jump()) {\n+    return false;\n+  }\n+  \/\/ codecache size > 240M\n+  if (MacroAssembler::codestub_branch_needs_far_jump()) {\n+    return true;\n+  }\n+  \/\/ codecache size: 128M..240M\n+  return !CodeCache::is_non_nmethod(addr);\n+}\n+\n+void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp, bool fixed_size) {\n@@ -411,1 +425,1 @@\n-  if (far_branches()) {\n+  if (target_needs_far_branch(entry.target())) {\n@@ -422,0 +436,5 @@\n+    if (codecache_branch_needs_far_jump() && fixed_size) {\n+      \/\/ ic_buffer case: jump code size is not expected to vary depending on target address\n+      nop();\n+      nop();\n+    }\n@@ -557,1 +576,1 @@\n-  if (far_branches()) {\n+  if (codecache_branch_needs_far_jump()) {\n@@ -578,1 +597,1 @@\n-  if (!far_branches()) {\n+  if (!codecache_branch_needs_far_jump()) {\n@@ -4374,6 +4393,1 @@\n-    address tpc1 = trampoline_call(has_neg);\n-    if (tpc1 == NULL) {\n-      DEBUG_ONLY(reset_labels(STUB_LONG, SET_RESULT, DONE));\n-      postcond(pc() == badAddress);\n-      return NULL;\n-    }\n+    far_call(has_neg);\n@@ -4385,6 +4399,1 @@\n-    address tpc2 = trampoline_call(has_neg_long);\n-    if (tpc2 == NULL) {\n-      DEBUG_ONLY(reset_labels(SET_RESULT, DONE));\n-      postcond(pc() == badAddress);\n-      return NULL;\n-    }\n+    far_call(has_neg_long);\n@@ -4566,6 +4575,1 @@\n-    address tpc = trampoline_call(stub);\n-    if (tpc == NULL) {\n-      DEBUG_ONLY(reset_labels(SHORT, LAST_CHECK, CSET_EQ, SAME, DONE));\n-      postcond(pc() == badAddress);\n-      return NULL;\n-    }\n+    far_call(stub);\n@@ -4725,18 +4729,1 @@\n-    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n-    \/\/ trampoline stubs generated by Call LIR ops, and in any case it\n-    \/\/ makes sense for a C1 compilation task to proceed as quickly as\n-    \/\/ possible.\n-    CompileTask* task;\n-    if (StubRoutines::aarch64::complete()\n-        && Thread::current()->is_Compiler_thread()\n-        && (task = ciEnv::current()->task())\n-        && is_c2_compile(task->comp_level())) {\n-      address tpc = trampoline_call(zero_blocks);\n-      if (tpc == NULL) {\n-        DEBUG_ONLY(reset_labels(around));\n-        assert(false, \"failed to allocate space for trampoline\");\n-        return NULL;\n-      }\n-    } else {\n-      far_call(zero_blocks);\n-    }\n+    far_call(zero_blocks);\n@@ -5085,6 +5072,1 @@\n-      address tpc = trampoline_call(stub);\n-      if (tpc == NULL) {\n-        DEBUG_ONLY(reset_labels(big, done));\n-        postcond(pc() == badAddress);\n-        return NULL;\n-      }\n+      far_call(stub);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":29,"deletions":47,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1071,1 +1071,2 @@\n-  static bool far_branches() {\n+  \/\/ Jumps that can reach anywhere in the code cache.\n+  static bool codecache_branch_needs_far_jump() {\n@@ -1075,1 +1076,5 @@\n-  \/\/ Jumps that can reach anywhere in the code cache.\n+  \/\/ Jumps that can reach a nonmethod stub\n+  static bool codestub_branch_needs_far_jump() {\n+    return CodeCache::max_distance_to_codestub() > branch_range;\n+  }\n+\n@@ -1078,1 +1083,1 @@\n-  void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n+  void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1, bool fixed_size = false);\n@@ -1080,2 +1085,2 @@\n-  static int far_branch_size() {\n-    if (far_branches()) {\n+  static int far_codestub_branch_size() {\n+    if (codestub_branch_needs_far_jump()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-  if (a.far_branches()\n+  if (a.codecache_branch_needs_far_jump()\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,0 +299,1 @@\n+  non_profiled_size = align_down(non_profiled_size, alignment);\n@@ -303,1 +304,0 @@\n-  \/\/    Non-profiled nmethods\n@@ -306,0 +306,1 @@\n+  \/\/    Non-profiled nmethods\n@@ -308,4 +309,4 @@\n-  ReservedSpace non_method_space    = rs.first_part(non_nmethod_size);\n-  ReservedSpace rest                = rs.last_part(non_nmethod_size);\n-  ReservedSpace profiled_space      = rest.first_part(profiled_size);\n-  ReservedSpace non_profiled_space  = rest.last_part(profiled_size);\n+  ReservedSpace non_profiled_space  = rs.first_part(non_profiled_size);\n+  ReservedSpace rest                = rs.last_part(non_profiled_size);\n+  ReservedSpace non_method_space    = rest.first_part(non_nmethod_size);\n+  ReservedSpace profiled_space      = rest.last_part(non_nmethod_size);\n@@ -892,0 +893,18 @@\n+bool CodeCache::is_non_nmethod(address addr) {\n+  CodeHeap* blob = get_code_heap(CodeBlobType::NonNMethod);\n+  return blob->contains(addr);\n+}\n+\n+size_t CodeCache::max_distance_to_codestub() {\n+  if (!SegmentedCodeCache) {\n+    return ReservedCodeCacheSize;\n+  } else {\n+    CodeHeap* blob = get_code_heap(CodeBlobType::NonNMethod);\n+    \/\/ the max distance is minimized by placing the NonNMethod segment\n+    \/\/ in between MethodProfiled and MethodNonProfiled segments\n+    size_t dist1 = (size_t)blob->high() - (size_t)_low_bound;\n+    size_t dist2 = (size_t)_high_bound - (size_t)blob->low();\n+    return dist1 > dist2 ? dist1 : dist2;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":24,"deletions":5,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -214,0 +214,3 @@\n+  static size_t max_distance_to_codestub();\n+  static bool is_non_nmethod(address addr);\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}