{"files":[{"patch":"@@ -389,0 +389,13 @@\n+static inline bool target_needs_far_branch(address addr) {\n+  \/\/ codecache size <= 128M\n+  if (!MacroAssembler::codecache_branch_needs_far_jump()) {\n+    return false;\n+  }\n+  \/\/ codecache size > 240M\n+  if (MacroAssembler::codestub_branch_needs_far_jump()) {\n+    return true;\n+  }\n+  \/\/ codecache size: 128M..240M\n+  return !CodeCache::is_non_nmethod(addr);\n+}\n+\n@@ -393,2 +406,1 @@\n-  assert(CodeCache::is_non_nmethod(entry.target()), \"must be a call to the code stub\");\n-  if (codestub_branch_needs_far_jump()) {\n+  if (target_needs_far_branch(entry.target())) {\n@@ -408,13 +420,0 @@\n-static inline bool target_needs_far_branch(address addr) {\n-  \/\/ codecache size <= 128M\n-  if (!MacroAssembler::codecache_branch_needs_far_jump()) {\n-    return false;\n-  }\n-  \/\/ codecache size > 240M\n-  if (MacroAssembler::codestub_branch_needs_far_jump()) {\n-    return true;\n-  }\n-  \/\/ codecache size: 128M..240M\n-  return !CodeCache::is_non_nmethod(addr);\n-}\n-\n@@ -4393,1 +4392,6 @@\n-    far_call(has_neg);\n+    address tpc1 = trampoline_call(has_neg);\n+    if (tpc1 == NULL) {\n+      DEBUG_ONLY(reset_labels(STUB_LONG, SET_RESULT, DONE));\n+      postcond(pc() == badAddress);\n+      return NULL;\n+    }\n@@ -4399,1 +4403,6 @@\n-    far_call(has_neg_long);\n+    address tpc2 = trampoline_call(has_neg_long);\n+    if (tpc2 == NULL) {\n+      DEBUG_ONLY(reset_labels(SET_RESULT, DONE));\n+      postcond(pc() == badAddress);\n+      return NULL;\n+    }\n@@ -4575,1 +4584,6 @@\n-    far_call(stub);\n+    address tpc = trampoline_call(stub);\n+    if (tpc == NULL) {\n+      DEBUG_ONLY(reset_labels(SHORT, LAST_CHECK, CSET_EQ, SAME, DONE));\n+      postcond(pc() == badAddress);\n+      return NULL;\n+    }\n@@ -4729,1 +4743,18 @@\n-    far_call(zero_blocks);\n+    \/\/ Make sure this is a C2 compilation. C1 allocates space only for\n+    \/\/ trampoline stubs generated by Call LIR ops, and in any case it\n+    \/\/ makes sense for a C1 compilation task to proceed as quickly as\n+    \/\/ possible.\n+    CompileTask* task;\n+    if (StubRoutines::aarch64::complete()\n+        && Thread::current()->is_Compiler_thread()\n+        && (task = ciEnv::current()->task())\n+        && is_c2_compile(task->comp_level())) {\n+      address tpc = trampoline_call(zero_blocks);\n+      if (tpc == NULL) {\n+        DEBUG_ONLY(reset_labels(around));\n+        assert(false, \"failed to allocate space for trampoline\");\n+        return NULL;\n+      }\n+    } else {\n+      far_call(zero_blocks);\n+    }\n@@ -5072,1 +5103,6 @@\n-      far_call(stub);\n+      address tpc = trampoline_call(stub);\n+      if (tpc == NULL) {\n+        DEBUG_ONLY(reset_labels(big, done));\n+        postcond(pc() == badAddress);\n+        return NULL;\n+      }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":56,"deletions":20,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -1076,0 +1076,4 @@\n+  static bool trampoline_needs_far_jump() {\n+    return ReservedCodeCacheSize > branch_range;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-  if (a.codecache_branch_needs_far_jump()\n+  if (a.trampoline_needs_far_jump()\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}