{"files":[{"patch":"@@ -1282,1 +1282,1 @@\n-    return MacroAssembler::far_branch_size();\n+    return MacroAssembler::far_codestub_branch_size();\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  return (MacroAssembler::far_branches() ? 6 : 4) * NativeInstruction::instruction_size;\n+  return (MacroAssembler::codecache_branch_needs_far_jump() ? 6 : 4) * NativeInstruction::instruction_size;\n@@ -55,2 +55,6 @@\n-  __ far_jump(ExternalAddress(entry_point));\n-  __ align(wordSize);\n+  int jump_code_size = __ far_jump(ExternalAddress(entry_point));\n+  \/\/ IC stub code size is not expected to vary depending on target address.\n+  \/\/ We use NOPs to make the ldr+far_jump+int64 size equal to ic_stub_code_size.\n+  for (int i = jump_code_size; i < ic_stub_code_size() - 12; i += 4) {\n+    __ nop();\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/icBuffer_aarch64.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -389,0 +389,13 @@\n+static inline bool target_needs_far_branch(address addr) {\n+  \/\/ codecache size <= 128M\n+  if (!MacroAssembler::codecache_branch_needs_far_jump()) {\n+    return false;\n+  }\n+  \/\/ codecache size > 240M\n+  if (MacroAssembler::codestub_branch_needs_far_jump()) {\n+    return true;\n+  }\n+  \/\/ codecache size: 128M..240M\n+  return !CodeCache::is_non_nmethod(addr);\n+}\n+\n@@ -393,1 +406,1 @@\n-  if (far_branches()) {\n+  if (target_needs_far_branch(entry.target())) {\n@@ -407,1 +420,1 @@\n-void MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {\n+int MacroAssembler::far_jump(Address entry, CodeBuffer *cbuf, Register tmp) {\n@@ -411,1 +424,2 @@\n-  if (far_branches()) {\n+  address start = pc();\n+  if (target_needs_far_branch(entry.target())) {\n@@ -423,0 +437,1 @@\n+  return pc() - start;\n@@ -557,1 +572,1 @@\n-  if (far_branches()) {\n+  if (codecache_branch_needs_far_jump()) {\n@@ -578,1 +593,1 @@\n-  if (!far_branches()) {\n+  if (!codecache_branch_needs_far_jump()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1071,1 +1071,2 @@\n-  static bool far_branches() {\n+  \/\/ Jumps that can reach anywhere in the code cache.\n+  static bool codecache_branch_needs_far_jump() {\n@@ -1075,1 +1076,9 @@\n-  \/\/ Jumps that can reach anywhere in the code cache.\n+  static bool is_trampoline_needed() {\n+    return ReservedCodeCacheSize > branch_range;\n+  }\n+\n+  \/\/ Jumps that can reach a nonmethod stub\n+  static bool codestub_branch_needs_far_jump() {\n+    return CodeCache::max_distance_to_non_nmethod() > branch_range;\n+  }\n+\n@@ -1078,1 +1087,1 @@\n-  void far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n+  int far_jump(Address entry, CodeBuffer *cbuf = NULL, Register tmp = rscratch1);\n@@ -1080,2 +1089,2 @@\n-  static int far_branch_size() {\n-    if (far_branches()) {\n+  static int far_codestub_branch_size() {\n+    if (codestub_branch_needs_far_jump()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":14,"deletions":5,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-  if (a.far_branches()\n+  if (a.is_trampoline_needed()\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -299,0 +299,1 @@\n+  non_profiled_size = align_down(non_profiled_size, alignment);\n@@ -303,1 +304,0 @@\n-  \/\/    Non-profiled nmethods\n@@ -306,0 +306,1 @@\n+  \/\/    Non-profiled nmethods\n@@ -308,4 +309,4 @@\n-  ReservedSpace non_method_space    = rs.first_part(non_nmethod_size);\n-  ReservedSpace rest                = rs.last_part(non_nmethod_size);\n-  ReservedSpace profiled_space      = rest.first_part(profiled_size);\n-  ReservedSpace non_profiled_space  = rest.last_part(profiled_size);\n+  ReservedSpace non_profiled_space  = rs.first_part(non_profiled_size);\n+  ReservedSpace rest                = rs.last_part(non_profiled_size);\n+  ReservedSpace non_method_space    = rest.first_part(non_nmethod_size);\n+  ReservedSpace profiled_space      = rest.last_part(non_nmethod_size);\n@@ -892,0 +893,17 @@\n+bool CodeCache::is_non_nmethod(address addr) {\n+  CodeHeap* blob = get_code_heap(CodeBlobType::NonNMethod);\n+  return blob->contains(addr);\n+}\n+\n+size_t CodeCache::max_distance_to_non_nmethod() {\n+  if (!SegmentedCodeCache) {\n+    return ReservedCodeCacheSize;\n+  } else {\n+    CodeHeap* blob = get_code_heap(CodeBlobType::NonNMethod);\n+    \/\/ the max distance is minimized by placing the NonNMethod segment\n+    \/\/ in between MethodProfiled and MethodNonProfiled segments\n+    size_t dist1 = (size_t)blob->high() - (size_t)_low_bound;\n+    size_t dist2 = (size_t)_high_bound - (size_t)blob->low();\n+    return dist1 > dist2 ? dist1 : dist2;\n+  }\n+}\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -216,0 +216,3 @@\n+  static size_t max_distance_to_non_nmethod();\n+  static bool is_non_nmethod(address addr);\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}