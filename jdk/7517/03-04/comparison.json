{"files":[{"patch":"@@ -37,1 +37,1 @@\n-  return (MacroAssembler::codecache_branch_needs_far_jump() ? 6 : 4) * NativeInstruction::instruction_size;\n+  return (MacroAssembler::far_branches() ? 6 : 4) * NativeInstruction::instruction_size;\n","filename":"src\/hotspot\/cpu\/aarch64\/icBuffer_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,1 @@\n-  if (!MacroAssembler::codecache_branch_needs_far_jump()) {\n+  if (!MacroAssembler::far_branches()) {\n@@ -572,1 +572,1 @@\n-  if (codecache_branch_needs_far_jump()) {\n+  if (far_branches()) {\n@@ -593,1 +593,1 @@\n-  if (!codecache_branch_needs_far_jump()) {\n+  if (!far_branches()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1072,5 +1072,1 @@\n-  static bool codecache_branch_needs_far_jump() {\n-    return ReservedCodeCacheSize > branch_range;\n-  }\n-\n-  static bool is_trampoline_needed() {\n+  static bool far_branches() {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -533,1 +533,1 @@\n-  if (a.is_trampoline_needed()\n+  if (a.far_branches()\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.aarch64;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.*;\n+\n+\/*\n+ * @test\n+ * @bug 8280872\n+ * @summary Far call to runtime stub should be generated with single instruction for CodeHeap up to 250MB\n+ * @library \/test\/lib \/\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run driver compiler.c2.TestFarJump\n+ *\/\n+public class TestFarJump {\n+\n+    \/\/ ADRP instruction encoding:\n+    \/\/   |31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 10|\n+    \/\/   | 1|immlo| 1  0  0  0  0|                immhi                                   |     Rd       |\n+    static boolean isADRP(int encoding) {\n+        final int mask = 0b1001_1111;\n+        final int val  = 0b1001_0000;\n+        return ((encoding >> 24) & mask) == val;\n+    }\n+\n+    \/\/ Looking for adrp instruction in binary\/text assembly output:\n+    \/\/     0x0000ffff7ff1b7d0: c8ff ffd0 | 0801 1091 | 0001 1fd6\n+    \/\/     0x0000ffff6bf20ee0: adrp        x8, 0x0000ffff6bef1000\n+    static boolean containsADRP(String input) {\n+        int index = input.indexOf(\": \");\n+        if (index == -1) {\n+            return false;\n+        }\n+        input = input.substring(index + 1);\n+        if (input.contains(\"adrp\")) {\n+            return true;\n+        }\n+        Pattern pattern = Pattern.compile(\"[0-9a-f ]*\");\n+        Matcher matcher = pattern.matcher(input);\n+        while (matcher.find()) {\n+            String match = matcher.group();\n+            match = match.replace(\" \" , \"\");\n+            if (match.length() != 8) {\n+                continue;\n+            }\n+            int dump = (int)Long.parseLong(match, 16);\n+            \/\/ little endian dump: the least significant bytes are stored before the more significant bytes\n+            int encoding = Integer.reverseBytes(dump);\n+            if (isADRP(encoding)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    static void runVM(boolean bigCodeHeap) throws Exception {\n+        String className = TestFarJump.class.getName();\n+        String[] procArgs = {\n+            \"-XX:-Inline\",\n+            \"-Xcomp\",\n+            \"-Xbatch\",\n+            \"-XX:+TieredCompilation\",\n+            \"-XX:+SegmentedCodeCache\",\n+            \"-XX:CompileOnly=\" + className + \"::main\",\n+            \"-XX:ReservedCodeCacheSize=\" + (bigCodeHeap ? \"256M\" : \"200M\"),\n+            \"-XX:+UnlockDiagnosticVMOptions\",\n+            \"-XX:+PrintAssembly\",\n+            className};\n+\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(procArgs);\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        List<String> lines = output.asLines();\n+\n+        ListIterator<String> itr = lines.listIterator();\n+        while (itr.hasNext()) {\n+            String line = itr.next();\n+            if (line.contains(\"[Exception Handler]\")) {\n+                String next1 = itr.next();\n+                String next2 = itr.next();\n+                System.out.println(line);\n+                System.out.println(next1);\n+                System.out.println(next2);\n+                boolean containsADRP = containsADRP(next1) || containsADRP(next2);\n+                if (bigCodeHeap && !containsADRP) {\n+                    throw new RuntimeException(\"ADRP instruction is expected on far jump\");\n+                }\n+                if (!bigCodeHeap && containsADRP) {\n+                    throw new RuntimeException(\"for CodeHeap < 250MB the far jump is expected to be encoded with a single branch instruction\");\n+                }\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"Assembly output: exception Handler is not found\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length == 0) {\n+            \/\/ Main VM: fork VM with options\n+            runVM(true);\n+            runVM(false);\n+            return;\n+        }\n+        if (args.length > 0) {\n+            \/\/ We are in a forked VM. Just exit\n+            System.out.println(\"Ok\");\n+        }\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestFarJump.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"}]}