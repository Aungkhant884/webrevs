{"files":[{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.annotation.Annotation;\n@@ -62,0 +61,1 @@\n+\n@@ -64,0 +64,2 @@\n+\/\/import jdk.lang.classfile.Classfile;\n+\n@@ -295,6 +297,10 @@\n-        for (Method m : getClass().getDeclaredMethods()) {\n-            Annotation a = m.getAnnotation(Test.class);\n-            if (a != null) {\n-                runTest(m, f);\n-                out.println();\n-            }\n+        var methods = List.of(getClass().getDeclaredMethods()).stream()\n+                .filter(m -> m.isAnnotationPresent(Test.class))\n+                .collect(Collectors.toCollection(() -> new ArrayList<>()));\n+        var methodOrderComparator = getMethodComparator();\n+        if (methodOrderComparator != null) {\n+            methods.sort(methodOrderComparator);\n+        }\n+        for (Method m : methods) {\n+            runTest(m, f);\n+            out.println();\n@@ -305,0 +311,55 @@\n+\/\/ The following is for when the Classfile library is generally available.\n+\/\/    private Comparator<Method> getClassOrderMethodComparator(Class<?> c) {\n+\/\/        try {\n+\/\/            var url = c.getProtectionDomain().getCodeSource().getLocation();\n+\/\/            var path = Path.of(url.toURI()).resolve(c.getName().replace(\".\", \"\/\") + \".class\");\n+\/\/            var cf = Classfile.of().parse(path);\n+\/\/            var map = new HashMap<String, Integer>();\n+\/\/            var index = 0;\n+\/\/            for (var m : cf.methods()) {\n+\/\/                map.putIfAbsent(m.methodName().stringValue(), index++);\n+\/\/            }\n+\/\/            return Comparator.<Method>comparingInt(m -> map.getOrDefault(m.getName(), -1));\n+\/\/        } catch (URISyntaxException | IOException e) {\n+\/\/            throw new Error(\"Cannot sort methods: \" + e, e);\n+\/\/        }\n+\/\/    }\n+\n+    \/**\n+     * {@return the comparator used to sort the default set of methods to be executed,\n+     *   or {@code null} if the methods should not be sorted }\n+     *\n+     * @implSpec This implementation returns a source-order comparator.\n+     *\/\n+    public Comparator<Method> getMethodComparator() {\n+        return getSourceOrderMethodComparator(getClass());\n+    }\n+\n+    \/**\n+     * {@return the source-order method comparator for methods in the given class}\n+     * @param c the class\n+     *\/\n+    public static Comparator<Method> getSourceOrderMethodComparator(Class<?> c) {\n+        var path = Path.of(testSrc)\n+                .resolve(c.getName()\n+                        .replace(\".\", \"\/\")\n+                        .replaceAll(\"\\\\$.*\", \"\")\n+                        + \".java\");\n+        try {\n+            var src = Files.readString(path);\n+            \/\/ Fuzzy match for test method declarations.\n+            \/\/ It doesn't matter if there are false positives, as long as the true positives are in the correct order.\n+            \/\/ It doesn't matter too much if there are false negatives: they'll just be executed first.\n+            var isMethodDecl = Pattern.compile(\"public +void +(?<name>[A-Za-z][A-Za-z0-9_]*)\\\\(\");\n+            var matcher = isMethodDecl.matcher(src);\n+            var map = new HashMap<String, Integer>();\n+            var index = 0;\n+            while (matcher.find()) {\n+                map.putIfAbsent(matcher.group(\"name\"), index++);\n+            }\n+            return Comparator.<Method>comparingInt(m -> map.getOrDefault(m.getName(), -1));\n+        } catch (IOException e) {\n+            throw new Error(\"Cannot sort methods: \" + e, e);\n+        }\n+    }\n+\n","filename":"test\/langtools\/jdk\/javadoc\/lib\/javadoc\/tester\/JavadocTester.java","additions":68,"deletions":7,"binary":false,"changes":75,"status":"modified"}]}