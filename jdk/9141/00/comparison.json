{"files":[{"patch":"@@ -795,1 +795,0 @@\n-int java_lang_Class::_init_lock_offset;\n@@ -929,6 +928,0 @@\n-  \/\/ Allocate a simple java object for a lock.\n-  \/\/ This needs to be a java object because during class initialization\n-  \/\/ it can be held across a java call.\n-  typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK);\n-  set_init_lock(mirror(), r);\n-\n@@ -1273,2 +1266,0 @@\n-    set_init_lock(archived_mirror, NULL);\n-\n@@ -1356,4 +1347,0 @@\n-    \/\/ create the init_lock\n-    typeArrayOop r = oopFactory::new_typeArray(T_INT, 0, CHECK_(false));\n-    set_init_lock(mirror(), r);\n-\n@@ -1424,9 +1411,0 @@\n-oop java_lang_Class::init_lock(oop java_class) {\n-  assert(_init_lock_offset != 0, \"must be set\");\n-  return java_class->obj_field(_init_lock_offset);\n-}\n-void java_lang_Class::set_init_lock(oop java_class, oop init_lock) {\n-  assert(_init_lock_offset != 0, \"must be set\");\n-  java_class->obj_field_put(_init_lock_offset, init_lock);\n-}\n-\n@@ -1644,5 +1622,0 @@\n-  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n-  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n-  \/\/ GC treats them the same.\n-  _init_lock_offset = _component_mirror_offset;\n-\n@@ -1655,1 +1628,0 @@\n-  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":0,"deletions":28,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -288,1 +288,0 @@\n-  static int _init_lock_offset;\n@@ -303,1 +302,0 @@\n-  static void set_init_lock(oop java_class, oop init_lock);\n@@ -359,4 +357,0 @@\n-  static oop  init_lock(oop java_class);\n-  static void clear_init_lock(oop java_class) {\n-    set_init_lock(java_class, NULL);\n-  }\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1777,1 +1777,1 @@\n-  \/\/ an ObjectLocker to do the final serialization of updates\n+  \/\/ a lock to do the final serialization of updates\n","filename":"src\/hotspot\/share\/interpreter\/linkResolver.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  nonstatic_field(InstanceKlass,               _init_state,                                   u1)                                    \\\n+  nonstatic_field(InstanceKlass,               _init_state,                                   InstanceKlass::ClassState)             \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -269,1 +269,1 @@\n-             method->method_holder()->is_reentrant_initialization(Thread::current()),\n+             method->method_holder()->is_reentrant(Thread::current()),\n@@ -376,0 +376,2 @@\n+  \/\/ Lock fields to write\n+  MutexLocker ml(cpool->pool_holder()->init_monitor());\n@@ -377,8 +379,0 @@\n-  JavaThread* current = JavaThread::current();\n-  objArrayHandle resolved_references(current, cpool->resolved_references());\n-  \/\/ Use the resolved_references() lock for this cpCache entry.\n-  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n-  \/\/ or MethodType constant pool cache entries.\n-  assert(resolved_references() != NULL,\n-         \"a resolved_references array should have been created for this class\");\n-  ObjectLocker ol(resolved_references, current);\n@@ -456,0 +450,1 @@\n+    objArrayOop resolved_references = cpool->resolved_references();\n@@ -483,8 +478,1 @@\n-  \/\/ Use the resolved_references() lock for this cpCache entry.\n-  \/\/ resolved_references are created for all classes with Invokedynamic, MethodHandle\n-  \/\/ or MethodType constant pool cache entries.\n-  JavaThread* current = THREAD;\n-  objArrayHandle resolved_references(current, cpool->resolved_references());\n-  assert(resolved_references() != NULL,\n-         \"a resolved_references array should have been created for this class\");\n-  ObjectLocker ol(resolved_references, current);\n+  MutexLocker ml(THREAD, cpool->pool_holder()->init_monitor());\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":5,"deletions":17,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -498,0 +498,4 @@\n+static Monitor* create_init_monitor(const char* name) {\n+  return new Monitor(Mutex::safepoint, name);\n+}\n+\n@@ -510,0 +514,1 @@\n+  _init_monitor(create_init_monitor(\"InstanceKlassInitMonitor_lock\")),\n@@ -727,22 +732,0 @@\n-oop InstanceKlass::init_lock() const {\n-  \/\/ return the init lock from the mirror\n-  oop lock = java_lang_Class::init_lock(java_mirror());\n-  \/\/ Prevent reordering with any access of initialization state\n-  OrderAccess::loadload();\n-  assert(lock != NULL || !is_not_initialized(), \/\/ initialized or in_error state\n-         \"only fully initialized state can have a null lock\");\n-  return lock;\n-}\n-\n-\/\/ Set the initialization lock to null so the object can be GC'ed.  Any racing\n-\/\/ threads to get this lock will see a null lock and will not lock.\n-\/\/ That's okay because they all check for initialized state after getting\n-\/\/ the lock and return.\n-void InstanceKlass::fence_and_clear_init_lock() {\n-  \/\/ make sure previous stores are all done, notably the init_state.\n-  OrderAccess::storestore();\n-  java_lang_Class::clear_init_lock(java_mirror());\n-  assert(!is_not_initialized(), \"class must be initialized now\");\n-}\n-\n-\n@@ -776,0 +759,20 @@\n+void InstanceKlass::check_link_state_and_wait(JavaThread* current) {\n+  MonitorLocker ml(current, _init_monitor);\n+\n+  \/\/ Another thread is linking this class, wait.\n+  while (is_being_linked() && !is_reentrant(current)) {\n+    ml.wait();\n+  }\n+\n+  \/\/ This thread is recursively linking this class, continue\n+  if (is_being_linked() && is_reentrant(current)) {\n+    return;\n+  }\n+\n+  \/\/ If this class wasn't linked already, set state to being_linked\n+  if (!is_linked()) {\n+    set_init_state(being_linked);\n+    set_init_thread(current);\n+  }\n+}\n+\n@@ -854,3 +857,2 @@\n-    HandleMark hm(THREAD);\n-    Handle h_init_lock(THREAD, init_lock());\n-    ObjectLocker ol(h_init_lock, jt);\n+    LockLinkState init_lock(this, jt);\n+\n@@ -914,11 +916,1 @@\n-      if (UseVtableBasedCHA) {\n-        MutexLocker ml(THREAD, Compile_lock);\n-        set_init_state(linked);\n-\n-        \/\/ Now flush all code that assume the class is not linked.\n-        if (Universe::is_fully_initialized()) {\n-          CodeCache::flush_dependents_on(this);\n-        }\n-      } else {\n-        set_init_state(linked);\n-      }\n+      set_initialization_state_and_notify(linked, THREAD);\n@@ -1037,0 +1029,1 @@\n+  bool throw_error = false;\n@@ -1043,2 +1036,1 @@\n-    Handle h_init_lock(THREAD, init_lock());\n-    ObjectLocker ol(h_init_lock, jt);\n+    MonitorLocker ml(THREAD, _init_monitor);\n@@ -1047,4 +1039,1 @@\n-    \/\/ If we were to use wait() instead of waitInterruptibly() then\n-    \/\/ we might end up throwing IE from link\/symbol resolution sites\n-    \/\/ that aren't expected to throw.  This would wreak havoc.  See 6320309.\n-    while (is_being_initialized() && !is_reentrant_initialization(jt)) {\n+    while (is_being_initialized() && !is_reentrant(jt)) {\n@@ -1053,1 +1042,1 @@\n-      ol.wait_uninterruptibly(jt);\n+      ml.wait();\n@@ -1058,1 +1047,1 @@\n-    if (is_being_initialized() && is_reentrant_initialization(jt)) {\n+    if (is_being_initialized() && is_reentrant(jt)) {\n@@ -1071,3 +1060,2 @@\n-      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n-      ResourceMark rm(THREAD);\n-      Handle cause(THREAD, get_initialization_error(THREAD));\n+      throw_error = true;\n+    } else {\n@@ -1075,8 +1063,3 @@\n-      stringStream ss;\n-      ss.print(\"Could not initialize class %s\", external_name());\n-      if (cause.is_null()) {\n-        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n-      } else {\n-        THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n-                        ss.as_string(), cause);\n-      }\n+      \/\/ Step 6\n+      set_init_state(being_initialized);\n+      set_init_thread(jt);\n@@ -1084,0 +1067,7 @@\n+  }\n+\n+  \/\/ Throw error outside lock\n+  if (throw_error) {\n+    DTRACE_CLASSINIT_PROBE_WAIT(erroneous, -1, wait);\n+    ResourceMark rm(THREAD);\n+    Handle cause(THREAD, get_initialization_error(THREAD));\n@@ -1085,3 +1075,8 @@\n-    \/\/ Step 6\n-    set_init_state(being_initialized);\n-    set_init_thread(jt);\n+    stringStream ss;\n+    ss.print(\"Could not initialize class %s\", external_name());\n+    if (cause.is_null()) {\n+      THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), ss.as_string());\n+    } else {\n+      THROW_MSG_CAUSE(vmSymbols::java_lang_NoClassDefFoundError(),\n+                      ss.as_string(), cause);\n+    }\n@@ -1147,1 +1142,1 @@\n-    set_initialization_state_and_notify(fully_initialized, CHECK);\n+    set_initialization_state_and_notify(fully_initialized, THREAD);\n@@ -1180,4 +1175,8 @@\n-void InstanceKlass::set_initialization_state_and_notify(ClassState state, TRAPS) {\n-  Handle h_init_lock(THREAD, init_lock());\n-  if (h_init_lock() != NULL) {\n-    ObjectLocker ol(h_init_lock, THREAD);\n+void InstanceKlass::set_initialization_state_and_notify(ClassState state, JavaThread* current) {\n+  MonitorLocker ml(current, _init_monitor);\n+\n+  \/\/ Now flush all code that assume the class is not linked.\n+  \/\/ Set state under the Compile_lock also.\n+  if (state == linked && UseVtableBasedCHA && Universe::is_fully_initialized()) {\n+    MutexLocker ml(current, Compile_lock);\n+\n@@ -1186,2 +1185,2 @@\n-    fence_and_clear_init_lock();\n-    ol.notify_all(CHECK);\n+\n+    CodeCache::flush_dependents_on(this);\n@@ -1189,1 +1188,0 @@\n-    assert(h_init_lock() != NULL, \"The initialization state should never be set twice\");\n@@ -1193,0 +1191,1 @@\n+  ml.notify_all();\n@@ -2521,0 +2520,1 @@\n+  _init_monitor = NULL;\n@@ -2600,0 +2600,3 @@\n+\n+  \/\/ restore the monitor\n+  _init_monitor = create_init_monitor(\"InstanceKlassInitMonitorRestored_lock\");\n@@ -2707,0 +2710,3 @@\n+  \/\/ Destroy the init_monitor\n+  delete _init_monitor;\n+\n@@ -3380,1 +3386,1 @@\n-  \"allocated\", \"loaded\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n+  \"allocated\", \"loaded\", \"being_linked\", \"linked\", \"being_initialized\", \"fully_initialized\", \"initialization_error\"\n@@ -3934,0 +3940,3 @@\n+  if (state > loaded) {\n+    assert_lock_strong(_init_monitor);\n+  }\n@@ -3937,1 +3946,2 @@\n-  assert(good_state || state == allocated, \"illegal state transition\");\n+  bool link_failed = _init_state == being_linked && state == loaded;\n+  assert(good_state || state == allocated || link_failed, \"illegal state transition\");\n@@ -3940,1 +3950,1 @@\n-  _init_state = (u1)state;\n+  _init_state = state;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":79,"deletions":69,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  enum ClassState {\n+  enum ClassState : u1 {\n@@ -149,0 +149,1 @@\n+    being_linked,                       \/\/ currently running verifier and rewriter\n@@ -227,4 +228,1 @@\n-  \/\/ Class states are defined as ClassState (see above).\n-  \/\/ Place the _init_state here to utilize the unused 2-byte after\n-  \/\/ _idnum_allocated_count.\n-  u1              _init_state;              \/\/ state of class\n+  ClassState      _init_state;              \/\/ state of class\n@@ -232,1 +230,1 @@\n-  u1              _reference_type;                \/\/ reference type\n+  u1              _reference_type;          \/\/ reference type\n@@ -255,0 +253,1 @@\n+  Monitor*        _init_monitor;         \/\/ mutual exclusion to _init_state and _init_thread.\n@@ -256,0 +255,1 @@\n+\n@@ -539,8 +539,9 @@\n-  bool is_loaded() const                   { return _init_state >= loaded; }\n-  bool is_linked() const                   { return _init_state >= linked; }\n-  bool is_initialized() const              { return _init_state == fully_initialized; }\n-  bool is_not_initialized() const          { return _init_state <  being_initialized; }\n-  bool is_being_initialized() const        { return _init_state == being_initialized; }\n-  bool is_in_error_state() const           { return _init_state == initialization_error; }\n-  bool is_reentrant_initialization(Thread *thread)  { return thread == _init_thread; }\n-  ClassState  init_state()                 { return (ClassState)_init_state; }\n+  bool is_loaded() const                   { return init_state() >= loaded; }\n+  bool is_linked() const                   { return init_state() >= linked; }\n+  bool is_being_linked() const             { return init_state() == being_linked; }\n+  bool is_initialized() const              { return init_state() == fully_initialized; }\n+  bool is_not_initialized() const          { return init_state() <  being_initialized; }\n+  bool is_being_initialized() const        { return init_state() == being_initialized; }\n+  bool is_in_error_state() const           { return init_state() == initialization_error; }\n+  bool is_reentrant(Thread *thread)        { return thread == _init_thread; }\n+  ClassState  init_state() const           { return Atomic::load(&_init_state); }\n@@ -550,0 +551,15 @@\n+  class LockLinkState : public StackObj {\n+    InstanceKlass* _ik;\n+    JavaThread*    _current;\n+   public:\n+    LockLinkState(InstanceKlass* ik, JavaThread* current) : _ik(ik), _current(current) {\n+      ik->check_link_state_and_wait(current);\n+    }\n+    ~LockLinkState() {\n+      if (!_ik->is_linked()) {\n+        \/\/ Reset to loaded if linking failed.\n+        _ik->set_initialization_state_and_notify(loaded, _current);\n+      }\n+    }\n+  };\n+\n@@ -914,1 +930,1 @@\n-  void set_initialization_state_and_notify(ClassState state, TRAPS);\n+  void set_initialization_state_and_notify(ClassState state, JavaThread* current);\n@@ -1157,6 +1173,0 @@\n-  \/\/ Lock for (1) initialization; (2) access to the ConstantPool of this class.\n-  \/\/ Must be one per class and it has to be a VM internal object so java code\n-  \/\/ cannot lock it (like the mirror).\n-  \/\/ It has to be an object not a Mutex because it's held through java calls.\n-  oop init_lock() const;\n-\n@@ -1172,2 +1182,0 @@\n-private:\n-  void fence_and_clear_init_lock();\n@@ -1175,0 +1183,3 @@\n+  Monitor* init_monitor() const { return _init_monitor; }\n+private:\n+  void check_link_state_and_wait(JavaThread* current);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":34,"deletions":23,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -1408,1 +1408,1 @@\n-           callee_method->method_holder()->is_reentrant_initialization(current),\n+           callee_method->method_holder()->is_reentrant(current),\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-    else if (thread()->osthread()->get_state() == OBJECT_WAIT) {\n+    else if (thread()->osthread()->get_state() == CONDVAR_WAIT) {\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-  nonstatic_field(InstanceKlass,               _init_state,                                   u1)                                    \\\n+  nonstatic_field(InstanceKlass,               _init_state,                                   InstanceKlass::ClassState)             \\\n@@ -2283,0 +2283,1 @@\n+  declare_constant(InstanceKlass::being_linked)                           \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1129,8 +1129,0 @@\n-  \/\/ Also provide a pointer to the init_lock if present, so there aren't unreferenced int[0]\n-  \/\/ arrays.\n-  oop init_lock = ik->init_lock();\n-  if (init_lock != NULL) {\n-    field_count++;\n-    size += sizeof(address);\n-  }\n-\n@@ -1174,8 +1166,0 @@\n-\n-  \/\/ Add init lock to the end if the class is not yet initialized\n-  oop init_lock = ik->init_lock();\n-  if (init_lock != NULL) {\n-    writer->write_symbolID(vmSymbols::init_lock_name());         \/\/ name\n-    writer->write_u1(sig2tag(vmSymbols::int_array_signature())); \/\/ type\n-    writer->write_objectID(init_lock);\n-  }\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+  private static int CLASS_STATE_BEING_LINKED;\n@@ -121,0 +122,1 @@\n+    CLASS_STATE_BEING_LINKED = db.lookupIntConstant(\"InstanceKlass::being_linked\").intValue();\n@@ -187,0 +189,1 @@\n+     public static final ClassState BEING_LINKED = new ClassState(\"beingLinked\");\n@@ -210,0 +213,2 @@\n+     } else if (state == CLASS_STATE_BEING_LINKED) {\n+        return ClassState.BEING_LINKED;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-    final int instanceKlassInitStateOffset = getFieldOffset(\"InstanceKlass::_init_state\", Integer.class, \"u1\");\n+    final int instanceKlassInitStateOffset = getFieldOffset(\"InstanceKlass::_init_state\", Integer.class, \"InstanceKlass::ClassState\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,2 @@\n-    final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n+    \/\/ final static String IN_OBJECT_WAIT = \"in Object.wait()\";\n+    final static String IN_CONVAR_WAIT = \"waiting on condition\";\n@@ -142,1 +143,1 @@\n-                    if (!line.contains(IN_OBJECT_WAIT)) {\n+                    if (!line.contains(IN_CONVAR_WAIT)) {\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestThreadDumpClassInitMonitor.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}