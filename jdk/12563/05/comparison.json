{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit CorruptedZipFiles\n@@ -30,2 +31,6 @@\n-import java.util.*;\n-import java.util.zip.*;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+\n@@ -33,1 +38,10 @@\n-import static java.lang.System.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n@@ -35,0 +49,1 @@\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,11 +52,0 @@\n-    static int passed = 0, failed = 0;\n-\n-    static void fail(String msg) {\n-        failed++;\n-        err.println(msg);\n-    }\n-\n-    static void unexpected(Throwable t) {\n-        failed++;\n-        t.printStackTrace();\n-    }\n@@ -49,4 +53,83 @@\n-    public static void main(String[] args) throws Exception {\n-        try (FileOutputStream fos = new FileOutputStream(\"x.zip\");\n-             ZipOutputStream zos = new ZipOutputStream(fos))\n-        {\n+    \/*\n+     * Byte array holding a valid template ZIP.\n+     *\n+     * The 'good' ZIP file has the following structure:\n+     *\n+     * 0000 LOCAL HEADER #1       04034B50\n+     * 0004 Extract Zip Spec      14 '2.0'\n+     * 0005 Extract OS            00 'MS-DOS'\n+     * 0006 General Purpose Flag  0808\n+     *      [Bits 1-2]            0 'Normal Compression'\n+     *      [Bit  3]              1 'Streamed'\n+     *      [Bit 11]              1 'Language Encoding'\n+     * 0008 Compression Method    0008 'Deflated'\n+     * 000A Last Mod Time         567F7D07 'Fri Mar 31 15:40:14 2023'\n+     * 000E CRC                   00000000\n+     * 0012 Compressed Length     00000000\n+     * 0016 Uncompressed Length   00000000\n+     * 001A Filename Length       0001\n+     * 001C Extra Length          0000\n+     * 001E Filename              'x'\n+     * 001F PAYLOAD               ...\n+     *\n+     * 0022 STREAMING DATA HEADER 08074B50\n+     * 0026 CRC                   8CDC1683\n+     * 002A Compressed Length     00000003\n+     * 002E Uncompressed Length   00000001\n+     *\n+     * 0032 CENTRAL HEADER #1     02014B50\n+     * 0036 Created Zip Spec      14 '2.0'\n+     * 0037 Created OS            00 'MS-DOS'\n+     * 0038 Extract Zip Spec      14 '2.0'\n+     * 0039 Extract OS            00 'MS-DOS'\n+     * 003A General Purpose Flag  0808\n+     *      [Bits 1-2]            0 'Normal Compression'\n+     *      [Bit  3]              1 'Streamed'\n+     *      [Bit 11]              1 'Language Encoding'\n+     * 003C Compression Method    0008 'Deflated'\n+     * 003E Last Mod Time         567F7D07 'Fri Mar 31 15:40:14 2023'\n+     * 0042 CRC                   8CDC1683\n+     * 0046 Compressed Length     00000003\n+     * 004A Uncompressed Length   00000001\n+     * 004E Filename Length       0001\n+     * 0050 Extra Length          0000\n+     * 0052 Comment Length        0000\n+     * 0054 Disk Start            0000\n+     * 0056 Int File Attributes   0000\n+     *      [Bit 0]               0 'Binary Data'\n+     * 0058 Ext File Attributes   00000000\n+     * 005C Local Header Offset   00000000\n+     * 0060 Filename              'x'\n+     *\n+     * 0061 END CENTRAL HEADER    06054B50\n+     * 0065 Number of this disk   0000\n+     * 0067 Central Dir Disk no   0000\n+     * 0069 Entries in this disk  0001\n+     * 006B Total Entries         0001\n+     * 006D Size of Central Dir   0000002F\n+     * 0071 Offset to Central Dir 00000032\n+     * 0075 Comment Length        0000\n+     *\n+     *\/\n+    private static byte[] template;\n+\n+    \/\/ Copy of the template ZIP for modification by each test\n+    private byte[] copy;\n+\n+    \/\/ Litte-endian ByteBuffer for manipulating the ZIP copy\n+    private ByteBuffer buffer;\n+\n+    \/\/ Some well-known locations in the ZIP\n+    private static int endpos, cenpos, locpos;\n+\n+    \/\/ The path used when reading\/writing the corrupted ZIP to disk\n+    private Path zip = Path.of(\"corrupted.zip\");\n+\n+    \/*\n+     * Make a sample ZIP and calculate some known offsets into this ZIP\n+     *\/\n+    @BeforeAll\n+    public static void setup() throws IOException {\n+        \/\/ Make a ZIP with a single entry\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n@@ -57,0 +140,22 @@\n+        template = out.toByteArray();\n+        \/\/ ByteBuffer for reading fields from the ZIP\n+        ByteBuffer buffer = ByteBuffer.wrap(template).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ Calculate the offset of the End of central directory record\n+        endpos = template.length - ENDHDR;\n+        \/\/ Look up the offet of the Central directory header\n+        cenpos = buffer.getShort(endpos + ENDOFF);\n+        \/\/ Look up the offset of the corresponding Local file header\n+        locpos = buffer.getShort(cenpos + CENOFF);\n+\n+        \/\/ Run some sanity checks on the valid ZIP:\n+        assertEquals(ENDSIG, buffer.getInt(endpos),\"Where's ENDSIG?\");\n+        assertEquals(CENSIG, buffer.getInt(cenpos),\"Where's CENSIG?\");\n+        assertEquals(LOCSIG, buffer.getInt(locpos),\"Where's LOCSIG?\");\n+        assertEquals(buffer.getShort(cenpos+CENNAM),\n+                buffer.getShort(locpos+LOCNAM),\n+                \"Name field length mismatch\");\n+        assertEquals(buffer.getShort(cenpos+CENEXT),\n+                buffer.getShort( locpos+LOCEXT),\n+                \"Extra field length mismatch\");\n+    }\n@@ -58,113 +163,7 @@\n-        int len = (int)(new File(\"x.zip\").length());\n-        byte[] good = new byte[len];\n-        try (FileInputStream fis = new FileInputStream(\"x.zip\")) {\n-            fis.read(good);\n-        }\n-        new File(\"x.zip\").delete();\n-\n-        int endpos = len - ENDHDR;\n-        int cenpos = u16(good, endpos+ENDOFF);\n-        int locpos = u16(good, cenpos+CENOFF);\n-        if (u32(good, endpos) != ENDSIG) fail(\"Where's ENDSIG?\");\n-        if (u32(good, cenpos) != CENSIG) fail(\"Where's CENSIG?\");\n-        if (u32(good, locpos) != LOCSIG) fail(\"Where's LOCSIG?\");\n-        if (u16(good, locpos+LOCNAM) != u16(good,cenpos+CENNAM))\n-            fail(\"Name field length mismatch\");\n-        if (u16(good, locpos+LOCEXT) != u16(good,cenpos+CENEXT))\n-            fail(\"Extra field length mismatch\");\n-\n-        byte[] bad;\n-\n-        err.println(\"corrupted ENDSIZ\");\n-        bad = good.clone();\n-        bad[endpos+ENDSIZ]=(byte)0xff;\n-        checkZipException(bad, \".*bad central directory size.*\");\n-\n-        err.println(\"corrupted ENDOFF\");\n-        bad = good.clone();\n-        bad[endpos+ENDOFF]=(byte)0xff;\n-        checkZipException(bad, \".*bad central directory offset.*\");\n-\n-        err.println(\"corrupted CENSIG\");\n-        bad = good.clone();\n-        bad[cenpos]++;\n-        checkZipException(bad, \".*bad signature.*\");\n-\n-        err.println(\"corrupted CENFLG\");\n-        bad = good.clone();\n-        bad[cenpos+CENFLG] |= 1;\n-        checkZipException(bad, \".*encrypted entry.*\");\n-\n-        err.println(\"corrupted CENNAM 1\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENNAM 2\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]--;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENNAM 3\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]   = (byte)0xfd;\n-        bad[cenpos+CENNAM+1] = (byte)0xfd;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENEXT 1\");\n-        bad = good.clone();\n-        bad[cenpos+CENEXT]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENEXT 2\");\n-        bad = good.clone();\n-        bad[cenpos+CENEXT]   = (byte)0xfd;\n-        bad[cenpos+CENEXT+1] = (byte)0xfd;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENCOM\");\n-        bad = good.clone();\n-        bad[cenpos+CENCOM]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENHOW\");\n-        bad = good.clone();\n-        bad[cenpos+CENHOW] = 2;\n-        checkZipException(bad, \".*bad compression method.*\");\n-\n-        err.println(\"corrupted LOCSIG\");\n-        bad = good.clone();\n-        bad[locpos]++;\n-        checkZipExceptionInGetInputStream(bad, \".*bad signature.*\");\n-\n-        out.printf(\"passed = %d, failed = %d%n\", passed, failed);\n-        if (failed > 0) throw new Exception(\"Some tests failed\");\n-    }\n-\n-    static int uniquifier = 432;\n-\n-    static void checkZipExceptionImpl(byte[] data,\n-                                      String msgPattern,\n-                                      boolean getInputStream) {\n-        String zipName = \"bad\" + (uniquifier++) + \".zip\";\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(zipName)) {\n-                fos.write(data);\n-            }\n-            try (ZipFile zf = new ZipFile(zipName)) {\n-                if (getInputStream) {\n-                    InputStream is = zf.getInputStream(new ZipEntry(\"x\"));\n-                    is.read();\n-                }\n-            }\n-            fail(\"Failed to throw expected ZipException\");\n-        } catch (ZipException e) {\n-            if (e.getMessage().matches(msgPattern))\n-                passed++;\n-            else\n-                unexpected(e);\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            new File(zipName).delete();\n-        }\n+    \/*\n+     * Make a copy safe to modify by each test\n+     *\/\n+    @BeforeEach\n+    public void makeCopy() {\n+        copy = template.clone();\n+        buffer = ByteBuffer.wrap(copy).order(ByteOrder.LITTLE_ENDIAN);\n@@ -173,2 +172,6 @@\n-    static void checkZipException(byte[] data, String msgPattern) {\n-        checkZipExceptionImpl(data, msgPattern, false);\n+    \/*\n+     * Delete the ZIP file produced after each test method\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n@@ -177,2 +180,8 @@\n-    static void checkZipExceptionInGetInputStream(byte[] data, String msgPattern) {\n-        checkZipExceptionImpl(data, msgPattern, true);\n+    \/*\n+     * A ZipException is thrown when the 'End of Central Directory'\n+     * (END) header has a CEN size exceeding past the offset of the END record\n+     *\/\n+    @Test\n+    public void excessiveCENSize() throws IOException {\n+        buffer.putInt(endpos+ENDSIZ, 0xff000000);\n+        assertZipException(\".*bad central directory size.*\");\n@@ -181,2 +190,9 @@\n-    static int u8(byte[] data, int offset) {\n-        return data[offset]&0xff;\n+    \/*\n+     * A ZipException is thrown when the 'End of Central Directory'\n+     * (END) header has a CEN offset incoherent with the position calculated\n+     * by subtracting the CEN size from the END offset.\n+     *\/\n+    @Test\n+    public void excessiveCENOffset() throws IOException {\n+        buffer.putInt(endpos+ENDOFF, 0xff000000);\n+        assertZipException(\".*bad central directory offset.*\");\n@@ -185,2 +201,8 @@\n-    static int u16(byte[] data, int offset) {\n-        return u8(data,offset) + (u8(data,offset+1)<<8);\n+    \/*\n+     * A ZipException is thrown when a CEN header has an unexpected signature\n+     *\/\n+    @Test\n+    public void invalidCENSignature() throws IOException {\n+        int existingSignature = buffer.getInt(cenpos);\n+        buffer.putInt(cenpos, existingSignature +1);\n+        assertZipException(\".*bad signature.*\");\n@@ -189,2 +211,8 @@\n-    static int u32(byte[] data, int offset) {\n-        return u16(data,offset) + (u16(data,offset+2)<<16);\n+    \/*\n+     * A ZipException is thrown when a CEN header has the\n+     * 'general purpose bit flag 0' ('encrypted') set.\n+     *\/\n+    @Test\n+    public void encryptedEntry() throws IOException {\n+        copy[cenpos+CENFLG] |= 1;\n+        assertZipException(\".*encrypted entry.*\");\n@@ -193,6 +221,11 @@\n-    \/\/ The following can be deleted once this bug is fixed:\n-    \/\/ 6225935: \"import static\" accessibility rules for symbols different for no reason\n-    static final long LOCSIG = ZipFile.LOCSIG;\n-    static final long EXTSIG = ZipFile.EXTSIG;\n-    static final long CENSIG = ZipFile.CENSIG;\n-    static final long ENDSIG = ZipFile.ENDSIG;\n+    \/*\n+     * A ZipException is thrown when a CEN header has a file name\n+     *  length which makes the CEN header overflow into the\n+     * 'End of central directory' record.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength() throws IOException {\n+        short existingNameLength = buffer.getShort(cenpos + CENNAM);\n+        buffer.putShort(cenpos+CENNAM, (short) (existingNameLength + 1));\n+        assertZipException(\".*bad header size.*\");\n+    }\n@@ -200,4 +233,10 @@\n-    static final int LOCHDR = ZipFile.LOCHDR;\n-    static final int EXTHDR = ZipFile.EXTHDR;\n-    static final int CENHDR = ZipFile.CENHDR;\n-    static final int ENDHDR = ZipFile.ENDHDR;\n+    \/*\n+     * A ZipException is thrown when a CEN header has a\n+     * file name length which makes the CEN header overflow into the\n+     * 'End of central directory' record.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength2() throws IOException {\n+        buffer.putShort(cenpos + CENNAM, (short) 0xfdfd);\n+        assertZipException(\".*bad header size.*\");\n+    }\n@@ -205,9 +244,44 @@\n-    static final int LOCVER = ZipFile.LOCVER;\n-    static final int LOCFLG = ZipFile.LOCFLG;\n-    static final int LOCHOW = ZipFile.LOCHOW;\n-    static final int LOCTIM = ZipFile.LOCTIM;\n-    static final int LOCCRC = ZipFile.LOCCRC;\n-    static final int LOCSIZ = ZipFile.LOCSIZ;\n-    static final int LOCLEN = ZipFile.LOCLEN;\n-    static final int LOCNAM = ZipFile.LOCNAM;\n-    static final int LOCEXT = ZipFile.LOCEXT;\n+    \/*\n+     * A ZipException is thrown if the last CEN header is not immediately\n+     * followed by the start of the 'End of central directory' record\n+     *\/\n+    @Test\n+    public void insufficientFilenameLength() throws IOException {\n+        short existingNameLength = buffer.getShort(cenpos + CENNAM);\n+        buffer.putShort(cenpos+CENNAM, (short) (existingNameLength - 1));\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown if a CEN header has an\n+     * extra field length which makes the CEN header overflow into the\n+     * End of central directory record.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength() throws IOException {\n+        short existingExtraLength = buffer.getShort(cenpos + CENEXT);\n+        buffer.putShort(cenpos+CENEXT, (short) (existingExtraLength + 1));\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown if a CEN header has an\n+     * extra field length which makes the CEN header overflow into the\n+     * End of central directory record.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength2() throws IOException {\n+        buffer.putShort(cenpos+CENEXT, (short) 0xfdfd);\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a CEN header has a comment length\n+     * which overflows into the 'End of central directory' record\n+     *\/\n+    @Test\n+    public void excessiveCommentLength() throws IOException {\n+        short existingCommentLength = buffer.getShort(cenpos + CENCOM);\n+        buffer.putShort(cenpos+CENCOM, (short) (existingCommentLength + 1));\n+        assertZipException(\".*bad header size.*\");\n+    }\n@@ -215,15 +289,19 @@\n-    static final int CENVEM = ZipFile.CENVEM;\n-    static final int CENVER = ZipFile.CENVER;\n-    static final int CENFLG = ZipFile.CENFLG;\n-    static final int CENHOW = ZipFile.CENHOW;\n-    static final int CENTIM = ZipFile.CENTIM;\n-    static final int CENCRC = ZipFile.CENCRC;\n-    static final int CENSIZ = ZipFile.CENSIZ;\n-    static final int CENLEN = ZipFile.CENLEN;\n-    static final int CENNAM = ZipFile.CENNAM;\n-    static final int CENEXT = ZipFile.CENEXT;\n-    static final int CENCOM = ZipFile.CENCOM;\n-    static final int CENDSK = ZipFile.CENDSK;\n-    static final int CENATT = ZipFile.CENATT;\n-    static final int CENATX = ZipFile.CENATX;\n-    static final int CENOFF = ZipFile.CENOFF;\n+    \/*\n+     * A ZipException is thrown when a CEN header has a\n+     * compression method field which is unsupported by the implementation\n+     *\/\n+    @Test\n+    public void unsupportedCompressionMethod() throws IOException {\n+        copy[cenpos+CENHOW] = 2;\n+        assertZipException(\".*bad compression method.*\");\n+    }\n+\n+    \/*\n+     * A ZipException is thrown when a LOC header has an unexpected signature\n+     *\/\n+    @Test\n+    public void invalidLOCSignature() throws IOException {\n+        int existingSignatur = buffer.getInt(locpos);\n+        buffer.putInt(locpos, existingSignatur +1);\n+        assertZipException(\".*bad signature.*\");\n+    }\n@@ -231,5 +309,22 @@\n-    static final int ENDSUB = ZipFile.ENDSUB;\n-    static final int ENDTOT = ZipFile.ENDTOT;\n-    static final int ENDSIZ = ZipFile.ENDSIZ;\n-    static final int ENDOFF = ZipFile.ENDOFF;\n-    static final int ENDCOM = ZipFile.ENDCOM;\n+    \/*\n+     * Assert that opening a ZIP file and consuming the entry's\n+     * InputStream using the ZipFile API fails with a ZipException\n+     * with a message matching the given pattern.\n+     *\n+     * The ZIP file opened is the contents of the 'copy' byte array.\n+     *\/\n+    void assertZipException(String msgPattern) throws IOException {\n+\n+        Files.write(zip, copy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (ZipFile zf = new ZipFile(zip.toFile())) {\n+                try (InputStream is = zf.getInputStream(new ZipEntry(\"x\"))) {\n+                    is.transferTo(OutputStream.nullOutputStream());\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().matches(msgPattern),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":276,"deletions":181,"binary":false,"changes":457,"status":"modified"}]}