{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run junit CorruptedZipFiles\n@@ -30,2 +31,6 @@\n-import java.util.*;\n-import java.util.zip.*;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n@@ -33,1 +38,10 @@\n-import static java.lang.System.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n@@ -35,0 +49,1 @@\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -37,1 +52,0 @@\n-    static int passed = 0, failed = 0;\n@@ -39,4 +53,2 @@\n-    static void fail(String msg) {\n-        failed++;\n-        err.println(msg);\n-    }\n+    \/\/ Byte array holding a valid template ZIP\n+    private static byte[] template;\n@@ -44,4 +56,5 @@\n-    static void unexpected(Throwable t) {\n-        failed++;\n-        t.printStackTrace();\n-    }\n+    \/\/ Copy of the template ZIP for modification by each test\n+    private byte[] copy;\n+\n+    \/\/ Some well-known locations in the ZIP\n+    private static int endpos, cenpos, locpos;\n@@ -49,4 +62,11 @@\n-    public static void main(String[] args) throws Exception {\n-        try (FileOutputStream fos = new FileOutputStream(\"x.zip\");\n-             ZipOutputStream zos = new ZipOutputStream(fos))\n-        {\n+    \/\/ The path used when reading\/writing the corrupted ZIP to disk\n+    private Path zip = Path.of(\"corrupted.zip\");\n+\n+    \/*\n+     * Make a sample ZIP and calculate some known offsets into this ZIP\n+     *\/\n+    @BeforeClass\n+    public static void setup() throws IOException {\n+        \/\/ Make a ZIP with a single entry\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n@@ -57,0 +77,22 @@\n+        template = out.toByteArray();\n+        \/\/ ByteBuffer for reading fields from the ZIP\n+        ByteBuffer buffer = ByteBuffer.wrap(template).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        \/\/ Calculate the offset of the End of central directory record\n+        endpos = template.length - ENDHDR;\n+        \/\/ Look up the offet of the Central directory header\n+        cenpos = buffer.getShort(endpos + ENDOFF);\n+        \/\/ Look up the offset of the corresponding Local file header\n+        locpos = buffer.getShort(cenpos + CENOFF);\n+\n+        \/\/ Run some sanity checks on the valid ZIP:\n+        assertEquals(ENDSIG, buffer.getInt(endpos),\"Where's ENDSIG?\");\n+        assertEquals(CENSIG, buffer.getInt(cenpos),\"Where's CENSIG?\");\n+        assertEquals(LOCSIG, buffer.getInt(locpos),\"Where's LOCSIG?\");\n+        assertEquals(buffer.getShort(cenpos+CENNAM),\n+                buffer.getShort(locpos+LOCNAM),\n+                \"Name field length mismatch\");\n+        assertEquals(buffer.getShort(cenpos+CENEXT),\n+                buffer.getShort( locpos+LOCEXT),\n+                \"Extra field length mismatch\");\n+    }\n@@ -58,113 +100,6 @@\n-        int len = (int)(new File(\"x.zip\").length());\n-        byte[] good = new byte[len];\n-        try (FileInputStream fis = new FileInputStream(\"x.zip\")) {\n-            fis.read(good);\n-        }\n-        new File(\"x.zip\").delete();\n-\n-        int endpos = len - ENDHDR;\n-        int cenpos = u16(good, endpos+ENDOFF);\n-        int locpos = u16(good, cenpos+CENOFF);\n-        if (u32(good, endpos) != ENDSIG) fail(\"Where's ENDSIG?\");\n-        if (u32(good, cenpos) != CENSIG) fail(\"Where's CENSIG?\");\n-        if (u32(good, locpos) != LOCSIG) fail(\"Where's LOCSIG?\");\n-        if (u16(good, locpos+LOCNAM) != u16(good,cenpos+CENNAM))\n-            fail(\"Name field length mismatch\");\n-        if (u16(good, locpos+LOCEXT) != u16(good,cenpos+CENEXT))\n-            fail(\"Extra field length mismatch\");\n-\n-        byte[] bad;\n-\n-        err.println(\"corrupted ENDSIZ\");\n-        bad = good.clone();\n-        bad[endpos+ENDSIZ]=(byte)0xff;\n-        checkZipException(bad, \".*bad central directory size.*\");\n-\n-        err.println(\"corrupted ENDOFF\");\n-        bad = good.clone();\n-        bad[endpos+ENDOFF]=(byte)0xff;\n-        checkZipException(bad, \".*bad central directory offset.*\");\n-\n-        err.println(\"corrupted CENSIG\");\n-        bad = good.clone();\n-        bad[cenpos]++;\n-        checkZipException(bad, \".*bad signature.*\");\n-\n-        err.println(\"corrupted CENFLG\");\n-        bad = good.clone();\n-        bad[cenpos+CENFLG] |= 1;\n-        checkZipException(bad, \".*encrypted entry.*\");\n-\n-        err.println(\"corrupted CENNAM 1\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENNAM 2\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]--;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENNAM 3\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]   = (byte)0xfd;\n-        bad[cenpos+CENNAM+1] = (byte)0xfd;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENEXT 1\");\n-        bad = good.clone();\n-        bad[cenpos+CENEXT]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENEXT 2\");\n-        bad = good.clone();\n-        bad[cenpos+CENEXT]   = (byte)0xfd;\n-        bad[cenpos+CENEXT+1] = (byte)0xfd;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENCOM\");\n-        bad = good.clone();\n-        bad[cenpos+CENCOM]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENHOW\");\n-        bad = good.clone();\n-        bad[cenpos+CENHOW] = 2;\n-        checkZipException(bad, \".*bad compression method.*\");\n-\n-        err.println(\"corrupted LOCSIG\");\n-        bad = good.clone();\n-        bad[locpos]++;\n-        checkZipExceptionInGetInputStream(bad, \".*bad signature.*\");\n-\n-        out.printf(\"passed = %d, failed = %d%n\", passed, failed);\n-        if (failed > 0) throw new Exception(\"Some tests failed\");\n-    }\n-\n-    static int uniquifier = 432;\n-\n-    static void checkZipExceptionImpl(byte[] data,\n-                                      String msgPattern,\n-                                      boolean getInputStream) {\n-        String zipName = \"bad\" + (uniquifier++) + \".zip\";\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(zipName)) {\n-                fos.write(data);\n-            }\n-            try (ZipFile zf = new ZipFile(zipName)) {\n-                if (getInputStream) {\n-                    InputStream is = zf.getInputStream(new ZipEntry(\"x\"));\n-                    is.read();\n-                }\n-            }\n-            fail(\"Failed to throw expected ZipException\");\n-        } catch (ZipException e) {\n-            if (e.getMessage().matches(msgPattern))\n-                passed++;\n-            else\n-                unexpected(e);\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            new File(zipName).delete();\n-        }\n+    \/*\n+     * Make a copy safe to modify by each test\n+     *\/\n+    @Before\n+    public void makeCopy() {\n+        copy = template.clone();\n@@ -173,2 +108,6 @@\n-    static void checkZipException(byte[] data, String msgPattern) {\n-        checkZipExceptionImpl(data, msgPattern, false);\n+    \/*\n+     * Delete the ZIP file produced after each test method\n+     *\/\n+    @After\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n@@ -177,2 +116,9 @@\n-    static void checkZipExceptionInGetInputStream(byte[] data, String msgPattern) {\n-        checkZipExceptionImpl(data, msgPattern, true);\n+    \/*\n+     * An End of Central Directory header with a CEN size exceeding\n+     * past the offset of the End record itself should be rejected with\n+     * a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveCENSize() throws IOException {\n+        copy[endpos+ENDSIZ]=(byte)0xff;\n+        assertZipException(\".*bad central directory size.*\");\n@@ -181,2 +127,9 @@\n-    static int u8(byte[] data, int offset) {\n-        return data[offset]&0xff;\n+    \/*\n+     * An End of Central Directory header with a CEN offset incoherent\n+     * with the position calculated by subtracting the CEN size from\n+     * the End position should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveCENOffset() throws IOException {\n+        copy[endpos+ENDOFF]=(byte)0xff;\n+        assertZipException(\".*bad central directory offset.*\");\n@@ -185,2 +138,8 @@\n-    static int u16(byte[] data, int offset) {\n-        return u8(data,offset) + (u8(data,offset+1)<<8);\n+    \/*\n+     * A CEN header with an unexpected signature should be rejected\n+     * with a ZipException.\n+     *\/\n+    @Test\n+    public void invalidCENSignature() throws IOException {\n+        copy[cenpos]++;\n+        assertZipException(\".*bad signature.*\");\n@@ -189,2 +148,8 @@\n-    static int u32(byte[] data, int offset) {\n-        return u16(data,offset) + (u16(data,offset+2)<<16);\n+    \/*\n+     * A CEN header where the general purpose bit flag 0 ('encrypted')\n+     * is set should be rejected with a ZipException\n+     *\/\n+    @Test\n+    public void encryptedEntry() throws IOException {\n+        copy[cenpos+CENFLG] |= 1;\n+        assertZipException(\".*encrypted entry.*\");\n@@ -193,6 +158,9 @@\n-    \/\/ The following can be deleted once this bug is fixed:\n-    \/\/ 6225935: \"import static\" accessibility rules for symbols different for no reason\n-    static final long LOCSIG = ZipFile.LOCSIG;\n-    static final long EXTSIG = ZipFile.EXTSIG;\n-    static final long CENSIG = ZipFile.CENSIG;\n-    static final long ENDSIG = ZipFile.ENDSIG;\n+    \/*\n+     * A File name length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength() throws IOException {\n+        copy[cenpos+CENNAM]++;\n+        assertZipException(\".*bad header size.*\");\n+    }\n@@ -200,4 +168,10 @@\n-    static final int LOCHDR = ZipFile.LOCHDR;\n-    static final int EXTHDR = ZipFile.EXTHDR;\n-    static final int CENHDR = ZipFile.CENHDR;\n-    static final int ENDHDR = ZipFile.ENDHDR;\n+    \/*\n+     * A File name length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength2() throws IOException {\n+        copy[cenpos+CENNAM]   = (byte)0xfd;\n+        copy[cenpos+CENNAM+1] = (byte)0xfd;\n+        assertZipException(\".*bad header size.*\");\n+    }\n@@ -205,9 +179,40 @@\n-    static final int LOCVER = ZipFile.LOCVER;\n-    static final int LOCFLG = ZipFile.LOCFLG;\n-    static final int LOCHOW = ZipFile.LOCHOW;\n-    static final int LOCTIM = ZipFile.LOCTIM;\n-    static final int LOCCRC = ZipFile.LOCCRC;\n-    static final int LOCSIZ = ZipFile.LOCSIZ;\n-    static final int LOCLEN = ZipFile.LOCLEN;\n-    static final int LOCNAM = ZipFile.LOCNAM;\n-    static final int LOCEXT = ZipFile.LOCEXT;\n+    \/*\n+     * If the last CEN header is not immediatly followed by the start\n+     * of the End record, this should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void insufficientFilenameLength() throws IOException {\n+        copy[cenpos+CENNAM]--;\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * An Extra field length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength() throws IOException {\n+        copy[cenpos+CENEXT]++;\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * An Extra field length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength2() throws IOException {\n+        copy[cenpos+CENEXT]   = (byte)0xfd;\n+        copy[cenpos+CENEXT+1] = (byte)0xfd;\n+        assertZipException(\".*bad header size.*\");\n+    }\n+\n+    \/*\n+     * A File comment length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveCommentLength() throws IOException {\n+        copy[cenpos+CENCOM]++;\n+        assertZipException(\".*bad header size.*\");\n+    }\n@@ -215,15 +220,19 @@\n-    static final int CENVEM = ZipFile.CENVEM;\n-    static final int CENVER = ZipFile.CENVER;\n-    static final int CENFLG = ZipFile.CENFLG;\n-    static final int CENHOW = ZipFile.CENHOW;\n-    static final int CENTIM = ZipFile.CENTIM;\n-    static final int CENCRC = ZipFile.CENCRC;\n-    static final int CENSIZ = ZipFile.CENSIZ;\n-    static final int CENLEN = ZipFile.CENLEN;\n-    static final int CENNAM = ZipFile.CENNAM;\n-    static final int CENEXT = ZipFile.CENEXT;\n-    static final int CENCOM = ZipFile.CENCOM;\n-    static final int CENDSK = ZipFile.CENDSK;\n-    static final int CENATT = ZipFile.CENATT;\n-    static final int CENATX = ZipFile.CENATX;\n-    static final int CENOFF = ZipFile.CENOFF;\n+    \/*\n+     * A CEN header with an unsupported compression method should be rejected\n+     * with a ZipException.\n+     *\/\n+    @Test\n+    public void unsupportedCompressionMethod() throws IOException {\n+        copy[cenpos+CENHOW] = 2;\n+        assertZipException(\".*bad compression method.*\");\n+    }\n+\n+    \/*\n+     * A LOC header with an unexpected signature should be rejected\n+     * with a ZipException.\n+     *\/\n+    @Test\n+    public void invalidLOCSignature() throws IOException {\n+        copy[locpos]++;\n+        assertZipException(\".*bad signature.*\");\n+    }\n@@ -231,5 +240,22 @@\n-    static final int ENDSUB = ZipFile.ENDSUB;\n-    static final int ENDTOT = ZipFile.ENDTOT;\n-    static final int ENDSIZ = ZipFile.ENDSIZ;\n-    static final int ENDOFF = ZipFile.ENDOFF;\n-    static final int ENDCOM = ZipFile.ENDCOM;\n+    \/*\n+     * Assert that opening a ZIP file and consuming the entry's\n+     * InputStream using the ZipFile API fails with a ZipException\n+     * with a message matching the given pattern.\n+     *\n+     * The ZIP file opened is the contents of the 'copy' byte array.\n+     *\/\n+    void assertZipException(String msgPattern) throws IOException {\n+\n+        Files.write(zip, copy);\n+\n+        ZipException ex = assertThrows(ZipException.class, () -> {\n+            try (ZipFile zf = new ZipFile(zip.toFile())) {\n+                try (InputStream is = zf.getInputStream(new ZipEntry(\"x\"))) {\n+                    is.transferTo(OutputStream.nullOutputStream());\n+                }\n+            }\n+        });\n+        assertTrue(ex.getMessage().matches(msgPattern),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":205,"deletions":179,"binary":false,"changes":384,"status":"modified"}]}