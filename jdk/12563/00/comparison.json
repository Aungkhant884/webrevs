{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+ * @run testng CorruptedZipFiles\n@@ -30,2 +31,5 @@\n-import java.util.*;\n-import java.util.zip.*;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.Test;\n+\n@@ -33,1 +37,8 @@\n-import static java.lang.System.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n@@ -35,0 +46,1 @@\n+import static org.testng.Assert.*;\n@@ -37,1 +49,0 @@\n-    static int passed = 0, failed = 0;\n@@ -39,4 +50,2 @@\n-    static void fail(String msg) {\n-        failed++;\n-        err.println(msg);\n-    }\n+    \/\/ Byte array holding a valid template ZIP\n+    private byte[] template;\n@@ -44,4 +53,8 @@\n-    static void unexpected(Throwable t) {\n-        failed++;\n-        t.printStackTrace();\n-    }\n+    \/\/ Copy of the template ZIP for modification by each test\n+    private byte[] copy;\n+\n+    \/\/ Some well-known locations in the ZIP\n+    private int endpos, cenpos, locpos;\n+\n+    \/\/ The path used when reading\/writing the corrupted ZIP to disk\n+    private Path zip = Path.of(\"corrupted.zip\");\n@@ -49,4 +62,8 @@\n-    public static void main(String[] args) throws Exception {\n-        try (FileOutputStream fos = new FileOutputStream(\"x.zip\");\n-             ZipOutputStream zos = new ZipOutputStream(fos))\n-        {\n+    \/**\n+     * Make a sample ZIP and calculate some known offsets into this ZIP\n+     *\/\n+    @BeforeTest\n+    public void setup() throws IOException {\n+        \/\/ Make a ZIP with a single entry\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(out)) {\n@@ -57,0 +74,18 @@\n+        template = out.toByteArray();\n+\n+        \/\/ Calculate the offset of the End of central directory record\n+        endpos = template.length - ENDHDR;\n+        \/\/ Look up the offet of the Central directory header\n+        cenpos = u16(template, endpos+ENDOFF);\n+        \/\/ Look up the offset of the corresponding Local file header\n+        locpos = u16(template, cenpos + CENOFF);\n+\n+        \/\/ Run some sanity checks on the valid ZIP:\n+        assertEquals(u32(template, endpos), ENDSIG, \"Where's ENDSIG?\");\n+        assertEquals(u32(template, cenpos), CENSIG, \"Where's CENSIG?\");\n+        assertEquals(u32(template, locpos), LOCSIG, \"Where's LOCSIG?\");\n+        assertEquals(u16(template, locpos+LOCNAM), u16(template,cenpos+CENNAM),\n+            \"Name field length mismatch\");\n+        assertEquals(u16(template, locpos+LOCEXT), u16(template,cenpos+CENEXT),\n+            \"Extra field length mismatch\");\n+    }\n@@ -58,97 +93,147 @@\n-        int len = (int)(new File(\"x.zip\").length());\n-        byte[] good = new byte[len];\n-        try (FileInputStream fis = new FileInputStream(\"x.zip\")) {\n-            fis.read(good);\n-        }\n-        new File(\"x.zip\").delete();\n-\n-        int endpos = len - ENDHDR;\n-        int cenpos = u16(good, endpos+ENDOFF);\n-        int locpos = u16(good, cenpos+CENOFF);\n-        if (u32(good, endpos) != ENDSIG) fail(\"Where's ENDSIG?\");\n-        if (u32(good, cenpos) != CENSIG) fail(\"Where's CENSIG?\");\n-        if (u32(good, locpos) != LOCSIG) fail(\"Where's LOCSIG?\");\n-        if (u16(good, locpos+LOCNAM) != u16(good,cenpos+CENNAM))\n-            fail(\"Name field length mismatch\");\n-        if (u16(good, locpos+LOCEXT) != u16(good,cenpos+CENEXT))\n-            fail(\"Extra field length mismatch\");\n-\n-        byte[] bad;\n-\n-        err.println(\"corrupted ENDSIZ\");\n-        bad = good.clone();\n-        bad[endpos+ENDSIZ]=(byte)0xff;\n-        checkZipException(bad, \".*bad central directory size.*\");\n-\n-        err.println(\"corrupted ENDOFF\");\n-        bad = good.clone();\n-        bad[endpos+ENDOFF]=(byte)0xff;\n-        checkZipException(bad, \".*bad central directory offset.*\");\n-\n-        err.println(\"corrupted CENSIG\");\n-        bad = good.clone();\n-        bad[cenpos]++;\n-        checkZipException(bad, \".*bad signature.*\");\n-\n-        err.println(\"corrupted CENFLG\");\n-        bad = good.clone();\n-        bad[cenpos+CENFLG] |= 1;\n-        checkZipException(bad, \".*encrypted entry.*\");\n-\n-        err.println(\"corrupted CENNAM 1\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENNAM 2\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]--;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENNAM 3\");\n-        bad = good.clone();\n-        bad[cenpos+CENNAM]   = (byte)0xfd;\n-        bad[cenpos+CENNAM+1] = (byte)0xfd;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENEXT 1\");\n-        bad = good.clone();\n-        bad[cenpos+CENEXT]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENEXT 2\");\n-        bad = good.clone();\n-        bad[cenpos+CENEXT]   = (byte)0xfd;\n-        bad[cenpos+CENEXT+1] = (byte)0xfd;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENCOM\");\n-        bad = good.clone();\n-        bad[cenpos+CENCOM]++;\n-        checkZipException(bad, \".*bad header size.*\");\n-\n-        err.println(\"corrupted CENHOW\");\n-        bad = good.clone();\n-        bad[cenpos+CENHOW] = 2;\n-        checkZipException(bad, \".*bad compression method.*\");\n-\n-        err.println(\"corrupted LOCSIG\");\n-        bad = good.clone();\n-        bad[locpos]++;\n-        checkZipExceptionInGetInputStream(bad, \".*bad signature.*\");\n-\n-        out.printf(\"passed = %d, failed = %d%n\", passed, failed);\n-        if (failed > 0) throw new Exception(\"Some tests failed\");\n-    }\n-\n-    static int uniquifier = 432;\n-\n-    static void checkZipExceptionImpl(byte[] data,\n-                                      String msgPattern,\n-                                      boolean getInputStream) {\n-        String zipName = \"bad\" + (uniquifier++) + \".zip\";\n-        try {\n-            try (FileOutputStream fos = new FileOutputStream(zipName)) {\n-                fos.write(data);\n-            }\n-            try (ZipFile zf = new ZipFile(zipName)) {\n+    \/**\n+     * Make a copy safe to modify by each test\n+     *\/\n+    @BeforeMethod\n+    public void makeCopy() {\n+        copy = Arrays.copyOf(template, template.length);\n+    }\n+\n+    \/**\n+     * Delete the ZIP file produced after each test method\n+     *\/\n+    @AfterMethod\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * An End of Central Directory header with a CEN size exceeding\n+     * past the offset of the End record itself should be rejected with\n+     * a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveCENSize() throws IOException {\n+        copy[endpos+ENDSIZ]=(byte)0xff;\n+        checkZipException(\".*bad central directory size.*\");\n+    }\n+\n+    \/**\n+     * An End of Central Directory header with a CEN offset incoherent\n+     * with the position calculated by subtracting the CEN size from\n+     * the End position should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveCENOffset() throws IOException {\n+        copy[endpos+ENDOFF]=(byte)0xff;\n+        checkZipException(\".*bad central directory offset.*\");\n+    }\n+\n+    \/**\n+     * A CEN header with an unexpected signature should be rejected\n+     * with a ZipException.\n+     *\/\n+    @Test\n+    public void invalidCENSignature() throws IOException {\n+        copy[cenpos]++;\n+        checkZipException(\".*bad signature.*\");\n+    }\n+\n+    \/**\n+     * A CEN header where the general purpose bit flag 0 ('encrypted')\n+     * is set should be rejected with a ZipException\n+     *\/\n+    @Test\n+    public void encryptedEntry() throws IOException {\n+        copy[cenpos+CENFLG] |= 1;\n+        checkZipException(\".*encrypted entry.*\");\n+    }\n+\n+    \/**\n+     * A File name length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength() throws IOException {\n+        copy[cenpos+CENNAM]++;\n+        checkZipException(\".*bad header size.*\");\n+    }\n+\n+    \/**\n+     * A File name length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveFileNameLength2() throws IOException {\n+        copy[cenpos+CENNAM]   = (byte)0xfd;\n+        copy[cenpos+CENNAM+1] = (byte)0xfd;\n+        checkZipException(\".*bad header size.*\");\n+    }\n+\n+    \/**\n+     * If the last CEN header is not immediatly followed by the start\n+     * of the End record, this should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void insufficientFilenameLength() throws IOException {\n+        copy[cenpos+CENNAM]--;\n+        checkZipException(\".*bad header size.*\");\n+    }\n+\n+    \/**\n+     * An Extra field length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength() throws IOException {\n+        copy[cenpos+CENEXT]++;\n+        checkZipException(\".*bad header size.*\");\n+    }\n+\n+    \/**\n+     * An Extra field length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveExtraFieldLength2() throws IOException {\n+        copy[cenpos+CENEXT]   = (byte)0xfd;\n+        copy[cenpos+CENEXT+1] = (byte)0xfd;\n+        checkZipException(\".*bad header size.*\");\n+    }\n+\n+    \/**\n+     * A File comment length which makes the CEN header overflow into the\n+     * End of central directory record should be rejected with a ZipException.\n+     *\/\n+    @Test\n+    public void excessiveCommentLength() throws IOException {\n+        copy[cenpos+CENCOM]++;\n+        checkZipException(\".*bad header size.*\");\n+    }\n+\n+    \/**\n+     * A CEN header with an unsupported compression method should be rejected\n+     * with a ZipException.\n+     *\/\n+    @Test\n+    public void unsupportedCompressionMethod() throws IOException {\n+        copy[cenpos+CENHOW] = 2;\n+        checkZipException(\".*bad compression method.*\");\n+    }\n+\n+    \/**\n+     * A LOC header with an unexpected signature should be rejected\n+     * with a ZipException.\n+     *\/\n+    @Test\n+    public void invalidLOCSignature() throws IOException {\n+        copy[locpos]++;\n+        checkZipExceptionInGetInputStream(\".*bad signature.*\");\n+    }\n+\n+    void checkZipExceptionImpl(String msgPattern,\n+                               boolean getInputStream) throws IOException {\n+\n+        Files.write(zip, copy);\n+\n+        ZipException ex = expectThrows(ZipException.class, () -> {\n+            try (ZipFile zf = new ZipFile(zip.toFile())) {\n@@ -156,2 +241,3 @@\n-                    InputStream is = zf.getInputStream(new ZipEntry(\"x\"));\n-                    is.read();\n+                    try (InputStream is = zf.getInputStream(new ZipEntry(\"x\"))) {\n+                        is.transferTo(OutputStream.nullOutputStream());\n+                    }\n@@ -160,11 +246,4 @@\n-            fail(\"Failed to throw expected ZipException\");\n-        } catch (ZipException e) {\n-            if (e.getMessage().matches(msgPattern))\n-                passed++;\n-            else\n-                unexpected(e);\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            new File(zipName).delete();\n-        }\n+        });\n+        assertTrue(ex.getMessage().matches(msgPattern),\n+                \"Unexpected ZipException message: \" + ex.getMessage());\n+\n@@ -173,2 +252,2 @@\n-    static void checkZipException(byte[] data, String msgPattern) {\n-        checkZipExceptionImpl(data, msgPattern, false);\n+    void checkZipException(String msgPattern) throws IOException {\n+        checkZipExceptionImpl(msgPattern, false);\n@@ -177,2 +256,2 @@\n-    static void checkZipExceptionInGetInputStream(byte[] data, String msgPattern) {\n-        checkZipExceptionImpl(data, msgPattern, true);\n+    void checkZipExceptionInGetInputStream(String msgPattern) throws IOException {\n+        checkZipExceptionImpl(msgPattern, true);\n@@ -182,1 +261,1 @@\n-        return data[offset]&0xff;\n+        return data[offset] & 0xff;\n@@ -186,1 +265,1 @@\n-        return u8(data,offset) + (u8(data,offset+1)<<8);\n+        return u8(data,offset) + (u8(data,offset+1) << 8);\n@@ -190,46 +269,2 @@\n-        return u16(data,offset) + (u16(data,offset+2)<<16);\n-    }\n-\n-    \/\/ The following can be deleted once this bug is fixed:\n-    \/\/ 6225935: \"import static\" accessibility rules for symbols different for no reason\n-    static final long LOCSIG = ZipFile.LOCSIG;\n-    static final long EXTSIG = ZipFile.EXTSIG;\n-    static final long CENSIG = ZipFile.CENSIG;\n-    static final long ENDSIG = ZipFile.ENDSIG;\n-\n-    static final int LOCHDR = ZipFile.LOCHDR;\n-    static final int EXTHDR = ZipFile.EXTHDR;\n-    static final int CENHDR = ZipFile.CENHDR;\n-    static final int ENDHDR = ZipFile.ENDHDR;\n-\n-    static final int LOCVER = ZipFile.LOCVER;\n-    static final int LOCFLG = ZipFile.LOCFLG;\n-    static final int LOCHOW = ZipFile.LOCHOW;\n-    static final int LOCTIM = ZipFile.LOCTIM;\n-    static final int LOCCRC = ZipFile.LOCCRC;\n-    static final int LOCSIZ = ZipFile.LOCSIZ;\n-    static final int LOCLEN = ZipFile.LOCLEN;\n-    static final int LOCNAM = ZipFile.LOCNAM;\n-    static final int LOCEXT = ZipFile.LOCEXT;\n-\n-    static final int CENVEM = ZipFile.CENVEM;\n-    static final int CENVER = ZipFile.CENVER;\n-    static final int CENFLG = ZipFile.CENFLG;\n-    static final int CENHOW = ZipFile.CENHOW;\n-    static final int CENTIM = ZipFile.CENTIM;\n-    static final int CENCRC = ZipFile.CENCRC;\n-    static final int CENSIZ = ZipFile.CENSIZ;\n-    static final int CENLEN = ZipFile.CENLEN;\n-    static final int CENNAM = ZipFile.CENNAM;\n-    static final int CENEXT = ZipFile.CENEXT;\n-    static final int CENCOM = ZipFile.CENCOM;\n-    static final int CENDSK = ZipFile.CENDSK;\n-    static final int CENATT = ZipFile.CENATT;\n-    static final int CENATX = ZipFile.CENATX;\n-    static final int CENOFF = ZipFile.CENOFF;\n-\n-    static final int ENDSUB = ZipFile.ENDSUB;\n-    static final int ENDTOT = ZipFile.ENDTOT;\n-    static final int ENDSIZ = ZipFile.ENDSIZ;\n-    static final int ENDOFF = ZipFile.ENDOFF;\n-    static final int ENDCOM = ZipFile.ENDCOM;\n+        return u16(data,offset) + (u16(data,offset+2) << 16);\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":214,"deletions":179,"binary":false,"changes":393,"status":"modified"}]}