{"files":[{"patch":"@@ -53,1 +53,61 @@\n-    \/\/ Byte array holding a valid template ZIP\n+    \/*\n+     * Byte array holding a valid template ZIP.\n+     *\n+     * This 'good' ZIP file has the following structure:\n+     *\n+     * 0000 LOCAL HEADER #1       04034B50\n+     * 0004 Extract Zip Spec      14 '2.0'\n+     * 0005 Extract OS            00 'MS-DOS'\n+     * 0006 General Purpose Flag  0808\n+     *      [Bits 1-2]            0 'Normal Compression'\n+     *      [Bit  3]              1 'Streamed'\n+     *      [Bit 11]              1 'Language Encoding'\n+     * 0008 Compression Method    0008 'Deflated'\n+     * 000A Last Mod Time         567F7D07 'Fri Mar 31 15:40:14 2023'\n+     * 000E CRC                   00000000\n+     * 0012 Compressed Length     00000000\n+     * 0016 Uncompressed Length   00000000\n+     * 001A Filename Length       0001\n+     * 001C Extra Length          0000\n+     * 001E Filename              'x'\n+     * 001F PAYLOAD               ...\n+     *\n+     * 0022 STREAMING DATA HEADER 08074B50\n+     * 0026 CRC                   8CDC1683\n+     * 002A Compressed Length     00000003\n+     * 002E Uncompressed Length   00000001\n+     *\n+     * 0032 CENTRAL HEADER #1     02014B50\n+     * 0036 Created Zip Spec      14 '2.0'\n+     * 0037 Created OS            00 'MS-DOS'\n+     * 0038 Extract Zip Spec      14 '2.0'\n+     * 0039 Extract OS            00 'MS-DOS'\n+     * 003A General Purpose Flag  0808\n+     *      [Bits 1-2]            0 'Normal Compression'\n+     *      [Bit  3]              1 'Streamed'\n+     *      [Bit 11]              1 'Language Encoding'\n+     * 003C Compression Method    0008 'Deflated'\n+     * 003E Last Mod Time         567F7D07 'Fri Mar 31 15:40:14 2023'\n+     * 0042 CRC                   8CDC1683\n+     * 0046 Compressed Length     00000003\n+     * 004A Uncompressed Length   00000001\n+     * 004E Filename Length       0001\n+     * 0050 Extra Length          0000\n+     * 0052 Comment Length        0000\n+     * 0054 Disk Start            0000\n+     * 0056 Int File Attributes   0000\n+     *      [Bit 0]               0 'Binary Data'\n+     * 0058 Ext File Attributes   00000000\n+     * 005C Local Header Offset   00000000\n+     * 0060 Filename              'x'\n+     *\n+     * 0061 END CENTRAL HEADER    06054B50\n+     * 0065 Number of this disk   0000\n+     * 0067 Central Dir Disk no   0000\n+     * 0069 Entries in this disk  0001\n+     * 006B Total Entries         0001\n+     * 006D Size of Central Dir   0000002F\n+     * 0071 Offset to Central Dir 00000032\n+     * 0075 Comment Length        0000\n+     *\n+     *\/\n@@ -59,0 +119,3 @@\n+    \/\/ Litte-endian ByteBuffer for manipulating the ZIP copy\n+    private ByteBuffer buffer;\n+\n@@ -106,0 +169,1 @@\n+        buffer = ByteBuffer.wrap(copy).order(ByteOrder.LITTLE_ENDIAN);\n@@ -117,3 +181,2 @@\n-     * An End of Central Directory header with a CEN size exceeding\n-     * past the offset of the End record itself should be rejected with\n-     * a ZipException.\n+     * Validate that a ZipException is thrown when the 'End of Central Directory'\n+     * (END) header has a CEN size exceeding past the offset of the END record\n@@ -123,1 +186,1 @@\n-        copy[endpos+ENDSIZ]=(byte)0xff;\n+        buffer.putInt(endpos+ENDSIZ, 0xff000000);\n@@ -128,3 +191,3 @@\n-     * An End of Central Directory header with a CEN offset incoherent\n-     * with the position calculated by subtracting the CEN size from\n-     * the End position should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown when the 'End of Central Directory'\n+     * (END) header has a CEN offset incoherent with the position calculated\n+     * by subtracting the CEN size from the END offset.\n@@ -134,1 +197,1 @@\n-        copy[endpos+ENDOFF]=(byte)0xff;\n+        buffer.putInt(endpos+ENDOFF, 0xff000000);\n@@ -139,2 +202,1 @@\n-     * A CEN header with an unexpected signature should be rejected\n-     * with a ZipException.\n+     * Validate that a ZipException is thrown when a A CEN header has an unexpected signature\n@@ -144,1 +206,2 @@\n-        copy[cenpos]++;\n+        int existingSignature = buffer.getInt(cenpos);\n+        buffer.putInt(cenpos, existingSignature +1);\n@@ -149,2 +212,2 @@\n-     * A CEN header where the general purpose bit flag 0 ('encrypted')\n-     * is set should be rejected with a ZipException\n+     * Validate that a ZipException is thrown when a CEN header has the 'general\n+     * purpose bit flag 0' ('encrypted') set.\n@@ -159,2 +222,3 @@\n-     * A File name length which makes the CEN header overflow into the\n-     * End of central directory record should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown when a CEN header has a\n+     * file name length which makes the CEN header overflow into the\n+     * 'End of central directory' record.\n@@ -164,1 +228,2 @@\n-        copy[cenpos+CENNAM]++;\n+        short existingNameLength = buffer.getShort(cenpos + CENNAM);\n+        buffer.putShort(cenpos+CENNAM, (short) (existingNameLength + 1));\n@@ -169,2 +234,3 @@\n-     * A File name length which makes the CEN header overflow into the\n-     * End of central directory record should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown when a CEN header has a\n+     * file name length which makes the CEN header overflow into the\n+     * 'End of central directory' record.\n@@ -174,2 +240,1 @@\n-        copy[cenpos+CENNAM]   = (byte)0xfd;\n-        copy[cenpos+CENNAM+1] = (byte)0xfd;\n+        buffer.putShort(cenpos + CENNAM, (short) 0xfdfd);\n@@ -180,2 +245,2 @@\n-     * If the last CEN header is not immediatly followed by the start\n-     * of the End record, this should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown if the last CEN header is\n+     * not immediatly followed by the start of the 'End of central directory' record\n@@ -185,1 +250,2 @@\n-        copy[cenpos+CENNAM]--;\n+        short existingNameLength = buffer.getShort(cenpos + CENNAM);\n+        buffer.putShort(cenpos+CENNAM, (short) (existingNameLength - 1));\n@@ -190,2 +256,3 @@\n-     * An Extra field length which makes the CEN header overflow into the\n-     * End of central directory record should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown if a CEN header has an\n+     * extra field length which makes the CEN header overflow into the\n+     * End of central directory record.\n@@ -195,1 +262,2 @@\n-        copy[cenpos+CENEXT]++;\n+        short existingExtraLength = buffer.getShort(cenpos + CENEXT);\n+        buffer.putShort(cenpos+CENEXT, (short) (existingExtraLength + 1));\n@@ -200,2 +268,3 @@\n-     * An Extra field length which makes the CEN header overflow into the\n-     * End of central directory record should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown if a CEN header has an\n+     * extra field length which makes the CEN header overflow into the\n+     * End of central directory record.\n@@ -205,2 +274,1 @@\n-        copy[cenpos+CENEXT]   = (byte)0xfd;\n-        copy[cenpos+CENEXT+1] = (byte)0xfd;\n+        buffer.putShort(cenpos+CENEXT, (short) 0xfdfd);\n@@ -211,2 +279,2 @@\n-     * A File comment length which makes the CEN header overflow into the\n-     * End of central directory record should be rejected with a ZipException.\n+     * Validate that a ZipException is thrown when a CEN header has a comment length\n+     * which overflows into the 'End of central directory' record\n@@ -216,1 +284,2 @@\n-        copy[cenpos+CENCOM]++;\n+        short existingCommentLength = buffer.getShort(cenpos + CENCOM);\n+        buffer.putShort(cenpos+CENCOM, (short) (existingCommentLength + 1));\n@@ -221,2 +290,2 @@\n-     * A CEN header with an unsupported compression method should be rejected\n-     * with a ZipException.\n+     * Validate that a ZipException is thrown when a CEN header has a\n+     * compression method field which is unsupported by the implementation\n@@ -231,2 +300,1 @@\n-     * A LOC header with an unexpected signature should be rejected\n-     * with a ZipException.\n+     * Validate that a ZipException is thrown when a LOC header has an unexpected signature\n@@ -236,1 +304,2 @@\n-        copy[locpos]++;\n+        int existingSignatur = buffer.getInt(locpos);\n+        buffer.putInt(locpos, existingSignatur +1);\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":108,"deletions":39,"binary":false,"changes":147,"status":"modified"}]}