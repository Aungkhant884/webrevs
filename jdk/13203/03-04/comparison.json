{"files":[{"patch":"@@ -1144,1 +1144,0 @@\n-  \/\/ disabled if vritual threads are enabled with --enable-preview\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-import java.util.function.Predicate;\n-import java.util.stream.Stream;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Thread.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -544,0 +544,1 @@\n+        assert threadContainer() == null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/VirtualThread.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test that Thread.sleep emits a JFR jdk.ThreadSleep event\n+ * @run junit ThreadSleepEvent\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.IntStream;\n+import java.util.stream.LongStream;\n+import java.util.stream.Stream;\n+import static java.util.concurrent.TimeUnit.*;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordingFile;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class ThreadSleepEvent {\n+    private static final String THREAD_SLEEP_EVENT_NAME = \"jdk.ThreadSleep\";\n+\n+    static Stream<ThreadFactory> threadFactories() {\n+        return Stream.of(\n+                Thread.ofPlatform().factory(),\n+                Thread.ofVirtual().factory()\n+        );\n+    }\n+\n+    \/\/ Arguments.of(ThreadFactory, millis)\n+    static Stream<Arguments> threadFactoryAndMillis() {\n+        long[] millis = {0, 1000, Long.MAX_VALUE};\n+        return threadFactories()\n+                .flatMap(f -> LongStream.of(millis)\n+                        .mapToObj(ms -> Arguments.of(f, ms)));\n+    }\n+\n+    \/\/ Arguments.of(ThreadFactory, millis, nanos)\n+    static Stream<Arguments> threadFactoryAndMillisAndNanos() {\n+        int[] nanos = {0, 1000, 999_999};\n+        return threadFactoryAndMillis().flatMap(a -> IntStream.of(nanos)\n+                .mapToObj(ns -> Arguments.of(a.get()[0], a.get()[1], ns)));\n+    }\n+\n+    \/\/ Arguments.of(ThreadFactory, Duration)\n+    static Stream<Arguments> threadFactoryAndDuration() {\n+        Duration[] durations = {\n+                Duration.ofNanos(0),\n+                Duration.ofSeconds(1),\n+                Duration.ofSeconds(Long.MAX_VALUE, 999_999_999)\n+        };\n+        return threadFactories()\n+                .flatMap(f -> Stream.of(durations)\n+                        .map(d -> Arguments.of(f, d)));\n+    }\n+\n+    \/**\n+     * Test Thread.sleep(long) emits event.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactoryAndMillis\")\n+    void testSleep(ThreadFactory factory, long millis) throws Exception {\n+        long expectedTime = MILLISECONDS.toNanos(millis);\n+        long recordedTime = testSleep(factory, () -> Thread.sleep(millis));\n+        assertEquals(expectedTime, recordedTime);\n+    }\n+\n+    \/**\n+     * Test Thread.sleep(long, int) emits event.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactoryAndMillisAndNanos\")\n+    void testSleep(ThreadFactory factory, long millis, int nanos) throws Exception {\n+        long expectedTime = MILLISECONDS.toNanos(millis);\n+        expectedTime += Math.min(Long.MAX_VALUE - expectedTime, nanos);\n+        long recordedTime = testSleep(factory, () -> Thread.sleep(millis, nanos));\n+        assertEquals(expectedTime, recordedTime);\n+    }\n+\n+    \/**\n+     * Test Thread.sleep(Duration) emits event.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"threadFactoryAndDuration\")\n+    void testSleep(ThreadFactory factory, Duration duration) throws Exception {\n+        long expectedTime = NANOSECONDS.convert(duration);\n+        long recordedTime = testSleep(factory, () -> Thread.sleep(duration));\n+        assertEquals(expectedTime, recordedTime);\n+    }\n+\n+    \/**\n+     * Test that sleeper emits event, returning the recorded sleep time.\n+     *\/\n+    long testSleep(ThreadFactory factory, Sleeper sleeper) throws Exception {\n+        try (Recording recording = new Recording()) {\n+            long tid;\n+\n+            recording.enable(THREAD_SLEEP_EVENT_NAME);\n+            recording.start();\n+            try {\n+\n+                \/\/ start thread to run sleeper task\n+                var latch = new CountDownLatch(1);\n+                Thread thread = factory.newThread(() -> {\n+                    latch.countDown();\n+                    try {\n+                        sleeper.run();\n+                    } catch (InterruptedException e) {\n+                        \/\/ ignore;\n+                    }\n+                });\n+                thread.start();\n+\n+                \/\/ wait for thread to execute\n+                latch.await();\n+\n+                \/\/ don't wait for the sleep time\n+                thread.interrupt();\n+\n+                thread.join();\n+                tid = thread.threadId();\n+            } finally {\n+                recording.stop();\n+            }\n+\n+            \/\/ find the ThreadSleep event recorded by the thread\n+            RecordedEvent event = find(recording, THREAD_SLEEP_EVENT_NAME, tid).orElseThrow();\n+            return event.getLong(\"time\");\n+        }\n+    }\n+\n+    private interface Sleeper {\n+        void run() throws InterruptedException;\n+    }\n+\n+    \/**\n+     * Find a recorded event with the given name and recorded by a thread with the\n+     * given thread ID.\n+     *\/\n+    private static Optional<RecordedEvent> find(Recording recording,\n+                                                String name,\n+                                                long tid) throws Exception {\n+        Path recordingFile = recordingFile(recording);\n+        List<RecordedEvent> events = RecordingFile.readAllEvents(recordingFile);\n+        return events.stream()\n+                .filter(e -> e.getEventType().getName().equals(name)\n+                        && e.getThread().getJavaThreadId() == tid)\n+                .findAny();\n+    }\n+\n+    \/**\n+     * Return the file path to the recording file.\n+     *\/\n+    private static Path recordingFile(Recording recording) throws Exception {\n+        Path recordingFile = recording.getDestination();\n+        if (recordingFile == null) {\n+            ProcessHandle h = ProcessHandle.current();\n+            recordingFile = Path.of(\"recording-\" + recording.getId() + \"-pid\" + h.pid() + \".jfr\");\n+            recording.dump(recordingFile);\n+        }\n+        return recordingFile;\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/Thread\/ThreadSleepEvent.java","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test Thread.sleep when emitting the JFR ThreadSleepEvent throws OOME\n+ * @summary Test Thread.sleep when emitting the JFR jdk.ThreadSleep event throws OOME\n","filename":"test\/jdk\/java\/lang\/Thread\/ThreadSleepEventThrows.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-     * Runs a task in a virutal thread, returning a String with any output printed\n+     * Run a task in a virtual thread, returning a String with any output printed\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TracePinnedThreads.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-     * Runs a task in a virutal thread, returning a String with any output printed\n+     * Run a task in a virtual thread, returning a String with any output printed\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/TraceVirtualThreadLocals.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}