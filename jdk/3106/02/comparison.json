{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.ref.Cleaner.Cleanable;\n+import jdk.internal.ref.CleanerFactory;\n@@ -104,5 +106,4 @@\n-     * This object causes the timer's task execution thread to exit\n-     * gracefully when there are no live references to the Timer object and no\n-     * tasks in the timer queue.  It is used in preference to a finalizer on\n-     * Timer as such a finalizer would be susceptible to a subclass's\n-     * finalizer forgetting to call it.\n+     * An object of this class is registered with a Cleaner as the cleanup\n+     * handler for this Timer object.  This causes the execution thread to\n+     * exit gracefully when there are no live references to the Timer object\n+     * and no tasks in the timer queue.\n@@ -110,3 +111,10 @@\n-    private final Object threadReaper = new Object() {\n-        @SuppressWarnings(\"deprecation\")\n-        protected void finalize() throws Throwable {\n+    private static class ThreadReaper implements Runnable {\n+        private final TaskQueue queue;\n+        private final TimerThread thread;\n+\n+        ThreadReaper(TaskQueue queue, TimerThread thread) {\n+            this.queue = queue;\n+            this.thread = thread;\n+        }\n+\n+        public void run() {\n@@ -118,1 +126,3 @@\n-    };\n+    }\n+\n+    private final Cleanable cleanup;\n@@ -160,2 +170,1 @@\n-        thread.setName(name);\n-        thread.start();\n+        this(name, false);\n@@ -175,0 +184,2 @@\n+        var threadReaper = new ThreadReaper(queue, thread);\n+        this.cleanup = CleanerFactory.cleaner().register(this, threadReaper);\n@@ -431,1 +442,0 @@\n-            thread.newTasksMayBeScheduled = false;\n@@ -433,1 +443,1 @@\n-            queue.notify();  \/\/ In case queue was already empty.\n+            cleanup.clean();\n","filename":"src\/java.base\/share\/classes\/java\/util\/Timer.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263903\n+ * @requires vm.gc != \"Epsilon\"\n+ * @summary Discarding a Timer causes the Timer thread to stop.\n+ *\/\n+\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.lang.ref.Reference;\n+\n+public class AutoStop {\n+    static final Object wakeup = new Object();\n+    static Thread tdThread = null;\n+    static volatile int counter = 0;\n+    static final int COUNTER_LIMIT = 10;\n+\n+    public static void main(String[] args) throws Exception {\n+        Timer t = new Timer();\n+\n+        \/\/ Run an event that records the timer thread.\n+        t.schedule(new TimerTask() {\n+                public void run() {\n+                    synchronized(wakeup) {\n+                        tdThread = Thread.currentThread();\n+                        wakeup.notify();\n+                    }\n+                }\n+            }, 0);\n+\n+        \/\/ Wait for the thread to be accessible.\n+        try {\n+            synchronized(wakeup) {\n+                while (tdThread == null) {\n+                    wakeup.wait();\n+                }\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+\n+        \/\/ Schedule some events that increment the counter.\n+        for (int i = 0; i < COUNTER_LIMIT; ++i) {\n+            t.schedule(new TimerTask() {\n+                    public void run() {\n+                        ++counter;\n+                    }\n+                }, 100);\n+        }\n+\n+        \/\/ Ensure the timer is accessible at least until here.\n+        Reference.reachabilityFence(t);\n+        t = null;               \/\/ Remove the reference to the timer.\n+        System.gc();            \/\/ Run GC to trigger cleanup.\n+        tdThread.join();        \/\/ Wait for thread to stop.\n+        int finalCounter = counter;\n+        if (finalCounter != COUNTER_LIMIT) {\n+            throw new RuntimeException(\"Unrun events: counter = \" + finalCounter);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/java\/util\/Timer\/AutoStop.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}