{"files":[{"patch":"@@ -36,0 +36,1 @@\n+import java.util.function.Supplier;\n@@ -37,0 +38,1 @@\n+import java.util.Map;\n@@ -45,1 +47,2 @@\n-import jdk.internal.access.SharedSecrets;\n+import jdk.internal.util.ReferencedKeySet;\n+import jdk.internal.util.ReferenceKey;\n@@ -230,1 +233,7 @@\n-    static final ConcurrentWeakInternSet<MethodType> internTable = new ConcurrentWeakInternSet<>();\n+    static final ReferencedKeySet<MethodType> internTable =\n+        ReferencedKeySet.create(false, new Supplier<>() {\n+            @Override\n+            public Map<ReferenceKey<MethodType>, ReferenceKey<MethodType>> get() {\n+                return new ConcurrentHashMap<>(512);\n+            }\n+        });\n@@ -408,1 +417,1 @@\n-        return internTable.add(mt);\n+        return internTable.intern(mt);\n@@ -886,4 +895,0 @@\n-    \/\/ This implementation may also return true if x is a WeakEntry containing\n-    \/\/ a method type that is equal to this. This is an internal implementation\n-    \/\/ detail to allow for faster method type lookups.\n-    \/\/ See ConcurrentWeakInternSet.WeakEntry#equals(Object)\n@@ -898,4 +903,0 @@\n-        if (x instanceof ConcurrentWeakInternSet.WeakEntry<?> e\n-                && e.get() instanceof MethodType mt) {\n-            return equals(mt);\n-        }\n@@ -1393,108 +1394,0 @@\n-\n-    \/**\n-     * Simple implementation of weak concurrent intern set.\n-     *\n-     * @param <T> interned type\n-     *\/\n-    private static class ConcurrentWeakInternSet<T> {\n-\n-        private final ConcurrentMap<WeakEntry<T>, WeakEntry<T>> map;\n-        private final ReferenceQueue<T> stale;\n-\n-        public ConcurrentWeakInternSet() {\n-            this.map = new ConcurrentHashMap<>(512);\n-            this.stale = SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue();\n-        }\n-\n-        \/**\n-         * Get the existing interned element.\n-         * This method returns null if no element is interned.\n-         *\n-         * @param elem element to look up\n-         * @return the interned element\n-         *\/\n-        public T get(T elem) {\n-            if (elem == null) throw new NullPointerException();\n-            expungeStaleElements();\n-\n-            WeakEntry<T> value = map.get(elem);\n-            if (value != null) {\n-                T res = value.get();\n-                if (res != null) {\n-                    return res;\n-                }\n-            }\n-            return null;\n-        }\n-\n-        \/**\n-         * Interns the element.\n-         * Always returns non-null element, matching the one in the intern set.\n-         * Under the race against another add(), it can return <i>different<\/i>\n-         * element, if another thread beats us to interning it.\n-         *\n-         * @param elem element to add\n-         * @return element that was actually added\n-         *\/\n-        public T add(T elem) {\n-            if (elem == null) throw new NullPointerException();\n-\n-            \/\/ Playing double race here, and so spinloop is required.\n-            \/\/ First race is with two concurrent updaters.\n-            \/\/ Second race is with GC purging weak ref under our feet.\n-            \/\/ Hopefully, we almost always end up with a single pass.\n-            T interned;\n-            WeakEntry<T> e = new WeakEntry<>(elem, stale);\n-            do {\n-                expungeStaleElements();\n-                WeakEntry<T> exist = map.putIfAbsent(e, e);\n-                interned = (exist == null) ? elem : exist.get();\n-            } while (interned == null);\n-            return interned;\n-        }\n-\n-        private void expungeStaleElements() {\n-            Reference<? extends T> reference;\n-            while ((reference = stale.poll()) != null) {\n-                map.remove(reference);\n-            }\n-        }\n-\n-        private static class WeakEntry<T> extends WeakReference<T> {\n-\n-            public final int hashcode;\n-\n-            public WeakEntry(T key, ReferenceQueue<T> queue) {\n-                super(key, queue);\n-                hashcode = key.hashCode();\n-            }\n-\n-            \/**\n-             * This implementation returns {@code true} if {@code obj} is another\n-             * {@code WeakEntry} whose referent is equal to this referent, or\n-             * if {@code obj} is equal to the referent of this. This allows\n-             * lookups to be made without wrapping in a {@code WeakEntry}.\n-             *\n-             * @param obj the object to compare\n-             * @return true if {@code obj} is equal to this or the referent of this\n-             * @see MethodType#equals(Object)\n-             * @see Object#equals(Object)\n-             *\/\n-            @Override\n-            public boolean equals(Object obj) {\n-                Object mine = get();\n-                if (obj instanceof WeakEntry<?> we) {\n-                    Object that = we.get();\n-                    return (that == null || mine == null) ? (this == obj) : mine.equals(that);\n-                }\n-                return (mine == null) ? (obj == null) : mine.equals(obj);\n-            }\n-\n-            @Override\n-            public int hashCode() {\n-                return hashcode;\n-            }\n-\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":12,"deletions":119,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -369,1 +370,1 @@\n-                methodTypeCache = ReferencedKeyMap.create(ConcurrentHashMap::new);\n+                methodTypeCache = ReferencedKeyMap.create(false, ConcurrentHashMap::new);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carriers.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.lang.ref.WeakReference;\n-import java.util.Objects;\n-\n-\/**\n- * View\/wrapper of keys used by the backing {@link ReferencedKeyMap}.\n- * There are two style of keys; one for entries in the backing map and\n- * one for queries to the backing map. This second style avoids the\n- * overhead of a {@link Reference} object.\n- *\n- * @param <T> key type\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-sealed interface ReferenceKey<T> permits StrongReferenceKey, WeakReferenceKey, SoftReferenceKey {\n-    \/**\n-     * {@return the value of the unwrapped key}\n-     *\/\n-    T get();\n-\n-    \/**\n-     * Cleanup unused key.\n-     *\/\n-    void unused();\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferenceKey.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,334 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n-import java.lang.ref.SoftReference;\n-import java.lang.ref.WeakReference;\n-import java.util.AbstractMap;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Objects;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Supplier;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-\/**\n- * This class provides management of {@link Map maps} where it is desirable to\n- * remove entries automatically when the key is garbage collected. This is\n- * accomplished by using a backing map where the keys are either a\n- * {@link WeakReference} or a {@link SoftReference}.\n- * <p>\n- * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}\n- * of the backing map and whether {@link WeakReference} or\n- * {@link SoftReference} is to be used.\n- *\n- * {@snippet :\n- * \/\/ Use HashMap and WeakReference\n- * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);\n- * map.put(10_000_000L, \"a\");\n- * map.put(10_000_001L, \"b\");\n- * map.put(10_000_002L, \"c\");\n- * map.put(10_000_003L, \"d\");\n- * map.put(10_000_004L, \"e\");\n- *\n- * \/\/ Use ConcurrentHashMap and SoftReference\n- * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n- * map.put(20_000_000L, \"v\");\n- * map.put(20_000_001L, \"w\");\n- * map.put(20_000_002L, \"x\");\n- * map.put(20_000_003L, \"y\");\n- * map.put(20_000_004L, \"z\");\n- * }\n- *\n- * @implNote Care must be given that the backing map does replacement by\n- * replacing the value in the map entry instead of deleting the old entry and\n- * adding a new entry, otherwise replaced entries may end up with a strongly\n- * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\n- * to be safe.\n- *\n- * @param <K> the type of keys maintained by this map\n- * @param <V> the type of mapped values\n- *\n- * @since 21\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n- *\/\n-final class ReferencedKeyMap<K, V> implements Map<K, V> {\n-    \/**\n-     * true if {@link SoftReference} keys are to be used,\n-     * {@link WeakReference} otherwise.\n-     *\/\n-    private final boolean isSoft;\n-\n-    \/**\n-     * Backing {@link Map}.\n-     *\/\n-    private final Map<ReferenceKey<K>, V> map;\n-\n-    \/**\n-     * {@link ReferenceQueue} for cleaning up {@link WeakReferenceKey EntryKeys}.\n-     *\/\n-    private final ReferenceQueue<K> stale;\n-\n-    \/**\n-     * Private constructor.\n-     *\n-     * @param isSoft  true if {@link SoftReference} keys are to\n-     *                be used, {@link WeakReference} otherwise.\n-     * @param map     backing map\n-     *\/\n-    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\n-        this.isSoft = isSoft;\n-        this.map = map;\n-        this.stale = new ReferenceQueue<>();\n-    }\n-\n-    \/**\n-     * Create a new {@link ReferencedKeyMap} map.\n-     *\n-     * @param isSoft    true if {@link SoftReference} keys are to\n-     *                  be used, {@link WeakReference} otherwise.\n-     * @param supplier  {@link Supplier} of the backing map\n-     *\n-     * @return a new map with {@link Reference} keys\n-     *\n-     * @param <K> the type of keys maintained by the new map\n-     * @param <V> the type of mapped values\n-     *\/\n-    static <K, V> ReferencedKeyMap<K, V>\n-    create(boolean isSoft, Supplier<Map<ReferenceKey<K>, V>> supplier) {\n-        return new ReferencedKeyMap<K, V>(isSoft, supplier.get());\n-    }\n-\n-    \/**\n-     * Create a new {@link ReferencedKeyMap} map using\n-     * {@link WeakReference} keys.\n-     *\n-     * @param supplier  {@link Supplier} of the backing map\n-     *\n-     * @return a new map with {@link Reference} keys\n-     *\n-     * @param <K> the type of keys maintained by the new map\n-     * @param <V> the type of mapped values\n-     *\/\n-    static <K, V> ReferencedKeyMap<K, V>\n-    create(Supplier<Map<ReferenceKey<K>, V>> supplier) {\n-        return new ReferencedKeyMap<K, V>(false, supplier.get());\n-    }\n-\n-    \/**\n-     * {@return a key suitable for a map entry}\n-     *\n-     * @param key unwrapped key\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private ReferenceKey<K> entryKey(Object key) {\n-        if (isSoft) {\n-            return new SoftReferenceKey<>((K)key, stale);\n-        } else {\n-            return new WeakReferenceKey<>((K)key, stale);\n-        }\n-    }\n-\n-    \/**\n-     * {@return a key suitable for lookup}\n-     *\n-     * @param key unwrapped key\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    private ReferenceKey<K> lookupKey(Object key) {\n-        return new StrongReferenceKey<>((K)key);\n-    }\n-\n-    @Override\n-    public int size() {\n-        removeStaleReferences();\n-        return map.size();\n-    }\n-\n-    @Override\n-    public boolean isEmpty() {\n-        removeStaleReferences();\n-        return map.isEmpty();\n-    }\n-\n-    @Override\n-    public boolean containsKey(Object key) {\n-        Objects.requireNonNull(key, \"key must not be null\");\n-        removeStaleReferences();\n-        return map.containsKey(lookupKey(key));\n-    }\n-\n-    @Override\n-    public boolean containsValue(Object value) {\n-        Objects.requireNonNull(value, \"value must not be null\");\n-        removeStaleReferences();\n-        return map.containsValue(value);\n-    }\n-\n-    @Override\n-    public V get(Object key) {\n-        Objects.requireNonNull(key, \"key must not be null\");\n-        removeStaleReferences();\n-        return map.get(lookupKey(key));\n-    }\n-\n-    @Override\n-    public V put(K key, V newValue) {\n-        Objects.requireNonNull(key, \"key must not be null\");\n-        Objects.requireNonNull(newValue, \"value must not be null\");\n-        removeStaleReferences();\n-        ReferenceKey<K> entryKey = entryKey(key);\n-        \/\/ If {@code put} returns non-null then was actually a {@code replace}\n-        \/\/ and older key was used. In that case the new key was not used and the\n-        \/\/ reference marked stale.\n-        V oldValue = map.put(entryKey, newValue);\n-        if (oldValue != null) {\n-            entryKey.unused();\n-        }\n-        return oldValue;\n-    }\n-\n-    @Override\n-    public V remove(Object key) {\n-        \/\/ Rely on gc to clean up old key.\n-        return map.remove(lookupKey(key));\n-    }\n-\n-    @Override\n-    public void putAll(Map<? extends K, ? extends V> m) {\n-        removeStaleReferences();\n-        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\n-            K key = entry.getKey();\n-            V value = entry.getValue();\n-            put(key, value);\n-        }\n-    }\n-\n-    @Override\n-    public void clear() {\n-        removeStaleReferences();\n-        \/\/ Rely on gc to clean up old keys.\n-        map.clear();\n-    }\n-\n-    \/**\n-     * Common routine for collecting the current set of keys.\n-     *\n-     * @return {@link Stream} of valid keys (unwrapped)\n-     *\/\n-    private Stream<K> filterKeySet() {\n-        return map.keySet()\n-                .stream()\n-                .map(ReferenceKey::get)\n-                .filter(Objects::nonNull);\n-    }\n-\n-    @Override\n-    public Set<K> keySet() {\n-        removeStaleReferences();\n-        return filterKeySet().collect(Collectors.toSet());\n-    }\n-\n-    @Override\n-    public Collection<V> values() {\n-        removeStaleReferences();\n-        return map.values();\n-    }\n-\n-    @Override\n-    public Set<Entry<K, V>> entrySet() {\n-        removeStaleReferences();\n-        return filterKeySet()\n-                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\n-                .collect(Collectors.toSet());\n-    }\n-\n-    @Override\n-    public V putIfAbsent(K key, V newValue) {\n-        removeStaleReferences();\n-        ReferenceKey<K> entryKey = entryKey(key);\n-        \/\/ If {@code putIfAbsent} returns non-null then was actually a\n-        \/\/ {@code replace}  and older key was used. In that case the new key was\n-        \/\/ not used and the reference marked stale.\n-        V oldValue = map.putIfAbsent(entryKey, newValue);\n-        if (oldValue != null) {\n-            entryKey.unused();\n-        }\n-        return oldValue;\n-    }\n-\n-    @Override\n-    public boolean remove(Object key, Object value) {\n-        \/\/ Rely on gc to clean up old key.\n-        return map.remove(lookupKey(key), value);\n-    }\n-\n-    @Override\n-    public boolean replace(K key, V oldValue, V newValue) {\n-        removeStaleReferences();\n-        \/\/ If replace is successful then the older key will be used and the\n-        \/\/ lookup key will suffice.\n-        return map.replace(lookupKey(key), oldValue, newValue);\n-    }\n-\n-    @Override\n-    public V replace(K key, V value) {\n-        removeStaleReferences();\n-        \/\/ If replace is successful then the older key will be used and the\n-        \/\/ lookup key will suffice.\n-        return map.replace(lookupKey(key), value);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        removeStaleReferences();\n-        return filterKeySet()\n-                .map(k -> k + \"=\" + get(k))\n-                .collect(Collectors.joining(\", \", \"{\", \"}\"));\n-    }\n-\n-    \/**\n-     * Removes enqueued weak references from map.\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public void removeStaleReferences() {\n-        while (true) {\n-            WeakReferenceKey<K> key = (WeakReferenceKey<K>)stale.poll();\n-            if (key == null) {\n-                break;\n-            }\n-            map.remove(key);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferencedKeyMap.java","additions":0,"deletions":334,"binary":false,"changes":334,"status":"deleted"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.lang.ref.Reference;\n+\n+\/**\n+ * View\/wrapper of keys used by the backing {@link ReferencedKeyMap}.\n+ * There are two style of keys; one for entries in the backing map and\n+ * one for queries to the backing map. This second style avoids the\n+ * overhead of a {@link Reference} object.\n+ *\n+ * @param <T> key type\n+ *\n+ * @since 21\n+ *\/\n+public sealed interface ReferenceKey<T> permits StrongReferenceKey, WeakReferenceKey, SoftReferenceKey {\n+    \/**\n+     * {@return the value of the unwrapped key}\n+     *\/\n+    T get();\n+\n+    \/**\n+     * Cleanup unused key.\n+     *\/\n+    void unused();\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferenceKey.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,377 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Objects;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.access.SharedSecrets;\n+\n+\/**\n+ * This class provides management of {@link Map maps} where it is desirable to\n+ * remove entries automatically when the key is garbage collected. This is\n+ * accomplished by using a backing map where the keys are either a\n+ * {@link WeakReference} or a {@link SoftReference}.\n+ * <p>\n+ * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}\n+ * of the backing map and whether {@link WeakReference} or\n+ * {@link SoftReference} is to be used.\n+ *\n+ * {@snippet :\n+ * \/\/ Use HashMap and WeakReference\n+ * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);\n+ * map.put(10_000_000L, \"a\");\n+ * map.put(10_000_001L, \"b\");\n+ * map.put(10_000_002L, \"c\");\n+ * map.put(10_000_003L, \"d\");\n+ * map.put(10_000_004L, \"e\");\n+ *\n+ * \/\/ Use ConcurrentHashMap and SoftReference\n+ * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+ * map.put(20_000_000L, \"v\");\n+ * map.put(20_000_001L, \"w\");\n+ * map.put(20_000_002L, \"x\");\n+ * map.put(20_000_003L, \"y\");\n+ * map.put(20_000_004L, \"z\");\n+ * }\n+ *\n+ * @implNote Care must be given that the backing map does replacement by\n+ * replacing the value in the map entry instead of deleting the old entry and\n+ * adding a new entry, otherwise replaced entries may end up with a strongly\n+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\n+ * to be safe.\n+ *\n+ * @param <K> the type of keys maintained by this map\n+ * @param <V> the type of mapped values\n+ *\n+ * @since 21\n+ *\/\n+public final class ReferencedKeyMap<K, V> implements Map<K, V> {\n+    \/**\n+     * true if {@link SoftReference} keys are to be used,\n+     * {@link WeakReference} otherwise.\n+     *\/\n+    private final boolean isSoft;\n+\n+    \/**\n+     * Backing {@link Map}.\n+     *\/\n+    private final Map<ReferenceKey<K>, V> map;\n+\n+    \/**\n+     * {@link ReferenceQueue} for cleaning up {@link WeakReferenceKey EntryKeys}.\n+     *\/\n+    private final ReferenceQueue<K> stale;\n+\n+    \/**\n+     * Private constructor.\n+     *\n+     * @param isSoft  true if {@link SoftReference} keys are to\n+     *                be used, {@link WeakReference} otherwise.\n+     * @param map     backing map\n+     *\/\n+    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\n+        this.isSoft = isSoft;\n+        this.map = map;\n+        this.stale = SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue();\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeyMap} map.\n+     *\n+     * @param isSoft    true if {@link SoftReference} keys are to\n+     *                  be used, {@link WeakReference} otherwise.\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new map with {@link Reference} keys\n+     *\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    public static <K, V> ReferencedKeyMap<K, V>\n+    create(boolean isSoft, Supplier<Map<ReferenceKey<K>, V>> supplier) {\n+        return new ReferencedKeyMap<K, V>(isSoft, supplier.get());\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeyMap} map using\n+     * {@link WeakReference} keys.\n+     *\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new map with {@link Reference} keys\n+     *\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    public static <K, V> ReferencedKeyMap<K, V>\n+    create(Supplier<Map<ReferenceKey<K>, V>> supplier) {\n+        return new ReferencedKeyMap<K, V>(false, supplier.get());\n+    }\n+\n+    \/**\n+     * {@return a key suitable for a map entry}\n+     *\n+     * @param key unwrapped key\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private ReferenceKey<K> entryKey(Object key) {\n+        if (isSoft) {\n+            return new SoftReferenceKey<>((K)key, stale);\n+        } else {\n+            return new WeakReferenceKey<>((K)key, stale);\n+        }\n+    }\n+\n+    \/**\n+     * {@return a key suitable for lookup}\n+     *\n+     * @param key unwrapped key\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private ReferenceKey<K> lookupKey(Object key) {\n+        return new StrongReferenceKey<>((K)key);\n+    }\n+\n+    @Override\n+    public int size() {\n+        removeStaleReferences();\n+        return map.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        removeStaleReferences();\n+        return map.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        removeStaleReferences();\n+        return map.containsKey(lookupKey(key));\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        Objects.requireNonNull(value, \"value must not be null\");\n+        removeStaleReferences();\n+        return map.containsValue(value);\n+    }\n+\n+    @Override\n+    public V get(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        removeStaleReferences();\n+        return map.get(lookupKey(key));\n+    }\n+\n+    @Override\n+    public V put(K key, V newValue) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        Objects.requireNonNull(newValue, \"value must not be null\");\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = entryKey(key);\n+        \/\/ If {@code put} returns non-null then was actually a {@code replace}\n+        \/\/ and older key was used. In that case the new key was not used and the\n+        \/\/ reference marked stale.\n+        V oldValue = map.put(entryKey, newValue);\n+        if (oldValue != null) {\n+            entryKey.unused();\n+        }\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        \/\/ Rely on gc to clean up old key.\n+        return map.remove(lookupKey(key));\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        removeStaleReferences();\n+        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\n+            K key = entry.getKey();\n+            V value = entry.getValue();\n+            put(key, value);\n+        }\n+    }\n+\n+    @Override\n+    public void clear() {\n+        removeStaleReferences();\n+        \/\/ Rely on gc to clean up old keys.\n+        map.clear();\n+    }\n+\n+    \/**\n+     * Common routine for collecting the current set of keys.\n+     *\n+     * @return {@link Stream} of valid keys (unwrapped)\n+     *\/\n+    private Stream<K> filterKeySet() {\n+        return map.keySet()\n+                .stream()\n+                .map(ReferenceKey::get)\n+                .filter(Objects::nonNull);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        removeStaleReferences();\n+        return filterKeySet().collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        removeStaleReferences();\n+        return map.values();\n+    }\n+\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+        removeStaleReferences();\n+        return filterKeySet()\n+                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public V putIfAbsent(K key, V newValue) {\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = entryKey(key);\n+        \/\/ If {@code putIfAbsent} returns non-null then was actually a\n+        \/\/ {@code replace}  and older key was used. In that case the new key was\n+        \/\/ not used and the reference marked stale.\n+        V oldValue = map.putIfAbsent(entryKey, newValue);\n+        if (oldValue != null) {\n+            entryKey.unused();\n+        }\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public boolean remove(Object key, Object value) {\n+        \/\/ Rely on gc to clean up old key.\n+        return map.remove(lookupKey(key), value);\n+    }\n+\n+    @Override\n+    public boolean replace(K key, V oldValue, V newValue) {\n+        removeStaleReferences();\n+        \/\/ If replace is successful then the older key will be used and the\n+        \/\/ lookup key will suffice.\n+        return map.replace(lookupKey(key), oldValue, newValue);\n+    }\n+\n+    @Override\n+    public V replace(K key, V value) {\n+        removeStaleReferences();\n+        \/\/ If replace is successful then the older key will be used and the\n+        \/\/ lookup key will suffice.\n+        return map.replace(lookupKey(key), value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        removeStaleReferences();\n+        return filterKeySet()\n+                .map(k -> k + \"=\" + get(k))\n+                .collect(Collectors.joining(\", \", \"{\", \"}\"));\n+    }\n+\n+    \/**\n+     * Removes enqueued weak references from map.\n+     *\/\n+    public void removeStaleReferences() {\n+        while (true) {\n+            Object key = stale.poll();\n+            if (key == null) {\n+                break;\n+            }\n+            map.remove(key);\n+        }\n+    }\n+\n+    \/**\n+     * Puts an entry where the key and the value are the same. Used for\n+     * interning values.\n+     *\n+     * @implNote Requires a {@link ReferencedKeyMap} whose {@code V} type\n+     * is {@code ReferenceKey<K>}. Otherwise, a {@link ClassCastException} will\n+     * be thrown.\n+     *\n+     * @param key  key to add\n+     *\n+     * @return the old key instance unless null then the new key instance\n+     *\n+     * @throws ClassCastException if {@code V} is not {@code EntryKey<K>}\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    K intern(K key) {\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = (ReferenceKey<K>)get(lookupKey(key));\n+        if (entryKey != null) {\n+            K value = entryKey.get();\n+            if (value != null) {\n+                return value;\n+            }\n+        }\n+        entryKey = entryKey(key);\n+        K interned;\n+        do {\n+            removeStaleReferences();\n+            ReferenceKey<K> existing =\n+                    (ReferenceKey<K>)map.putIfAbsent(entryKey, (V)entryKey);\n+            if (existing == null) {\n+                return key;\n+            } else {\n+                \/\/ If {@code putIfAbsent} returns non-null then was actually a\n+                \/\/ {@code replace} and older key was used. In that case the new\n+                \/\/ key was not used and the reference marked stale.\n+                interned = existing.get();\n+                if (interned != null) {\n+                    entryKey.unused();\n+                }\n+            }\n+        } while (interned == null);\n+        return interned;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":377,"deletions":0,"binary":false,"changes":377,"status":"added"},{"patch":"@@ -0,0 +1,184 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+\n+\/**\n+ * This class provides management of {@link Set set} where it is desirable to\n+ * remove elements automatically when the element is garbage collected. This is\n+ * accomplished by using a backing map where the keys and values are either a\n+ * {@link WeakReference} or a {@link SoftReference}.\n+ * <p>\n+ * To create a {@link ReferencedKeySet} the user must provide a {@link Supplier}\n+ * of the backing map and whether {@link WeakReference} or\n+ * {@link SoftReference} is to be used.\n+ * {@snippet :\n+ * Set<Long> set;\n+ *\n+ * set = ReferencedKeySet.create(false, HashMap::new);\n+ * set.add(30_000_000L);\n+ * set.add(30_000_001L);\n+ * set.add(30_000_002L);\n+ * set.add(30_000_003L);\n+ * set.add(30_000_004L);\n+ *\n+ * set = ReferencedKeySet.create(true, ConcurrentHashMap::new);\n+ * set.add(40_000_000L);\n+ * set.add(40_000_001L);\n+ * set.add(40_000_002L);\n+ * set.add(40_000_003L);\n+ * set.add(40_000_004L);\n+ * }\n+ *\n+ * @implNote Care must be given that the backing map does replacement by\n+ * replacing the value in the map entry instead of deleting the old entry and\n+ * adding a new entry, otherwise replaced entries may end up with a strongly\n+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\n+ * to be safe.\n+ *\n+ * @param <T> the type of elements maintained by this set\n+ *\/\n+public class ReferencedKeySet<T> extends AbstractSet<T> {\n+    \/**\n+     * Backing {@link ReferencedKeySet} map.\n+     *\/\n+    final ReferencedKeyMap<T, ReferenceKey<T>> map;\n+\n+    \/**\n+     * Private constructor.\n+     *\n+     * @param map     backing map\n+     *\/\n+    private ReferencedKeySet(ReferencedKeyMap<T, ReferenceKey<T>> map) {\n+        this.map = map;\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeySet} elements.\n+     *\n+     * @param isSoft    true if {@link SoftReference} elements are to\n+     *                  be used, {@link WeakReference} otherwise.\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new set with {@link Reference} elements\n+     *\n+     * @param <E> the type of elements maintained by this set\n+     *\/\n+    public static <E> ReferencedKeySet<E>\n+    create(boolean isSoft, Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {\n+         return new ReferencedKeySet<>(ReferencedKeyMap.create(isSoft, supplier));\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeySet} set using\n+     * {@link WeakReference} elements.\n+     *\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new set with {@link Reference} elements\n+     *\n+     * @param <E> the type of elements maintained by this set\n+     *\/\n+    public static <E> ReferencedKeySet<E>\n+    create(Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {\n+        return new ReferencedKeySet<>(ReferencedKeyMap.create(false, supplier));\n+    }\n+\n+    \/**\n+     * Removes enqueued weak references from set.\n+     *\/\n+    public void removeStaleReferences() {\n+        map.removeStaleReferences();\n+    }\n+\n+    @Override\n+    public Iterator<T> iterator() {\n+        return map.keySet().iterator();\n+    }\n+\n+    @Override\n+    public int size() {\n+        return map.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return map.isEmpty();\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public boolean contains(Object o) {\n+        return map.containsKey((T)o);\n+    }\n+\n+    @Override\n+    public boolean add(T e) {\n+        return map.intern(e) == null;\n+    }\n+\n+    @Override\n+    public boolean remove(Object o) {\n+        return map.remove(o) != null;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        map.clear();\n+    }\n+\n+    \/**\n+     * Gets an existing element from the set, returning null if not present or\n+     * the old element if previously added.\n+     *\n+     * @param e  element to get\n+     *\n+     * @return the old element if present, otherwise, null\n+     *\/\n+    public T get(T e) {\n+        ReferenceKey<T> key = map.get(e);\n+\n+        return key == null ? null : key.get();\n+    }\n+\n+    \/**\n+     * Intern an element to the set, returning the element if newly added or the\n+     * old element if previously added.\n+     *\n+     * @param e  element to add\n+     *\n+     * @return the old element if present, otherwise, the new element\n+     *\/\n+    public T intern(T e) {\n+        return map.intern(e);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":184,"deletions":0,"binary":false,"changes":184,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.runtime;\n+package jdk.internal.util;\n@@ -38,3 +38,0 @@\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SoftReferenceKey.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SoftReferenceKey.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.runtime;\n+package jdk.internal.util;\n@@ -37,3 +37,0 @@\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/StrongReferenceKey.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StrongReferenceKey.java","status":"renamed"},{"patch":"@@ -26,1 +26,1 @@\n-package java.lang.runtime;\n+package jdk.internal.util;\n@@ -38,3 +38,0 @@\n- *\n- * Warning: This class is part of PreviewFeature.Feature.STRING_TEMPLATES.\n- *          Do not rely on its availability.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/WeakReferenceKey.java","additions":1,"deletions":4,"binary":false,"changes":5,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/WeakReferenceKey.java","status":"renamed"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test features provided by the ReferencedKeyMap class.\n- * @modules java.base\/java.lang.runtime\n- * @enablePreview\n- * @compile --patch-module java.base=${test.src} ReferencedKeyTest.java\n- * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.runtime.ReferencedKeyTest\n- *\/\n-\n-package java.lang.runtime;\n-\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.concurrent.ConcurrentHashMap;\n-import java.util.function.Supplier;\n-\n-public class ReferencedKeyTest {\n-    static long BASE_KEY = 10_000_000L;\n-\n-    public static void main(String[] args) throws Throwable {\n-        mapTest(false, HashMap::new);\n-        mapTest(true, HashMap::new);\n-        mapTest(false, ConcurrentHashMap::new);\n-        mapTest(true, ConcurrentHashMap::new);\n-    }\n-\n-    static void assertTrue(boolean test, String message) {\n-        if (!test) {\n-            throw new RuntimeException(message);\n-        }\n-    }\n-\n-    static void  mapTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, String>> supplier) {\n-        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n-        populate(map);\n-        collect();\n-        \/\/ assertTrue(map.isEmpty() || isSoft, \"Weak not collecting\");\n-        populate(map);\n-        methods(map);\n-    }\n-\n-    static void methods(Map<Long, String> map) {\n-        assertTrue(map.size() == 26, \"missing key\");\n-        assertTrue(map.containsKey(BASE_KEY + 'a' -'a'), \"missing key\");\n-        assertTrue(map.get(BASE_KEY + 'b' -'a').equals(\"b\"), \"wrong key\");\n-        assertTrue(map.containsValue(\"c\"), \"missing value\");\n-        map.remove(BASE_KEY + 'd' -'a');\n-        assertTrue(map.get(BASE_KEY + 'd' -'a') == null, \"not removed\");\n-        map.putAll(Map.of(1L, \"A\", 2L, \"B\"));\n-        assertTrue(map.get(2L).equals(\"B\"), \"collection not added\");\n-        assertTrue(map.keySet().contains(1L), \"key missing\");\n-        assertTrue(map.values().contains(\"A\"), \"key missing\");\n-        assertTrue(map.entrySet().contains(Map.entry(1L, \"A\")), \"key missing\");\n-        map.putIfAbsent(3L, \"C\");\n-        assertTrue(map.get(3L).equals(\"C\"), \"key missing\");\n-        map.putIfAbsent(2L, \"D\");\n-        assertTrue(map.get(2L).equals(\"B\"), \"key replaced\");\n-        map.remove(3L);\n-        assertTrue(map.get(3L) == null, \"key not removed\");\n-        map.replace(2L, \"D\");\n-        assertTrue(map.get(2L).equals(\"D\"), \"key not replaced\");\n-        map.replace(2L, \"B\", \"E\");\n-        assertTrue(map.get(2L).equals(\"D\"), \"key replaced\");\n-    }\n-\n-    static void collect() {\n-        System.gc();\n-        sleep();\n-    }\n-\n-    static void sleep() {\n-        try {\n-            Thread.sleep(100L);\n-        } catch (InterruptedException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-\n-    static void populate(Map<Long, String> map) {\n-        for (int i = 0; i < 26; i++) {\n-            Long key = BASE_KEY + i;\n-            String value = String.valueOf((char) ('a' + i));\n-            map.put(key, value);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/runtime\/ReferencedKeyTest.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8285932 8310913\n+ * @summary Test features provided by the ReferencedKeyMap\/ReferencedKeySet classes.\n+ * @modules java.base\/jdk.internal.util\n+ * @compile --patch-module java.base=${test.src} ReferencedKeyTest.java\n+ * @run main\/othervm --patch-module java.base=${test.class.path} jdk.internal.util.ReferencedKeyTest\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+\n+public class ReferencedKeyTest {\n+    static long BASE_KEY = 10_000_000L;\n+\n+    public static void main(String[] args) {\n+        mapTest(false, HashMap::new);\n+        mapTest(true, HashMap::new);\n+        mapTest(false, ConcurrentHashMap::new);\n+        mapTest(true, ConcurrentHashMap::new);\n+\n+        setTest(false, HashMap::new);\n+        setTest(true, HashMap::new);\n+        setTest(false, ConcurrentHashMap::new);\n+        setTest(true, ConcurrentHashMap::new);\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static void mapTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, String>> supplier) {\n+        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n+        populate(map);\n+        collect();\n+        \/\/ assertTrue(map.isEmpty() || isSoft, \"Weak not collecting\");\n+        populate(map);\n+        methods(map);\n+    }\n+\n+    static void setTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, ReferenceKey<Long>>> supplier) {\n+        ReferencedKeySet<Long> set = ReferencedKeySet.create(isSoft, supplier);\n+        populate(set);\n+        collect();\n+        \/\/ assertTrue(set.isEmpty() || isSoft, \"Weak not collecting\");\n+        populate(set);\n+        methods(set);\n+    }\n+\n+    static void methods(Map<Long, String> map) {\n+        assertTrue(map.size() == 26, \"missing key\");\n+        assertTrue(map.containsKey(BASE_KEY + 'a' -'a'), \"missing key\");\n+        assertTrue(map.get(BASE_KEY + 'b' -'a').equals(\"b\"), \"wrong key\");\n+        assertTrue(map.containsValue(\"c\"), \"missing value\");\n+        map.remove(BASE_KEY + 'd' -'a');\n+        assertTrue(map.get(BASE_KEY + 'd' -'a') == null, \"not removed\");\n+        map.putAll(Map.of(1L, \"A\", 2L, \"B\"));\n+        assertTrue(map.get(2L).equals(\"B\"), \"collection not added\");\n+        assertTrue(map.containsKey(1L), \"key missing\");\n+        assertTrue(map.containsValue(\"A\"), \"key missing\");\n+        assertTrue(map.entrySet().contains(Map.entry(1L, \"A\")), \"key missing\");\n+        map.putIfAbsent(3L, \"C\");\n+        assertTrue(map.get(3L).equals(\"C\"), \"key missing\");\n+        map.putIfAbsent(2L, \"D\");\n+        assertTrue(map.get(2L).equals(\"B\"), \"key replaced\");\n+        map.remove(3L);\n+        assertTrue(map.get(3L) == null, \"key not removed\");\n+        map.replace(2L, \"D\");\n+        assertTrue(map.get(2L).equals(\"D\"), \"key not replaced\");\n+        map.replace(2L, \"B\", \"E\");\n+        assertTrue(map.get(2L).equals(\"D\"), \"key replaced\");\n+    }\n+\n+    static void methods(ReferencedKeySet<Long> set) {\n+        assertTrue(set.size() == 26, \"missing key\");\n+        assertTrue(set.contains(BASE_KEY + 3), \"missing key\");\n+        set.remove(BASE_KEY + 3);\n+        assertTrue(!set.contains(BASE_KEY + 3), \"not removed\");\n+        Long element1 = set.get(BASE_KEY + 2);\n+        Long element2 = set.get(BASE_KEY + 3);\n+        Long intern1 = set.intern(BASE_KEY + 2);\n+        Long intern2 = set.intern(BASE_KEY + 3);\n+        assertTrue(element1 != null, \"missing key\");\n+        assertTrue(element2 == null, \"not removed\");\n+        assertTrue(element1 == intern1, \"intern failed\"); \/\/ must be same object\n+        assertTrue(intern2 != null, \"intern failed\");\n+    }\n+\n+    static void collect() {\n+        System.gc();\n+        sleep();\n+    }\n+\n+    static void sleep() {\n+        try {\n+            Thread.sleep(100L);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void populate(Map<Long, String> map) {\n+        for (int i = 0; i < 26; i++) {\n+            Long key = BASE_KEY + i;\n+            String value = String.valueOf((char) ('a' + i));\n+            map.put(key, value);\n+        }\n+    }\n+\n+    static void populate(Set<Long> set) {\n+        for (int i = 0; i < 26; i++) {\n+            Long value = BASE_KEY + i;\n+            set.add(value);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/ReferencedKeyTest.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"}]}