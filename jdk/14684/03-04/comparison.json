{"files":[{"patch":"@@ -234,1 +234,1 @@\n-        ReferencedKeySet.create(false, new Supplier<>() {\n+        ReferencedKeySet.create(false, true, new Supplier<>() {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -370,1 +370,1 @@\n-                methodTypeCache = ReferencedKeyMap.create(false, ConcurrentHashMap::new);\n+                methodTypeCache = ReferencedKeyMap.create(false, false, ConcurrentHashMap::new);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carriers.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-     * Invoked by MethodType.ConcurrentWeakInternSet\n+     * Invoked by jdk.internal.util.ReferencedKeyMap\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangRefAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-     * {@link ReferenceQueue} for cleaning up {@link WeakReferenceKey EntryKeys}.\n+     * {@link ReferenceQueue} for cleaning up entries.\n@@ -104,3 +104,6 @@\n-     * @param isSoft  true if {@link SoftReference} keys are to\n-     *                be used, {@link WeakReference} otherwise.\n-     * @param map     backing map\n+     * @param isSoft          true if {@link SoftReference} keys are to\n+     *                        be used, {@link WeakReference} otherwise.\n+     * @param useNativeQueue  true if uses NativeReferenceQueue\n+     *                        otherwise use {@link ReferenceQueue}.\n+     * @param map             backing map\n+     * @param stale           {@link ReferenceQueue} for cleaning up entries\n@@ -108,1 +111,1 @@\n-    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\n+    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map, ReferenceQueue<K> stale) {\n@@ -111,1 +114,1 @@\n-        this.stale = SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue();\n+        this.stale = stale;\n@@ -117,3 +120,5 @@\n-     * @param isSoft    true if {@link SoftReference} keys are to\n-     *                  be used, {@link WeakReference} otherwise.\n-     * @param supplier  {@link Supplier} of the backing map\n+     * @param isSoft          true if {@link SoftReference} keys are to\n+     *                        be used, {@link WeakReference} otherwise.\n+     * @param useNativeQueue  true if uses NativeReferenceQueue\n+     *                        otherwise use {@link ReferenceQueue}.\n+     * @param supplier        {@link Supplier} of the backing map\n@@ -127,18 +132,5 @@\n-    create(boolean isSoft, Supplier<Map<ReferenceKey<K>, V>> supplier) {\n-        return new ReferencedKeyMap<K, V>(isSoft, supplier.get());\n-    }\n-\n-    \/**\n-     * Create a new {@link ReferencedKeyMap} map using\n-     * {@link WeakReference} keys.\n-     *\n-     * @param supplier  {@link Supplier} of the backing map\n-     *\n-     * @return a new map with {@link Reference} keys\n-     *\n-     * @param <K> the type of keys maintained by the new map\n-     * @param <V> the type of mapped values\n-     *\/\n-    public static <K, V> ReferencedKeyMap<K, V>\n-    create(Supplier<Map<ReferenceKey<K>, V>> supplier) {\n-        return new ReferencedKeyMap<K, V>(false, supplier.get());\n+    create(boolean isSoft, boolean useNativeQueue, Supplier<Map<ReferenceKey<K>, V>> supplier) {\n+        return new ReferencedKeyMap<K, V>(isSoft, supplier.get(),\n+                useNativeQueue ? SharedSecrets.getJavaLangRefAccess().newNativeReferenceQueue()\n+                               : new ReferenceQueue<>()\n+                );\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":19,"deletions":27,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.ReferenceQueue;\n@@ -88,3 +89,5 @@\n-     * @param isSoft    true if {@link SoftReference} elements are to\n-     *                  be used, {@link WeakReference} otherwise.\n-     * @param supplier  {@link Supplier} of the backing map\n+     * @param isSoft          true if {@link SoftReference} elements are to\n+     *                        be used, {@link WeakReference} otherwise.\n+     * @param useNativeQueue  true if uses NativeReferenceQueue\n+     *                        otherwise use {@link ReferenceQueue}.\n+     * @param supplier        {@link Supplier} of the backing map\n@@ -97,17 +100,2 @@\n-    create(boolean isSoft, Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {\n-         return new ReferencedKeySet<>(ReferencedKeyMap.create(isSoft, supplier));\n-    }\n-\n-    \/**\n-     * Create a new {@link ReferencedKeySet} set using\n-     * {@link WeakReference} elements.\n-     *\n-     * @param supplier  {@link Supplier} of the backing map\n-     *\n-     * @return a new set with {@link Reference} elements\n-     *\n-     * @param <E> the type of elements maintained by this set\n-     *\/\n-    public static <E> ReferencedKeySet<E>\n-    create(Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {\n-        return new ReferencedKeySet<>(ReferencedKeyMap.create(false, supplier));\n+    create(boolean isSoft, boolean useNativeQueue, Supplier<Map<ReferenceKey<E>, ReferenceKey<E>>> supplier) {\n+         return new ReferencedKeySet<>(ReferencedKeyMap.create(isSoft, useNativeQueue, supplier));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeySet.java","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+        \/\/ Note: refersTo is insufficient since keys require equivalence.\n+        \/\/ refersTo would also require a cast to type T.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/SoftReferenceKey.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,0 +76,2 @@\n+        \/\/ Note: refersTo is insufficient since keys require equivalence.\n+        \/\/ refersTo would also require a cast to type T.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/WeakReferenceKey.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n+        Map<Long, String> map = ReferencedKeyMap.create(isSoft, false, supplier);\n@@ -72,1 +72,1 @@\n-        ReferencedKeySet<Long> set = ReferencedKeySet.create(isSoft, supplier);\n+        ReferencedKeySet<Long> set = ReferencedKeySet.create(isSoft, false, supplier);\n","filename":"test\/jdk\/jdk\/internal\/util\/ReferencedKeyTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}