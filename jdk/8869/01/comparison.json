{"files":[{"patch":"@@ -39,0 +39,2 @@\n+constexpr idx_t BitMap::NotFound;\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,0 +103,7 @@\n+  \/\/ Helper for get_prev_{zero,one}_bit variants.\n+  \/\/ - flip designates whether searching for 1s or 0s.  Must be one of\n+  \/\/   find_{zeros,ones}_flip.\n+  \/\/ - aligned_left is true if l_index is a priori on a bm_word_t boundary.\n+  template<bm_word_t flip, bool aligned_left>\n+  inline idx_t get_prev_bit_impl(idx_t l_index, idx_t r_index) const;\n+\n@@ -318,0 +325,9 @@\n+  static constexpr idx_t NotFound = ~(idx_t)0;\n+  \/\/ Find the index of the first bit set scanning from r_index (inclusive) to\n+  \/\/ l_index (inclusive) backwards.\n+  \/\/ Returns that index or NotFound if there is no such bit in the range.\n+  idx_t get_prev_one_offset(idx_t l_index, idx_t r_index) const;\n+  \/\/ Same as get_prev_one_offset, except requires that \"l_index\" is aligned to\n+  \/\/ bitsizeof(bm_word_t).\n+  idx_t get_prev_one_offset_aligned_left(idx_t l_index, idx_t r_index) const;\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -231,0 +231,60 @@\n+template<BitMap::bm_word_t flip, bool aligned_left>\n+inline BitMap::idx_t BitMap::get_prev_bit_impl(idx_t l_index, idx_t r_index) const {\n+  STATIC_ASSERT(flip == find_ones_flip || flip == find_zeros_flip);\n+  verify_range(l_index, r_index);\n+  assert(!aligned_left || is_aligned(l_index, BitsPerWord), \"l_index not aligned\");\n+  assert(sizeof(intptr_t) == sizeof(bm_word_t), \"must be for the high bit check\");\n+\n+  \/\/ The first word often contains an interesting bit, either due to\n+  \/\/ density or because of features of the calling algorithm.  So it's\n+  \/\/ important to examine that first word with a minimum of fuss,\n+  \/\/ minimizing setup time for later words that will be wasted if the\n+  \/\/ first word is indeed interesting.\n+\n+  \/\/ The benefit from aligned_left being true is very small. It saves\n+  \/\/ an operation when returning results.\n+\n+  \/\/ The return value of l_index when no bit is found is BitMap::NotFound.\n+\n+  if (l_index <= r_index) {\n+    \/\/ Get the word containing r_index, and shift out high bits.\n+    idx_t index = to_words_align_down(r_index);\n+    bm_word_t cword = (map(index) ^ flip) << (BitsPerWord - 1 - bit_in_word(r_index));\n+    if (intptr_t(cword) < 0) {\n+      \/\/ The first bit is similarly often interesting. When it matters\n+      \/\/ (density or features of the calling algorithm make it likely\n+      \/\/ the first bit is set), going straight to the next clause compares\n+      \/\/ poorly with doing this check first; count_leading_zeros can be\n+      \/\/ relatively expensive, plus there is the additional range check.\n+      \/\/ But when the first bit isn't set, the cost of having tested for\n+      \/\/ it is relatively small compared to the rest of the search.\n+      return r_index;\n+    } else if (cword != 0) {\n+      \/\/ Flipped and shifted first word is non-zero.\n+      idx_t result = r_index - count_leading_zeros(cword);\n+      if (aligned_left || (result >= l_index)) {\n+        return result;\n+      }\n+      \/\/ Result is beyond range bound.\n+    } else {\n+      \/\/ Flipped and shifted first word is zero.  Word search through\n+      \/\/ aligned down l_index for a non-zero flipped word.\n+      idx_t limit = to_words_align_down(l_index); \/\/ Minuscule savings when aligned.\n+      while (index > 0 && --index >= limit) {\n+        cword = map(index) ^ flip;\n+        if (cword != 0) {\n+          idx_t result = bit_index(index + 1) - count_leading_zeros(cword) - 1;\n+          if (aligned_left || (result >= l_index)) {\n+            return result;\n+          }\n+          \/\/ Result is beyond range bound; return NotFound\n+          assert(index == limit, \"invariant\");\n+          break;\n+        }\n+      }\n+      \/\/ No bits in range.\n+    }\n+  }\n+  return NotFound;\n+}\n+\n@@ -246,0 +306,10 @@\n+inline BitMap::idx_t\n+BitMap::get_prev_one_offset (idx_t l_index, idx_t r_index) const {\n+  return get_prev_bit_impl<find_ones_flip, false>(l_index, r_index);\n+}\n+\n+inline BitMap::idx_t\n+BitMap::get_prev_one_offset_aligned_left(idx_t l_index, idx_t r_index) const {\n+  return get_prev_bit_impl<find_ones_flip, true>(l_index, r_index);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/bitMap.inline.hpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -94,4 +94,144 @@\n-static idx_t compute_expected(idx_t search_start,\n-                              idx_t search_end,\n-                              idx_t left_bit,\n-                              idx_t right_bit) {\n+static idx_t compute_search_bwd_expected(idx_t search_left,\n+                                         idx_t search_right,\n+                                         idx_t left_bit,\n+                                         idx_t right_bit) {\n+  if (search_right >= right_bit) {\n+    if (search_left <= right_bit) {\n+      return right_bit;\n+    } else {\n+      return BitMap::NotFound;\n+    }\n+  } else if (search_right >= left_bit) {\n+    if (search_left <= left_bit) {\n+      return left_bit;\n+    } else {\n+      return BitMap::NotFound;\n+    }\n+  } else {\n+    return BitMap::NotFound;\n+  }\n+}\n+\n+static void test_search_bwd_testcase(BitMap& test_ones,\n+                                     idx_t search_left,\n+                                     idx_t search_right,\n+                                     idx_t left,\n+                                     idx_t right,\n+                                     bool aligned_left) {\n+  idx_t result;\n+  idx_t exp_result = compute_search_bwd_expected(search_left, search_right, left, right);\n+\n+  result = test_ones.get_prev_one_offset(search_left, search_right);\n+  EXPECT_EQ(result, exp_result) << \" search_left \" << search_left << \" search_right \" << search_right << \" left \" << left << \" right \" << right << \" result \" << result;\n+\n+  if (aligned_left) {\n+    result = test_ones.get_prev_one_offset_aligned_left(search_left, search_right);\n+    EXPECT_EQ(result, exp_result) << \" search_left \" << search_left << \" search_right \" << search_right << \" left \" << left << \" right \" << right << \" result \" << result;\n+  }\n+}\n+\n+static void test_search_bwd_ranges(BitMap& test_ones, idx_t left, idx_t right) {\n+  \/\/ Some trivial cases.\n+  test_search_bwd_testcase(test_ones, left, right, left, right, false);\n+  test_search_bwd_testcase(test_ones, right, right, left, right, false);\n+  test_search_bwd_testcase(test_ones, left, left, left, right, false);\n+\n+    \/\/ Test searches with various start and end ranges.\n+  for (size_t c_start = 0; c_start < search_nchunks; ++c_start) {\n+    for (size_t o_start = 0; o_start < search_noffsets; ++o_start) {\n+      idx_t start = c_start * search_chunk_size + search_offsets[o_start];\n+      \/\/ Terminate start iteration if start is more than two full\n+      \/\/ chunks beyond left.  There isn't anything new to learn by\n+      \/\/ continuing the iteration, and this noticably reduces the\n+      \/\/ time to run the test.\n+      if (left + 2 * search_chunk_size < start) {\n+        c_start = search_nchunks; \/\/ Set to limit to terminate iteration.\n+        break;\n+      }\n+\n+      for (size_t c_end = c_start; c_end < search_nchunks; ++c_end) {\n+        for (size_t o_end = (c_start == c_end) ? o_start : 0;\n+             o_end < search_noffsets;\n+             ++o_end) {\n+          idx_t end = c_end * search_chunk_size + search_offsets[o_end];\n+          \/\/ Similarly to start and left, terminate end iteration if\n+          \/\/ end is more than two full chunks beyond right.\n+          if (right + 2 * search_chunk_size < end) {\n+            c_end = search_nchunks; \/\/ Set to limit to terminate iteration.\n+            break;\n+          }\n+          \/\/ Skip this chunk if right is much larger than max(left, start)\n+          \/\/ and this chunk is one of many similar chunks in between,\n+          \/\/ again to reduce testing time.\n+          if (MAX2(start, left) + 2 * search_chunk_size < end) {\n+            if (end + 2 * search_chunk_size < right) {\n+              break;\n+            }\n+          }\n+\n+          ASSERT_LE(start, end);       \/\/ test bug if fail\n+          ASSERT_LT(end, BITMAP_SIZE); \/\/ test bug if fail\n+          bool aligned_left = search_offsets[o_start] == 0;\n+\n+          test_search_bwd_testcase(test_ones, start, end, left, right, aligned_left);\n+          if (start < end) {\n+            test_search_bwd_testcase(test_ones, start, MAX2(start, end - 1), left, right, aligned_left);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+TEST(BitMap, search_bwd) {\n+  CHeapBitMap test_ones(BITMAP_SIZE);\n+\n+  test_ones.clear_range(0, test_ones.size());\n+\n+  idx_t result = test_ones.get_prev_one_offset(0, test_ones.size());\n+  EXPECT_EQ(result, BitMap::NotFound);\n+\n+  for (size_t c_left = 0; c_left < 2; ++c_left) {\n+    for (size_t c_right = c_left;\n+         c_right < search_nchunks;\n+         (c_right == c_left + 1) ? c_right = search_nchunks -1 : ++c_right) {\n+\n+            \/\/ For each offset within the left chunk...\n+      for (size_t o_left = 0; o_left < search_noffsets; ++o_left) {\n+        \/\/ left is start of left chunk + offset.\n+        idx_t left = c_left * search_chunk_size + search_offsets[o_left];\n+\n+        test_ones.set_bit(left);\n+        EXPECT_TRUE(test_ones.at(left));\n+\n+        \/\/ For each offset within the right chunk and > left...\n+        for (size_t o_right = (c_left == c_right) ? o_left + 1 : 0;\n+             o_right < search_noffsets;\n+             ++o_right) {\n+          \/\/ right is start of right chunk + offset.\n+          idx_t right = c_right * search_chunk_size + search_offsets[o_right];\n+\n+          \/\/ Install the right bit.\n+          test_ones.set_bit(right);\n+          EXPECT_TRUE(test_ones.at(right));\n+\n+          \/\/ Apply the test.\n+          test_search_bwd_ranges(test_ones, left, right);\n+\n+          \/\/ Remove the right bit.\n+          test_ones.clear_bit(right);\n+          EXPECT_FALSE(test_ones.at(right));\n+        }\n+\n+        \/\/ Remove the left bit.\n+        test_ones.clear_bit(left);\n+        EXPECT_FALSE(test_ones.at(left));\n+      }\n+    }\n+  }\n+}\n+\n+static idx_t compute_search_fwd_expected(idx_t search_start,\n+                                         idx_t search_end,\n+                                         idx_t left_bit,\n+                                         idx_t right_bit) {\n@@ -111,4 +251,4 @@\n-static void test_search_ranges(BitMap& test_ones,\n-                               BitMap& test_zeros,\n-                               idx_t left,\n-                               idx_t right) {\n+static void test_search_fwd_ranges(BitMap& test_ones,\n+                                   BitMap& test_zeros,\n+                                   idx_t left,\n+                                   idx_t right) {\n@@ -171,1 +311,1 @@\n-          idx_t expected = compute_expected(start, end, left, right);\n+          idx_t expected = compute_search_fwd_expected(start, end, left, right);\n@@ -182,1 +322,1 @@\n-          idx_t expected2 = compute_expected(start2, end, left, right);\n+          idx_t expected2 = compute_search_fwd_expected(start2, end, left, right);\n@@ -197,1 +337,1 @@\n-TEST(BitMap, search) {\n+TEST(BitMap, search_fwd) {\n@@ -241,1 +381,1 @@\n-          test_search_ranges(test_ones, test_zeros, left, right);\n+          test_search_fwd_ranges(test_ones, test_zeros, left, right);\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_search.cpp","additions":152,"deletions":12,"binary":false,"changes":164,"status":"modified"}]}