{"files":[{"patch":"@@ -141,0 +141,38 @@\n+\/\/ Atomic updates of oops. This is only expected to work with updating the same\n+\/\/ logical object with its forwardee, or updating the location to NULL.\n+\/\/ The reason why we need a stronger memory ordering has to do with coordination\n+\/\/ with LRB copying the object.\n+\/\/\n+\/\/ Suppose \"o\" is the object that has a field \"x\" and the reference to \"o\" is stored\n+\/\/ to field at \"addr\", which happens to be Java volatile field. Then consider this example.\n+\/\/\n+\/\/ Thread 1 (Java)\n+\/\/         \/\/ --- previous access starts here\n+\/\/         ...\n+\/\/   T1.1: store(&o.x, 1, mo_relaxed);\n+\/\/   T1.2: store(&addr, o, mo_release); \/\/ volatile store\n+\/\/\n+\/\/         \/\/ --- new access starts here\n+\/\/         \/\/ LRB: copy and install the new copy to fwdptr\n+\/\/   T1.3: var copy = copy(o)\n+\/\/   T1.4: cas(&fwd, t, copy, mo_release)\n+\/\/         <access continues>\n+\/\/\n+\/\/ Thread 2 (GC updater)\n+\/\/   T2.1: var f = load(&fwd, mo_acquire)\n+\/\/   T2.2: cas(&addr, o, f, mo_release) \/\/ this method\n+\/\/\n+\/\/ Thread 3 (Java)\n+\/\/   T3.1: var o = load(&addr, mo_acquire) \/\/ volatile read\n+\/\/   T3.2: if (o != null)\n+\/\/   T3.3:   var r = load(&o.x, mo_relaxed)\n+\/\/\n+\/\/ r is guaranteed to contain \"1\".\n+\/\/\n+\/\/ Without GC involvement, there is synchronizes-with edge from T1.2 to T3.1,\n+\/\/ which guarantees this. With GC involvement, when LRB copies the object and\n+\/\/ another thread updates the reference to it, we need to have the transitive edge\n+\/\/ from T1.4 to T2.1 (that one is guaranteed by forwarding accesses), plus the edge\n+\/\/ from T2.2 to T3.1 (which is brought by this CAS).\n+\/\/\n+\n@@ -143,1 +181,1 @@\n-  return (oop) Atomic::cmpxchg(addr, c, n, memory_order_relaxed);\n+  return (oop) Atomic::cmpxchg(addr, c, n, memory_order_acq_rel);\n@@ -149,1 +187,1 @@\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val, memory_order_relaxed));\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val, memory_order_acq_rel));\n@@ -156,1 +194,1 @@\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val, memory_order_relaxed));\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val, memory_order_acq_rel));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":41,"deletions":3,"binary":false,"changes":44,"status":"modified"}]}