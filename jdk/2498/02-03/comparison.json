{"files":[{"patch":"@@ -348,1 +348,1 @@\n-        oop witness = ShenandoahHeap::atomic_update_oop(fwd, elem_ptr, o);\n+        ShenandoahHeap::atomic_update_oop(fwd, elem_ptr, o);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-      _heap->atomic_update_oop(resolved, p, o);\n+      ShenandoahHeap::atomic_update_oop(resolved, p, o);\n@@ -209,1 +209,1 @@\n-        Atomic::cmpxchg(p, obj, oop());\n+        ShenandoahHeap::atomic_clear_oop(p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -652,1 +652,1 @@\n-      Atomic::cmpxchg(p, obj, oop(NULL));\n+      ShenandoahHeap::atomic_clear_oop(p, obj);\n@@ -658,1 +658,1 @@\n-      Atomic::cmpxchg(p, obj, resolved);\n+      ShenandoahHeap::atomic_update_oop(resolved, p, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,3 +629,11 @@\n-  static inline oop atomic_update_oop(oop n, narrowOop* addr, oop c);\n-  static inline oop atomic_update_oop(oop n, oop* addr, oop c);\n-  static inline oop atomic_update_oop(oop n, narrowOop* addr, narrowOop c);\n+  static inline void atomic_update_oop(oop update,       oop* addr,       oop compare);\n+  static inline void atomic_update_oop(oop update, narrowOop* addr,       oop compare);\n+  static inline void atomic_update_oop(oop update, narrowOop* addr, narrowOop compare);\n+\n+  static inline bool atomic_update_oop_check(oop update,       oop* addr,       oop compare);\n+  static inline bool atomic_update_oop_check(oop update, narrowOop* addr,       oop compare);\n+  static inline bool atomic_update_oop_check(oop update, narrowOop* addr, narrowOop compare);\n+\n+  static inline void atomic_clear_oop(      oop* addr,       oop compare);\n+  static inline void atomic_clear_oop(narrowOop* addr,       oop compare);\n+  static inline void atomic_clear_oop(narrowOop* addr, narrowOop compare);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -134,3 +134,1 @@\n-      \/\/ We only check that non-NULL store still updated with non-forwarded reference.\n-      oop witness = atomic_update_oop(fwd, p, obj);\n-      shenandoah_assert_not_forwarded_except(p, witness, (witness == NULL) || (witness == obj));\n+      atomic_update_oop(fwd, p, obj);\n@@ -141,4 +139,6 @@\n-\/\/ Atomic updates of oops. This is only expected to work with updating the same\n-\/\/ logical object with its forwardee, or updating the location to NULL.\n-\/\/ The reason why we need a stronger memory ordering has to do with coordination\n-\/\/ with LRB copying the object.\n+\/\/ Atomic updates of heap location. This is only expected to work with updating the same\n+\/\/ logical object with its forwardee. The reason why we need a stronger memory ordering has\n+\/\/ to do with coordination with GC barriers and mutator accesses.\n+\/\/\n+\/\/ In essence, stronger CAS access is required to maintain the transitive acq\/rel that mutator\n+\/\/ accesses build by themselves. To illustrate this point, consider the following example.\n@@ -147,1 +147,3 @@\n-\/\/ to field at \"addr\", which happens to be Java volatile field. Then consider this example.\n+\/\/ to field at \"addr\", which happens to be Java volatile field. Normally, the accesses to volatile\n+\/\/ field at \"addr\" would be matched with release\/acquire barriers. This changes when GC moves\n+\/\/ the object under mutator feet.\n@@ -178,0 +180,43 @@\n+\/\/ Note that we do not need to \"acquire\" in these methods, because we do not read the\n+\/\/ failure witnesses contents on any path.\n+\/\/\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, oop* addr, oop compare) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  Atomic::cmpxchg(addr, compare, update, memory_order_release);\n+}\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, narrowOop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, compare, u, memory_order_release);\n+}\n+\n+inline void ShenandoahHeap::atomic_update_oop(oop update, narrowOop* addr, oop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop c = CompressedOops::encode(compare);\n+  narrowOop u = CompressedOops::encode(update);\n+  Atomic::cmpxchg(addr, c, u, memory_order_release);\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, oop* addr, oop compare) {\n+  assert(is_aligned(addr, HeapWordSize), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  return (oop) Atomic::cmpxchg(addr, compare, update, memory_order_release) == compare;\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, narrowOop* addr, narrowOop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop u = CompressedOops::encode(update);\n+  return (narrowOop) Atomic::cmpxchg(addr, compare, u, memory_order_release) == compare;\n+}\n+\n+inline bool ShenandoahHeap::atomic_update_oop_check(oop update, narrowOop* addr, oop compare) {\n+  assert(is_aligned(addr, sizeof(narrowOop)), \"Address should be aligned: \" PTR_FORMAT, p2i(addr));\n+  narrowOop c = CompressedOops::encode(compare);\n+  narrowOop u = CompressedOops::encode(update);\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, c, u, memory_order_release)) == compare;\n+}\n+\n+\/\/ The memory ordering discussion above does not apply for methods that store NULLs:\n+\/\/ then, there is no transitive reads in mutator (as we see NULLs), and we can do\n+\/\/ relaxed memory ordering there.\n@@ -179,1 +224,1 @@\n-inline oop ShenandoahHeap::atomic_update_oop(oop n, oop* addr, oop c) {\n+inline void ShenandoahHeap::atomic_clear_oop(oop* addr, oop compare) {\n@@ -181,1 +226,1 @@\n-  return (oop) Atomic::cmpxchg(addr, c, n, memory_order_release);\n+  Atomic::cmpxchg(addr, compare, oop(), memory_order_relaxed);\n@@ -184,1 +229,1 @@\n-inline oop ShenandoahHeap::atomic_update_oop(oop n, narrowOop* addr, narrowOop c) {\n+inline void ShenandoahHeap::atomic_clear_oop(narrowOop* addr, oop compare) {\n@@ -186,2 +231,2 @@\n-  narrowOop val = CompressedOops::encode(n);\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val, memory_order_release));\n+  narrowOop cmp = CompressedOops::encode(compare);\n+  Atomic::cmpxchg(addr, cmp, narrowOop(), memory_order_relaxed);\n@@ -190,1 +235,1 @@\n-inline oop ShenandoahHeap::atomic_update_oop(oop n, narrowOop* addr, oop c) {\n+inline void ShenandoahHeap::atomic_clear_oop(narrowOop* addr, narrowOop compare) {\n@@ -192,3 +237,1 @@\n-  narrowOop cmp = CompressedOops::encode(c);\n-  narrowOop val = CompressedOops::encode(n);\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val, memory_order_release));\n+  Atomic::cmpxchg(addr, compare, narrowOop(), memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -120,14 +120,3 @@\n-static bool reference_cas_discovered(oop reference, oop discovered);\n-\n-template<>\n-bool reference_cas_discovered<narrowOop>(oop reference, oop discovered) {\n-  volatile narrowOop* addr = reinterpret_cast<volatile narrowOop*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n-  narrowOop compare = CompressedOops::encode(NULL);\n-  narrowOop exchange = CompressedOops::encode(discovered);\n-  return Atomic::cmpxchg(addr, compare, exchange) == compare;\n-}\n-\n-template<>\n-bool reference_cas_discovered<oop>(oop reference, oop discovered) {\n-  volatile oop* addr = reinterpret_cast<volatile oop*>(java_lang_ref_Reference::discovered_addr_raw(reference));\n-  return Atomic::cmpxchg(addr, oop(NULL), discovered) == NULL;\n+static bool reference_cas_discovered(oop reference, oop discovered) {\n+  T* addr = reinterpret_cast<T *>(java_lang_ref_Reference::discovered_addr_raw(reference));\n+  return ShenandoahHeap::atomic_update_oop_check(discovered, addr, NULL);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"}]}