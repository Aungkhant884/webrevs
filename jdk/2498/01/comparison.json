{"files":[{"patch":"@@ -72,1 +72,1 @@\n-    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n+    ShenandoahHeap::atomic_update_oop(fwd, load_addr, obj);\n@@ -129,1 +129,1 @@\n-    ShenandoahHeap::cas_oop(fwd, load_addr, obj);\n+    ShenandoahHeap::atomic_update_oop(fwd, load_addr, obj);\n@@ -348,1 +348,1 @@\n-        oop witness = ShenandoahHeap::cas_oop(fwd, elem_ptr, o);\n+        oop witness = ShenandoahHeap::atomic_update_oop(fwd, elem_ptr, o);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        ShenandoahHeap::cas_oop(fwd, p, o);\n+        ShenandoahHeap::atomic_update_oop(fwd, p, o);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSetClone.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-      _heap->cas_oop(resolved, p, o);\n+      _heap->atomic_update_oop(resolved, p, o);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -629,3 +629,3 @@\n-  static inline oop cas_oop(oop n, narrowOop* addr, oop c);\n-  static inline oop cas_oop(oop n, oop* addr, oop c);\n-  static inline oop cas_oop(oop n, narrowOop* addr, narrowOop c);\n+  static inline oop atomic_update_oop(oop n, narrowOop* addr, oop c);\n+  static inline oop atomic_update_oop(oop n, oop* addr, oop c);\n+  static inline oop atomic_update_oop(oop n, narrowOop* addr, narrowOop c);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -135,1 +135,1 @@\n-      oop witness = cas_oop(fwd, p, obj);\n+      oop witness = atomic_update_oop(fwd, p, obj);\n@@ -141,1 +141,39 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, oop* addr, oop c) {\n+\/\/ Atomic updates of oops. This is only expected to work with updating the same\n+\/\/ logical object with its forwardee, or updating the location to NULL.\n+\/\/ The reason why we need a stronger memory ordering has to do with coordination\n+\/\/ with LRB copying the object.\n+\/\/\n+\/\/ Suppose \"o\" is the object that has a field \"x\" and the reference to \"o\" is stored\n+\/\/ to field at \"addr\", which happens to be Java volatile field. Then consider this example.\n+\/\/\n+\/\/ Thread 1 (Java)\n+\/\/         \/\/ --- previous access starts here\n+\/\/         ...\n+\/\/   T1.1: store(&o.x, 1, mo_relaxed);\n+\/\/   T1.2: store(&addr, o, mo_release); \/\/ volatile store\n+\/\/\n+\/\/         \/\/ --- new access starts here\n+\/\/         \/\/ LRB: copy and install the new copy to fwdptr\n+\/\/   T1.3: var copy = copy(o)\n+\/\/   T1.4: cas(&fwd, t, copy, mo_release)\n+\/\/         <access continues>\n+\/\/\n+\/\/ Thread 2 (GC updater)\n+\/\/   T2.1: var f = load(&fwd, mo_acquire)\n+\/\/   T2.2: cas(&addr, o, f, mo_release) \/\/ this method\n+\/\/\n+\/\/ Thread 3 (Java)\n+\/\/   T3.1: var o = load(&addr, mo_acquire) \/\/ volatile read\n+\/\/   T3.2: if (o != null)\n+\/\/   T3.3:   var r = load(&o.x, mo_relaxed)\n+\/\/\n+\/\/ r is guaranteed to contain \"1\".\n+\/\/\n+\/\/ Without GC involvement, there is synchronizes-with edge from T1.2 to T3.1,\n+\/\/ which guarantees this. With GC involvement, when LRB copies the object and\n+\/\/ another thread updates the reference to it, we need to have the transitive edge\n+\/\/ from T1.4 to T2.1 (that one is guaranteed by forwarding accesses), plus the edge\n+\/\/ from T2.2 to T3.1 (which is brought by this CAS).\n+\/\/\n+\n+inline oop ShenandoahHeap::atomic_update_oop(oop n, oop* addr, oop c) {\n@@ -143,1 +181,1 @@\n-  return (oop) Atomic::cmpxchg(addr, c, n);\n+  return (oop) Atomic::cmpxchg(addr, c, n, memory_order_acq_rel);\n@@ -146,1 +184,1 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, narrowOop c) {\n+inline oop ShenandoahHeap::atomic_update_oop(oop n, narrowOop* addr, narrowOop c) {\n@@ -149,1 +187,1 @@\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val));\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, c, val, memory_order_acq_rel));\n@@ -152,1 +190,1 @@\n-inline oop ShenandoahHeap::cas_oop(oop n, narrowOop* addr, oop c) {\n+inline oop ShenandoahHeap::atomic_update_oop(oop n, narrowOop* addr, oop c) {\n@@ -156,1 +194,1 @@\n-  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val));\n+  return CompressedOops::decode(Atomic::cmpxchg(addr, cmp, val, memory_order_acq_rel));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":45,"deletions":7,"binary":false,"changes":52,"status":"modified"}]}