{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -787,1 +787,1 @@\n-                dumpTokenMap();\n+                dumpTokenMap(debug);\n@@ -869,1 +869,1 @@\n-                dumpTokenMap();\n+                dumpTokenMap(debug);\n@@ -1155,1 +1155,1 @@\n-                    dumpTokenMap();\n+                    dumpTokenMap(debug);\n@@ -1232,1 +1232,1 @@\n-            if (ch == null || ch.length == 0) {\n+            if (ch.length == 0) {\n@@ -1983,19 +1983,6 @@\n-            X509Certificate endCert = loadCert(session, h.handle);\n-            token.p11.C_DestroyObject(session.id(), h.handle);\n-            if (debug != null) {\n-                debug.println(\"destroyChain destroyed end entity cert \" +\n-                        \"with CKA_ID [\" +\n-                        getIDNullSafe(cka_id) +\n-                        \"]\");\n-            }\n-\n-            \/\/ build chain following issuer->subject links\n-\n-            X509Certificate next = endCert;\n-            while (true) {\n-\n-                if (next.getSubjectX500Principal().equals\n-                    (next.getIssuerX500Principal())) {\n-                    \/\/ self-signed - done\n-                    break;\n-                }\n+            long currHdl = h.handle;\n+            boolean checkPrivKey = false;\n+            while (currHdl != 0L) {\n+                X509Certificate cert = loadCert(session, currHdl);\n+                boolean selfSigned = cert.getSubjectX500Principal().equals\n+                        (cert.getIssuerX500Principal());\n@@ -2003,0 +1990,3 @@\n+                \/\/ only delete if both of the followings are true\n+                \/\/ 1) no other certs depend on it\n+                \/\/ 2) not corresponds to any private key\n@@ -2004,20 +1994,6 @@\n-                        ATTR_TOKEN_TRUE,\n-                        ATTR_CLASS_CERT,\n-                        new CK_ATTRIBUTE(CKA_SUBJECT,\n-                                  next.getIssuerX500Principal().getEncoded()) };\n-                long[] ch = findObjects(session, attrs);\n-\n-                if (ch == null || ch.length == 0) {\n-                    \/\/ done\n-                    break;\n-                } else {\n-                    \/\/ if more than one found, use first\n-                    if (debug != null && ch.length > 1) {\n-                        debug.println(\"destroyChain found \" +\n-                                ch.length +\n-                                \" certificate entries for subject [\" +\n-                                next.getIssuerX500Principal() +\n-                                \"] in token - using first entry\");\n-                    }\n-\n-                    next = loadCert(session, ch[0]);\n+                    ATTR_TOKEN_TRUE,\n+                    ATTR_CLASS_CERT,\n+                    new CK_ATTRIBUTE(CKA_ISSUER,\n+                        cert.getSubjectX500Principal().getEncoded())\n+                };\n+                boolean destroyIt = true;\n@@ -2025,1 +2001,5 @@\n-                    \/\/ only delete if not part of any other chain\n+                long[] dependents = findObjects(session, attrs);\n+                if (dependents.length > 1 ||\n+                        (!selfSigned && dependents.length == 1)) {\n+                    destroyIt = false;\n+                }\n@@ -2027,0 +2007,2 @@\n+                if (destroyIt && checkPrivKey) {\n+                    \/\/ proceed with checking if there is a private key\n@@ -2028,18 +2010,12 @@\n-                        ATTR_TOKEN_TRUE,\n-                        ATTR_CLASS_CERT,\n-                        new CK_ATTRIBUTE(CKA_ISSUER,\n-                                next.getSubjectX500Principal().getEncoded()) };\n-                    long[] issuers = findObjects(session, attrs);\n-\n-                    boolean destroyIt = false;\n-                    if (issuers == null || issuers.length == 0) {\n-                        \/\/ no other certs with this issuer -\n-                        \/\/ destroy it\n-                        destroyIt = true;\n-                    } else if (issuers.length == 1) {\n-                        X509Certificate iCert = loadCert(session, issuers[0]);\n-                        if (next.equals(iCert)) {\n-                            \/\/ only cert with issuer is itself (self-signed) -\n-                            \/\/ destroy it\n-                            destroyIt = true;\n-                        }\n+                        new CK_ATTRIBUTE(CKA_ID),\n+                    };\n+                    token.p11.C_GetAttributeValue(session.id(), currHdl, attrs);\n+                    byte[] currId = attrs[0].getByteArray();\n+                    if (currId != null) {\n+                        attrs = new CK_ATTRIBUTE[] {\n+                            ATTR_TOKEN_TRUE,\n+                            ATTR_CLASS_PKEY,\n+                            new CK_ATTRIBUTE(CKA_ID, currId)\n+                        };\n+                        long[] privKeys = findObjects(session, attrs);\n+                        destroyIt = privKeys.length == 0;\n@@ -2047,15 +2023,13 @@\n-\n-                    if (destroyIt) {\n-                        token.p11.C_DestroyObject(session.id(), ch[0]);\n-                        if (debug != null) {\n-                            debug.println\n-                                (\"destroyChain destroyed cert in chain \" +\n-                                \"with subject [\" +\n-                                next.getSubjectX500Principal() + \"]\");\n-                        }\n-                    } else {\n-                        if (debug != null) {\n-                            debug.println(\"destroyChain did not destroy \" +\n-                                \"shared cert in chain with subject [\" +\n-                                next.getSubjectX500Principal() + \"]\");\n-                        }\n+                }\n+                if (destroyIt) {\n+                    token.p11.C_DestroyObject(session.id(), currHdl);\n+                    if (debug != null) {\n+                        debug.println(\"destroyChain destroyed cert in chain \" +\n+                            \"with subject [\" +\n+                            cert.getSubjectX500Principal() + \"]\");\n+                    }\n+                } else {\n+                    if (debug != null) {\n+                        debug.println(\"destroyChain did not destroy \" +\n+                            \"shared cert in chain with subject [\" +\n+                            cert.getSubjectX500Principal() + \"]\");\n@@ -2064,0 +2038,23 @@\n+                if (selfSigned) {\n+                    break; \/\/ done\n+                }\n+                attrs = new CK_ATTRIBUTE[] {\n+                    ATTR_TOKEN_TRUE,\n+                    ATTR_CLASS_CERT,\n+                    new CK_ATTRIBUTE(CKA_SUBJECT,\n+                        cert.getIssuerX500Principal().getEncoded())\n+                };\n+                long[] ch = findObjects(session, attrs);\n+                if (ch.length == 0) {\n+                    break;\n+                }\n+                \/\/ if more than one found, use first\n+                if (debug != null && ch.length > 1) {\n+                    debug.println(\"destroyChain found \" +\n+                        ch.length +\n+                        \" certificate entries for subject [\" +\n+                        cert.getIssuerX500Principal() +\n+                        \"] in token - using first entry\");\n+                }\n+                currHdl = ch[0];\n+                checkPrivKey = true;\n@@ -2065,1 +2062,0 @@\n-\n@@ -2067,1 +2063,0 @@\n-\n@@ -2649,1 +2644,1 @@\n-    private void dumpTokenMap() {\n+    private void dumpTokenMap(Debug debug) {\n@@ -2651,1 +2646,1 @@\n-        System.out.println(\"Token Alias Map:\");\n+        debug.println(\"Token Alias Map:\");\n@@ -2653,1 +2648,1 @@\n-            System.out.println(\"  [empty]\");\n+            debug.println(\"  [empty]\");\n@@ -2656,1 +2651,1 @@\n-                System.out.println(\"  \" + s + aliasMap.get(s));\n+                debug.println(\"  \" + s + aliasMap.get(s));\n@@ -2670,0 +2665,1 @@\n+    \/\/ return an empty array if no match\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyStore.java","additions":80,"deletions":84,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -0,0 +1,231 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8301154\n+ * @summary test cert chain deletion logic w\/ NSS PKCS11 KeyStore\n+ * @library \/test\/lib ..\n+ * @run testng\/othervm CertChainRemoval\n+ *\/\n+import jdk.test.lib.SecurityTools;\n+import java.io.*;\n+import java.nio.file.Path;\n+import java.util.*;\n+\n+import java.security.Key;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.Provider;\n+import java.security.cert.Certificate;\n+\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\n+public class CertChainRemoval extends PKCS11Test {\n+\n+    private static final Path TEST_DATA_PATH = Path.of(BASE)\n+            .resolve(\"CertChainRemoval\");\n+    private static final String DIR = TEST_DATA_PATH.toString();\n+\n+    private record KeyStoreInfo(File file, String type, char[] passwd) {}\n+\n+    private static final KeyStoreInfo TEMP = new KeyStoreInfo(\n+            new File(DIR, \"temp.ks\"),\n+            \"JKS\",\n+            new char[] { 'c', 'h', 'a', 'n', 'g', 'e', 'i', 't' });\n+\n+    private static final KeyStoreInfo PKCS11KS = new KeyStoreInfo(\n+            null,\n+            \"PKCS11\",\n+            new char[] { 't', 'e', 's', 't', '1', '2' });\n+\n+    @BeforeClass\n+    public void setUp() throws Exception {\n+        copyNssCertKeyToClassesDir();\n+        setCommonSystemProps();\n+        \/\/ if temp keystore already exists; skip the creation\n+        if (!TEMP.file.exists()) {\n+            createKeyStore(TEMP);\n+        }\n+        System.setProperty(\"CUSTOM_P11_CONFIG\",\n+                TEST_DATA_PATH.resolve(\"p11-nss.txt\").toString());\n+    }\n+\n+    @Test\n+    public void test() throws Exception {\n+        main(new CertChainRemoval());\n+    }\n+\n+    private static void printKeyStore(String header, KeyStore ks)\n+            throws KeyStoreException {\n+        System.out.println(header);\n+        Enumeration enu = ks.aliases();\n+        int count = 0;\n+        while (enu.hasMoreElements()) {\n+            count++;\n+            System.out.println(\"Entry# \" + count +\n+                    \" = \" + (String)enu.nextElement());\n+        }\n+        System.out.println(\"========\");\n+    }\n+\n+    private static void checkEntry(KeyStore ks, String alias,\n+            Certificate[] expChain) throws KeyStoreException {\n+        Certificate c = ks.getCertificate(alias);\n+        Certificate[] chain = ks.getCertificateChain(alias);\n+        if (expChain == null) {\n+            if (c != null || (chain != null && chain.length != 0)) {\n+                throw new RuntimeException(\"Fail: \" + alias + \" not removed\");\n+            }\n+        } else {\n+            if (!c.equals(expChain[0]) || !Arrays.equals(chain, expChain)) {\n+                System.out.println(\"expChain: \" + expChain.length);\n+                System.out.println(\"actualChain: \" + chain.length);\n+                throw new RuntimeException(\"Fail: \" + alias +\n+                        \" chain check diff\");\n+            }\n+        }\n+    }\n+\n+    public void main(Provider p) throws Exception {\n+        KeyStore sunks = KeyStore.getInstance(TEMP.type, \"SUN\");\n+        sunks.load(new FileInputStream(TEMP.file), TEMP.passwd);\n+        printKeyStore(\"Starting with: \", sunks);\n+\n+        KeyStore p11ks;\n+        try {\n+            p11ks = KeyStore.getInstance(PKCS11KS.type, p);\n+            p11ks.load(null, PKCS11KS.passwd);\n+            printKeyStore(\"Initial PKCS11 KeyStore: \", p11ks);\n+        } catch (Exception e) {\n+            System.out.println(\"Skip test, due to \" + e);\n+            return;\n+        }\n+\n+        \/\/ get the necessary keys from the temp keystore\n+        Key pk1PrivKey = sunks.getKey(\"pk1\", TEMP.passwd);\n+        Certificate pk1Cert = sunks.getCertificate(\"pk1\");\n+        Key caPrivKey = sunks.getKey(\"ca1\", TEMP.passwd);\n+        Certificate ca1Cert = sunks.getCertificate(\"ca1\");\n+        Key rootPrivKey = sunks.getKey(\"root\", TEMP.passwd);\n+        Certificate rootCert = sunks.getCertificate(\"root\");\n+\n+        Certificate[] pk1Chain = { pk1Cert, ca1Cert, rootCert };\n+        Certificate[] ca1Chain = { ca1Cert, rootCert };\n+        Certificate[] rootChain = { rootCert };\n+\n+        \/\/ populate keystore with \"pk1\" and \"ca\", then delete \"pk1\"\n+        System.out.println(\"Add pk1, ca1 and root, then delete pk1\");\n+        p11ks.setKeyEntry(\"pk1\", pk1PrivKey, null, pk1Chain);\n+        p11ks.setKeyEntry(\"ca1\", caPrivKey, null, ca1Chain);\n+        p11ks.setKeyEntry(\"root\", rootPrivKey, null, rootChain);\n+        p11ks.deleteEntry(\"pk1\");\n+\n+        \/\/ reload the keystore\n+        p11ks.store(null, PKCS11KS.passwd);\n+        p11ks.load(null, PKCS11KS.passwd);\n+        printKeyStore(\"Reload#1: ca1 \/ root\", p11ks);\n+\n+        \/\/ should only have \"ca1\" and \"root\"\n+        checkEntry(p11ks, \"pk1\", null);\n+        checkEntry(p11ks, \"ca1\", ca1Chain);\n+        checkEntry(p11ks, \"root\", rootChain);\n+\n+        \/\/ now add \"pk1\" and delete \"ca1\"\n+        System.out.println(\"Now add pk1 and delete ca1\");\n+        p11ks.setKeyEntry(\"pk1\", pk1PrivKey, null, pk1Chain);\n+        p11ks.deleteEntry(\"ca1\");\n+\n+        \/\/ reload the keystore\n+        p11ks.store(null, PKCS11KS.passwd);\n+        p11ks.load(null, PKCS11KS.passwd);\n+        printKeyStore(\"Reload#2: pk1 \/ root\", p11ks);\n+\n+        \/\/ should only have \"pk1\" and \"root\" now\n+        checkEntry(p11ks, \"pk1\", pk1Chain);\n+        checkEntry(p11ks, \"ca1\", null);\n+        checkEntry(p11ks, \"root\", rootChain);\n+\n+        \/\/ now delete \"root\"\n+        System.out.println(\"Now delete root\");\n+        p11ks.deleteEntry(\"root\");\n+\n+        \/\/ reload the keystore\n+        p11ks.store(null, PKCS11KS.passwd);\n+        p11ks.load(null, PKCS11KS.passwd);\n+        printKeyStore(\"Reload#3: pk1\", p11ks);\n+\n+        \/\/ should only have \"pk1\" now\n+        checkEntry(p11ks, \"pk1\", pk1Chain);\n+        checkEntry(p11ks, \"ca1\", null);\n+        checkEntry(p11ks, \"root\", null);\n+\n+        \/\/ now delete \"pk1\"\n+        System.out.println(\"Now delete pk1\");\n+        p11ks.deleteEntry(\"pk1\");\n+\n+        \/\/ reload the keystore\n+        p11ks.store(null, PKCS11KS.passwd);\n+        p11ks.load(null, PKCS11KS.passwd);\n+        printKeyStore(\"Reload#4: \", p11ks);\n+\n+        \/\/ should have nothing now\n+        checkEntry(p11ks, \"pk1\", null);\n+        checkEntry(p11ks, \"ca1\", null);\n+        checkEntry(p11ks, \"root\", null);\n+\n+        System.out.println(\"Test Passed\");\n+    }\n+\n+    private static void createKeyStore(KeyStoreInfo ksi) throws Exception {\n+        System.out.println(\"Creating keypairs and storing them into \" +\n+            ksi.file.getAbsolutePath());\n+        String keyGenOptions = \" -keyalg RSA -keysize 2048 \";\n+        String keyStoreOptions = \" -keystore \" + ksi.file.getAbsolutePath() +\n+                \" -storetype \" + ksi.type + \" -storepass \" +\n+                new String(ksi.passwd);\n+\n+        String[] aliases = { \"ROOT\", \"CA1\", \"PK1\" };\n+        for (String n : aliases) {\n+            SecurityTools.keytool(\"-genkeypair -alias \" + n +\n+                \" -dname CN=\" + n + keyGenOptions + keyStoreOptions);\n+            String issuer = switch (n) {\n+                case \"CA1\"-> \"ROOT\";\n+                case \"PK1\"-> \"CA1\";\n+                default-> null;\n+            };\n+            if (issuer != null) {\n+                \/\/ export CSR and issue the cert using the issuer\n+                SecurityTools.keytool(\"-certreq -alias \" + n +\n+                    \" -file tmp.req\" + keyStoreOptions);\n+                SecurityTools.keytool(\"-gencert -alias \" + issuer +\n+                    \" -infile tmp.req -outfile tmp.cert -validity 3650\" +\n+                    keyStoreOptions);\n+                SecurityTools.keytool(\"-importcert -alias \" + n +\n+                    \" -file tmp.cert\" + keyStoreOptions);\n+            }\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/CertChainRemoval.java","additions":231,"deletions":0,"binary":false,"changes":231,"status":"added"},{"patch":"","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/CertChainRemoval\/p11-nss.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/BasicData\/p11-nss.txt","status":"copied"},{"filename":"test\/jdk\/sun\/security\/pkcs11\/KeyStore\/CertChainRemoval\/temp.ks","binary":true,"status":"added"}]}