[{"commit":{"message":"Make the code more readable"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"1e455e313915be1d0ba81c5d64d3cbbdd8fc551c"},{"commit":{"message":"Reword some comments"},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"}],"sha":"7272ce10eebc1d0250f0b30839347fdf740ce9b9"},{"commit":{"message":"8291466: C2: assert(false) failed: infinite loop in PhaseIterGVN::transform_old with -XX:+StressIGVN\n\nRecently, an igvn infinite loop issue was reported. Git bisection shows\nit appears after our JDK-8289996 patch. But after that patch is backed\nout, we find similar test still fails. We have attached a jtreg case to\nreproduce this issue.\n\nThe ideal graph of the problematic method has a `MulINode` multiplying a\n`PhiNode` by a `ConINode`. For better optimizations, `MulINode::Ideal()`\nmoves the constant input to the right hand side. And `Ideal()` function\nin its parent class `MulNode` has the similar logic. In some code paths,\n`MulINode::Ideal()` calls `MulNode::Ideal()`. The problem here is that,\n`MulINode` and `MulNode` use different ways to check constant. One calls\n`type->singleton()` and the other calls `node->find_int_con(val)` which\naccepts constant in `PhiNode`. So in some corner cases where a `PhiNode`\ncan be evaluated to a constant, the two inputs of the `MulNode` will be\nswapped back and forth in `Ideal()` calls. It eventually causes the igvn\ninfinite loop issue.\n\nThis patch removes the `swap_edges()` logic in `MulINode` and `MulLNode`\nbecause it's enough to do this by calling `MulNode::Ideal()`. We also do\nsome code cleanup in this patch as we have done in JDK-8289996.\n\nTested hotspot::hotspot_all_no_apps, jdk::tier1~3 and langtools::tier1."},"files":[{"filename":"src\/hotspot\/share\/opto\/mulnode.cpp"},{"filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMulNodeInfiniteGVN.java"}],"sha":"8ca741904e79adf547717a74e024f4bd365f84ef"}]