{"files":[{"patch":"@@ -242,1 +242,0 @@\n-  \/\/ Swap constant to right\n@@ -244,4 +243,3 @@\n-  if ((con = in(1)->find_int_con(0)) != 0) {\n-    swap_edges(1, 2);\n-    \/\/ Finish rest of method to use info in 'con'\n-  } else if ((con = in(2)->find_int_con(0)) == 0) {\n+  if ((con = in(2)->find_int_con(0)) == 0) {\n+    \/\/ Call MulNode::Ideal() for common transformations. After that,\n+    \/\/ the constant input should be on the right side.\n@@ -251,3 +249,3 @@\n-  \/\/ Now we have a constant Node on the right and the constant in con\n-  if (con == 0) return NULL;   \/\/ By zero is handled by Value call\n-  if (con == 1) return NULL;   \/\/ By one  is handled by Identity call\n+  \/\/ Now we have a constant Node on the right and the constant in con.\n+  \/\/ We can't find ZERO constant but it's handled by Value call.\n+  if (con == 1) return NULL;   \/\/ By one is handled by Identity call\n@@ -265,1 +263,1 @@\n-  unsigned int bit1 = abs_con & (0-abs_con);       \/\/ Extract low bit\n+  unsigned int bit1 = submultiple_power_of_2(abs_con);\n@@ -339,4 +337,3 @@\n-  if ((con = in(1)->find_long_con(0)) != 0) {\n-    swap_edges(1, 2);\n-    \/\/ Finish rest of method to use info in 'con'\n-  } else if ((con = in(2)->find_long_con(0)) == 0) {\n+  if ((con = in(2)->find_long_con(0)) == 0) {\n+    \/\/ Call MulNode::Ideal() for common transformations. After that,\n+    \/\/ the constant input should be on the right side.\n@@ -346,3 +343,3 @@\n-  \/\/ Now we have a constant Node on the right and the constant in con\n-  if (con == CONST64(0)) return NULL;  \/\/ By zero is handled by Value call\n-  if (con == CONST64(1)) return NULL;  \/\/ By one  is handled by Identity call\n+  \/\/ Now we have a constant Node on the right and the constant in con.\n+  \/\/ We can't find ZERO constant but it's handled by Value call.\n+  if (con == CONST64(1)) return NULL;  \/\/ By one is handled by Identity call\n@@ -359,1 +356,1 @@\n-  julong bit1 = abs_con & (0-abs_con);      \/\/ Extract low bit\n+  julong bit1 = submultiple_power_of_2(abs_con);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,10 @@\n+\/\/ Return the largest power of two that is a submultiple of the given value.\n+\/\/ This is the same as the numeric value of the least-significant set bit.\n+\/\/ For unsigned values, it replaces the old trick of (value & -value).\n+\/\/ precondition: value > 0.\n+template<typename T, ENABLE_IF(std::is_integral<T>::value)>\n+inline T submultiple_power_of_2(T value) {\n+  assert(value > 0, \"Invalid value\");\n+  return value & -value;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/powerOfTwo.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key stress randomness\n+ * @bug 8291466\n+ * @summary Infinite loop in PhaseIterGVN::transform_old with -XX:+StressIGVN\n+ * @requires vm.compiler2.enabled\n+ * @run main\/othervm -Xbatch -XX:-TieredCompilation\n+ *                   -XX:+UnlockDiagnosticVMOptions -XX:+StressIGVN\n+ *                   -XX:StressSeed=1 compiler.c2.TestMulNodeInfiniteGVN\n+ *\/\n+\n+package compiler.c2;\n+\n+public class TestMulNodeInfiniteGVN {\n+\n+    private static int fun() {\n+        int sum = 0;\n+        for (int c = 0; c < 50000; c++) {\n+            int x = 9;\n+            while ((x += 2) < 12) {\n+                for (int k = 1; k < 2; k++) {\n+                    sum += x * k;\n+                }\n+            }\n+            int y = 11;\n+            while ((y += 2) < 14) {\n+                for (int k = 1; k < 2; k++) {\n+                    sum += y * k;\n+                }\n+            }\n+            int z = 17;\n+            while ((z += 2) < 20) {\n+                for (int k = 1; k < 2; k++) {\n+                    sum += z * k;\n+                }\n+            }\n+        }\n+        return sum;\n+    }\n+\n+    public static void main(String[] args) {\n+        fun();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMulNodeInfiniteGVN.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"}]}