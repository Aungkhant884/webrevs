{"files":[{"patch":"@@ -402,0 +402,19 @@\n+static inline bool target_needs_trampoline(Address entry) {\n+  if (entry.rspec().type() == relocInfo::runtime_call_type) {\n+    \/\/ Runtime calls are statically bound.\n+    \/\/ Once they are generated neither a caller nor a callee address cannot be changed.\n+    \/\/ Check whether a far branch is needed to reach the target.\n+    return target_needs_far_branch(entry.target());\n+  } else {\n+    assert(entry.rspec().type() == relocInfo::opt_virtual_call_type\n+           || entry.rspec().type() == relocInfo::static_call_type\n+           || entry.rspec().type() == relocInfo::virtual_call_type, \"wrong reloc type: not Java method call\");\n+    \/\/ Other calls are Java calls.\n+    \/\/ A callee address can be changed at any time as a result of\n+    \/\/ callee deoptimization or the callee being C1 compiled has become C2 compiled.\n+    \/\/ If CodeCache size > 128M, such calls must have reserved trampolines for cases\n+    \/\/ when a new callee address out of 128M range.\n+    return MacroAssembler::far_branches();\n+  }\n+}\n+\n@@ -571,0 +590,2 @@\n+  bool need_trampoline = target_needs_trampoline(entry);\n+\n@@ -572,1 +593,1 @@\n-  if (far_branches()) {\n+  if (need_trampoline) {\n@@ -593,1 +614,1 @@\n-  if (!far_branches()) {\n+  if (!need_trampoline) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,106 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test TestTrampoline\n+ * @summary Checks that trampolines to runtime code are not generated if they are not needed.\n+ * @bug 8285487\n+ * @library \/test\/lib\n+ *\n+ * @requires vm.flagless\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.debug == false\n+ * @requires vm.compiler2.enabled\n+ *\n+ * @run driver compiler.c2.aarch64.TestTrampoline\n+ *\/\n+\n+public class TestTrampoline {\n+    private final static int ITERATIONS_TO_HEAT_LOOP = 20_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        String testClassName = TestTrampoline.Test.class.getName();\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:CompileCommand=print,\" + testClassName + \"::\" + \"test\");\n+        \/\/ ReservedCodeCacheSize=130M causes generation of trampolines.\n+        \/\/ As the non-nmethod segment is put between other two segments,\n+        \/\/ runtime calls will be within 128M range.\n+        \/\/ So there is no need for trampolines for runtime calls.\n+        command.add(\"-XX:ReservedCodeCacheSize=130M\");\n+        command.add(\"-XX:+SegmentedCodeCache\");\n+        command.add(testClassName);\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(command);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        System.out.println(analyzer.getOutput());\n+        checkOutput(analyzer);\n+    }\n+\n+    private static String skipTo(Iterator<String> iter, String substring) {\n+        while (iter.hasNext()) {\n+            String nextLine = iter.next();\n+            if (nextLine.contains(substring)) {\n+                return nextLine;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void checkOutput(OutputAnalyzer output) {\n+        Iterator<String> iter = output.asLines().listIterator();\n+\n+        String match = skipTo(iter, \"Compiled method (c2)\");\n+        if (match == null || !match.contains(\"Test::test\")) {\n+            throw new RuntimeException(\"Missing compiler output for the method 'test'\");\n+        }\n+\n+        match = skipTo(iter, \"[Stub Code]\");\n+        if (match != null && skipTo(iter, \"{trampoline_stub}\") != null) {\n+            throw new RuntimeException(\"Found unexpected {trampoline_stub}\");\n+        }\n+    }\n+\n+    static class Test {\n+        private static void test(String s, int i) {\n+            if (s.charAt(i) > 128)\n+                throw new RuntimeException();\n+        }\n+\n+        public static void main(String[] args) {\n+            String s = \"Returns the char value at the specified index.\";\n+            for (int i = 0; i < ITERATIONS_TO_HEAT_LOOP; ++i) {\n+                test(s, i % s.length());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestTrampoline.java","additions":106,"deletions":0,"binary":false,"changes":106,"status":"added"}]}