{"files":[{"patch":"@@ -852,0 +852,40 @@\n+\/\/ Check the entry target is always reachable from any branch.\n+static bool is_always_within_branch_range(Address entry) {\n+  const address target = entry.target();\n+  if (!MacroAssembler::far_branches()) {\n+    if (entry.rspec().type() == relocInfo::runtime_call_type &&\n+        !CodeCache::contains(target)) {\n+      \/\/ If it is a runtime call of an address outside small CodeCache,\n+      \/\/ we need to check whether it is in range.\n+      assert(target < CodeCache::low_bound() || target >= CodeCache::high_bound(),\n+             \"target is inside CodeCache\");\n+      \/\/ Case 1: -------T-------L====CodeCache====H-------\n+      \/\/                ^-------longest branch---|\n+      \/\/ Case 2: -------L====CodeCache====H-------T-------\n+      \/\/                |-------longest branch ---^\n+      const address longest_branch_start =\n+          (target < CodeCache::low_bound())\n+              ? CodeCache::high_bound() - NativeInstruction::instruction_size\n+              : CodeCache::low_bound();\n+      return Assembler::reachable_from_branch_at(longest_branch_start, target);\n+    }\n+    return true;\n+  }\n+\n+  if (entry.rspec().type() == relocInfo::runtime_call_type && CodeCache::contains(target)) {\n+    \/\/ Runtime calls are calls of a non-compiled method.\n+    \/\/ Non-compiled methods stay forever in CodeCache.\n+    \/\/ We check whether the longest possible branch is within the branch range.\n+    assert(CodeCache::find_blob(target) != NULL &&\n+          !CodeCache::find_blob(target)->is_compiled(),\n+          \"runtime call of compiled method\");\n+    const address right_longest_branch_start = CodeCache::high_bound() - NativeInstruction::instruction_size;\n+    const address left_longest_branch_start = CodeCache::low_bound();\n+    const bool is_reachable = Assembler::reachable_from_branch_at(left_longest_branch_start, target) &&\n+                              Assembler::reachable_from_branch_at(right_longest_branch_start, target);\n+    return is_reachable;\n+  }\n+\n+  return false;\n+}\n+\n@@ -862,16 +902,1 @@\n-  \/\/ We might need a trampoline if branches are far.\n-  bool need_trampoline = far_branches();\n-  if (!need_trampoline && entry.rspec().type() == relocInfo::runtime_call_type && !CodeCache::contains(target)) {\n-    \/\/ If it is a runtime call of an address outside small CodeCache,\n-    \/\/ we need to check whether it is in range.\n-    assert(target < CodeCache::low_bound() || target >= CodeCache::high_bound(), \"target is inside CodeCache\");\n-    \/\/ Case 1: -------T-------L====CodeCache====H-------\n-    \/\/                ^-------longest branch---|\n-    \/\/ Case 2: -------L====CodeCache====H-------T-------\n-    \/\/                |-------longest branch ---^\n-    address longest_branch_start = (target < CodeCache::low_bound()) ? CodeCache::high_bound() - NativeInstruction::instruction_size\n-                                                                     : CodeCache::low_bound();\n-    need_trampoline = !reachable_from_branch_at(longest_branch_start, target);\n-  }\n-\n-  if (need_trampoline) {\n+  if (!is_always_within_branch_range(entry)) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":41,"deletions":16,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler.c2.aarch64;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+\/**\n+ * @test TestTrampoline\n+ * @summary Checks that trampolines to runtime code are not generated if they are not needed.\n+ * @bug 8285487\n+ * @library \/test\/lib\n+ *\n+ * @requires vm.flagless & os.arch==\"aarch64\" &\n+ *           vm.debug == false & vm.compiler2.enabled\n+ *\n+ * @run driver compiler.c2.aarch64.TestTrampoline\n+ *\/\n+\n+public class TestTrampoline {\n+    private final static int ITERATIONS_TO_HEAT_LOOP = 20_000;\n+\n+    public static void main(String[] args) throws Exception {\n+        String testClassName = TestTrampoline.Test.class.getName();\n+        ArrayList<String> command = new ArrayList<String>();\n+        command.add(\"-XX:+UnlockDiagnosticVMOptions\");\n+        command.add(\"-Xbatch\");\n+        command.add(\"-XX:CompileCommand=print,\" + testClassName + \"::\" + \"test\");\n+        \/\/ ReservedCodeCacheSize=130M causes generation of trampolines.\n+        \/\/ As the non-nmethod segment is put between other two segments,\n+        \/\/ runtime calls will be within 128M range.\n+        \/\/ So there is no need for trampolines for runtime calls.\n+        command.add(\"-XX:ReservedCodeCacheSize=130M\");\n+        command.add(\"-XX:+SegmentedCodeCache\");\n+        command.add(testClassName);\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(command);\n+        OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+        analyzer.shouldHaveExitValue(0);\n+        System.out.println(analyzer.getOutput());\n+        checkOutput(analyzer);\n+    }\n+\n+    private static String skipTo(Iterator<String> iter, String substring) {\n+        while (iter.hasNext()) {\n+            String nextLine = iter.next();\n+            if (nextLine.contains(substring)) {\n+                return nextLine;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static void checkOutput(OutputAnalyzer output) {\n+        Iterator<String> iter = output.asLines().listIterator();\n+\n+        String match = skipTo(iter, \"Compiled method (c2)\");\n+        if (match == null || !match.contains(\"Test::test\")) {\n+            throw new RuntimeException(\"Missing compiler output for the method 'test'\");\n+        }\n+\n+        match = skipTo(iter, \"[Stub Code]\");\n+        if (match != null && skipTo(iter, \"{trampoline_stub}\") != null) {\n+            throw new RuntimeException(\"Found unexpected {trampoline_stub}\");\n+        }\n+    }\n+\n+    static class Test {\n+        private static void test(String s, int i) {\n+            if (s.charAt(i) > 128)\n+                throw new RuntimeException();\n+        }\n+\n+        public static void main(String[] args) {\n+            String s = \"Returns the char value at the specified index.\";\n+            for (int i = 0; i < ITERATIONS_TO_HEAT_LOOP; ++i) {\n+                test(s, i % s.length());\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/aarch64\/TestTrampoline.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"}]}