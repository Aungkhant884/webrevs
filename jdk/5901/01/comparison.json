{"files":[{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.reflect.Modifier;\n+\n@@ -160,1 +162,1 @@\n-                if (targetClass == implClass) {\n+                if (targetClass == implClass && Modifier.isPrivate(implInfo.getModifiers())) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/AbstractValidatingLambdaMetafactory.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.util.function.Supplier;\n+\n+public class InvokeSpecialMethodImpl {\n+    private static final String SUPER = \"super\";\n+    private static final String SUBCLASS = \"overridden\";\n+\n+    public static void main(String... args) {\n+        SubClass o = new SubClass();\n+        if (!o.test().equals(o.testWithLambda())) {\n+            throw new RuntimeException(\"testWithLambda returns \" + o.testWithLambda());\n+        }\n+    }\n+\n+    public String test() {\n+        return testPrivate();\n+    }\n+\n+    public String testWithLambda() {\n+        Supplier<String> supplier = this::testPrivate;\n+        return supplier.get();\n+    }\n+\n+    private String testPrivate() {\n+        return SUPER;\n+    }\n+\n+    public static class SubClass extends InvokeSpecialMethodImpl {\n+        public String testPrivate() {\n+            return SUBCLASS;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/invokeSpecial\/InvokeSpecialMethodImpl.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,320 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8274848\n+ * @modules java.base\/jdk.internal.org.objectweb.asm\n+ * @library \/test\/lib\n+ * @run main\/othervm InvokeSpecialMethodTest\n+ * @summary ensure REF_invokeSpecial on a non-private implementation method\n+ *          behaves as if `super::m` is invoked regardless of its access flag\n+ *\/\n+\n+import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n+import jdk.internal.org.objectweb.asm.Attribute;\n+import jdk.internal.org.objectweb.asm.ClassReader;\n+import jdk.internal.org.objectweb.asm.ClassVisitor;\n+import jdk.internal.org.objectweb.asm.ClassWriter;\n+import jdk.internal.org.objectweb.asm.Handle;\n+import jdk.internal.org.objectweb.asm.Label;\n+import jdk.internal.org.objectweb.asm.MethodVisitor;\n+import jdk.internal.org.objectweb.asm.Opcodes;\n+import jdk.internal.org.objectweb.asm.TypePath;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.compiler.CompilerUtils;\n+\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+public class InvokeSpecialMethodTest {\n+    private static final Path CLASSES = Path.of(\"classes\");\n+    private static final String IMPL_CLASSNAME = \"InvokeSpecialMethodImpl\";\n+    private static final String IMPL_SUBCLASS = \"InvokeSpecialMethodImpl$SubClass\";\n+    private static final String IMPL_METHODNAME = \"testPrivate\";\n+\n+    public static void main(String... args) throws Throwable {\n+        Path src = Path.of(System.getProperty(\"test.src\"));\n+\n+        \/\/ compile with --release 10 as pre-nestmate class\n+        \/\/ The implementation method handle should be REF_invokeSpecial\n+        \/\/ on InvokeSpecialMethodImpl::testPrivate\n+        CompilerUtils.compile(src.resolve(IMPL_CLASSNAME + \".java\"), CLASSES, \"--release\", \"10\");\n+\n+        \/\/ validate InvokeSpecialMethodImpl::testPrivate is executed\n+        \/\/ not the public SubClass::testPrivate method\n+        ProcessTools.executeTestJava(\"-cp\", CLASSES.toString(), IMPL_CLASSNAME)\n+                    .shouldHaveExitValue(0);\n+\n+        \/\/ test if InvokeSpecialMethodImpl::testPrivate is public or protected\n+        runTest(Opcodes.ACC_PUBLIC);\n+        runTest(Opcodes.ACC_PROTECTED);\n+    }\n+\n+    \/**\n+     * Patch InvokeSpecialMethodImpl::testPrivate to the given access.\n+     * Then run InvokeSpecialMethodImpl to ensure that REF_invokeSpecial method\n+     * handle does not invoke the overridden testPrivate method in the subclass.\n+     *\/\n+    public static void runTest(int access) throws Throwable {\n+        String dir = \"test-\" + access;\n+        Path dest = Path.of(dir);\n+        try (InputStream inputStream = Files.newInputStream(CLASSES.resolve(IMPL_CLASSNAME + \".class\"))) {\n+            ClassReader reader = new ClassReader(inputStream);\n+            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n+            ClassVisitor visitor = make(writer, access);\n+            reader.accept(visitor, ClassReader.EXPAND_FRAMES);\n+            Files.createDirectories(dest);\n+            Files.write(dest.resolve(IMPL_CLASSNAME + \".class\"), writer.toByteArray());\n+        }\n+        Files.copy(CLASSES.resolve(IMPL_SUBCLASS + \".class\"), dest.resolve(IMPL_SUBCLASS + \".class\"));\n+        ProcessTools.executeTestJava(\"-cp\", dir, IMPL_CLASSNAME)\n+                    .shouldHaveExitValue(0);\n+    }\n+\n+    \/*\n+     * Patch the testPrivate method with the given new access.\n+     *\/\n+    public static ClassVisitor make(ClassVisitor cv, int newAccess) {\n+        return new ClassVisitor(Opcodes.ASM8, cv) {\n+            public MethodVisitor visitMethod(int access, String name, String desc,\n+                                             String signature, String[] exceptions) {\n+                if (name.equals(IMPL_METHODNAME))\n+                    access = newAccess;\n+                return new CheckMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));\n+            }\n+        };\n+    }\n+\n+    \/*\n+     * A method visitor to check BSM on LambdaMetafactory.metafactroy\n+     * with REF_invokeSpecial on InvokeSpecialMethodImpl::testPrivate\n+     *\/\n+    static class CheckMethodVisitor extends MethodVisitor {\n+        final MethodVisitor mv;\n+        public CheckMethodVisitor(final MethodVisitor methodVisitor) {\n+            super(Opcodes.ASM8, methodVisitor);\n+            this.mv = methodVisitor;\n+        }\n+\n+        @Override\n+        public void visitParameter(final String name, final int access) {\n+            super.visitParameter(name, access);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n+             return super.visitAnnotation(descriptor, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTypeAnnotation(\n+                final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n+            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitAttribute(final Attribute attribute) {\n+            super.visitAttribute(attribute);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitAnnotationDefault() {\n+            return super.visitAnnotationDefault();\n+        }\n+\n+        @Override\n+        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n+            super.visitAnnotableParameterCount(parameterCount, visible);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitParameterAnnotation(\n+                final int parameter, final String descriptor, final boolean visible) {\n+            return super.visitParameterAnnotation(parameter, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitCode() {\n+            super.visitCode();\n+        }\n+\n+        @Override\n+        public void visitFrame(\n+                final int type,\n+                final int numLocal,\n+                final Object[] local,\n+                final int numStack,\n+                final Object[] stack) {\n+            super.visitFrame(type, numLocal, local, numStack, stack);\n+        }\n+\n+        @Override\n+        public void visitInsn(final int opcode) {\n+            super.visitInsn(opcode);\n+        }\n+\n+        @Override\n+        public void visitIntInsn(final int opcode, final int operand) {\n+            super.visitIntInsn(opcode, operand);\n+        }\n+\n+        @Override\n+        public void visitVarInsn(final int opcode, final int var) {\n+            super.visitVarInsn(opcode, var);\n+        }\n+\n+        @Override\n+        public void visitTypeInsn(final int opcode, final String type) {\n+            super.visitTypeInsn(opcode, type);\n+        }\n+\n+        @Override\n+        public void visitFieldInsn(\n+                final int opcode, final String owner, final String name, final String descriptor) {\n+            super.visitFieldInsn(opcode, owner, name, descriptor);\n+        }\n+\n+        @Override\n+        public void visitMethodInsn(\n+                final int opcode,\n+                final String owner,\n+                final String name,\n+                final String descriptor,\n+                final boolean isInterface) {\n+            mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n+        }\n+\n+        @Override\n+        public void visitInvokeDynamicInsn(\n+                final String name,\n+                final String descriptor,\n+                final Handle bootstrapMethodHandle,\n+                final Object... bootstrapMethodArguments) {\n+            if (bootstrapMethodHandle.getOwner().equals(\"java\/lang\/invoke\/LambdaMetafactory\")\n+                    && bootstrapMethodHandle.getName().equals(\"metafactory\")) {\n+                Handle handle = (Handle) bootstrapMethodArguments[1];\n+                if (handle.getOwner().equals(IMPL_CLASSNAME) && handle.getName().equals(IMPL_METHODNAME)) {\n+                    if (handle.getTag() != Opcodes.H_INVOKESPECIAL) {\n+                        throw new RuntimeException(\"Must be REF_invokeSpecial: \" + handle);\n+                    }\n+                }\n+            }\n+            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n+        }\n+\n+        @Override\n+        public void visitJumpInsn(final int opcode, final Label label) {\n+            super.visitJumpInsn(opcode, label);\n+        }\n+\n+        @Override\n+        public void visitLabel(final Label label) {\n+            super.visitLabel(label);\n+        }\n+\n+        @Override\n+        public void visitLdcInsn(final Object value) {\n+            super.visitLdcInsn(value);\n+        }\n+\n+        @Override\n+        public void visitIincInsn(final int var, final int increment) {\n+            super.visitIincInsn(var, increment);\n+        }\n+\n+        @Override\n+        public void visitTableSwitchInsn(\n+                final int min, final int max, final Label dflt, final Label... labels) {\n+            super.visitTableSwitchInsn(min, max, dflt, labels);\n+        }\n+\n+        @Override\n+        public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n+            super.visitLookupSwitchInsn(dflt, keys, labels);\n+        }\n+\n+        @Override\n+        public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n+            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitInsnAnnotation(\n+                final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n+            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitTryCatchBlock(\n+                final Label start, final Label end, final Label handler, final String type) {\n+            super.visitTryCatchBlock(start, end, handler, type);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitTryCatchAnnotation(\n+                final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n+            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitLocalVariable(\n+                final String name,\n+                final String descriptor,\n+                final String signature,\n+                final Label start,\n+                final Label end,\n+                final int index) {\n+            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n+        }\n+\n+        @Override\n+        public AnnotationVisitor visitLocalVariableAnnotation(\n+                final int typeRef,\n+                final TypePath typePath,\n+                final Label[] start,\n+                final Label[] end,\n+                final int[] index,\n+                final String descriptor,\n+                final boolean visible) {\n+            return super.visitLocalVariableAnnotation(\n+                            typeRef, typePath, start, end, index, descriptor, visible);\n+        }\n+\n+        @Override\n+        public void visitLineNumber(final int line, final Label start) {\n+            super.visitLineNumber(line, start);\n+        }\n+\n+        @Override\n+        public void visitMaxs(final int maxStack, final int maxLocals) {\n+            super.visitMaxs(maxStack, maxLocals);\n+        }\n+\n+        @Override\n+        public void visitEnd() {\n+            super.visitEnd();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/invokeSpecial\/InvokeSpecialMethodTest.java","additions":320,"deletions":0,"binary":false,"changes":320,"status":"added"}]}