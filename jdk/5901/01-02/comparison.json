{"files":[{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.function.Supplier;\n-\n-public class InvokeSpecialMethodImpl {\n-    private static final String SUPER = \"super\";\n-    private static final String SUBCLASS = \"overridden\";\n-\n-    public static void main(String... args) {\n-        SubClass o = new SubClass();\n-        if (!o.test().equals(o.testWithLambda())) {\n-            throw new RuntimeException(\"testWithLambda returns \" + o.testWithLambda());\n-        }\n-    }\n-\n-    public String test() {\n-        return testPrivate();\n-    }\n-\n-    public String testWithLambda() {\n-        Supplier<String> supplier = this::testPrivate;\n-        return supplier.get();\n-    }\n-\n-    private String testPrivate() {\n-        return SUPER;\n-    }\n-\n-    public static class SubClass extends InvokeSpecialMethodImpl {\n-        public String testPrivate() {\n-            return SUBCLASS;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/invokeSpecial\/InvokeSpecialMethodImpl.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -27,3 +27,1 @@\n- * @modules java.base\/jdk.internal.org.objectweb.asm\n- * @library \/test\/lib\n- * @run main\/othervm InvokeSpecialMethodTest\n+ * @run main InvokeSpecialMethodTest\n@@ -34,16 +32,6 @@\n-import jdk.internal.org.objectweb.asm.AnnotationVisitor;\n-import jdk.internal.org.objectweb.asm.Attribute;\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Handle;\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.TypePath;\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.compiler.CompilerUtils;\n-\n-import java.io.InputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import static java.lang.invoke.MethodType.methodType;\n@@ -52,130 +40,2 @@\n-    private static final Path CLASSES = Path.of(\"classes\");\n-    private static final String IMPL_CLASSNAME = \"InvokeSpecialMethodImpl\";\n-    private static final String IMPL_SUBCLASS = \"InvokeSpecialMethodImpl$SubClass\";\n-    private static final String IMPL_METHODNAME = \"testPrivate\";\n-\n-    public static void main(String... args) throws Throwable {\n-        Path src = Path.of(System.getProperty(\"test.src\"));\n-\n-        \/\/ compile with --release 10 as pre-nestmate class\n-        \/\/ The implementation method handle should be REF_invokeSpecial\n-        \/\/ on InvokeSpecialMethodImpl::testPrivate\n-        CompilerUtils.compile(src.resolve(IMPL_CLASSNAME + \".java\"), CLASSES, \"--release\", \"10\");\n-\n-        \/\/ validate InvokeSpecialMethodImpl::testPrivate is executed\n-        \/\/ not the public SubClass::testPrivate method\n-        ProcessTools.executeTestJava(\"-cp\", CLASSES.toString(), IMPL_CLASSNAME)\n-                    .shouldHaveExitValue(0);\n-\n-        \/\/ test if InvokeSpecialMethodImpl::testPrivate is public or protected\n-        runTest(Opcodes.ACC_PUBLIC);\n-        runTest(Opcodes.ACC_PROTECTED);\n-    }\n-\n-    \/**\n-     * Patch InvokeSpecialMethodImpl::testPrivate to the given access.\n-     * Then run InvokeSpecialMethodImpl to ensure that REF_invokeSpecial method\n-     * handle does not invoke the overridden testPrivate method in the subclass.\n-     *\/\n-    public static void runTest(int access) throws Throwable {\n-        String dir = \"test-\" + access;\n-        Path dest = Path.of(dir);\n-        try (InputStream inputStream = Files.newInputStream(CLASSES.resolve(IMPL_CLASSNAME + \".class\"))) {\n-            ClassReader reader = new ClassReader(inputStream);\n-            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n-            ClassVisitor visitor = make(writer, access);\n-            reader.accept(visitor, ClassReader.EXPAND_FRAMES);\n-            Files.createDirectories(dest);\n-            Files.write(dest.resolve(IMPL_CLASSNAME + \".class\"), writer.toByteArray());\n-        }\n-        Files.copy(CLASSES.resolve(IMPL_SUBCLASS + \".class\"), dest.resolve(IMPL_SUBCLASS + \".class\"));\n-        ProcessTools.executeTestJava(\"-cp\", dir, IMPL_CLASSNAME)\n-                    .shouldHaveExitValue(0);\n-    }\n-\n-    \/*\n-     * Patch the testPrivate method with the given new access.\n-     *\/\n-    public static ClassVisitor make(ClassVisitor cv, int newAccess) {\n-        return new ClassVisitor(Opcodes.ASM8, cv) {\n-            public MethodVisitor visitMethod(int access, String name, String desc,\n-                                             String signature, String[] exceptions) {\n-                if (name.equals(IMPL_METHODNAME))\n-                    access = newAccess;\n-                return new CheckMethodVisitor(super.visitMethod(access, name, desc, signature, exceptions));\n-            }\n-        };\n-    }\n-\n-    \/*\n-     * A method visitor to check BSM on LambdaMetafactory.metafactroy\n-     * with REF_invokeSpecial on InvokeSpecialMethodImpl::testPrivate\n-     *\/\n-    static class CheckMethodVisitor extends MethodVisitor {\n-        final MethodVisitor mv;\n-        public CheckMethodVisitor(final MethodVisitor methodVisitor) {\n-            super(Opcodes.ASM8, methodVisitor);\n-            this.mv = methodVisitor;\n-        }\n-\n-        @Override\n-        public void visitParameter(final String name, final int access) {\n-            super.visitParameter(name, access);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotation(final String descriptor, final boolean visible) {\n-             return super.visitAnnotation(descriptor, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTypeAnnotation(\n-                final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n-            return super.visitTypeAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitAttribute(final Attribute attribute) {\n-            super.visitAttribute(attribute);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitAnnotationDefault() {\n-            return super.visitAnnotationDefault();\n-        }\n-\n-        @Override\n-        public void visitAnnotableParameterCount(int parameterCount, boolean visible) {\n-            super.visitAnnotableParameterCount(parameterCount, visible);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitParameterAnnotation(\n-                final int parameter, final String descriptor, final boolean visible) {\n-            return super.visitParameterAnnotation(parameter, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitCode() {\n-            super.visitCode();\n-        }\n-\n-        @Override\n-        public void visitFrame(\n-                final int type,\n-                final int numLocal,\n-                final Object[] local,\n-                final int numStack,\n-                final Object[] stack) {\n-            super.visitFrame(type, numLocal, local, numStack, stack);\n-        }\n-\n-        @Override\n-        public void visitInsn(final int opcode) {\n-            super.visitInsn(opcode);\n-        }\n-\n-        @Override\n-        public void visitIntInsn(final int opcode, final int operand) {\n-            super.visitIntInsn(opcode, operand);\n-        }\n+    static class Test {\n+        static final Lookup LOOKUP = MethodHandles.lookup();\n@@ -183,3 +43,2 @@\n-        @Override\n-        public void visitVarInsn(final int opcode, final int var) {\n-            super.visitVarInsn(opcode, var);\n+        public String m_public() {\n+            return \"test_public\";\n@@ -187,4 +46,2 @@\n-\n-        @Override\n-        public void visitTypeInsn(final int opcode, final String type) {\n-            super.visitTypeInsn(opcode, type);\n+        protected String m_protected() {\n+            return \"test_protected\";\n@@ -192,5 +49,2 @@\n-\n-        @Override\n-        public void visitFieldInsn(\n-                final int opcode, final String owner, final String name, final String descriptor) {\n-            super.visitFieldInsn(opcode, owner, name, descriptor);\n+        private String m_private() {\n+            return \"test_private\";\n@@ -199,24 +53,9 @@\n-        @Override\n-        public void visitMethodInsn(\n-                final int opcode,\n-                final String owner,\n-                final String name,\n-                final String descriptor,\n-                final boolean isInterface) {\n-            mv.visitMethodInsn(opcode, owner, name, descriptor, isInterface);\n-        }\n-\n-        @Override\n-        public void visitInvokeDynamicInsn(\n-                final String name,\n-                final String descriptor,\n-                final Handle bootstrapMethodHandle,\n-                final Object... bootstrapMethodArguments) {\n-            if (bootstrapMethodHandle.getOwner().equals(\"java\/lang\/invoke\/LambdaMetafactory\")\n-                    && bootstrapMethodHandle.getName().equals(\"metafactory\")) {\n-                Handle handle = (Handle) bootstrapMethodArguments[1];\n-                if (handle.getOwner().equals(IMPL_CLASSNAME) && handle.getName().equals(IMPL_METHODNAME)) {\n-                    if (handle.getTag() != Opcodes.H_INVOKESPECIAL) {\n-                        throw new RuntimeException(\"Must be REF_invokeSpecial: \" + handle);\n-                    }\n-                }\n+        public static class SubClass extends Test {\n+            public String m_public() {\n+                return \"subclass_public\";\n+            }\n+            public String m_protected() {\n+                return \"subclass_protected\";\n+            }\n+            public String m_private() {\n+                return \"subclass_private\";\n@@ -224,55 +63,0 @@\n-            super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethodHandle, bootstrapMethodArguments);\n-        }\n-\n-        @Override\n-        public void visitJumpInsn(final int opcode, final Label label) {\n-            super.visitJumpInsn(opcode, label);\n-        }\n-\n-        @Override\n-        public void visitLabel(final Label label) {\n-            super.visitLabel(label);\n-        }\n-\n-        @Override\n-        public void visitLdcInsn(final Object value) {\n-            super.visitLdcInsn(value);\n-        }\n-\n-        @Override\n-        public void visitIincInsn(final int var, final int increment) {\n-            super.visitIincInsn(var, increment);\n-        }\n-\n-        @Override\n-        public void visitTableSwitchInsn(\n-                final int min, final int max, final Label dflt, final Label... labels) {\n-            super.visitTableSwitchInsn(min, max, dflt, labels);\n-        }\n-\n-        @Override\n-        public void visitLookupSwitchInsn(final Label dflt, final int[] keys, final Label[] labels) {\n-            super.visitLookupSwitchInsn(dflt, keys, labels);\n-        }\n-\n-        @Override\n-        public void visitMultiANewArrayInsn(final String descriptor, final int numDimensions) {\n-            super.visitMultiANewArrayInsn(descriptor, numDimensions);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitInsnAnnotation(\n-                final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n-            return super.visitInsnAnnotation(typeRef, typePath, descriptor, visible);\n-        }\n-\n-        @Override\n-        public void visitTryCatchBlock(\n-                final Label start, final Label end, final Label handler, final String type) {\n-            super.visitTryCatchBlock(start, end, handler, type);\n-        }\n-\n-        @Override\n-        public AnnotationVisitor visitTryCatchAnnotation(\n-                final int typeRef, final TypePath typePath, final String descriptor, final boolean visible) {\n-            return super.visitTryCatchAnnotation(typeRef, typePath, descriptor, visible);\n@@ -281,9 +65,10 @@\n-        @Override\n-        public void visitLocalVariable(\n-                final String name,\n-                final String descriptor,\n-                final String signature,\n-                final Label start,\n-                final Label end,\n-                final int index) {\n-            super.visitLocalVariable(name, descriptor, signature, start, end, index);\n+        \/*\n+         * findSpecial with Test class as the special caller matching\n+         * the factory type `StringFactory(Test)`\n+         *\/\n+        static MethodHandle mh(String name) {\n+            try {\n+                return LOOKUP.findSpecial(Test.class, name, methodType(String.class), Test.class);\n+            } catch (NoSuchMethodException | IllegalAccessException e) {\n+                throw new RuntimeException(e);\n+            }\n@@ -291,0 +76,7 @@\n+        static final MethodHandle M_PUBLIC = mh(\"m_public\");\n+        static final MethodHandle M_PROTECTED = mh(\"m_protected\");\n+        static final MethodHandle M_PRIVATE = mh(\"m_private\");\n+    }\n+    interface StringFactory {\n+        String get();\n+    }\n@@ -292,12 +84,5 @@\n-        @Override\n-        public AnnotationVisitor visitLocalVariableAnnotation(\n-                final int typeRef,\n-                final TypePath typePath,\n-                final Label[] start,\n-                final Label[] end,\n-                final int[] index,\n-                final String descriptor,\n-                final boolean visible) {\n-            return super.visitLocalVariableAnnotation(\n-                            typeRef, typePath, start, end, index, descriptor, visible);\n-        }\n+    public static void main(String... args) throws Throwable {\n+        test(Test.M_PUBLIC, \"test_public\");\n+        test(Test.M_PROTECTED, \"test_protected\");\n+        test(Test.M_PRIVATE, \"test_private\");\n+    }\n@@ -305,4 +90,4 @@\n-        @Override\n-        public void visitLineNumber(final int line, final Label start) {\n-            super.visitLineNumber(line, start);\n-        }\n+    static void test(MethodHandle implMethod, String expected) throws Throwable {\n+        testMetafactory(implMethod, expected);\n+        testAltMetafactory(implMethod, expected);\n+    }\n@@ -310,4 +95,9 @@\n-        @Override\n-        public void visitMaxs(final int maxStack, final int maxLocals) {\n-            super.visitMaxs(maxStack, maxLocals);\n-        }\n+    static void testMetafactory(MethodHandle implMethod, String expected) throws Throwable {\n+        CallSite cs = LambdaMetafactory.metafactory(Test.LOOKUP, \"get\",\n+                                                    methodType(StringFactory.class, Test.class),\n+                                                    methodType(String.class), implMethod, methodType(String.class));\n+        Test o = new Test.SubClass();\n+        StringFactory factory = (StringFactory) cs.dynamicInvoker().invokeExact(o);\n+        String actual = factory.get();\n+        if (!expected.equals(actual)) throw new AssertionError(\"Unexpected result: \" + actual);\n+    }\n@@ -315,4 +105,9 @@\n-        @Override\n-        public void visitEnd() {\n-            super.visitEnd();\n-        }\n+    static void testAltMetafactory(MethodHandle implMethod, String expected) throws Throwable {\n+        CallSite cs = LambdaMetafactory.altMetafactory(Test.LOOKUP, \"get\",\n+                                                       methodType(StringFactory.class, Test.class),\n+                                                       methodType(String.class), implMethod, methodType(String.class),\n+                                                       LambdaMetafactory.FLAG_SERIALIZABLE);\n+        Test o = new Test.SubClass();\n+        StringFactory factory = (StringFactory) cs.dynamicInvoker().invokeExact(o);\n+        String actual = factory.get();\n+        if (!expected.equals(actual)) throw new AssertionError(\"Unexpected result: \" + actual);\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/invokeSpecial\/InvokeSpecialMethodTest.java","additions":68,"deletions":273,"binary":false,"changes":341,"status":"modified"}]}