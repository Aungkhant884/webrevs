{"files":[{"patch":"@@ -456,2 +456,3 @@\n-\/\/ create Runtime Predicates above it. They all share the same uncommon trap. The Parse Predicate will follow the\n-\/\/ Runtime Predicates. Together they form a Regular Predicate Block. There are three kinds of Parse Predicates:\n+\/\/ create Regular Predicates (Runtime Predicates with possible Assertion Predicates) above it. Together they form a\n+\/\/ Predicate Block. The Parse Predicate and Regular Predicates share the same uncommon trap.\n+\/\/ There are three kinds of Parse Predicates:\n@@ -472,0 +473,2 @@\n+  Node* uncommon_trap() const;\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -1989,0 +1990,7 @@\n+Node* ParsePredicateNode::uncommon_trap() const {\n+  ParsePredicateUncommonProj* uncommon_proj = proj_out(0)->as_IfFalse();\n+  Node* uct_region_or_call = uncommon_proj->unique_ctrl_out();\n+  assert(uct_region_or_call->is_Region() || uct_region_or_call->is_Call(), \"must be a region or call uct\");\n+  return uct_region_or_call;\n+}\n+\n@@ -2006,0 +2014,1 @@\n+\n","filename":"src\/hotspot\/share\/opto\/ifnode.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -43,4 +44,4 @@\n- * The general idea of Loop Predication is to hoist a check inside a loop body by inserting a Hoisted Predicate with an\n- * uncommon trap on the entry path to the loop. The old check inside the loop can be eliminated. If the condition of the\n- * Hoisted Predicate fails at runtime, we'll execute the uncommon trap to avoid entering the loop which misses the check.\n- * Loop Predication can currently remove array range checks and loop invariant checks (such as null checks).\n+ * The general idea of Loop Predication is to hoist a check inside a loop body by inserting a Hoisted Check Predicate with\n+ * an uncommon trap on the entry path to the loop. The old check inside the loop can be eliminated. If the condition of\n+ * the Hoisted Check Predicate fails at runtime, we'll execute the uncommon trap to avoid entering the loop which misses\n+ * the check. Loop Predication can currently remove array range checks and loop invariant checks (such as null checks).\n@@ -48,167 +49,3 @@\n- * On top of these predicates added by Loop Predication, there are other kinds of predicates. The following list provides\n- * a complete description of all predicates used in the C2 compiler:\n- *\n- *\n- * There are different kinds of predicates throughout the code. We differentiate between the following predicates:\n- *\n- * - Regular Predicate: This term is used to refer to a Parse Predicate or a Runtime Predicate and can be used to\n- *                      distinguish from any Assertion Predicate.\n- * - Parse Predicate: Added during parsing to capture the current JVM state. This predicate represents a \"placeholder\"\n- *                    above which more Runtime Predicates can be created later after parsing.\n- *\n- *                    There are initially three Parse Predicates for each loop:\n- *                    - Loop Parse Predicate:             The Parse Predicate added for Loop Predicates.\n- *                    - Profiled Loop Parse Predicate:    The Parse Predicate added for Profiled Loop Predicates.\n- *                    - Loop Limit Check Parse Predicate: The Parse Predicate added for a Loop Limit Check Predicate.\n- * - Runtime Predicate: This term is used to refer to a Hoisted Predicate (either a Loop Predicate or a Profiled Loop\n- *                      Predicate) or a Loop Limit Check Predicate. These predicates will be checked at runtime while the\n- *                      Parse and Assertion Predicates are always removed before code generation (except for Initialized\n- *                      Assertion Predicates which are kept in debug builds while being removed in product builds).\n- *     - Hoisted Predicate: Either a Loop Predicate or a Profiled Loop Predicate that was created during Loop Predication\n- *                          to hoist a check out of a loop. Each Hoisted Predicate is accompanied by additional\n- *                          Assertion Predicates.\n- *         - Loop Predicate:     A predicate that can either hoist a loop-invariant check out of a loop or a range check\n- *                               of the form \"a[i*scale + offset]\", where scale and offset are loop-invariant, out of a\n- *                               counted loop. A check must be executed in each loop iteration to hoist it. Otherwise, no\n- *                               Loop Predicate can be created. This predicate is created during Loop Predication and is\n- *                               inserted above the Loop Parse Predicate.\n- *         - Profiled Loop:      This predicate is very similar to a Loop Predicate but the hoisted check does not need\n- *           Predicate           to be executed in each loop iteration. By using profiling information, only checks with\n- *                               a high execution frequency are chosen to be replaced by a Profiled Loop Predicate. This\n- *                               predicate is created during Loop Predication and is inserted above the Profiled Loop\n- *                               Parse Predicate.\n- *     - Loop Limit Check:   This predicate is created when transforming a loop to a counted loop to protect against\n- *       Predicate           the case when adding the stride to the induction variable would cause an overflow which\n- *                           will not satisfy the loop limit exit condition. This overflow is unexpected for further\n- *                           counted loop optimizations and could lead to wrong results. Therefore, when this predicate\n- *                           fails at runtime, we must trap and recompile the method without turning the loop into a\n- *                           a counted loop to avoid these overflow problems.\n- *                           The predicate does not replace an actual check inside the loop. This predicate can only\n- *                           be added once above the Loop Limit Check Parse Predicate for a loop.\n- * - Assertion Predicate: An always true predicate which will never fail (its range is already covered by an earlier\n- *                        Hoisted Predicate or the main-loop entry guard) but is required in order to fold away a dead\n- *                        sub loop inside which some data could be proven to be dead (by the type system) and replaced\n- *                        by top. Without such Assertion Predicates, we could find that type ranges in Cast and ConvX2Y\n- *                        data nodes become impossible and are replaced by top. This is an indicator that the sub loop\n- *                        is never executed and must be dead. But there is no way for C2 to prove that the sub loop is\n- *                        actually dead. Assertion Predicates come to the rescue to fold such seemingly dead sub loops\n- *                        away to avoid a broken graph. Assertion Predicates are left in the graph as a sanity checks in\n- *                        debug builds (they must never fail at runtime) while they are being removed in product builds.\n- *                        We use special Opaque4 nodes to block some optimizations and replace the Assertion Predicates\n- *                        later in product builds.\n- *\n- *                        There are two kinds of Assertion Predicates:\n- *                        - Template Assertion Predicate:    A template for an Assertion Predicate that uses OpaqueLoop*\n- *                                                           nodes as placeholders for the init and stride value of a loop.\n- *                                                           This predicate does not represent an actual check, yet, and\n- *                                                           just serves as a template to create an Initialized Assertion\n- *                                                           Predicate for a (sub) loop.\n- *                        - Initialized Assertion Predicate: An Assertion Predicate that represents an actual check for a\n- *                                                           (sub) loop that was initialized by cloning a Template\n- *                                                           Assertion Predicate. The check is always true and is covered\n- *                                                           by an earlier check (a Hoisted Predicate or the main-loop\n- *                                                           entry guard).\n- *\n- *                        Assertion Predicates are required when removing a range check from a loop. These are inserted\n- *                        either at Loop Predication or at Range Check Elimination:\n- *                        - Loop Predication:        A range check inside a loop is replaced by a Hoisted Predicate before\n- *                                                   the loop. We add two additional Template Assertion Predicates from\n- *                                                   which we can later create Initialized Assertion Predicates. One\n- *                                                   would have been enough if the number of array accesses inside a sub\n- *                                                   loop does not change. But when unrolling the sub loop, we are\n- *                                                   doubling the number of array accesses - we need to cover them all.\n- *                                                   To do that, we only need to create an Initialized Assertion Predicate\n- *                                                   for the first, initial value and for the last value:\n- *                                                   Let a[i] be an array access in the original, not-yet unrolled loop\n- *                                                   with stride 1. When unrolling this loop, we double the stride\n- *                                                   (i.e. stride 2) and have now two accesses a[i] and a[i+1]. We need\n- *                                                   checks for both. When further unrolling this loop, we only need to\n- *                                                   keep the checks on the first and last access (e.g. a[i] and a[i+3]\n- *                                                   on the next unrolling step as they cover the checks in the middle\n- *                                                   for a[i+1] and a[i+2]).\n- *                                                   Therefore, we just need to cover:\n- *                                                   - Initial value: a[init]\n- *                                                   - Last value: a[init + new stride - original stride]\n- *                                                   (We could still only use one Template Assertion Predicate to create\n- *                                                   both Initialized Assertion Predicates from - might be worth doing\n- *                                                   at some point).\n- *                                                   When later splitting a loop (pre\/main\/post, peeling, unrolling),\n- *                                                   we create two Initialized Assertion Predicates from the Template\n- *                                                   Assertion Predicates by replacing the OpaqueLoop* nodes by actual\n- *                                                   values. Initially (before unrolling), both Assertion Predicates are\n- *                                                   equal. The Initialized Assertion Predicates are always true because\n- *                                                   their range is covered by a corresponding Hoisted Predicate.\n- *                        - Range Check Elimination: A range check is removed from the main-loop by changing the pre\n- *                                                   and main-loop iterations. We add two additional Template Assertion\n- *                                                   Predicates (see explanation in section above) and one Initialized\n- *                                                   Assertion Predicate for the just removed range check. When later\n- *                                                   unrolling the main-loop, we create two Initialized Assertion\n- *                                                   Predicates from the Template Assertion Predicates by replacing the\n- *                                                   OpaqueLoop* nodes by actual values for the unrolled loop.\n- *                                                   The Initialized Assertion Predicates are always true: They are true\n- *                                                   when entering the main-loop (because we adjusted the pre-loop exit\n- *                                                   condition), when executing the last iteration of the main-loop\n- *                                                   (because we adjusted the main-loop exit condition), and during all\n- *                                                   other iterations of the main-loop in-between by implication.\n- *                                                   Note that Range Check Elimination could remove additional range\n- *                                                   checks which we were not possible to remove with Loop Predication\n- *                                                   before (for example, because no Parse Predicates were available\n- *                                                   before the loop to create Hoisted Predicates with).\n- *\n- *\n- * In order to group predicates and refer to them throughout the code, we introduce the following additional terms:\n- * - Regular Predicate Block: A Regular Predicate Block groups all Runtime Predicates in a Runtime Predicate Block\n- *                            together with their dedicated Parse Predicate from which they were created (all predicates\n- *                            share the same uncommon trap). The Runtime Predicate Block could be empty (i.e. no\n- *                            Runtime Predicates created) and the Parse Predicate could be missing (after removing Parse\n- *                            Predicates). There are three such Regular Predicate Blocks:\n- *                            - Loop Predicate Block\n- *                            - Profiled Loop Predicate Block\n- *                            - Loop Limit Check Predicate Block\n- * - Runtime Predicate Block: A block containing all Runtime Predicates that share the same uncommon trap (i.e. belonging\n- *                            to a single Parse Predicate which is not included in this block). This block could be empty\n- *                            if there were no Runtime Predicates created with the Parse Predicate below this block.\n- *                            For the time being: We also count Assertion Predicates to this block but that will be\n- *                            changed with the redesign of Assertion Predicates where we remove them from this block\n- *                            (JDK-8288981).\n- *\n- * Initially, before applying any loop-splitting optimizations, we find the following structure after Loop Predication\n- * (predicates inside square brackets [] do not need to exist if there are no checks to hoist):\n- *\n- *   [Loop Hoisted Predicate 1 + two Template Assertion Predicates]                 \\ Runtime       \\\n- *   [Loop Hoisted Predicate 2 + two Template Assertion Predicates]                 | Predicate     |\n- *   ...                                                                            | Block         | Loop Predicate Block\n- *   [Loop Hoisted Predicate n + two Template Assertion Predicates]                 \/               |\n- * Loop Parse Predicate                                                                             \/\n- *\n- *   [Profiled Loop Hoisted Predicate 1 + two Template Assertion Predicates]       \\ Runtime       \\\n- *   [Profiled Loop Hoisted Predicate 2 + two Template Assertion Predicates]       | Predicate     | Profiled Loop\n- *   ...                                                                           | Block         | Predicate Block\n- *   [Profiled Loop Hoisted Predicate m + two Template Assertion Predicates]       \/               |\n- * Profiled Loop Parse Predicate                                                                   \/\n- *                                                                                 \\ Runtime\n- *   [Loop Limit Check Predicate] (at most one)                                    \/ Predicate     \\ Loop Limit Check\n- * Loop Limit Check Parse Predicate                                                  Block         \/ Predicate Block\n- * Loop Head\n- *\n- * As an example, let's look at how the predicate structure looks for the main-loop after creating pre\/main\/post loops\n- * and applying Range Check Elimination (the order is insignificant):\n- *\n- * Main Loop entry (zero-trip) guard\n- *   [For Loop Predicate 1: Two Template + two Initialized Assertion Predicates]\n- *   [For Loop Predicate 2: Two Template + two Initialized Assertion Predicates]\n- *   ...\n- *   [For Loop Predicate n: Two Template + two Initialized Assertion Predicates]\n- *\n- *   [For Profiled Loop Predicate 1: Two Template + two Initialized Assertion Predicates]\n- *   [For Profiled Loop Predicate 2: Two Template + two Initialized Assertion Predicates]\n- *   ...\n- *   [For Profiled Loop Predicate m: Two Template + two Initialized Assertion Predicates]\n- *\n- *   (after unrolling, we have two Initialized Assertion Predicates for the Assertion Predicates of Range Check Elimination)\n- *   [For Range Check Elimination Check 1: Two Templates + one Initialized Assertion Predicate]\n- *   [For Range Check Elimination Check 2: Two Templates + one Initialized Assertion Predicate]\n- *   ...\n- *   [For Range Check Elimination Check k: Two Templates + one Initialized Assertion Predicate]\n- * Main Loop Head\n- *\/\n+ * On top of these predicates added by Loop Predication, there are other kinds of predicates. A detailed description\n+ * about all predicates can be found in predicates.hpp.\n+*\/\n@@ -267,2 +104,1 @@\n-                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs,\n-                                                        const bool if_cont_is_true_proj) {\n+                                                        const int opcode, const bool rewire_uncommon_proj_phi_inputs) {\n@@ -324,9 +160,2 @@\n-  IfProjNode* if_cont;\n-  IfProjNode* if_uct;\n-  if (if_cont_is_true_proj) {\n-    if_cont = new IfTrueNode(new_iff);\n-    if_uct  = new IfFalseNode(new_iff);\n-  } else {\n-    if_uct  = new IfTrueNode(new_iff);\n-    if_cont = new IfFalseNode(new_iff);\n-  }\n+  IfProjNode* if_cont = new IfTrueNode(new_iff);\n+  IfProjNode* if_uct  = new IfFalseNode(new_iff);\n@@ -584,2 +413,1 @@\n-  IfProjNode* if_proj = create_new_if_for_predicate(output_proj, nullptr, reason, iff->Opcode(),\n-                                               false, predicate->is_IfTrue());\n+  IfProjNode* if_proj = create_new_if_for_predicate(output_proj, nullptr, reason, iff->Opcode(), false);\n@@ -592,1 +420,2 @@\n-\/\/ Clone Parse Predicates to cloned loops when unswitching a loop.\n+\/\/ Clone the old Parse Predicates and Assertion Predicates before the unswitch If to the unswitched loops after the\n+\/\/ unswitch If.\n@@ -598,7 +427,5 @@\n-  ParsePredicates parse_predicates(entry);\n-  ParsePredicateSuccessProj* loop_predicate_proj = parse_predicates.loop_predicate_proj();\n-  if (loop_predicate_proj != nullptr) {\n-    \/\/ Clone Parse Predicate and Template Assertion Predicates of the Loop Predicate Block.\n-    iffast_pred = clone_parse_predicate_to_unswitched_loop(loop_predicate_proj, iffast_pred,\n-                                                           Deoptimization::Reason_predicate, false);\n-    check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n+  const Predicates predicates(entry);\n+  clone_loop_predication_predicates_to_unswitched_loop(loop, old_new, predicates.loop_predicate_block(),\n+                                                       Deoptimization::Reason_predicate, iffast_pred, ifslow_pred);\n+  clone_loop_predication_predicates_to_unswitched_loop(loop, old_new, predicates.profiled_loop_predicate_block(),\n+                                                       Deoptimization::Reason_profile_predicate, iffast_pred, ifslow_pred);\n@@ -606,6 +433,6 @@\n-    ifslow_pred = clone_parse_predicate_to_unswitched_loop(loop_predicate_proj, ifslow_pred,\n-                                                           Deoptimization::Reason_predicate, true);\n-    check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n-\n-    clone_assertion_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_predicate, loop_predicate_proj,\n-                                                  iffast_pred, ifslow_pred);\n+  const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+  if (loop_limit_check_predicate_block->has_parse_predicate() && !head->is_CountedLoop()) {\n+    \/\/ Don't clone the Loop Limit Check Parse Predicate if we already have a counted loop (a Loop Limit Check Predicate\n+    \/\/ is only created when converting a LoopNode to a CountedLoopNode).\n+    clone_parse_predicate_to_unswitched_loops(loop_limit_check_predicate_block, Deoptimization::Reason_loop_limit_check,\n+                                              iffast_pred, ifslow_pred);\n@@ -613,0 +440,1 @@\n+}\n@@ -614,13 +442,8 @@\n-  ParsePredicateSuccessProj* profiled_loop_predicate_proj = parse_predicates.profiled_loop_predicate_proj();\n-  if (profiled_loop_predicate_proj != nullptr) {\n-    \/\/ Clone Parse Predicate and Template Assertion Predicates of the Profiled Loop Predicate Block.\n-    iffast_pred = clone_parse_predicate_to_unswitched_loop(profiled_loop_predicate_proj, iffast_pred,\n-                                                           Deoptimization::Reason_profile_predicate, false);\n-    check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n-\n-    ifslow_pred = clone_parse_predicate_to_unswitched_loop(profiled_loop_predicate_proj, ifslow_pred,\n-                                                           Deoptimization::Reason_profile_predicate, true);\n-    check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n-\n-    clone_assertion_predicates_to_unswitched_loop(loop, old_new, Deoptimization::Reason_profile_predicate,\n-                                                  profiled_loop_predicate_proj, iffast_pred, ifslow_pred);\n+\/\/ Clone the Parse Predicate and Template Assertion Predicates of a Loop Predication related Predicate Block.\n+void PhaseIdealLoop::clone_loop_predication_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n+                                                                          const PredicateBlock* predicate_block,\n+                                                                          Deoptimization::DeoptReason reason,\n+                                                                          IfProjNode*& iffast_pred,\n+                                                                          IfProjNode*& ifslow_pred) {\n+  if (predicate_block->is_non_empty()) {\n+    clone_parse_predicate_to_unswitched_loops(predicate_block, reason, iffast_pred, ifslow_pred);\n@@ -628,0 +451,2 @@\n+    clone_assertion_predicates_to_unswitched_loop(loop, old_new, reason, predicate_block->parse_predicate_success_proj(),\n+                                                  iffast_pred, ifslow_pred);\n@@ -629,0 +454,1 @@\n+}\n@@ -630,7 +456,6 @@\n-  ParsePredicateSuccessProj* loop_limit_check_predicate_proj = parse_predicates.loop_limit_check_predicate_proj();\n-  if (loop_limit_check_predicate_proj != nullptr && !head->is_CountedLoop()) {\n-    \/\/ Don't clone the Loop Limit Check Parse Predicate if we already have a counted loop (a Loop Limit Check Predicate\n-    \/\/ is only created when converting a LoopNode to a CountedLoopNode).\n-    iffast_pred = clone_parse_predicate_to_unswitched_loop(loop_limit_check_predicate_proj, iffast_pred,\n-                                                           Deoptimization::Reason_loop_limit_check, false);\n-    check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n+void PhaseIdealLoop::clone_parse_predicate_to_unswitched_loops(const PredicateBlock* predicate_block,\n+                                                               Deoptimization::DeoptReason reason,\n+                                                               IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred) {\n+  ParsePredicateSuccessProj* parse_predicate_proj = predicate_block->parse_predicate_success_proj();\n+  iffast_pred = clone_parse_predicate_to_unswitched_loop(parse_predicate_proj, iffast_pred, reason, false);\n+  check_cloned_parse_predicate_for_unswitching(iffast_pred, true);\n@@ -638,4 +463,2 @@\n-    ifslow_pred = clone_parse_predicate_to_unswitched_loop(loop_limit_check_predicate_proj, ifslow_pred,\n-                                                           Deoptimization::Reason_loop_limit_check, true);\n-    check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n-  }\n+  ifslow_pred = clone_parse_predicate_to_unswitched_loop(parse_predicate_proj, ifslow_pred, reason, true);\n+  check_cloned_parse_predicate_for_unswitching(ifslow_pred, false);\n@@ -864,3 +687,3 @@\n-    \/\/ If we create a Hoisted Range Check Predicate for this wrong pattern, it could succeed at runtime (i.e. true\n-    \/\/ for the value of \"scale*iv + offset\" in the first loop iteration and true for the value of \"scale*iv + offset\"\n-    \/\/ in the last loop iteration) while the check to be hoisted could fail in other loop iterations.\n+    \/\/ If we create a Range Check Predicate for this wrong pattern, it could succeed at runtime (i.e. true for the\n+    \/\/ value of \"scale*iv + offset\" in the first loop iteration and true for the value of \"scale*iv + offset\" in the\n+    \/\/ last loop iteration) while the check to be hoisted could fail in other loop iterations.\n@@ -874,1 +697,1 @@\n-    \/\/ Hoisted Range Check Predicate is always true:\n+    \/\/ Range Check Predicate is always true:\n@@ -1111,1 +934,1 @@\n-bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree* loop, IfProjNode* predicate_proj, float& loop_trip_cnt) {\n+bool PhaseIdealLoop::loop_predication_should_follow_branches(IdealLoopTree* loop, float& loop_trip_cnt) {\n@@ -1116,4 +939,0 @@\n-  if (predicate_proj == nullptr) {\n-    return false;\n-  }\n-\n@@ -1485,3 +1304,3 @@\n-\/\/ Each newly created Hoisted Predicate is accompanied by two Template Assertion Predicates. Later, we initialize them\n-\/\/ by making a copy of them when splitting a loop into sub loops. The Assertion Predicates ensure that dead sub loops\n-\/\/ are removed properly.\n+\/\/ Each newly created Hoisted Check Predicate is accompanied by two Template Assertion Predicates. Later, we initialize\n+\/\/ them by making a copy of them when splitting a loop into sub loops. The Assertion Predicates ensure that dead sub\n+\/\/ loops are removed properly.\n@@ -1532,1 +1351,2 @@\n-\/\/ Insert Hoisted Predicates for null checks and range checks and additional Template Assertion Predicates for range checks.\n+\/\/ Insert Hoisted Check Predicates for null checks and range checks and additional Template Assertion Predicates for\n+\/\/ range checks.\n@@ -1563,20 +1383,3 @@\n-  ParsePredicates parse_predicates(entry);\n-\n-  bool can_create_loop_predicates = true;\n-  \/\/ We cannot add Loop Predicates if:\n-  \/\/ - Already added Profiled Loop Predicates (Loop Predicates and Profiled Loop Predicates can be dependent\n-  \/\/   through a data node, and thus we should only add new Profiled Loop Predicates which are below Loop Predicates\n-  \/\/   in the graph).\n-  \/\/ - There are currently no Profiled Loop Predicates, but we have a data node with a control dependency on the Loop\n-  \/\/   Parse Predicate (could happen, for example, if we've removed an earlier created Profiled Loop Predicate with\n-  \/\/   dominated_by()). We should not create a Loop Predicate for a check that is dependent on this data node because\n-  \/\/   the Loop Predicate would end up above the data node with its dependency on the Loop Parse Predicate below. This\n-  \/\/   would become unschedulable. However, we can still hoist the check as Profiled Loop Predicate which would end up\n-  \/\/   below the Loop Parse Predicate.\n-  if (Predicates::has_profiled_loop_predicates(parse_predicates)\n-      || (parse_predicates.loop_predicate_proj() != nullptr && parse_predicates.loop_predicate_proj()->outcnt() != 1)) {\n-    can_create_loop_predicates = false;\n-  }\n-  ParsePredicateSuccessProj* loop_predicate_proj = parse_predicates.loop_predicate_proj();\n-  ParsePredicateSuccessProj* profiled_loop_predicate_proj = parse_predicates.profiled_loop_predicate_proj();\n-\n+  const Predicates predicates(entry);\n+  const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n+  const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n@@ -1584,1 +1387,2 @@\n-  bool follow_branches = loop_predication_should_follow_branches(loop, profiled_loop_predicate_proj, loop_trip_cnt);\n+  bool follow_branches = profiled_loop_predicate_block->has_parse_predicate() &&\n+                         loop_predication_should_follow_branches(loop, loop_trip_cnt);\n@@ -1587,1 +1391,1 @@\n-  if (loop_predicate_proj == nullptr && !follow_branches) {\n+  if (!loop_predicate_block->has_parse_predicate() && !follow_branches) {\n@@ -1590,1 +1394,1 @@\n-      tty->print(\"missing predicate:\");\n+      tty->print(\"Missing Parse Predicates:\");\n@@ -1628,1 +1432,1 @@\n-  if (can_create_loop_predicates) {\n+  if (can_create_loop_predicates(profiled_loop_predicate_block)) {\n@@ -1657,2 +1461,3 @@\n-      if (loop_predicate_proj != nullptr) {\n-        hoisted = loop_predication_impl_helper(loop, if_proj, loop_predicate_proj, cl, zero, invar,\n+      if (loop_predicate_block->has_parse_predicate()) {\n+        ParsePredicateSuccessProj* loop_parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n+        hoisted = loop_predication_impl_helper(loop, if_proj, loop_parse_predicate_proj, cl, zero, invar,\n@@ -1665,1 +1470,1 @@\n-    assert(profiled_loop_predicate_proj != nullptr, \"sanity check\");\n+    assert(profiled_loop_predicate_block->has_parse_predicate(), \"sanity check\");\n@@ -1668,2 +1473,1 @@\n-    \/\/ Some projections were skipped by regular predicates because of\n-    \/\/ an early loop exit. Try them with profile data.\n+    \/\/ Some projections were skipped due to an early loop exit. Try them with profile data.\n@@ -1675,2 +1479,4 @@\n-        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profiled_loop_predicate_proj, cl, zero, invar,\n-                                               Deoptimization::Reason_profile_predicate) | hoisted;\n+        ParsePredicateSuccessProj* profiled_loop_parse_predicate_proj =\n+            profiled_loop_predicate_block->parse_predicate_success_proj();\n+        hoisted = loop_predication_impl_helper(loop, if_proj->as_IfProj(), profiled_loop_parse_predicate_proj,\n+                                               cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n@@ -1691,1 +1497,4 @@\n-      hoisted = loop_predication_impl_helper(loop, if_proj, profiled_loop_predicate_proj, cl, zero, invar, Deoptimization::Reason_profile_predicate) | hoisted;\n+      ParsePredicateSuccessProj* profiled_loop_parse_predicate_proj =\n+          profiled_loop_predicate_block->parse_predicate_success_proj();\n+      hoisted = loop_predication_impl_helper(loop, if_proj, profiled_loop_parse_predicate_proj, cl, zero,\n+                                             invar, Deoptimization::Reason_profile_predicate) | hoisted;\n@@ -1709,0 +1518,21 @@\n+\/\/ We cannot add Loop Predicates if:\n+\/\/ (1) Already added Profiled Loop Predicates (Loop Predicates and Profiled Loop Predicates can be dependent\n+\/\/     through a data node, and thus we should only add new Profiled Loop Predicates which are below Loop Predicates\n+\/\/     in the graph).\n+\/\/ (2) There are currently no Profiled Loop Predicates, but we have a data node with a control dependency on the Loop\n+\/\/     Parse Predicate (could happen, for example, if we've removed an earlier created Profiled Loop Predicate with\n+\/\/     dominated_by()). We should not create a Loop Predicate for a check that is dependent on this data node because\n+\/\/     the Loop Predicate would end up above the data node with its dependency on the Loop Parse Predicate below. This\n+\/\/     would become unschedulable. However, we can still hoist the check as Profiled Loop Predicate which would end up\n+\/\/     below the Loop Parse Predicate.\n+bool PhaseIdealLoop::can_create_loop_predicates(const PredicateBlock* profiled_loop_predicate_block) const {\n+  bool has_profiled_loop_predicate_block = profiled_loop_predicate_block != nullptr;\n+  bool can_create_loop_predicates = true;\n+  if (has_profiled_loop_predicate_block\n+      && (profiled_loop_predicate_block->has_runtime_predicates() \/\/ (1)\n+          || profiled_loop_predicate_block->entry()->outcnt() != 1)) { \/\/ (2)\n+    can_create_loop_predicates = false;\n+  }\n+  return can_create_loop_predicates;\n+}\n+\n@@ -1729,143 +1559,0 @@\n-\n-\/\/ Skip over all predicates (all Regular Predicate Blocks) starting at the Parse Predicate projection 'node'. Return the\n-\/\/ first node that is not a predicate If node anymore (i.e. entry into the first predicate If on top) or 'node' if 'node'\n-\/\/ is not a Parse Predicate projection.\n-Node* Predicates::skip_all_predicates(Node* node) {\n-  ParsePredicates parse_predicates(node);\n-  if (parse_predicates.has_any()) {\n-    return skip_all_predicates(parse_predicates);\n-  } else {\n-    return node;\n-  }\n-}\n-\n-\/\/ Skip over all Runtime Predicates belonging to the given Parse Predicates. Return the first node that is not a predicate\n-\/\/ If node anymore (i.e. entry into the first predicate If on top).\n-Node* Predicates::skip_all_predicates(ParsePredicates& parse_predicates) {\n-  assert(parse_predicates.has_any(), \"must have at least one Parse Predicate\");\n-  return skip_predicates_in_block(parse_predicates.get_top_predicate_proj());\n-}\n-\n-\/\/ Skip over all predicates in a Regular Predicate Block starting at the Parse Predicate projection\n-\/\/ 'parse_predicate_success_proj'. Return the first node not belonging this block anymore (i.e. entry\n-\/\/ into this Regular Predicate Block).\n-Node* Predicates::skip_predicates_in_block(ParsePredicateSuccessProj* parse_predicate_success_proj) {\n-  IfProjNode* prev;\n-  IfProjNode* next = parse_predicate_success_proj;\n-  do {\n-    prev = next;\n-    next = next_predicate_proj_in_block(next);\n-  } while (next != nullptr);\n-  assert(prev->in(0)->is_If(), \"must be predicate If\");\n-  return prev->in(0)->in(0);\n-}\n-\n-\/\/ Find next Runtime Predicate projection in a Regular Predicate Block or return null if there is none.\n-IfProjNode* Predicates::next_predicate_proj_in_block(IfProjNode* proj) {\n-  IfNode* iff = proj->in(0)->as_If();\n-  ProjNode* uncommon_proj = iff->proj_out(1 - proj->_con);\n-  Node* rgn = uncommon_proj->unique_ctrl_out();\n-  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n-  Node* next = iff->in(0);\n-  if (next != nullptr && next->is_Proj() && next->in(0)->is_If()) {\n-    uncommon_proj = next->in(0)->as_If()->proj_out(1 - next->as_Proj()->_con);\n-    if (uncommon_proj->unique_ctrl_out() == rgn) {\n-      \/\/ Same Runtime Predicate Block.\n-      return next->as_IfProj();\n-    }\n-  }\n-  return nullptr;\n-}\n-\n-\/\/ Is there at least one Profiled Loop Predicate?\n-bool Predicates::has_profiled_loop_predicates(ParsePredicates& parse_predicates) {\n-  ParsePredicateSuccessProj* profiled_loop_predicate = parse_predicates.profiled_loop_predicate_proj();\n-  if (profiled_loop_predicate == nullptr) {\n-    return false;\n-  }\n-  return Predicates::next_predicate_proj_in_block(profiled_loop_predicate) != nullptr;\n-}\n-\n-\/\/ Given a node 'starting_proj', check if it is a Parse Predicate success projection.\n-\/\/ If so, find all Parse Predicates above the loop.\n-ParsePredicates::ParsePredicates(Node* starting_proj) : _top_predicate_proj(nullptr), _starting_proj(nullptr) {\n-  if (starting_proj == nullptr || !starting_proj->is_IfTrue()) {\n-    return; \/\/ Not a predicate.\n-  }\n-  _starting_proj = starting_proj->as_IfTrue();\n-  find_parse_predicate_projections();\n-}\n-\n-void ParsePredicates::find_parse_predicate_projections() {\n-  Node* maybe_parse_predicate_proj = _starting_proj;\n-  for (int i = 0; i < 3; i++) { \/\/ At most 3 Parse Predicates for a loop\n-    if (!is_success_proj(maybe_parse_predicate_proj)) {\n-      break;\n-    }\n-    ParsePredicateSuccessProj* parse_predicate_proj = maybe_parse_predicate_proj->as_IfTrue();\n-    if (!assign_predicate_proj(parse_predicate_proj)) {\n-      \/\/ Found a Parse Predicate of another (already removed) loop.\n-      break;\n-    }\n-    _top_predicate_proj = parse_predicate_proj;\n-    maybe_parse_predicate_proj = Predicates::skip_predicates_in_block(parse_predicate_proj);\n-  }\n-}\n-\n-\/\/ Is 'node' a success (non-UCT) projection of a Parse Predicate?\n-bool ParsePredicates::is_success_proj(Node* node) {\n-  if (node == nullptr || !node->is_Proj()) {\n-    return false;\n-  }\n-  ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(node);\n-  if (parse_predicate == nullptr) {\n-    return false;\n-  }\n-  return !is_uct_proj(node, parse_predicate->deopt_reason());\n-}\n-\n-\/\/ Is 'node' a UCT projection of a Parse Predicate of kind 'kind'?\n-bool ParsePredicates::is_uct_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n-  return node->as_Proj()->is_uncommon_trap_proj(deopt_reason);\n-}\n-\n-\/\/ Check the parent of `parse_predicate_proj` is a ParsePredicateNode. If so return it. Otherwise, return null.\n-ParsePredicateNode* ParsePredicates::get_parse_predicate_or_null(Node* parse_predicate_proj) {\n-  return parse_predicate_proj->in(0)->isa_ParsePredicate();\n-}\n-\n-\/\/ Initialize the Parse Predicate projection field that matches the kind of the parent of `parse_predicate_proj`.\n-\/\/ Only initialize if Parse Predicate projection itself or any of the Parse Predicate projections coming further up\n-\/\/ in the graph are not already initialized (this would be a sign of repeated Parse Predicates which are not cleaned up,\n-\/\/ yet).\n-bool ParsePredicates::assign_predicate_proj(ParsePredicateSuccessProj* parse_predicate_proj) {\n-  ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(parse_predicate_proj);\n-  assert(parse_predicate != nullptr, \"must exist\");\n-  Deoptimization::DeoptReason deopt_reason = parse_predicate->deopt_reason();\n-  switch (deopt_reason) {\n-    case Deoptimization::DeoptReason::Reason_predicate:\n-      if (_loop_predicate_proj != nullptr) {\n-        return false;\n-      }\n-      _loop_predicate_proj = parse_predicate_proj;\n-      break;\n-    case Deoptimization::DeoptReason::Reason_profile_predicate:\n-      if (_profiled_loop_predicate_proj != nullptr ||\n-          _loop_predicate_proj != nullptr) {\n-        return false;\n-      }\n-      _profiled_loop_predicate_proj = parse_predicate_proj;\n-      break;\n-    case Deoptimization::DeoptReason::Reason_loop_limit_check:\n-      if (_loop_limit_check_predicate_proj != nullptr ||\n-          _loop_predicate_proj != nullptr ||\n-          _profiled_loop_predicate_proj != nullptr) {\n-        return false;\n-      }\n-      _loop_limit_check_predicate_proj = parse_predicate_proj;\n-      break;\n-    default:\n-      fatal(\"invalid case\");\n-  }\n-  return true;\n-}\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":97,"deletions":410,"binary":false,"changes":507,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -781,2 +782,2 @@\n-    ParsePredicates parse_predicates(new_head->in(LoopNode::EntryControl));\n-    initialize_assertion_predicates_for_peeled_loop(parse_predicates.loop_predicate_proj(),\n+    const Predicates predicates(new_head->in(LoopNode::EntryControl));\n+    initialize_assertion_predicates_for_peeled_loop(predicates.loop_predicate_block(),\n@@ -786,1 +787,1 @@\n-    initialize_assertion_predicates_for_peeled_loop(parse_predicates.profiled_loop_predicate_proj(),\n+    initialize_assertion_predicates_for_peeled_loop(predicates.profiled_loop_predicate_block(),\n@@ -1310,3 +1311,4 @@\n-void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride,\n-                                                                   IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n-                                                                   const uint dd_main_head, const uint idx_before_pre_post,\n+void PhaseIdealLoop::copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init,\n+                                                                   Node* stride, IdealLoopTree* outer_loop,\n+                                                                   LoopNode* outer_main_head, const uint dd_main_head,\n+                                                                   const uint idx_before_pre_post,\n@@ -1317,1 +1319,1 @@\n-  if (predicate != nullptr) {\n+  if (predicate_block->has_parse_predicate()) {\n@@ -1322,2 +1324,3 @@\n-    IfNode* iff = predicate->in(0)->as_If();\n-    ProjNode* uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+    Node* predicate_proj = predicate_block->parse_predicate_success_proj();\n+    IfNode* iff = predicate_proj->in(0)->as_If();\n+    ProjNode* uncommon_proj = iff->proj_out(1 - predicate_proj->as_Proj()->_con);\n@@ -1326,2 +1329,1 @@\n-    assert(iff->in(1)->in(1)->Opcode() == Op_Opaque1, \"unexpected predicate shape\");\n-    predicate = iff->in(0);\n+    predicate_proj = iff->in(0);\n@@ -1335,3 +1337,3 @@\n-    while (predicate != nullptr && predicate->is_Proj() && predicate->in(0)->is_If()) {\n-      iff = predicate->in(0)->as_If();\n-      uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n+    while (predicate_proj != nullptr && predicate_proj->is_Proj() && predicate_proj->in(0)->is_If()) {\n+      iff = predicate_proj->in(0)->as_If();\n+      uncommon_proj = iff->proj_out(1 - predicate_proj->as_Proj()->_con);\n@@ -1345,1 +1347,1 @@\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, opaque_init, nullptr, predicate, uncommon_proj,\n+        prev_proj = clone_assertion_predicate_and_initialize(iff, opaque_init, nullptr, predicate_proj, uncommon_proj,\n@@ -1349,1 +1351,1 @@\n-        prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate, uncommon_proj,\n+        prev_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate_proj, uncommon_proj,\n@@ -1355,2 +1357,2 @@\n-        for (DUIterator i = predicate->outs(); predicate->has_out(i); i++) {\n-          Node* loop_node = predicate->out(i);\n+        for (DUIterator i = predicate_proj->outs(); predicate_proj->has_out(i); i++) {\n+          Node* loop_node = predicate_proj->out(i);\n@@ -1378,1 +1380,1 @@\n-      predicate = predicate->in(0)->in(0);\n+      predicate_proj = predicate_proj->in(0)->in(0);\n@@ -1594,2 +1596,2 @@\n-    ParsePredicates parse_predicates(entry);\n-    copy_assertion_predicates_to_main_loop_helper(parse_predicates.loop_predicate_proj(), init, stride, outer_loop,\n+    const Predicates predicates(entry);\n+    copy_assertion_predicates_to_main_loop_helper(predicates.loop_predicate_block(), init, stride, outer_loop,\n@@ -1599,1 +1601,1 @@\n-    copy_assertion_predicates_to_main_loop_helper(parse_predicates.profiled_loop_predicate_proj(), init, stride,\n+    copy_assertion_predicates_to_main_loop_helper(predicates.profiled_loop_predicate_block(), init, stride,\n@@ -2117,1 +2119,2 @@\n-void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(IfProjNode* predicate_proj, LoopNode* outer_loop_head,\n+void PhaseIdealLoop::initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block,\n+                                                                     LoopNode* outer_loop_head,\n@@ -2122,1 +2125,1 @@\n-  if (predicate_proj == nullptr) {\n+  if (!predicate_block->has_runtime_predicates()) {\n@@ -2128,3 +2131,3 @@\n-  predicate_proj = Predicates::next_predicate_proj_in_block(predicate_proj);\n-  while (predicate_proj != nullptr) {\n-    IfNode* iff = predicate_proj->in(0)->as_If();\n+  Node* next_regular_predicate_proj = predicate_block->skip_parse_predicate();\n+  while (next_regular_predicate_proj->is_IfProj()) {\n+    IfNode* iff = next_regular_predicate_proj->in(0)->as_If();\n@@ -2133,2 +2136,2 @@\n-      ProjNode* uncommon_proj = iff->proj_out(1 - predicate_proj->as_Proj()->_con);\n-      input_proj = clone_assertion_predicate_and_initialize(iff, init, stride, predicate_proj, uncommon_proj, control,\n+      ProjNode* uncommon_proj = iff->proj_out(1 - next_regular_predicate_proj->as_Proj()->_con);\n+      input_proj = clone_assertion_predicate_and_initialize(iff, init, stride, next_regular_predicate_proj, uncommon_proj, control,\n@@ -2139,2 +2142,2 @@\n-      for (DUIterator i = predicate_proj->outs(); predicate_proj->has_out(i); i++) {\n-        Node* dependent = predicate_proj->out(i);\n+      for (DUIterator i = next_regular_predicate_proj->outs(); next_regular_predicate_proj->has_out(i); i++) {\n+        Node* dependent = next_regular_predicate_proj->out(i);\n@@ -2154,1 +2157,1 @@\n-    predicate_proj = Predicates::next_predicate_proj_in_block(predicate_proj);\n+    next_regular_predicate_proj = iff->in(0);\n@@ -2911,1 +2914,1 @@\n-  Node *ctrl = cl->skip_predicates();\n+  Node *ctrl = cl->skip_assertion_predicates_with_halt();\n@@ -3412,1 +3415,1 @@\n-  Node* ctrl = main_loop->skip_predicates();\n+  Node* ctrl = main_loop->skip_assertion_predicates_with_halt();\n@@ -3451,1 +3454,1 @@\n-  Node* main_iff = main_head->skip_predicates()->in(0);\n+  Node* main_iff = main_head->skip_assertion_predicates_with_halt()->in(0);\n@@ -3522,1 +3525,2 @@\n-    Node* in_ctrl = Predicates::skip_all_predicates(cl->skip_predicates());\n+    Predicates predicates(cl->skip_strip_mined()->in(LoopNode::EntryControl));\n+    Node* in_ctrl = predicates.entry();\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":40,"deletions":36,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -120,10 +121,3 @@\n-  LoopNode *head = loop->_head->as_Loop();\n-  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  if (ParsePredicates::is_success_proj(entry)) {\n-    assert(entry->is_IfProj(), \"sanity - must be ifProj since there is at least one predicate\");\n-    if (entry->outcnt() > 1) {\n-      \/\/ Bailout if there are predicates from which there are additional control dependencies (i.e. from loop\n-      \/\/ entry 'entry') to previously partially peeled statements since this case is not handled and can lead\n-      \/\/ to a wrong execution. Remove this bailout, once this is fixed.\n-      return;\n-    }\n+  LoopNode* head = loop->_head->as_Loop();\n+  if (has_control_dependencies_from_predicates(head)) {\n+    return;\n@@ -131,0 +125,1 @@\n+\n@@ -149,1 +144,1 @@\n-  ProjNode* proj_false = invar_iff->proj_out(0);\n+  verify_fast_loop(head, proj_true);\n@@ -151,16 +146,0 @@\n-#ifdef ASSERT\n-  assert(proj_true->is_IfTrue(), \"must be true projection\");\n-  entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n-  ParsePredicates parse_predicates(entry);\n-  if (!parse_predicates.has_any()) {\n-    \/\/ No Parse Predicate.\n-    Node* uniqc = proj_true->unique_ctrl_out();\n-    assert((uniqc == head && !head->is_strip_mined()) || (uniqc == head->in(LoopNode::EntryControl)\n-           && head->is_strip_mined()), \"must hold by construction if no predicates\");\n-  } else {\n-    \/\/ There is at least one Parse Predicate. When skipping all predicates\/Regular Predicate Blocks, we should end up\n-    \/\/ at 'proj_true'.\n-    assert(proj_true == Predicates::skip_all_predicates(parse_predicates),\n-           \"must hold by construction if at least one Parse Predicate\");\n-  }\n-#endif\n@@ -205,0 +184,1 @@\n+  ProjNode* proj_false = invar_iff->proj_out(0);\n@@ -226,0 +206,15 @@\n+bool PhaseIdealLoop::has_control_dependencies_from_predicates(LoopNode* head) const {\n+  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  Predicates predicates(entry);\n+  if (predicates.has_any()) {\n+    assert(entry->is_IfProj(), \"sanity - must be ifProj since there is at least one predicate\");\n+    if (entry->outcnt() > 1) {\n+      \/\/ Bailout if there are predicates from which there are additional control dependencies (i.e. from loop\n+      \/\/ entry 'entry') to previously partially peeled statements since this case is not handled and can lead\n+      \/\/ to a wrong execution. Remove this bailout, once this is fixed.\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n@@ -274,0 +269,18 @@\n+#ifdef ASSERT\n+void PhaseIdealLoop::verify_fast_loop(LoopNode* head, const ProjNode* proj_true) const {\n+  assert(proj_true->is_IfTrue(), \"must be true projection\");\n+  Node* entry = head->skip_strip_mined()->in(LoopNode::EntryControl);\n+  Predicates predicates(entry);\n+  if (!predicates.has_any()) {\n+    \/\/ No Parse Predicate.\n+    Node* uniqc = proj_true->unique_ctrl_out();\n+    assert((uniqc == head && !head->is_strip_mined()) || (uniqc == head->in(LoopNode::EntryControl)\n+                                                          && head->is_strip_mined()), \"must hold by construction if no predicates\");\n+  } else {\n+    \/\/ There is at least one Parse Predicate. When skipping all predicates\/predicate blocks, we should end up\n+    \/\/ at 'proj_true'.\n+    assert(proj_true == predicates.entry(), \"must hold by construction if at least one Parse Predicate\");\n+  }\n+}\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":40,"deletions":27,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"opto\/predicates.hpp\"\n@@ -346,0 +347,1 @@\n+  assert(loop_limit_check_parse_proj->in(0)->is_ParsePredicate(), \"must be parse predicate\");\n@@ -1806,1 +1808,3 @@\n-    if (!ParsePredicates::is_loop_limit_check_predicate_proj(init_control)) {\n+    const Predicates predicates(init_control);\n+    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+    if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n@@ -1810,1 +1814,1 @@\n-        tty->print(\"missing loop limit check:\");\n+        tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n@@ -1818,4 +1822,2 @@\n-    ParsePredicateSuccessProj* loop_limit_check_parse_predicate_proj = init_control->as_IfTrue();\n-    ParsePredicateNode* parse_predicate = loop_limit_check_parse_predicate_proj->in(0)->as_ParsePredicate();\n-\n-    if (!is_dominator(get_ctrl(limit), parse_predicate->in(0))) {\n+    ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n+    if (!is_dominator(get_ctrl(limit), loop_limit_check_parse_predicate->in(0))) {\n@@ -1836,1 +1838,1 @@\n-    insert_loop_limit_check_predicate(loop_limit_check_parse_predicate_proj, cmp_limit, bol);\n+    insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n@@ -1849,1 +1851,3 @@\n-      if (!ParsePredicates::is_loop_limit_check_predicate_proj(init_control)) {\n+      const Predicates predicates(init_control);\n+      const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+      if (!loop_limit_check_predicate_block->has_parse_predicate()) {\n@@ -1853,1 +1857,1 @@\n-          tty->print(\"missing loop limit check:\");\n+          tty->print(\"Missing Loop Limit Check Parse Predicate:\");\n@@ -1860,2 +1864,0 @@\n-      ParsePredicateSuccessProj* loop_limit_check_parse_predicate_proj = init_control->as_IfTrue();\n-      ParsePredicateNode* parse_predicate = init_control->in(0)->as_ParsePredicate();\n@@ -1863,2 +1865,4 @@\n-      if (!is_dominator(get_ctrl(limit), parse_predicate->in(0)) ||\n-          !is_dominator(get_ctrl(init_trip), parse_predicate->in(0))) {\n+      ParsePredicateNode* loop_limit_check_parse_predicate = loop_limit_check_predicate_block->parse_predicate();\n+      Node* parse_predicate_entry = loop_limit_check_parse_predicate->in(0);\n+      if (!is_dominator(get_ctrl(limit), parse_predicate_entry) ||\n+          !is_dominator(get_ctrl(init_trip), parse_predicate_entry)) {\n@@ -1879,1 +1883,1 @@\n-      insert_loop_limit_check_predicate(loop_limit_check_parse_predicate_proj, cmp_limit, bol);\n+      insert_loop_limit_check_predicate(init_control->as_IfTrue(), cmp_limit, bol);\n@@ -2573,29 +2577,1 @@\n-Node* CountedLoopNode::skip_predicates_from_entry(Node* ctrl) {\n-    while (ctrl != nullptr && ctrl->is_Proj() && ctrl->in(0) != nullptr && ctrl->in(0)->is_If() &&\n-           !is_zero_trip_guard_if(ctrl->in(0)->as_If()) &&\n-           (ctrl->in(0)->as_If()->proj_out_or_null(1-ctrl->as_Proj()->_con) == nullptr ||\n-             (ctrl->in(0)->as_If()->proj_out(1-ctrl->as_Proj()->_con)->outcnt() == 1 &&\n-              ctrl->in(0)->as_If()->proj_out(1-ctrl->as_Proj()->_con)->unique_out()->Opcode() == Op_Halt))) {\n-      ctrl = ctrl->in(0)->in(0);\n-    }\n-\n-    return ctrl;\n-  }\n-\n-bool CountedLoopNode::is_zero_trip_guard_if(const IfNode* iff) {\n-  if (iff->in(1) == nullptr || !iff->in(1)->is_Bool()) {\n-    return false;\n-  }\n-  if (iff->in(1)->in(1) == nullptr || iff->in(1)->in(1)->Opcode() != Op_CmpI) {\n-    return false;\n-  }\n-  if (iff->in(1)->in(1)->in(1) != nullptr && iff->in(1)->in(1)->in(1)->Opcode() == Op_OpaqueZeroTripGuard) {\n-    return true;\n-  }\n-  if (iff->in(1)->in(1)->in(2) != nullptr && iff->in(1)->in(1)->in(2)->Opcode() == Op_OpaqueZeroTripGuard) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-Node* CountedLoopNode::skip_predicates() {\n+Node* CountedLoopNode::skip_assertion_predicates_with_halt() {\n@@ -2607,1 +2583,2 @@\n-    return skip_predicates_from_entry(ctrl);\n+    AssertionPredicatesWithHalt assertion_predicates(ctrl);\n+    return assertion_predicates.entry();\n@@ -3981,2 +3958,2 @@\n-  ParsePredicates parse_predicates(entry);\n-  if (parse_predicates.loop_limit_check_predicate_proj() != nullptr) {\n+  const Predicates predicates(entry);\n+  if (predicates.loop_limit_check_predicate_block()->is_non_empty()) {\n@@ -3985,1 +3962,1 @@\n-  if (UseProfiledLoopPredicate && parse_predicates.profiled_loop_predicate_proj() != nullptr) {\n+  if (UseProfiledLoopPredicate && predicates.profiled_loop_predicate_block()->is_non_empty()) {\n@@ -3988,1 +3965,1 @@\n-  if (UseLoopPredicate && parse_predicates.loop_predicate_proj() != nullptr) {\n+  if (UseLoopPredicate && predicates.loop_predicate_block()->is_non_empty()) {\n@@ -4096,5 +4073,6 @@\n-    ParsePredicates parse_predicates(entry);\n-    ProjNode* predicate_proj = parse_predicates.loop_limit_check_predicate_proj();\n-    if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n-      assert(predicate_proj->in(0)->in(1)->in(1)->Opcode() == Op_Opaque1, \"must be\");\n-      useful_predicates.push(predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n+    const Predicates predicates(entry);\n+    const PredicateBlock* loop_limit_check_predicate_block = predicates.loop_limit_check_predicate_block();\n+    if (loop_limit_check_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n+      IfProjNode* parse_predicate_proj = loop_limit_check_predicate_block->parse_predicate_success_proj();\n+      assert(parse_predicate_proj->in(0)->in(1)->in(1)->Opcode() == Op_Opaque1, \"must be\");\n+      useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n@@ -4103,4 +4081,5 @@\n-      predicate_proj = parse_predicates.profiled_loop_predicate_proj();\n-      if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n-        useful_predicates.push(predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(predicate_proj, useful_predicates, true);\n+      const PredicateBlock* profiled_loop_predicate_block = predicates.profiled_loop_predicate_block();\n+      if (profiled_loop_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n+        IfProjNode* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n+        useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n+        get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n@@ -4111,4 +4090,5 @@\n-      predicate_proj = parse_predicates.loop_predicate_proj();\n-      if (predicate_proj != nullptr) { \/\/ right pattern that can be used by loop predication\n-        useful_predicates.push(predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n-        get_assertion_predicates(predicate_proj, useful_predicates, true);\n+      const PredicateBlock* loop_predicate_block = predicates.loop_predicate_block();\n+      if (loop_predicate_block->has_parse_predicate()) { \/\/ right pattern that can be used by loop predication\n+        IfProjNode* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n+        useful_predicates.push(parse_predicate_proj->in(0)->in(1)->in(1)); \/\/ good one\n+        get_assertion_predicates(parse_predicate_proj, useful_predicates, true);\n@@ -5709,1 +5689,1 @@\n-  Node* ctrl = skip_predicates();\n+  Node* ctrl = skip_assertion_predicates_with_halt();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":42,"deletions":62,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-class ParsePredicates;\n+class PredicateBlock;\n@@ -335,5 +335,1 @@\n-  \/\/ If this is a main loop in a pre\/main\/post loop nest, walk over\n-  \/\/ the predicates that were inserted by\n-  \/\/ duplicate_predicates()\/add_range_check_predicate()\n-  static Node* skip_predicates_from_entry(Node* ctrl);\n-  Node* skip_predicates();\n+  Node* skip_assertion_predicates_with_halt();\n@@ -350,2 +346,0 @@\n-\n-  static bool is_zero_trip_guard_if(const IfNode* iff);\n@@ -948,5 +942,5 @@\n-  void copy_assertion_predicates_to_main_loop_helper(Node* predicate, Node* init, Node* stride, IdealLoopTree* outer_loop,\n-                                                     LoopNode* outer_main_head, uint dd_main_head,\n-                                                     uint idx_before_pre_post, uint idx_after_post_before_pre,\n-                                                     Node* zero_trip_guard_proj_main, Node* zero_trip_guard_proj_post,\n-                                                     const Node_List &old_new);\n+  void copy_assertion_predicates_to_main_loop_helper(const PredicateBlock* predicate_block, Node* init, Node* stride,\n+                                                     IdealLoopTree* outer_loop, LoopNode* outer_main_head,\n+                                                     uint dd_main_head, uint idx_before_pre_post,\n+                                                     uint idx_after_post_before_pre, Node* zero_trip_guard_proj_main,\n+                                                     Node* zero_trip_guard_proj_post, const Node_List &old_new);\n@@ -969,3 +963,3 @@\n-  void initialize_assertion_predicates_for_peeled_loop(IfProjNode* predicate_proj, LoopNode* outer_loop_head,\n-                                                       const int dd_outer_loop_head, Node* init, Node* stride,\n-                                                       IdealLoopTree* outer_loop, const uint idx_before_clone,\n+  void initialize_assertion_predicates_for_peeled_loop(const PredicateBlock* predicate_block, LoopNode* outer_loop_head,\n+                                                       int dd_outer_loop_head, Node* init, Node* stride,\n+                                                       IdealLoopTree* outer_loop, uint idx_before_clone,\n@@ -1352,2 +1346,1 @@\n-                                          int opcode, bool rewire_uncommon_proj_phi_inputs = false,\n-                                          bool if_cont_is_true_proj = true);\n+                                          int opcode, bool rewire_uncommon_proj_phi_inputs = false);\n@@ -1374,0 +1367,2 @@\n+\n+ private:\n@@ -1377,1 +1372,2 @@\n-  bool loop_predication_should_follow_branches(IdealLoopTree* loop, IfProjNode* predicate_proj, float& loop_trip_cnt);\n+  bool can_create_loop_predicates(const PredicateBlock* profiled_loop_predicate_block) const;\n+  bool loop_predication_should_follow_branches(IdealLoopTree* loop, float& loop_trip_cnt);\n@@ -1392,0 +1388,3 @@\n+  bool has_control_dependencies_from_predicates(LoopNode* head) const;\n+  void verify_fast_loop(LoopNode* head, const ProjNode* proj_true) const NOT_DEBUG_RETURN;\n+ public:\n@@ -1638,0 +1637,6 @@\n+  void clone_loop_predication_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new,\n+                                                            const PredicateBlock* predicate_block,\n+                                                            Deoptimization::DeoptReason reason, IfProjNode*& iffast_pred,\n+                                                            IfProjNode*& ifslow_pred);\n+  void clone_parse_predicate_to_unswitched_loops(const PredicateBlock* predicate_block, Deoptimization::DeoptReason reason,\n+                                                 IfProjNode*& iffast_pred, IfProjNode*& ifslow_pred);\n@@ -1918,59 +1923,0 @@\n-\/\/ Utility class to work on predicates.\n-class Predicates {\n- public:\n-  static Node* skip_all_predicates(Node* node);\n-  static Node* skip_all_predicates(ParsePredicates& parse_predicates);\n-  static Node* skip_predicates_in_block(ParsePredicateSuccessProj* parse_predicate_success_proj);\n-  static IfProjNode* next_predicate_proj_in_block(IfProjNode* proj);\n-  static bool has_profiled_loop_predicates(ParsePredicates& parse_predicates);\n-};\n-\n-\/\/ Class representing the Parse Predicates that are added during parsing with ParsePredicateNodes.\n-class ParsePredicates {\n- private:\n-  ParsePredicateSuccessProj* _loop_predicate_proj = nullptr;\n-  ParsePredicateSuccessProj* _profiled_loop_predicate_proj = nullptr;\n-  ParsePredicateSuccessProj* _loop_limit_check_predicate_proj = nullptr;\n-  \/\/ The success projection of the Parse Predicate that comes first when starting from root.\n-  ParsePredicateSuccessProj* _top_predicate_proj;\n-  ParsePredicateSuccessProj* _starting_proj;\n-\n-  void find_parse_predicate_projections();\n-  static bool is_uct_proj(Node* node, Deoptimization::DeoptReason deopt_reason);\n-  static ParsePredicateNode* get_parse_predicate_or_null(Node* proj);\n-  bool assign_predicate_proj(ParsePredicateSuccessProj* parse_predicate_proj);\n- public:\n-  ParsePredicates(Node* starting_proj);\n-\n-  \/\/ Success projection of Loop Parse Predicate.\n-  ParsePredicateSuccessProj* loop_predicate_proj() {\n-    return _loop_predicate_proj;\n-  }\n-\n-  \/\/ Success proj of Profiled Loop Parse Predicate.\n-  ParsePredicateSuccessProj* profiled_loop_predicate_proj() {\n-    return _profiled_loop_predicate_proj;\n-  }\n-\n-  \/\/ Success proj of Loop Limit Check Parse Predicate.\n-  ParsePredicateSuccessProj* loop_limit_check_predicate_proj() {\n-    return _loop_limit_check_predicate_proj;\n-  }\n-\n-  \/\/ Return the success projection of the Parse Predicate that comes first when starting from root.\n-  ParsePredicateSuccessProj* get_top_predicate_proj() {\n-    return _top_predicate_proj;\n-  }\n-\n-  static bool is_success_proj(Node* node);\n-\n-  \/\/ Are there any Parse Predicates?\n-  bool has_any() const {\n-    return _top_predicate_proj != nullptr;\n-  }\n-\n-  static bool is_loop_limit_check_predicate_proj(Node* node) {\n-    ParsePredicateNode* parse_predicate = get_parse_predicate_or_null(node);\n-    return parse_predicate != nullptr && parse_predicate->deopt_reason() == Deoptimization::DeoptReason::Reason_loop_limit_check;\n-  }\n-};\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":24,"deletions":78,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"opto\/callnode.hpp\"\n+#include \"opto\/predicates.hpp\"\n+\n+\/\/ Walk over all Initialized Assertion Predicates and return the entry into the first Initialized Assertion Predicate\n+\/\/ (i.e. not belonging to an Initialized Assertion Predicate anymore)\n+Node* AssertionPredicatesWithHalt::find_entry(Node* start_proj) {\n+  Node* entry = start_proj;\n+  while (is_assertion_predicate_success_proj(entry)) {\n+    entry = entry->in(0)->in(0);\n+  }\n+  return entry;\n+}\n+\n+bool AssertionPredicatesWithHalt::is_assertion_predicate_success_proj(const Node* predicate_proj) {\n+  if (predicate_proj == nullptr || !predicate_proj->is_IfProj() || !predicate_proj->in(0)->is_If()) {\n+    return false;\n+  }\n+  return has_opaque4(predicate_proj) && has_halt(predicate_proj);\n+}\n+\n+\/\/ Check if the If node of `predicate_proj` has an Opaque4 node as input.\n+bool AssertionPredicatesWithHalt::has_opaque4(const Node* predicate_proj) {\n+  IfNode* iff = predicate_proj->in(0)->as_If();\n+  return iff->in(1)->Opcode() == Op_Opaque4;\n+}\n+\n+\/\/ Check if the other projection (UCT projection) of `success_proj` has a Halt node as output.\n+bool AssertionPredicatesWithHalt::has_halt(const Node* success_proj) {\n+  ProjNode* other_proj = success_proj->as_IfProj()->other_if_proj();\n+  return other_proj->outcnt() == 1 && other_proj->unique_out()->Opcode() == Op_Halt;\n+}\n+\n+\/\/ Returns the Parse Predicate node if the provided node is a Parse Predicate success proj. Otherwise, return null.\n+ParsePredicateNode* ParsePredicate::init_parse_predicate(Node* parse_predicate_proj,\n+                                                         Deoptimization::DeoptReason deopt_reason) {\n+  assert(parse_predicate_proj != nullptr, \"must not be null\");\n+  if (parse_predicate_proj->is_IfTrue() && parse_predicate_proj->in(0)->is_ParsePredicate()) {\n+    ParsePredicateNode* parse_predicate_node = parse_predicate_proj->in(0)->as_ParsePredicate();\n+    if (parse_predicate_node->deopt_reason() == deopt_reason) {\n+      return parse_predicate_node;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+Deoptimization::DeoptReason RuntimePredicate::uncommon_trap_reason(IfProjNode* if_proj) {\n+    CallStaticJavaNode* uct_call = if_proj->is_uncommon_trap_if_pattern(Deoptimization::Reason_none);\n+    if (uct_call == nullptr) {\n+      return Deoptimization::Reason_none;\n+    }\n+    return Deoptimization::trap_request_reason(uct_call->uncommon_trap_request());\n+}\n+\n+bool RuntimePredicate::is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason) {\n+  if (node->is_IfProj()) {\n+    return deopt_reason == uncommon_trap_reason(node->as_IfProj());\n+  } else {\n+    return false;\n+  }\n+}\n+\n+\/\/ Walk over all Regular Predicates of this block (if any) and return the first node not belonging to the block\n+\/\/ anymore (i.e. entry to the first Regular Predicate in this block if any or `regular_predicate_proj` otherwise).\n+Node* PredicateBlock::skip_regular_predicates(Node* regular_predicate_proj, Deoptimization::DeoptReason deopt_reason) {\n+  Node* entry = regular_predicate_proj;\n+  while (RuntimePredicate::is_success_proj(entry, deopt_reason)) {\n+    assert(entry->in(0)->as_If(), \"must be If node\");\n+    entry = entry->in(0)->in(0);\n+  }\n+  return entry;\n+}\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,358 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OPTO_PREDICATES_HPP\n+#define SHARE_OPTO_PREDICATES_HPP\n+\n+#include \"opto\/cfgnode.hpp\"\n+\n+\/*\n+ * There are different kinds of predicates throughout the code. We differentiate between the following predicates:\n+ *\n+ * - Regular Predicate: This term is used to refer to a Runtime Predicate or an Assertion Predicate and can be used to\n+ *                      distinguish from any Parse Predicate which is not a real predicate but rather a placeholder.\n+ * - Parse Predicate: Added during parsing to capture the current JVM state. This predicate represents a \"placeholder\"\n+ *                    above which Regular Predicates can be created later after parsing.\n+ *\n+ *                    There are initially three Parse Predicates for each loop:\n+ *                    - Loop Parse Predicate:             The Parse Predicate added for Loop Predicates.\n+ *                    - Profiled Loop Parse Predicate:    The Parse Predicate added for Profiled Loop Predicates.\n+ *                    - Loop Limit Check Parse Predicate: The Parse Predicate added for a Loop Limit Check Predicate.\n+ * - Runtime Predicate: This term is used to refer to a Hoisted Check Predicate (either a Loop Predicate or a Profiled\n+ *                      Loop Predicate) or a Loop Limit Check Predicate. These predicates will be checked at runtime while\n+ *                      the Parse and Assertion Predicates are always removed before code generation (except for\n+ *                      Initialized Assertion Predicates which are kept in debug builds while being removed in product\n+ *                      builds).\n+ *     - Hoisted Check Predicate: Either a Loop Predicate or a Profiled Loop Predicate that is created during Loop\n+ *                                Predication to hoist a check out of a loop.\n+ *         - Loop Predicate:     This predicate is created to hoist a loop-invariant check or a range check of the\n+ *                               form \"a[i*scale + offset]\", where scale and offset are loop-invariant, out of a\n+ *                               counted loop. The hoisted check must be executed in each loop iteration. This predicate\n+ *                               is created during Loop Predication and is inserted above the Loop Parse Predicate. Each\n+ *                               predicate for a range check is accompanied by additional Assertion Predicates (see below).\n+ *         - Profiled Loop:      This predicate is very similar to a Loop Predicate but the check to be hoisted does not\n+ *           Predicate           need to be executed in each loop iteration. By using profiling information, only checks\n+ *                               with a high execution frequency are chosen to be replaced by a Profiled Loop Predicate.\n+ *                               This predicate is created during Loop Predication and is inserted above the Profiled\n+ *                               Loop Parse Predicate.\n+ *     - Loop Limit Check:   This predicate is created when transforming a loop to a counted loop to protect against\n+ *       Predicate           the case when adding the stride to the induction variable would cause an overflow which\n+ *                           will not satisfy the loop limit exit condition. This overflow is unexpected for further\n+ *                           counted loop optimizations and could lead to wrong results. Therefore, when this predicate\n+ *                           fails at runtime, we must trap and recompile the method without turning the loop into a\n+ *                           counted loop to avoid these overflow problems.\n+ *                           The predicate does not replace an actual check inside the loop. This predicate can only\n+ *                           be added once above the Loop Limit Check Parse Predicate for a loop.\n+ * - Assertion Predicate: An always true predicate which will never fail (its range is already covered by an earlier\n+ *                        Hoisted Check Predicate or the main-loop entry guard) but is required in order to fold away a\n+ *                        dead sub loop in which some data could be proven to be dead (by the type system) and replaced\n+ *                        by top. Without such Assertion Predicates, we could find that type ranges in Cast and ConvX2Y\n+ *                        data nodes become impossible and are replaced by top. This is an indicator that the sub loop\n+ *                        is never executed and must be dead. But there is no way for C2 to prove that the sub loop is\n+ *                        actually dead. Assertion Predicates come to the rescue to fold such seemingly dead sub loops\n+ *                        away to avoid a broken graph. Assertion Predicates are left in the graph as a sanity checks in\n+ *                        debug builds (they must never fail at runtime) while they are being removed in product builds.\n+ *                        We use special Opaque4 nodes to block some optimizations and replace the Assertion Predicates\n+ *                        later in product builds.\n+ *\n+ *                        There are two kinds of Assertion Predicates:\n+ *                        - Template Assertion Predicate:    A template for an Assertion Predicate that uses OpaqueLoop*\n+ *                                                           nodes as placeholders for the init and stride value of a loop.\n+ *                                                           This predicate does not represent an actual check, yet, and\n+ *                                                           just serves as a template to create an Initialized Assertion\n+ *                                                           Predicate for a (sub) loop.\n+ *                        - Initialized Assertion Predicate: An Assertion Predicate that represents an actual check for a\n+ *                                                           (sub) loop that was initialized by cloning a Template\n+ *                                                           Assertion Predicate. The check is always true and is covered\n+ *                                                           by an earlier check (a Hoisted Check Predicate or the\n+ *                                                           main-loop entry guard).\n+ *\n+ *                        Assertion Predicates are required when removing a range check from a loop. These are inserted\n+ *                        either at Loop Predication or at Range Check Elimination:\n+ *                        - Loop Predication:        A range check inside a loop is replaced by a Hoisted Check Predicate\n+ *                                                   before the loop. We add two additional Template Assertion Predicates\n+ *                                                   from which we can later create Initialized Assertion Predicates. One\n+ *                                                   would have been enough if the number of array accesses inside a sub\n+ *                                                   loop does not change. But when unrolling the sub loop, we are\n+ *                                                   doubling the number of array accesses - we need to cover them all.\n+ *                                                   To do that, we only need to create an Initialized Assertion Predicate\n+ *                                                   for the first, initial value and for the last value:\n+ *                                                   Let a[i] be an array access in the original, not-yet unrolled loop\n+ *                                                   with stride 1. When unrolling this loop, we double the stride\n+ *                                                   (i.e. stride 2) and have now two accesses a[i] and a[i+1]. We need\n+ *                                                   checks for both. When further unrolling this loop, we only need to\n+ *                                                   keep the checks on the first and last access (e.g. a[i] and a[i+3]\n+ *                                                   on the next unrolling step as they cover the checks in the middle\n+ *                                                   for a[i+1] and a[i+2]).\n+ *                                                   Therefore, we just need to cover:\n+ *                                                   - Initial value: a[init]\n+ *                                                   - Last value: a[init + new stride - original stride]\n+ *                                                   (We could still only use one Template Assertion Predicate to create\n+ *                                                   both Initialized Assertion Predicates from - might be worth doing\n+ *                                                   at some point).\n+ *                                                   When later splitting a loop (pre\/main\/post, peeling, unrolling),\n+ *                                                   we create two Initialized Assertion Predicates from the Template\n+ *                                                   Assertion Predicates by replacing the OpaqueLoop* nodes by actual\n+ *                                                   values. Initially (before unrolling), both Assertion Predicates are\n+ *                                                   equal. The Initialized Assertion Predicates are always true because\n+ *                                                   their range is covered by a corresponding Hoisted Check Predicate.\n+ *                        - Range Check Elimination: A range check is removed from the main-loop by changing the pre\n+ *                                                   and main-loop iterations. We add two additional Template Assertion\n+ *                                                   Predicates (see explanation in section above) and one Initialized\n+ *                                                   Assertion Predicate for the just removed range check. When later\n+ *                                                   unrolling the main-loop, we create two Initialized Assertion\n+ *                                                   Predicates from the Template Assertion Predicates by replacing the\n+ *                                                   OpaqueLoop* nodes by actual values for the unrolled loop.\n+ *                                                   The Initialized Assertion Predicates are always true: They are true\n+ *                                                   when entering the main-loop (because we adjusted the pre-loop exit\n+ *                                                   condition), when executing the last iteration of the main-loop\n+ *                                                   (because we adjusted the main-loop exit condition), and during all\n+ *                                                   other iterations of the main-loop in-between by implication.\n+ *                                                   Note that Range Check Elimination could remove additional range\n+ *                                                   checks which were not possible to remove with Loop Predication\n+ *                                                   before (for example, because no Parse Predicates were available\n+ *                                                   before the loop to create Hoisted Check Predicates with).\n+ *\n+ *\n+ * In order to group predicates and refer to them throughout the code, we introduce the following additional term:\n+ * - Predicate Block: A block containing all Runtime Predicates, including the Assertion Predicates for Range Check\n+ *                    Predicates, and the associated Parse Predicate which all share the same uncommon trap. This block\n+ *                    could be empty if there were no Runtime Predicates created and the Parse Predicate was already\n+ *                    removed.\n+ *                    There are three different Predicate Blocks:\n+ *                    - Loop Predicate Block: Groups the Loop Predicates (if any), including the Assertion Predicates,\n+ *                                            and the Loop Parse Predicate (if not removed, yet) together.\n+ *                    - Profiled Loop         Groups the Profiled Loop Predicates (if any), including the Assertion\n+ *                      Predicate Block:      Predicates, and the Profiled Loop Parse Predicate (if not removed, yet)\n+ *                                            together.\n+ *                    - Loop Limit Check      Groups the Loop Limit Check Predicate (if created) and the Loop Limit\n+ *                      Predicate Block:      Check Parse Predicate (if not removed, yet) together.\n+ *\n+ *\n+ * Initially, before applying any loop-splitting optimizations, we find the following structure after Loop Predication\n+ * (predicates inside square brackets [] do not need to exist if there are no checks to hoist):\n+ *\n+ *   [Loop Predicate 1 + two Template Assertion Predicates]            \\\n+ *   [Loop Predicate 2 + two Template Assertion Predicates]            |\n+ *   ...                                                               | Loop Predicate Block\n+ *   [Loop Predicate n + two Template Assertion Predicates]            |\n+ * Loop Parse Predicate                                                \/\n+ *\n+ *   [Profiled Loop Predicate 1 + two Template Assertion Predicates]   \\\n+ *   [Profiled Loop Predicate 2 + two Template Assertion Predicates]   | Profiled Loop\n+ *   ...                                                               | Predicate Block\n+ *   [Profiled Loop Predicate m + two Template Assertion Predicates]   |\n+ * Profiled Loop Parse Predicate                                       \/\n+ *\n+ *   [Loop Limit Check Predicate] (at most one)                        \\ Loop Limit Check\n+ * Loop Limit Check Parse Predicate                                    \/ Predicate Block\n+ * Loop Head\n+ *\n+ * As an example, let's look at how the predicate structure looks for the main-loop after creating pre\/main\/post loops\n+ * and applying Range Check Elimination (the order is insignificant):\n+ *\n+ * Main Loop entry (zero-trip) guard\n+ *   [For Loop Predicate 1: Two Template + two Initialized Assertion Predicates]\n+ *   [For Loop Predicate 2: Two Template + two Initialized Assertion Predicates]\n+ *   ...\n+ *   [For Loop Predicate n: Two Template + two Initialized Assertion Predicates]\n+ *\n+ *   [For Profiled Loop Predicate 1: Two Template + two Initialized Assertion Predicates]\n+ *   [For Profiled Loop Predicate 2: Two Template + two Initialized Assertion Predicates]\n+ *   ...\n+ *   [For Profiled Loop Predicate m: Two Template + two Initialized Assertion Predicates]\n+ *\n+ *   (after unrolling, we have two Initialized Assertion Predicates for the Assertion Predicates of Range Check Elimination)\n+ *   [For Range Check Elimination Check 1: Two Templates + one Initialized Assertion Predicate]\n+ *   [For Range Check Elimination Check 2: Two Templates + one Initialized Assertion Predicate]\n+ *   ...\n+ *   [For Range Check Elimination Check k: Two Templates + one Initialized Assertion Predicate]\n+ * Main Loop Head\n+ *\/\n+\n+\n+\/\/ Class to represent Assertion Predicates with a HaltNode instead of an UCT (i.e. either an Initialized Assertion\n+\/\/ Predicate or a Template Assertion Predicate created after the initial one at Loop Predication).\n+class AssertionPredicatesWithHalt : public StackObj {\n+  Node* _entry;\n+\n+  static Node* find_entry(Node* start_proj);\n+  static bool has_opaque4(const Node* predicate_proj);\n+  static bool has_halt(const Node* success_proj);\n+  static bool is_assertion_predicate_success_proj(const Node* predicate_proj);\n+\n+ public:\n+  AssertionPredicatesWithHalt(Node* assertion_predicate_proj) : _entry(find_entry(assertion_predicate_proj)) {}\n+\n+  \/\/ Returns the control input node into the first assertion predicate If. If there are no assertion predicates, it\n+  \/\/ returns the same node initially passed to the constructor.\n+  Node* entry() const {\n+    return _entry;\n+  }\n+};\n+\n+\/\/ Class to represent a Parse Predicate.\n+class ParsePredicate : public StackObj {\n+  ParsePredicateSuccessProj* _success_proj;\n+  ParsePredicateNode* _parse_predicate_node;\n+  Node* _entry;\n+\n+  IfTrueNode* init_success_proj(const Node* parse_predicate_proj) const {\n+    assert(parse_predicate_proj != nullptr, \"must not be null\");\n+    return parse_predicate_proj->isa_IfTrue();\n+  }\n+\n+  static ParsePredicateNode* init_parse_predicate(Node* parse_predicate_proj, Deoptimization::DeoptReason deopt_reason);\n+\n+ public:\n+  ParsePredicate(Node* parse_predicate_proj, Deoptimization::DeoptReason deopt_reason)\n+      : _success_proj(init_success_proj(parse_predicate_proj)),\n+        _parse_predicate_node(init_parse_predicate(parse_predicate_proj, deopt_reason)),\n+        _entry(_parse_predicate_node != nullptr ? _parse_predicate_node->in(0) : parse_predicate_proj) {}\n+\n+  \/\/ Returns the control input node into this Parse Predicate if it is valid. Otherwise, it returns the passed node\n+  \/\/ into the constructor of this class.\n+  Node* entry() const {\n+    return _entry;\n+  }\n+\n+  \/\/ This Parse Predicate is valid if the node passed to the constructor is a projection of a ParsePredicateNode and the\n+  \/\/ deopt_reason of the uncommon trap of the ParsePredicateNode matches the passed deopt_reason to the constructor.\n+  bool is_valid() const {\n+    return _parse_predicate_node != nullptr;\n+  }\n+\n+  ParsePredicateNode* node() const {\n+    assert(is_valid(), \"must be valid\");\n+    return _parse_predicate_node;\n+  }\n+\n+  ParsePredicateSuccessProj* success_proj() const {\n+    assert(is_valid(), \"must be valid\");\n+    return _success_proj;\n+  }\n+};\n+\n+\/\/ Utility class for queries on Runtime Predicates.\n+class RuntimePredicate : public StackObj {\n+  static Deoptimization::DeoptReason uncommon_trap_reason(IfProjNode* if_proj);\n+\n+ public:\n+  static bool is_success_proj(Node* node, Deoptimization::DeoptReason deopt_reason);\n+};\n+\n+\/\/ This class represents a Predicate Block (i.e. either a Loop Predicate Block, a Profiled Loop Predicate Block,\n+\/\/ or a Loop Limit Check Predicate Block). It contains zero or more Regular Predicates followed by a Parse Predicate\n+\/\/ which, however, does not need to exist (we could already have decided to remove Parse Predicates for this loop).\n+class PredicateBlock : public StackObj {\n+  ParsePredicate _parse_predicate; \/\/ Could be missing.\n+  Node* _entry;\n+\n+  static Node* skip_regular_predicates(Node* regular_predicate_proj, Deoptimization::DeoptReason deopt_reason);\n+\n+ public:\n+  PredicateBlock(Node* predicate_proj, Deoptimization::DeoptReason deopt_reason)\n+      : _parse_predicate(predicate_proj, deopt_reason),\n+        _entry(skip_regular_predicates(_parse_predicate.entry(), deopt_reason)) {}\n+\n+  \/\/ Returns the control input node into this Regular Predicate block. This is either:\n+  \/\/ - The control input to the first If node in the block representing a Runtime Predicate if there is at least one\n+  \/\/   Runtime Predicate.\n+  \/\/ - The control input node into the ParsePredicate node if there is only a Parse Predicate and no Runtime Predicate.\n+  \/\/ - The same node initially passed to the constructor if this Regular Predicate block is empty (i.e. no Parse\n+  \/\/   Predicate or Runtime Predicate).\n+  Node* entry() const {\n+    return _entry;\n+  }\n+\n+  bool is_non_empty() const {\n+    return has_parse_predicate() || has_runtime_predicates();\n+  }\n+\n+  bool has_parse_predicate() const {\n+    return _parse_predicate.is_valid();\n+  }\n+\n+  ParsePredicateNode* parse_predicate() const {\n+    return _parse_predicate.node();\n+  }\n+\n+  ParsePredicateSuccessProj* parse_predicate_success_proj() const {\n+    return _parse_predicate.success_proj();\n+  }\n+\n+  bool has_runtime_predicates() const {\n+    return _parse_predicate.entry() != _entry;\n+  }\n+\n+  \/\/ Returns either:\n+  \/\/ - The entry to the Parse Predicate if present.\n+  \/\/ - The last Runtime Predicate success projection if Parse Predicate is not present.\n+  \/\/ - The entry to this Regular Predicate Block if the block is empty.\n+  Node* skip_parse_predicate() const {\n+    return _parse_predicate.entry();\n+  }\n+};\n+\n+\/\/ This class takes a loop entry node and finds all the available predicates for the loop.\n+class Predicates : public StackObj {\n+  Node* _loop_entry;\n+  PredicateBlock _loop_limit_check_predicate_block;\n+  PredicateBlock _profiled_loop_predicate_block;\n+  PredicateBlock _loop_predicate_block;\n+  Node* _entry;\n+\n+ public:\n+  Predicates(Node* loop_entry)\n+      : _loop_entry(loop_entry),\n+        _loop_limit_check_predicate_block(loop_entry, Deoptimization::Reason_loop_limit_check),\n+        _profiled_loop_predicate_block(_loop_limit_check_predicate_block.entry(),\n+                                       Deoptimization::Reason_profile_predicate),\n+        _loop_predicate_block(_profiled_loop_predicate_block.entry(),\n+                              Deoptimization::Reason_predicate),\n+        _entry(_loop_predicate_block.entry()) {}\n+\n+  \/\/ Returns the control input the first predicate if there are any predicates. If there are no predicates, the same\n+  \/\/ node initially passed to the constructor is returned.\n+  Node* entry() const {\n+    return _entry;\n+  }\n+\n+  const PredicateBlock* loop_predicate_block() const {\n+    return &_loop_predicate_block;\n+  }\n+\n+  const PredicateBlock* profiled_loop_predicate_block() const {\n+    return &_profiled_loop_predicate_block;\n+  }\n+\n+  const PredicateBlock* loop_limit_check_predicate_block() const {\n+    return &_loop_limit_check_predicate_block;\n+  }\n+\n+  bool has_any() const {\n+    return _entry != _loop_entry;\n+  }\n+};\n+#endif \/\/ SHARE_OPTO_PREDICATES_HPP\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":358,"deletions":0,"binary":false,"changes":358,"status":"added"},{"patch":"@@ -4014,1 +4014,1 @@\n-  Node* p_f = cl->skip_predicates()->in(0)->in(0);\n+  Node* p_f = cl->skip_assertion_predicates_with_halt()->in(0)->in(0);\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}