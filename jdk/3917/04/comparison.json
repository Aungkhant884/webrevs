{"files":[{"patch":"@@ -79,1 +79,0 @@\n-#define GENERATE_ADDRESS_IS_PREFERRED\n","filename":"src\/hotspot\/cpu\/arm\/c1_Defs_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1175,1 +1175,0 @@\n-    assert(!unaligned, \"unexpected\");\n@@ -1304,1 +1303,0 @@\n-    assert(!unaligned, \"unexpected\");\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -897,160 +897,5 @@\n-\n-static bool match_index_and_scale(Instruction*  instr,\n-                                  Instruction** index,\n-                                  int*          log2_scale) {\n-  \/\/ Skip conversion ops. This works only on 32bit because of the implicit l2i that the\n-  \/\/ unsafe performs.\n-#ifndef _LP64\n-  Convert* convert = instr->as_Convert();\n-  if (convert != NULL && convert->op() == Bytecodes::_i2l) {\n-    assert(convert->value()->type() == intType, \"invalid input type\");\n-    instr = convert->value();\n-  }\n-#endif\n-\n-  ShiftOp* shift = instr->as_ShiftOp();\n-  if (shift != NULL) {\n-    if (shift->op() == Bytecodes::_lshl) {\n-      assert(shift->x()->type() == longType, \"invalid input type\");\n-    } else {\n-#ifndef _LP64\n-      if (shift->op() == Bytecodes::_ishl) {\n-        assert(shift->x()->type() == intType, \"invalid input type\");\n-      } else {\n-        return false;\n-      }\n-#else\n-      return false;\n-#endif\n-    }\n-\n-\n-    \/\/ Constant shift value?\n-    Constant* con = shift->y()->as_Constant();\n-    if (con == NULL) return false;\n-    \/\/ Well-known type and value?\n-    IntConstant* val = con->type()->as_IntConstant();\n-    assert(val != NULL, \"Should be an int constant\");\n-\n-    *index = shift->x();\n-    int tmp_scale = val->value();\n-    if (tmp_scale >= 0 && tmp_scale < 4) {\n-      *log2_scale = tmp_scale;\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  ArithmeticOp* arith = instr->as_ArithmeticOp();\n-  if (arith != NULL) {\n-    \/\/ See if either arg is a known constant\n-    Constant* con = arith->x()->as_Constant();\n-    if (con != NULL) {\n-      *index = arith->y();\n-    } else {\n-      con = arith->y()->as_Constant();\n-      if (con == NULL) return false;\n-      *index = arith->x();\n-    }\n-    long const_value;\n-    \/\/ Check for integer multiply\n-    if (arith->op() == Bytecodes::_lmul) {\n-      assert((*index)->type() == longType, \"invalid input type\");\n-      LongConstant* val = con->type()->as_LongConstant();\n-      assert(val != NULL, \"expecting a long constant\");\n-      const_value = val->value();\n-    } else {\n-#ifndef _LP64\n-      if (arith->op() == Bytecodes::_imul) {\n-        assert((*index)->type() == intType, \"invalid input type\");\n-        IntConstant* val = con->type()->as_IntConstant();\n-        assert(val != NULL, \"expecting an int constant\");\n-        const_value = val->value();\n-      } else {\n-        return false;\n-      }\n-#else\n-      return false;\n-#endif\n-    }\n-    switch (const_value) {\n-    case 1: *log2_scale = 0; return true;\n-    case 2: *log2_scale = 1; return true;\n-    case 4: *log2_scale = 2; return true;\n-    case 8: *log2_scale = 3; return true;\n-    default:            return false;\n-    }\n-  }\n-\n-  \/\/ Unknown instruction sequence; don't touch it\n-  return false;\n-}\n-\n-\n-static bool match(UnsafeRawOp* x,\n-                  Instruction** base,\n-                  Instruction** index,\n-                  int*          log2_scale) {\n-  ArithmeticOp* root = x->base()->as_ArithmeticOp();\n-  if (root == NULL) return false;\n-  \/\/ Limit ourselves to addition for now\n-  if (root->op() != Bytecodes::_ladd) return false;\n-\n-  bool match_found = false;\n-  \/\/ Try to find shift or scale op\n-  if (match_index_and_scale(root->y(), index, log2_scale)) {\n-    *base = root->x();\n-    match_found = true;\n-  } else if (match_index_and_scale(root->x(), index, log2_scale)) {\n-    *base = root->y();\n-    match_found = true;\n-  } else if (NOT_LP64(root->y()->as_Convert() != NULL) LP64_ONLY(false)) {\n-    \/\/ Skipping i2l works only on 32bit because of the implicit l2i that the unsafe performs.\n-    \/\/ 64bit needs a real sign-extending conversion.\n-    Convert* convert = root->y()->as_Convert();\n-    if (convert->op() == Bytecodes::_i2l) {\n-      assert(convert->value()->type() == intType, \"should be an int\");\n-      \/\/ pick base and index, setting scale at 1\n-      *base  = root->x();\n-      *index = convert->value();\n-      *log2_scale = 0;\n-      match_found = true;\n-    }\n-  }\n-  \/\/ The default solution\n-  if (!match_found) {\n-    *base = root->x();\n-    *index = root->y();\n-    *log2_scale = 0;\n-  }\n-\n-  \/\/ If the value is pinned then it will be always be computed so\n-  \/\/ there's no profit to reshaping the expression.\n-  return !root->is_pinned();\n-}\n-\n-\n-void Canonicalizer::do_UnsafeRawOp(UnsafeRawOp* x) {\n-  Instruction* base = NULL;\n-  Instruction* index = NULL;\n-  int          log2_scale;\n-\n-  if (match(x, &base, &index, &log2_scale)) {\n-    x->set_base(base);\n-    x->set_index(index);\n-    x->set_log2_scale(log2_scale);\n-    if (PrintUnsafeOptimization) {\n-      tty->print_cr(\"Canonicalizer: UnsafeRawOp id %d: base = id %d, index = id %d, log2_scale = %d\",\n-                    x->id(), x->base()->id(), x->index()->id(), x->log2_scale());\n-    }\n-  }\n-}\n-\n-void Canonicalizer::do_RoundFP(RoundFP* x) {}\n-void Canonicalizer::do_UnsafeGetRaw(UnsafeGetRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }\n-void Canonicalizer::do_UnsafePutRaw(UnsafePutRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }\n-void Canonicalizer::do_UnsafeGetObject(UnsafeGetObject* x) {}\n-void Canonicalizer::do_UnsafePutObject(UnsafePutObject* x) {}\n-void Canonicalizer::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}\n-void Canonicalizer::do_ProfileCall(ProfileCall* x) {}\n+void Canonicalizer::do_RoundFP        (RoundFP*         x) {}\n+void Canonicalizer::do_UnsafeGet      (UnsafeGet*       x) {}\n+void Canonicalizer::do_UnsafePut      (UnsafePut*       x) {}\n+void Canonicalizer::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {}\n+void Canonicalizer::do_ProfileCall    (ProfileCall*     x) {}\n@@ -1058,2 +903,2 @@\n-void Canonicalizer::do_ProfileInvoke(ProfileInvoke* x) {}\n-void Canonicalizer::do_RuntimeCall(RuntimeCall* x) {}\n+void Canonicalizer::do_ProfileInvoke  (ProfileInvoke*   x) {}\n+void Canonicalizer::do_RuntimeCall    (RuntimeCall*     x) {}\n@@ -1062,1 +907,1 @@\n-void Canonicalizer::do_Assert(Assert* x) {}\n+void Canonicalizer::do_Assert         (Assert*          x) {}\n@@ -1064,1 +909,1 @@\n-void Canonicalizer::do_MemBar(MemBar* x) {}\n+void Canonicalizer::do_MemBar         (MemBar*          x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":9,"deletions":164,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-  void do_UnsafeRawOp(UnsafeRawOp* x);\n-\n-  void unsafe_raw_match(UnsafeRawOp* x,\n-                        Instruction** base,\n-                        Instruction** index,\n-                        int* scale);\n@@ -103,5 +97,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x);\n-  virtual void do_UnsafePutObject(UnsafePutObject* x);\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  virtual void do_UnsafeGet      (UnsafeGet*       x);\n+  virtual void do_UnsafePut      (UnsafePut*       x);\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3151,4 +3151,5 @@\n-      get = append(new UnsafeGetRaw(as_BasicType(local->type()), e,\n-                                    append(new Constant(new IntConstant(offset))),\n-                                    0,\n-                                    true \/*unaligned*\/, true \/*wide*\/));\n+      Value off_val = append(new Constant(new IntConstant(offset)));\n+      get = append(new UnsafeGet(as_BasicType(local->type()), e,\n+                                 off_val,\n+                                 false\/*is_volatile*\/,\n+                                 true\/*is_raw*\/));\n@@ -3481,44 +3482,44 @@\n-  case vmIntrinsics::_getReference       : append_unsafe_get_obj(callee, T_OBJECT,  false); return;\n-  case vmIntrinsics::_getBoolean         : append_unsafe_get_obj(callee, T_BOOLEAN, false); return;\n-  case vmIntrinsics::_getByte            : append_unsafe_get_obj(callee, T_BYTE,    false); return;\n-  case vmIntrinsics::_getShort           : append_unsafe_get_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_getChar            : append_unsafe_get_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_getInt             : append_unsafe_get_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_getLong            : append_unsafe_get_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_getFloat           : append_unsafe_get_obj(callee, T_FLOAT,   false); return;\n-  case vmIntrinsics::_getDouble          : append_unsafe_get_obj(callee, T_DOUBLE,  false); return;\n-  case vmIntrinsics::_putReference       : append_unsafe_put_obj(callee, T_OBJECT,  false); return;\n-  case vmIntrinsics::_putBoolean         : append_unsafe_put_obj(callee, T_BOOLEAN, false); return;\n-  case vmIntrinsics::_putByte            : append_unsafe_put_obj(callee, T_BYTE,    false); return;\n-  case vmIntrinsics::_putShort           : append_unsafe_put_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_putChar            : append_unsafe_put_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_putInt             : append_unsafe_put_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_putLong            : append_unsafe_put_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_putFloat           : append_unsafe_put_obj(callee, T_FLOAT,   false); return;\n-  case vmIntrinsics::_putDouble          : append_unsafe_put_obj(callee, T_DOUBLE,  false); return;\n-  case vmIntrinsics::_getShortUnaligned  : append_unsafe_get_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_getCharUnaligned   : append_unsafe_get_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_getIntUnaligned    : append_unsafe_get_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_getLongUnaligned   : append_unsafe_get_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_putShortUnaligned  : append_unsafe_put_obj(callee, T_SHORT,   false); return;\n-  case vmIntrinsics::_putCharUnaligned   : append_unsafe_put_obj(callee, T_CHAR,    false); return;\n-  case vmIntrinsics::_putIntUnaligned    : append_unsafe_put_obj(callee, T_INT,     false); return;\n-  case vmIntrinsics::_putLongUnaligned   : append_unsafe_put_obj(callee, T_LONG,    false); return;\n-  case vmIntrinsics::_getReferenceVolatile  : append_unsafe_get_obj(callee, T_OBJECT,  true); return;\n-  case vmIntrinsics::_getBooleanVolatile : append_unsafe_get_obj(callee, T_BOOLEAN, true); return;\n-  case vmIntrinsics::_getByteVolatile    : append_unsafe_get_obj(callee, T_BYTE,    true); return;\n-  case vmIntrinsics::_getShortVolatile   : append_unsafe_get_obj(callee, T_SHORT,   true); return;\n-  case vmIntrinsics::_getCharVolatile    : append_unsafe_get_obj(callee, T_CHAR,    true); return;\n-  case vmIntrinsics::_getIntVolatile     : append_unsafe_get_obj(callee, T_INT,     true); return;\n-  case vmIntrinsics::_getLongVolatile    : append_unsafe_get_obj(callee, T_LONG,    true); return;\n-  case vmIntrinsics::_getFloatVolatile   : append_unsafe_get_obj(callee, T_FLOAT,   true); return;\n-  case vmIntrinsics::_getDoubleVolatile  : append_unsafe_get_obj(callee, T_DOUBLE,  true); return;\n-  case vmIntrinsics::_putReferenceVolatile : append_unsafe_put_obj(callee, T_OBJECT,  true); return;\n-  case vmIntrinsics::_putBooleanVolatile : append_unsafe_put_obj(callee, T_BOOLEAN, true); return;\n-  case vmIntrinsics::_putByteVolatile    : append_unsafe_put_obj(callee, T_BYTE,    true); return;\n-  case vmIntrinsics::_putShortVolatile   : append_unsafe_put_obj(callee, T_SHORT,   true); return;\n-  case vmIntrinsics::_putCharVolatile    : append_unsafe_put_obj(callee, T_CHAR,    true); return;\n-  case vmIntrinsics::_putIntVolatile     : append_unsafe_put_obj(callee, T_INT,     true); return;\n-  case vmIntrinsics::_putLongVolatile    : append_unsafe_put_obj(callee, T_LONG,    true); return;\n-  case vmIntrinsics::_putFloatVolatile   : append_unsafe_put_obj(callee, T_FLOAT,   true); return;\n-  case vmIntrinsics::_putDoubleVolatile  : append_unsafe_put_obj(callee, T_DOUBLE,  true); return;\n+  case vmIntrinsics::_getReference           : append_unsafe_get(callee, T_OBJECT,  false); return;\n+  case vmIntrinsics::_getBoolean             : append_unsafe_get(callee, T_BOOLEAN, false); return;\n+  case vmIntrinsics::_getByte                : append_unsafe_get(callee, T_BYTE,    false); return;\n+  case vmIntrinsics::_getShort               : append_unsafe_get(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_getChar                : append_unsafe_get(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_getInt                 : append_unsafe_get(callee, T_INT,     false); return;\n+  case vmIntrinsics::_getLong                : append_unsafe_get(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_getFloat               : append_unsafe_get(callee, T_FLOAT,   false); return;\n+  case vmIntrinsics::_getDouble              : append_unsafe_get(callee, T_DOUBLE,  false); return;\n+  case vmIntrinsics::_putReference           : append_unsafe_put(callee, T_OBJECT,  false); return;\n+  case vmIntrinsics::_putBoolean             : append_unsafe_put(callee, T_BOOLEAN, false); return;\n+  case vmIntrinsics::_putByte                : append_unsafe_put(callee, T_BYTE,    false); return;\n+  case vmIntrinsics::_putShort               : append_unsafe_put(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_putChar                : append_unsafe_put(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_putInt                 : append_unsafe_put(callee, T_INT,     false); return;\n+  case vmIntrinsics::_putLong                : append_unsafe_put(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_putFloat               : append_unsafe_put(callee, T_FLOAT,   false); return;\n+  case vmIntrinsics::_putDouble              : append_unsafe_put(callee, T_DOUBLE,  false); return;\n+  case vmIntrinsics::_getShortUnaligned      : append_unsafe_get(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_getCharUnaligned       : append_unsafe_get(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_getIntUnaligned        : append_unsafe_get(callee, T_INT,     false); return;\n+  case vmIntrinsics::_getLongUnaligned       : append_unsafe_get(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_putShortUnaligned      : append_unsafe_put(callee, T_SHORT,   false); return;\n+  case vmIntrinsics::_putCharUnaligned       : append_unsafe_put(callee, T_CHAR,    false); return;\n+  case vmIntrinsics::_putIntUnaligned        : append_unsafe_put(callee, T_INT,     false); return;\n+  case vmIntrinsics::_putLongUnaligned       : append_unsafe_put(callee, T_LONG,    false); return;\n+  case vmIntrinsics::_getReferenceVolatile   : append_unsafe_get(callee, T_OBJECT,  true); return;\n+  case vmIntrinsics::_getBooleanVolatile     : append_unsafe_get(callee, T_BOOLEAN, true); return;\n+  case vmIntrinsics::_getByteVolatile        : append_unsafe_get(callee, T_BYTE,    true); return;\n+  case vmIntrinsics::_getShortVolatile       : append_unsafe_get(callee, T_SHORT,   true); return;\n+  case vmIntrinsics::_getCharVolatile        : append_unsafe_get(callee, T_CHAR,    true); return;\n+  case vmIntrinsics::_getIntVolatile         : append_unsafe_get(callee, T_INT,     true); return;\n+  case vmIntrinsics::_getLongVolatile        : append_unsafe_get(callee, T_LONG,    true); return;\n+  case vmIntrinsics::_getFloatVolatile       : append_unsafe_get(callee, T_FLOAT,   true); return;\n+  case vmIntrinsics::_getDoubleVolatile      : append_unsafe_get(callee, T_DOUBLE,  true); return;\n+  case vmIntrinsics::_putReferenceVolatile   : append_unsafe_put(callee, T_OBJECT,  true); return;\n+  case vmIntrinsics::_putBooleanVolatile     : append_unsafe_put(callee, T_BOOLEAN, true); return;\n+  case vmIntrinsics::_putByteVolatile        : append_unsafe_put(callee, T_BYTE,    true); return;\n+  case vmIntrinsics::_putShortVolatile       : append_unsafe_put(callee, T_SHORT,   true); return;\n+  case vmIntrinsics::_putCharVolatile        : append_unsafe_put(callee, T_CHAR,    true); return;\n+  case vmIntrinsics::_putIntVolatile         : append_unsafe_put(callee, T_INT,     true); return;\n+  case vmIntrinsics::_putLongVolatile        : append_unsafe_put(callee, T_LONG,    true); return;\n+  case vmIntrinsics::_putFloatVolatile       : append_unsafe_put(callee, T_FLOAT,   true); return;\n+  case vmIntrinsics::_putDoubleVolatile      : append_unsafe_put(callee, T_DOUBLE,  true); return;\n@@ -3529,6 +3530,6 @@\n-  case vmIntrinsics::_getAndAddLong      : append_unsafe_get_and_set_obj(callee, true); return;\n-  case vmIntrinsics::_getAndSetInt       :\n-  case vmIntrinsics::_getAndSetLong      :\n-  case vmIntrinsics::_getAndSetReference : append_unsafe_get_and_set_obj(callee, false); return;\n-  case vmIntrinsics::_getCharStringU     : append_char_access(callee, false); return;\n-  case vmIntrinsics::_putCharStringU     : append_char_access(callee, true); return;\n+  case vmIntrinsics::_getAndAddLong          : append_unsafe_get_and_set(callee, true); return;\n+  case vmIntrinsics::_getAndSetInt           :\n+  case vmIntrinsics::_getAndSetLong          :\n+  case vmIntrinsics::_getAndSetReference     : append_unsafe_get_and_set(callee, false); return;\n+  case vmIntrinsics::_getCharStringU         : append_char_access(callee, false); return;\n+  case vmIntrinsics::_putCharStringU         : append_char_access(callee, true); return;\n@@ -4221,1 +4222,1 @@\n-void GraphBuilder::append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile) {\n+void GraphBuilder::append_unsafe_get(ciMethod* callee, BasicType t, bool is_volatile) {\n@@ -4228,1 +4229,1 @@\n-  Instruction* op = append(new UnsafeGetObject(t, args->at(1), offset, is_volatile));\n+  Instruction* op = append(new UnsafeGet(t, args->at(1), offset, is_volatile));\n@@ -4234,1 +4235,1 @@\n-void GraphBuilder::append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile) {\n+void GraphBuilder::append_unsafe_put(ciMethod* callee, BasicType t, bool is_volatile) {\n@@ -4246,1 +4247,1 @@\n-  Instruction* op = append(new UnsafePutObject(t, args->at(1), offset, val, is_volatile));\n+  Instruction* op = append(new UnsafePut(t, args->at(1), offset, val, is_volatile));\n@@ -4251,18 +4252,0 @@\n-\n-void GraphBuilder::append_unsafe_get_raw(ciMethod* callee, BasicType t) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-  null_check(args->at(0));\n-  Instruction* op = append(new UnsafeGetRaw(t, args->at(1), false));\n-  push(op->type(), op);\n-  compilation()->set_has_unsafe_access(true);\n-}\n-\n-\n-void GraphBuilder::append_unsafe_put_raw(ciMethod* callee, BasicType t) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-  null_check(args->at(0));\n-  Instruction* op = append(new UnsafePutRaw(t, args->at(1), args->at(2)));\n-  compilation()->set_has_unsafe_access(true);\n-}\n-\n-\n@@ -4356,1 +4339,1 @@\n-void GraphBuilder::append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add) {\n+void GraphBuilder::append_unsafe_get_and_set(ciMethod* callee, bool is_add) {\n@@ -4364,1 +4347,1 @@\n-  Instruction* op = append(new UnsafeGetAndSetObject(t, args->at(1), offset, args->at(3), is_add));\n+  Instruction* op = append(new UnsafeGetAndSet(t, args->at(1), offset, args->at(3), is_add));\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":61,"deletions":78,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -376,4 +376,2 @@\n-  void append_unsafe_get_obj(ciMethod* callee, BasicType t, bool is_volatile);\n-  void append_unsafe_put_obj(ciMethod* callee, BasicType t, bool is_volatile);\n-  void append_unsafe_get_raw(ciMethod* callee, BasicType t);\n-  void append_unsafe_put_raw(ciMethod* callee, BasicType t);\n+  void append_unsafe_get(ciMethod* callee, BasicType t, bool is_volatile);\n+  void append_unsafe_put(ciMethod* callee, BasicType t, bool is_volatile);\n@@ -381,1 +379,1 @@\n-  void append_unsafe_get_and_set_obj(ciMethod* callee, bool is_add);\n+  void append_unsafe_get_and_set(ciMethod* callee, bool is_add);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,7 +99,3 @@\n-class     UnsafeRawOp;\n-class       UnsafeGetRaw;\n-class       UnsafePutRaw;\n-class     UnsafeObjectOp;\n-class       UnsafeGetObject;\n-class       UnsafePutObject;\n-class         UnsafeGetAndSetObject;\n+class     UnsafeGet;\n+class     UnsafePut;\n+class     UnsafeGetAndSet;\n@@ -200,5 +196,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x) = 0;\n-  virtual void do_UnsafePutObject(UnsafePutObject* x) = 0;\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) = 0;\n+  virtual void do_UnsafeGet      (UnsafeGet*       x) = 0;\n+  virtual void do_UnsafePut      (UnsafePut*       x) = 0;\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x) = 0;\n@@ -2261,1 +2255,4 @@\n-  BasicType _basic_type;    \/\/ ValueType can not express byte-sized integers\n+  Value _object;                                 \/\/ Object to be fetched from or mutated\n+  Value _offset;                                 \/\/ Offset within object\n+  bool  _is_volatile;                            \/\/ true if volatile - dl\/JSR166\n+  BasicType _basic_type;                         \/\/ ValueType can not express byte-sized integers\n@@ -2265,3 +2262,3 @@\n-  UnsafeOp(BasicType basic_type, bool is_put)\n-  : Instruction(is_put ? voidType : as_ValueType(basic_type))\n-  , _basic_type(basic_type)\n+  UnsafeOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)\n+    : Instruction(is_put ? voidType : as_ValueType(basic_type)),\n+    _object(object), _offset(offset), _is_volatile(is_volatile), _basic_type(basic_type)\n@@ -2278,0 +2275,3 @@\n+  Value object()                                 { return _object; }\n+  Value offset()                                 { return _offset; }\n+  bool  is_volatile()                            { return _is_volatile; }\n@@ -2280,47 +2280,2 @@\n-  virtual void input_values_do(ValueVisitor* f)   { }\n-};\n-\n-\n-BASE(UnsafeRawOp, UnsafeOp)\n- private:\n-  Value _base;                                   \/\/ Base address (a Java long)\n-  Value _index;                                  \/\/ Index if computed by optimizer; initialized to NULL\n-  int   _log2_scale;                             \/\/ Scale factor: 0, 1, 2, or 3.\n-                                                 \/\/ Indicates log2 of number of bytes (1, 2, 4, or 8)\n-                                                 \/\/ to scale index by.\n-\n- protected:\n-  UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)\n-  : UnsafeOp(basic_type, is_put)\n-  , _base(addr)\n-  , _index(NULL)\n-  , _log2_scale(0)\n-  {\n-    \/\/ Can not use ASSERT_VALUES because index may be NULL\n-    assert(addr != NULL && addr->type()->is_long(), \"just checking\");\n-  }\n-\n-  UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)\n-  : UnsafeOp(basic_type, is_put)\n-  , _base(base)\n-  , _index(index)\n-  , _log2_scale(log2_scale)\n-  {\n-  }\n-\n- public:\n-  \/\/ accessors\n-  Value base()                                   { return _base; }\n-  Value index()                                  { return _index; }\n-  bool  has_index()                              { return (_index != NULL); }\n-  int   log2_scale()                             { return _log2_scale; }\n-\n-  \/\/ setters\n-  void set_base (Value base)                     { _base  = base; }\n-  void set_index(Value index)                    { _index = index; }\n-  void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n-                                                   f->visit(&_base);\n-                                                   if (has_index()) f->visit(&_index); }\n+  virtual void input_values_do(ValueVisitor* f)   { f->visit(&_object);\n+                                                    f->visit(&_offset); }\n@@ -2329,2 +2284,1 @@\n-\n-LEAF(UnsafeGetRaw, UnsafeRawOp)\n+LEAF(UnsafeGet, UnsafeOp)\n@@ -2332,2 +2286,1 @@\n- bool _may_be_unaligned, _is_wide;  \/\/ For OSREntry\n-\n+  bool _is_raw;\n@@ -2335,25 +2288,2 @@\n- UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)\n-  : UnsafeRawOp(basic_type, addr, false) {\n-    _may_be_unaligned = may_be_unaligned;\n-    _is_wide = is_wide;\n-  }\n-\n- UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)\n-  : UnsafeRawOp(basic_type, base, index, log2_scale, false) {\n-    _may_be_unaligned = may_be_unaligned;\n-    _is_wide = is_wide;\n-  }\n-\n-  bool may_be_unaligned()                         { return _may_be_unaligned; }\n-  bool is_wide()                                  { return _is_wide; }\n-};\n-\n-\n-LEAF(UnsafePutRaw, UnsafeRawOp)\n- private:\n-  Value _value;                                  \/\/ Value to be stored\n-\n- public:\n-  UnsafePutRaw(BasicType basic_type, Value addr, Value value)\n-  : UnsafeRawOp(basic_type, addr, true)\n-  , _value(value)\n+  UnsafeGet(BasicType basic_type, Value object, Value offset, bool is_volatile)\n+  : UnsafeOp(basic_type, object, offset, false, is_volatile)\n@@ -2361,1 +2291,0 @@\n-    assert(value != NULL, \"just checking\");\n@@ -2363,0 +2292,1 @@\n+    _is_raw = false;\n@@ -2364,4 +2294,2 @@\n-\n-  UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)\n-  : UnsafeRawOp(basic_type, base, index, log2_scale, true)\n-  , _value(value)\n+  UnsafeGet(BasicType basic_type, Value object, Value offset, bool is_volatile, bool is_raw)\n+  : UnsafeOp(basic_type, object, offset, false, is_volatile), _is_raw(is_raw)\n@@ -2369,1 +2297,0 @@\n-    assert(value != NULL, \"just checking\");\n@@ -2374,27 +2301,1 @@\n-  Value value()                                  { return _value; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);\n-                                                   f->visit(&_value); }\n-};\n-\n-\n-BASE(UnsafeObjectOp, UnsafeOp)\n- private:\n-  Value _object;                                 \/\/ Object to be fetched from or mutated\n-  Value _offset;                                 \/\/ Offset within object\n-  bool  _is_volatile;                            \/\/ true if volatile - dl\/JSR166\n- public:\n-  UnsafeObjectOp(BasicType basic_type, Value object, Value offset, bool is_put, bool is_volatile)\n-    : UnsafeOp(basic_type, is_put), _object(object), _offset(offset), _is_volatile(is_volatile)\n-  {\n-  }\n-\n-  \/\/ accessors\n-  Value object()                                 { return _object; }\n-  Value offset()                                 { return _offset; }\n-  bool  is_volatile()                            { return _is_volatile; }\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n-                                                   f->visit(&_object);\n-                                                   f->visit(&_offset); }\n+  bool is_raw()                             { return _is_raw; }\n@@ -2404,11 +2305,1 @@\n-LEAF(UnsafeGetObject, UnsafeObjectOp)\n- public:\n-  UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile)\n-  : UnsafeObjectOp(basic_type, object, offset, false, is_volatile)\n-  {\n-    ASSERT_VALUES\n-  }\n-};\n-\n-\n-LEAF(UnsafePutObject, UnsafeObjectOp)\n+LEAF(UnsafePut, UnsafeOp)\n@@ -2418,2 +2309,2 @@\n-  UnsafePutObject(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)\n-  : UnsafeObjectOp(basic_type, object, offset, true, is_volatile)\n+  UnsafePut(BasicType basic_type, Value object, Value offset, Value value, bool is_volatile)\n+  : UnsafeOp(basic_type, object, offset, true, is_volatile)\n@@ -2429,1 +2320,1 @@\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);\n+  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n@@ -2433,1 +2324,1 @@\n-LEAF(UnsafeGetAndSetObject, UnsafeObjectOp)\n+LEAF(UnsafeGetAndSet, UnsafeOp)\n@@ -2438,2 +2329,2 @@\n-  UnsafeGetAndSetObject(BasicType basic_type, Value object, Value offset, Value value, bool is_add)\n-  : UnsafeObjectOp(basic_type, object, offset, false, false)\n+  UnsafeGetAndSet(BasicType basic_type, Value object, Value offset, Value value, bool is_add)\n+  : UnsafeOp(basic_type, object, offset, false, false)\n@@ -2451,1 +2342,1 @@\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeObjectOp::input_values_do(f);\n+  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":34,"deletions":143,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -266,16 +266,0 @@\n-  output()->print(\".(\");\n-}\n-\n-void InstructionPrinter::print_unsafe_raw_op(UnsafeRawOp* op, const char* name) {\n-  print_unsafe_op(op, name);\n-  output()->print(\"base \");\n-  print_value(op->base());\n-  if (op->has_index()) {\n-    output()->print(\", index \"); print_value(op->index());\n-    output()->print(\", log2_scale %d\", op->log2_scale());\n-  }\n-}\n-\n-\n-void InstructionPrinter::print_unsafe_object_op(UnsafeObjectOp* op, const char* name) {\n-  print_unsafe_op(op, name);\n@@ -817,11 +801,2 @@\n-\n-void InstructionPrinter::do_UnsafeGetRaw(UnsafeGetRaw* x) {\n-  print_unsafe_raw_op(x, \"UnsafeGetRaw\");\n-  output()->put(')');\n-}\n-\n-\n-void InstructionPrinter::do_UnsafePutRaw(UnsafePutRaw* x) {\n-  print_unsafe_raw_op(x, \"UnsafePutRaw\");\n-  output()->print(\", value \");\n-  print_value(x->value());\n+void InstructionPrinter::do_UnsafeGet(UnsafeGet* x) {\n+  print_unsafe_op(x, x->is_raw() ? \"UnsafeGet (raw)\" : \"UnsafeGet\");\n@@ -831,9 +806,2 @@\n-\n-void InstructionPrinter::do_UnsafeGetObject(UnsafeGetObject* x) {\n-  print_unsafe_object_op(x, \"UnsafeGetObject\");\n-  output()->put(')');\n-}\n-\n-\n-void InstructionPrinter::do_UnsafePutObject(UnsafePutObject* x) {\n-  print_unsafe_object_op(x, \"UnsafePutObject\");\n+void InstructionPrinter::do_UnsafePut(UnsafePut* x) {\n+  print_unsafe_op(x, \"UnsafePut\");\n@@ -845,2 +813,2 @@\n-void InstructionPrinter::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {\n-  print_unsafe_object_op(x, x->is_add()?\"UnsafeGetAndSetObject (add)\":\"UnsafeGetAndSetObject\");\n+void InstructionPrinter::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {\n+  print_unsafe_op(x, x->is_add()?\"UnsafeGetAndSet (add)\":\"UnsafeGetAndSet\");\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":6,"deletions":38,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -77,2 +77,0 @@\n-  void print_unsafe_raw_op(UnsafeRawOp* op, const char* name);\n-  void print_unsafe_object_op(UnsafeObjectOp* op, const char* name);\n@@ -127,5 +125,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x);\n-  virtual void do_UnsafePutObject(UnsafePutObject* x);\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  virtual void do_UnsafeGet      (UnsafeGet*       x);\n+  virtual void do_UnsafePut      (UnsafePut*       x);\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2079,5 +2079,0 @@\n-\/\/ Here UnsafeGetRaw may have x->base() and x->index() be int or long\n-\/\/ on both 64 and 32 bits. Expecting x->base() to be always long on 64bit.\n-void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {\n-  LIRItem base(x->base(), this);\n-  LIRItem idx(this);\n@@ -2085,177 +2080,1 @@\n-  base.load_item();\n-  if (x->has_index()) {\n-    idx.set_instruction(x->index());\n-    idx.load_nonconstant();\n-  }\n-\n-  LIR_Opr reg = rlock_result(x, x->basic_type());\n-\n-  int   log2_scale = 0;\n-  if (x->has_index()) {\n-    log2_scale = x->log2_scale();\n-  }\n-\n-  assert(!x->has_index() || idx.value() == x->index(), \"should match\");\n-\n-  LIR_Opr base_op = base.result();\n-  LIR_Opr index_op = idx.result();\n-#ifndef _LP64\n-  if (base_op->type() == T_LONG) {\n-    base_op = new_register(T_INT);\n-    __ convert(Bytecodes::_l2i, base.result(), base_op);\n-  }\n-  if (x->has_index()) {\n-    if (index_op->type() == T_LONG) {\n-      LIR_Opr long_index_op = index_op;\n-      if (index_op->is_constant()) {\n-        long_index_op = new_register(T_LONG);\n-        __ move(index_op, long_index_op);\n-      }\n-      index_op = new_register(T_INT);\n-      __ convert(Bytecodes::_l2i, long_index_op, index_op);\n-    } else {\n-      assert(x->index()->type()->tag() == intTag, \"must be\");\n-    }\n-  }\n-  \/\/ At this point base and index should be all ints.\n-  assert(base_op->type() == T_INT && !base_op->is_constant(), \"base should be an non-constant int\");\n-  assert(!x->has_index() || index_op->type() == T_INT, \"index should be an int\");\n-#else\n-  if (x->has_index()) {\n-    if (index_op->type() == T_INT) {\n-      if (!index_op->is_constant()) {\n-        index_op = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, idx.result(), index_op);\n-      }\n-    } else {\n-      assert(index_op->type() == T_LONG, \"must be\");\n-      if (index_op->is_constant()) {\n-        index_op = new_register(T_LONG);\n-        __ move(idx.result(), index_op);\n-      }\n-    }\n-  }\n-  \/\/ At this point base is a long non-constant\n-  \/\/ Index is a long register or a int constant.\n-  \/\/ We allow the constant to stay an int because that would allow us a more compact encoding by\n-  \/\/ embedding an immediate offset in the address expression. If we have a long constant, we have to\n-  \/\/ move it into a register first.\n-  assert(base_op->type() == T_LONG && !base_op->is_constant(), \"base must be a long non-constant\");\n-  assert(!x->has_index() || (index_op->type() == T_INT && index_op->is_constant()) ||\n-                            (index_op->type() == T_LONG && !index_op->is_constant()), \"unexpected index type\");\n-#endif\n-\n-  BasicType dst_type = x->basic_type();\n-\n-  LIR_Address* addr;\n-  if (index_op->is_constant()) {\n-    assert(log2_scale == 0, \"must not have a scale\");\n-    assert(index_op->type() == T_INT, \"only int constants supported\");\n-    addr = new LIR_Address(base_op, index_op->as_jint(), dst_type);\n-  } else {\n-#ifdef X86\n-    addr = new LIR_Address(base_op, index_op, LIR_Address::Scale(log2_scale), 0, dst_type);\n-#elif defined(GENERATE_ADDRESS_IS_PREFERRED)\n-    addr = generate_address(base_op, index_op, log2_scale, 0, dst_type);\n-#else\n-    if (index_op->is_illegal() || log2_scale == 0) {\n-      addr = new LIR_Address(base_op, index_op, dst_type);\n-    } else {\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index_op, log2_scale, tmp);\n-      addr = new LIR_Address(base_op, tmp, dst_type);\n-    }\n-#endif\n-  }\n-\n-  if (x->may_be_unaligned() && (dst_type == T_LONG || dst_type == T_DOUBLE)) {\n-    __ unaligned_move(addr, reg);\n-  } else {\n-    if (dst_type == T_OBJECT && x->is_wide()) {\n-      __ move_wide(addr, reg);\n-    } else {\n-      __ move(addr, reg);\n-    }\n-  }\n-}\n-\n-\n-void LIRGenerator::do_UnsafePutRaw(UnsafePutRaw* x) {\n-  int  log2_scale = 0;\n-  BasicType type = x->basic_type();\n-\n-  if (x->has_index()) {\n-    log2_scale = x->log2_scale();\n-  }\n-\n-  LIRItem base(x->base(), this);\n-  LIRItem value(x->value(), this);\n-  LIRItem idx(this);\n-\n-  base.load_item();\n-  if (x->has_index()) {\n-    idx.set_instruction(x->index());\n-    idx.load_item();\n-  }\n-\n-  if (type == T_BYTE || type == T_BOOLEAN) {\n-    value.load_byte_item();\n-  } else {\n-    value.load_item();\n-  }\n-\n-  set_no_result(x);\n-\n-  LIR_Opr base_op = base.result();\n-  LIR_Opr index_op = idx.result();\n-\n-#ifdef GENERATE_ADDRESS_IS_PREFERRED\n-  LIR_Address* addr = generate_address(base_op, index_op, log2_scale, 0, x->basic_type());\n-#else\n-#ifndef _LP64\n-  if (base_op->type() == T_LONG) {\n-    base_op = new_register(T_INT);\n-    __ convert(Bytecodes::_l2i, base.result(), base_op);\n-  }\n-  if (x->has_index()) {\n-    if (index_op->type() == T_LONG) {\n-      index_op = new_register(T_INT);\n-      __ convert(Bytecodes::_l2i, idx.result(), index_op);\n-    }\n-  }\n-  \/\/ At this point base and index should be all ints and not constants\n-  assert(base_op->type() == T_INT && !base_op->is_constant(), \"base should be an non-constant int\");\n-  assert(!x->has_index() || (index_op->type() == T_INT && !index_op->is_constant()), \"index should be an non-constant int\");\n-#else\n-  if (x->has_index()) {\n-    if (index_op->type() == T_INT) {\n-      index_op = new_register(T_LONG);\n-      __ convert(Bytecodes::_i2l, idx.result(), index_op);\n-    }\n-  }\n-  \/\/ At this point base and index are long and non-constant\n-  assert(base_op->type() == T_LONG && !base_op->is_constant(), \"base must be a non-constant long\");\n-  assert(!x->has_index() || (index_op->type() == T_LONG && !index_op->is_constant()), \"index must be a non-constant long\");\n-#endif\n-\n-  if (log2_scale != 0) {\n-    \/\/ temporary fix (platform dependent code without shift on Intel would be better)\n-    \/\/ TODO: ARM also allows embedded shift in the address\n-    LIR_Opr tmp = new_pointer_register();\n-    if (TwoOperandLIRForm) {\n-      __ move(index_op, tmp);\n-      index_op = tmp;\n-    }\n-    __ shift_left(index_op, log2_scale, tmp);\n-    if (!TwoOperandLIRForm) {\n-      index_op = tmp;\n-    }\n-  }\n-\n-  LIR_Address* addr = new LIR_Address(base_op, index_op, x->basic_type());\n-#endif \/\/ !GENERATE_ADDRESS_IS_PREFERRED\n-  __ move(value.result(), addr);\n-}\n-\n-\n-void LIRGenerator::do_UnsafeGetObject(UnsafeGetObject* x) {\n+void LIRGenerator::do_UnsafeGet(UnsafeGet* x) {\n@@ -2282,2 +2101,18 @@\n-  access_load_at(decorators, type,\n-                 src, off.result(), result);\n+  if (!x->is_raw()) {\n+    access_load_at(decorators, type, src, off.result(), result);\n+  } else {\n+    \/\/ Currently it is only used in GraphBuilder::setup_osr_entry_block.\n+    \/\/ It reads the value from [src + offset] directly.\n+#ifdef _LP64\n+    LIR_Opr offset = new_register(T_LONG);\n+    __ convert(Bytecodes::_i2l, off.result(), offset);\n+#else\n+    LIR_Opr offset = off.result();\n+#endif\n+    LIR_Address* addr = new LIR_Address(src.result(), offset, type);\n+    if (type == T_LONG || type == T_DOUBLE) {\n+      __ unaligned_move(addr, result);\n+    } else {\n+      access_load(IN_NATIVE, type, LIR_OprFact::address(addr), result);\n+    }\n+  }\n@@ -2287,1 +2122,1 @@\n-void LIRGenerator::do_UnsafePutObject(UnsafePutObject* x) {\n+void LIRGenerator::do_UnsafePut(UnsafePut* x) {\n@@ -2313,1 +2148,1 @@\n-void LIRGenerator::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {\n+void LIRGenerator::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":21,"deletions":186,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -588,5 +588,3 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  virtual void do_UnsafeGetObject(UnsafeGetObject* x);\n-  virtual void do_UnsafePutObject(UnsafePutObject* x);\n-  virtual void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  virtual void do_UnsafeGet      (UnsafeGet*       x);\n+  virtual void do_UnsafePut      (UnsafePut*       x);\n+  virtual void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -533,5 +533,3 @@\n-  void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  void do_UnsafePutRaw   (UnsafePutRaw*    x);\n-  void do_UnsafeGetObject(UnsafeGetObject* x);\n-  void do_UnsafePutObject(UnsafePutObject* x);\n-  void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x);\n+  void do_UnsafeGet      (UnsafeGet*       x);\n+  void do_UnsafePut      (UnsafePut*       x);\n+  void do_UnsafeGetAndSet(UnsafeGetAndSet* x);\n@@ -719,5 +717,3 @@\n-void NullCheckVisitor::do_UnsafeGetRaw   (UnsafeGetRaw*    x) {}\n-void NullCheckVisitor::do_UnsafePutRaw   (UnsafePutRaw*    x) {}\n-void NullCheckVisitor::do_UnsafeGetObject(UnsafeGetObject* x) {}\n-void NullCheckVisitor::do_UnsafePutObject(UnsafePutObject* x) {}\n-void NullCheckVisitor::do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) {}\n+void NullCheckVisitor::do_UnsafeGet      (UnsafeGet*       x) {}\n+void NullCheckVisitor::do_UnsafePut      (UnsafePut*       x) {}\n+void NullCheckVisitor::do_UnsafeGetAndSet(UnsafeGetAndSet* x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -136,2 +136,0 @@\n-    void do_UnsafePutRaw   (UnsafePutRaw*    x) { \/* nothing to do *\/ };\n-    void do_UnsafePutObject(UnsafePutObject* x) { \/* nothing to do *\/ };\n@@ -167,3 +165,3 @@\n-    void do_UnsafeGetRaw   (UnsafeGetRaw*    x) { \/* nothing to do *\/ };\n-    void do_UnsafeGetObject(UnsafeGetObject* x) { \/* nothing to do *\/ };\n-    void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) { \/* nothing to do *\/ };\n+    void do_UnsafePut      (UnsafePut*       x) { \/* nothing to do *\/ };\n+    void do_UnsafeGet      (UnsafeGet*       x) { \/* nothing to do *\/ };\n+    void do_UnsafeGetAndSet(UnsafeGetAndSet* x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -157,5 +157,3 @@\n-  void do_UnsafePutRaw   (UnsafePutRaw*    x) { kill_memory(); }\n-  void do_UnsafePutObject(UnsafePutObject* x) { kill_memory(); }\n-  void do_UnsafeGetAndSetObject(UnsafeGetAndSetObject* x) { kill_memory(); }\n-  void do_UnsafeGetRaw   (UnsafeGetRaw*    x) { \/* nothing to do *\/ }\n-  void do_UnsafeGetObject(UnsafeGetObject* x) {\n+  void do_UnsafePut      (UnsafePut*       x) { kill_memory(); }\n+  void do_UnsafeGetAndSet(UnsafeGetAndSet* x) { kill_memory(); }\n+  void do_UnsafeGet      (UnsafeGet*       x) {\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -300,6 +300,0 @@\n-  develop(bool, OptimizeUnsafes, true,                                      \\\n-          \"Optimize raw unsafe ops\")                                        \\\n-                                                                            \\\n-  develop(bool, PrintUnsafeOptimization, false,                             \\\n-          \"Print optimization of raw unsafe ops\")                           \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}