{"files":[{"patch":"@@ -79,1 +79,0 @@\n-#define GENERATE_ADDRESS_IS_PREFERRED\n","filename":"src\/hotspot\/cpu\/arm\/c1_Defs_arm.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -897,153 +897,0 @@\n-\n-static bool match_index_and_scale(Instruction*  instr,\n-                                  Instruction** index,\n-                                  int*          log2_scale) {\n-  \/\/ Skip conversion ops. This works only on 32bit because of the implicit l2i that the\n-  \/\/ unsafe performs.\n-#ifndef _LP64\n-  Convert* convert = instr->as_Convert();\n-  if (convert != NULL && convert->op() == Bytecodes::_i2l) {\n-    assert(convert->value()->type() == intType, \"invalid input type\");\n-    instr = convert->value();\n-  }\n-#endif\n-\n-  ShiftOp* shift = instr->as_ShiftOp();\n-  if (shift != NULL) {\n-    if (shift->op() == Bytecodes::_lshl) {\n-      assert(shift->x()->type() == longType, \"invalid input type\");\n-    } else {\n-#ifndef _LP64\n-      if (shift->op() == Bytecodes::_ishl) {\n-        assert(shift->x()->type() == intType, \"invalid input type\");\n-      } else {\n-        return false;\n-      }\n-#else\n-      return false;\n-#endif\n-    }\n-\n-\n-    \/\/ Constant shift value?\n-    Constant* con = shift->y()->as_Constant();\n-    if (con == NULL) return false;\n-    \/\/ Well-known type and value?\n-    IntConstant* val = con->type()->as_IntConstant();\n-    assert(val != NULL, \"Should be an int constant\");\n-\n-    *index = shift->x();\n-    int tmp_scale = val->value();\n-    if (tmp_scale >= 0 && tmp_scale < 4) {\n-      *log2_scale = tmp_scale;\n-      return true;\n-    } else {\n-      return false;\n-    }\n-  }\n-\n-  ArithmeticOp* arith = instr->as_ArithmeticOp();\n-  if (arith != NULL) {\n-    \/\/ See if either arg is a known constant\n-    Constant* con = arith->x()->as_Constant();\n-    if (con != NULL) {\n-      *index = arith->y();\n-    } else {\n-      con = arith->y()->as_Constant();\n-      if (con == NULL) return false;\n-      *index = arith->x();\n-    }\n-    long const_value;\n-    \/\/ Check for integer multiply\n-    if (arith->op() == Bytecodes::_lmul) {\n-      assert((*index)->type() == longType, \"invalid input type\");\n-      LongConstant* val = con->type()->as_LongConstant();\n-      assert(val != NULL, \"expecting a long constant\");\n-      const_value = val->value();\n-    } else {\n-#ifndef _LP64\n-      if (arith->op() == Bytecodes::_imul) {\n-        assert((*index)->type() == intType, \"invalid input type\");\n-        IntConstant* val = con->type()->as_IntConstant();\n-        assert(val != NULL, \"expecting an int constant\");\n-        const_value = val->value();\n-      } else {\n-        return false;\n-      }\n-#else\n-      return false;\n-#endif\n-    }\n-    switch (const_value) {\n-    case 1: *log2_scale = 0; return true;\n-    case 2: *log2_scale = 1; return true;\n-    case 4: *log2_scale = 2; return true;\n-    case 8: *log2_scale = 3; return true;\n-    default:            return false;\n-    }\n-  }\n-\n-  \/\/ Unknown instruction sequence; don't touch it\n-  return false;\n-}\n-\n-\n-static bool match(UnsafeRawOp* x,\n-                  Instruction** base,\n-                  Instruction** index,\n-                  int*          log2_scale) {\n-  ArithmeticOp* root = x->base()->as_ArithmeticOp();\n-  if (root == NULL) return false;\n-  \/\/ Limit ourselves to addition for now\n-  if (root->op() != Bytecodes::_ladd) return false;\n-\n-  bool match_found = false;\n-  \/\/ Try to find shift or scale op\n-  if (match_index_and_scale(root->y(), index, log2_scale)) {\n-    *base = root->x();\n-    match_found = true;\n-  } else if (match_index_and_scale(root->x(), index, log2_scale)) {\n-    *base = root->y();\n-    match_found = true;\n-  } else if (NOT_LP64(root->y()->as_Convert() != NULL) LP64_ONLY(false)) {\n-    \/\/ Skipping i2l works only on 32bit because of the implicit l2i that the unsafe performs.\n-    \/\/ 64bit needs a real sign-extending conversion.\n-    Convert* convert = root->y()->as_Convert();\n-    if (convert->op() == Bytecodes::_i2l) {\n-      assert(convert->value()->type() == intType, \"should be an int\");\n-      \/\/ pick base and index, setting scale at 1\n-      *base  = root->x();\n-      *index = convert->value();\n-      *log2_scale = 0;\n-      match_found = true;\n-    }\n-  }\n-  \/\/ The default solution\n-  if (!match_found) {\n-    *base = root->x();\n-    *index = root->y();\n-    *log2_scale = 0;\n-  }\n-\n-  \/\/ If the value is pinned then it will be always be computed so\n-  \/\/ there's no profit to reshaping the expression.\n-  return !root->is_pinned();\n-}\n-\n-\n-void Canonicalizer::do_UnsafeRawOp(UnsafeRawOp* x) {\n-  Instruction* base = NULL;\n-  Instruction* index = NULL;\n-  int          log2_scale;\n-\n-  if (match(x, &base, &index, &log2_scale)) {\n-    x->set_base(base);\n-    x->set_index(index);\n-    x->set_log2_scale(log2_scale);\n-    if (PrintUnsafeOptimization) {\n-      tty->print_cr(\"Canonicalizer: UnsafeRawOp id %d: base = id %d, index = id %d, log2_scale = %d\",\n-                    x->id(), x->base()->id(), x->index()->id(), x->log2_scale());\n-    }\n-  }\n-}\n-\n@@ -1051,2 +898,0 @@\n-void Canonicalizer::do_UnsafeGetRaw(UnsafeGetRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }\n-void Canonicalizer::do_UnsafePutRaw(UnsafePutRaw* x) { if (OptimizeUnsafes) do_UnsafeRawOp(x); }\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.cpp","additions":0,"deletions":155,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -49,6 +49,0 @@\n-  void do_UnsafeRawOp(UnsafeRawOp* x);\n-\n-  void unsafe_raw_match(UnsafeRawOp* x,\n-                        Instruction** base,\n-                        Instruction** index,\n-                        int* scale);\n@@ -103,2 +97,0 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n","filename":"src\/hotspot\/share\/c1\/c1_Canonicalizer.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3151,4 +3151,5 @@\n-      get = append(new UnsafeGetRaw(as_BasicType(local->type()), e,\n-                                    append(new Constant(new IntConstant(offset))),\n-                                    0,\n-                                    true \/*unaligned*\/, true \/*wide*\/));\n+      Value off_val = append(new Constant(new IntConstant(offset)));\n+      get = append(new UnsafeGetObject(as_BasicType(local->type()), e,\n+                                      off_val,\n+                                      false\/*is_volatile*\/,\n+                                      true\/*is_raw_get*\/));\n@@ -4251,18 +4252,0 @@\n-\n-void GraphBuilder::append_unsafe_get_raw(ciMethod* callee, BasicType t) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-  null_check(args->at(0));\n-  Instruction* op = append(new UnsafeGetRaw(t, args->at(1), false));\n-  push(op->type(), op);\n-  compilation()->set_has_unsafe_access(true);\n-}\n-\n-\n-void GraphBuilder::append_unsafe_put_raw(ciMethod* callee, BasicType t) {\n-  Values* args = state()->pop_arguments(callee->arg_size());\n-  null_check(args->at(0));\n-  Instruction* op = append(new UnsafePutRaw(t, args->at(1), args->at(2)));\n-  compilation()->set_has_unsafe_access(true);\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -378,2 +378,0 @@\n-  void append_unsafe_get_raw(ciMethod* callee, BasicType t);\n-  void append_unsafe_put_raw(ciMethod* callee, BasicType t);\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -99,3 +99,0 @@\n-class     UnsafeRawOp;\n-class       UnsafeGetRaw;\n-class       UnsafePutRaw;\n@@ -200,2 +197,0 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x) = 0;\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x) = 0;\n@@ -2284,98 +2279,0 @@\n-BASE(UnsafeRawOp, UnsafeOp)\n- private:\n-  Value _base;                                   \/\/ Base address (a Java long)\n-  Value _index;                                  \/\/ Index if computed by optimizer; initialized to NULL\n-  int   _log2_scale;                             \/\/ Scale factor: 0, 1, 2, or 3.\n-                                                 \/\/ Indicates log2 of number of bytes (1, 2, 4, or 8)\n-                                                 \/\/ to scale index by.\n-\n- protected:\n-  UnsafeRawOp(BasicType basic_type, Value addr, bool is_put)\n-  : UnsafeOp(basic_type, is_put)\n-  , _base(addr)\n-  , _index(NULL)\n-  , _log2_scale(0)\n-  {\n-    \/\/ Can not use ASSERT_VALUES because index may be NULL\n-    assert(addr != NULL && addr->type()->is_long(), \"just checking\");\n-  }\n-\n-  UnsafeRawOp(BasicType basic_type, Value base, Value index, int log2_scale, bool is_put)\n-  : UnsafeOp(basic_type, is_put)\n-  , _base(base)\n-  , _index(index)\n-  , _log2_scale(log2_scale)\n-  {\n-  }\n-\n- public:\n-  \/\/ accessors\n-  Value base()                                   { return _base; }\n-  Value index()                                  { return _index; }\n-  bool  has_index()                              { return (_index != NULL); }\n-  int   log2_scale()                             { return _log2_scale; }\n-\n-  \/\/ setters\n-  void set_base (Value base)                     { _base  = base; }\n-  void set_index(Value index)                    { _index = index; }\n-  void set_log2_scale(int log2_scale)            { _log2_scale = log2_scale; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeOp::input_values_do(f);\n-                                                   f->visit(&_base);\n-                                                   if (has_index()) f->visit(&_index); }\n-};\n-\n-\n-LEAF(UnsafeGetRaw, UnsafeRawOp)\n- private:\n- bool _may_be_unaligned, _is_wide;  \/\/ For OSREntry\n-\n- public:\n- UnsafeGetRaw(BasicType basic_type, Value addr, bool may_be_unaligned, bool is_wide = false)\n-  : UnsafeRawOp(basic_type, addr, false) {\n-    _may_be_unaligned = may_be_unaligned;\n-    _is_wide = is_wide;\n-  }\n-\n- UnsafeGetRaw(BasicType basic_type, Value base, Value index, int log2_scale, bool may_be_unaligned, bool is_wide = false)\n-  : UnsafeRawOp(basic_type, base, index, log2_scale, false) {\n-    _may_be_unaligned = may_be_unaligned;\n-    _is_wide = is_wide;\n-  }\n-\n-  bool may_be_unaligned()                         { return _may_be_unaligned; }\n-  bool is_wide()                                  { return _is_wide; }\n-};\n-\n-\n-LEAF(UnsafePutRaw, UnsafeRawOp)\n- private:\n-  Value _value;                                  \/\/ Value to be stored\n-\n- public:\n-  UnsafePutRaw(BasicType basic_type, Value addr, Value value)\n-  : UnsafeRawOp(basic_type, addr, true)\n-  , _value(value)\n-  {\n-    assert(value != NULL, \"just checking\");\n-    ASSERT_VALUES\n-  }\n-\n-  UnsafePutRaw(BasicType basic_type, Value base, Value index, int log2_scale, Value value)\n-  : UnsafeRawOp(basic_type, base, index, log2_scale, true)\n-  , _value(value)\n-  {\n-    assert(value != NULL, \"just checking\");\n-    ASSERT_VALUES\n-  }\n-\n-  \/\/ accessors\n-  Value value()                                  { return _value; }\n-\n-  \/\/ generic\n-  virtual void input_values_do(ValueVisitor* f)   { UnsafeRawOp::input_values_do(f);\n-                                                   f->visit(&_value); }\n-};\n-\n-\n@@ -2405,0 +2302,2 @@\n+ private:\n+  bool _is_raw_get;\n@@ -2410,0 +2309,1 @@\n+    _is_raw_get = false;\n@@ -2411,0 +2311,8 @@\n+  UnsafeGetObject(BasicType basic_type, Value object, Value offset, bool is_volatile, bool is_raw_get)\n+  : UnsafeObjectOp(basic_type, object, offset, false, is_volatile), _is_raw_get(is_raw_get)\n+  {\n+    ASSERT_VALUES\n+  }\n+\n+  \/\/ accessors\n+  bool is_raw_get()                             { return _is_raw_get; }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":11,"deletions":103,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -269,11 +269,0 @@\n-void InstructionPrinter::print_unsafe_raw_op(UnsafeRawOp* op, const char* name) {\n-  print_unsafe_op(op, name);\n-  output()->print(\"base \");\n-  print_value(op->base());\n-  if (op->has_index()) {\n-    output()->print(\", index \"); print_value(op->index());\n-    output()->print(\", log2_scale %d\", op->log2_scale());\n-  }\n-}\n-\n-\n@@ -817,15 +806,0 @@\n-\n-void InstructionPrinter::do_UnsafeGetRaw(UnsafeGetRaw* x) {\n-  print_unsafe_raw_op(x, \"UnsafeGetRaw\");\n-  output()->put(')');\n-}\n-\n-\n-void InstructionPrinter::do_UnsafePutRaw(UnsafePutRaw* x) {\n-  print_unsafe_raw_op(x, \"UnsafePutRaw\");\n-  output()->print(\", value \");\n-  print_value(x->value());\n-  output()->put(')');\n-}\n-\n-\n@@ -837,1 +811,0 @@\n-\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -77,1 +77,0 @@\n-  void print_unsafe_raw_op(UnsafeRawOp* op, const char* name);\n@@ -127,2 +126,0 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n","filename":"src\/hotspot\/share\/c1\/c1_InstructionPrinter.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2079,181 +2079,0 @@\n-\/\/ Here UnsafeGetRaw may have x->base() and x->index() be int or long\n-\/\/ on both 64 and 32 bits. Expecting x->base() to be always long on 64bit.\n-void LIRGenerator::do_UnsafeGetRaw(UnsafeGetRaw* x) {\n-  LIRItem base(x->base(), this);\n-  LIRItem idx(this);\n-\n-  base.load_item();\n-  if (x->has_index()) {\n-    idx.set_instruction(x->index());\n-    idx.load_nonconstant();\n-  }\n-\n-  LIR_Opr reg = rlock_result(x, x->basic_type());\n-\n-  int   log2_scale = 0;\n-  if (x->has_index()) {\n-    log2_scale = x->log2_scale();\n-  }\n-\n-  assert(!x->has_index() || idx.value() == x->index(), \"should match\");\n-\n-  LIR_Opr base_op = base.result();\n-  LIR_Opr index_op = idx.result();\n-#ifndef _LP64\n-  if (base_op->type() == T_LONG) {\n-    base_op = new_register(T_INT);\n-    __ convert(Bytecodes::_l2i, base.result(), base_op);\n-  }\n-  if (x->has_index()) {\n-    if (index_op->type() == T_LONG) {\n-      LIR_Opr long_index_op = index_op;\n-      if (index_op->is_constant()) {\n-        long_index_op = new_register(T_LONG);\n-        __ move(index_op, long_index_op);\n-      }\n-      index_op = new_register(T_INT);\n-      __ convert(Bytecodes::_l2i, long_index_op, index_op);\n-    } else {\n-      assert(x->index()->type()->tag() == intTag, \"must be\");\n-    }\n-  }\n-  \/\/ At this point base and index should be all ints.\n-  assert(base_op->type() == T_INT && !base_op->is_constant(), \"base should be an non-constant int\");\n-  assert(!x->has_index() || index_op->type() == T_INT, \"index should be an int\");\n-#else\n-  if (x->has_index()) {\n-    if (index_op->type() == T_INT) {\n-      if (!index_op->is_constant()) {\n-        index_op = new_register(T_LONG);\n-        __ convert(Bytecodes::_i2l, idx.result(), index_op);\n-      }\n-    } else {\n-      assert(index_op->type() == T_LONG, \"must be\");\n-      if (index_op->is_constant()) {\n-        index_op = new_register(T_LONG);\n-        __ move(idx.result(), index_op);\n-      }\n-    }\n-  }\n-  \/\/ At this point base is a long non-constant\n-  \/\/ Index is a long register or a int constant.\n-  \/\/ We allow the constant to stay an int because that would allow us a more compact encoding by\n-  \/\/ embedding an immediate offset in the address expression. If we have a long constant, we have to\n-  \/\/ move it into a register first.\n-  assert(base_op->type() == T_LONG && !base_op->is_constant(), \"base must be a long non-constant\");\n-  assert(!x->has_index() || (index_op->type() == T_INT && index_op->is_constant()) ||\n-                            (index_op->type() == T_LONG && !index_op->is_constant()), \"unexpected index type\");\n-#endif\n-\n-  BasicType dst_type = x->basic_type();\n-\n-  LIR_Address* addr;\n-  if (index_op->is_constant()) {\n-    assert(log2_scale == 0, \"must not have a scale\");\n-    assert(index_op->type() == T_INT, \"only int constants supported\");\n-    addr = new LIR_Address(base_op, index_op->as_jint(), dst_type);\n-  } else {\n-#ifdef X86\n-    addr = new LIR_Address(base_op, index_op, LIR_Address::Scale(log2_scale), 0, dst_type);\n-#elif defined(GENERATE_ADDRESS_IS_PREFERRED)\n-    addr = generate_address(base_op, index_op, log2_scale, 0, dst_type);\n-#else\n-    if (index_op->is_illegal() || log2_scale == 0) {\n-      addr = new LIR_Address(base_op, index_op, dst_type);\n-    } else {\n-      LIR_Opr tmp = new_pointer_register();\n-      __ shift_left(index_op, log2_scale, tmp);\n-      addr = new LIR_Address(base_op, tmp, dst_type);\n-    }\n-#endif\n-  }\n-\n-  if (x->may_be_unaligned() && (dst_type == T_LONG || dst_type == T_DOUBLE)) {\n-    __ unaligned_move(addr, reg);\n-  } else {\n-    if (dst_type == T_OBJECT && x->is_wide()) {\n-      __ move_wide(addr, reg);\n-    } else {\n-      __ move(addr, reg);\n-    }\n-  }\n-}\n-\n-\n-void LIRGenerator::do_UnsafePutRaw(UnsafePutRaw* x) {\n-  int  log2_scale = 0;\n-  BasicType type = x->basic_type();\n-\n-  if (x->has_index()) {\n-    log2_scale = x->log2_scale();\n-  }\n-\n-  LIRItem base(x->base(), this);\n-  LIRItem value(x->value(), this);\n-  LIRItem idx(this);\n-\n-  base.load_item();\n-  if (x->has_index()) {\n-    idx.set_instruction(x->index());\n-    idx.load_item();\n-  }\n-\n-  if (type == T_BYTE || type == T_BOOLEAN) {\n-    value.load_byte_item();\n-  } else {\n-    value.load_item();\n-  }\n-\n-  set_no_result(x);\n-\n-  LIR_Opr base_op = base.result();\n-  LIR_Opr index_op = idx.result();\n-\n-#ifdef GENERATE_ADDRESS_IS_PREFERRED\n-  LIR_Address* addr = generate_address(base_op, index_op, log2_scale, 0, x->basic_type());\n-#else\n-#ifndef _LP64\n-  if (base_op->type() == T_LONG) {\n-    base_op = new_register(T_INT);\n-    __ convert(Bytecodes::_l2i, base.result(), base_op);\n-  }\n-  if (x->has_index()) {\n-    if (index_op->type() == T_LONG) {\n-      index_op = new_register(T_INT);\n-      __ convert(Bytecodes::_l2i, idx.result(), index_op);\n-    }\n-  }\n-  \/\/ At this point base and index should be all ints and not constants\n-  assert(base_op->type() == T_INT && !base_op->is_constant(), \"base should be an non-constant int\");\n-  assert(!x->has_index() || (index_op->type() == T_INT && !index_op->is_constant()), \"index should be an non-constant int\");\n-#else\n-  if (x->has_index()) {\n-    if (index_op->type() == T_INT) {\n-      index_op = new_register(T_LONG);\n-      __ convert(Bytecodes::_i2l, idx.result(), index_op);\n-    }\n-  }\n-  \/\/ At this point base and index are long and non-constant\n-  assert(base_op->type() == T_LONG && !base_op->is_constant(), \"base must be a non-constant long\");\n-  assert(!x->has_index() || (index_op->type() == T_LONG && !index_op->is_constant()), \"index must be a non-constant long\");\n-#endif\n-\n-  if (log2_scale != 0) {\n-    \/\/ temporary fix (platform dependent code without shift on Intel would be better)\n-    \/\/ TODO: ARM also allows embedded shift in the address\n-    LIR_Opr tmp = new_pointer_register();\n-    if (TwoOperandLIRForm) {\n-      __ move(index_op, tmp);\n-      index_op = tmp;\n-    }\n-    __ shift_left(index_op, log2_scale, tmp);\n-    if (!TwoOperandLIRForm) {\n-      index_op = tmp;\n-    }\n-  }\n-\n-  LIR_Address* addr = new LIR_Address(base_op, index_op, x->basic_type());\n-#endif \/\/ !GENERATE_ADDRESS_IS_PREFERRED\n-  __ move(value.result(), addr);\n-}\n-\n@@ -2282,2 +2101,13 @@\n-  access_load_at(decorators, type,\n-                 src, off.result(), result);\n+  if (!x->is_raw_get()) {\n+    access_load_at(decorators, type,\n+                  src, off.result(), result);\n+  } else {\n+#ifdef _LP64\n+  LIR_Opr offset = new_register(T_LONG);\n+  __ convert(Bytecodes::_i2l, off.result(), offset);\n+#else\n+  LIR_Opr offset = off.result();\n+#endif\n+    access_load(IN_NATIVE, type,\n+                LIR_OprFact::address(new LIR_Address(src.result(), offset, type)), result);\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":13,"deletions":183,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -588,2 +588,0 @@\n-  virtual void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  virtual void do_UnsafePutRaw   (UnsafePutRaw*    x);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -533,2 +533,0 @@\n-  void do_UnsafeGetRaw   (UnsafeGetRaw*    x);\n-  void do_UnsafePutRaw   (UnsafePutRaw*    x);\n@@ -719,2 +717,0 @@\n-void NullCheckVisitor::do_UnsafeGetRaw   (UnsafeGetRaw*    x) {}\n-void NullCheckVisitor::do_UnsafePutRaw   (UnsafePutRaw*    x) {}\n","filename":"src\/hotspot\/share\/c1\/c1_Optimizer.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,0 @@\n-    void do_UnsafePutRaw   (UnsafePutRaw*    x) { \/* nothing to do *\/ };\n@@ -167,1 +166,0 @@\n-    void do_UnsafeGetRaw   (UnsafeGetRaw*    x) { \/* nothing to do *\/ };\n","filename":"src\/hotspot\/share\/c1\/c1_RangeCheckElimination.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,0 @@\n-  void do_UnsafePutRaw   (UnsafePutRaw*    x) { kill_memory(); }\n@@ -160,1 +159,0 @@\n-  void do_UnsafeGetRaw   (UnsafeGetRaw*    x) { \/* nothing to do *\/ }\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -300,6 +300,0 @@\n-  develop(bool, OptimizeUnsafes, true,                                      \\\n-          \"Optimize raw unsafe ops\")                                        \\\n-                                                                            \\\n-  develop(bool, PrintUnsafeOptimization, false,                             \\\n-          \"Print optimization of raw unsafe ops\")                           \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/c1\/c1_globals.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}