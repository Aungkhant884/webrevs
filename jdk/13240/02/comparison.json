{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-ifeq ($(call isTargetOs, linux macosx windows), true)\n+ifeq ($(call isTargetOs, linux macosx windows aix), true)\n","filename":"make\/modules\/jdk.net\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.net;\n+\n+import java.net.SocketException;\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import jdk.net.ExtendedSocketOptions.PlatformSocketOptions;\n+import sun.nio.fs.UnixUserPrincipals;\n+\n+@SuppressWarnings(\"removal\")\n+class AIXSocketOptions extends PlatformSocketOptions {\n+\n+    public AIXSocketOptions() {\n+    }\n+\n+    @Override\n+    void setQuickAck(int fd, boolean on) throws SocketException {\n+        setQuickAck0(fd, on);\n+    }\n+\n+    @Override\n+    boolean getQuickAck(int fd) throws SocketException {\n+        return getQuickAck0(fd);\n+    }\n+\n+    @Override\n+    public boolean quickAckSupported() {\n+        return quickAckSupported0();\n+    }\n+\n+    @Override\n+    boolean keepAliveOptionsSupported() {\n+        return keepAliveOptionsSupported0();\n+    }\n+\n+    @Override\n+    boolean ipDontFragmentSupported() {\n+        return true;\n+    }\n+\n+    boolean peerCredentialsSupported() {\n+        return true;\n+    }\n+\n+    @Override\n+    void setTcpkeepAliveProbes(int fd, final int value) throws SocketException {\n+        setTcpkeepAliveProbes0(fd, value);\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveTime(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveTime0(fd, value);\n+    }\n+\n+    @Override\n+    void setTcpKeepAliveIntvl(int fd, final int value) throws SocketException {\n+        setTcpKeepAliveIntvl0(fd, value);\n+    }\n+\n+    @Override\n+    int getTcpkeepAliveProbes(int fd) throws SocketException {\n+        return getTcpkeepAliveProbes0(fd);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveTime(int fd) throws SocketException {\n+        return getTcpKeepAliveTime0(fd);\n+    }\n+\n+    @Override\n+    int getTcpKeepAliveIntvl(int fd) throws SocketException {\n+        return getTcpKeepAliveIntvl0(fd);\n+    }\n+\n+    @Override\n+    void setIpDontFragment(int fd, final boolean value, boolean isIPv6) throws SocketException {\n+        setIpDontFragment0(fd, value, isIPv6);\n+    }\n+\n+    @Override\n+    boolean getIpDontFragment(int fd, boolean isIPv6) throws SocketException {\n+        return getIpDontFragment0(fd, isIPv6);\n+    }\n+\n+    @Override\n+    UnixDomainPrincipal getSoPeerCred(int fd) throws SocketException {\n+        long l = getSoPeerCred0(fd);\n+        int euid = (int)(l >> 32);\n+        int egid = (int)l;\n+        UserPrincipal user = UnixUserPrincipals.fromUid(euid);\n+        GroupPrincipal group = UnixUserPrincipals.fromGid(egid);\n+        return new UnixDomainPrincipal(user, group);\n+    }\n+\n+    private static native void setTcpkeepAliveProbes0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveTime0(int fd, int value) throws SocketException;\n+    private static native void setTcpKeepAliveIntvl0(int fd, int value) throws SocketException;\n+    private static native void setIpDontFragment0(int fd, boolean value, boolean isIPv6) throws SocketException;\n+    private static native int getTcpkeepAliveProbes0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveTime0(int fd) throws SocketException;\n+    private static native int getTcpKeepAliveIntvl0(int fd) throws SocketException;\n+    private static native boolean getIpDontFragment0(int fd, boolean isIPv6) throws SocketException;\n+    private static native void setQuickAck0(int fd, boolean on) throws SocketException;\n+    private static native boolean getQuickAck0(int fd) throws SocketException;\n+    private static native long getSoPeerCred0(int fd) throws SocketException;\n+    private static native boolean keepAliveOptionsSupported0();\n+    private static native boolean quickAckSupported0();\n+    static {\n+        if (System.getSecurityManager() == null) {\n+            System.loadLibrary(\"extnet\");\n+        } else {\n+            AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+                System.loadLibrary(\"extnet\");\n+                return null;\n+            });\n+        }\n+    }\n+}\n","filename":"src\/jdk.net\/aix\/classes\/jdk\/net\/AIXSocketOptions.java","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+#include <sys\/socket.h>\n+#include <sys\/un.h>\n+#include <sys\/types.h>\n+#include <string.h>\n+#include <errno.h>\n+#include <unistd.h>\n+\n+#include <jni.h>\n+#include <netinet\/tcp.h>\n+#include <netinet\/in.h>\n+#include \"jni_util.h\"\n+#include \"jdk_net_AIXSocketOptions.h\"\n+\n+\n+static void handleError(JNIEnv *env, jint rv, const char *errmsg) {\n+    if (rv < 0) {\n+        if (errno == ENOPROTOOPT) {\n+            JNU_ThrowByName(env, \"java\/lang\/UnsupportedOperationException\",\n+                    \"unsupported socket option\");\n+        } else {\n+            JNU_ThrowByNameWithLastError(env, \"java\/net\/SocketException\", errmsg);\n+        }\n+    }\n+}\n+\n+static jint socketOptionSupported(jint level, jint optname) {\n+    jint one = 1;\n+    jint rv, s;\n+    socklen_t sz = sizeof (one);\n+    \/* First try IPv6; fall back to IPv4. *\/\n+    s = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP);\n+    if (s < 0) {\n+        if (errno == EPFNOSUPPORT || errno == EAFNOSUPPORT) {\n+            s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);\n+        }\n+        if (s < 0) {\n+            return 0;\n+        }\n+    }\n+    rv = getsockopt(s, level, optname, (void *) &one, &sz);\n+    if (rv != 0 && errno == ENOPROTOOPT) {\n+        rv = 0;\n+    } else {\n+        rv = 1;\n+    }\n+    close(s);\n+    return rv;\n+}\n+\n+\/*\n+ * Declare library specific JNI_Onload entry if static build\n+ *\/\n+DEF_STATIC_JNI_OnLoad\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    setQuickAck\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setQuickAck0\n+(JNIEnv *env, jobject unused, jint fd, jboolean on) {\n+    int optval;\n+    int rv;\n+    optval = (on ? 1 : 0);\n+    rv = setsockopt(fd, SOL_SOCKET, TCP_NODELAYACK, &optval, sizeof (optval));\n+    handleError(env, rv, \"set option TCP_NODELAYACK failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    getQuickAck\n+ * Signature: (I)Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_AIXSocketOptions_getQuickAck0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    int on;\n+    socklen_t sz = sizeof (on);\n+    int rv = getsockopt(fd, SOL_SOCKET, TCP_NODELAYACK, &on, &sz);\n+    handleError(env, rv, \"get option TCP_NODELAYACK failed\");\n+    return on != 0;\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    quickAckSupported\n+ * Signature: ()Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_AIXSocketOptions_quickAckSupported0\n+(JNIEnv *env, jobject unused) {\n+    return socketOptionSupported(SOL_SOCKET, TCP_NODELAYACK);\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    getSoPeerCred0\n+ * Signature: (I)L\n+ *\/\n+JNIEXPORT jlong JNICALL Java_jdk_net_AIXSocketOptions_getSoPeerCred0\n+  (JNIEnv *env, jclass clazz, jint fd) {\n+\n+    int rv;\n+    struct peercred_struct cred_info;\n+    socklen_t len = sizeof(cred_info);\n+\n+    if ((rv=getsockopt(fd, SOL_SOCKET, SO_PEERID, &cred_info, &len)) < 0) {\n+        handleError(env, rv, \"get  failed\");\n+    } else {\n+        if ((int)cred_info.euid == -1) {\n+            handleError(env, -1, \"get  failed\");\n+            cred_info.euid = cred_info.egid = -1;\n+        }\n+    }\n+    return (((jlong)cred_info.euid) << 32) | (cred_info.egid & 0xffffffffL);\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    keepAliveOptionsSupported0\n+ * Signature: ()Z\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_AIXSocketOptions_keepAliveOptionsSupported0\n+(JNIEnv *env, jobject unused) {\n+    return socketOptionSupported(IPPROTO_TCP, TCP_KEEPIDLE) && socketOptionSupported(IPPROTO_TCP, TCP_KEEPCNT)\n+            && socketOptionSupported(IPPROTO_TCP, TCP_KEEPINTVL);\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    setTcpkeepAliveProbes0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setTcpkeepAliveProbes0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &optval, sizeof (optval));\n+    handleError(env, rv, \"set option TCP_KEEPCNT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    setTcpKeepAliveTime0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setTcpKeepAliveTime0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &optval, sizeof (optval));\n+    handleError(env, rv, \"set option TCP_KEEPIDLE failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    setTcpKeepAliveIntvl0\n+ * Signature: (II)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setTcpKeepAliveIntvl0\n+(JNIEnv *env, jobject unused, jint fd, jint optval) {\n+    jint rv = setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &optval, sizeof (optval));\n+    handleError(env, rv, \"set option TCP_KEEPINTVL failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    getTcpkeepAliveProbes0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_AIXSocketOptions_getTcpkeepAliveProbes0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof (optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPCNT failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    getTcpKeepAliveTime0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_AIXSocketOptions_getTcpKeepAliveTime0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof (optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPIDLE failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    getTcpKeepAliveIntvl0\n+ * Signature: (I)I;\n+ *\/\n+JNIEXPORT jint JNICALL Java_jdk_net_AIXSocketOptions_getTcpKeepAliveIntvl0\n+(JNIEnv *env, jobject unused, jint fd) {\n+    jint optval, rv;\n+    socklen_t sz = sizeof (optval);\n+    rv = getsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &optval, &sz);\n+    handleError(env, rv, \"get option TCP_KEEPINTVL failed\");\n+    return optval;\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    setIpDontFragment0\n+ * Signature: (IZZ)V\n+ *\/\n+JNIEXPORT void JNICALL Java_jdk_net_AIXSocketOptions_setIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd, jboolean optval, jboolean isIPv6) {\n+    jint rv, optsetting;\n+\n+    \/\/optsetting = optval ? IP_PMTUDISC_DO\/IP_DONTFRAG : IP_PMTUDISC_DONT;\n+    optsetting = optval ? 1 : 0;\n+    if (!isIPv6) {\n+        rv = setsockopt(fd, IPPROTO_IP, IP_DONTFRAG, &optsetting, sizeof (optsetting));\n+    } else {\n+        rv = setsockopt(fd, IPPROTO_IPV6, IPV6_DONTFRAG, &optsetting, sizeof (optsetting));\n+    }\n+    handleError(env, rv, \"set option IP_DONTFRAGMENT failed\");\n+}\n+\n+\/*\n+ * Class:     jdk_net_AIXSocketOptions\n+ * Method:    getIpDontFragment0\n+ * Signature: (IZ)Z;\n+ *\/\n+JNIEXPORT jboolean JNICALL Java_jdk_net_AIXSocketOptions_getIpDontFragment0\n+(JNIEnv *env, jobject unused, jint fd, jboolean isIPv6) {\n+    jint optlevel, optname, optval, rv;\n+\n+    if (!isIPv6) {\n+        optlevel = IPPROTO_IP;\n+        optname = IP_DONTFRAG;\n+    } else {\n+        optlevel = IPPROTO_IPV6;\n+        optname = IPV6_DONTFRAG;\n+    }\n+    socklen_t sz = sizeof(optval);\n+    rv = getsockopt(fd, optlevel, optname, &optval, &sz);\n+    handleError(env, rv, \"get option IP_DONTFRAGMENT failed\");\n+    return optval > 0 ? JNI_TRUE : JNI_FALSE;\n+}\n","filename":"src\/jdk.net\/aix\/native\/libextnet\/AIXSocketOptions.c","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -416,0 +416,2 @@\n+            } else if (osname.startsWith(\"AIX\")) {\n+                return newInstance(\"jdk.net.AIXSocketOptions\");\n","filename":"src\/jdk.net\/share\/classes\/jdk\/net\/ExtendedSocketOptions.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}