{"files":[{"patch":"@@ -225,2 +225,0 @@\n-#if defined(_LP64) || !defined(TRACE_ID_SHIFT)\n-  case vmIntrinsics::_getClassId:\n@@ -228,2 +226,0 @@\n-#endif\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3045,27 +3045,0 @@\n-void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {\n-  CodeEmitInfo* info = state_for(x);\n-  CodeEmitInfo* info2 = new CodeEmitInfo(info); \/\/ Clone for the second null check\n-\n-  assert(info != NULL, \"must have info\");\n-  LIRItem arg(x->argument_at(0), this);\n-\n-  arg.load_item();\n-  LIR_Opr klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n-  LIR_Opr id = new_register(T_LONG);\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);\n-\n-  __ move(trace_id_addr, id);\n-  __ logical_or(id, LIR_OprFact::longConst(0x01l), id);\n-  __ store(id, trace_id_addr);\n-\n-#ifdef TRACE_ID_META_BITS\n-  __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);\n-#endif\n-\n-  __ move(id, rlock_result(x));\n-}\n@@ -3121,3 +3094,0 @@\n-  case vmIntrinsics::_getClassId:\n-    do_ClassIDIntrinsic(x);\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -112,0 +114,7 @@\n+\n+#ifdef JFR_HAVE_INTRINSICS\n+JRT_LEAF(void, Jfr::trace_id_load_barrier(Klass * klass))\n+  assert(klass != NULL, \"sanity\");\n+  JfrTraceIdLoadBarrier::load_barrier(klass);\n+JRT_END\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+#include \"jfr\/support\/jfrIntrinsics.hpp\"\n+#ifdef JFR_HAVE_INTRINSICS\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#endif\n+\n@@ -57,0 +62,4 @@\n+\n+#ifdef JFR_HAVE_INTRINSICS\n+  static void trace_id_load_barrier(Klass* klass);\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-      (char*)\"getClassIdNonIntrinsic\", (char*)\"(Ljava\/lang\/Class;)J\", (void*)jfr_class_id,\n+      (char*)\"getClassId\", (char*)\"(Ljava\/lang\/Class;)J\", (void*)jfr_class_id,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  static jlong epoch_address() {\n-    return (jlong)&_epoch_state;\n+  static address epoch_address() {\n+    return (address)&_epoch_state;\n@@ -117,0 +117,4 @@\n+\n+  static address signal_address() {\n+    return _tag_state.signaled_address();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  friend class Jfr;\n@@ -76,0 +77,1 @@\n+  static void load_barrier(const Klass* klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,3 +68,1 @@\n-inline traceid JfrTraceIdLoadBarrier::load(const Klass* klass) {\n-  assert(klass != NULL, \"invariant\");\n-  if (should_tag(klass)) {\n+inline void JfrTraceIdLoadBarrier::load_barrier(const Klass* klass) {\n@@ -74,0 +72,6 @@\n+}\n+\n+inline traceid JfrTraceIdLoadBarrier::load(const Klass* klass) {\n+  assert(klass != NULL, \"invariant\");\n+  if (should_tag(klass)) {\n+    load_barrier(klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+  address signaled_address() { return (address)&_signaled; }\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSignal.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1109,1 +1109,2 @@\n-                  strcmp(call->as_CallLeaf()->_name, \"vectorizedMismatch\") == 0)\n+                  strcmp(call->as_CallLeaf()->_name, \"vectorizedMismatch\") == 0 ||\n+                  strcmp(call->as_CallLeaf()->_name, \"trace_id_load_barrier\") == 0)\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -354,1 +354,2 @@\n-                     bool require_atomic_access) {\n+                     bool require_atomic_access,\n+                     MemNode::MemOrd mo) {\n@@ -362,1 +363,1 @@\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, MemNode::unordered);\n+    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo);\n@@ -364,1 +365,1 @@\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, MemNode::unordered);\n+    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-             bool require_atomic_access = false);\n+             bool require_atomic_access = false, MemNode::MemOrd mo = MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"jfr\/jfr.hpp\"\n@@ -2753,5 +2754,17 @@\n-\/*\n-* oop -> myklass\n-* myklass->trace_id |= USED\n-* return myklass->trace_id & ~0x3\n-*\/\n+\/**\n+ * if oop->klass != null\n+ *   \/\/ normal class\n+ *   epoch = _epoch_state ? 2 : 1\n+ *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch {\n+ *     ... \/\/ enter slow path when the klass is first recorded or the epoch of JFR shifts\n+ *   }\n+ *   id = oop->klass->trace_id >> TRACE_ID_SHIFT \/\/ normal class path\n+ * else\n+ *   \/\/ primitive class\n+ *   if oop->array_klass != null\n+ *     id = (oop->array_klass->trace_id >> TRACE_ID_SHIFT) + 1 \/\/ primitive class path\n+ *   else\n+ *     id = LAST_TYPE_ID + 1 \/\/ void class path\n+ *   if (!signaled)\n+ *     signaled = true\n+ *\/\n@@ -2759,3 +2772,1 @@\n-  Node* cls = null_check(argument(0), T_OBJECT);\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n-  kls = null_check(kls, T_OBJECT);\n+  Node* cls = argument(0);\n@@ -2763,19 +2774,56 @@\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  Node* insp = basic_plus_adr(kls, in_bytes(offset));\n-  Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);\n-\n-  Node* clsused = longcon(0x01l); \/\/ set the class bit\n-  Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));\n-  const TypePtr *adr_type = _gvn.type(insp)->isa_ptr();\n-  store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);\n-\n-#ifdef TRACE_ID_META_BITS\n-  Node* mbits = longcon(~TRACE_ID_META_BITS);\n-  tvalue = _gvn.transform(new AndLNode(tvalue, mbits));\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  Node* cbits = intcon(TRACE_ID_SHIFT);\n-  tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));\n-#endif\n-\n-  set_result(tvalue);\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  IdealVariable result(ideal); __ declarations_done();\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                 basic_plus_adr(cls, java_lang_Class::klass_offset()),\n+                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+\n+\n+  __ if_then(kls, BoolTest::ne, null()); {\n+    Node* kls_trace_id_addr = basic_plus_adr(kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+    Node* kls_trace_id_raw = ideal.load(ideal.ctrl(), kls_trace_id_addr,TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+\n+    Node* epoch_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::epoch_address()));\n+    Node* epoch = ideal.load(ideal.ctrl(), epoch_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+    epoch = _gvn.transform(new LShiftLNode(longcon(1), epoch));\n+    Node* mask = _gvn.transform(new LShiftLNode(epoch, intcon(META_SHIFT)));\n+    mask = _gvn.transform(new OrLNode(mask, epoch));\n+    Node* kls_trace_id_raw_and_mask = _gvn.transform(new AndLNode(kls_trace_id_raw, mask));\n+\n+    float unlikely  = PROB_UNLIKELY(0.999);\n+    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch, unlikely); {\n+      sync_kit(ideal);\n+      make_runtime_call(RC_LEAF,\n+                        OptoRuntime::trace_id_load_barrier_Type(),\n+                        CAST_FROM_FN_PTR(address, Jfr::trace_id_load_barrier),\n+                        \"trace_id_load_barrier\",\n+                        TypePtr::BOTTOM,\n+                        kls);\n+      ideal.sync_kit(this);\n+    } __ end_if();\n+\n+    ideal.set(result,  _gvn.transform(new URShiftLNode(kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT))));\n+  } __ else_(); {\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                   basic_plus_adr(cls, java_lang_Class::array_klass_offset()),\n+                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    __ if_then(array_kls, BoolTest::ne, null()); {\n+      Node* array_kls_trace_id_addr = basic_plus_adr(array_kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+      Node* array_kls_trace_id_raw = ideal.load(ideal.ctrl(), array_kls_trace_id_addr, TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+      Node* array_kls_trace_id = _gvn.transform(new URShiftLNode(array_kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT)));\n+      ideal.set(result, _gvn.transform(new AddLNode(array_kls_trace_id, longcon(1))));\n+    } __ else_(); {\n+      \/\/ void class case\n+      ideal.set(result, _gvn.transform(longcon(LAST_TYPE_ID + 1)));\n+    } __ end_if();\n+\n+    Node* signaled_flag_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::signal_address()));\n+    Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+    __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+      ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+    } __ end_if();\n+  } __ end_if();\n+\n+  final_sync(ideal);\n+  set_result(ideal.value(result));\n+#undef __\n@@ -2783,1 +2831,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":75,"deletions":28,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -1502,0 +1502,15 @@\n+#if INCLUDE_JFR\n+const TypeFunc *OptoRuntime::trace_id_load_barrier_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::KLASS;\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms + 0, fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n+#endif\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -307,0 +307,2 @@\n+  JFR_ONLY(static const TypeFunc* trace_id_load_barrier_Type();)\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -988,1 +988,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-            putLong(JVM.getClassIdNonIntrinsic(aClass));\n+            putLong(JVM.getClassId(aClass));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,3 +144,0 @@\n-\n-    \/\/ temporary workaround until we solve intrinsics supporting epoch shift tagging\n-    public static native long getClassIdNonIntrinsic(Class<?> clazz);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-        \/*\n-        Temporarily excluded until getClassId is reworked to accommodate epoch shift tagging\n+        JVM.getJVM().createNativeJFR();\n+        TestJFRIntrinsic ti = new TestJFRIntrinsic();\n@@ -66,2 +66,0 @@\n-        *\/\n-        TestJFRIntrinsic ti = new TestJFRIntrinsic();\n@@ -72,1 +70,0 @@\n-    \/*\n@@ -79,1 +76,0 @@\n-    *\/\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJFRIntrinsic.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}