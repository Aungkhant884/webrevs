{"files":[{"patch":"@@ -371,30 +371,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-void TraceIdLoadBarrierStub::emit_code(LIR_Assembler* ce) {\n-  __ bind(_entry);\n-\n-  __ push(RegSet::range(r0, r29), sp);         \/\/ integer registers except lr & sp\n-\n-  for (int i = 31; i>= 0; i -= 4) {\n-    __ sub(sp, sp, 4 * wordSize); \/\/ no pre-increment for st1. Emulate it without modifying other registers\n-    __ st1(as_FloatRegister(i-3), as_FloatRegister(i-2), as_FloatRegister(i-1),\n-           as_FloatRegister(i), __ T1D, Address(sp));\n-  }\n-\n-\n-  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier)));\n-  __ blr(rscratch1);\n-\n-  for (int i = 0; i < 32; i += 4) {\n-    __ ld1(as_FloatRegister(i), as_FloatRegister(i+1), as_FloatRegister(i+2),\n-           as_FloatRegister(i+3), __ T1D, Address(__ post(sp, 4 * wordSize)));\n-  }\n-\n-  __ pop(RegSet::range(r0, r29), sp);\n-\n-  ce->add_call_info_here(_info);\n-  ce->verify_oop_map(_info);\n-\n-  __ b(_continuation);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_CodeStubs_aarch64.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -552,17 +552,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-void TraceIdLoadBarrierStub::emit_code(LIR_Assembler* ce) {\n-  __ bind(_entry);\n-\n-  __ save_live_registers_no_oop_map(true);\n-\n-  __ call(RuntimeAddress(CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier)));\n-\n-  __ restore_live_registers(true);\n-\n-  ce->add_call_info_here(_info);\n-  ce->verify_oop_map(_info);\n-\n-  __ jmp(_continuation);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/c1_CodeStubs_x86.cpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -564,20 +564,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-class TraceIdLoadBarrierStub: public CodeStub {\n- private:\n-  CodeEmitInfo* _info;\n-\n- public:\n-  TraceIdLoadBarrierStub(CodeEmitInfo* info) : _info(info) {}\n-  virtual CodeEmitInfo* info() const             { return _info; }\n-  virtual void visit(LIR_OpVisitState* visitor) {\n-    visitor->do_slow_case(_info);\n-  }\n-\n-  virtual void emit_code(LIR_Assembler* e);\n-\n-#ifndef PRODUCT\n-  virtual void print_name(outputStream* out) const { out->print(\"TraceIdLoadBarrierStub\"); }\n-#endif \/\/ PRODUCT\n-};\n-#endif\n-\n","filename":"src\/hotspot\/share\/c1\/c1_CodeStubs.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -225,3 +225,2 @@\n-#if (defined AARCH64 || defined X86)\n-  case vmIntrinsics::_getClassId:\n-#endif\n+  \/\/ TODO: temporarily not implement getClassId in c1\n+  \/\/ case vmIntrinsics::_getClassId:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -47,4 +47,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n-#endif\n-\n@@ -3049,127 +3045,0 @@\n-void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {\n-#if !(defined AARCH64 || defined X86)\n-  \/\/ TODO: arm, ppc, s390\n-#else\n-  LIRItem arg(x->argument_at(0), this);\n-\n-  arg.load_item();\n-\n-  LIR_Opr cls = arg.result();\n-  LIR_Opr result = new_register(T_LONG);\n-\n-  LabelObj* L_signal = new LabelObj();\n-  LabelObj* L_end = new LabelObj();\n-\n-  LIR_Opr klass = new_register(T_METADATA);\n-\n-  __ move(new LIR_Address(cls, java_lang_Class::klass_offset(), T_ADDRESS), klass);\n-\n-  LabelObj* klass_not_null = new LabelObj();\n-\n-  __ cmp(lir_cond_notEqual, klass, LIR_OprFact::metadataConst(0));\n-  __ branch(lir_cond_notEqual, klass_not_null->label());\n-\n-  LIR_Opr array_klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(cls, java_lang_Class::array_klass_offset(), T_ADDRESS), array_klass);\n-\n-  LabelObj* L_void = new LabelObj();\n-  __ move(LIR_OprFact::longConst(LAST_TYPE_ID + 1), result);\n-  __ cmp(lir_cond_equal, array_klass, LIR_OprFact::metadataConst(0));\n-  __ branch(lir_cond_equal, L_signal->label());\n-\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  LIR_Address* prim_trace_id_addr = new LIR_Address(array_klass, in_bytes(offset), T_LONG);\n-  LIR_Opr prim_trace_id = new_register(T_LONG);\n-  __ move(prim_trace_id_addr, prim_trace_id);\n-  __ shift_right(prim_trace_id, TRACE_ID_SHIFT, prim_trace_id);\n-  __ add(prim_trace_id, LIR_OprFact::longConst(1), prim_trace_id);\n-  __ move(prim_trace_id, result);\n-  __ branch(lir_cond_always, L_signal->label());\n-\n-  __ branch_destination(klass_not_null->label());\n-  LIR_Opr trace_id_raw = new_register(T_LONG);\n-  LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);\n-  __ move(trace_id_addr, trace_id_raw);\n-\n-  LIR_Opr epoch = new_register(T_INT);\n-  LIR_Opr epoch_address = new_pointer_register();\n-  __ move(LIR_OprFact::intptrConst(JfrTraceIdEpoch::epoch_address()), epoch_address);\n-  __ move(new LIR_Address(epoch_address, (intx)0, T_INT), epoch);\n-  __ cmp(lir_cond_equal, epoch, LIR_OprFact::intConst(0));\n-  LIR_Opr this_epoch_bit = new_register(T_LONG);\n-  __ cmove(lir_cond_equal, LIR_OprFact::longConst(EPOCH_0_BIT),\n-           LIR_OprFact::longConst(EPOCH_1_BIT), this_epoch_bit, T_LONG);\n-  LIR_Opr mask = new_register(T_LONG);\n-  __ move(this_epoch_bit, mask);\n-  __ shift_left(mask, META_SHIFT, mask);\n-  __ logical_or(mask, this_epoch_bit, mask);\n-  LIR_Opr trace_id_raw_and_mask = new_register(T_LONG);\n-  __ move(trace_id_raw, trace_id_raw_and_mask);\n-  __ logical_and(trace_id_raw_and_mask, mask, trace_id_raw_and_mask);\n-\n-  __ move(trace_id_raw, result);\n-  __ shift_right(result, TRACE_ID_SHIFT, result);\n-  __ cmp(lir_cond_equal, trace_id_raw_and_mask, this_epoch_bit);\n-  __ branch(lir_cond_equal, L_end->label());\n-\n-#ifdef VM_LITTLE_ENDIAN\n-  LIR_Address* trace_id_low_addr = new LIR_Address(klass, in_bytes(offset), T_BYTE);\n-#else\n-  LIR_Address* trace_id_low_addr = new LIR_Address(klass, in_bytes(offset) + 7, T_BYTE);\n-#endif\n-  LIR_Opr current_value = new_register(T_INT);\n-  __ move(trace_id_low_addr, current_value);\n-  LIR_Opr epoch_i = new_register(T_INT);\n-  __ convert(Bytecodes::_l2i, this_epoch_bit, epoch_i);\n-  LIR_Opr new_value = new_register(T_INT);\n-  __ logical_or(current_value, epoch_i, current_value);\n-  __ move(current_value, new_value);\n-  __ move(new_value, trace_id_low_addr);\n-  __ membar_storestore();\n-\n-  BasicTypeList signature;\n-  signature.append(T_METADATA); \/\/ Klass*\n-  LIR_OprList* args = new LIR_OprList();\n-  args->append(klass);\n-\n-  \/\/ move the arguments into the correct location\n-  CallingConvention* cc = frame_map()->c_calling_convention(&signature);\n-\n-  assert(cc->length() == args->length(), \"argument mismatch\");\n-  for (int i = 0; i < args->length(); i++) {\n-    LIR_Opr arg = args->at(i);\n-    LIR_Opr loc = cc->at(i);\n-    if (loc->is_register()) {\n-      __ move(arg, loc);\n-    } else {\n-      LIR_Address* addr = loc->as_address_ptr();\n-      if (addr->type() == T_LONG || addr->type() == T_DOUBLE) {\n-        __ unaligned_move(arg, addr);\n-      } else {\n-        __ move(arg, addr);\n-      }\n-    }\n-  }\n-\n-  CodeEmitInfo *info = state_for(x, x->state());\n-  CodeStub* stub = new TraceIdLoadBarrierStub(info);\n-  __ jump(stub);\n-  __ branch_destination(stub->continuation());\n-\n-  __ branch_destination(L_signal->label());\n-  LIR_Opr signal = new_register(T_INT);\n-  LIR_Opr signal_addr = new_register(T_LONG);\n-  __ move(LIR_OprFact::intptrConst(JfrTraceIdEpoch::signal_address()), signal_addr);\n-  __ move(new LIR_Address(signal_addr, (intx)0, T_BOOLEAN), signal);\n-  __ membar_acquire();\n-  __ cmp(lir_cond_equal, signal, 1);\n-  __ branch(lir_cond_equal, L_end->label());\n-  __ move(LIR_OprFact::intConst(1), signal);\n-  __ membar_storestore();\n-  __ move(signal, new LIR_Address(signal_addr, (intx)0, T_BOOLEAN));\n-\n-  __ branch_destination(L_end->label());\n-\n-  __ move(result, rlock_result(x));\n-#endif\n-}\n@@ -3225,3 +3094,0 @@\n-  case vmIntrinsics::_getClassId:\n-    do_ClassIDIntrinsic(x);\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":134,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -251,1 +251,0 @@\n-  case trace_id_load_barrier_id:\n@@ -339,1 +338,0 @@\n-  FUNCTION_CASE(entry, SharedRuntime::trace_id_load_barrier);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-  stub(trace_id_load_barrier)        \\\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}