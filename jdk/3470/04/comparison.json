{"files":[{"patch":"@@ -225,2 +225,2 @@\n-#if defined(_LP64) || !defined(TRACE_ID_SHIFT)\n-  case vmIntrinsics::_getClassId:\n+  \/\/ TODO: temporarily not implement getClassId in c1\n+  \/\/ case vmIntrinsics::_getClassId:\n@@ -228,2 +228,0 @@\n-#endif\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3045,27 +3045,0 @@\n-void LIRGenerator::do_ClassIDIntrinsic(Intrinsic* x) {\n-  CodeEmitInfo* info = state_for(x);\n-  CodeEmitInfo* info2 = new CodeEmitInfo(info); \/\/ Clone for the second null check\n-\n-  assert(info != NULL, \"must have info\");\n-  LIRItem arg(x->argument_at(0), this);\n-\n-  arg.load_item();\n-  LIR_Opr klass = new_register(T_METADATA);\n-  __ move(new LIR_Address(arg.result(), java_lang_Class::klass_offset(), T_ADDRESS), klass, info);\n-  LIR_Opr id = new_register(T_LONG);\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  LIR_Address* trace_id_addr = new LIR_Address(klass, in_bytes(offset), T_LONG);\n-\n-  __ move(trace_id_addr, id);\n-  __ logical_or(id, LIR_OprFact::longConst(0x01l), id);\n-  __ store(id, trace_id_addr);\n-\n-#ifdef TRACE_ID_META_BITS\n-  __ logical_and(id, LIR_OprFact::longConst(~TRACE_ID_META_BITS), id);\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  __ unsigned_shift_right(id, TRACE_ID_SHIFT, id);\n-#endif\n-\n-  __ move(id, rlock_result(x));\n-}\n@@ -3121,3 +3094,0 @@\n-  case vmIntrinsics::_getClassId:\n-    do_ClassIDIntrinsic(x);\n-    break;\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":0,"deletions":30,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+      (char*)\"getClassId\", (char*)\"(Ljava\/lang\/Class;)J\", (void*)jfr_class_id,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,2 +70,2 @@\n-  static jlong epoch_address() {\n-    return (jlong)&_epoch_state;\n+  static address epoch_address() {\n+    return (address)&_epoch_state;\n@@ -117,0 +117,4 @@\n+\n+  static address signal_address() {\n+    return _tag_state.signaled_address();\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  friend class SharedRuntime;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+\n+  address signaled_address() { return (address)&_signaled; }\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrSignal.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,1 +354,2 @@\n-                     bool require_atomic_access) {\n+                     bool require_atomic_access,\n+                     MemNode::MemOrd mo) {\n@@ -362,1 +363,1 @@\n-    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, MemNode::unordered);\n+    ld = LoadLNode::make_atomic(ctl, mem, adr, adr_type, t, mo);\n@@ -364,1 +365,1 @@\n-    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, MemNode::unordered);\n+    ld = LoadNode::make(_gvn, ctl, mem, adr, adr_type, t, bt, mo);\n","filename":"src\/hotspot\/share\/opto\/idealKit.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -223,1 +223,1 @@\n-             bool require_atomic_access = false);\n+             bool require_atomic_access = false, MemNode::MemOrd mo = MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/idealKit.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#endif\n+\n@@ -2753,5 +2757,17 @@\n-\/*\n-* oop -> myklass\n-* myklass->trace_id |= USED\n-* return myklass->trace_id & ~0x3\n-*\/\n+\/**\n+ * if oop->klass != null\n+ *   epoch = _epoch_state ? 2 : 1\n+ *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch\n+ *     SET_USED_THIS_EPOCH\n+ *     enqueue klass\n+ *     if (!signaled) \/\/ JfrSignal::signal\n+ *       signaled = true\n+ *   id = oop->klass->trace_id >> TRACE_ID_SHIFT \/\/ normal class path\n+ * else\n+ *   if oop->array_klass != null\n+ *     id = (oop->array_klass->trace_id >> TRACE_ID_SHIFT) + 1 \/\/ primitive class path\n+ *   else\n+ *     id = LAST_TYPE_ID + 1 \/\/ void class path\n+ *   if (!signaled)\n+ *     signaled = true\n+ *\/\n@@ -2760,6 +2776,0 @@\n-  Node* kls = load_klass_from_mirror(cls, false, NULL, 0);\n-  kls = null_check(kls, T_OBJECT);\n-\n-  ByteSize offset = KLASS_TRACE_ID_OFFSET;\n-  Node* insp = basic_plus_adr(kls, in_bytes(offset));\n-  Node* tvalue = make_load(NULL, insp, TypeLong::LONG, T_LONG, MemNode::unordered);\n@@ -2767,12 +2777,25 @@\n-  Node* clsused = longcon(0x01l); \/\/ set the class bit\n-  Node* orl = _gvn.transform(new OrLNode(tvalue, clsused));\n-  const TypePtr *adr_type = _gvn.type(insp)->isa_ptr();\n-  store_to_memory(control(), insp, orl, T_LONG, adr_type, MemNode::unordered);\n-\n-#ifdef TRACE_ID_META_BITS\n-  Node* mbits = longcon(~TRACE_ID_META_BITS);\n-  tvalue = _gvn.transform(new AndLNode(tvalue, mbits));\n-#endif\n-#ifdef TRACE_ID_SHIFT\n-  Node* cbits = intcon(TRACE_ID_SHIFT);\n-  tvalue = _gvn.transform(new URShiftLNode(tvalue, cbits));\n+  IdealKit ideal(this);\n+#define __ ideal.\n+  IdealVariable result(ideal); __ declarations_done();\n+  Node* kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                 basic_plus_adr(cls, java_lang_Class::klass_offset()),\n+                                                 TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+\n+  Node* signaled_flag_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::signal_address()));\n+\n+  __ if_then(kls, BoolTest::ne, null()); {\n+    Node* kls_trace_id_addr = basic_plus_adr(kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+    Node* kls_trace_id_raw = ideal.load(ideal.ctrl(), kls_trace_id_addr,TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+\n+    Node* epoch_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::epoch_address()));\n+    Node* epoch = ideal.load(ideal.ctrl(), epoch_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw);\n+    epoch = _gvn.transform(new LShiftLNode(longcon(1), epoch));\n+    Node* mask = _gvn.transform(new LShiftLNode(epoch, intcon(META_SHIFT)));\n+    mask = _gvn.transform(new OrLNode(mask, epoch));\n+    Node* kls_trace_id_raw_and_mask = _gvn.transform(new AndLNode(kls_trace_id_raw, mask));\n+\n+    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch); {\n+#ifdef VM_LITTLE_ENDIAN\n+      Node* kls_trace_id_low_addr = basic_plus_adr(kls_trace_id_addr, (intptr_t)0);\n+#else\n+      Node* kls_trace_id_low_addr = basic_plus_adr(kls_trace_id_addr, (intptr_t)7);\n@@ -2780,2 +2803,46 @@\n-\n-  set_result(tvalue);\n+      Node* current_value = ideal.load(ideal.ctrl(), kls_trace_id_low_addr, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);\n+      Node* new_value = _gvn.transform(new OrINode(current_value, _gvn.transform(new ConvL2INode(epoch, TypeInt::BYTE))));\n+      Node* store_trace_id = ideal.store(ideal.ctrl(), kls_trace_id_low_addr, new_value, T_BYTE, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+      sync_kit(ideal);\n+      insert_mem_bar(Op_MemBarStoreStore, store_trace_id);\n+\n+      make_runtime_call(RC_LEAF,\n+                        OptoRuntime::trace_id_load_barrier_Type(),\n+                        CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier),\n+                        \"SharedRuntime::trace_id_load_barrier\",\n+                        TypePtr::BOTTOM,\n+                        kls);\n+\n+      ideal.sync_kit(this);\n+\n+      Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+      __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+        ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+      } __ end_if();\n+    } __ end_if();\n+\n+    ideal.set(result,  _gvn.transform(new URShiftLNode(kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT))));\n+  } __ else_(); {\n+    Node* array_kls = _gvn.transform(LoadKlassNode::make(_gvn, NULL, immutable_memory(),\n+                                                   basic_plus_adr(cls, java_lang_Class::array_klass_offset()),\n+                                                   TypeRawPtr::BOTTOM, TypeKlassPtr::OBJECT_OR_NULL));\n+    __ if_then(array_kls, BoolTest::ne, null()); {\n+      Node* array_kls_trace_id_addr = basic_plus_adr(array_kls, in_bytes(KLASS_TRACE_ID_OFFSET));\n+      Node* array_kls_trace_id_raw = ideal.load(ideal.ctrl(), array_kls_trace_id_addr, TypeLong::LONG, T_LONG, Compile::AliasIdxRaw);\n+      Node* array_kls_trace_id = _gvn.transform(new URShiftLNode(array_kls_trace_id_raw, ideal.ConI(TRACE_ID_SHIFT)));\n+      ideal.set(result, _gvn.transform(new AddLNode(array_kls_trace_id, longcon(1))));\n+    } __ else_(); {\n+      \/\/ void class case\n+      ideal.set(result, _gvn.transform(longcon(LAST_TYPE_ID + 1)));\n+    } __ end_if();\n+\n+    Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n+    __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n+      ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n+    } __ end_if();\n+  } __ end_if();\n+\n+  final_sync(ideal);\n+  set_result(ideal.value(result));\n+#undef __\n@@ -2783,1 +2850,0 @@\n-\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":92,"deletions":26,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -1502,0 +1502,13 @@\n+const TypeFunc *OptoRuntime::trace_id_load_barrier_Type() {\n+  \/\/ create input type (domain)\n+  const Type **fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = TypeInstPtr::KLASS;\n+  const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms + 1, fields);\n+\n+  \/\/ create result type (range)\n+  fields = TypeTuple::fields(0);\n+\n+  const TypeTuple *range = TypeTuple::make(TypeFunc::Parms + 0, fields);\n+\n+  return TypeFunc::make(domain,range);\n+}\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -307,0 +307,2 @@\n+  static const TypeFunc* trace_id_load_barrier_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -988,1 +988,0 @@\n-\n@@ -1884,0 +1883,6 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+JRT_LEAF(void, SharedRuntime::trace_id_load_barrier(Klass * klass))\n+  JfrTraceIdLoadBarrier::enqueue(klass);\n+JRT_END\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -525,0 +525,4 @@\n+#ifdef JFR_HAVE_INTRINSICS\n+  static void trace_id_load_barrier(Klass* klass);\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-            putLong(JVM.getClassIdNonIntrinsic(aClass));\n+            putLong(JVM.getClassId(aClass));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,2 +62,2 @@\n-        \/*\n-        Temporarily excluded until getClassId is reworked to accommodate epoch shift tagging\n+        JVM.getJVM().createNativeJFR();\n+        TestJFRIntrinsic ti = new TestJFRIntrinsic();\n@@ -66,2 +66,0 @@\n-        *\/\n-        TestJFRIntrinsic ti = new TestJFRIntrinsic();\n@@ -72,1 +70,0 @@\n-    \/*\n@@ -79,1 +76,0 @@\n-    *\/\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestJFRIntrinsic.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"}]}