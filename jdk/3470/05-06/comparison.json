{"files":[{"patch":"@@ -225,2 +225,0 @@\n-  \/\/ TODO: temporarily not implement getClassId in c1\n-  \/\/ case vmIntrinsics::_getClassId:\n","filename":"src\/hotspot\/share\/c1\/c1_Compiler.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -112,0 +114,7 @@\n+\n+#ifdef JFR_HAVE_INTRINSICS\n+JRT_LEAF(void, Jfr::trace_id_load_barrier(Klass * klass))\n+  assert(klass != NULL, \"sanity\");\n+  JfrTraceIdLoadBarrier::load_barrier(klass);\n+JRT_END\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/jfr.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+#include \"jfr\/support\/jfrIntrinsics.hpp\"\n+#ifdef JFR_HAVE_INTRINSICS\n+#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n+#endif\n+\n@@ -57,0 +62,4 @@\n+\n+#ifdef JFR_HAVE_INTRINSICS\n+  static void trace_id_load_barrier(Klass* klass);\n+#endif\n","filename":"src\/hotspot\/share\/jfr\/jfr.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-      (char*)\"getClassIdNonIntrinsic\", (char*)\"(Ljava\/lang\/Class;)J\", (void*)jfr_class_id,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+  friend class Jfr;\n@@ -71,1 +72,0 @@\n-  friend class SharedRuntime;\n@@ -77,0 +77,1 @@\n+  static void load_barrier(const Klass* klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -68,3 +68,1 @@\n-inline traceid JfrTraceIdLoadBarrier::load(const Klass* klass) {\n-  assert(klass != NULL, \"invariant\");\n-  if (should_tag(klass)) {\n+inline void JfrTraceIdLoadBarrier::load_barrier(const Klass* klass) {\n@@ -74,0 +72,6 @@\n+}\n+\n+inline traceid JfrTraceIdLoadBarrier::load(const Klass* klass) {\n+  assert(klass != NULL, \"invariant\");\n+  if (should_tag(klass)) {\n+    load_barrier(klass);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdLoadBarrier.inline.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"jfr\/jfr.hpp\"\n@@ -60,4 +61,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-#include \"jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceIdEpoch.hpp\"\n-#endif\n-\n@@ -2759,0 +2756,1 @@\n+ *   \/\/ normal class\n@@ -2760,5 +2758,3 @@\n- *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch\n- *     SET_USED_THIS_EPOCH\n- *     enqueue klass\n- *     if (!signaled) \/\/ JfrSignal::signal\n- *       signaled = true\n+ *   if oop->klass->trace_id & ((epoch << META_SHIFT) | epoch)) != epoch {\n+ *     ... \/\/ enter slow path when the klass is first recorded or the epoch of JFR shifts\n+ *   }\n@@ -2767,0 +2763,1 @@\n+ *   \/\/ primitive class\n@@ -2775,1 +2772,1 @@\n-  Node* cls = null_check(argument(0), T_OBJECT);\n+  Node* cls = argument(0);\n@@ -2784,1 +2781,0 @@\n-  Node* signaled_flag_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::signal_address()));\n@@ -2797,10 +2793,2 @@\n-    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch); {\n-#ifdef VM_LITTLE_ENDIAN\n-      Node* kls_trace_id_low_addr = basic_plus_adr(kls_trace_id_addr, (intptr_t)0);\n-#else\n-      Node* kls_trace_id_low_addr = basic_plus_adr(kls_trace_id_addr, (intptr_t)7);\n-#endif\n-      Node* current_value = ideal.load(ideal.ctrl(), kls_trace_id_low_addr, TypeInt::BYTE, T_BYTE, Compile::AliasIdxRaw);\n-      Node* new_value = _gvn.transform(new OrINode(current_value, _gvn.transform(new ConvL2INode(epoch, TypeInt::BYTE))));\n-      Node* store_trace_id = ideal.store(ideal.ctrl(), kls_trace_id_low_addr, new_value, T_BYTE, Compile::AliasIdxRaw, MemNode::unordered);\n-\n+    float unlikely  = PROB_UNLIKELY(0.999);\n+    __ if_then(kls_trace_id_raw_and_mask, BoolTest::ne, epoch, unlikely); {\n@@ -2808,2 +2796,0 @@\n-      insert_mem_bar(Op_MemBarStoreStore, store_trace_id);\n-\n@@ -2812,1 +2798,1 @@\n-                        CAST_FROM_FN_PTR(address, SharedRuntime::trace_id_load_barrier),\n+                        CAST_FROM_FN_PTR(address, Jfr::trace_id_load_barrier),\n@@ -2816,1 +2802,0 @@\n-\n@@ -2818,5 +2803,0 @@\n-\n-      Node* signaled = ideal.load(ideal.ctrl(), signaled_flag_address, TypeInt::BOOL, T_BOOLEAN, Compile::AliasIdxRaw, true, MemNode::acquire);\n-      __ if_then(signaled, BoolTest::ne, ideal.ConI(1)); {\n-        ideal.store(ideal.ctrl(), signaled_flag_address, ideal.ConI(1), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::release, true);\n-      } __ end_if();\n@@ -2840,0 +2820,1 @@\n+    Node* signaled_flag_address = makecon(TypeRawPtr::make(JfrTraceIdEpoch::signal_address()));\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":11,"deletions":30,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1502,0 +1502,1 @@\n+#if INCLUDE_JFR\n@@ -1515,0 +1516,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-  static const TypeFunc* trace_id_load_barrier_Type();\n+  JFR_ONLY(static const TypeFunc* trace_id_load_barrier_Type();)\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1883,6 +1883,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-JRT_LEAF(void, SharedRuntime::trace_id_load_barrier(Klass * klass))\n-  JfrTraceIdLoadBarrier::enqueue(klass);\n-JRT_END\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -525,4 +525,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-  static void trace_id_load_barrier(Klass* klass);\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,3 +144,0 @@\n-\n-    \/\/ temporary workaround until we solve intrinsics supporting epoch shift tagging\n-    public static native long getClassIdNonIntrinsic(Class<?> clazz);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}