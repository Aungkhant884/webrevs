{"files":[{"patch":"@@ -696,1 +696,1 @@\n-    ac->_adr_type = TypeRawPtr::BOTTOM;\n+    ac->set_adr_type(TypeRawPtr::BOTTOM);\n","filename":"src\/hotspot\/share\/gc\/shared\/c2\/barrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -635,0 +635,6 @@\n+\/\/ unlike set_map(), this is two-way setting.\n+void JVMState::bind_map(SafePointNode* map) {\n+  set_map(map);\n+  _map->set_jvms(this);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-class Chaitin;\n@@ -55,7 +54,3 @@\n-class     BoxLockNode;\n-class     LockNode;\n-class     UnlockNode;\n-class JVMState;\n-class State;\n-class StartNode;\n-class MachCallNode;\n+class     AbstractLockNode;\n+class       LockNode;\n+class       UnlockNode;\n@@ -297,1 +292,2 @@\n-  void              set_map(SafePointNode *map) { _map = map; }\n+  void              set_map(SafePointNode* map) { _map = map; }\n+  void              bind_map(SafePointNode* map); \/\/ set_map() and set_jvms() for the SafePointNode\n@@ -326,0 +322,4 @@\n+  friend JVMState;\n+  friend class GraphKit;\n+  friend class VMStructs;\n+\n@@ -329,0 +329,13 @@\n+protected:\n+  JVMState* const _jvms;      \/\/ Pointer to list of JVM State objects\n+  \/\/ Many calls take *all* of memory as input,\n+  \/\/ but some produce a limited subset of that memory as output.\n+  \/\/ The adr_type reports the call's behavior as a store, not a load.\n+  const TypePtr*  _adr_type;  \/\/ What type of memory does this node produce?\n+  ReplacedNodes   _replaced_nodes; \/\/ During parsing: list of pair of nodes from calls to GraphKit::replace_in_map()\n+  bool            _has_ea_local_in_scope; \/\/ NoEscape or ArgEscape objects in JVM States\n+\n+  void set_jvms(JVMState* s) {\n+  assert(s != nullptr, \"assign NULL value to _jvms\");\n+    *(JVMState**)&_jvms = s;  \/\/ override const attribute in the accessor\n+  }\n@@ -341,14 +354,1 @@\n-  JVMState* const _jvms;      \/\/ Pointer to list of JVM State objects\n-  const TypePtr*  _adr_type;  \/\/ What type of memory does this node produce?\n-  ReplacedNodes   _replaced_nodes; \/\/ During parsing: list of pair of nodes from calls to GraphKit::replace_in_map()\n-  bool            _has_ea_local_in_scope; \/\/ NoEscape or ArgEscape objects in JVM States\n-\n-  \/\/ Many calls take *all* of memory as input,\n-  \/\/ but some produce a limited subset of that memory as output.\n-  \/\/ The adr_type reports the call's behavior as a store, not a load.\n-\n-  virtual JVMState* jvms() const { return _jvms; }\n-  void set_jvms(JVMState* s) {\n-    *(JVMState**)&_jvms = s;  \/\/ override const attribute in the accessor\n-  }\n-\n+  JVMState* jvms() const { return _jvms; }\n@@ -477,2 +477,3 @@\n-  virtual const Type    *bottom_type() const { return Type::CONTROL; }\n-  virtual const TypePtr *adr_type() const { return _adr_type; }\n+  virtual const Type*    bottom_type() const { return Type::CONTROL; }\n+  virtual const TypePtr* adr_type() const { return _adr_type; }\n+  void set_adr_type(const TypePtr* adr_type) { _adr_type = adr_type; }\n@@ -582,2 +583,2 @@\n-  CallNode(const TypeFunc* tf, address addr, const TypePtr* adr_type)\n-    : SafePointNode(tf->domain()->cnt(), NULL, adr_type),\n+  CallNode(const TypeFunc* tf, address addr, const TypePtr* adr_type, JVMState* jvms = nullptr)\n+    : SafePointNode(tf->domain()->cnt(), jvms, adr_type),\n@@ -790,2 +791,2 @@\n-                  const TypePtr* adr_type)\n-    : CallNode(tf, addr, adr_type)\n+                  const TypePtr* adr_type, JVMState* jvms = nullptr)\n+    : CallNode(tf, addr, adr_type, jvms)\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  CallRuntimeNode *call = new CallRuntimeNode(c_sig, C_function, name, TypePtr::BOTTOM);\n+  CallRuntimeNode* call = new CallRuntimeNode(c_sig, C_function, name, TypePtr::BOTTOM, new (C) JVMState(0));\n@@ -172,1 +172,0 @@\n-  call->set_jvms(new (C) JVMState(0));\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -818,1 +818,1 @@\n-  SafePointNode* map  = new SafePointNode(max_size, NULL);\n+  SafePointNode* map  = new SafePointNode(max_size, jvms);\n@@ -842,1 +842,0 @@\n-  map->set_jvms(jvms);\n@@ -1077,2 +1076,1 @@\n-      ex_jvms->set_map(kit.clone_map());\n-      ex_jvms->map()->set_jvms(ex_jvms);\n+      ex_jvms->bind_map(kit.clone_map());\n@@ -1097,2 +1095,1 @@\n-      ex_map->set_jvms(caller->clone_shallow(C));\n-      ex_map->jvms()->set_map(ex_map);\n+      caller->clone_shallow(C)->bind_map(ex_map);\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"}]}