{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -1983,1 +1984,1 @@\n-  \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  \/\/ Scale the index to be the entry index * sizeof(ResolvedIndyEntry)\n@@ -1990,0 +1991,17 @@\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  get_cache_index_at_bcp(index, cache, bcp_offset, sizeof(u2));\n+  \/\/ Take shortcut if the size is a power of 2\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    slli(index, index, log2i_exact(sizeof(ResolvedFieldEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    mv(cache, sizeof(ResolvedFieldEntry));\n+    mul(index, index, cache); \/\/ Scale the index to be the entry index * sizeof(ResolvedIndyEntry)\n+  }\n+  \/\/ Get address of field entries array\n+  ld(cache, Address(xcpool, ConstantPoolCache::field_entries_offset()));\n+  add(cache, cache, Array<ResolvedIndyEntry>::base_offset_in_bytes());\n+  add(cache, cache, index);\n+  la(cache, Address(cache, 0));\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -303,0 +303,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -172,1 +173,10 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ la(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+      } else {\n+        __ la(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+      }\n+      \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+      __ membar(MacroAssembler::AnyAny);\n+      __ lbu(temp_reg, Address(temp_reg, 0));\n+      __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n@@ -2158,5 +2168,0 @@\n-  switch (code) {\n-    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-    default: break;\n-  }\n@@ -2191,0 +2196,65 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                            Register Rcache,\n+                                            Register index) {\n+  const Register temp = x9;\n+  assert_different_registers(Rcache, index, temp);\n+\n+  Label resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+  default: break;\n+  }\n+\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ load_field_entry(Rcache, index);\n+  if (byte_no == f1_byte) {\n+    __ la(temp, Address(Rcache, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+  } else {\n+    __ la(temp, Address(Rcache, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+  }\n+  \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+  __ membar(MacroAssembler::AnyAny);\n+  __ lbu(temp, Address(temp, 0));\n+  __ membar(MacroAssembler::LoadLoad | MacroAssembler::LoadStore);\n+  __ mv(t0, (int) code);  \/\/ have we resolved this bytecode?\n+  __ beq(temp, t0, resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mv(temp, (int) code);\n+  __ call_VM(noreg, entry, temp);\n+\n+  \/\/ Update registers with resolved info\n+  __ load_field_entry(Rcache, index);\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register index,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, index, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_unsigned_byte(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ Store TOS into index register in case it is needed later\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ ld(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ ld(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj, x15, t1);\n+  }\n+}\n+\n@@ -2346,2 +2416,1 @@\n-    __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);\n-    __ la(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));\n+    __ load_field_entry(c_rarg2, index);\n@@ -2357,1 +2426,0 @@\n-    \/\/ c_rarg3: jvalue object on the stack\n@@ -2360,2 +2428,2 @@\n-                                       c_rarg1, c_rarg2, c_rarg3);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+                                       c_rarg1, c_rarg2);\n+    __ load_field_entry(cache, index, 1);\n@@ -2373,2 +2441,1 @@\n-  const Register cache     = x12;\n-  const Register index     = x13;\n+  const Register cache     = x14;\n@@ -2376,0 +2443,2 @@\n+  const Register index     = x13;\n+  const Register tos       = x13;\n@@ -2377,2 +2446,1 @@\n-  const Register flags     = x10;\n-  const Register raw_flags = x16;\n+  const Register flags     = x16;\n@@ -2381,1 +2449,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2383,1 +2451,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);\n+  load_resolved_field_entry(obj, cache, tos, off, flags, is_static);\n@@ -2396,4 +2464,0 @@\n-  __ slli(flags, raw_flags, XLEN - (ConstantPoolCacheEntry::tos_state_shift +\n-                                    ConstantPoolCacheEntry::tos_state_bits));\n-  __ srli(flags, flags, XLEN - ConstantPoolCacheEntry::tos_state_bits);\n-\n@@ -2401,1 +2465,1 @@\n-  __ bnez(flags, notByte);\n+  __ bnez(tos, notByte);\n@@ -2418,1 +2482,1 @@\n-  __ sub(t0, flags, (u1)ztos);\n+  __ sub(t0, tos, (u1)ztos);\n@@ -2432,1 +2496,1 @@\n-  __ sub(t0, flags, (u1)atos);\n+  __ sub(t0, tos, (u1)atos);\n@@ -2443,1 +2507,1 @@\n-  __ sub(t0, flags, (u1)itos);\n+  __ sub(t0, tos, (u1)itos);\n@@ -2456,1 +2520,1 @@\n-  __ sub(t0, flags, (u1)ctos);\n+  __ sub(t0, tos, (u1)ctos);\n@@ -2468,1 +2532,1 @@\n-  __ sub(t0, flags, (u1)stos);\n+  __ sub(t0, tos, (u1)stos);\n@@ -2480,1 +2544,1 @@\n-  __ sub(t0, flags, (u1)ltos);\n+  __ sub(t0, tos, (u1)ltos);\n@@ -2492,1 +2556,1 @@\n-  __ sub(t0, flags, (u1)ftos);\n+  __ sub(t0, tos, (u1)ftos);\n@@ -2505,1 +2569,1 @@\n-  __ sub(t0, flags, (u1)dtos);\n+  __ sub(t0, tos, (u1)dtos);\n@@ -2525,1 +2589,1 @@\n-  __ test_bit(t0, raw_flags, ConstantPoolCacheEntry::is_volatile_shift);\n+  __ test_bit(t0, flags, ResolvedFieldEntry::is_volatile_shift);\n@@ -2549,2 +2613,0 @@\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-\n@@ -2564,1 +2626,1 @@\n-    __ get_cache_and_index_at_bcp(c_rarg2, t0, 1);\n+    __ mv(c_rarg2, cache);\n@@ -2574,5 +2636,1 @@\n-      __ lwu(c_rarg3, Address(c_rarg2,\n-                              in_bytes(cp_base_offset +\n-                                       ConstantPoolCacheEntry::flags_offset())));\n-      __ srli(c_rarg3, c_rarg3, ConstantPoolCacheEntry::tos_state_shift);\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n+      __ load_unsigned_byte(c_rarg3, Address(c_rarg2, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -2589,2 +2647,0 @@\n-    \/\/ cache entry pointer\n-    __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));\n@@ -2600,1 +2656,1 @@\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+    __ load_field_entry(cache, index);\n@@ -2615,1 +2671,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2617,1 +2673,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, index, off, flags, is_static);\n@@ -2624,1 +2680,1 @@\n-    __ test_bit(t0, x15, ConstantPoolCacheEntry::is_volatile_shift);\n+    __ test_bit(t0, x15, ResolvedFieldEntry::is_volatile_shift);\n@@ -2633,4 +2689,0 @@\n-  __ slli(flags, flags, XLEN - (ConstantPoolCacheEntry::tos_state_shift +\n-                                ConstantPoolCacheEntry::tos_state_bits));\n-  __ srli(flags, flags, XLEN - ConstantPoolCacheEntry::tos_state_bits);\n-\n@@ -2638,1 +2690,2 @@\n-  __ bnez(flags, notByte);\n+  \/\/ Index holds TOS\n+  __ bnez(index, notByte);\n@@ -2662,1 +2715,1 @@\n-  __ sub(t0, flags, (u1)ztos);\n+  __ sub(t0, index, (u1)ztos);\n@@ -2682,1 +2735,1 @@\n-  __ sub(t0, flags, (u1)atos);\n+  __ sub(t0, index, (u1)atos);\n@@ -2703,1 +2756,1 @@\n-  __ sub(t0, flags, (u1)itos);\n+  __ sub(t0, index, (u1)itos);\n@@ -2723,1 +2776,1 @@\n-  __ sub(t0, flags, (u1)ctos);\n+  __ sub(t0, index, (u1)ctos);\n@@ -2743,1 +2796,1 @@\n-  __ sub(t0, flags, (u1)stos);\n+  __ sub(t0, index, (u1)stos);\n@@ -2763,1 +2816,1 @@\n-  __ sub(t0, flags, (u1)ltos);\n+  __ sub(t0, index, (u1)ltos);\n@@ -2783,1 +2836,1 @@\n-  __ sub(t0, flags, (u1)ftos);\n+  __ sub(t0, index, (u1)ftos);\n@@ -2804,1 +2857,1 @@\n-  __ sub(t0, flags, (u1)dtos);\n+  __ sub(t0, index, (u1)dtos);\n@@ -2834,1 +2887,1 @@\n-    __ test_bit(t0, x15, ConstantPoolCacheEntry::is_volatile_shift);\n+    __ test_bit(t0, x15, ResolvedFieldEntry::is_volatile_shift);\n@@ -2887,1 +2940,1 @@\n-    __ get_cache_entry_pointer_at_bcp(c_rarg2, x10, 1);\n+    __ load_field_entry(c_rarg2, x10);\n@@ -2921,1 +2974,5 @@\n-  __ get_cache_and_index_at_bcp(x12, x11, 1);\n+  __ load_field_entry(x12, x11);\n+  __ push_reg(x10);\n+  \/\/ X11: field offset, X12: TOS, X13: flags\n+  load_resolved_field_entry(x12, x12, x10, x11, x13);\n+  __ pop_reg(x10);\n@@ -2926,7 +2983,0 @@\n-  \/\/ test for volatile with x13\n-  __ lwu(x13, Address(x12, in_bytes(base +\n-                                    ConstantPoolCacheEntry::flags_offset())));\n-\n-  \/\/ replace index with field offset from cache entry\n-  __ ld(x11, Address(x12, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));\n-\n@@ -2935,1 +2985,1 @@\n-    __ test_bit(t0, x13, ConstantPoolCacheEntry::is_volatile_shift);\n+    __ test_bit(t0, x13, ResolvedFieldEntry::is_volatile_shift);\n@@ -2983,1 +3033,1 @@\n-    __ test_bit(t0, x13, ConstantPoolCacheEntry::is_volatile_shift);\n+    __ test_bit(t0, x13, ResolvedFieldEntry::is_volatile_shift);\n@@ -3005,1 +3055,1 @@\n-    __ get_cache_entry_pointer_at_bcp(c_rarg2, t1, 1);\n+    __ load_field_entry(c_rarg2, t1);\n@@ -3020,1 +3070,1 @@\n-  __ get_cache_and_index_at_bcp(x12, x11, 1);\n+  __ load_field_entry(x12, x11);\n@@ -3025,4 +3075,2 @@\n-  __ ld(x11, Address(x12, in_bytes(ConstantPoolCache::base_offset() +\n-                                   ConstantPoolCacheEntry::f2_offset())));\n-  __ lwu(x13, Address(x12, in_bytes(ConstantPoolCache::base_offset() +\n-                                    ConstantPoolCacheEntry::flags_offset())));\n+  __ load_sized_value(x11, Address(x12, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+  __ load_unsigned_byte(x13, Address(x12, in_bytes(ResolvedFieldEntry::flags_offset())));\n@@ -3069,1 +3117,1 @@\n-    __ test_bit(t0, x13, ConstantPoolCacheEntry::is_volatile_shift);\n+    __ test_bit(t0, x13, ResolvedFieldEntry::is_volatile_shift);\n@@ -3082,3 +3130,2 @@\n-  __ get_cache_and_index_at_bcp(x12, x13, 2);\n-  __ ld(x11, Address(x12, in_bytes(ConstantPoolCache::base_offset() +\n-                                   ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(x12, x13, 2);\n+  __ load_sized_value(x11, Address(x12, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n@@ -3111,3 +3158,2 @@\n-    __ lwu(x13, Address(x12, in_bytes(ConstantPoolCache::base_offset() +\n-                                      ConstantPoolCacheEntry::flags_offset())));\n-    __ test_bit(t0, x13, ConstantPoolCacheEntry::is_volatile_shift);\n+    __ load_unsigned_byte(x13, Address(x12, in_bytes(ResolvedFieldEntry::flags_offset())));\n+    __ test_bit(t0, x13, ResolvedFieldEntry::is_volatile_shift);\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":129,"deletions":83,"binary":false,"changes":212,"status":"modified"}]}