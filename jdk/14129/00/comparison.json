{"files":[{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -1883,0 +1884,16 @@\n+\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+  \/\/ Take shortcut if the size is a power of 2\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    lsl(index, index, log2i_exact(sizeof(ResolvedFieldEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    mov(cache, sizeof(ResolvedFieldEntry));\n+    mul(index, index, cache); \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  }\n+  \/\/ Get address of field entries array\n+  ldr(cache, Address(rcpool, ConstantPoolCache::field_entries_offset()));\n+  add(cache, cache, Array<ResolvedFieldEntry>::base_offset_in_bytes());\n+  lea(cache, Address(cache, index));\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -190,1 +191,8 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ lea(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+      } else {\n+        __ lea(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+      }\n+      \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+      __ ldarb(temp_reg, temp_reg);\n@@ -2250,5 +2258,0 @@\n-  switch (code) {\n-  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-  default: break;\n-  }\n@@ -2282,0 +2285,63 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                            Register Rcache,\n+                                            Register index) {\n+  const Register temp = r19;\n+  assert_different_registers(Rcache, index, temp);\n+\n+  Label resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+  default: break;\n+  }\n+\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ load_field_entry(Rcache, index);\n+  if (byte_no == f1_byte) {\n+    __ lea(temp, Address(Rcache, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+  } else {\n+    __ lea(temp, Address(Rcache, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+  }\n+  \/\/ Load-acquire the bytecode to match store-release in ResolvedFieldEntry::fill_in()\n+  __ ldarb(temp, temp);\n+  __ subs(zr, temp, (int) code);  \/\/ have we resolved this bytecode?\n+  __ br(Assembler::EQ, resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ mov(temp, (int) code);\n+  __ call_VM(noreg, entry, temp);\n+\n+  \/\/ Update registers with resolved info\n+  __ load_field_entry(Rcache, index);\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register index,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, index, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_unsigned_byte(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ Store TOS into index register in case it is needed later\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ ldr(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ ldr(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj, r5, rscratch2);\n+  }\n+}\n+\n@@ -2433,2 +2499,1 @@\n-    __ get_cache_and_index_at_bcp(c_rarg2, c_rarg3, 1);\n-    __ lea(c_rarg2, Address(c_rarg2, in_bytes(ConstantPoolCache::base_offset())));\n+    __ load_field_entry(c_rarg2, index);\n@@ -2444,1 +2509,0 @@\n-    \/\/ c_rarg3: jvalue object on the stack\n@@ -2447,2 +2511,2 @@\n-               c_rarg1, c_rarg2, c_rarg3);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+               c_rarg1, c_rarg2);\n+    __ load_field_entry(cache, index);\n@@ -2470,1 +2534,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2472,1 +2536,3 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, raw_flags, is_static);\n+  load_resolved_field_entry(obj, cache, index, off, raw_flags, is_static);\n+  \/\/ Index holds the TOS\n+  __ mov(flags, index);\n@@ -2487,1 +2553,2 @@\n-    __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ andr(raw_flags, raw_flags, 0x1);\n+    __ tbz(raw_flags, 0, notVolatile);\n@@ -2497,5 +2564,0 @@\n-  \/\/ x86 uses a shift and mask or wings it with a shift plus assert\n-  \/\/ the mask is not needed. aarch64 just uses bitfield extract\n-  __ ubfxw(flags, raw_flags, ConstantPoolCacheEntry::tos_state_shift,\n-           ConstantPoolCacheEntry::tos_state_bits);\n-\n@@ -2624,1 +2686,1 @@\n-  __ tbz(raw_flags, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+  __ tbz(raw_flags, 0, notVolatile);\n@@ -2649,2 +2711,0 @@\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n-\n@@ -2660,1 +2720,1 @@\n-    __ get_cache_and_index_at_bcp(c_rarg2, rscratch1, 1);\n+    __ mov(c_rarg2, cache);\n@@ -2670,6 +2730,1 @@\n-      __ ldrw(c_rarg3, Address(c_rarg2,\n-                               in_bytes(cp_base_offset +\n-                                        ConstantPoolCacheEntry::flags_offset())));\n-      __ lsr(c_rarg3, c_rarg3,\n-             ConstantPoolCacheEntry::tos_state_shift);\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n+      __ load_unsigned_byte(c_rarg3, Address(c_rarg2, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -2686,2 +2741,0 @@\n-    \/\/ cache entry pointer\n-    __ add(c_rarg2, c_rarg2, in_bytes(cp_base_offset));\n@@ -2697,1 +2750,1 @@\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+    __ load_field_entry(cache, index);\n@@ -2712,1 +2765,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2714,1 +2767,1 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, index, off, flags, is_static);\n@@ -2721,1 +2774,2 @@\n-    __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ andr(r5, r5, 0x1);\n+    __ tbz(r5, 0, notVolatile);\n@@ -2732,4 +2786,0 @@\n-  \/\/ x86 uses a shift and mask or wings it with a shift plus assert\n-  \/\/ the mask is not needed. aarch64 just uses bitfield extract\n-  __ ubfxw(flags, flags, ConstantPoolCacheEntry::tos_state_shift,  ConstantPoolCacheEntry::tos_state_bits);\n-\n@@ -2737,1 +2787,2 @@\n-  __ cbnz(flags, notByte);\n+  \/\/ Index holds TOS\n+  __ cbnz(index, notByte);\n@@ -2754,1 +2805,1 @@\n-  __ cmp(flags, (u1)ztos);\n+  __ cmp(index, (u1)ztos);\n@@ -2769,1 +2820,1 @@\n-  __ cmp(flags, (u1)atos);\n+  __ cmp(index, (u1)atos);\n@@ -2785,1 +2836,1 @@\n-  __ cmp(flags, (u1)itos);\n+  __ cmp(index, (u1)itos);\n@@ -2800,1 +2851,1 @@\n-  __ cmp(flags, (u1)ctos);\n+  __ cmp(index, (u1)ctos);\n@@ -2815,1 +2866,1 @@\n-  __ cmp(flags, (u1)stos);\n+  __ cmp(index, (u1)stos);\n@@ -2830,1 +2881,1 @@\n-  __ cmp(flags, (u1)ltos);\n+  __ cmp(index, (u1)ltos);\n@@ -2845,1 +2896,1 @@\n-  __ cmp(flags, (u1)ftos);\n+  __ cmp(index, (u1)ftos);\n@@ -2861,1 +2912,1 @@\n-  __ cmp(flags, (u1)dtos);\n+  __ cmp(index, (u1)dtos);\n@@ -2886,1 +2937,1 @@\n-    __ tbz(r5, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r5, 0, notVolatile);\n@@ -2905,2 +2956,1 @@\n-void TemplateTable::jvmti_post_fast_field_mod()\n-{\n+void TemplateTable::jvmti_post_fast_field_mod() {\n@@ -2936,1 +2986,1 @@\n-    __ get_cache_entry_pointer_at_bcp(c_rarg2, r0, 1);\n+    __ load_field_entry(c_rarg2, r0);\n@@ -2971,1 +3021,7 @@\n-  __ get_cache_and_index_at_bcp(r2, r1, 1);\n+  __ load_field_entry(r2, r1);\n+  __ push(r0);\n+  \/\/ R1: field offset, R2: TOS, R3: flags\n+  load_resolved_field_entry(r2, r2, r0, r1, r3);\n+  \/\/ Test for volatile\n+  __ andr(r3, r3, 0x1);\n+  __ pop(r0);\n@@ -2976,7 +3032,0 @@\n-  \/\/ test for volatile with r3\n-  __ ldrw(r3, Address(r2, in_bytes(base +\n-                                   ConstantPoolCacheEntry::flags_offset())));\n-\n-  \/\/ replace index with field offset from cache entry\n-  __ ldr(r1, Address(r2, in_bytes(base + ConstantPoolCacheEntry::f2_offset())));\n-\n@@ -2985,1 +3034,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, 0, notVolatile);\n@@ -3033,1 +3082,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, 0, notVolatile);\n@@ -3052,1 +3101,1 @@\n-    __ get_cache_entry_pointer_at_bcp(c_rarg2, rscratch2, 1);\n+    __ load_field_entry(c_rarg2, rscratch2);\n@@ -3067,1 +3116,1 @@\n-  __ get_cache_and_index_at_bcp(r2, r1, 1);\n+  __ load_field_entry(r2, r1);\n@@ -3072,4 +3121,2 @@\n-  __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                  ConstantPoolCacheEntry::f2_offset())));\n-  __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                   ConstantPoolCacheEntry::flags_offset())));\n+  __ load_sized_value(r1, Address(r2, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+  __ load_unsigned_byte(r3, Address(r2, in_bytes(ResolvedFieldEntry::flags_offset())));\n@@ -3090,1 +3137,2 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ andr(r3, r3, 0x1);\n+    __ tbz(r3, 0, notVolatile);\n@@ -3127,1 +3175,1 @@\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ tbz(r3, 0, notVolatile);\n@@ -3140,3 +3188,2 @@\n-  __ get_cache_and_index_at_bcp(r2, r3, 2);\n-  __ ldr(r1, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                  ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(r2, r3, 2);\n+  __ load_sized_value(r1, Address(r2, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n@@ -3152,3 +3199,3 @@\n-    __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                     ConstantPoolCacheEntry::flags_offset())));\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ load_unsigned_byte(r3, Address(r2, in_bytes(ResolvedFieldEntry::flags_offset())));\n+    __ andr(r3, r3, 0x1);\n+    __ tbz(r3, 0, notVolatile);\n@@ -3180,3 +3227,3 @@\n-    __ ldrw(r3, Address(r2, in_bytes(ConstantPoolCache::base_offset() +\n-                                     ConstantPoolCacheEntry::flags_offset())));\n-    __ tbz(r3, ConstantPoolCacheEntry::is_volatile_shift, notVolatile);\n+    __ load_unsigned_byte(r3, Address(r2, in_bytes(ResolvedFieldEntry::flags_offset())));\n+    __ andr(r3, r3, 0x1);\n+    __ tbz(r3, 0, notVolatile);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":126,"deletions":79,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -2120,0 +2121,15 @@\n+\n+void InterpreterMacroAssembler::load_field_entry(Register cache, Register index, int bcp_offset) {\n+  \/\/ Get index out of bytecode pointer\n+  movptr(cache, Address(rbp, frame::interpreter_frame_cache_offset * wordSize));\n+  get_cache_index_at_bcp(index, bcp_offset, sizeof(u2));\n+\n+  movptr(cache, Address(cache, ConstantPoolCache::field_entries_offset()));\n+  \/\/ Take shortcut if the size is a power of 2\n+  if (is_power_of_2(sizeof(ResolvedFieldEntry))) {\n+    shll(index, log2i_exact(sizeof(ResolvedFieldEntry))); \/\/ Scale index by power of 2\n+  } else {\n+    imull(index, index, sizeof(ResolvedFieldEntry)); \/\/ Scale the index to be the entry index * sizeof(ResolvedInvokeDynamicInfo)\n+  }\n+  lea(cache, Address(cache, index, Address::times_1, Array<ResolvedFieldEntry>::base_offset_in_bytes()));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -310,1 +310,1 @@\n-\n+  void load_field_entry(Register cache, Register index, int bcp_offset = 1);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -200,1 +201,7 @@\n-      __ get_cache_and_index_and_bytecode_at_bcp(temp_reg, bc_reg, temp_reg, byte_no, 1);\n+      __ load_field_entry(temp_reg, bc_reg);\n+      if (byte_no == f1_byte) {\n+        __ load_unsigned_byte(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+      } else {\n+        __ load_unsigned_byte(temp_reg, Address(temp_reg, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+      }\n+\n@@ -2659,5 +2666,0 @@\n-  switch (code) {\n-  case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n-  case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n-  default: break;\n-  }\n@@ -2694,0 +2696,62 @@\n+void TemplateTable::resolve_cache_and_index_for_field(int byte_no,\n+                                            Register cache,\n+                                            Register index) {\n+  const Register temp = rbx;\n+  assert_different_registers(cache, index, temp);\n+\n+  Label resolved;\n+\n+  Bytecodes::Code code = bytecode();\n+  switch (code) {\n+    case Bytecodes::_nofast_getfield: code = Bytecodes::_getfield; break;\n+    case Bytecodes::_nofast_putfield: code = Bytecodes::_putfield; break;\n+    default: break;\n+  }\n+\n+  assert(byte_no == f1_byte || byte_no == f2_byte, \"byte_no out of range\");\n+  __ load_field_entry(cache, index);\n+  if (byte_no == f1_byte) {\n+    __ load_unsigned_byte(temp, Address(cache, in_bytes(ResolvedFieldEntry::get_code_offset())));\n+  } else {\n+    __ load_unsigned_byte(temp, Address(cache, in_bytes(ResolvedFieldEntry::put_code_offset())));\n+  }\n+  __ cmpl(temp, code);  \/\/ have we resolved this bytecode?\n+  __ jcc(Assembler::equal, resolved);\n+\n+  \/\/ resolve first time through\n+  address entry = CAST_FROM_FN_PTR(address, InterpreterRuntime::resolve_from_cache);\n+  __ movl(temp, code);\n+  __ call_VM(noreg, entry, temp);\n+  \/\/ Update registers with resolved info\n+  __ load_field_entry(cache, index);\n+\n+  __ bind(resolved);\n+}\n+\n+void TemplateTable::load_resolved_field_entry(Register obj,\n+                                              Register cache,\n+                                              Register index,\n+                                              Register offset,\n+                                              Register flags,\n+                                              bool is_static = false) {\n+  assert_different_registers(cache, index, flags, offset);\n+\n+  \/\/ Field offset\n+  __ load_sized_value(offset, Address(cache, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n+  \/\/ Flags\n+  __ load_unsigned_byte(flags, Address(cache, in_bytes(ResolvedFieldEntry::flags_offset())));\n+\n+  \/\/ Store TOS into index register in case it is needed later\n+  __ load_unsigned_byte(index, Address(cache, in_bytes(ResolvedFieldEntry::type_offset())));\n+\n+  \/\/ Klass overwrite register\n+  if (is_static) {\n+    __ movptr(obj, Address(cache, ResolvedFieldEntry::field_holder_offset()));\n+    const int mirror_offset = in_bytes(Klass::java_mirror_offset());\n+    __ movptr(obj, Address(obj, mirror_offset));\n+    __ resolve_oop_handle(obj, rscratch2);\n+  }\n+\n+}\n+\n@@ -2841,3 +2905,1 @@\n-    __ addptr(cache, in_bytes(ConstantPoolCache::base_offset()));\n-    __ shll(index, LogBytesPerWord);\n-    __ addptr(cache, index);\n+    __ load_field_entry(cache, index);\n@@ -2854,2 +2916,3 @@\n-               rax, cache);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+              rax, cache);\n+\n+    __ load_field_entry(cache, index);\n@@ -2869,0 +2932,1 @@\n+  const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n@@ -2871,1 +2935,0 @@\n-  const Register obj   = LP64_ONLY(c_rarg3) NOT_LP64(rcx);\n@@ -2876,1 +2939,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -2878,1 +2941,4 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, index, off, flags, is_static);\n+  \/\/ Index holds the TOS\n+  __ mov(flags, index);\n+\n@@ -2886,1 +2952,0 @@\n-  __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);\n@@ -2889,3 +2954,2 @@\n-\n-  __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);\n-\n+  \/\/ Compare the method to zero\n+  __ testl(flags, flags);\n@@ -2893,0 +2957,1 @@\n+\n@@ -3031,7 +3096,4 @@\n-\n-  const Register robj = LP64_ONLY(c_rarg2)   NOT_LP64(rax);\n-  const Register RBX  = LP64_ONLY(c_rarg1)   NOT_LP64(rbx);\n-  const Register RCX  = LP64_ONLY(c_rarg3)   NOT_LP64(rcx);\n-  const Register RDX  = LP64_ONLY(rscratch1) NOT_LP64(rdx);\n-\n-  ByteSize cp_base_offset = ConstantPoolCache::base_offset();\n+  \/\/ Cache is rcx and index is rdx\n+  const Register entry = LP64_ONLY(c_rarg2) NOT_LP64(rax); \/\/ ResolvedFieldEntry\n+  const Register obj = LP64_ONLY(c_rarg1) NOT_LP64(rbx);   \/\/ Object pointer\n+  const Register value = LP64_ONLY(c_rarg3) NOT_LP64(rcx); \/\/ JValue object\n@@ -3043,1 +3105,1 @@\n-    assert_different_registers(cache, index, rax);\n+    assert_different_registers(cache, obj, rax);\n@@ -3048,2 +3110,1 @@\n-    __ get_cache_and_index_at_bcp(robj, RDX, 1);\n-\n+    __ mov(entry, cache);\n@@ -3053,1 +3114,1 @@\n-      __ xorl(RBX, RBX);\n+      __ xorl(obj, obj);\n@@ -3063,9 +3124,1 @@\n-      __ movl(RCX, Address(robj, RDX,\n-                           Address::times_ptr,\n-                           in_bytes(cp_base_offset +\n-                                     ConstantPoolCacheEntry::flags_offset())));\n-      NOT_LP64(__ mov(rbx, rsp));\n-      __ shrl(RCX, ConstantPoolCacheEntry::tos_state_shift);\n-\n-      \/\/ Make sure we don't need to mask rcx after the above shift\n-      ConstantPoolCacheEntry::verify_tos_state_shift();\n+      __ load_unsigned_byte(value, Address(entry, in_bytes(ResolvedFieldEntry::type_offset())));\n@@ -3073,2 +3126,2 @@\n-      __ movptr(c_rarg1, at_tos_p1());  \/\/ initially assume a one word jvalue\n-      __ cmpl(c_rarg3, ltos);\n+      __ movptr(obj, at_tos_p1());  \/\/ initially assume a one word jvalue\n+      __ cmpl(value, ltos);\n@@ -3076,2 +3129,2 @@\n-                 c_rarg1, at_tos_p2()); \/\/ ltos (two word jvalue)\n-      __ cmpl(c_rarg3, dtos);\n+                 obj, at_tos_p2()); \/\/ ltos (two word jvalue)\n+      __ cmpl(value, dtos);\n@@ -3079,1 +3132,1 @@\n-                 c_rarg1, at_tos_p2()); \/\/ dtos (two word jvalue)\n+                 obj, at_tos_p2()); \/\/ dtos (two word jvalue)\n@@ -3081,1 +3134,2 @@\n-      __ cmpl(rcx, ltos);\n+      __ mov(obj, rsp);\n+      __ cmpl(value, ltos);\n@@ -3083,1 +3137,1 @@\n-      __ cmpl(rcx, dtos);\n+      __ cmpl(value, dtos);\n@@ -3085,1 +3139,1 @@\n-      __ addptr(rbx, Interpreter::expr_offset_in_bytes(1)); \/\/ one word jvalue (not ltos, dtos)\n+      __ addptr(obj, Interpreter::expr_offset_in_bytes(1)); \/\/ one word jvalue (not ltos, dtos)\n@@ -3089,1 +3143,1 @@\n-      __ addptr(rbx, Interpreter::expr_offset_in_bytes(2)); \/\/ two words jvalue\n+      __ addptr(obj, Interpreter::expr_offset_in_bytes(2)); \/\/ two words jvalue\n@@ -3093,1 +3147,1 @@\n-      __ movptr(rbx, Address(rbx, 0));\n+      __ movptr(obj, Address(obj, 0));\n@@ -3096,4 +3150,1 @@\n-    \/\/ cache entry pointer\n-    __ addptr(robj, in_bytes(cp_base_offset));\n-    __ shll(RDX, LogBytesPerWord);\n-    __ addptr(robj, RDX);\n+\n@@ -3101,4 +3152,4 @@\n-    __ mov(RCX, rsp);\n-    \/\/ c_rarg1: object pointer set up above (null if static)\n-    \/\/ c_rarg2: cache entry pointer\n-    \/\/ c_rarg3: jvalue object on the stack\n+    __ mov(value, rsp);\n+    \/\/ obj: object pointer set up above (null if static)\n+    \/\/ cache: field entry pointer\n+    \/\/ value: jvalue object on the stack\n@@ -3106,4 +3157,5 @@\n-               CAST_FROM_FN_PTR(address,\n-                                InterpreterRuntime::post_field_modification),\n-               RBX, robj, RCX);\n-    __ get_cache_and_index_at_bcp(cache, index, 1);\n+              CAST_FROM_FN_PTR(address,\n+                              InterpreterRuntime::post_field_modification),\n+              obj, entry, value);\n+    \/\/ Reload field entry\n+    __ load_field_entry(cache, index);\n@@ -3117,0 +3169,1 @@\n+  const Register obj = rcx;\n@@ -3119,1 +3172,0 @@\n-  const Register obj   = rcx;\n@@ -3123,1 +3175,1 @@\n-  resolve_cache_and_index(byte_no, cache, index, sizeof(u2));\n+  resolve_cache_and_index_for_field(byte_no, cache, index);\n@@ -3125,1 +3177,2 @@\n-  load_field_cp_cache_entry(obj, cache, index, off, flags, is_static);\n+  load_resolved_field_entry(obj, cache, index, off, flags, is_static);\n+  __ mov(flags, index);\n@@ -3132,3 +3185,0 @@\n-  __ movl(rdx, flags);\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n@@ -3136,0 +3186,3 @@\n+  \/\/ Swap registers so flags has TOS state\n+  __ xchgl(index, flags);\n+  __ andl(index, 0x1);\n@@ -3137,1 +3190,1 @@\n-  __ testl(rdx, rdx);\n+  __ testl(index, index);\n@@ -3164,4 +3217,2 @@\n-  __ shrl(flags, ConstantPoolCacheEntry::tos_state_shift);\n-\n-  assert(btos == 0, \"change code, btos != 0\");\n-  __ andl(flags, ConstantPoolCacheEntry::tos_state_mask);\n+  \/\/ Test TOS\n+  __ testl(flags, flags);\n@@ -3363,2 +3414,2 @@\n-    LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rax, 1));\n-    NOT_LP64(__ get_cache_entry_pointer_at_bcp(rax, rdx, 1));\n+    LP64_ONLY(__ load_field_entry(c_rarg2, rax));\n+    NOT_LP64(__ load_field_entry(rax, rdx));\n@@ -3391,11 +3442,1 @@\n-  ByteSize base = ConstantPoolCache::base_offset();\n-\n-  jvmti_post_fast_field_mod();\n-\n-  \/\/ access constant pool cache\n-  __ get_cache_and_index_at_bcp(rcx, rbx, 1);\n-\n-  \/\/ test for volatile with rdx but rdx is tos register for lputfield.\n-  __ movl(rdx, Address(rcx, rbx, Address::times_ptr,\n-                       in_bytes(base +\n-                                ConstantPoolCacheEntry::flags_offset())));\n+  Register cache = rcx;\n@@ -3403,3 +3444,1 @@\n-  \/\/ replace index with field offset from cache entry\n-  __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,\n-                         in_bytes(base + ConstantPoolCacheEntry::f2_offset())));\n+  Label notVolatile, Done;\n@@ -3407,3 +3446,1 @@\n-  \/\/ [jk] not needed currently\n-  \/\/ volatile_barrier(Assembler::Membar_mask_bits(Assembler::LoadStore |\n-  \/\/                                              Assembler::StoreStore));\n+  jvmti_post_fast_field_mod();\n@@ -3411,3 +3448,6 @@\n-  Label notVolatile, Done;\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n+  __ push(rax);\n+  __ load_field_entry(rcx, rax);\n+  load_resolved_field_entry(noreg, cache, rax, rbx, rdx);\n+  \/\/ RBX: field offset, RCX: RAX: TOS, RDX: flags\n+  __ andl(rdx, 0x1); \/\/is_volatile\n+  __ pop(rax);\n@@ -3488,2 +3528,2 @@\n-    LP64_ONLY(__ get_cache_entry_pointer_at_bcp(c_rarg2, rcx, 1));\n-    NOT_LP64(__ get_cache_entry_pointer_at_bcp(rcx, rdx, 1));\n+    LP64_ONLY(__ load_field_entry(c_rarg2, rcx));\n+    NOT_LP64(__ load_field_entry(rcx, rdx));\n@@ -3502,12 +3542,2 @@\n-  __ get_cache_and_index_at_bcp(rcx, rbx, 1);\n-  \/\/ replace index with field offset from cache entry\n-  \/\/ [jk] not needed currently\n-  \/\/ __ movl(rdx, Address(rcx, rbx, Address::times_8,\n-  \/\/                      in_bytes(ConstantPoolCache::base_offset() +\n-  \/\/                               ConstantPoolCacheEntry::flags_offset())));\n-  \/\/ __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  \/\/ __ andl(rdx, 0x1);\n-  \/\/\n-  __ movptr(rbx, Address(rcx, rbx, Address::times_ptr,\n-                         in_bytes(ConstantPoolCache::base_offset() +\n-                                  ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(rcx, rbx);\n+  __ load_sized_value(rbx, Address(rcx, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n@@ -3568,5 +3598,3 @@\n-  __ get_cache_and_index_at_bcp(rcx, rdx, 2);\n-  __ movptr(rbx,\n-            Address(rcx, rdx, Address::times_ptr,\n-                    in_bytes(ConstantPoolCache::base_offset() +\n-                             ConstantPoolCacheEntry::f2_offset())));\n+  __ load_field_entry(rcx, rdx, 2);\n+  __ load_sized_value(rbx, Address(rcx, in_bytes(ResolvedFieldEntry::field_offset_offset())), sizeof(int), true \/*is_signed*\/);\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":140,"deletions":112,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -608,1 +608,1 @@\n-  ConstantPoolCacheEntry* entry = cache->entry_at(index);\n+  ResolvedFieldEntry* entry = cache->resolved_field_entry_at(index);\n@@ -625,1 +625,1 @@\n-  switch (entry->flag_state()) {\n+  switch (entry->tos()) {\n@@ -637,1 +637,1 @@\n-  int offset = entry->f2_as_index();\n+  int offset = entry->field_offset();\n@@ -642,1 +642,1 @@\n-    switch (entry->flag_state()) {\n+    switch (entry->tos()) {\n@@ -656,1 +656,1 @@\n-    switch (entry->flag_state()) {\n+    switch (entry->tos()) {\n@@ -699,1 +699,1 @@\n-  ConstantPoolCacheEntry* entry = cache->entry_at(index);\n+  ResolvedFieldEntry* entry = cache->resolved_field_entry_at(index);\n@@ -710,1 +710,1 @@\n-  switch (entry->flag_state()) {\n+  switch (entry->tos()) {\n@@ -727,1 +727,1 @@\n-  int offset = entry->f2_as_index();\n+  int offset = entry->field_offset();\n@@ -729,1 +729,1 @@\n-    switch (entry->flag_state()) {\n+    switch (entry->tos()) {\n@@ -744,1 +744,1 @@\n-    switch (entry->flag_state()) {\n+    switch (entry->tos()) {\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-  return get_index_u2_cpcache();\n+  return get_index_u2();\n","filename":"src\/hotspot\/share\/ci\/ciStreams.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,1 @@\n-  return constants()->name_ref_at(index(), _code);\n+  return constants()->name_ref_at(index(), Bytecodes::java_code(_code));\n@@ -167,0 +167,2 @@\n+  else if (Bytecodes::is_field_code(rawc))\n+    return get_index_u2(rawc);\n","filename":"src\/hotspot\/share\/interpreter\/bytecode.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -68,0 +69,1 @@\n+  int       get_index_u2_raw()       { int i=Bytes::get_native_u2(_next_pc); _next_pc+=2; return i; }\n@@ -79,0 +81,1 @@\n+  bool      check_field_index(int i, int& cp_index, outputStream* st);\n@@ -237,1 +240,5 @@\n-      okay = check_cp_cache_index(i, cp_index, st);\n+      if (Bytecodes::is_field_code(code)) {\n+        okay = check_field_index(i, cp_index, st);\n+      } else {\n+        okay = check_cp_cache_index(i, cp_index, st);\n+      }\n@@ -318,0 +325,11 @@\n+bool BytecodePrinter::check_field_index(int i, int& cp_index, outputStream* st) {\n+  ConstantPool* constants = _current_method->constants();\n+  if (constants->cache() == nullptr) {\n+    cp_index = i; \/\/ TODO: This is wrong on little-endian. See JDK-8309811.\n+  } else {\n+    ResolvedFieldEntry* field_entry = constants->resolved_field_entry_at(i);\n+    cp_index = field_entry->constant_pool_index();\n+  }\n+  return true;\n+}\n+\n@@ -609,1 +627,2 @@\n-      print_field_or_method(get_index_u2_cpcache(), st);\n+      \/\/ TODO: get_index_u2() does not work here due to using java_u2 instead of native_u2\n+      print_field_or_method(get_index_u2_raw(), st);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeTracer.cpp","additions":21,"deletions":2,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -985,1 +985,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1135,1 +1135,1 @@\n-        int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+        int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1329,1 +1329,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) + ConstantPool::CPCACHE_INDEX_TAG;\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1340,1 +1340,1 @@\n-      int cp_index = Bytes::get_native_u2(code_base + pos) + ConstantPool::CPCACHE_INDEX_TAG;\n+      int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1417,1 +1417,1 @@\n-        int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+        int cp_index = Bytes::get_native_u2(code_base + pos);\n@@ -1425,1 +1425,1 @@\n-        int cp_index = Bytes::get_native_u2(code_base + pos) DEBUG_ONLY(+ ConstantPool::CPCACHE_INDEX_TAG);\n+        int cp_index = Bytes::get_native_u2(code_base + pos);\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -422,0 +422,1 @@\n+  static bool        is_field_code  (Code code)    { return (_getstatic <= java_code(code) && java_code(code) <= _putfield); }\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-#include \"oops\/constantPool.hpp\"\n+#include \"oops\/constantPool.inline.hpp\"\n@@ -667,0 +667,1 @@\n+  int field_index = last_frame.get_index_u2(bytecode);\n@@ -670,1 +671,1 @@\n-    LinkResolver::resolve_field_access(info, pool, last_frame.get_index_u2_cpcache(bytecode),\n+    LinkResolver::resolve_field_access(info, pool, field_index,\n@@ -675,2 +676,2 @@\n-  ConstantPoolCacheEntry* cp_cache_entry = last_frame.cache_entry();\n-  if (cp_cache_entry->is_resolved(bytecode)) return;\n+  if (pool->resolved_field_entry_at(field_index)->is_resolved(bytecode)) return;\n+\n@@ -716,10 +717,3 @@\n-  cp_cache_entry->set_field(\n-    get_code,\n-    put_code,\n-    info.field_holder(),\n-    info.index(),\n-    info.offset(),\n-    state,\n-    info.access_flags().is_final(),\n-    info.access_flags().is_volatile()\n-  );\n+  ResolvedFieldEntry* entry = pool->resolved_field_entry_at(field_index);\n+  entry->fill_in(info.field_holder(), info.offset(), (u2)info.index(), (u1)state, (u1)get_code, (u1)put_code);\n+  entry->set_flags(info.access_flags().is_final(), info.access_flags().is_volatile());\n@@ -1168,1 +1162,1 @@\n-                                                      ConstantPoolCacheEntry *cp_entry))\n+                                                      ResolvedFieldEntry *entry))\n@@ -1172,2 +1166,2 @@\n-  InstanceKlass* ik = InstanceKlass::cast(cp_entry->f1_as_klass());\n-  int index = cp_entry->field_index();\n+  InstanceKlass* ik = entry->field_holder();\n+  int index = entry->field_index();\n@@ -1184,2 +1178,2 @@\n-  InstanceKlass* cp_entry_f1 = InstanceKlass::cast(cp_entry->f1_as_klass());\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(cp_entry_f1, cp_entry->f2_as_index(), is_static);\n+  InstanceKlass* entry_f1 = entry->field_holder();\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(entry_f1, entry->field_offset(), is_static);\n@@ -1187,1 +1181,1 @@\n-  JvmtiExport::post_field_access(current, last_frame.method(), last_frame.bcp(), cp_entry_f1, h_obj, fid);\n+  JvmtiExport::post_field_access(current, last_frame.method(), last_frame.bcp(), entry_f1, h_obj, fid);\n@@ -1191,1 +1185,1 @@\n-                                                            ConstantPoolCacheEntry *cp_entry, jvalue *value))\n+                                                            ResolvedFieldEntry *entry, jvalue *value))\n@@ -1193,1 +1187,1 @@\n-  Klass* k = cp_entry->f1_as_klass();\n+  InstanceKlass* ik = entry->field_holder();\n@@ -1196,2 +1190,1 @@\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n-  int index = cp_entry->field_index();\n+  int index = entry->field_index();\n@@ -1203,1 +1196,1 @@\n-  switch(cp_entry->flag_state()) {\n+  switch((TosState)entry->tos()) {\n@@ -1218,1 +1211,1 @@\n-  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, cp_entry->f2_as_index(), is_static);\n+  jfieldID fid = jfieldIDWorkaround::to_jfieldID(ik, entry->field_offset(), is_static);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-    ConstantPoolCacheEntry *cp_entry);\n+    ResolvedFieldEntry *entry);\n@@ -125,1 +125,1 @@\n-    ConstantPoolCacheEntry *cp_entry, jvalue *value);\n+    ResolvedFieldEntry *entry, jvalue *value);\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -53,1 +54,7 @@\n-      case JVM_CONSTANT_Fieldref          : \/\/ fall through\n+        add_cp_cache_entry(i);\n+        break;\n+      case JVM_CONSTANT_Fieldref          :\n+        _cp_map.at_put(i, _field_entry_index);\n+        _field_entry_index++;\n+        _initialized_field_entries.push(ResolvedFieldEntry((u2)i));\n+        break;\n@@ -103,1 +110,1 @@\n-                                  _invokedynamic_references_map, _initialized_indy_entries, CHECK);\n+                                  _invokedynamic_references_map, _initialized_indy_entries, _initialized_field_entries, CHECK);\n@@ -178,0 +185,17 @@\n+void Rewriter::rewrite_field_reference(address bcp, int offset, bool reverse) {\n+  address p = bcp + offset;\n+  if (!reverse) {\n+    int cp_index = Bytes::get_Java_u2(p);\n+    int field_entry_index = _cp_map.at(cp_index);\n+    Bytes::put_native_u2(p, field_entry_index);\n+    if (!_method_handle_invokers.is_empty())\n+      maybe_rewrite_invokehandle(p - 1, cp_index, -1, reverse);\n+  } else {\n+    int field_entry_index = Bytes::get_native_u2(p);\n+    int pool_index = _initialized_field_entries.at(field_entry_index).constant_pool_index();\n+    Bytes::put_Java_u2(p, pool_index);\n+    if (!_method_handle_invokers.is_empty())\n+      maybe_rewrite_invokehandle(p - 1, pool_index, -1, reverse);\n+  }\n+}\n+\n@@ -452,0 +476,2 @@\n+        rewrite_field_reference(bcp, prefix_length+1, reverse);\n+        break;\n@@ -567,1 +593,2 @@\n-    _invokedynamic_index(0)\n+    _invokedynamic_index(0),\n+    _field_entry_index(0)\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -50,0 +51,1 @@\n+  int                 _field_entry_index;\n@@ -54,0 +56,1 @@\n+  GrowableArray<ResolvedFieldEntry> _initialized_field_entries;\n@@ -166,0 +169,1 @@\n+  void rewrite_field_reference(address bcp, int offset, bool reverse);\n","filename":"src\/hotspot\/share\/interpreter\/rewriter.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -269,0 +269,3 @@\n+  static void resolve_cache_and_index_for_field(int byte_no,\n+                                                Register cache,\n+                                                Register index);\n@@ -270,0 +273,6 @@\n+  static void load_resolved_field_entry(Register obj,\n+                                        Register cache,\n+                                        Register index,\n+                                        Register off,\n+                                        Register flags,\n+                                        bool is_static);\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -409,1 +410,1 @@\n-                                  target, cache),                   \\\n+                                  target, entry),                   \\\n@@ -429,1 +430,1 @@\n-                                  target, cache,                    \\\n+                                  target, entry,                    \\\n@@ -1725,1 +1726,0 @@\n-          ConstantPoolCacheEntry* cache;\n@@ -1727,0 +1727,1 @@\n+          ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -1739,2 +1740,1 @@\n-          cache = cp->entry_at(index);\n-          if (!cache->is_resolved(code)) {\n+          if (!entry->is_resolved(code)) {\n@@ -1743,1 +1743,1 @@\n-            cache = cp->entry_at(index);\n+            entry = cp->resolved_field_entry_at(index);\n@@ -1748,1 +1748,1 @@\n-            Klass* k = cache->f1_as_klass();\n+            Klass* k = entry->field_holder();\n@@ -1755,1 +1755,1 @@\n-            if (REWRITE_BYTECODES && !cache->is_volatile() &&\n+            if (REWRITE_BYTECODES && !entry->is_volatile() &&\n@@ -1758,1 +1758,1 @@\n-              REWRITE_AT_PC(fast_get_type(cache->flag_state()));\n+              REWRITE_AT_PC(fast_get_type((TosState)(entry->tos())));\n@@ -1767,3 +1767,3 @@\n-          TosState tos_type = cache->flag_state();\n-          int field_offset = cache->f2_as_index();\n-          if (cache->is_volatile()) {\n+          TosState tos_type = (TosState)(entry->tos());\n+          int field_offset = entry->field_offset();\n+          if (entry->is_volatile()) {\n@@ -1845,1 +1845,1 @@\n-         }\n+        }\n@@ -1852,1 +1852,1 @@\n-          ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+          ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -1861,1 +1861,1 @@\n-          if (!cache->is_resolved(code)) {\n+          if (!entry->is_resolved(code)) {\n@@ -1864,1 +1864,1 @@\n-            cache = cp->entry_at(index);\n+            entry = cp->resolved_field_entry_at(index);\n@@ -1872,1 +1872,1 @@\n-          TosState tos_type = cache->flag_state();\n+          TosState tos_type = (TosState)(entry->tos());\n@@ -1879,1 +1879,1 @@\n-            Klass* k = cache->f1_as_klass();\n+            Klass* k = entry->field_holder();\n@@ -1887,1 +1887,1 @@\n-            if (REWRITE_BYTECODES && !cache->is_volatile() &&\n+            if (REWRITE_BYTECODES && !entry->is_volatile() &&\n@@ -1890,1 +1890,1 @@\n-              REWRITE_AT_PC(fast_put_type(cache->flag_state()));\n+              REWRITE_AT_PC(fast_put_type((TosState)(entry->tos())));\n@@ -1899,2 +1899,2 @@\n-          int field_offset = cache->f2_as_index();\n-          if (cache->is_volatile()) {\n+          int field_offset = entry->field_offset();\n+          if (entry->is_volatile()) {\n@@ -2588,2 +2588,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2603,2 +2603,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2617,2 +2617,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2631,2 +2631,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2646,2 +2646,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2660,2 +2660,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2674,2 +2674,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2689,2 +2689,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2703,1 +2703,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2710,1 +2710,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2718,1 +2718,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2725,1 +2725,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2733,1 +2733,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2740,1 +2740,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2748,1 +2748,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2755,1 +2755,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2763,1 +2763,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2770,1 +2770,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2778,1 +2778,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2785,1 +2785,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2793,1 +2793,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2800,1 +2800,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2808,1 +2808,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2815,1 +2815,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2823,1 +2823,1 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n@@ -2830,1 +2830,1 @@\n-        int field_offset = cache->f2_as_index();\n+        int field_offset = entry->field_offset();\n@@ -2845,2 +2845,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2861,2 +2861,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n@@ -2876,2 +2876,2 @@\n-        ConstantPoolCacheEntry* cache = cp->entry_at(index);\n-        int field_offset = cache->f2_as_index();\n+        ResolvedFieldEntry* entry = cp->resolved_field_entry_at(index);\n+        int field_offset = entry->field_offset();\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":62,"deletions":62,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -688,2 +688,1 @@\n-      \/\/ TODO: handle resolved field entries with new structure\n-      \/\/ i = ....\n+      return resolved_field_entry_at(index)->constant_pool_index();\n@@ -740,1 +739,0 @@\n-\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -922,0 +922,4 @@\n+  \/\/ ResolvedFieldEntry getters\n+  inline ResolvedFieldEntry* resolved_field_entry_at(int field_index);\n+  inline int resolved_field_entries_length() const;\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -45,0 +46,8 @@\n+inline ResolvedFieldEntry* ConstantPool::resolved_field_entry_at(int field_index) {\n+    return cache()->resolved_field_entry_at(field_index);\n+}\n+\n+inline int ConstantPool::resolved_field_entries_length() const {\n+    return cache()->resolved_field_entries_length();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/constantPool.inline.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -643,0 +644,13 @@\n+template <class T>\n+static Array<T>* initialize_resolved_entries_array(ClassLoaderData* loader_data, GrowableArray<T> entries, TRAPS) {\n+  Array<T>* resolved_entries;\n+  if (entries.length()) {\n+    resolved_entries = MetadataFactory::new_array<T>(loader_data, entries.length(), CHECK_NULL);\n+    for (int i = 0; i < entries.length(); i++) {\n+      resolved_entries->at_put(i, entries.at(i));\n+    }\n+    return resolved_entries;\n+  }\n+  return nullptr;\n+}\n+\n@@ -647,0 +661,1 @@\n+                                     const GrowableArray<ResolvedFieldEntry> field_entries,\n@@ -652,10 +667,3 @@\n-  \/\/ Initialize ResolvedIndyEntry array with available data\n-  Array<ResolvedIndyEntry>* resolved_indy_entries;\n-  if (indy_entries.length()) {\n-    resolved_indy_entries = MetadataFactory::new_array<ResolvedIndyEntry>(loader_data, indy_entries.length(), CHECK_NULL);\n-    for (int i = 0; i < indy_entries.length(); i++) {\n-      resolved_indy_entries->at_put(i, indy_entries.at(i));\n-    }\n-  } else {\n-    resolved_indy_entries = nullptr;\n-  }\n+  \/\/ Initialize resolved entry arrays with available data\n+  Array<ResolvedFieldEntry>* resolved_field_entries = initialize_resolved_entries_array(loader_data, field_entries, CHECK_NULL);\n+  Array<ResolvedIndyEntry>* resolved_indy_entries = initialize_resolved_entries_array(loader_data, indy_entries, CHECK_NULL);\n@@ -664,1 +672,1 @@\n-              ConstantPoolCache(length, index_map, invokedynamic_map, resolved_indy_entries);\n+              ConstantPoolCache(length, index_map, invokedynamic_map, resolved_indy_entries, resolved_field_entries);\n@@ -717,0 +725,5 @@\n+  if (_resolved_field_entries != nullptr) {\n+    for (int i = 0; i < _resolved_field_entries->length(); i++) {\n+      resolved_field_entry_at(i)->remove_unshareable_info();\n+    }\n+  }\n@@ -732,0 +745,2 @@\n+    if (_resolved_field_entries)\n+      MetadataFactory::free_array<ResolvedFieldEntry>(data, _resolved_field_entries);\n@@ -833,0 +848,3 @@\n+  if (_resolved_field_entries != nullptr) {\n+    it->push(&_resolved_field_entries, MetaspaceClosure::_writable);\n+  }\n@@ -927,8 +945,2 @@\n-  for (int i = 0; i < resolved_indy_entries_length(); i++) {\n-    ResolvedIndyEntry* indy_entry = resolved_indy_entry_at(i);\n-    indy_entry->print_on(st);\n-    if (indy_entry->has_appendix()) {\n-      st->print(\"  appendix: \");\n-      constant_pool()->resolved_reference_from_indy(i)->print_on(st);\n-    }\n-  }\n+  print_resolved_field_entries(st);\n+  print_resolved_indy_entries(st);\n@@ -945,3 +957,14 @@\n-void ConstantPoolCache::print_resolved_indy_entries(outputStream* st)   const {\n-  for (int i = 0; i < _resolved_indy_entries->length(); i++) {\n-    _resolved_indy_entries->at(i).print_on(st);\n+void ConstantPoolCache::print_resolved_field_entries(outputStream* st) const {\n+  for (int field_index = 0; field_index < resolved_field_entries_length(); field_index++) {\n+    resolved_field_entry_at(field_index)->print_on(st);\n+  }\n+}\n+\n+void ConstantPoolCache::print_resolved_indy_entries(outputStream* st) const {\n+  for (int indy_index = 0; indy_index < resolved_indy_entries_length(); indy_index++) {\n+    ResolvedIndyEntry* indy_entry = resolved_indy_entry_at(indy_index);\n+    indy_entry->print_on(st);\n+    if (indy_entry->has_appendix()) {\n+      st->print(\"  appendix: \");\n+      constant_pool()->resolved_reference_from_indy(indy_index)->print_on(st);\n+    }\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":45,"deletions":22,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -131,0 +131,1 @@\n+class ResolvedFieldEntry;\n@@ -409,1 +410,2 @@\n-  Array<ResolvedIndyEntry>* _resolved_indy_entries;\n+  Array<ResolvedIndyEntry>*  _resolved_indy_entries;\n+  Array<ResolvedFieldEntry>* _resolved_field_entries;\n@@ -420,1 +422,2 @@\n-                    Array<ResolvedIndyEntry>* indy_info);\n+                    Array<ResolvedIndyEntry>* indy_info,\n+                    Array<ResolvedFieldEntry>* field_entries);\n@@ -430,0 +433,1 @@\n+                                     const GrowableArray<ResolvedFieldEntry> field_entries,\n@@ -445,0 +449,5 @@\n+  Array<ResolvedFieldEntry>* resolved_field_entries()          { return _resolved_field_entries; }\n+  inline ResolvedFieldEntry* resolved_field_entry_at(int field_index) const;\n+  inline int resolved_field_entries_length() const;\n+  void print_resolved_field_entries(outputStream* st) const;\n+\n@@ -451,2 +460,3 @@\n-  static ByteSize resolved_references_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_references); }\n-  static ByteSize invokedynamic_entries_offset() { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries); }\n+  static ByteSize resolved_references_offset()     { return byte_offset_of(ConstantPoolCache, _resolved_references);    }\n+  static ByteSize invokedynamic_entries_offset()   { return byte_offset_of(ConstantPoolCache, _resolved_indy_entries);  }\n+  static ByteSize field_entries_offset()           { return byte_offset_of(ConstantPoolCache, _resolved_field_entries); }\n","filename":"src\/hotspot\/share\/oops\/cpCache.hpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -91,1 +92,2 @@\n-                                            Array<ResolvedIndyEntry>* invokedynamic_info) :\n+                                            Array<ResolvedIndyEntry>* invokedynamic_info,\n+                                            Array<ResolvedFieldEntry>* field_entries) :\n@@ -95,1 +97,2 @@\n-                                                  _resolved_indy_entries(invokedynamic_info) {\n+                                                  _resolved_indy_entries(invokedynamic_info),\n+                                                  _resolved_field_entries(field_entries) {\n@@ -110,0 +113,8 @@\n+inline ResolvedFieldEntry* ConstantPoolCache::resolved_field_entry_at(int field_index) const {\n+  return _resolved_field_entries->adr_at(field_index);\n+}\n+\n+inline int ConstantPoolCache::resolved_field_entries_length() const {\n+  return _resolved_field_entries->length();\n+}\n+\n","filename":"src\/hotspot\/share\/oops\/cpCache.inline.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1600,4 +1600,12 @@\n-    case Bytecodes::_getstatic:         do_field(true,  true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_putstatic:         do_field(false, true,  itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_getfield:          do_field(true,  false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n-    case Bytecodes::_putfield:          do_field(false, false, itr->get_index_u2_cpcache(), itr->bci(), itr->code()); break;\n+    case Bytecodes::_getstatic:\n+      do_field(true,  true,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n+    case Bytecodes::_putstatic:\n+      do_field(false,  true,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n+    case Bytecodes::_getfield:\n+      do_field(true,  false,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n+    case Bytecodes::_putfield:\n+      do_field(false,  false,  itr->get_index_u2(), itr->bci(), itr->code());\n+      break;\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"resolvedFieldEntry.hpp\"\n+\n+void ResolvedFieldEntry::print_on(outputStream* st) const {\n+  st->print_cr(\"Field Entry:\");\n+\n+  if (field_holder() != nullptr) {\n+    st->print_cr(\" - Holder: \" INTPTR_FORMAT \" %s\", p2i(field_holder()), field_holder()->external_name());\n+  } else {\n+    st->print_cr(\"- Holder: null\");\n+  }\n+  st->print_cr(\" - Offset: %d\", field_offset());\n+  st->print_cr(\" - Field Index: %d\", field_index());\n+  st->print_cr(\" - CP Index: %d\", constant_pool_index());\n+  st->print_cr(\" - TOS: %s\", type2name(as_BasicType((TosState)tos())));\n+  st->print_cr(\" - Is Final: %d\", is_final());\n+  st->print_cr(\" - Is Volatile: %d\", is_volatile());\n+  st->print_cr(\" - Bytecode 1: %s\", Bytecodes::name((Bytecodes::Code)get_code()));\n+  st->print_cr(\" - Bytecode 2: %s\", Bytecodes::name((Bytecodes::Code)put_code()));\n+}\n+\n+void ResolvedFieldEntry::remove_unshareable_info() {\n+  u2 saved_cpool_index = _cpool_index;\n+  memset(this, 0, sizeof(*this));\n+  _cpool_index = saved_cpool_index;\n+}\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_RESOLVEDFIELDENTRY_HPP\n+#define SHARE_OOPS_RESOLVEDFIELDENTRY_HPP\n+\n+#include \"code\/compressedStream.hpp\"\n+#include \"interpreter\/bytecodes.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"utilities\/sizes.hpp\"\n+\n+\/\/ ResolvedFieldEntry contains the resolution information for field related bytecodes like\n+\/\/ like getfield, putfield, getstatic, and putstatic. A member of this class can be initialized\n+\/\/ with the constant pool index associated with the bytecode before any resolution is done, where\n+\/\/ \"resolution\" refers to populating the getcode and putcode fields and other relevant information.\n+\/\/ The field's type (TOS), offset, holder klass, and index within that class can all be acquired\n+\/\/ together and are used to populate this structure. These entries are contained\n+\/\/ within the ConstantPoolCache and are accessed with indices added to the invokedynamic bytecode after\n+\/\/ rewriting.\n+\n+\/\/ Field bytecodes start with a constant pool index as their operate, which is then rewritten to\n+\/\/ a \"field index\", which is an index into the array of ResolvedFieldEntry.\n+\n+\/\/class InstanceKlass;\n+class ResolvedFieldEntry {\n+  friend class VMStructs;\n+\n+  InstanceKlass* _field_holder; \/\/ Field holder klass\n+  int _field_offset;            \/\/ Field offset in bytes\n+  u2 _field_index;              \/\/ Index into field information in holder InstanceKlass\n+  u2 _cpool_index;              \/\/ Constant pool index\n+  u1 _tos;                      \/\/ TOS state\n+  u1 _flags;                    \/\/ Flags: [0000|00|is_final|is_volatile]\n+  u1 _get_code, _put_code;      \/\/ Get and Put bytecodes of the field\n+\n+public:\n+  ResolvedFieldEntry(u2 cpi) :\n+    _field_holder(nullptr),\n+    _field_offset(0),\n+    _field_index(0),\n+    _cpool_index(cpi),\n+    _tos(0),\n+    _flags(0),\n+    _get_code(0),\n+    _put_code(0) {}\n+  ResolvedFieldEntry() :\n+    ResolvedFieldEntry(0) {}\n+\n+  \/\/ Bit shift to get flags\n+  \/\/ Note: Only two flags exists at the moment but more could be added\n+  enum {\n+      is_final_shift        = 1, \/\/ unused\n+  };\n+\n+  \/\/ Getters\n+  InstanceKlass* field_holder() const { return _field_holder; }\n+  int field_offset()            const { return _field_offset; }\n+  u2 field_index()              const { return _field_index;  }\n+  u2 constant_pool_index()      const { return _cpool_index;  }\n+  u1 tos()                      const { return _tos;          }\n+  u1 get_code()                 const { return Atomic::load_acquire(&_get_code);      }\n+  u1 put_code()                 const { return Atomic::load_acquire(&_put_code);      }\n+  bool is_final()               const { return (_flags & (1 << is_final_shift)) != 0; }\n+  bool is_volatile ()           const { return (_flags & 1) != 0;                     }\n+  bool is_resolved(Bytecodes::Code code) const {\n+    switch(code) {\n+    case Bytecodes::_getstatic:\n+    case Bytecodes::_getfield:\n+      return (get_code() == code);\n+    case Bytecodes::_putstatic:\n+    case Bytecodes::_putfield:\n+      return (put_code() == code);\n+    default:\n+      assert(code == Bytecodes::_nop, \"Must be get, put, or nop bytecode\");\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Printing\n+  void print_on(outputStream* st) const;\n+\n+  void set_flags(bool is_final, bool is_volatile) {\n+    u1 new_flags = (static_cast<u1>(is_final) << static_cast<u1>(is_final_shift)) | static_cast<u1>(is_volatile);\n+    _flags = new_flags;\n+  }\n+\n+  inline void set_bytecode(u1* code, u1 new_code) {\n+  #ifdef ASSERT\n+    \/\/ Read once.\n+    volatile Bytecodes::Code c = (Bytecodes::Code)*code;\n+    assert(c == 0 || c == new_code || new_code == 0, \"update must be consistent\");\n+  #endif\n+    Atomic::release_store(code, new_code);\n+  }\n+\n+  \/\/ Populate the strucutre with resolution information\n+  void fill_in(InstanceKlass* klass, intx offset, int index, int tos, u1 b1, u1 b2) {\n+    _field_holder = klass;\n+    _field_offset = offset;\n+    _field_index = index;\n+    _tos = tos;\n+\n+    \/\/ This has to be done last\n+    set_bytecode(&_get_code, b1);\n+    set_bytecode(&_put_code, b2);\n+  }\n+\n+  \/\/ CDS\n+  void remove_unshareable_info();\n+\n+  \/\/ Offsets\n+  static ByteSize field_holder_offset() { return byte_offset_of(ResolvedFieldEntry, _field_holder); }\n+  static ByteSize field_offset_offset() { return byte_offset_of(ResolvedFieldEntry, _field_offset); }\n+  static ByteSize field_index_offset()  { return byte_offset_of(ResolvedFieldEntry, _field_index);  }\n+  static ByteSize get_code_offset()     { return byte_offset_of(ResolvedFieldEntry, _get_code);     }\n+  static ByteSize put_code_offset()     { return byte_offset_of(ResolvedFieldEntry, _put_code);     }\n+  static ByteSize type_offset()         { return byte_offset_of(ResolvedFieldEntry, _tos);          }\n+  static ByteSize flags_offset()        { return byte_offset_of(ResolvedFieldEntry, _flags);        }\n+\n+};\n+\n+#endif \/\/SHARE_OOPS_RESOLVEDFIELDENTRY_HPP\n","filename":"src\/hotspot\/share\/oops\/resolvedFieldEntry.hpp","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -1029,1 +1029,7 @@\n-      case Bytecodes::_putfield        :  \/\/ fall through\n+      case Bytecodes::_putfield        :  {\n+        int field_index = Bytes::get_native_u2(bcp+1);\n+        int pool_index = mh->constants()->resolved_field_entry_at(field_index)->constant_pool_index();\n+        assert(pool_index < mh->constants()->length(), \"sanity check\");\n+        Bytes::put_Java_u2((address)(p+1), (u2)pool_index);     \/\/ java byte ordering\n+        break;\n+      }\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,12 @@\n-  case Bytecodes::_putfield        : \/\/ fall through\n+  case Bytecodes::_putfield        : {\n+    int index_old = s_old->get_index_u2();\n+    int index_new = s_new->get_index_u2();\n+    \/\/ Check if the names of classes, field\/method names and signatures at these indexes\n+    \/\/ are the same. Indices which are really into constantpool cache (rather than constant\n+    \/\/ pool itself) are accepted by the constantpool query routines below.\n+    if ((old_cp->klass_ref_at_noresolve(index_old, c_old) != new_cp->klass_ref_at_noresolve(index_new, c_old)) ||\n+        (old_cp->name_ref_at(index_old, c_old) != new_cp->name_ref_at(index_new, c_old)) ||\n+        (old_cp->signature_ref_at(index_old, c_old) != new_cp->signature_ref_at(index_new, c_old)))\n+      return false;\n+    break;\n+  }\n","filename":"src\/hotspot\/share\/prims\/methodComparator.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1888,0 +1888,18 @@\n+WB_ENTRY(jint, WB_getFieldEntriesLength(JNIEnv* env, jobject wb, jclass klass))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == nullptr) {\n+    return -1;\n+  }\n+  return cp->resolved_field_entries_length();\n+WB_END\n+\n+WB_ENTRY(jint, WB_getFieldCPIndex(JNIEnv* env, jobject wb, jclass klass, jint index))\n+  InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));\n+  ConstantPool* cp = ik->constants();\n+  if (cp->cache() == NULL) {\n+      return -1;\n+  }\n+  return cp->resolved_field_entry_at(index)->constant_pool_index();\n+WB_END\n+\n@@ -2774,0 +2792,2 @@\n+  {CC\"getFieldEntriesLength0\", CC\"(Ljava\/lang\/Class;)I\",  (void*)&WB_getFieldEntriesLength},\n+  {CC\"getFieldCPIndex0\",    CC\"(Ljava\/lang\/Class;I)I\", (void*)&WB_getFieldCPIndex},\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+#include \"oops\/resolvedFieldEntry.hpp\"\n@@ -226,0 +227,2 @@\n+  nonstatic_field(ConstantPoolCache,           _resolved_field_entries,                       Array<ResolvedFieldEntry>*)            \\\n+  nonstatic_field(ResolvedFieldEntry,          _cpool_index,                                  u2)                                    \\\n@@ -478,0 +481,2 @@\n+  nonstatic_field(Array<ResolvedFieldEntry>,   _length,                                       int)                                   \\\n+  nonstatic_field(Array<ResolvedFieldEntry>,   _data[0],                                      ResolvedFieldEntry)                    \\\n@@ -961,7 +966,8 @@\n-  nonstatic_field(Array<int>,                         _length,                                int)                                   \\\n-  unchecked_nonstatic_field(Array<int>,               _data,                                  sizeof(int))                           \\\n-  unchecked_nonstatic_field(Array<u1>,                _data,                                  sizeof(u1))                            \\\n-  unchecked_nonstatic_field(Array<u2>,                _data,                                  sizeof(u2))                            \\\n-  unchecked_nonstatic_field(Array<Method*>,           _data,                                  sizeof(Method*))                       \\\n-  unchecked_nonstatic_field(Array<Klass*>,            _data,                                  sizeof(Klass*))                        \\\n-  unchecked_nonstatic_field(Array<ResolvedIndyEntry>, _data,                                  sizeof(ResolvedIndyEntry))             \\\n+  nonstatic_field(Array<int>,                          _length,                               int)                                   \\\n+  unchecked_nonstatic_field(Array<int>,                _data,                                 sizeof(int))                           \\\n+  unchecked_nonstatic_field(Array<u1>,                 _data,                                 sizeof(u1))                            \\\n+  unchecked_nonstatic_field(Array<u2>,                 _data,                                 sizeof(u2))                            \\\n+  unchecked_nonstatic_field(Array<Method*>,            _data,                                 sizeof(Method*))                       \\\n+  unchecked_nonstatic_field(Array<Klass*>,             _data,                                 sizeof(Klass*))                        \\\n+  unchecked_nonstatic_field(Array<ResolvedFieldEntry>, _data,                                 sizeof(ResolvedFieldEntry))            \\\n+  unchecked_nonstatic_field(Array<ResolvedIndyEntry>,  _data,                                 sizeof(ResolvedIndyEntry))             \\\n@@ -1896,0 +1902,1 @@\n+            declare_type(Array<ResolvedFieldEntry>, MetaspaceObj)         \\\n@@ -1913,0 +1920,1 @@\n+  declare_toplevel_type(ResolvedFieldEntry)                               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -267,2 +267,1 @@\n-        \/\/ TODO: handle resolved field entries with new structure\n-        \/\/ i = ....\n+        return getCache().getFieldEntryAt(index).getConstantPoolIndex();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPool.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+    resolvedFieldArray = type.getAddressField(\"_resolved_field_entries\");\n@@ -75,0 +76,1 @@\n+  private static AddressField  resolvedFieldArray;\n@@ -94,0 +96,6 @@\n+  public ResolvedFieldEntry getFieldEntryAt(int i) {\n+    Address addr = resolvedFieldArray.getValue(getAddress());\n+    ResolvedFieldArray array = new ResolvedFieldArray(addr);\n+    return array.getAt(i);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ConstantPoolCache.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ package sun.jvm.hotspot.oops;\n+\n+ import sun.jvm.hotspot.debugger.Address;\n+ import sun.jvm.hotspot.runtime.VM;\n+ import sun.jvm.hotspot.types.Type;\n+ import sun.jvm.hotspot.types.TypeDataBase;\n+ import sun.jvm.hotspot.types.WrongTypeException;\n+ import sun.jvm.hotspot.utilities.GenericArray;\n+ import sun.jvm.hotspot.utilities.Observable;\n+ import sun.jvm.hotspot.utilities.Observer;\n+\n+ public class ResolvedFieldArray extends GenericArray {\n+     static {\n+         VM.registerVMInitializedObserver(new Observer() {\n+             public void update(Observable o, Object data) {\n+                 initialize(VM.getVM().getTypeDataBase());\n+             }\n+         });\n+     }\n+\n+     private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+         elemType = db.lookupType(\"ResolvedFieldEntry\");\n+\n+         Type type = db.lookupType(\"Array<ResolvedFieldEntry>\");\n+         dataFieldOffset = type.getAddressField(\"_data\").getOffset();\n+     }\n+\n+     private static long dataFieldOffset;\n+     protected static Type elemType;\n+\n+     public ResolvedFieldArray(Address addr) {\n+         super(addr, dataFieldOffset);\n+     }\n+\n+     public ResolvedFieldEntry getAt(int index) {\n+         if (index < 0 || index >= length()) throw new ArrayIndexOutOfBoundsException(index + \" \" + length());\n+\n+         Type elemType = getElemType();\n+\n+         Address data = getAddress().addOffsetTo(dataFieldOffset);\n+         long elemSize = elemType.getSize();\n+\n+         return new ResolvedFieldEntry(data.addOffsetTo(index* elemSize));\n+     }\n+\n+     public Type getElemType() {\n+         return elemType;\n+     }\n+ }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ResolvedFieldArray.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+ package sun.jvm.hotspot.oops;\n+\n+ import java.util.*;\n+ import sun.jvm.hotspot.debugger.*;\n+ import sun.jvm.hotspot.runtime.*;\n+ import sun.jvm.hotspot.types.*;\n+ import sun.jvm.hotspot.utilities.*;\n+ import sun.jvm.hotspot.utilities.Observable;\n+ import sun.jvm.hotspot.utilities.Observer;\n+\n+ public class ResolvedFieldEntry extends VMObject {\n+     private static long          size;\n+     private static long          baseOffset;\n+     private static CIntegerField cpIndex;\n+\n+     static {\n+         VM.registerVMInitializedObserver(new Observer() {\n+             public void update(Observable o, Object data) {\n+                 initialize(VM.getVM().getTypeDataBase());\n+             }\n+         });\n+     }\n+\n+     private static synchronized void initialize(TypeDataBase db) throws WrongTypeException {\n+         Type type = db.lookupType(\"ResolvedFieldEntry\");\n+         size = type.getSize();\n+\n+         cpIndex = type.getCIntegerField(\"_cpool_index\");\n+     }\n+\n+     ResolvedFieldEntry(Address addr) {\n+         super(addr);\n+     }\n+\n+     public int getConstantPoolIndex() {\n+         return this.getAddress().getJShortAt(cpIndex.getOffset());\n+     }\n+\n+     public void iterateFields(MetadataVisitor visitor) { }\n+ }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/ResolvedFieldEntry.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -64,2 +64,8 @@\n-  ASSERT_TRUE(strstr(output, \"volatile:\") != NULL) << \"must have volatile flag\";\n-  ASSERT_TRUE(strstr(output, \"field index:\") != NULL) << \"must have field index\";\n+  ASSERT_TRUE(strstr(output, \"Offset:\") != NULL) << \"must have field offset\";\n+  ASSERT_TRUE(strstr(output, \"Field Index:\") != NULL) << \"must have field index\";\n+  ASSERT_TRUE(strstr(output, \"CP Index:\") != NULL) << \"must have constant pool index\";\n+  ASSERT_TRUE(strstr(output, \"TOS:\") != NULL) << \"must have type\";\n+  ASSERT_TRUE(strstr(output, \"Is Final:\") != NULL) << \"must have final flag\";\n+  ASSERT_TRUE(strstr(output, \"Is Volatile:\") != NULL) << \"must have volatile flag\";\n+  ASSERT_TRUE(strstr(output, \"Bytecode 1:\") != NULL) << \"must have \\\"bytecode 1\\\"\";\n+  ASSERT_TRUE(strstr(output, \"Bytecode 2:\") != NULL) << \"must have \\\"bytecode 2\\\"\";\n","filename":"test\/hotspot\/gtest\/oops\/test_cpCache_output.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -87,0 +87,7 @@\n+            if (constantPoolSS.getTagAt(cpi).equals(Tag.FIELDREF)) {\n+                for (int field_index = 0; field_index < WB.getFieldEntriesLength(this.klass); field_index++) {\n+                    if (WB.getFieldCPIndex(this.klass, field_index) == cpi) {\n+                        return field_index;\n+                    }\n+                }\n+            }\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ConstantPoolTestsHelper.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -108,0 +108,2 @@\n+        mustMatch(\".*getstatic [0-9]+ <java\/lang\/System.out\/Ljava\/io\/PrintStream;>\");\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/BytecodeTracerTest.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -154,0 +154,12 @@\n+  private native int getFieldEntriesLength0(Class<?> aClass);\n+  public         int getFieldEntriesLength(Class<?> aClass) {\n+    Objects.requireNonNull(aClass);\n+    return getFieldEntriesLength0(aClass);\n+  }\n+\n+  private native int getFieldCPIndex0(Class<?> aClass, int index);\n+  public         int getFieldCPIndex(Class<?> aClass, int index) {\n+    Objects.requireNonNull(aClass);\n+    return getFieldCPIndex0(aClass, index);\n+  }\n+\n","filename":"test\/lib\/jdk\/test\/whitebox\/WhiteBox.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"}]}