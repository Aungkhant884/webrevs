{"files":[{"patch":"@@ -1669,1 +1669,1 @@\n-        return JVMTI_ERROR_INTERNAL;\n+        return JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,2 +106,2 @@\n-  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001\/TestDescription.java \\\n-  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002\/TestDescription.java \\\n+  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.java \\\n+  vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java \\\n","filename":"test\/hotspot\/jtreg\/TEST.quick-groups","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -94,1 +96,1 @@\n-                    workingThreads[i].suspend();\n+                    JVMTIUtils.suspendThread(workingThreads[i]);\n@@ -99,1 +101,1 @@\n-                    workingThreads[i].resume();\n+                    JVMTIUtils.resumeThread(workingThreads[i]);\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeDirectTest.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -46,2 +48,2 @@\n-                    _suspend_threads[i].suspend();\n-                    _suspend_threads[i].resume();\n+                    JVMTIUtils.suspendThread(_suspend_threads[i]);\n+                    JVMTIUtils.resumeThread(_suspend_threads[i]);\n@@ -77,1 +79,1 @@\n-            thr.suspend();\n+            JVMTIUtils.suspendThread(thr);\n@@ -80,1 +82,1 @@\n-            thr.resume();\n+            JVMTIUtils.resumeThread(thr);\n@@ -91,1 +93,1 @@\n-                thr.resume();\n+                JVMTIUtils.resumeThread(thr);\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/HandshakeSuspendExitTest.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @library \/test\/lib\n+ * @library \/test\/lib \/testlibrary\n@@ -34,0 +34,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -44,1 +46,1 @@\n-            suspend_thread.suspend();\n+            JVMTIUtils.suspendThread(suspend_thread);\n@@ -46,1 +48,1 @@\n-            suspend_thread.resume();\n+            JVMTIUtils.resumeThread(suspend_thread);\n","filename":"test\/hotspot\/jtreg\/runtime\/handshake\/SuspendBlocked.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+ * @library \/testlibrary\n@@ -38,0 +39,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -66,1 +69,1 @@\n-        t.suspend();\n+        JVMTIUtils.suspendThread(t);\n@@ -68,1 +71,1 @@\n-        t.resume();\n+        JVMTIUtils.resumeThread(t);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/terminatedThread\/TestTerminatedThread.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- *     a thread and for various thread states calls Thread.suspend()\/resume()\n- *     methods or JVMDI functions SuspendThread\/ResumeThread. Then native method\n+ *     a thread and for various thread states calls\n+ *     JVMTI functions SuspendThread\/ResumeThread. Then native method\n@@ -123,9 +123,0 @@\n-            thr.suspend();\n-            System.out.println(\"thrstat02.meth after thr.suspend()\");\n-            checkStatus(STATUS_MONITOR, true);\n-            System.out.println(\"thrstat02.meth after checkStatus(STATUS_MONITOR,true)\");\n-\n-            thr.resume();\n-            System.out.println(\"thrstat02.meth after thr.resume()\");\n-            checkStatus(STATUS_MONITOR, false);\n-            System.out.println(\"thrstat02.meth after checkStatus(STATUS_MONITOR,false)\");\n@@ -136,4 +127,0 @@\n-        thr.suspend();\n-        checkStatus(STATUS_RUNNING, true);\n-        thr.resume();\n-        checkStatus(STATUS_RUNNING, false);\n@@ -143,4 +130,0 @@\n-            checkStatus(STATUS_WAIT, false);\n-            thr.suspend();\n-            checkStatus(STATUS_WAIT, true);\n-            thr.resume();\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/thread\/GetThreadState\/thrstat02\/thrstat02.java","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+\n+    public static native void suspendThread(Thread t);\n+    public static native void resumeThread(Thread t);\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/JVMTIUtils.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+  caps.can_suspend = 1;\n@@ -55,1 +56,1 @@\n-    LOG(\"JVMTI_ERROR_THREAD_NOT_ALIVE happened\");\n+    LOG(\"JVMTI_ERROR_THREAD_NOT_ALIVE happened\\n\");\n@@ -61,0 +62,24 @@\n+JNIEXPORT void JNICALL\n+Java_jvmti_JVMTIUtils_suspendThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  jvmtiError err =  jvmti->SuspendThread(thread);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    return;\n+  }\n+  if (err == JVMTI_ERROR_THREAD_SUSPENDED) {\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"Error during SuspendThread\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_jvmti_JVMTIUtils_resumeThread(JNIEnv *jni, jclass cls, jthread thread) {\n+  jvmtiError err =  jvmti->ResumeThread(thread);\n+  if (err == JVMTI_ERROR_THREAD_NOT_ALIVE) {\n+    return;\n+  }\n+  if (err == JVMTI_ERROR_THREAD_NOT_SUSPENDED) {\n+    return;\n+  }\n+  check_jvmti_status(jni, err, \"Error during ResumeThread\");\n+}\n+\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jvmti\/libJvmtiUtils.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,1 +136,1 @@\n-    static final int MAX_CASE = 2;\n+    static final int MAX_CASE = 1;\n@@ -172,1 +172,0 @@\n-        for (int i = 0; i < MAX_CASE; i++) {\n@@ -174,7 +173,7 @@\n-            debuggee.sendSignal(\"newcheck\");\n-            try {\n-                debuggee.receiveExpectedSignal(\"checkready\");\n-            } catch (Failure e) {\n-                debuggee.quit();\n-                throw e;\n-            }\n+        debuggee.sendSignal(\"newcheck\");\n+        try {\n+            debuggee.receiveExpectedSignal(\"checkready\");\n+        } catch (Failure e) {\n+            debuggee.quit();\n+            throw e;\n+        }\n@@ -182,1 +181,1 @@\n-            log1(\"BEGIN OF CASE #\" + i);\n+        log1(\"BEGIN OF CASE #0\");\n@@ -184,5 +183,1 @@\n-            \/\/~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ variable part\n-            switch (i) {\n-            case 0:\n-                executeCase(i, \"Thread02\");\n-                break;\n+        executeCase(0, \"Thread02\");\n@@ -190,5 +185,0 @@\n-            case 1:\n-                executeCase(i, \"Thread12\");\n-                break;\n-            }\n-        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/interrupt\/interrupt001.java","additions":11,"deletions":21,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n- *          \/test\/lib\n+ *          \/test\/lib \/testlibrary\n@@ -73,1 +73,1 @@\n- *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts} -Djava.library.path=${test.nativepath}\"\n@@ -75,1 +75,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/interrupt\/interrupt001\/TestDescription.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+\n@@ -104,20 +105,3 @@\n-                switch (i) {\n-                case 0:\n-                    synchronized (interrupt001aThread.lockingObject) {\n-                        thread2 = threadStart(\"Thread02\");\n-                        thread3 = threadStart(\"Thread03\");\n-\n-                        pipe.println(\"checkready\");\n-                        if (checkInterruptStatus() == FAILED) {\n-                            exitCode = FAILED;\n-                            break label0;\n-                        }\n-                    }\n-                    log1(\"mainThread is out of: synchronized (lockingObject)\");\n-\n-                    if (waitThreadJoin(thread2) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n-                    if (waitThreadJoin(thread3) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n+                synchronized (interrupt001aThread.lockingObject) {\n+                    thread2 = threadStart(\"Thread02\");\n+                    thread3 = threadStart(\"Thread03\");\n@@ -125,3 +109,2 @@\n-                    instruction = pipe.readln();\n-                    if (!instruction.equals(\"continue\")) {\n-                        logErr(\"Unexpected instruction #1: \" + instruction);\n+                    pipe.println(\"checkready\");\n+                    if (checkInterruptStatus() == FAILED) {\n@@ -131,24 +114,2 @@\n-                    pipe.println(\"docontinue\");\n-                    break;\n-\n-                case 1:\n-                    synchronized (interrupt001aThread.lockingObject) {\n-                        thread2 = threadStart(\"Thread12\");\n-                        thread3 = threadStart(\"Thread13\");\n-\n-                        log1(\"suspending Thread2\");\n-                        thread2.suspend();\n-\n-                        log1(\"suspending Thread3\");\n-                        thread3.suspend();\n-\n-                        log1(\"interrupting the Thread3\");\n-                        thread3.interrupt();\n-\n-                        pipe.println(\"checkready\");\n-                        if (checkInterruptStatus() == FAILED) {\n-                            exitCode = FAILED;\n-                            break label0;\n-                        }\n-                    }\n-                    log1(\"mainThread is out of: synchronized (lockingObject)\");\n+                }\n+                log1(\"mainThread is out of: synchronized (lockingObject)\");\n@@ -156,10 +117,6 @@\n-                    log1(\"resuming Thread2\");\n-                    thread2.resume();\n-                    if (waitThreadJoin(thread2) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n-                    log1(\"resuming Thread3\");\n-                    thread3.resume();\n-                    if (waitThreadJoin(thread3) == FAILED) {\n-                        exitCode = FAILED;\n-                    }\n+                if (waitThreadJoin(thread2) == FAILED) {\n+                    exitCode = FAILED;\n+                }\n+                if (waitThreadJoin(thread3) == FAILED) {\n+                    exitCode = FAILED;\n+                }\n@@ -167,8 +124,8 @@\n-                    instruction = pipe.readln();\n-                    if (!instruction.equals(\"continue\")) {\n-                        logErr(\"Unexpected instruction #2: \" + instruction);\n-                        exitCode = FAILED;\n-                        break label0;\n-                    }\n-                    pipe.println(\"docontinue\");\n-                    break;\n+                instruction = pipe.readln();\n+                if (!instruction.equals(\"continue\")) {\n+                    logErr(\"Unexpected instruction #1: \" + instruction);\n+                    exitCode = FAILED;\n+                    break label0;\n+                }\n+                pipe.println(\"docontinue\");\n+                break;\n@@ -177,1 +134,0 @@\n-                }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/interrupt\/interrupt001a.java","additions":23,"deletions":67,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,28 @@\n+\/*\n+ * @test\n+ *\n+ * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n+ * VM Testbase keywords: [quick, monitoring]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     The test checks that\n+ *         ThreadInfo.isSuspended()\n+ *     returns correct values for a thread in different states.\n+ *     The test starts an instance of MyThread and checks that isSuspended()\n+ *     returns false for it. Then it suspends the thread and expects the method\n+ *     to return true. After that the MyThread is resumed and isSuspended() must\n+ *     return false.\n+ *     Testing of the method does not depend on the way to access metrics, so\n+ *     only one (direct access) is implemented in the test.\n+ * COMMENT\n+ *     Fixed the bug\n+ *     4989235 TEST: The spec is updated accoring to 4982289, 4985742\n+ *     Updated according to:\n+ *     5024531 Fix MBeans design flaw that restricts to use JMX CompositeData\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *          \/testlibrary\n+ * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended001\n+ *\/\n+\n@@ -30,0 +58,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -56,1 +86,1 @@\n-        thread.suspend();\n+        JVMTIUtils.suspendThread(thread);\n@@ -66,1 +96,1 @@\n-        thread.resume();\n+        JVMTIUtils.resumeThread(thread);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.java","additions":33,"deletions":3,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     The test checks that\n- *         ThreadInfo.isSuspended()\n- *     returns correct values for a thread in different states.\n- *     The test starts an instance of MyThread and checks that isSuspended()\n- *     returns false for it. Then it suspends the thread and expects the method\n- *     to return true. After that the MyThread is resumed and isSuspended() must\n- *     return false.\n- *     Testing of the method does not depend on the way to access metrics, so\n- *     only one (direct access) is implemented in the test.\n- * COMMENT\n- *     Fixed the bug\n- *     4989235 TEST: The spec is updated accoring to 4982289, 4985742\n- *     Updated according to:\n- *     5024531 Fix MBeans design flaw that restricts to use JMX CompositeData\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended001\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001\/TestDescription.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,19 @@\n+\/*\n+ * @test\n+ *\n+ * @bug 8167108 8266130\n+ * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.\n+ * VM Testbase keywords: [quick, monitoring]\n+ * VM Testbase readme:\n+ * DESCRIPTION\n+ *     Same test as issuspended001 with additional calls to\n+ *     ThreadInfo.isSuspended() as the worker thread is exiting.\n+ * COMMENT\n+ *     Derived from nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ *          \/testlibrary\n+ * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n+ *\/\n+\n@@ -30,0 +49,2 @@\n+import jvmti.JVMTIUtils;\n+\n@@ -81,1 +102,1 @@\n-            thread.suspend();\n+            JVMTIUtils.suspendThread(thread);\n@@ -92,1 +113,1 @@\n-            thread.resume();\n+            JVMTIUtils.resumeThread(thread);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- *\n- * @bug 8167108 8266130\n- * @summary converted from VM Testbase nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002.\n- * VM Testbase keywords: [quick, monitoring]\n- * VM Testbase readme:\n- * DESCRIPTION\n- *     Same test as issuspended001 with additional calls to\n- *     ThreadInfo.isSuspended() as the worker thread is exiting.\n- * COMMENT\n- *     Derived from nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended001.\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm nsk.monitoring.ThreadInfo.isSuspended.issuspended002\n- *\/\n-\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/monitoring\/ThreadInfo\/isSuspended\/issuspended002\/TestDescription.java","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"}]}