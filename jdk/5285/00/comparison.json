{"files":[{"patch":"@@ -1461,0 +1461,214 @@\n+    \/**\n+     * Returns the smallest (closest to negative infinity)\n+     * {@code int} value that is greater than or equal to the algebraic quotient.\n+     * There is one special case: if the dividend is\n+     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},\n+     * then integer overflow occurs and\n+     * the result is equal to {@code Integer.MIN_VALUE}.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * positive infinity (ceiling) rounding mode.\n+     * The ceiling rounding mode gives different results from truncation\n+     * when the exact quotient is not an integer and is positive.\n+     * <ul>\n+     *   <li>If the signs of the arguments are different, the results of\n+     *       {@code ceilDiv} and the {@code \/} operator are the same.  <br>\n+     *       For example, {@code ceilDiv(-4, 3) == -1} and {@code (-4 \/ 3) == -1}.<\/li>\n+     *   <li>If the signs of the arguments are the same, {@code ceilDiv}\n+     *       returns the smallest integer greater than or equal to the quotient\n+     *       while the {@code \/} operator returns the largest integer less\n+     *       than or equal to the quotient.\n+     *       They differ if and only if the quotient is not an integer.<br>\n+     *       For example, {@code ceilDiv(4, 3) == 2},\n+     *       whereas {@code (4 \/ 3) == 1}.\n+     *   <\/li>\n+     * <\/ul>\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the smallest (closest to negative infinity)\n+     * {@code int} value that is greater than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see #ceilMod(int, int)\n+     * @see #ceil(double)\n+     * @since 18\n+     *\/\n+    public static int ceilDiv(int x, int y) {\n+        final int q = x \/ y;\n+        \/\/ if the signs are the same and modulo not zero, round up\n+        if ((x ^ y) >= 0 && (q * y != x)) {\n+            return q + 1;\n+        }\n+        return q;\n+    }\n+\n+    \/**\n+     * Returns the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * There is one special case: if the dividend is\n+     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n+     * then integer overflow occurs and\n+     * the result is equal to {@code Long.MIN_VALUE}.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * positive infinity (ceiling) rounding mode.\n+     * The ceiling rounding mode gives different results from truncation\n+     * when the exact result is not an integer and is positive.\n+     * <p>\n+     * For examples, see {@link #ceilDiv(int, int)}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see #ceilMod(int, int)\n+     * @see #ceil(double)\n+     * @since 18\n+     *\/\n+    public static long ceilDiv(long x, int y) {\n+        return ceilDiv(x, (long)y);\n+    }\n+\n+    \/**\n+     * Returns the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * There is one special case: if the dividend is\n+     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n+     * then integer overflow occurs and\n+     * the result is equal to {@code Long.MIN_VALUE}.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * positive infinity (ceiling) rounding mode.\n+     * The ceiling rounding mode gives different results from truncation\n+     * when the exact result is not an integer and is positive.\n+     * <p>\n+     * For examples, see {@link #ceilDiv(int, int)}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see #ceilMod(int, int)\n+     * @see #ceil(double)\n+     * @since 18\n+     *\/\n+    public static long ceilDiv(long x, long y) {\n+        final long q = x \/ y;\n+        \/\/ if the signs are the same and modulo not zero, round up\n+        if ((x ^ y) >= 0 && (q * y != x)) {\n+            return q + 1;\n+        }\n+        return q;\n+    }\n+\n+    \/**\n+     * Returns the ceiling modulus of the {@code int} arguments.\n+     * <p>\n+     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n+     * has the opposite sign as the divisor {@code y} or is zero, and\n+     * is in the range of {@code -abs(y) < r < +abs(y)}.\n+     *\n+     * <p>\n+     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n+     * <ul>\n+     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n+     * <\/ul>\n+     * <p>\n+     * The difference in values between {@code ceilMod} and the {@code %} operator\n+     * is due to the difference between {@code ceilDiv} and the {@code \/}\n+     * operator, as detailed in {@linkplain #ceilDiv(int, int)}.\n+     * <p>\n+     * Examples:\n+     * <ul>\n+     *   <li>Regardless of the signs of the arguments, {@code ceilMod}(x, y)\n+     *       is zero exactly when {@code x % y} is zero as well.<\/li>\n+     *   <li>If neither of {@code ceilMod}(x, y) or {@code x % y} is zero,\n+     *       their results differ exactly when the signs of the arguments are the same.<br>\n+     *       <ul>\n+     *       <li>{@code ceilMod(+4, +3) == -2}; &nbsp; and {@code (+4 % +3) == +1}<\/li>\n+     *       <li>{@code ceilMod(-4, -3) == +2}; &nbsp; and {@code (-4 % -3) == -1}<\/li>\n+     *       <li>{@code ceilMod(+4, -3) == +1}; &nbsp; and {@code (+4 % -3) == +1}<\/li>\n+     *       <li>{@code ceilMod(-4, +3) == -1}; &nbsp; and {@code (-4 % +3) == -1}<\/li>\n+     *       <\/ul>\n+     *   <\/li>\n+     * <\/ul>\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see #ceilDiv(int, int)\n+     * @since 18\n+     *\/\n+    public static int ceilMod(int x, int y) {\n+        final int r = x % y;\n+        \/\/ if the signs are the same and modulo not zero, adjust result\n+        if ((x ^ y) >= 0 && r != 0) {\n+            return r - y;\n+        }\n+        return r;\n+    }\n+\n+    \/**\n+     * Returns the ceiling modulus of the {@code long} and {@code int} arguments.\n+     * <p>\n+     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n+     * has the opposite sign as the divisor {@code y} or is zero, and\n+     * is in the range of {@code -abs(y) < r < +abs(y)}.\n+     *\n+     * <p>\n+     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n+     * <ul>\n+     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n+     * <\/ul>\n+     * <p>\n+     * For examples, see {@link #ceilMod(int, int)}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see #ceilDiv(long, int)\n+     * @since 18\n+     *\/\n+    public static int ceilMod(long x, int y) {\n+        \/\/ Result cannot overflow the range of int.\n+        return (int)ceilMod(x, (long)y);\n+    }\n+\n+    \/**\n+     * Returns the ceiling modulus of the {@code long} arguments.\n+     * <p>\n+     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n+     * has the opposite sign as the divisor {@code y} or is zero, and\n+     * is in the range of {@code -abs(y) < r < +abs(y)}.\n+     *\n+     * <p>\n+     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n+     * <ul>\n+     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n+     * <\/ul>\n+     * <p>\n+     * For examples, see {@link #ceilMod(int, int)}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see #ceilDiv(long, long)\n+     * @since 18\n+     *\/\n+    public static long ceilMod(long x, long y) {\n+        final long r = x % y;\n+        \/\/ if the signs are the same and modulo not zero, adjust result\n+        if ((x ^ y) >= 0 && r != 0) {\n+            return r - y;\n+        }\n+        return r;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"modified"},{"patch":"@@ -1207,0 +1207,156 @@\n+    \/**\n+     * Returns the smallest (closest to negative infinity)\n+     * {@code int} value that is greater than or equal to the algebraic quotient.\n+     * There is one special case: if the dividend is\n+     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is {@code -1},\n+     * then integer overflow occurs and\n+     * the result is equal to {@code Integer.MIN_VALUE}.\n+     * <p>\n+     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n+     * a comparison to the integer division {@code \/} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the smallest (closest to negative infinity)\n+     * {@code int} value that is greater than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see Math#ceilDiv(int, int)\n+     * @see Math#ceil(double)\n+     * @since 18\n+     *\/\n+    public static int ceilDiv(int x, int y) {\n+        return Math.ceilDiv(x, y);\n+    }\n+\n+    \/**\n+     * Returns the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * There is one special case: if the dividend is\n+     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n+     * then integer overflow occurs and\n+     * the result is equal to {@code Long.MIN_VALUE}.\n+     * <p>\n+     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n+     * a comparison to the integer division {@code \/} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see Math#ceilDiv(long, int)\n+     * @see Math#ceil(double)\n+     * @since 18\n+     *\/\n+    public static long ceilDiv(long x, int y) {\n+        return Math.ceilDiv(x, y);\n+    }\n+\n+    \/**\n+     * Returns the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * There is one special case: if the dividend is\n+     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is {@code -1},\n+     * then integer overflow occurs and\n+     * the result is equal to {@code Long.MIN_VALUE}.\n+     * <p>\n+     * See {@link Math#ceilDiv(int, int) Math.ceilDiv} for examples and\n+     * a comparison to the integer division {@code \/} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the smallest (closest to negative infinity)\n+     * {@code long} value that is greater than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see Math#ceilDiv(long, long)\n+     * @see Math#ceil(double)\n+     * @since 18\n+     *\/\n+    public static long ceilDiv(long x, long y) {\n+        return Math.ceilDiv(x, y);\n+    }\n+\n+    \/**\n+     * Returns the ceiling modulus of the {@code int} arguments.\n+     * <p>\n+     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n+     * has the opposite sign as the divisor {@code y} or is zero, and\n+     * is in the range of {@code -abs(y) < r < +abs(y)}.\n+     *\n+     * <p>\n+     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n+     * <ul>\n+     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n+     * <\/ul>\n+     * <p>\n+     * See {@link Math#ceilMod(int, int) Math.ceilMod} for examples and\n+     * a comparison to the {@code %} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see Math#ceilMod(int, int)\n+     * @see StrictMath#ceilDiv(int, int)\n+     * @since 18\n+     *\/\n+    public static int ceilMod(int x, int y) {\n+        return Math.ceilMod(x , y);\n+    }\n+\n+    \/**\n+     * Returns the ceiling modulus of the {@code long} and {@code int} arguments.\n+     * <p>\n+     * The ceiling modulus is {@code r = x - (ceilDiv(x, y) * y)},\n+     * has the opposite sign as the divisor {@code y} or is zero, and\n+     * is in the range of {@code -abs(y) < r < +abs(y)}.\n+     *\n+     * <p>\n+     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n+     * <ul>\n+     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n+     * <\/ul>\n+     * <p>\n+     * See {@link Math#ceilMod(int, int) Math.ceilMod} for examples and\n+     * a comparison to the {@code %} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see Math#ceilMod(long, int)\n+     * @see StrictMath#ceilDiv(long, int)\n+     * @since 18\n+     *\/\n+    public static int ceilMod(long x, int y) {\n+        return Math.ceilMod(x , y);\n+    }\n+\n+    \/**\n+     * Returns the ceiling modulus of the {@code long} arguments.\n+     * <p>\n+     * The floor modulus is {@code r = x - (ceilDiv(x, y) * y)},\n+     * has the same sign as the divisor {@code y} or is zero, and\n+     * is in the range of {@code -abs(y) < r < +abs(y)}.\n+     *\n+     * <p>\n+     * The relationship between {@code ceilDiv} and {@code ceilMod} is such that:\n+     * <ul>\n+     *   <li>{@code ceilDiv(x, y) * y + ceilMod(x, y) == x}<\/li>\n+     * <\/ul>\n+     * <p>\n+     * See {@link Math#ceilMod(int, int) Math.ceilMod} for examples and\n+     * a comparison to the {@code %} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the ceiling modulus {@code x - (ceilDiv(x, y) * y)}\n+     * @throws ArithmeticException if the divisor {@code y} is zero\n+     * @see Math#ceilMod(long, long)\n+     * @see StrictMath#ceilDiv(long, long)\n+     * @since 18\n+     *\/\n+    public static long ceilMod(long x, long y) {\n+        return Math.ceilMod(x, y);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,3 @@\n- * @test Test Math and StrictMath Floor Div \/ Modulo operations.\n- * @bug 6282196\n- * @summary Basic tests for Floor division and modulo methods for both Math\n+ * @test Test Math and StrictMath Floor and Ceil Div \/ Modulo operations.\n+ * @bug 6282196 8271602\n+ * @summary Basic tests for Floor and Ceil division and modulo methods for both Math\n@@ -46,0 +46,1 @@\n+        testLongIntFloorDivMod();\n@@ -47,0 +48,3 @@\n+        testIntCeilDivMod();\n+        testLongIntCeilDivMod();\n+        testLongCeilDivMod();\n@@ -287,7 +291,7 @@\n-        testLongIntFloorDivMod(Long.MAX_VALUE, 1, Long.MAX_VALUE, 0L);\n-        testLongIntFloorDivMod(Long.MAX_VALUE, -1, -Long.MAX_VALUE, 0L);\n-        testLongIntFloorDivMod(Long.MAX_VALUE, 3, Long.MAX_VALUE \/ 3L, 1L);\n-        testLongIntFloorDivMod(Long.MAX_VALUE - 1L, 3, (Long.MAX_VALUE - 1L) \/ 3L, 0L);\n-        testLongIntFloorDivMod(Long.MIN_VALUE, 3, Long.MIN_VALUE \/ 3L - 1L, 1L);\n-        testLongIntFloorDivMod(Long.MIN_VALUE + 1L, 3, Long.MIN_VALUE \/ 3L - 1L, 2L);\n-        testLongIntFloorDivMod(Long.MIN_VALUE + 1, -1, Long.MAX_VALUE, 0L);\n+        testLongIntFloorDivMod(Long.MAX_VALUE, 1, Long.MAX_VALUE, 0);\n+        testLongIntFloorDivMod(Long.MAX_VALUE, -1, -Long.MAX_VALUE, 0);\n+        testLongIntFloorDivMod(Long.MAX_VALUE, 3, Long.MAX_VALUE \/ 3L, 1);\n+        testLongIntFloorDivMod(Long.MAX_VALUE - 1L, 3, (Long.MAX_VALUE - 1L) \/ 3L, 0);\n+        testLongIntFloorDivMod(Long.MIN_VALUE, 3, Long.MIN_VALUE \/ 3L - 1L, 1);\n+        testLongIntFloorDivMod(Long.MIN_VALUE + 1L, 3, Long.MIN_VALUE \/ 3L - 1L, 2);\n+        testLongIntFloorDivMod(Long.MIN_VALUE + 1, -1, Long.MAX_VALUE, 0);\n@@ -299,1 +303,1 @@\n-        testLongIntFloorDivMod(Long.MIN_VALUE, -1, Long.MIN_VALUE, 0L);\n+        testLongIntFloorDivMod(Long.MIN_VALUE, -1, Long.MIN_VALUE, 0);\n@@ -344,1 +348,1 @@\n-            fail(\"FAIL: long Math.floorMod(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+            fail(\"FAIL: int Math.floorMod(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n@@ -349,1 +353,1 @@\n-            fail(\"FAIL: long StrictMath.floorMod(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+            fail(\"FAIL: int StrictMath.floorMod(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n@@ -359,1 +363,1 @@\n-            long fr = resultD.longValue();\n+            int fr = resultD.intValue();\n@@ -414,1 +418,1 @@\n-     * Invoke floorDiv and return the result or any exception.\n+     * Invoke floorMod and return the result or any exception.\n@@ -428,1 +432,1 @@\n-     * Invoke floorDiv and return the result or any exception.\n+     * Invoke floorMod and return the result or any exception.\n@@ -442,1 +446,1 @@\n-     * Invoke floorDiv and return the result or any exception.\n+     * Invoke floorMod and return the result or any exception.\n@@ -498,1 +502,1 @@\n-     * Invoke floorDiv and return the result or any exception.\n+     * Invoke floorMod and return the result or any exception.\n@@ -512,1 +516,1 @@\n-     * Invoke floorDiv and return the result or any exception.\n+     * Invoke floorMod and return the result or any exception.\n@@ -526,1 +530,1 @@\n-     * Invoke floorDiv and return the result or any exception.\n+     * Invoke floorMod and return the result or any exception.\n@@ -539,0 +543,476 @@\n+    \/**\n+     * Test the integer ceilDiv and ceilMod methods.\n+     * Math and StrictMath tested and the same results are expected for both.\n+     *\/\n+    static void testIntCeilDivMod() {\n+        testIntCeilDivMod(4, 0, new ArithmeticException(), new ArithmeticException()); \/\/ Should throw ArithmeticException\n+        testIntCeilDivMod(4, 3, 2, -2);\n+        testIntCeilDivMod(3, 3, 1, 0);\n+        testIntCeilDivMod(2, 3, 1, -1);\n+        testIntCeilDivMod(1, 3, 1, -2);\n+        testIntCeilDivMod(0, 3, 0, 0);\n+        testIntCeilDivMod(4, -3, -1, 1);\n+        testIntCeilDivMod(3, -3, -1, 0);\n+        testIntCeilDivMod(2, -3, 0, 2);\n+        testIntCeilDivMod(1, -3, 0, 1);\n+        testIntCeilDivMod(0, -3, 0, 0);\n+        testIntCeilDivMod(-1, 3, 0, -1);\n+        testIntCeilDivMod(-2, 3, 0, -2);\n+        testIntCeilDivMod(-3, 3, -1, 0);\n+        testIntCeilDivMod(-4, 3, -1, -1);\n+        testIntCeilDivMod(-1, -3, 1, 2);\n+        testIntCeilDivMod(-2, -3, 1, 1);\n+        testIntCeilDivMod(-3, -3, 1, 0);\n+        testIntCeilDivMod(-4, -3, 2, 2);\n+        testIntCeilDivMod(Integer.MAX_VALUE, 1, Integer.MAX_VALUE, 0);\n+        testIntCeilDivMod(Integer.MAX_VALUE, -1, -Integer.MAX_VALUE, 0);\n+        testIntCeilDivMod(Integer.MAX_VALUE, 3, 715_827_883, -2);\n+        testIntCeilDivMod(Integer.MAX_VALUE - 1, 3, 715_827_882, 0);\n+        testIntCeilDivMod(Integer.MIN_VALUE, 3, -715_827_882, -2);\n+        testIntCeilDivMod(Integer.MIN_VALUE + 1, 3, -715_827_882, -1);\n+        testIntCeilDivMod(Integer.MIN_VALUE + 1, -1, Integer.MAX_VALUE, 0);\n+        testIntCeilDivMod(Integer.MAX_VALUE, Integer.MAX_VALUE, 1, 0);\n+        testIntCeilDivMod(Integer.MAX_VALUE, Integer.MIN_VALUE, 0, Integer.MAX_VALUE);\n+        testIntCeilDivMod(Integer.MIN_VALUE, Integer.MIN_VALUE, 1, 0);\n+        testIntCeilDivMod(Integer.MIN_VALUE, Integer.MAX_VALUE, -1, -1);\n+        \/\/ Special case of integer overflow\n+        testIntCeilDivMod(Integer.MIN_VALUE, -1, Integer.MIN_VALUE, 0);\n+    }\n+\n+    \/**\n+     * Test CeilDiv and then CeilMod with int data.\n+     *\/\n+    static void testIntCeilDivMod(int x, int y, Object divExpected, Object modExpected) {\n+        testIntCeilDiv(x, y, divExpected);\n+        testIntCeilMod(x, y, modExpected);\n+    }\n+\n+    \/**\n+     * Test CeilDiv with int data.\n+     *\/\n+    static void testIntCeilDiv(int x, int y, Object expected) {\n+        Object result = doCeilDiv(x, y);\n+        if (!resultEquals(result, expected)) {\n+            fail(\"FAIL: Math.ceilDiv(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+        }\n+\n+        Object strict_result = doStrictCeilDiv(x, y);\n+        if (!resultEquals(strict_result, expected)) {\n+            fail(\"FAIL: StrictMath.ceilDiv(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+        }\n+    }\n+\n+    \/**\n+     * Test CeilMod with int data.\n+     *\/\n+    static void testIntCeilMod(int x, int y, Object expected) {\n+        Object result = doCeilMod(x, y);\n+        if (!resultEquals(result, expected)) {\n+            fail(\"FAIL: Math.ceilMod(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+        }\n+\n+        Object strict_result = doStrictCeilMod(x, y);\n+        if (!resultEquals(strict_result, expected)) {\n+            fail(\"FAIL: StrictMath.ceilMod(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+        }\n+\n+        try {\n+            \/\/ Verify result against double precision ceil function\n+            int tmp = x \/ y;     \/\/ Force ArithmeticException for divide by zero\n+            double ff = x - Math.ceil((double)x \/ (double)y) * y;\n+            int fr = (int)ff;\n+            boolean t = (fr == ((Integer)result));\n+            if (!result.equals(fr)) {\n+                fail(\"FAIL: Math.ceilMod(%d, %d) = %s differs from Math.ceil(x, y): %d%n\", x, y, result, fr);\n+            }\n+        } catch (ArithmeticException ae) {\n+            if (y != 0) {\n+                fail(\"FAIL: Math.ceilMod(%d, %d); unexpected %s%n\", x, y, ae);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test the ceilDiv and ceilMod methods for primitive long.\n+     *\/\n+    static void testLongCeilDivMod() {\n+        testLongCeilDivMod(4L, 0L, new ArithmeticException(), new ArithmeticException()); \/\/ Should throw ArithmeticException\n+        testLongCeilDivMod(4L, 3L, 2L, -2L);\n+        testLongCeilDivMod(3L, 3L, 1L, 0L);\n+        testLongCeilDivMod(2L, 3L, 1L, -1L);\n+        testLongCeilDivMod(1L, 3L, 1L, -2L);\n+        testLongCeilDivMod(0L, 3L, 0L, 0L);\n+        testLongCeilDivMod(4L, -3L, -1L, 1L);\n+        testLongCeilDivMod(3L, -3L, -1L, 0L);\n+        testLongCeilDivMod(2L, -3L, 0L, 2L);\n+        testLongCeilDivMod(1L, -3L, 0L, 1L);\n+        testLongCeilDivMod(0L, -3L, 0L, 0L);\n+        testLongCeilDivMod(-1L, 3L, 0L, -1L);\n+        testLongCeilDivMod(-2L, 3L, 0L, -2L);\n+        testLongCeilDivMod(-3L, 3L, -1L, 0L);\n+        testLongCeilDivMod(-4L, 3L, -1L, -1L);\n+        testLongCeilDivMod(-1L, -3L, 1L, 2L);\n+        testLongCeilDivMod(-2L, -3L, 1L, 1L);\n+        testLongCeilDivMod(-3L, -3L, 1L, 0L);\n+        testLongCeilDivMod(-4L, -3L, 2L, 2L);\n+\n+        testLongCeilDivMod(Long.MAX_VALUE, 1, Long.MAX_VALUE, 0L);\n+        testLongCeilDivMod(Long.MAX_VALUE, -1, -Long.MAX_VALUE, 0L);\n+        testLongCeilDivMod(Long.MAX_VALUE, 3L, Long.MAX_VALUE \/ 3L + 1, -2L);\n+        testLongCeilDivMod(Long.MAX_VALUE - 1L, 3L, (Long.MAX_VALUE - 1L) \/ 3L, 0L);\n+        testLongCeilDivMod(Long.MIN_VALUE, 3L, Long.MIN_VALUE \/ 3L, -2L);\n+        testLongCeilDivMod(Long.MIN_VALUE + 1L, 3L, Long.MIN_VALUE \/ 3L, -1L);\n+        testLongCeilDivMod(Long.MIN_VALUE + 1, -1, Long.MAX_VALUE, 0L);\n+        testLongCeilDivMod(Long.MAX_VALUE, Long.MAX_VALUE, 1L, 0L);\n+        testLongCeilDivMod(Long.MAX_VALUE, Long.MIN_VALUE, 0L, Long.MAX_VALUE);\n+        testLongCeilDivMod(Long.MIN_VALUE, Long.MIN_VALUE, 1L, 0L);\n+        testLongCeilDivMod(Long.MIN_VALUE, Long.MAX_VALUE, -1L, -1L);\n+        \/\/ Special case of integer overflow\n+        testLongCeilDivMod(Long.MIN_VALUE, -1, Long.MIN_VALUE, 0L);\n+    }\n+\n+    \/**\n+     * Test the long ceilDiv and ceilMod methods.\n+     * Math and StrictMath are tested and the same results are expected for both.\n+     *\/\n+    static void testLongCeilDivMod(long x, long y, Object divExpected, Object modExpected) {\n+        testLongCeilDiv(x, y, divExpected);\n+        testLongCeilMod(x, y, modExpected);\n+    }\n+\n+    \/**\n+     * Test CeilDiv with long arguments against expected value.\n+     * The expected value is usually a Long but in some cases  is\n+     * an ArithmeticException.\n+     *\n+     * @param x dividend\n+     * @param y modulus\n+     * @param expected expected value,\n+     *\/\n+    static void testLongCeilDiv(long x, long y, Object expected) {\n+        Object result = doCeilDiv(x, y);\n+        if (!resultEquals(result, expected)) {\n+            fail(\"FAIL: long Math.ceilDiv(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+        }\n+\n+        Object strict_result = doStrictCeilDiv(x, y);\n+        if (!resultEquals(strict_result, expected)) {\n+            fail(\"FAIL: long StrictMath.ceilDiv(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+        }\n+    }\n+\n+    \/**\n+     * Test CeilMod of long arguments against expected value.\n+     * The expected value is usually a Long but in some cases  is\n+     * an ArithmeticException.\n+     *\n+     * @param x dividend\n+     * @param y modulus\n+     * @param expected expected value\n+     *\/\n+    static void testLongCeilMod(long x, long y, Object expected) {\n+        Object result = doCeilMod(x, y);\n+        if (!resultEquals(result, expected)) {\n+            fail(\"FAIL: long Math.ceilMod(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+        }\n+\n+        Object strict_result = doStrictCeilMod(x, y);\n+        if (!resultEquals(strict_result, expected)) {\n+            fail(\"FAIL: long StrictMath.ceilMod(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+        }\n+\n+        try {\n+            \/\/ Verify the result against BigDecimal rounding mode.\n+            BigDecimal xD = new BigDecimal(x);\n+            BigDecimal yD = new BigDecimal(y);\n+            BigDecimal resultD = xD.divide(yD, RoundingMode.CEILING);\n+            resultD = resultD.multiply(yD);\n+            resultD = xD.subtract(resultD);\n+            long fr = resultD.longValue();\n+            if (!result.equals(fr)) {\n+                fail(\"FAIL: Long.ceilMod(%d, %d) = %d is different than BigDecimal result: %d%n\", x, y, result, fr);\n+\n+            }\n+        } catch (ArithmeticException ae) {\n+            if (y != 0) {\n+                fail(\"FAIL: long Math.ceilMod(%d, %d); unexpected ArithmeticException from bigdecimal\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test the ceilDiv and ceilMod methods for mixed long and int.\n+     *\/\n+    static void testLongIntCeilDivMod() {\n+        testLongIntCeilDivMod(4L, 0, new ArithmeticException(), new ArithmeticException()); \/\/ Should throw ArithmeticException\n+        testLongIntCeilDivMod(4L, 3, 2L, -2);\n+        testLongIntCeilDivMod(3L, 3, 1L, 0);\n+        testLongIntCeilDivMod(2L, 3, 1L, -1);\n+        testLongIntCeilDivMod(1L, 3, 1L, -2);\n+        testLongIntCeilDivMod(0L, 3, 0L, 0);\n+        testLongIntCeilDivMod(4L, -3, -1L, 1);\n+        testLongIntCeilDivMod(3L, -3, -1L, 0);\n+        testLongIntCeilDivMod(2L, -3, 0L, 2);\n+        testLongIntCeilDivMod(1L, -3, 0L, 1);\n+        testLongIntCeilDivMod(0L, -3, 0L, 0);\n+        testLongIntCeilDivMod(-1L, 3, 0L, -1);\n+        testLongIntCeilDivMod(-2L, 3, 0L, -2);\n+        testLongIntCeilDivMod(-3L, 3, -1L, 0);\n+        testLongIntCeilDivMod(-4L, 3, -1L, -1);\n+        testLongIntCeilDivMod(-1L, -3, 1L, 2);\n+        testLongIntCeilDivMod(-2L, -3, 1L, 1);\n+        testLongIntCeilDivMod(-3L, -3, 1L, 0);\n+        testLongIntCeilDivMod(-4L, -3, 2L, 2);\n+\n+        testLongIntCeilDivMod(Long.MAX_VALUE, 1, Long.MAX_VALUE, 0);\n+        testLongIntCeilDivMod(Long.MAX_VALUE, -1, -Long.MAX_VALUE, 0);\n+        testLongIntCeilDivMod(Long.MAX_VALUE, 3, Long.MAX_VALUE \/ 3L + 1, -2);\n+        testLongIntCeilDivMod(Long.MAX_VALUE - 1L, 3, (Long.MAX_VALUE - 1L) \/ 3L, 0);\n+        testLongIntCeilDivMod(Long.MIN_VALUE, 3, Long.MIN_VALUE \/ 3L, -2);\n+        testLongIntCeilDivMod(Long.MIN_VALUE + 1L, 3, Long.MIN_VALUE \/ 3L, -1);\n+        testLongIntCeilDivMod(Long.MIN_VALUE + 1, -1, Long.MAX_VALUE, 0);\n+        testLongIntCeilDivMod(Long.MAX_VALUE, Integer.MAX_VALUE, 4_294_967_299L, -2_147_483_646);\n+        testLongIntCeilDivMod(Long.MAX_VALUE, Integer.MIN_VALUE, -4_294_967_295L, 2_147_483_647);\n+        testLongIntCeilDivMod(Long.MIN_VALUE, Integer.MIN_VALUE, 4_294_967_296L, 0);\n+        testLongIntCeilDivMod(Long.MIN_VALUE, Integer.MAX_VALUE, -4_294_967_298L, -2);\n+        \/\/ Special case of integer overflow\n+        testLongIntCeilDivMod(Long.MIN_VALUE, -1, Long.MIN_VALUE, 0);\n+    }\n+\n+    \/**\n+     * Test the integer ceilDiv and ceilMod methods.\n+     * Math and StrictMath are tested and the same results are expected for both.\n+     *\/\n+    static void testLongIntCeilDivMod(long x, int y, Object divExpected, Object modExpected) {\n+        testLongIntCeilDiv(x, y, divExpected);\n+        testLongIntCeilMod(x, y, modExpected);\n+    }\n+\n+    \/**\n+     * Test CeilDiv with long arguments against expected value.\n+     * The expected value is usually a Long but in some cases  is\n+     * an ArithmeticException.\n+     *\n+     * @param x dividend\n+     * @param y modulus\n+     * @param expected expected value,\n+     *\/\n+    static void testLongIntCeilDiv(long x, int y, Object expected) {\n+        Object result = doCeilDiv(x, y);\n+        if (!resultEquals(result, expected)) {\n+            fail(\"FAIL: long Math.ceilDiv(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+        }\n+\n+        Object strict_result = doStrictCeilDiv(x, y);\n+        if (!resultEquals(strict_result, expected)) {\n+            fail(\"FAIL: long StrictMath.ceilDiv(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+        }\n+    }\n+\n+    \/**\n+     * Test CeilMod of long arguments against expected value.\n+     * The expected value is usually a Long but in some cases  is\n+     * an ArithmeticException.\n+     *\n+     * @param x dividend\n+     * @param y modulus\n+     * @param expected expected value\n+     *\/\n+    static void testLongIntCeilMod(long x, int y, Object expected) {\n+        Object result = doCeilMod(x, y);\n+        if (!resultEquals(result, expected)) {\n+            fail(\"FAIL: int Math.ceilMod(%d, %d) = %s; expected %s%n\", x, y, result, expected);\n+        }\n+\n+        Object strict_result = doStrictCeilMod(x, y);\n+        if (!resultEquals(strict_result, expected)) {\n+            fail(\"FAIL: int StrictMath.ceilMod(%d, %d) = %s; expected %s%n\", x, y, strict_result, expected);\n+        }\n+\n+        try {\n+            \/\/ Verify the result against BigDecimal rounding mode.\n+            BigDecimal xD = new BigDecimal(x);\n+            BigDecimal yD = new BigDecimal(y);\n+            BigDecimal resultD = xD.divide(yD, RoundingMode.CEILING);\n+            resultD = resultD.multiply(yD);\n+            resultD = xD.subtract(resultD);\n+            int fr = resultD.intValue();\n+            if (!result.equals(fr)) {\n+                fail(\"FAIL: Long.ceilMod(%d, %d) = %d is different than BigDecimal result: %d%n\", x, y, result, fr);\n+\n+            }\n+        } catch (ArithmeticException ae) {\n+            if (y != 0) {\n+                fail(\"FAIL: long Math.ceilMod(%d, %d); unexpected ArithmeticException from bigdecimal\");\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilDiv and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doCeilDiv(int x, int y) {\n+        try {\n+            return Math.ceilDiv(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilDiv and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doCeilDiv(long x, int y) {\n+        try {\n+            return Math.ceilDiv(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilDiv and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doCeilDiv(long x, long y) {\n+        try {\n+            return Math.ceilDiv(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilMod and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doCeilMod(int x, int y) {\n+        try {\n+            return Math.ceilMod(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilMod and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doCeilMod(long x, int y) {\n+        try {\n+            return Math.ceilMod(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilMod and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doCeilMod(long x, long y) {\n+        try {\n+            return Math.ceilMod(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilDiv and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doStrictCeilDiv(int x, int y) {\n+        try {\n+            return StrictMath.ceilDiv(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilDiv and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doStrictCeilDiv(long x, int y) {\n+        try {\n+            return StrictMath.ceilDiv(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilDiv and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doStrictCeilDiv(long x, long y) {\n+        try {\n+            return StrictMath.ceilDiv(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilMod and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doStrictCeilMod(int x, int y) {\n+        try {\n+            return StrictMath.ceilMod(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilMod and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doStrictCeilMod(long x, int y) {\n+        try {\n+            return StrictMath.ceilMod(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n+    \/**\n+     * Invoke ceilMod and return the result or any exception.\n+     * @param x the x value\n+     * @param y the y value\n+     * @return the result Integer or an exception.\n+     *\/\n+    static Object doStrictCeilMod(long x, long y) {\n+        try {\n+            return StrictMath.ceilMod(x, y);\n+        } catch (ArithmeticException ae) {\n+            return ae;\n+        }\n+    }\n+\n","filename":"test\/jdk\/java\/lang\/Math\/DivModTests.java","additions":501,"deletions":21,"binary":false,"changes":522,"status":"modified"}]}