{"files":[{"patch":"@@ -72,0 +72,3 @@\n+    \/\/ Number of elements in the buffer reserved for VM to use\n+    private static final int RESERVED_ELEMENTS = 2;\n+    private static final int MIN_BATCH_SIZE    = RESERVED_ELEMENTS + 2;\n@@ -75,1 +78,0 @@\n-    private static final int MIN_BATCH_SIZE    = SMALL_BATCH;\n@@ -199,1 +201,1 @@\n-         * Returns the next batch size, always >= minimum batch size (32)\n+         * Returns the next batch size, always >= minimum batch size\n@@ -542,1 +544,1 @@\n-                int initialBatchSize = Math.max(walker.estimateDepth(), SMALL_BATCH);\n+                int initialBatchSize = Math.max(walker.estimateDepth()+RESERVED_ELEMENTS, SMALL_BATCH);\n@@ -750,0 +752,8 @@\n+        \/*\n+         * Typically finding the caller class only needs to walk two stack frames\n+         * 0: StackWalker::getCallerClass\n+         * 1: API\n+         * 2: caller class\n+         *\n+         * So start the initial batch size with the minimum size.\n+         *\/\n@@ -752,1 +762,1 @@\n-            this.frameBuffer = new ClassFrameBuffer(walker, getNextBatchSize());\n+            this.frameBuffer = new ClassFrameBuffer(walker, MIN_BATCH_SIZE);\n@@ -757,1 +767,5 @@\n-            return MIN_BATCH_SIZE;\n+            \/\/ this method is only called when the caller class is not found in\n+            \/\/ the first batch. getCallerClass may be invoked via core reflection.\n+            \/\/ So increase the next batch size as there may be implementation-specific\n+            \/\/ frames before reaching the caller class's frame.\n+            return SMALL_BATCH;\n@@ -762,1 +776,1 @@\n-            return MIN_BATCH_SIZE;\n+            return SMALL_BATCH;\n@@ -788,1 +802,1 @@\n-        static final int START_POS = 2;     \/\/ 0th and 1st elements are reserved\n+        static final int START_POS = RESERVED_ELEMENTS;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StackStreamFactory.java","additions":21,"deletions":7,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3, jvmArgsAppend = {\"-Xmx1g\", \"-Xms1g\"})\n+@State(Scope.Benchmark)\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MICROSECONDS)\n+public class CallerClassBench {\n+    static final StackWalker INST = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE);\n+\n+    @Benchmark\n+    public Class<?> getCallerClass() {\n+        return INST.getCallerClass();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/CallerClassBench.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -313,10 +313,0 @@\n-    \/**\n-     * StackWalker.getCallerClass()\n-     *\/\n-    @Benchmark\n-    public void getCallerClass(Blackhole bh) {\n-        final StackWalker sw = walker(walker);\n-        Class<?> c = sw.getCallerClass();\n-        bh.consume(c);\n-    }\n-\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StackWalkBench.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}