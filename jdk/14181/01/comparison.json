{"files":[{"patch":"@@ -31,2 +31,1 @@\n-import jdk.internal.util.OperatingSystem;\n-import jdk.internal.util.Version;\n+import jdk.internal.util.OSVersion;\n@@ -37,2 +36,2 @@\n-    private static final boolean hasDynamicLoaderCache = OperatingSystem.version()\n-            .compareTo(new Version(10, 16)) >= 0;\n+    private static final boolean hasDynamicLoaderCache = OSVersion.current()\n+            .compareTo(new OSVersion(10, 16)) >= 0;\n","filename":"src\/java.base\/macosx\/classes\/jdk\/internal\/loader\/ClassLoaderHelper.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.util;\n+\n+\/**\n+ * A software Version with major, minor, and micro components.\n+ * @param major major version\n+ * @param minor minor version\n+ * @param micro micro version\n+ *\/\n+public record OSVersion(int major, int minor, int micro) implements Comparable<OSVersion> {\n+\n+    \/\/ Parse and save the current OS version\n+    private static final OSVersion CURRENT_OSVERSION = initVersion();\n+\n+    \/**\n+     * {@return a Version for major, minor versions}\n+     *\n+     * @param major major version\n+     * @param minor minor version\n+     *\/\n+    public OSVersion(int major, int minor) {\n+        this(major, minor, 0);\n+    }\n+\n+    \/*\n+     * Initialize the current Version from the os.version system property\n+     *\/\n+    private static OSVersion initVersion() {\n+        final String osVer = StaticProperty.osVersion();\n+        try {\n+            return parse(osVer);\n+        } catch (IllegalArgumentException iae) {\n+            throw new InternalError(\"os.version malformed: \" + osVer, iae);\n+        }\n+    }\n+\n+    \/**\n+     * {@return the current operating system version}\n+     *\/\n+    public static OSVersion current() {\n+        return CURRENT_OSVERSION;\n+    }\n+\n+    \/**\n+     * {@return Compare this version with another version}\n+     *\n+     * @param other the object to be compared\n+     *\/\n+    @Override\n+    public int compareTo(OSVersion other) {\n+        int result = Integer.compare(major, other.major);\n+        if (result == 0) {\n+            result = Integer.compare(minor, other.minor);\n+            if (result == 0) {\n+                return Integer.compare(micro, other.micro);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return (micro == 0)\n+                ? major + \".\" + minor\n+                : major + \".\" + minor + \".\" + micro;\n+    }\n+\n+    \/**\n+     * {@return A Version parsed from a version string split on \".\" characters}\n+     * Only major, minor, and micro version numbers are parsed, finer detail is ignored.\n+     * Missing values for minor and micro are replaced with zero.\n+     * The string must start with a number, if there is a '.' it must be followed by a number.\n+     * <p>\n+     * Parsed by hand because it is called before RegEx can be initialized safely.\n+     *\n+     * @param str a version string\n+     * @throws IllegalArgumentException if the string does not start with digits\n+     *          or digits do not follow '.'\n+     *\/\n+    public static OSVersion parse(String str) throws IllegalArgumentException {\n+        int len = str.length();\n+        int majorStart = 0;\n+        int majorEnd = skipDigits(str, majorStart);\n+        int major = Integer.parseInt(str.substring(majorStart, majorEnd));\n+\n+        int minor = 0, micro = 0;\n+        if (majorEnd < len && str.charAt(majorEnd) == '.') {\n+            int minorStart = majorEnd + 1;\n+            int minorEnd = skipDigits(str, minorStart);\n+            minor = Integer.parseInt(str.substring(minorStart, minorEnd));\n+\n+            if (minorEnd < len && str.charAt(minorEnd) == '.') {\n+                int microStart = minorEnd + 1;\n+                int microEnd = skipDigits(str, microStart);\n+                micro = Integer.parseInt(str.substring(microStart, microEnd));\n+            }\n+        }\n+        return new OSVersion(major, minor, micro);\n+    }\n+\n+    \/**\n+     * {@return The index of the first non-digit from start}\n+     * @throws IllegalArgumentException if there are no digits\n+     *\/\n+    private static int skipDigits(String s, int start) {\n+        int index = start;\n+        while (index < s.length() && Character.isDigit(s.charAt(index))) {\n+            index++;\n+        }\n+        if (index == start)\n+            throw new IllegalArgumentException(\"malformed version, missing digits: \" + s);\n+        return index;\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OSVersion.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.Locale;\n@@ -83,1 +84,2 @@\n-    private static final OperatingSystem CURRENT_OS = initOS(PlatformProps.CURRENT_OS_STRING);\n+    \/\/ The current OperatingSystem\n+    private static final OperatingSystem CURRENT_OS = initOS();\n@@ -129,30 +131,2 @@\n-    private static OperatingSystem initOS(String osName) {\n-        \/\/ Too early to use Locale conversions, manually do uppercase\n-        StringBuilder sb = new StringBuilder(osName);\n-        for (int i = 0; i < sb.length(); i++) {\n-            char ch = sb.charAt(i);\n-            if (ch >= 'a' && ch <= 'z') {\n-                sb.setCharAt(i, (char)(ch - ('a' - 'A')));  \/\/ Map lower case down to uppercase\n-            }\n-        }\n-        osName = sb.toString();\n-        return OperatingSystem.valueOf(osName);\n-    }\n-\n-    \/**\n-     * {@return the operating system version with major, minor, micro}\n-     *\/\n-    public static Version version() {\n-        return CURRENT_VERSION;\n-    }\n-\n-    \/\/ Parse and save the current version\n-    private static final Version CURRENT_VERSION = initVersion();\n-\n-    private static Version initVersion() {\n-        final String osVer = StaticProperty.osVersion();\n-        try {\n-            return Version.parse(osVer);\n-        } catch (IllegalArgumentException iae) {\n-            throw new InternalError(\"os.version malformed: \" + osVer, iae);\n-        }\n+    private static OperatingSystem initOS() {\n+        return OperatingSystem.valueOf(PlatformProps.CURRENT_OS_STRING.toUpperCase(Locale.ROOT));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/OperatingSystem.java","additions":5,"deletions":31,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.util;\n-\n-\/**\n- * A software Version with major, minor, and micro components.\n- * @param major major version\n- * @param minor minor version\n- * @param micro micro version\n- *\/\n-public record Version(int major, int minor, int micro) implements Comparable<Version> {\n-\n-    \/**\n-     * {@return a Version for major, minor versions}\n-     *\n-     * @param major major version\n-     * @param minor minor version\n-     *\/\n-    public Version(int major, int minor) {\n-        this(major, minor, 0);\n-    }\n-\n-    \/**\n-     * {@return Compare this version with another version}\n-     *\n-     * @param other the object to be compared\n-     *\/\n-    @Override\n-    public int compareTo(Version other) {\n-        int result = Integer.compare(major, other.major);\n-        if (result == 0) {\n-            result = Integer.compare(minor, other.minor);\n-            if (result == 0) {\n-                return Integer.compare(micro, other.micro);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return (micro == 0)\n-                ? major + \".\" + minor\n-                : major + \".\" + minor + \".\" + micro;\n-    }\n-\n-    \/**\n-     * {@return A Version parsed from a version string split on \".\" characters}\n-     * Only major, minor, and micro version numbers are parsed, finer detail is ignored.\n-     * Missing values for minor and micro are replaced with zero.\n-     * The string must start with a number, if there is a '.' it must be followed by a number.\n-     * <p>\n-     * Parsed by hand because it is called before RegEx can be initialized safely.\n-     *\n-     * @param str a version string\n-     * @throws IllegalArgumentException if the string does not start with digits\n-     *          or digits do not follow '.'\n-     *\/\n-    public static Version parse(String str) throws IllegalArgumentException {\n-        int len = str.length();\n-        int majorStart = 0;\n-        int majorEnd = skipDigits(str, majorStart);\n-        int major = Integer.parseInt(str.substring(majorStart, majorEnd));\n-\n-        int minor = 0, micro = 0;\n-        if (majorEnd < len && str.charAt(majorEnd) == '.') {\n-            int minorStart = majorEnd + 1;\n-            int minorEnd = skipDigits(str, minorStart);\n-            minor = Integer.parseInt(str.substring(minorStart, minorEnd));\n-\n-            if (minorEnd < len && str.charAt(minorEnd) == '.') {\n-                int microStart = minorEnd + 1;\n-                int microEnd = skipDigits(str, microStart);\n-                micro = Integer.parseInt(str.substring(microStart, microEnd));\n-            }\n-        }\n-        return new Version(major, minor, micro);\n-    }\n-\n-    \/**\n-     * {@return The index of the first non-digit from start}\n-     * @throws IllegalArgumentException if there are no digits\n-     *\/\n-\n-    private static int skipDigits(String s, int start) {\n-        int index = start;\n-        while (index < s.length() && Character.isDigit(s.charAt(index))) {\n-            index++;\n-        }\n-        if (index == start)\n-            throw new IllegalArgumentException(\"malformed version, missing digits: \" + s);\n-        return index;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/Version.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.internal.util.Version;\n+import jdk.internal.util.OSVersion;\n@@ -92,1 +92,1 @@\n-        Version ver = OperatingSystem.version();\n+        OSVersion ver = OSVersion.current();\n","filename":"test\/jdk\/jdk\/internal\/util\/OSTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.internal.util.Version;\n+import jdk.internal.util.OSVersion;\n@@ -32,1 +32,1 @@\n-import org.junit.jupiter.api.Test;\n+\n@@ -48,8 +48,8 @@\n-                Arguments.of(\"1\", new Version(1, 0)),\n-                Arguments.of(\"1.2\", new Version(1, 2)),\n-                Arguments.of(\"1.2\", new Version(1, 2, 0)),\n-                Arguments.of(\"1.2.3\", new Version(1, 2, 3)),\n-                Arguments.of(\"1-abc\", new Version(1, 0, 0)), \/\/ Ignore extra\n-                Arguments.of(\"1.2-abc\", new Version(1, 2, 0)), \/\/ Ignore extra\n-                Arguments.of(\"1.2.3.4\", new Version(1, 2, 3)), \/\/ Ignore extra\n-                Arguments.of(\"1.2.3-abc\", new Version(1, 2, 3)) \/\/ Ignore extra\n+                Arguments.of(\"1\", new OSVersion(1, 0)),\n+                Arguments.of(\"1.2\", new OSVersion(1, 2)),\n+                Arguments.of(\"1.2\", new OSVersion(1, 2, 0)),\n+                Arguments.of(\"1.2.3\", new OSVersion(1, 2, 3)),\n+                Arguments.of(\"1-abc\", new OSVersion(1, 0, 0)), \/\/ Ignore extra\n+                Arguments.of(\"1.2-abc\", new OSVersion(1, 2, 0)), \/\/ Ignore extra\n+                Arguments.of(\"1.2.3.4\", new OSVersion(1, 2, 3)), \/\/ Ignore extra\n+                Arguments.of(\"1.2.3-abc\", new OSVersion(1, 2, 3)) \/\/ Ignore extra\n@@ -61,2 +61,2 @@\n-    public void checkParse(String verName, Version expected) {\n-        Version actual = Version.parse(verName);\n+    public void checkParse(String verName, OSVersion expected) {\n+        OSVersion actual = OSVersion.parse(verName);\n@@ -77,1 +77,1 @@\n-        Throwable th = assertThrows(IllegalArgumentException.class, () -> Version.parse(verName));\n+        Throwable th = assertThrows(IllegalArgumentException.class, () -> OSVersion.parse(verName));\n@@ -84,8 +84,8 @@\n-                Arguments.of(new Version(2, 1), new Version(2, 1), 0),\n-                Arguments.of(new Version(2, 1), new Version(2, 0), +1),\n-                Arguments.of(new Version(2, 0), new Version(2, 1), -1),\n-                Arguments.of(new Version(3, 3, 1), new Version(3, 3, 1), 0),\n-                Arguments.of(new Version(3, 3, 1), new Version(3, 3, 0), +1),\n-                Arguments.of(new Version(3, 3, 0), new Version(3, 3, 1), -1),\n-                Arguments.of(new Version(2, 0), new Version(3, 0), -1),\n-                Arguments.of(new Version(3, 0), new Version(2, 0), +1)\n+                Arguments.of(new OSVersion(2, 1), new OSVersion(2, 1), 0),\n+                Arguments.of(new OSVersion(2, 1), new OSVersion(2, 0), +1),\n+                Arguments.of(new OSVersion(2, 0), new OSVersion(2, 1), -1),\n+                Arguments.of(new OSVersion(3, 3, 1), new OSVersion(3, 3, 1), 0),\n+                Arguments.of(new OSVersion(3, 3, 1), new OSVersion(3, 3, 0), +1),\n+                Arguments.of(new OSVersion(3, 3, 0), new OSVersion(3, 3, 1), -1),\n+                Arguments.of(new OSVersion(2, 0), new OSVersion(3, 0), -1),\n+                Arguments.of(new OSVersion(3, 0), new OSVersion(2, 0), +1)\n@@ -97,1 +97,1 @@\n-    public void checkVersionCompare(Version v1, Version v2, int expected) {\n+    public void checkVersionCompare(OSVersion v1, OSVersion v2, int expected) {\n","filename":"test\/jdk\/jdk\/internal\/util\/VersionTest.java","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"}]}