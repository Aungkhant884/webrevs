{"files":[{"patch":"@@ -1215,1 +1215,3 @@\n-    static class Sinh {\n+    static final class Sinh {\n+        private Sinh() {throw new AssertionError(\"no instances\");};\n+\n@@ -1289,1 +1291,3 @@\n-    static class Cosh {\n+    static final class Cosh {\n+        private Cosh() {throw new AssertionError(\"no instances\");};\n+\n@@ -1363,1 +1367,3 @@\n-    static class Tanh {\n+    static final class Tanh {\n+        private Tanh() {throw new AssertionError(\"no instances\");};\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -842,1 +842,1 @@\n-    static class Sinh {\n+    private static final class Sinh {\n@@ -845,1 +845,1 @@\n-        private static double compute(double x) {\n+        static double compute(double x) {\n@@ -872,0 +872,1 @@\n+            \/\/ Note: the original FDLIBM sources use\n@@ -873,1 +874,7 @@\n-            \/\/ lx =  (((*(unsigned*)&one)>>29)) + (unsigned*)&x ;\n+            \/\/ to set lx to the low-order 32 bits of x. The expression\n+            \/\/ in question is an alternate way to implement the\n+            \/\/ functionality of the C FDLIBM __LO macro and the\n+            \/\/ expression is coded to work on both big-edian and\n+            \/\/ little-endian machines. However, this port will instead\n+            \/\/ use the __LO method call to represent this\n+            \/\/ functionality.\n@@ -906,1 +913,1 @@\n-    static class Cosh {\n+    private static final class Cosh {\n@@ -908,1 +915,1 @@\n-        private static double compute(double x) {\n+        static double compute(double x) {\n@@ -974,1 +981,1 @@\n-    static class Tanh {\n+    private static final class Tanh {\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"}]}