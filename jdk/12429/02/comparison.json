{"files":[{"patch":"@@ -1197,0 +1197,202 @@\n+\n+    \/**\n+     * Method :\n+     * mathematically sinh(x) if defined to be (exp(x)-exp(-x))\/2\n+     *      1. Replace x by |x| (sinh(-x) = -sinh(x)).\n+     *      2.\n+     *                                                  E + E\/(E+1)\n+     *          0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)\n+     *                                                      2\n+     *\n+     *          22       <= x <= lnovft :  sinh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  sinh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  sinh(x) := x*shuge (overflow)\n+     *\n+     * Special cases:\n+     *      sinh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only sinh(0)=0 is exact for finite x.\n+     *\/\n+    static class Sinh {\n+        private static final double one = 1.0, shuge = 1.0e307;\n+\n+         static double compute(double x) {\n+            double t, w, h;\n+            int ix, jx;\n+            \/* unsigned *\/ int lx;\n+\n+            \/\/ High word of |x|\n+            jx = __HI(x);\n+            ix = jx & 0x7fff_ffff;\n+\n+            \/\/ x is INF or NaN\n+            if (ix >= 0x7ff0_0000) {\n+                return x + x;\n+            }\n+\n+            h = 0.5;\n+            if (jx < 0) {\n+                h = -h;\n+            }\n+            \/\/ |x| in [0,22], return sign(x)*0.5*(E+E\/(E+1)))\n+            if (ix < 0x4036_0000) {          \/\/ |x| < 22\n+                if (ix < 0x3e30_0000)        \/\/ |x| < 2**-28\n+                    if (shuge + x > one) {   \/\/ sinh(tiny) = tiny with inexact\n+                        return x;\n+                    }\n+                t = StrictMath.expm1(Math.abs(x));\n+                if (ix < 0x3ff0_0000) {\n+                    return h*(2.0 * t - t*t\/(t + one));\n+                }\n+                return h*(t + t\/(t + one));\n+            }\n+\n+            \/\/ |x| in [22, log(maxdouble)] return 0.5*exp(|x|)\n+            if (ix < 0x4086_2E42) {\n+                return h*StrictMath.exp(Math.abs(x));\n+            }\n+\n+            \/\/ |x| in [log(maxdouble), overflowthresold]\n+            lx = __LO(x);\n+            if (ix < 0x4086_33CE ||\n+                ((ix == 0x4086_33ce) &&\n+                 (Long.compareUnsigned(lx, 0x8fb9_f87d) <= 0 ))) {\n+                w = StrictMath.exp(0.5 * Math.abs(x));\n+                t = h * w;\n+                return t * w;\n+            }\n+\n+            \/\/ |x| > overflowthresold, sinh(x) overflow\n+            return x * shuge;\n+        }\n+    }\n+\n+    \/**\n+     * Method :\n+     * mathematically cosh(x) if defined to be (exp(x)+exp(-x))\/2\n+     *      1. Replace x by |x| (cosh(x) = cosh(-x)).\n+     *      2.\n+     *                                                      [ exp(x) - 1 ]^2\n+     *          0        <= x <= ln2\/2  :  cosh(x) := 1 + -------------------\n+     *                                                         2*exp(x)\n+     *\n+     *                                                exp(x) +  1\/exp(x)\n+     *          ln2\/2    <= x <= 22     :  cosh(x) := -------------------\n+     *                                                        2\n+     *          22       <= x <= lnovft :  cosh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  cosh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  cosh(x) := huge*huge (overflow)\n+     *\n+     * Special cases:\n+     *      cosh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only cosh(0)=1 is exact for finite x.\n+     *\/\n+    static class Cosh {\n+        private static final double one = 1.0, half=0.5, huge = 1.0e300;\n+        static double compute(double x) {\n+            double t, w;\n+            int ix;\n+            \/*unsigned*\/ int lx;\n+\n+            \/\/ High word of |x|\n+            ix = __HI(x);\n+            ix &= 0x7fff_ffff;\n+\n+            \/\/ x is INF or NaN\n+            if (ix >= 0x7ff0_0000) {\n+                return x*x;\n+            }\n+\n+            \/\/ |x| in [0,0.5*ln2], return 1+expm1(|x|)^2\/(2*exp(|x|))\n+            if (ix < 0x3fd6_2e43) {\n+                t = StrictMath.expm1(Math.abs(x));\n+                w = one + t;\n+                if (ix < 0x3c80_0000) { \/\/ cosh(tiny) = 1\n+                    return w;\n+                }\n+                return one + (t * t)\/(w + w);\n+            }\n+\n+            \/\/ |x| in [0.5*ln2, 22], return (exp(|x|) + 1\/exp(|x|)\/2\n+            if (ix < 0x4036_0000) {\n+                t = StrictMath.exp(Math.abs(x));\n+                return half*t + half\/t;\n+            }\n+\n+            \/\/ |x| in [22, log(maxdouble)] return half*exp(|x|)\n+            if (ix < 0x4086_2E42) {\n+                return half*StrictMath.exp(Math.abs(x));\n+            }\n+\n+            \/\/ |x| in [log(maxdouble), overflowthresold]\n+            lx = __LO(x);\n+            if (ix<0x4086_33CE ||\n+                ((ix == 0x4086_33ce) &&\n+                 (Integer.compareUnsigned(lx, 0x8fb9_f87d) <= 0))) {\n+                w = StrictMath.exp(half*Math.abs(x));\n+                t = half*w;\n+                return t*w;\n+            }\n+\n+            \/\/ |x| > overflowthresold, cosh(x) overflow\n+            return huge*huge;\n+        }\n+    }\n+    \/**\n+     * Return the Hyperbolic Tangent of x\n+     *\n+     * Method :\n+     *                                     x    -x\n+     *                                    e  - e\n+     *      0. tanh(x) is defined to be -----------\n+     *                                     x    -x\n+     *                                    e  + e\n+     *      1. reduce x to non-negative by tanh(-x) = -tanh(x).\n+     *      2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)\n+     *                                              -t\n+     *          2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)\n+     *                                             t + 2\n+     *                                                   2\n+     *          1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)\n+     *                                                 t + 2\n+     *          22.0   <  x <= INF    : tanh(x) := 1.\n+     *\n+     * Special cases:\n+     *      tanh(NaN) is NaN;\n+     *      only tanh(0)=0 is exact for finite argument.\n+     *\/\n+    static class Tanh {\n+        private static final double one=1.0, two=2.0, tiny = 1.0e-300;\n+        static double compute(double x) {\n+            double t, z;\n+            int jx, ix;\n+\n+            \/\/ High word of |x|.\n+            jx = __HI(x);\n+            ix = jx & 0x7fff_ffff;\n+\n+            \/\/ x is INF or NaN\n+            if (ix >= 0x7ff0_0000) {\n+                if (jx >= 0) {  \/\/ tanh(+-inf)=+-1\n+                    return one\/x + one;\n+                } else {        \/\/ tanh(NaN) = NaN\n+                    return one\/x - one;\n+                }\n+            }\n+\n+            \/\/ |x| < 22\n+            if (ix < 0x4036_0000) {          \/\/ |x| < 22\n+                if (ix<0x3c80_0000)          \/\/ |x| < 2**-55\n+                    return x*(one + x);      \/\/ tanh(small) = small\n+                if (ix>=0x3ff0_0000) {       \/\/ |x| >= 1\n+                    t = StrictMath.expm1(two*Math.abs(x));\n+                    z = one - two\/(t + two);\n+                } else {\n+                    t = StrictMath.expm1(-two*Math.abs(x));\n+                    z= -t\/(t + two);\n+                }\n+            } else { \/\/ |x| > 22, return +-1\n+                z = one - tiny;             \/\/ raised inexact flag\n+            }\n+            return (jx >= 0)? z: -z;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -1987,1 +1987,3 @@\n-    public static native double sinh(double x);\n+    public static double sinh(double x) {\n+        return FdLibm.Sinh.compute(x);\n+    }\n@@ -2011,1 +2013,3 @@\n-    public static native double cosh(double x);\n+    public static double cosh(double x) {\n+        return FdLibm.Cosh.compute(x);\n+    }\n@@ -2042,1 +2046,3 @@\n-    public static native double tanh(double x);\n+    public static double tanh(double x) {\n+        return FdLibm.Tanh.compute(x);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -93,0 +93,13 @@\n+    public static double sinh(double x) {\n+        return Sinh.compute(x);\n+    }\n+\n+    public static double cosh(double x) {\n+        return Cosh.compute(x);\n+    }\n+\n+    public static double tanh(double x) {\n+        return Tanh.compute(x);\n+    }\n+\n+\n@@ -811,0 +824,184 @@\n+\n+    \/**\n+     * Method :\n+     * mathematically sinh(x) if defined to be (exp(x)-exp(-x))\/2\n+     *      1. Replace x by |x| (sinh(-x) = -sinh(x)).\n+     *      2.\n+     *                                                  E + E\/(E+1)\n+     *          0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)\n+     *                                                      2\n+     *\n+     *          22       <= x <= lnovft :  sinh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  sinh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  sinh(x) := x*shuge (overflow)\n+     *\n+     * Special cases:\n+     *      sinh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only sinh(0)=0 is exact for finite x.\n+     *\/\n+    static class Sinh {\n+        private static final double one = 1.0, shuge = 1.0e307;\n+\n+        private static double compute(double x) {\n+            double t,w,h;\n+            int ix,jx;\n+            \/* unsigned *\/ int lx;\n+\n+            \/* High word of |x|. *\/\n+            jx = __HI(x);\n+            ix = jx&0x7fffffff;\n+\n+            \/* x is INF or NaN *\/\n+            if(ix>=0x7ff00000) return x+x;\n+\n+            h = 0.5;\n+            if (jx<0) h = -h;\n+            \/* |x| in [0,22], return sign(x)*0.5*(E+E\/(E+1))) *\/\n+            if (ix < 0x40360000) {          \/* |x|<22 *\/\n+                if (ix<0x3e300000)          \/* |x|<2**-28 *\/\n+                    if(shuge+x>one) return x;\/* sinh(tiny) = tiny with inexact *\/\n+                t = FdlibmTranslit.expm1(Math.abs(x));\n+                if(ix<0x3ff00000) return h*(2.0*t-t*t\/(t+one));\n+                return h*(t+t\/(t+one));\n+            }\n+\n+            \/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) *\/\n+            if (ix < 0x40862E42)  return h*StrictMath.exp(Math.abs(x)); \/\/ TODO switch to translit\n+\n+            \/* |x| in [log(maxdouble), overflowthresold] *\/\n+            \/\/ lx = *( (((*(unsigned*)&one)>>29)) + (unsigned*)&x);\n+            \/\/ lx =  (((*(unsigned*)&one)>>29)) + (unsigned*)&x ;\n+            lx = __LO(x);\n+            if (ix<0x408633CE || ((ix==0x408633ce)&&(Long.compareUnsigned(lx, 0x8fb9f87d) <= 0 ))) {\n+                w = StrictMath.exp(0.5*Math.abs(x)); \/\/ TODO switch to translit\n+                t = h*w;\n+                return t*w;\n+            }\n+\n+            \/* |x| > overflowthresold, sinh(x) overflow *\/\n+            return x*shuge;\n+        }\n+    }\n+\n+    \/**\n+     * Method :\n+     * mathematically cosh(x) if defined to be (exp(x)+exp(-x))\/2\n+     *      1. Replace x by |x| (cosh(x) = cosh(-x)).\n+     *      2.\n+     *                                                      [ exp(x) - 1 ]^2\n+     *          0        <= x <= ln2\/2  :  cosh(x) := 1 + -------------------\n+     *                                                         2*exp(x)\n+     *\n+     *                                                exp(x) +  1\/exp(x)\n+     *          ln2\/2    <= x <= 22     :  cosh(x) := -------------------\n+     *                                                        2\n+     *          22       <= x <= lnovft :  cosh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  cosh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  cosh(x) := huge*huge (overflow)\n+     *\n+     * Special cases:\n+     *      cosh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only cosh(0)=1 is exact for finite x.\n+     *\/\n+    static class Cosh {\n+        private static final double one = 1.0, half=0.5, huge = 1.0e300;\n+        private static double compute(double x) {\n+            double t,w;\n+            int ix;\n+            \/*unsigned*\/ int lx;\n+\n+            \/* High word of |x|. *\/\n+            ix = __HI(x);\n+            ix &= 0x7fffffff;\n+\n+            \/* x is INF or NaN *\/\n+            if(ix>=0x7ff00000) return x*x;\n+\n+            \/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2\/(2*exp(|x|)) *\/\n+            if(ix<0x3fd62e43) {\n+                t = expm1(Math.abs(x));\n+                w = one+t;\n+                if (ix<0x3c800000) return w;        \/* cosh(tiny) = 1 *\/\n+                return one+(t*t)\/(w+w);\n+            }\n+\n+            \/* |x| in [0.5*ln2,22], return (exp(|x|)+1\/exp(|x|)\/2; *\/\n+            if (ix < 0x40360000) {\n+                t = StrictMath.exp(Math.abs(x)); \/\/ TODO switch to translit\n+                return half*t+half\/t;\n+            }\n+\n+            \/* |x| in [22, log(maxdouble)] return half*exp(|x|) *\/\n+            if (ix < 0x40862E42)  return half*StrictMath.exp(Math.abs(x)); \/\/ TODO switch to translit\n+\n+            \/* |x| in [log(maxdouble), overflowthresold] *\/\n+            lx = __LO(x);\n+            if (ix<0x408633CE ||\n+                ((ix==0x408633ce)&&(Integer.compareUnsigned(lx, 0x8fb9f87d) <= 0))) {\n+                w = StrictMath.exp(half*Math.abs(x)); \/\/ TODO switch to translit\n+                t = half*w;\n+                return t*w;\n+            }\n+\n+            \/* |x| > overflowthresold, cosh(x) overflow *\/\n+            return huge*huge;\n+        }\n+    }\n+\n+    \/**\n+     * Return the Hyperbolic Tangent of x\n+     *\n+     * Method :\n+     *                                     x    -x\n+     *                                    e  - e\n+     *      0. tanh(x) is defined to be -----------\n+     *                                     x    -x\n+     *                                    e  + e\n+     *      1. reduce x to non-negative by tanh(-x) = -tanh(x).\n+     *      2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)\n+     *                                              -t\n+     *          2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)\n+     *                                             t + 2\n+     *                                                   2\n+     *          1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)\n+     *                                                 t + 2\n+     *          22.0   <  x <= INF    : tanh(x) := 1.\n+     *\n+     * Special cases:\n+     *      tanh(NaN) is NaN;\n+     *      only tanh(0)=0 is exact for finite argument.\n+     *\/\n+    static class Tanh {\n+        private static final double one=1.0, two=2.0, tiny = 1.0e-300;\n+        static double compute(double x) {\n+            double t,z;\n+            int jx,ix;\n+\n+            \/* High word of |x|. *\/\n+            jx = __HI(x);\n+            ix = jx&0x7fffffff;\n+\n+            \/* x is INF or NaN *\/\n+            if(ix>=0x7ff00000) {\n+                if (jx>=0) return one\/x+one;    \/* tanh(+-inf)=+-1 *\/\n+                else       return one\/x-one;    \/* tanh(NaN) = NaN *\/\n+            }\n+\n+            \/* |x| < 22 *\/\n+            if (ix < 0x40360000) {          \/* |x|<22 *\/\n+                if (ix<0x3c800000)          \/* |x|<2**-55 *\/\n+                    return x*(one+x);       \/* tanh(small) = small *\/\n+                if (ix>=0x3ff00000) {       \/* |x|>=1  *\/\n+                    t = expm1(two*Math.abs(x));\n+                    z = one - two\/(t+two);\n+                } else {\n+                    t = expm1(-two*Math.abs(x));\n+                    z= -t\/(t+two);\n+                }\n+                \/* |x| > 22, return +-1 *\/\n+            } else {\n+                z = one - tiny;             \/* raised inexact flag *\/\n+            }\n+            return (jx>=0)? z: -z;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -26,1 +27,8 @@\n- * @bug 4851625\n+ * @bug 4851625 8301444\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build HyperbolicTests\n+ * @run main HyperbolicTests\n@@ -45,0 +53,237 @@\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslitSinh();\n+        failures += testAgainstTranslitCosh();\n+        failures += testAgainstTranslitTanh();\n+\n+        failures += testSinh();\n+        failures += testCosh();\n+        failures += testTanh();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing the hyperbolics incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.sinh against transliteration port of sinh.\n+     *\/\n+    private static int testAgainstTranslitSinh() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRangeSinh(x, Math.ulp(x), 1000);\n+\n+         \/\/ ... and just below subnormal threshold ...\n+          x = Math.nextDown(Double.MIN_NORMAL);\n+          failures += testRangeSinh(x, -Math.ulp(x), 1000);\n+\n+         \/\/ ... and near 1.0 ...\n+          failures += testRangeMidpointSinh(1.0, Math.ulp(x), 2000);\n+          \/\/ (Note: probes every-other value less than 1.0 due to\n+          \/\/ change in the size of an ulp at 1.0.\n+\n+          \/\/ Probe near decision points in the FDLIBM algorithm.\n+          double[] decisionPoints = {\n+               0.0,\n+\n+               22.0,\n+              -22.0,\n+\n+               0x1.0p-28,\n+              -0x1.0p-28,\n+\n+               \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n+               0x1.62e42fefa39efp9,\n+              -0x1.62e42fefa39efp9,\n+\n+               \/\/ Largest argument with finite sinh, 710.4758600739439\n+               0x1.633ce8fb9f87dp9,\n+              -0x1.633ce8fb9f87dp9,\n+          };\n+\n+          for (double testPoint : decisionPoints) {\n+              failures += testRangeMidpointSinh(testPoint, Math.ulp(testPoint), 1000);\n+          }\n+\n+          x = Tests.createRandomDouble(random);\n+\n+          \/\/ Make the increment twice the ulp value in case the random\n+          \/\/ value is near an exponent threshold. Don't worry about test\n+          \/\/ elements overflowing to infinity if the starting value is\n+          \/\/ near Double.MAX_VALUE.\n+          failures += testRangeSinh(x, 2.0 * Math.ulp(x), 1000);\n+\n+         return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.cosh against transliteration port of cosh.\n+     *\/\n+    private static int testAgainstTranslitCosh() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRangeCosh(x, Math.ulp(x), 1000);\n+\n+         \/\/ ... and just below subnormal threshold ...\n+          x = Math.nextDown(Double.MIN_NORMAL);\n+          failures += testRangeCosh(x, -Math.ulp(x), 1000);\n+\n+         \/\/ ... and near 1.0 ...\n+          failures += testRangeMidpointCosh(1.0, Math.ulp(x), 2000);\n+          \/\/ (Note: probes every-other value less than 1.0 due to\n+          \/\/ change in the size of an ulp at 1.0.\n+\n+          \/\/ Probe near decision points in the FDLIBM algorithm.\n+          double[] decisionPoints = {\n+               0.0,\n+\n+               22.0,\n+              -22.0,\n+\n+               \/\/ StrictMath.log(2)\/2 ~= 0.34657359027997264\n+               0x1.62e42fefa39efp-2,\n+              -0x1.62e42fefa39efp-2,\n+\n+               0x1.0p-28,\n+              -0x1.0p-28,\n+\n+               \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n+               0x1.62e42fefa39efp9,\n+              -0x1.62e42fefa39efp9,\n+\n+               \/\/ Largest argument with finite cosh, 710.4758600739439\n+               0x1.633ce8fb9f87dp9,\n+              -0x1.633ce8fb9f87dp9,\n+          };\n+\n+          for (double testPoint : decisionPoints) {\n+              failures += testRangeMidpointCosh(testPoint, Math.ulp(testPoint), 1000);\n+          }\n+\n+          x = Tests.createRandomDouble(random);\n+\n+          \/\/ Make the increment twice the ulp value in case the random\n+          \/\/ value is near an exponent threshold. Don't worry about test\n+          \/\/ elements overflowing to infinity if the starting value is\n+          \/\/ near Double.MAX_VALUE.\n+          failures += testRangeCosh(x, 2.0 * Math.ulp(x), 1000);\n+\n+         return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.tanh against transliteration port of tanh\n+     *\/\n+    private static int testAgainstTranslitTanh() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRangeTanh(x, Math.ulp(x), 1000);\n+\n+         \/\/ ... and just below subnormal threshold ...\n+          x = Math.nextDown(Double.MIN_NORMAL);\n+          failures += testRangeTanh(x, -Math.ulp(x), 1000);\n+\n+         \/\/ ... and near 1.0 ...\n+          failures += testRangeMidpointTanh(1.0, Math.ulp(x), 2000);\n+          \/\/ (Note: probes every-other value less than 1.0 due to\n+          \/\/ change in the size of an ulp at 1.0.\n+\n+          \/\/ Probe near decision points in the FDLIBM algorithm.\n+          double[] decisionPoints = {\n+               0.0,\n+\n+               0x1.0p-55,\n+              -0x1.0p-55,\n+\n+               1.0,\n+              -1.0,\n+\n+               22.0,\n+          };\n+\n+          for (double testPoint : decisionPoints) {\n+              failures += testRangeMidpointTanh(testPoint, Math.ulp(testPoint), 1000);\n+          }\n+\n+          x = Tests.createRandomDouble(random);\n+\n+          \/\/ Make the increment twice the ulp value in case the random\n+          \/\/ value is near an exponent threshold. Don't worry about test\n+          \/\/ elements overflowing to infinity if the starting value is\n+          \/\/ near Double.MAX_VALUE.\n+          failures += testRangeTanh(x, 2.0 * Math.ulp(x), 1000);\n+\n+         return failures;\n+    }\n+\n+    private static int testRangeSinh(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testSinhCase(x, FdlibmTranslit.sinh(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeCosh(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testCoshCase(x, FdlibmTranslit.cosh(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeTanh(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testTanhCase(x, FdlibmTranslit.tanh(x));\n+        }\n+        return failures;\n+    }\n+\n+\n+    private static int testRangeMidpointSinh(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testSinhCase(x, FdlibmTranslit.sinh(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpointCosh(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testCoshCase(x, FdlibmTranslit.cosh(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpointTanh(double midpoint, double increment, int count) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testTanhCase(x, FdlibmTranslit.tanh(x));\n+        }\n+        return failures;\n+    }\n+\n+\n@@ -264,15 +509,0 @@\n-\n-\n-    public static void main(String [] argv) {\n-        int failures = 0;\n-\n-        failures += testSinh();\n-        failures += testCosh();\n-        failures += testTanh();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing the hyperbolics incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/HyperbolicTests.java","additions":247,"deletions":17,"binary":false,"changes":264,"status":"modified"}]}