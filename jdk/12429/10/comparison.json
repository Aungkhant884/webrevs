{"files":[{"patch":"@@ -953,2 +953,3 @@\n-    static class Exp {\n-        private static final double one     = 1.0;\n+    static final class Exp {\n+        private Exp() {throw new UnsupportedOperationException();}\n+\n@@ -972,4 +973,0 @@\n-        private Exp() {\n-            throw new UnsupportedOperationException();\n-        }\n-\n@@ -1018,2 +1015,2 @@\n-                if (huge + x > one)\n-                    return one + x; \/* trigger inexact *\/\n+                if (huge + x > 1.0)\n+                    return 1.0 + x; \/* trigger inexact *\/\n@@ -1028,1 +1025,1 @@\n-                return one - ((x*c)\/(c - 2.0) - x);\n+                return 1.0 - ((x*c)\/(c - 2.0) - x);\n@@ -1030,1 +1027,1 @@\n-                y = one - ((lo - (x*c)\/(2.0 - c)) - hi);\n+                y = 1.0 - ((lo - (x*c)\/(2.0 - c)) - hi);\n@@ -1629,0 +1626,211 @@\n+\n+    \/**\n+     * Method :\n+     * mathematically sinh(x) if defined to be (exp(x)-exp(-x))\/2\n+     *      1. Replace x by |x| (sinh(-x) = -sinh(x)).\n+     *      2.\n+     *                                                  E + E\/(E+1)\n+     *          0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)\n+     *                                                      2\n+     *\n+     *          22       <= x <= lnovft :  sinh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  sinh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  sinh(x) := x*shuge (overflow)\n+     *\n+     * Special cases:\n+     *      sinh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only sinh(0)=0 is exact for finite x.\n+     *\/\n+    static final class Sinh {\n+        private Sinh() {throw new UnsupportedOperationException();}\n+\n+        private static final double shuge = 1.0e307;\n+\n+        static double compute(double x) {\n+            double t, w, h;\n+            int ix, jx;\n+            \/* unsigned *\/ int lx;\n+\n+            \/\/ High word of |x|\n+            jx = __HI(x);\n+            ix = jx & 0x7fff_ffff;\n+\n+            \/\/ x is INF or NaN\n+            if (ix >= 0x7ff0_0000) {\n+                return x + x;\n+            }\n+\n+            h = 0.5;\n+            if (jx < 0) {\n+                h = -h;\n+            }\n+            \/\/ |x| in [0,22], return sign(x)*0.5*(E+E\/(E+1)))\n+            if (ix < 0x4036_0000) {          \/\/ |x| < 22\n+                if (ix < 0x3e30_0000)        \/\/ |x| < 2**-28\n+                    if (shuge + x > 1.0) {   \/\/ sinh(tiny) = tiny with inexact\n+                        return x;\n+                    }\n+                t = StrictMath.expm1(Math.abs(x));\n+                if (ix < 0x3ff0_0000) {\n+                    return h*(2.0 * t - t*t\/(t + 1.0));\n+                }\n+                return h*(t + t\/(t + 1.0));\n+            }\n+\n+            \/\/ |x| in [22, log(maxdouble)] return 0.5*exp(|x|)\n+            if (ix < 0x4086_2E42) {\n+                return h*StrictMath.exp(Math.abs(x));\n+            }\n+\n+            \/\/ |x| in [log(maxdouble), overflowthresold]\n+            lx = __LO(x);\n+            if (ix < 0x4086_33CE ||\n+                ((ix == 0x4086_33ce) &&\n+                 (Long.compareUnsigned(lx, 0x8fb9_f87d) <= 0 ))) {\n+                w = StrictMath.exp(0.5 * Math.abs(x));\n+                t = h * w;\n+                return t * w;\n+            }\n+\n+            \/\/ |x| > overflowthresold, sinh(x) overflow\n+            return x * shuge;\n+        }\n+    }\n+\n+    \/**\n+     * Method :\n+     * mathematically cosh(x) if defined to be (exp(x)+exp(-x))\/2\n+     *      1. Replace x by |x| (cosh(x) = cosh(-x)).\n+     *      2.\n+     *                                                      [ exp(x) - 1 ]^2\n+     *          0        <= x <= ln2\/2  :  cosh(x) := 1 + -------------------\n+     *                                                         2*exp(x)\n+     *\n+     *                                                exp(x) +  1\/exp(x)\n+     *          ln2\/2    <= x <= 22     :  cosh(x) := -------------------\n+     *                                                        2\n+     *          22       <= x <= lnovft :  cosh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  cosh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  cosh(x) := huge*huge (overflow)\n+     *\n+     * Special cases:\n+     *      cosh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only cosh(0)=1 is exact for finite x.\n+     *\/\n+    static final class Cosh {\n+        private Cosh() {throw new UnsupportedOperationException();}\n+\n+        private static final double huge = 1.0e300;\n+\n+        static double compute(double x) {\n+            double t, w;\n+            int ix;\n+            \/*unsigned*\/ int lx;\n+\n+            \/\/ High word of |x|\n+            ix = __HI(x);\n+            ix &= 0x7fff_ffff;\n+\n+            \/\/ x is INF or NaN\n+            if (ix >= 0x7ff0_0000) {\n+                return x*x;\n+            }\n+\n+            \/\/ |x| in [0,0.5*ln2], return 1+expm1(|x|)^2\/(2*exp(|x|))\n+            if (ix < 0x3fd6_2e43) {\n+                t = StrictMath.expm1(Math.abs(x));\n+                w = 1.0 + t;\n+                if (ix < 0x3c80_0000) { \/\/ cosh(tiny) = 1\n+                    return w;\n+                }\n+                return 1.0 + (t * t)\/(w + w);\n+            }\n+\n+            \/\/ |x| in [0.5*ln2, 22], return (exp(|x|) + 1\/exp(|x|)\/2\n+            if (ix < 0x4036_0000) {\n+                t = StrictMath.exp(Math.abs(x));\n+                return 0.5*t + 0.5\/t;\n+            }\n+\n+            \/\/ |x| in [22, log(maxdouble)] return 0.5*exp(|x|)\n+            if (ix < 0x4086_2E42) {\n+                return 0.5*StrictMath.exp(Math.abs(x));\n+            }\n+\n+            \/\/ |x| in [log(maxdouble), overflowthresold]\n+            lx = __LO(x);\n+            if (ix<0x4086_33CE ||\n+                ((ix == 0x4086_33ce) &&\n+                 (Integer.compareUnsigned(lx, 0x8fb9_f87d) <= 0))) {\n+                w = StrictMath.exp(0.5*Math.abs(x));\n+                t = 0.5*w;\n+                return t*w;\n+            }\n+\n+            \/\/ |x| > overflowthresold, cosh(x) overflow\n+            return huge*huge;\n+        }\n+    }\n+\n+    \/**\n+     * Return the Hyperbolic Tangent of x\n+     *\n+     * Method :\n+     *                                     x    -x\n+     *                                    e  - e\n+     *      0. tanh(x) is defined to be -----------\n+     *                                     x    -x\n+     *                                    e  + e\n+     *      1. reduce x to non-negative by tanh(-x) = -tanh(x).\n+     *      2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)\n+     *                                              -t\n+     *          2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)\n+     *                                             t + 2\n+     *                                                   2\n+     *          1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)\n+     *                                                 t + 2\n+     *          22.0   <  x <= INF    : tanh(x) := 1.\n+     *\n+     * Special cases:\n+     *      tanh(NaN) is NaN;\n+     *      only tanh(0)=0 is exact for finite argument.\n+     *\/\n+    static final class Tanh {\n+        private Tanh() {throw new UnsupportedOperationException();}\n+\n+        private static final double tiny = 1.0e-300;\n+\n+        static double compute(double x) {\n+            double t, z;\n+            int jx, ix;\n+\n+            \/\/ High word of |x|.\n+            jx = __HI(x);\n+            ix = jx & 0x7fff_ffff;\n+\n+            \/\/ x is INF or NaN\n+            if (ix >= 0x7ff0_0000) {\n+                if (jx >= 0) {  \/\/ tanh(+-inf)=+-1\n+                    return 1.0\/x + 1.0;\n+                } else {        \/\/ tanh(NaN) = NaN\n+                    return 1.0\/x - 1.0;\n+                }\n+            }\n+\n+            \/\/ |x| < 22\n+            if (ix < 0x4036_0000) {          \/\/ |x| < 22\n+                if (ix<0x3c80_0000)          \/\/ |x| < 2**-55\n+                    return x*(1.0 + x);      \/\/ tanh(small) = small\n+                if (ix>=0x3ff0_0000) {       \/\/ |x| >= 1\n+                    t = StrictMath.expm1(2.0*Math.abs(x));\n+                    z = 1.0 - 2.0\/(t + 2.0);\n+                } else {\n+                    t = StrictMath.expm1(-2.0*Math.abs(x));\n+                    z= -t\/(t + 2.0);\n+                }\n+            } else { \/\/ |x| > 22, return +-1\n+                z = 1.0 - tiny;             \/\/ raised inexact flag\n+            }\n+            return (jx >= 0)? z: -z;\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":218,"deletions":10,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -2084,1 +2084,3 @@\n-    public static native double sinh(double x);\n+    public static double sinh(double x) {\n+        return FdLibm.Sinh.compute(x);\n+    }\n@@ -2108,1 +2110,3 @@\n-    public static native double cosh(double x);\n+    public static double cosh(double x) {\n+        return FdLibm.Cosh.compute(x);\n+    }\n@@ -2139,1 +2143,3 @@\n-    public static native double tanh(double x);\n+    public static double tanh(double x) {\n+        return FdLibm.Tanh.compute(x);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301833 8302026\n+ * @bug 8301833 8302026 8301444\n@@ -76,1 +76,1 @@\n-         \/\/ new UnaryTestCase(\"exp\",   FdlibmTranslit::exp,   StrictMath::exp,   DEFAULT_SHIFT),\n+            new UnaryTestCase(\"exp\",   FdlibmTranslit::exp,   StrictMath::exp,   DEFAULT_SHIFT),\n@@ -79,3 +79,3 @@\n-         \/\/ new UnaryTestCase(\"sinh\",  FdlibmTranslit::sinh,  StrictMath::sinh,  DEFAULT_SHIFT),\n-         \/\/ new UnaryTestCase(\"cosh\",  FdlibmTranslit::cosh,  StrictMath::cosh,  DEFAULT_SHIFT),\n-         \/\/ new UnaryTestCase(\"tanh\",  FdlibmTranslit::tanh,  StrictMath::tanh,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"sinh\",  FdlibmTranslit::sinh,  StrictMath::sinh,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"cosh\",  FdlibmTranslit::cosh,  StrictMath::cosh,  DEFAULT_SHIFT),\n+            new UnaryTestCase(\"tanh\",  FdlibmTranslit::tanh,  StrictMath::tanh,  DEFAULT_SHIFT),\n@@ -125,1 +125,1 @@\n-        \/\/ Note: pow does _not_ have translit a port\n+        \/\/ Note: pow does _not_ have a transliteration port.\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExhaustingTests.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -143,1 +143,1 @@\n-            failures += testExpCase(x, FdlibmTranslit.Exp.compute(x));\n+            failures += testExpCase(x, FdlibmTranslit.exp(x));\n","filename":"test\/jdk\/java\/lang\/StrictMath\/ExpTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,0 +105,4 @@\n+    public static double exp(double x) {\n+        return Exp.compute(x);\n+    }\n+\n@@ -109,0 +113,13 @@\n+    public static double sinh(double x) {\n+        return Sinh.compute(x);\n+    }\n+\n+    public static double cosh(double x) {\n+        return Cosh.compute(x);\n+    }\n+\n+    public static double tanh(double x) {\n+        return Tanh.compute(x);\n+    }\n+\n+\n@@ -623,1 +640,1 @@\n-    static class Exp {\n+    private static final class Exp {\n@@ -641,1 +658,1 @@\n-        public static double compute(double x) {\n+        static double compute(double x) {\n@@ -1219,0 +1236,194 @@\n+\n+    \/**\n+     * Method :\n+     * mathematically sinh(x) if defined to be (exp(x)-exp(-x))\/2\n+     *      1. Replace x by |x| (sinh(-x) = -sinh(x)).\n+     *      2.\n+     *                                                  E + E\/(E+1)\n+     *          0        <= x <= 22     :  sinh(x) := --------------, E=expm1(x)\n+     *                                                      2\n+     *\n+     *          22       <= x <= lnovft :  sinh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  sinh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  sinh(x) := x*shuge (overflow)\n+     *\n+     * Special cases:\n+     *      sinh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only sinh(0)=0 is exact for finite x.\n+     *\/\n+    private static final class Sinh {\n+        private static final double one = 1.0, shuge = 1.0e307;\n+\n+        static double compute(double x) {\n+            double t,w,h;\n+            int ix,jx;\n+            \/* unsigned *\/ int lx;\n+\n+            \/* High word of |x|. *\/\n+            jx = __HI(x);\n+            ix = jx&0x7fffffff;\n+\n+            \/* x is INF or NaN *\/\n+            if(ix>=0x7ff00000) return x+x;\n+\n+            h = 0.5;\n+            if (jx<0) h = -h;\n+            \/* |x| in [0,22], return sign(x)*0.5*(E+E\/(E+1))) *\/\n+            if (ix < 0x40360000) {          \/* |x|<22 *\/\n+                if (ix<0x3e300000)          \/* |x|<2**-28 *\/\n+                    if(shuge+x>one) return x;\/* sinh(tiny) = tiny with inexact *\/\n+                t = FdlibmTranslit.expm1(Math.abs(x));\n+                if(ix<0x3ff00000) return h*(2.0*t-t*t\/(t+one));\n+                return h*(t+t\/(t+one));\n+            }\n+\n+            \/* |x| in [22, log(maxdouble)] return 0.5*exp(|x|) *\/\n+            if (ix < 0x40862E42) return h*FdlibmTranslit.exp(Math.abs(x));\n+\n+            \/* |x| in [log(maxdouble), overflowthresold] *\/\n+            \/\/ Note: the original FDLIBM sources use\n+            \/\/ lx = *( (((*(unsigned*)&one)>>29)) + (unsigned*)&x);\n+            \/\/ to set lx to the low-order 32 bits of x. The expression\n+            \/\/ in question is an alternate way to implement the\n+            \/\/ functionality of the C FDLIBM __LO macro and the\n+            \/\/ expression is coded to work on both big-edian and\n+            \/\/ little-endian machines. However, this port will instead\n+            \/\/ use the __LO method call to represent this\n+            \/\/ functionality.\n+            lx = __LO(x);\n+            if (ix<0x408633CE || ((ix==0x408633ce)&&(Long.compareUnsigned(lx, 0x8fb9f87d) <= 0 ))) {\n+                w = exp(0.5*Math.abs(x));\n+                t = h*w;\n+                return t*w;\n+            }\n+\n+            \/* |x| > overflowthresold, sinh(x) overflow *\/\n+            return x*shuge;\n+        }\n+    }\n+\n+    \/**\n+     * Method :\n+     * mathematically cosh(x) if defined to be (exp(x)+exp(-x))\/2\n+     *      1. Replace x by |x| (cosh(x) = cosh(-x)).\n+     *      2.\n+     *                                                      [ exp(x) - 1 ]^2\n+     *          0        <= x <= ln2\/2  :  cosh(x) := 1 + -------------------\n+     *                                                         2*exp(x)\n+     *\n+     *                                                exp(x) +  1\/exp(x)\n+     *          ln2\/2    <= x <= 22     :  cosh(x) := -------------------\n+     *                                                        2\n+     *          22       <= x <= lnovft :  cosh(x) := exp(x)\/2\n+     *          lnovft   <= x <= ln2ovft:  cosh(x) := exp(x\/2)\/2 * exp(x\/2)\n+     *          ln2ovft  <  x           :  cosh(x) := huge*huge (overflow)\n+     *\n+     * Special cases:\n+     *      cosh(x) is |x| if x is +INF, -INF, or NaN.\n+     *      only cosh(0)=1 is exact for finite x.\n+     *\/\n+    private static final class Cosh {\n+        private static final double one = 1.0, half=0.5, huge = 1.0e300;\n+        static double compute(double x) {\n+            double t,w;\n+            int ix;\n+            \/*unsigned*\/ int lx;\n+\n+            \/* High word of |x|. *\/\n+            ix = __HI(x);\n+            ix &= 0x7fffffff;\n+\n+            \/* x is INF or NaN *\/\n+            if(ix>=0x7ff00000) return x*x;\n+\n+            \/* |x| in [0,0.5*ln2], return 1+expm1(|x|)^2\/(2*exp(|x|)) *\/\n+            if(ix<0x3fd62e43) {\n+                t = expm1(Math.abs(x));\n+                w = one+t;\n+                if (ix<0x3c800000) return w;        \/* cosh(tiny) = 1 *\/\n+                return one+(t*t)\/(w+w);\n+            }\n+\n+            \/* |x| in [0.5*ln2,22], return (exp(|x|)+1\/exp(|x|)\/2; *\/\n+            if (ix < 0x40360000) {\n+                t = exp(Math.abs(x));\n+                return half*t+half\/t;\n+            }\n+\n+            \/* |x| in [22, log(maxdouble)] return half*exp(|x|) *\/\n+            if (ix < 0x40862E42) return half*exp(Math.abs(x));\n+\n+            \/* |x| in [log(maxdouble), overflowthresold] *\/\n+            \/\/ See note above in the sinh implementation for how this\n+            \/\/ transliteration port uses __LO(x) in the line below\n+            \/\/ that differs from the idiom used in the original FDLIBM.\n+            lx = __LO(x);\n+            if (ix<0x408633CE ||\n+                ((ix==0x408633ce)&&(Integer.compareUnsigned(lx, 0x8fb9f87d) <= 0))) {\n+                w = exp(half*Math.abs(x));\n+                t = half*w;\n+                return t*w;\n+            }\n+\n+            \/* |x| > overflowthresold, cosh(x) overflow *\/\n+            return huge*huge;\n+        }\n+    }\n+\n+    \/**\n+     * Return the Hyperbolic Tangent of x\n+     *\n+     * Method :\n+     *                                     x    -x\n+     *                                    e  - e\n+     *      0. tanh(x) is defined to be -----------\n+     *                                     x    -x\n+     *                                    e  + e\n+     *      1. reduce x to non-negative by tanh(-x) = -tanh(x).\n+     *      2.  0      <= x <= 2**-55 : tanh(x) := x*(one+x)\n+     *                                              -t\n+     *          2**-55 <  x <=  1     : tanh(x) := -----; t = expm1(-2x)\n+     *                                             t + 2\n+     *                                                   2\n+     *          1      <= x <=  22.0  : tanh(x) := 1-  ----- ; t=expm1(2x)\n+     *                                                 t + 2\n+     *          22.0   <  x <= INF    : tanh(x) := 1.\n+     *\n+     * Special cases:\n+     *      tanh(NaN) is NaN;\n+     *      only tanh(0)=0 is exact for finite argument.\n+     *\/\n+    private static final class Tanh {\n+        private static final double one=1.0, two=2.0, tiny = 1.0e-300;\n+        static double compute(double x) {\n+            double t,z;\n+            int jx,ix;\n+\n+            \/* High word of |x|. *\/\n+            jx = __HI(x);\n+            ix = jx&0x7fffffff;\n+\n+            \/* x is INF or NaN *\/\n+            if(ix>=0x7ff00000) {\n+                if (jx>=0) return one\/x+one;    \/* tanh(+-inf)=+-1 *\/\n+                else       return one\/x-one;    \/* tanh(NaN) = NaN *\/\n+            }\n+\n+            \/* |x| < 22 *\/\n+            if (ix < 0x40360000) {          \/* |x|<22 *\/\n+                if (ix<0x3c800000)          \/* |x|<2**-55 *\/\n+                    return x*(one+x);       \/* tanh(small) = small *\/\n+                if (ix>=0x3ff00000) {       \/* |x|>=1  *\/\n+                    t = expm1(two*Math.abs(x));\n+                    z = one - two\/(t+two);\n+                } else {\n+                    t = expm1(-two*Math.abs(x));\n+                    z= -t\/(t+two);\n+                }\n+                \/* |x| > 22, return +-1 *\/\n+            } else {\n+                z = one - tiny;             \/* raised inexact flag *\/\n+            }\n+            return (jx>=0)? z: -z;\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":213,"deletions":2,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,3 @@\n+import jdk.test.lib.RandomFactory;\n+import java.util.function.DoubleUnaryOperator;\n+\n@@ -26,1 +29,8 @@\n- * @bug 4851625\n+ * @bug 4851625 8301444\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build HyperbolicTests\n+ * @run main HyperbolicTests\n@@ -33,1 +43,1 @@\n- * sinh, cos, and tanh, including the FDLIBM-based ones required by\n+ * sinh, cosh, and tanh, including the FDLIBM-based ones required by\n@@ -45,1 +55,187 @@\n-    static int testSinhCase(double input, double expected) {\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testAgainstTranslitCommon();\n+\n+        failures += testAgainstTranslitSinh();\n+        failures += testAgainstTranslitCosh();\n+        failures += testAgainstTranslitTanh();\n+\n+        failures += testSinh();\n+        failures += testCosh();\n+        failures += testTanh();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing the hyperbolics incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n+    \/**\n+     * Bundle together groups of testing methods.\n+     *\/\n+    private static enum HyperbolicTest {\n+        SINH(HyperbolicTests::testSinhCase, FdlibmTranslit::sinh),\n+        COSH(HyperbolicTests::testCoshCase, FdlibmTranslit::cosh),\n+        TANH(HyperbolicTests::testTanhCase, FdlibmTranslit::tanh);\n+\n+        private DoubleDoubleToInt testCase;\n+        private DoubleUnaryOperator transliteration;\n+\n+        HyperbolicTest(DoubleDoubleToInt testCase, DoubleUnaryOperator transliteration) {\n+            this.testCase = testCase;\n+            this.transliteration = transliteration;\n+        }\n+\n+        public DoubleDoubleToInt testCase() {return testCase;}\n+        public DoubleUnaryOperator transliteration() {return transliteration;}\n+    }\n+\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test against shared points of interest.\n+     *\/\n+    private static int testAgainstTranslitCommon() {\n+        int failures = 0;\n+        double[] pointsOfInterest = {\n+            Double.MIN_NORMAL,\n+            1.0,\n+            Tests.createRandomDouble(random),\n+        };\n+\n+        for (var testMethods : HyperbolicTest.values()) {\n+            for (double testPoint : pointsOfInterest) {\n+                failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, testMethods);\n+            }\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.sinh against transliteration port of sinh.\n+     *\/\n+    private static int testAgainstTranslitSinh() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0.0,\n+\n+             22.0,\n+            -22.0,\n+\n+             0x1.0p-28,\n+            -0x1.0p-28,\n+\n+            \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n+             0x1.62e42fefa39efp9,\n+            -0x1.62e42fefa39efp9,\n+\n+            \/\/ Largest argument with finite sinh, 710.4758600739439\n+             0x1.633ce8fb9f87dp9,\n+            -0x1.633ce8fb9f87dp9,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, HyperbolicTest.SINH);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.cosh against transliteration port of cosh.\n+     *\/\n+    private static int testAgainstTranslitCosh() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0.0,\n+\n+             22.0,\n+            -22.0,\n+\n+            \/\/ StrictMath.log(2)\/2 ~= 0.34657359027997264\n+             0x1.62e42fefa39efp-2,\n+            -0x1.62e42fefa39efp-2,\n+\n+             0x1.0p-28,\n+            -0x1.0p-28,\n+\n+            \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n+             0x1.62e42fefa39efp9,\n+            -0x1.62e42fefa39efp9,\n+\n+            \/\/ Largest argument with finite cosh, 710.4758600739439\n+             0x1.633ce8fb9f87dp9,\n+            -0x1.633ce8fb9f87dp9,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, HyperbolicTest.COSH);\n+        }\n+\n+        return failures;\n+    }\n+\n+    \/**\n+     * Test StrictMath.tanh against transliteration port of tanh\n+     *\/\n+    private static int testAgainstTranslitTanh() {\n+        int failures = 0;\n+        double x;\n+\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0.0,\n+\n+             0x1.0p-55,\n+            -0x1.0p-55,\n+\n+             1.0,\n+            -1.0,\n+\n+             22.0,\n+        };\n+\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, HyperbolicTest.COSH);\n+        }\n+\n+        return failures;\n+    }\n+\n+    private interface DoubleDoubleToInt {\n+        int apply(double x, double y);\n+    }\n+\n+    private static int testRange(double start, double increment, int count,\n+                                 HyperbolicTest testMethods) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testRangeMidpoint(double midpoint, double increment, int count,\n+                                         HyperbolicTest testMethods) {\n+        int failures = 0;\n+        double x = midpoint - increment*(count \/ 2) ;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n+        }\n+        return failures;\n+    }\n+\n+    private static int testSinhCase(double input, double expected) {\n@@ -50,1 +246,1 @@\n-    static int testCoshCase(double input, double expected) {\n+    private static int testCoshCase(double input, double expected) {\n@@ -55,1 +251,1 @@\n-    static int testTanhCase(double input, double expected) {\n+    private static int testTanhCase(double input, double expected) {\n@@ -60,1 +256,1 @@\n-    static int testSinh() {\n+    private static int testSinh() {\n@@ -150,1 +346,1 @@\n-            failures+=testSinhCase(testCase[0], testCase[1]);\n+            failures += testSinhCase(testCase[0], testCase[1]);\n@@ -155,1 +351,1 @@\n-    static int testCosh() {\n+    private static int testCosh() {\n@@ -191,1 +387,1 @@\n-            failures+=testCoshCase(testCase[0], testCase[1]);\n+            failures += testCoshCase(testCase[0], testCase[1]);\n@@ -196,1 +392,1 @@\n-    static int testTanh() {\n+    private static int testTanh() {\n@@ -260,1 +456,1 @@\n-            failures+=testTanhCase(testCase[0], testCase[1]);\n+            failures += testTanhCase(testCase[0], testCase[1]);\n@@ -264,15 +460,0 @@\n-\n-\n-    public static void main(String [] argv) {\n-        int failures = 0;\n-\n-        failures += testSinh();\n-        failures += testCosh();\n-        failures += testTanh();\n-\n-        if (failures > 0) {\n-            System.err.println(\"Testing the hyperbolics incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n-        }\n-    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/HyperbolicTests.java","additions":208,"deletions":27,"binary":false,"changes":235,"status":"modified"}]}