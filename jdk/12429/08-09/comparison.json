{"files":[{"patch":"@@ -662,1 +662,1 @@\n-        private Exp() {throw new UnsupportedOperationException();};\n+        private Exp() {throw new UnsupportedOperationException();}\n@@ -664,1 +664,0 @@\n-        private static final double one     = 1.0;\n@@ -724,2 +723,2 @@\n-                if (huge + x > one)\n-                    return one + x; \/* trigger inexact *\/\n+                if (huge + x > 1.0)\n+                    return 1.0 + x; \/* trigger inexact *\/\n@@ -734,1 +733,1 @@\n-                return one - ((x*c)\/(c - 2.0) - x);\n+                return 1.0 - ((x*c)\/(c - 2.0) - x);\n@@ -736,1 +735,1 @@\n-                y = one - ((lo - (x*c)\/(2.0 - c)) - hi);\n+                y = 1.0 - ((lo - (x*c)\/(2.0 - c)) - hi);\n@@ -1356,1 +1355,1 @@\n-        private static final double one = 1.0, shuge = 1.0e307;\n+        private static final double shuge = 1.0e307;\n@@ -1358,1 +1357,1 @@\n-         static double compute(double x) {\n+        static double compute(double x) {\n@@ -1379,1 +1378,1 @@\n-                    if (shuge + x > one) {   \/\/ sinh(tiny) = tiny with inexact\n+                    if (shuge + x > 1.0) {   \/\/ sinh(tiny) = tiny with inexact\n@@ -1384,1 +1383,1 @@\n-                    return h*(2.0 * t - t*t\/(t + one));\n+                    return h*(2.0 * t - t*t\/(t + 1.0));\n@@ -1386,1 +1385,1 @@\n-                return h*(t + t\/(t + one));\n+                return h*(t + t\/(t + 1.0));\n@@ -1432,1 +1431,2 @@\n-        private static final double one = 1.0, half=0.5, huge = 1.0e300;\n+        private static final double huge = 1.0e300;\n+\n@@ -1450,1 +1450,1 @@\n-                w = one + t;\n+                w = 1.0 + t;\n@@ -1454,1 +1454,1 @@\n-                return one + (t * t)\/(w + w);\n+                return 1.0 + (t * t)\/(w + w);\n@@ -1460,1 +1460,1 @@\n-                return half*t + half\/t;\n+                return 0.5*t + 0.5\/t;\n@@ -1463,1 +1463,1 @@\n-            \/\/ |x| in [22, log(maxdouble)] return half*exp(|x|)\n+            \/\/ |x| in [22, log(maxdouble)] return 0.5*exp(|x|)\n@@ -1465,1 +1465,1 @@\n-                return half*StrictMath.exp(Math.abs(x));\n+                return 0.5*StrictMath.exp(Math.abs(x));\n@@ -1473,2 +1473,2 @@\n-                w = StrictMath.exp(half*Math.abs(x));\n-                t = half*w;\n+                w = StrictMath.exp(0.5*Math.abs(x));\n+                t = 0.5*w;\n@@ -1482,0 +1482,1 @@\n+\n@@ -1508,1 +1509,2 @@\n-        private static final double one=1.0, two=2.0, tiny = 1.0e-300;\n+        private static final double tiny = 1.0e-300;\n+\n@@ -1520,1 +1522,1 @@\n-                    return one\/x + one;\n+                    return 1.0\/x + 1.0;\n@@ -1522,1 +1524,1 @@\n-                    return one\/x - one;\n+                    return 1.0\/x - 1.0;\n@@ -1529,1 +1531,1 @@\n-                    return x*(one + x);      \/\/ tanh(small) = small\n+                    return x*(1.0 + x);      \/\/ tanh(small) = small\n@@ -1531,2 +1533,2 @@\n-                    t = StrictMath.expm1(two*Math.abs(x));\n-                    z = one - two\/(t + two);\n+                    t = StrictMath.expm1(2.0*Math.abs(x));\n+                    z = 1.0 - 2.0\/(t + 2.0);\n@@ -1534,2 +1536,2 @@\n-                    t = StrictMath.expm1(-two*Math.abs(x));\n-                    z= -t\/(t + two);\n+                    t = StrictMath.expm1(-2.0*Math.abs(x));\n+                    z= -t\/(t + 2.0);\n@@ -1538,1 +1540,1 @@\n-                z = one - tiny;             \/\/ raised inexact flag\n+                z = 1.0 - tiny;             \/\/ raised inexact flag\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":30,"deletions":28,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.util.function.DoubleUnaryOperator;\n+\n@@ -41,1 +43,1 @@\n- * sinh, cos, and tanh, including the FDLIBM-based ones required by\n+ * sinh, cosh, and tanh, including the FDLIBM-based ones required by\n@@ -56,0 +58,2 @@\n+        failures += testAgainstTranslitCommon();\n+\n@@ -71,0 +75,20 @@\n+    \/**\n+     * Bundle together groups of testing methods.\n+     *\/\n+    private static enum HyperbolicTest {\n+        SINH(HyperbolicTests::testSinhCase, FdlibmTranslit::sinh),\n+        COSH(HyperbolicTests::testCoshCase, FdlibmTranslit::cosh),\n+        TANH(HyperbolicTests::testTanhCase, FdlibmTranslit::tanh);\n+\n+        private DoubleDoubleToInt testCase;\n+        private DoubleUnaryOperator transliteration;\n+\n+        HyperbolicTest(DoubleDoubleToInt testCase, DoubleUnaryOperator transliteration) {\n+            this.testCase = testCase;\n+            this.transliteration = transliteration;\n+        }\n+\n+        public DoubleDoubleToInt testCase() {return testCase;}\n+        public DoubleUnaryOperator transliteration() {return transliteration;}\n+    }\n+\n@@ -75,1 +99,1 @@\n-     * Test StrictMath.sinh against transliteration port of sinh.\n+     * Test against shared points of interest.\n@@ -77,1 +101,1 @@\n-    private static int testAgainstTranslitSinh() {\n+    private static int testAgainstTranslitCommon() {\n@@ -79,9 +103,5 @@\n-        double x;\n-\n-        \/\/ Test just above subnormal threshold...\n-        x = Double.MIN_NORMAL;\n-        failures += testRangeSinh(x, Math.ulp(x), 1000);\n-\n-         \/\/ ... and just below subnormal threshold ...\n-          x = Math.nextDown(Double.MIN_NORMAL);\n-          failures += testRangeSinh(x, -Math.ulp(x), 1000);\n+        double[] pointsOfInterest = {\n+            Double.MIN_NORMAL,\n+            1.0,\n+            Tests.createRandomDouble(random),\n+        };\n@@ -89,4 +109,5 @@\n-         \/\/ ... and near 1.0 ...\n-          failures += testRangeMidpointSinh(1.0, Math.ulp(x), 2000);\n-          \/\/ (Note: probes every-other value less than 1.0 due to\n-          \/\/ change in the size of an ulp at 1.0.\n+        for (var testMethods : HyperbolicTest.values()) {\n+            for (double testPoint : pointsOfInterest) {\n+                failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, testMethods);\n+            }\n+        }\n@@ -94,3 +115,2 @@\n-          \/\/ Probe near decision points in the FDLIBM algorithm.\n-          double[] decisionPoints = {\n-               0.0,\n+        return failures;\n+    }\n@@ -98,2 +118,6 @@\n-               22.0,\n-              -22.0,\n+    \/**\n+     * Test StrictMath.sinh against transliteration port of sinh.\n+     *\/\n+    private static int testAgainstTranslitSinh() {\n+        int failures = 0;\n+        double x;\n@@ -101,2 +125,3 @@\n-               0x1.0p-28,\n-              -0x1.0p-28,\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0.0,\n@@ -104,3 +129,2 @@\n-               \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n-               0x1.62e42fefa39efp9,\n-              -0x1.62e42fefa39efp9,\n+             22.0,\n+            -22.0,\n@@ -108,4 +132,2 @@\n-               \/\/ Largest argument with finite sinh, 710.4758600739439\n-               0x1.633ce8fb9f87dp9,\n-              -0x1.633ce8fb9f87dp9,\n-          };\n+             0x1.0p-28,\n+            -0x1.0p-28,\n@@ -113,3 +135,3 @@\n-          for (double testPoint : decisionPoints) {\n-              failures += testRangeMidpointSinh(testPoint, Math.ulp(testPoint), 1000);\n-          }\n+            \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n+             0x1.62e42fefa39efp9,\n+            -0x1.62e42fefa39efp9,\n@@ -117,1 +139,4 @@\n-          x = Tests.createRandomDouble(random);\n+            \/\/ Largest argument with finite sinh, 710.4758600739439\n+             0x1.633ce8fb9f87dp9,\n+            -0x1.633ce8fb9f87dp9,\n+        };\n@@ -119,5 +144,3 @@\n-          \/\/ Make the increment twice the ulp value in case the random\n-          \/\/ value is near an exponent threshold. Don't worry about test\n-          \/\/ elements overflowing to infinity if the starting value is\n-          \/\/ near Double.MAX_VALUE.\n-          failures += testRangeSinh(x, 2.0 * Math.ulp(x), 1000);\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, HyperbolicTest.SINH);\n+        }\n@@ -125,1 +148,1 @@\n-         return failures;\n+        return failures;\n@@ -135,16 +158,3 @@\n-        \/\/ Test just above subnormal threshold...\n-        x = Double.MIN_NORMAL;\n-        failures += testRangeCosh(x, Math.ulp(x), 1000);\n-\n-         \/\/ ... and just below subnormal threshold ...\n-          x = Math.nextDown(Double.MIN_NORMAL);\n-          failures += testRangeCosh(x, -Math.ulp(x), 1000);\n-\n-         \/\/ ... and near 1.0 ...\n-          failures += testRangeMidpointCosh(1.0, Math.ulp(x), 2000);\n-          \/\/ (Note: probes every-other value less than 1.0 due to\n-          \/\/ change in the size of an ulp at 1.0.\n-\n-          \/\/ Probe near decision points in the FDLIBM algorithm.\n-          double[] decisionPoints = {\n-               0.0,\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+            0.0,\n@@ -152,2 +162,2 @@\n-               22.0,\n-              -22.0,\n+             22.0,\n+            -22.0,\n@@ -155,3 +165,3 @@\n-               \/\/ StrictMath.log(2)\/2 ~= 0.34657359027997264\n-               0x1.62e42fefa39efp-2,\n-              -0x1.62e42fefa39efp-2,\n+            \/\/ StrictMath.log(2)\/2 ~= 0.34657359027997264\n+             0x1.62e42fefa39efp-2,\n+            -0x1.62e42fefa39efp-2,\n@@ -159,2 +169,2 @@\n-               0x1.0p-28,\n-              -0x1.0p-28,\n+             0x1.0p-28,\n+            -0x1.0p-28,\n@@ -162,3 +172,3 @@\n-               \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n-               0x1.62e42fefa39efp9,\n-              -0x1.62e42fefa39efp9,\n+            \/\/ StrictMath.log(Double.MAX_VALUE) ~= 709.782712893384\n+             0x1.62e42fefa39efp9,\n+            -0x1.62e42fefa39efp9,\n@@ -166,10 +176,4 @@\n-               \/\/ Largest argument with finite cosh, 710.4758600739439\n-               0x1.633ce8fb9f87dp9,\n-              -0x1.633ce8fb9f87dp9,\n-          };\n-\n-          for (double testPoint : decisionPoints) {\n-              failures += testRangeMidpointCosh(testPoint, Math.ulp(testPoint), 1000);\n-          }\n-\n-          x = Tests.createRandomDouble(random);\n+            \/\/ Largest argument with finite cosh, 710.4758600739439\n+             0x1.633ce8fb9f87dp9,\n+            -0x1.633ce8fb9f87dp9,\n+        };\n@@ -177,5 +181,3 @@\n-          \/\/ Make the increment twice the ulp value in case the random\n-          \/\/ value is near an exponent threshold. Don't worry about test\n-          \/\/ elements overflowing to infinity if the starting value is\n-          \/\/ near Double.MAX_VALUE.\n-          failures += testRangeCosh(x, 2.0 * Math.ulp(x), 1000);\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, HyperbolicTest.COSH);\n+        }\n@@ -183,1 +185,1 @@\n-         return failures;\n+        return failures;\n@@ -193,19 +195,3 @@\n-        \/\/ Test just above subnormal threshold...\n-        x = Double.MIN_NORMAL;\n-        failures += testRangeTanh(x, Math.ulp(x), 1000);\n-\n-         \/\/ ... and just below subnormal threshold ...\n-          x = Math.nextDown(Double.MIN_NORMAL);\n-          failures += testRangeTanh(x, -Math.ulp(x), 1000);\n-\n-         \/\/ ... and near 1.0 ...\n-          failures += testRangeMidpointTanh(1.0, Math.ulp(x), 2000);\n-          \/\/ (Note: probes every-other value less than 1.0 due to\n-          \/\/ change in the size of an ulp at 1.0.\n-\n-          \/\/ Probe near decision points in the FDLIBM algorithm.\n-          double[] decisionPoints = {\n-               0.0,\n-\n-               0x1.0p-55,\n-              -0x1.0p-55,\n+        \/\/ Probe near decision points in the FDLIBM algorithm.\n+        double[] decisionPoints = {\n+             0.0,\n@@ -213,2 +199,2 @@\n-               1.0,\n-              -1.0,\n+             0x1.0p-55,\n+            -0x1.0p-55,\n@@ -216,2 +202,2 @@\n-               22.0,\n-          };\n+             1.0,\n+            -1.0,\n@@ -219,14 +205,2 @@\n-          for (double testPoint : decisionPoints) {\n-              failures += testRangeMidpointTanh(testPoint, Math.ulp(testPoint), 1000);\n-          }\n-\n-          x = Tests.createRandomDouble(random);\n-\n-          \/\/ Make the increment twice the ulp value in case the random\n-          \/\/ value is near an exponent threshold. Don't worry about test\n-          \/\/ elements overflowing to infinity if the starting value is\n-          \/\/ near Double.MAX_VALUE.\n-          failures += testRangeTanh(x, 2.0 * Math.ulp(x), 1000);\n-\n-         return failures;\n-    }\n+             22.0,\n+        };\n@@ -234,5 +208,2 @@\n-    private static int testRangeSinh(double start, double increment, int count) {\n-        int failures = 0;\n-        double x = start;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testSinhCase(x, FdlibmTranslit.sinh(x));\n+        for (double testPoint : decisionPoints) {\n+            failures += testRangeMidpoint(testPoint, Math.ulp(testPoint), 1000, HyperbolicTest.COSH);\n@@ -240,2 +211,0 @@\n-        return failures;\n-    }\n@@ -243,6 +212,0 @@\n-    private static int testRangeCosh(double start, double increment, int count) {\n-        int failures = 0;\n-        double x = start;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testCoshCase(x, FdlibmTranslit.cosh(x));\n-        }\n@@ -252,7 +215,2 @@\n-    private static int testRangeTanh(double start, double increment, int count) {\n-        int failures = 0;\n-        double x = start;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testTanhCase(x, FdlibmTranslit.tanh(x));\n-        }\n-        return failures;\n+    private interface DoubleDoubleToInt {\n+        int apply(double x, double y);\n@@ -261,2 +219,2 @@\n-\n-    private static int testRangeMidpointSinh(double midpoint, double increment, int count) {\n+    private static int testRange(double start, double increment, int count,\n+                                 HyperbolicTest testMethods) {\n@@ -264,10 +222,1 @@\n-        double x = midpoint - increment*(count \/ 2) ;\n-        for (int i = 0; i < count; i++, x += increment) {\n-            failures += testSinhCase(x, FdlibmTranslit.sinh(x));\n-        }\n-        return failures;\n-    }\n-\n-    private static int testRangeMidpointCosh(double midpoint, double increment, int count) {\n-        int failures = 0;\n-        double x = midpoint - increment*(count \/ 2) ;\n+        double x = start;\n@@ -275,1 +224,2 @@\n-            failures += testCoshCase(x, FdlibmTranslit.cosh(x));\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n@@ -280,1 +230,2 @@\n-    private static int testRangeMidpointTanh(double midpoint, double increment, int count) {\n+    private static int testRangeMidpoint(double midpoint, double increment, int count,\n+                                         HyperbolicTest testMethods) {\n@@ -284,1 +235,2 @@\n-            failures += testTanhCase(x, FdlibmTranslit.tanh(x));\n+            failures +=\n+                testMethods.testCase().apply(x, testMethods.transliteration().applyAsDouble(x));\n@@ -289,2 +241,1 @@\n-\n-    static int testSinhCase(double input, double expected) {\n+    private static int testSinhCase(double input, double expected) {\n@@ -295,1 +246,1 @@\n-    static int testCoshCase(double input, double expected) {\n+    private static int testCoshCase(double input, double expected) {\n@@ -300,1 +251,1 @@\n-    static int testTanhCase(double input, double expected) {\n+    private static int testTanhCase(double input, double expected) {\n@@ -305,1 +256,1 @@\n-    static int testSinh() {\n+    private static int testSinh() {\n@@ -395,1 +346,1 @@\n-            failures+=testSinhCase(testCase[0], testCase[1]);\n+            failures += testSinhCase(testCase[0], testCase[1]);\n@@ -400,1 +351,1 @@\n-    static int testCosh() {\n+    private static int testCosh() {\n@@ -436,1 +387,1 @@\n-            failures+=testCoshCase(testCase[0], testCase[1]);\n+            failures += testCoshCase(testCase[0], testCase[1]);\n@@ -441,1 +392,1 @@\n-    static int testTanh() {\n+    private static int testTanh() {\n@@ -505,1 +456,1 @@\n-            failures+=testTanhCase(testCase[0], testCase[1]);\n+            failures += testTanhCase(testCase[0], testCase[1]);\n","filename":"test\/jdk\/java\/lang\/StrictMath\/HyperbolicTests.java","additions":115,"deletions":164,"binary":false,"changes":279,"status":"modified"}]}