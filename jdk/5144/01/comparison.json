{"files":[{"patch":"@@ -599,3 +599,1 @@\n-* Generic lambdas.  Lambdas are not (yet) permitted.\n-\n-* Lambda init captures.  Lambdas are not (yet) permitted.\n+* Also see [lambda expressions](#lambdaexpressions).\n@@ -706,0 +704,267 @@\n+### Local Function Objects\n+\n+* Local function objects, including lambda expressions, may be used.\n+* Lambda expressions must only be used as a downward value.\n+* Prefer `[&]` as the capture list of a lambda expression.\n+* Return type deduction for lambda expressions is permitted, and indeed encouraged.\n+* An empty parameter list for a lambda expression may be elided.\n+* A lambda expression must not be `mutable`.\n+* Generic lambda expressions are permitted.\n+* Lambda expressions should be relatively simple.\n+* Anonymous lambda expressions should not overly clutter the enclosing expression.\n+* An anonymous lambda expression must not be directly invoked.\n+* Bind expressions are forbidden.\n+\n+Single-use function objects can be defined locally within a function,\n+directly at the point of use.  This is an alternative to having a function\n+or function object class defined at class or namespace scope.\n+\n+This usage was somewhat limited by C++03, which does not permit such a class\n+to be used as a template parameter.  That restriction was removed by C++11\n+([n2657]). Use of this feature is permitted.\n+\n+Many HotSpot protocols involve \"function-like\" objects that involve some\n+named member function rather than a call operator.  For example, a function\n+that performs some action on all threads might be written as\n+\n+```\n+void do_something() {\n+  struct DoSomething : public ThreadClosure {\n+    virtual void do_thread(Thread* t) {\n+      ... do something with t ...\n+    }\n+  } closure;\n+  Threads::threads_do(&closure);\n+}\n+```\n+\n+HotSpot code has historically usually placed the DoSomething class at\n+namespace (or sometimes class) scope.  This separates the function's code\n+from its use, often to the detriment of readability.  It requires giving the\n+class a globally unique name (if at namespace scope).  It also loses the\n+information that the class is intended for use in exactly one place, and\n+does not have any subclasses.  (However, the latter can now be indicated by\n+declaring it `final`.)  Often, for simplicity, a local class will skip\n+things like access control and accessor functions, giving the enclosing\n+function direct access to the implementation and eliminating some\n+boilerplate that might be provided if the class is in some outer (more\n+accessible) scope.  On the other hand, if there is a lot of surrounding code\n+in the function body or the local class is of significant size, defining it\n+locally can increase clutter and reduce readability.\n+\n+<a name=\"lambdaexpressions\"><\/a>\n+C++11 added _lambda expressions_ as a new way to write a function object.\n+Simple lambda expressions can be significantly more concise than a function\n+object, eliminating a lot of boiler-plate.  On the other hand, a complex\n+lambda expression may not provide much, if any, readability benefit compared\n+to an ordinary function object.  Also, while a lambda can encapsulate a call\n+to a \"function-like\" object, it cannot be used in place of such.\n+\n+A common use for local functions is as one-use [RAII] objects.  The amount\n+of boilerplate for a function object class (local or not) makes such usage\n+somewhat clumsy and verbose.  But with the help of a small amount of\n+supporting utility code, lambdas work particularly well for this use case.\n+\n+Another use for local functions is [partial application][PARTIALAPP].  Again\n+here, lambdas are typically much simpler and less verbose than function\n+object classes.\n+\n+Because of these benefits, lambda expressions are permitted in HotSpot code,\n+with some restrictions and usage guidance.  An anonymous lambda is one which\n+is passed directly as an argument.  A named lambda is the value of a\n+variable, which is its name.\n+\n+Lambda expressions should only be passed downward.  In particular, a lambda\n+should not be returned from a function or stored in a global variable,\n+whether directly or as the value of a member of some other object.  Lambda\n+capture is syntactically subtle (by design), and propagating a lambda in\n+such ways can easily pass references to captured values to places where they\n+are no longer valid.  In particular, members of the enclosing `this` object\n+are effectively captured by reference, even if the default capture is\n+by-value.  For such uses-cases a function object class should be used to\n+make the desired value capturing and propagation explicit.\n+\n+Limiting the capture list to `[&]` (implicitly capture by reference) is a\n+simplifying restriction that still provides good support for HotSpot usage,\n+while reducing the cases a reader must recognize and understand.\n+\n+* Many common lambda uses require reference capture.  Not permitting it\n+would substantially reduce the utility of lambdas.\n+\n+* Referential transparency.  Implicit reference capture makes variable\n+references in the lambda body have the same meaning they would have in the\n+enclosing code.  There isn't a semantic barrier across which the meaning of\n+a variable changes.\n+\n+* Explicit reference capture introduces significant clutter, especially when\n+lambda expressions are relatively small and simple, as they should be in\n+HotSpot code.\n+\n+* There are a number of reasons why by-value capture might be used, but for\n+the most part they don't apply to HotSpot code, given other usage restrictions.\n+\n+    * A primary use-case for by-value capture is to support escaping uses,\n+    where values captured by-reference might become invalid.  That use-case\n+    doesn't apply if only downward lambdas are used.\n+\n+    * By-value capture can also make a lambda-local copy for mutation, which\n+    requires making the lambda `mutable`; see below.\n+\n+    * By-value capture might be viewed as an optimization, avoiding any\n+    overhead for reference capture of cheap to copy values.  But the\n+    compiler can often eliminate any such overhead.\n+\n+    * By-value capture by a non-`mutable` lambda makes the captured values\n+    const, preventing any modification by the lambda and making the captured\n+    value unaffected by modifications to the outer variable.  But this only\n+    applies to captured auto variables, not member variables, and is\n+    inconsistent with referential transparency.\n+\n+* Non-capturing lambdas (with an empty capture list - `[]`) have limited\n+utility.  There are cases where no captures are required (pure functions,\n+for example), but if the function is small and simple then that's obvious\n+anyway.\n+\n+* Capture initializers (a C++14 feature - [N3649]) are not permitted.\n+Capture initializers inherently increase the complexity of the capture list,\n+and provide little benefit over an additional in-scope local variable.\n+\n+The use of `mutable` lambda expressions is forbidden because there don't\n+seem to be many, if any, good use-cases for them in HotSpot.  A lambda\n+expression needs to be mutable in order to modify a by-value captured value.\n+But with only downward lambdas, such usage seems likely to be rare and\n+complicated.  It is better to use a function object class in any such cases\n+that arise, rather than requiring all HotSpot developers to understand this\n+relatively obscure feature.\n+\n+While it is possible to directly invoke an anonymous lambda expression, that\n+feature should not be used, as such a form can be confusing to readers.\n+Instead, name the lambda and call it by name.\n+\n+Some reasons to prefer a named lambda instead of an anonymous lambda are\n+\n+* The body contains non-trivial control flow or declarations or other nested\n+constructs.\n+\n+* Its role in an argument list is hard to guess without examining the\n+function declaration.  Give it a name that indicates its purpose.\n+\n+* It has an unusual capture list.\n+\n+* It has a complex explicit return type or parameter types.\n+\n+Lambda expressions, and particularly anonymous lambda expressions, should be\n+simple and compact.  One-liners are good.  Anonymous lambdas should usually\n+be limited to a couple lines of body code.  More complex lambdas should be\n+named.  A named lambda should not clutter the enclosing function and make it\n+long and complex; do continue to break up large functions via the use of\n+separate helper functions.\n+\n+An anonymous lambda expression should either be a one-liner in a one-line\n+expression, or isolated in its own set of lines.  Don't place part of a\n+lambda expression on the same line as other arguments to a function.  The\n+body of a multi-line lambda argument should be indented from the start of\n+the capture list, as if that were the start of an ordinary function\n+definition.  The body of a multi-line named lambda should be indented one\n+step from the variable's indentation.\n+\n+Some examples:\n+\n+1. `foo([&] { ++counter; });`\n+2. `foo(x, [&] { ++counter; });`\n+3. `foo([&] { if (predicate) ++counter; });`\n+4. `foo([&] { auto tmp = process(x); tmp.f(); return tmp.g(); })`\n+5. Separate one-line lambda from other arguments:\n+\n+    ```\n+    foo(c.begin(), c.end(),\n+        [&] (const X& x) { do_something(x); return x.value(); });\n+    ```\n+6. Indentation for multi-line lambda:\n+\n+    ```\n+    c.do_entries([&] (const X& x) {\n+                   do_something(x, a);\n+                   do_something1(x, b);\n+                   do_something2(x, c);\n+                 });\n+    ```\n+7. Separate multi-line lambda from other arguments:\n+\n+    ```\n+    foo(c.begin(), c.end(),\n+        [&] (const X& x) {\n+          do_something(x, a);\n+          do_something1(x, b);\n+          do_something2(x, c);\n+        });\n+    ```\n+8. Multi-line named lambda:\n+\n+    ```\n+    auto do_entry = [&] (const X& x) {\n+      do_something(x, a);\n+      do_something1(x, b);\n+      do_something2(x, c);\n+    };\n+    ```\n+\n+Item 4, and especially items 6 and 7, are pushing the simplicity limits for\n+anonymous lambdas.  Item 6 might be better written using a named lambda:\n+```\n+c.do_entries(do_entry);\n+```\n+\n+Note that C++11 also added _bind expressions_ as a way to write a function\n+object for partial application, using `std::bind` and related facilities\n+from the Standard Library.  `std::bind` generalizes and replaces some of the\n+binders from C++03.  Bind expressions are not permitted in HotSpot code.\n+They don't provide enough benefit over lambdas or local function classes in\n+the cases where bind expressions are applicable to warrant the introduction\n+of yet another mechanism in this space into HotSpot code.\n+\n+References:\n+\n+* Local and unnamed types as template parameters ([n2657])\n+* New wording for C++0x lambdas ([n2927])\n+* Generalized lambda capture (init-capture) ([N3648])\n+* Generic (polymorphic) lambda expressions ([N3649])\n+\n+[n2657]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm \n+[n2927]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2009\/n2927.pdf\n+[N3648]: https:\/\/isocpp.org\/files\/papers\/N3648.html\n+[N3649]: https:\/\/isocpp.org\/files\/papers\/N3649.html\n+\n+References from C++17\n+\n+* Wording for constexpr lambda ([p0170r1])\n+* Lambda capture of *this by Value ([p0018r3])\n+\n+[p0170r1]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2016\/p0170r1.pdf\n+[p0018r3]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2016\/p0018r3.html\n+\n+References from C++20\n+\n+* Allow lambda capture [=, this] ([p0409r2])\n+* Familiar template syntax for generic lambdas ([p0428r2])\n+* Simplifying implicit lambda capture ([p0588r1])\n+* Default constructible and assignable stateless lambdas ([p0624r2])\n+* Lambdas in unevaluated contexts ([p0315r4])\n+* Allow pack expansion in lambda init-capture ([p0780r2]) ([p2095r0])\n+* Deprecate implicit capture of this via [=] ([p0806r2])\n+\n+[p0409r2]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0409r2.html\n+[p0428r2]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0428r2.pdf\n+[p0588r1]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0588r1.html\n+[p0624r2]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0624r2.pdf\n+[p0315r4]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0315r4.pdf\n+[p0780r2]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0780r2.html\n+[p2095r0]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2020\/p2095r0.html\n+[p0806r2]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0806r2.html\n+\n+References from C++23\n+\n+* Make () more optional for lambdas  ([p1102r2])\n+\n+[p1102r2]: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2020\/p1102r2.html\n+\n@@ -760,3 +1025,0 @@\n-* Local and unnamed types as template parameters\n-([n2657](http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm))\n-\n@@ -840,3 +1102,0 @@\n-* Lambdas\n-\n-\n@@ -857,0 +1116,3 @@\n+\n+[PARTIALAPP]: https:\/\/en.wikipedia.org\/wiki\/Partial_application\n+  \"Partial Application\"\n","filename":"doc\/hotspot-style.md","additions":271,"deletions":9,"binary":false,"changes":280,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"utilities\/scopeGuard.hpp\"\n@@ -781,14 +782,0 @@\n-class LineCopy : StackObj {\n-  const char* _copy;\n-public:\n-    LineCopy(char* line) {\n-      _copy = os::strdup(line, mtInternal);\n-    }\n-    ~LineCopy() {\n-      os::free((void*)_copy);\n-    }\n-    char* get() {\n-      return (char*)_copy;\n-    }\n-};\n-\n@@ -799,1 +786,3 @@\n-  LineCopy original(line);\n+  char* original_line = os::strdup(line, mtInternal);\n+  auto g = make_guard([&] { os::free(original_line); });\n+\n@@ -808,1 +797,1 @@\n-    print_parse_error(error_buf, original.get());\n+    print_parse_error(error_buf, original_line);\n@@ -840,1 +829,1 @@\n-      print_parse_error(error_buf, original.get());\n+      print_parse_error(error_buf, original_line);\n@@ -857,1 +846,1 @@\n-          print_parse_error(error_buf, original.get());\n+          print_parse_error(error_buf, original_line);\n@@ -866,1 +855,1 @@\n-          print_parse_error(error_buf, original.get());\n+          print_parse_error(error_buf, original_line);\n@@ -874,1 +863,1 @@\n-          print_parse_error(error_buf, original.get());\n+          print_parse_error(error_buf, original_line);\n@@ -893,1 +882,1 @@\n-      print_parse_error(error_buf, original.get());\n+      print_parse_error(error_buf, original_line);\n@@ -904,1 +893,1 @@\n-        print_parse_error(error_buf, original.get());\n+        print_parse_error(error_buf, original_line);\n@@ -910,1 +899,1 @@\n-      print_parse_error(error_buf, original.get());\n+      print_parse_error(error_buf, original_line);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+#include \"utilities\/scopeGuard.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  SATBMarkQueueSet(allocator)\n+  SATBMarkQueueSet(allocator), _g1h(G1CollectedHeap::heap())\n@@ -100,18 +100,0 @@\n-static inline bool discard_entry(const void* entry, G1CollectedHeap* g1h) {\n-  return !requires_marking(entry, g1h) || g1h->is_marked_next(cast_to_oop(entry));\n-}\n-\n-\/\/ Workaround for not yet having std::bind.\n-class G1SATBMarkQueueFilterFn {\n-  G1CollectedHeap* _g1h;\n-\n-public:\n-  G1SATBMarkQueueFilterFn() : _g1h(G1CollectedHeap::heap()) {}\n-\n-  \/\/ Return true if entry should be filtered out (removed), false if\n-  \/\/ it should be retained.\n-  bool operator()(const void* entry) const {\n-    return discard_entry(entry, _g1h);\n-  }\n-};\n-\n@@ -119,1 +101,4 @@\n-  apply_filter(G1SATBMarkQueueFilterFn(), queue);\n+  auto requires_discard = [&] (const void* entry) {\n+    return !requires_marking(entry, _g1h) || _g1h->is_marked_next(cast_to_oop(entry));\n+  };\n+  apply_filter(requires_discard, queue);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":5,"deletions":20,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_SCOPEGUARD_HPP\n+#define SHARE_UTILITIES_SCOPEGUARD_HPP\n+\n+#include <utility>\n+\n+\/\/ The ScopeGuard class is an RAII utility, calling the associated exit\n+\/\/ function when the scope of the guard object ends.  The exit function must\n+\/\/ be copy constructible.\n+\/\/\n+\/\/ See also: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2019\/p0052r10.pdf\n+\/\/ This ScopeGuard class is loosely based on the scope_exit class in that paper.\n+template<typename F>\n+class ScopeGuard {\n+  F _exit_function;\n+  bool _enabled;\n+\n+public:\n+  \/\/ Construct an enabled guard object with the given exit function.\n+  ScopeGuard(F&& exit_function) :\n+    _exit_function(std::forward<F>(exit_function)),\n+    _enabled(true)\n+  {}\n+\n+  \/\/ Call the exit function if the guard is enabled.\n+  ~ScopeGuard() { if (_enabled) _exit_function(); }\n+\n+  \/\/ Construct a guard object with the same exit function and enabled state\n+  \/\/ as the moved from object.  The moved from object is implicitly disabled.\n+  ScopeGuard(ScopeGuard&& from) :\n+    _exit_function(std::move(from._exit_function)),\n+    _enabled(from._enabled)\n+  {\n+    from.release();\n+  }\n+\n+  ScopeGuard(const ScopeGuard&) = delete;\n+  ScopeGuard& operator=(const ScopeGuard&) = delete;\n+  ScopeGuard& operator=(ScopeGuard&&) = delete;\n+\n+  \/\/ Disable invocation of the exit function.\n+  void release() { _enabled = false; }\n+};\n+\n+\/\/ Factory function for a ScopeGuard object with the indicated exit\n+\/\/ function.  Typical usage is\n+\/\/   auto g = make_guard([&] { ... cleanup ... });\n+template<typename F>\n+inline ScopeGuard<F> make_guard(F&& exit_function) {\n+  return ScopeGuard<F>(std::forward<F>(exit_function));\n+}\n+\n+#endif \/\/ SHARE_UTILITIES_SCOPEGUARD_HPP\n","filename":"src\/hotspot\/share\/utilities\/scopeGuard.hpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}