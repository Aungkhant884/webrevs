{"files":[{"patch":"@@ -53,0 +53,1 @@\n+<li><a href=\"#local-function-objects\">Local Function Objects<\/a><\/li>\n@@ -257,2 +258,1 @@\n-<li><p>Generic lambdas. Lambdas are not (yet) permitted.<\/p><\/li>\n-<li><p>Lambda init captures. Lambdas are not (yet) permitted.<\/p><\/li>\n+<li><p>Also see <a href=\"#lambdaexpressions\">lambda expressions<\/a>.<\/p><\/li>\n@@ -291,0 +291,115 @@\n+<h3 id=\"local-function-objects\">Local Function Objects<\/h3>\n+<ul>\n+<li>Local function objects, including lambda expressions, may be used.<\/li>\n+<li>Lambda expressions must only be used as a downward value.<\/li>\n+<li>Prefer <code>[&amp;]<\/code> as the capture list of a lambda expression.<\/li>\n+<li>Return type deduction for lambda expressions is permitted, and indeed encouraged.<\/li>\n+<li>An empty parameter list for a lambda expression may be elided.<\/li>\n+<li>A lambda expression must not be <code>mutable<\/code>.<\/li>\n+<li>Generic lambda expressions are permitted.<\/li>\n+<li>Lambda expressions should be relatively simple.<\/li>\n+<li>Anonymous lambda expressions should not overly clutter the enclosing expression.<\/li>\n+<li>An anonymous lambda expression must not be directly invoked.<\/li>\n+<li>Bind expressions are forbidden.<\/li>\n+<\/ul>\n+<p>Single-use function objects can be defined locally within a function, directly at the point of use. This is an alternative to having a function or function object class defined at class or namespace scope.<\/p>\n+<p>This usage was somewhat limited by C++03, which does not permit such a class to be used as a template parameter. That restriction was removed by C++11 (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm\">n2657<\/a>). Use of this feature is permitted.<\/p>\n+<p>Many HotSpot protocols involve &quot;function-like&quot; objects that involve some named member function rather than a call operator. For example, a function that performs some action on all threads might be written as<\/p>\n+<pre><code>void do_something() {\n+  struct DoSomething : public ThreadClosure {\n+    virtual void do_thread(Thread* t) {\n+      ... do something with t ...\n+    }\n+  } closure;\n+  Threads::threads_do(&amp;closure);\n+}<\/code><\/pre>\n+<p>HotSpot code has historically usually placed the DoSomething class at namespace (or sometimes class) scope. This separates the function's code from its use, often to the detriment of readability. It requires giving the class a globally unique name (if at namespace scope). It also loses the information that the class is intended for use in exactly one place, and does not have any subclasses. (However, the latter can now be indicated by declaring it <code>final<\/code>.) Often, for simplicity, a local class will skip things like access control and accessor functions, giving the enclosing function direct access to the implementation and eliminating some boilerplate that might be provided if the class is in some outer (more accessible) scope. On the other hand, if there is a lot of surrounding code in the function body or the local class is of significant size, defining it locally can increase clutter and reduce readability.<\/p>\n+<p><a name=\"lambdaexpressions\"><\/a> C++11 added <em>lambda expressions<\/em> as a new way to write a function object. Simple lambda expressions can be significantly more concise than a function object, eliminating a lot of boiler-plate. On the other hand, a complex lambda expression may not provide much, if any, readability benefit compared to an ordinary function object. Also, while a lambda can encapsulate a call to a &quot;function-like&quot; object, it cannot be used in place of such.<\/p>\n+<p>A common use for local functions is as one-use <a href=\"https:\/\/en.cppreference.com\/w\/cpp\/language\/raii\" title=\"Resource Acquisition Is Initialization\">RAII<\/a> objects. The amount of boilerplate for a function object class (local or not) makes such usage somewhat clumsy and verbose. But with the help of a small amount of supporting utility code, lambdas work particularly well for this use case.<\/p>\n+<p>Another use for local functions is <a href=\"https:\/\/en.wikipedia.org\/wiki\/Partial_application\" title=\"Partial Application\">partial application<\/a>. Again here, lambdas are typically much simpler and less verbose than function object classes.<\/p>\n+<p>Because of these benefits, lambda expressions are permitted in HotSpot code, with some restrictions and usage guidance. An anonymous lambda is one which is passed directly as an argument. A named lambda is the value of a variable, which is its name.<\/p>\n+<p>Lambda expressions should only be passed downward. In particular, a lambda should not be returned from a function or stored in a global variable, whether directly or as the value of a member of some other object. Lambda capture is syntactically subtle (by design), and propagating a lambda in such ways can easily pass references to captured values to places where they are no longer valid. In particular, members of the enclosing <code>this<\/code> object are effectively captured by reference, even if the default capture is by-value. For such uses-cases a function object class should be used to make the desired value capturing and propagation explicit.<\/p>\n+<p>Limiting the capture list to <code>[&amp;]<\/code> (implicitly capture by reference) is a simplifying restriction that still provides good support for HotSpot usage, while reducing the cases a reader must recognize and understand.<\/p>\n+<ul>\n+<li><p>Many common lambda uses require reference capture. Not permitting it would substantially reduce the utility of lambdas.<\/p><\/li>\n+<li><p>Referential transparency. Implicit reference capture makes variable references in the lambda body have the same meaning they would have in the enclosing code. There isn't a semantic barrier across which the meaning of a variable changes.<\/p><\/li>\n+<li><p>Explicit reference capture introduces significant clutter, especially when lambda expressions are relatively small and simple, as they should be in HotSpot code.<\/p><\/li>\n+<li><p>There are a number of reasons why by-value capture might be used, but for the most part they don't apply to HotSpot code, given other usage restrictions.<\/p>\n+<ul>\n+<li><p>A primary use-case for by-value capture is to support escaping uses, where values captured by-reference might become invalid. That use-case doesn't apply if only downward lambdas are used.<\/p><\/li>\n+<li><p>By-value capture can also make a lambda-local copy for mutation, which requires making the lambda <code>mutable<\/code>; see below.<\/p><\/li>\n+<li><p>By-value capture might be viewed as an optimization, avoiding any overhead for reference capture of cheap to copy values. But the compiler can often eliminate any such overhead.<\/p><\/li>\n+<li><p>By-value capture by a non-<code>mutable<\/code> lambda makes the captured values const, preventing any modification by the lambda and making the captured value unaffected by modifications to the outer variable. But this only applies to captured auto variables, not member variables, and is inconsistent with referential transparency.<\/p><\/li>\n+<\/ul><\/li>\n+<li><p>Non-capturing lambdas (with an empty capture list - <code>[]<\/code>) have limited utility. There are cases where no captures are required (pure functions, for example), but if the function is small and simple then that's obvious anyway.<\/p><\/li>\n+<li><p>Capture initializers (a C++14 feature - <a href=\"https:\/\/isocpp.org\/files\/papers\/N3649.html\">N3649<\/a>) are not permitted. Capture initializers inherently increase the complexity of the capture list, and provide little benefit over an additional in-scope local variable.<\/p><\/li>\n+<\/ul>\n+<p>The use of <code>mutable<\/code> lambda expressions is forbidden because there don't seem to be many, if any, good use-cases for them in HotSpot. A lambda expression needs to be mutable in order to modify a by-value captured value. But with only downward lambdas, such usage seems likely to be rare and complicated. It is better to use a function object class in any such cases that arise, rather than requiring all HotSpot developers to understand this relatively obscure feature.<\/p>\n+<p>While it is possible to directly invoke an anonymous lambda expression, that feature should not be used, as such a form can be confusing to readers. Instead, name the lambda and call it by name.<\/p>\n+<p>Some reasons to prefer a named lambda instead of an anonymous lambda are<\/p>\n+<ul>\n+<li><p>The body contains non-trivial control flow or declarations or other nested constructs.<\/p><\/li>\n+<li><p>Its role in an argument list is hard to guess without examining the function declaration. Give it a name that indicates its purpose.<\/p><\/li>\n+<li><p>It has an unusual capture list.<\/p><\/li>\n+<li><p>It has a complex explicit return type or parameter types.<\/p><\/li>\n+<\/ul>\n+<p>Lambda expressions, and particularly anonymous lambda expressions, should be simple and compact. One-liners are good. Anonymous lambdas should usually be limited to a couple lines of body code. More complex lambdas should be named. A named lambda should not clutter the enclosing function and make it long and complex; do continue to break up large functions via the use of separate helper functions.<\/p>\n+<p>An anonymous lambda expression should either be a one-liner in a one-line expression, or isolated in its own set of lines. Don't place part of a lambda expression on the same line as other arguments to a function. The body of a multi-line lambda argument should be indented from the start of the capture list, as if that were the start of an ordinary function definition. The body of a multi-line named lambda should be indented one step from the variable's indentation.<\/p>\n+<p>Some examples:<\/p>\n+<ol type=\"1\">\n+<li><code>foo([&amp;] { ++counter; });<\/code><\/li>\n+<li><code>foo(x, [&amp;] { ++counter; });<\/code><\/li>\n+<li><code>foo([&amp;] { if (predicate) ++counter; });<\/code><\/li>\n+<li><code>foo([&amp;] { auto tmp = process(x); tmp.f(); return tmp.g(); })<\/code><\/li>\n+<li><p>Separate one-line lambda from other arguments:<\/p>\n+<pre><code>foo(c.begin(), c.end(),\n+    [&amp;] (const X&amp; x) { do_something(x); return x.value(); });<\/code><\/pre><\/li>\n+<li><p>Indentation for multi-line lambda:<\/p>\n+<pre><code>c.do_entries([&amp;] (const X&amp; x) {\n+               do_something(x, a);\n+               do_something1(x, b);\n+               do_something2(x, c);\n+             });<\/code><\/pre><\/li>\n+<li><p>Separate multi-line lambda from other arguments:<\/p>\n+<pre><code>foo(c.begin(), c.end(),\n+    [&amp;] (const X&amp; x) {\n+      do_something(x, a);\n+      do_something1(x, b);\n+      do_something2(x, c);\n+    });<\/code><\/pre><\/li>\n+<li><p>Multi-line named lambda:<\/p>\n+<pre><code>auto do_entry = [&amp;] (const X&amp; x) {\n+  do_something(x, a);\n+  do_something1(x, b);\n+  do_something2(x, c);\n+};<\/code><\/pre><\/li>\n+<\/ol>\n+<p>Item 4, and especially items 6 and 7, are pushing the simplicity limits for anonymous lambdas. Item 6 might be better written using a named lambda:<\/p>\n+<pre><code>c.do_entries(do_entry);<\/code><\/pre>\n+<p>Note that C++11 also added <em>bind expressions<\/em> as a way to write a function object for partial application, using <code>std::bind<\/code> and related facilities from the Standard Library. <code>std::bind<\/code> generalizes and replaces some of the binders from C++03. Bind expressions are not permitted in HotSpot code. They don't provide enough benefit over lambdas or local function classes in the cases where bind expressions are applicable to warrant the introduction of yet another mechanism in this space into HotSpot code.<\/p>\n+<p>References:<\/p>\n+<ul>\n+<li>Local and unnamed types as template parameters (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm\">n2657<\/a>)<\/li>\n+<li>New wording for C++0x lambdas (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2009\/n2927.pdf\">n2927<\/a>)<\/li>\n+<li>Generalized lambda capture (init-capture) (<a href=\"https:\/\/isocpp.org\/files\/papers\/N3648.html\">N3648<\/a>)<\/li>\n+<li>Generic (polymorphic) lambda expressions (<a href=\"https:\/\/isocpp.org\/files\/papers\/N3649.html\">N3649<\/a>)<\/li>\n+<\/ul>\n+<p>References from C++17<\/p>\n+<ul>\n+<li>Wording for constexpr lambda (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2016\/p0170r1.pdf\">p0170r1<\/a>)<\/li>\n+<li>Lambda capture of *this by Value (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2016\/p0018r3.html\">p0018r3<\/a>)<\/li>\n+<\/ul>\n+<p>References from C++20<\/p>\n+<ul>\n+<li>Allow lambda capture [=, this] (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0409r2.html\">p0409r2<\/a>)<\/li>\n+<li>Familiar template syntax for generic lambdas (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0428r2.pdf\">p0428r2<\/a>)<\/li>\n+<li>Simplifying implicit lambda capture (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0588r1.html\">p0588r1<\/a>)<\/li>\n+<li>Default constructible and assignable stateless lambdas (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0624r2.pdf\">p0624r2<\/a>)<\/li>\n+<li>Lambdas in unevaluated contexts (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2017\/p0315r4.pdf\">p0315r4<\/a>)<\/li>\n+<li>Allow pack expansion in lambda init-capture (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0780r2.html\">p0780r2<\/a>) (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2020\/p2095r0.html\">p2095r0<\/a>)<\/li>\n+<li>Deprecate implicit capture of this via [=] (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0806r2.html\">p0806r2<\/a>)<\/li>\n+<\/ul>\n+<p>References from C++23<\/p>\n+<ul>\n+<li>Make () more optional for lambdas (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2020\/p1102r2.html\">p1102r2<\/a>)<\/li>\n+<\/ul>\n@@ -308,1 +423,0 @@\n-<li><p>Local and unnamed types as template parameters (<a href=\"http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2008\/n2657.htm\">n2657<\/a>)<\/p><\/li>\n@@ -340,1 +454,0 @@\n-<li><p>Lambdas<\/p><\/li>\n","filename":"doc\/hotspot-style.html","additions":117,"deletions":4,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"utilities\/scopeGuard.hpp\"\n@@ -782,0 +781,14 @@\n+class LineCopy : StackObj {\n+  const char* _copy;\n+public:\n+    LineCopy(char* line) {\n+      _copy = os::strdup(line, mtInternal);\n+    }\n+    ~LineCopy() {\n+      os::free((void*)_copy);\n+    }\n+    char* get() {\n+      return (char*)_copy;\n+    }\n+};\n+\n@@ -786,3 +799,1 @@\n-  char* original_line = os::strdup(line, mtInternal);\n-  auto g = make_guard([&] { os::free(original_line); });\n-\n+  LineCopy original(line);\n@@ -797,1 +808,1 @@\n-    print_parse_error(error_buf, original_line);\n+    print_parse_error(error_buf, original.get());\n@@ -829,1 +840,1 @@\n-      print_parse_error(error_buf, original_line);\n+      print_parse_error(error_buf, original.get());\n@@ -846,1 +857,1 @@\n-          print_parse_error(error_buf, original_line);\n+          print_parse_error(error_buf, original.get());\n@@ -855,1 +866,1 @@\n-          print_parse_error(error_buf, original_line);\n+          print_parse_error(error_buf, original.get());\n@@ -863,1 +874,1 @@\n-          print_parse_error(error_buf, original_line);\n+          print_parse_error(error_buf, original.get());\n@@ -882,1 +893,1 @@\n-      print_parse_error(error_buf, original_line);\n+      print_parse_error(error_buf, original.get());\n@@ -893,1 +904,1 @@\n-        print_parse_error(error_buf, original_line);\n+        print_parse_error(error_buf, original.get());\n@@ -899,1 +910,1 @@\n-      print_parse_error(error_buf, original_line);\n+      print_parse_error(error_buf, original.get());\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -118,1 +118,0 @@\n-#include \"utilities\/scopeGuard.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  SATBMarkQueueSet(allocator), _g1h(G1CollectedHeap::heap())\n+  SATBMarkQueueSet(allocator)\n@@ -100,0 +100,18 @@\n+static inline bool discard_entry(const void* entry, G1CollectedHeap* g1h) {\n+  return !requires_marking(entry, g1h) || g1h->is_marked_next(cast_to_oop(entry));\n+}\n+\n+\/\/ Workaround for not yet having std::bind.\n+class G1SATBMarkQueueFilterFn {\n+  G1CollectedHeap* _g1h;\n+\n+public:\n+  G1SATBMarkQueueFilterFn() : _g1h(G1CollectedHeap::heap()) {}\n+\n+  \/\/ Return true if entry should be filtered out (removed), false if\n+  \/\/ it should be retained.\n+  bool operator()(const void* entry) const {\n+    return discard_entry(entry, _g1h);\n+  }\n+};\n+\n@@ -101,4 +119,1 @@\n-  auto requires_discard = [&] (const void* entry) {\n-    return !requires_marking(entry, _g1h) || _g1h->is_marked_next(cast_to_oop(entry));\n-  };\n-  apply_filter(requires_discard, queue);\n+  apply_filter(G1SATBMarkQueueFilterFn(), queue);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_UTILITIES_SCOPEGUARD_HPP\n-#define SHARE_UTILITIES_SCOPEGUARD_HPP\n-\n-#include <utility>\n-\n-\/\/ The ScopeGuard class is an RAII utility, calling the associated exit\n-\/\/ function when the scope of the guard object ends.  The exit function must\n-\/\/ be copy constructible.\n-\/\/\n-\/\/ See also: http:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2019\/p0052r10.pdf\n-\/\/ This ScopeGuard class is loosely based on the scope_exit class in that paper.\n-template<typename F>\n-class ScopeGuard {\n-  F _exit_function;\n-  bool _enabled;\n-\n-public:\n-  \/\/ Construct an enabled guard object with the given exit function.\n-  ScopeGuard(F&& exit_function) :\n-    _exit_function(std::forward<F>(exit_function)),\n-    _enabled(true)\n-  {}\n-\n-  \/\/ Call the exit function if the guard is enabled.\n-  ~ScopeGuard() { if (_enabled) _exit_function(); }\n-\n-  \/\/ Construct a guard object with the same exit function and enabled state\n-  \/\/ as the moved from object.  The moved from object is implicitly disabled.\n-  ScopeGuard(ScopeGuard&& from) :\n-    _exit_function(std::move(from._exit_function)),\n-    _enabled(from._enabled)\n-  {\n-    from.release();\n-  }\n-\n-  ScopeGuard(const ScopeGuard&) = delete;\n-  ScopeGuard& operator=(const ScopeGuard&) = delete;\n-  ScopeGuard& operator=(ScopeGuard&&) = delete;\n-\n-  \/\/ Disable invocation of the exit function.\n-  void release() { _enabled = false; }\n-};\n-\n-\/\/ Factory function for a ScopeGuard object with the indicated exit\n-\/\/ function.  Typical usage is\n-\/\/   auto g = make_guard([&] { ... cleanup ... });\n-template<typename F>\n-inline ScopeGuard<F> make_guard(F&& exit_function) {\n-  return ScopeGuard<F>(std::forward<F>(exit_function));\n-}\n-\n-#endif \/\/ SHARE_UTILITIES_SCOPEGUARD_HPP\n","filename":"src\/hotspot\/share\/utilities\/scopeGuard.hpp","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"}]}