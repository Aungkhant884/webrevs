{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,7 +147,7 @@\n-  SATBMarkQueue& queue = G1ThreadLocalData::satb_mark_queue(thread);\n-  assert(!queue.is_active(), \"SATB queue should not be active\");\n-  assert(queue.buffer() == nullptr, \"SATB queue should not have a buffer\");\n-  assert(queue.index() == 0, \"SATB queue index should be zero\");\n-  \/\/ Can't assert that the DCQ is empty.  There is early execution on\n-  \/\/ the main thread, before it gets added to the threads list, which\n-  \/\/ is where this is called.  That execution may enqueue dirty cards.\n+  SATBMarkQueue& satbq = G1ThreadLocalData::satb_mark_queue(thread);\n+  assert(!satbq.is_active(), \"SATB queue should not be active\");\n+  assert(satbq.buffer() == nullptr, \"SATB queue should not have a buffer\");\n+  assert(satbq.index() == 0, \"SATB queue index should be zero\");\n+  G1DirtyCardQueue& dirtyq = G1ThreadLocalData::dirty_card_queue(thread);\n+  assert(dirtyq.buffer() == nullptr, \"Dirty Card queue should not have a buffer\");\n+  assert(dirtyq.index() == 0, \"Dirty Card queue index should be zero\");\n@@ -158,1 +158,1 @@\n-  queue.set_active(_satb_mark_queue_set.is_active());\n+  satbq.set_active(_satb_mark_queue_set.is_active());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BarrierSet.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  G1BarrierSet::dirty_card_queue_set().flush_queue(*this);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1DirtyCardQueue.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -146,0 +146,4 @@\n+  return JNI_OK;\n+}\n+\n+jint init_globals2() {\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+jint init_globals2();    \/\/ construction of early Java objects (main Java thread)\n","filename":"src\/hotspot\/share\/runtime\/init.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -556,0 +556,16 @@\n+  \/\/ Add main_thread to threads list to finish barrier setup with\n+  \/\/ on_thread_attach.  Should be before starting to build Java objects in\n+  \/\/ init_globals2, which invokes barriers.\n+  {\n+    MutexLocker mu(Threads_lock);\n+    Threads::add(main_thread);\n+  }\n+\n+  status = init_globals2();\n+  if (status != JNI_OK) {\n+    Threads::remove(main_thread, false);\n+    main_thread->smr_delete();\n+    *canTryAgain = false; \/\/ don't let caller call JNI_CreateJavaVM again\n+    return status;\n+  }\n+\n@@ -561,4 +577,0 @@\n-  { MutexLocker mu(Threads_lock);\n-    Threads::add(main_thread);\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"}]}