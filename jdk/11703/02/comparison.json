{"files":[{"patch":"@@ -877,1 +877,1 @@\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c\n+  BUILD_HOTSPOT_JTREG_EXCLUDE += exesigtest.c libterminatedThread.c libTestJNI.c libCompleteExit.c libTestPsig.c libnativeStack.c\n@@ -1518,0 +1518,1 @@\n+  BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libnativeStack += -lpthread\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -1677,2 +1678,2 @@\n-\/\/ This is the external format from above, but selecting the platform\n-\/\/ or vthread as applicable.\n+\/\/ This is the external format, selecting the platform or vthread\n+\/\/ as applicable, and allowing for a native-only stack.\n@@ -1680,2 +1681,11 @@\n-  if (is_vthread_mounted()) {\n-    print_vthread_stack_on(tty);\n+  if (!has_last_Java_frame()) {\n+    assert(this == JavaThread::current(), \"Can't print native stack of other threads\");\n+    ResourceMark rm(this);\n+    char* buf = NEW_RESOURCE_ARRAY_RETURN_NULL(char, O_BUFLEN);\n+    if (buf == nullptr) {\n+      tty->print_cr(\"Unable to print native stack - out of memory\");\n+      return;\n+    }\n+    frame f = os::current_frame();\n+    VMError::print_native_stack(tty, f, this, true \/*print_source_info *\/,\n+                                -1 \/* max stack *\/, buf, O_BUFLEN);\n@@ -1683,1 +1693,1 @@\n-    print_stack_on(tty);\n+    print_active_stack_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -106,9 +106,0 @@\n-  \/\/ public for use by the internal non-product debugger.\n-  NOT_PRODUCT(public:)\n-  \/\/ print_source_info: if true, we try to resolve the source information on platforms that support it\n-  \/\/  (useful but may slow down, timeout or misfunction in error situations)\n-  \/\/ max_frames: if not -1, overrides StackPrintLimit\n-  static void print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info,\n-                                 int max_frames, char* buf, int buf_size);\n-  NOT_PRODUCT(private:)\n-\n@@ -150,0 +141,6 @@\n+  \/\/ print_source_info: if true, we try to resolve the source information on platforms that support it\n+  \/\/  (useful but may slow down, timeout or misfunction in error situations)\n+  \/\/ max_frames: if not -1, overrides StackPrintLimit\n+  static void print_native_stack(outputStream* st, frame fr, Thread* t, bool print_source_info,\n+                                 int max_frames, char* buf, int buf_size);\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug  8295974\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @summary Generate a JNI Fatal error, or a warning, in a launched VM and check\n+ *          the native stack is present as expected.\n+ * @comment The native code only supports POSIX so no windows testing\n+ * @run driver TestNativeStack\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestNativeStack {\n+\n+    \/**\n+     * Create a native thread that will execute native code that\n+     * will either trigger a JNI warning (with -Xcheck:jni) or a JNI\n+     * error, depending on the value of `warning`.\n+     *\/\n+    static native void triggerJNIStackTrace(boolean warning);\n+\n+    static {\n+        System.loadLibrary(\"nativeStack\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        \/\/ case 1: Trigger a JNI warning with Xcheck:jni\n+        OutputAnalyzer oa =\n+            ProcessTools.executeTestJvm(\"-Xcheck:jni\",\n+                                        \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                        \"TestNativeStack$Main\");\n+        oa.shouldHaveExitValue(0);\n+        oa.shouldContain(\"WARNING in native method\");\n+        oa.shouldContain(\"thread_start\");\n+        oa.reportDiagnosticSummary();\n+\n+        \/\/ Case 2: Trigger a JNI FatalError call\n+        oa = ProcessTools.executeTestJvm(\"-XX:-CreateCoredumpOnCrash\",\n+                                         \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                         \"TestNativeStack$Main\",\n+                                         \"error\");\n+        oa.shouldNotHaveExitValue(0);\n+        oa.shouldContain(\"FATAL ERROR in native method\");\n+        oa.shouldContain(\"thread_start\");\n+        oa.reportDiagnosticSummary();\n+    }\n+\n+    static class Main {\n+        public static void main(String[] args) throws Throwable {\n+            boolean doWarning = args.length == 0;\n+            System.out.println(\"Triggering a JNI \" +\n+                               (doWarning ? \"warning\" : \"fatal error\"));\n+            triggerJNIStackTrace(doWarning);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/nativeStack\/TestNativeStack.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+\n+#include <pthread.h>\n+#include <string.h>\n+\n+#include \"jni.h\"\n+\n+JavaVM* jvm;\n+jboolean warning = 0;\n+\n+void generateWarning(JNIEnv *env) {\n+  jclass class_id;\n+  jmethodID method_id;\n+\n+  printf(\"About to trigger JNI Warning\\n\");\n+\n+  \/\/ Just call Thread.currentThread() twice in succession without checking\n+  \/\/ for an exception in between.\n+\n+  class_id = (*env)->FindClass (env, \"java\/lang\/Thread\");\n+  if (class_id == NULL) {\n+    fprintf(stderr, \"Test ERROR. Can't load class Thread\\n\");\n+    exit(1);\n+  }\n+\n+  method_id = (*env)->GetStaticMethodID(env, class_id, \"currentThread\",\n+                                        \"()Ljava\/lang\/Thread;\");\n+  if (method_id == NULL) {\n+    fprintf(stderr, \"Test ERROR. Can't find method currentThread\\n\");\n+    exit(1);\n+  }\n+\n+  jobject nativeThread = (*env)->CallStaticObjectMethod(env, class_id, method_id, NULL);\n+  nativeThread = (*env)->CallStaticObjectMethod(env, class_id, method_id, NULL);\n+}\n+\n+void generateError(JNIEnv *env) {\n+  printf(\"About to trigger JNI FatalError\\n\");\n+  (*env)->FatalError(env, \"Fatal error generated in test code\");\n+}\n+\n+static void * thread_start(void* unused) {\n+  JNIEnv *env;\n+  int res;\n+\n+  printf(\"Native thread is running and attaching as daemon ...\\n\");\n+\n+  res = (*jvm)->AttachCurrentThreadAsDaemon(jvm, (void **)&env, NULL);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't attach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  if (warning != 0) {\n+    generateWarning(env);\n+  } else {\n+    generateError(env);\n+  }\n+\n+  if ((*env)->ExceptionOccurred(env) != NULL) {\n+    (*env)->ExceptionDescribe(env);\n+    exit(1);\n+  }\n+  printf(\"Native thread terminating\\n\");\n+\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_TestNativeStack_triggerJNIStackTrace\n+(JNIEnv *env, jclass cls, jboolean warn) {\n+  pthread_t thread;\n+  int res = (*env)->GetJavaVM(env, &jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't extract JavaVM: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  warning = warn;\n+\n+  if ((res = pthread_create(&thread, NULL, thread_start, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_create failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_join(thread, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_join failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/nativeStack\/libnativeStack.c","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"}]}