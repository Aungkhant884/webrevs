{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -67,8 +68,2 @@\n- * <p> All methods in this class accept {@code null} values for keys and values.\n- * However, {@code null} keys will never will be present in HTTP request\n- * headers, and will not be output\/sent in response headers. Null values can be\n- * represented as either a {@code null} entry for the key (i.e. the list is\n- * {@code null}) or where the key has a list, but one (or more) of the list's\n- * values is {@code null}. Null values are output as a header line containing\n- * the key but no associated value.\n- *\n+ * <p> All methods in this class reject {@code null} values for keys and values.\n+ * {@code null} keys will never be present in HTTP request or response headers.\n@@ -92,3 +87,1 @@\n-        if (key == null) {\n-            return null;\n-        }\n+        Objects.requireNonNull(key);\n@@ -114,0 +107,1 @@\n+    @Override\n@@ -116,0 +110,1 @@\n+    @Override\n@@ -118,0 +113,1 @@\n+    @Override\n@@ -119,7 +115,2 @@\n-        if (key == null) {\n-            return false;\n-        }\n-        if (!(key instanceof String)) {\n-            return false;\n-        }\n-        return map.containsKey(normalize((String)key));\n+        Objects.requireNonNull(key);\n+        return key instanceof String k && map.containsKey(normalize(k));\n@@ -128,0 +119,1 @@\n+    @Override\n@@ -129,0 +121,1 @@\n+        Objects.requireNonNull(value);\n@@ -132,0 +125,1 @@\n+    @Override\n@@ -137,2 +131,3 @@\n-     * Returns the first value from the {@link List} of {@code String}\n-     * values for the given key (if at least one exists).\n+     * Returns the first value from the {@link List} of {@code String} values\n+     * for the given {@code key}, or {@code null} if no mapping for the\n+     * {@code key} exists.\n@@ -141,1 +136,3 @@\n-     * @return the first {@code String} value associated with the key\n+     * @return    the first {@code String} value associated with the key,\n+     *            or {@code null} is no mapping for the key exists\n+     * @throws NullPointerException if key is null\n@@ -145,1 +142,1 @@\n-        if (l == null) {\n+        if (l == null) {  \/\/ no mapping exists\n@@ -151,0 +148,1 @@\n+    @Override\n@@ -158,2 +156,2 @@\n-     * Adds the given value to the list of headers for the given key. If\n-     * the mapping does not already exist, then it is created.\n+     * Adds the given {@code value} to the list of headers for the given\n+     * {@code key}. If the mapping does not already exist, then it is created.\n@@ -161,1 +159,1 @@\n-     * @param key the header name\n+     * @param key   the header name\n@@ -163,0 +161,1 @@\n+     * @throws NullPointerException if key or value are null\n@@ -200,2 +199,2 @@\n-     * Sets the given value as the sole header value for the given\n-     * key. If the mapping does not already exist, then it is created.\n+     * Sets the given {@code value} as the sole header value for the given\n+     * {@code key}. If the mapping does not already exist, then it is created.\n@@ -203,1 +202,1 @@\n-     * @param key the header name\n+     * @param key   the header name\n@@ -205,0 +204,1 @@\n+     * @throws NullPointerException if key or value are null\n@@ -212,0 +212,1 @@\n+    @Override\n@@ -216,0 +217,1 @@\n+    @Override\n@@ -220,0 +222,1 @@\n+    @Override\n@@ -222,0 +225,1 @@\n+    @Override\n@@ -224,0 +228,1 @@\n+    @Override\n@@ -226,0 +231,1 @@\n+    @Override\n@@ -230,0 +236,1 @@\n+    @Override\n@@ -232,0 +239,1 @@\n+            Objects.requireNonNull(values);\n@@ -238,0 +246,1 @@\n+    @Override\n@@ -242,0 +251,1 @@\n+    @Override\n@@ -244,0 +254,1 @@\n+    @Override\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":39,"deletions":28,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -28,1 +28,4 @@\n- * @run testng HeadersTest\n+ * @modules jdk.httpserver\/sun.net.httpserver:+open\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n+ * @run testng\/othervm HeadersTest\n@@ -31,0 +34,10 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n@@ -33,0 +46,1 @@\n+import java.util.LinkedList;\n@@ -36,0 +50,4 @@\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n@@ -39,0 +57,1 @@\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n@@ -46,1 +65,0 @@\n-    static final Class<NullPointerException> NPE = NullPointerException.class;\n@@ -48,0 +66,2 @@\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n@@ -56,5 +76,3 @@\n-    public static void testPutAll() {\n-        final var h0 = new Headers();\n-        final var map = new HashMap<String, List<String>>();\n-        map.put(\"a\", null);\n-        assertThrows(NPE, () -> h0.putAll(map));\n+    public static void testNull() {\n+        final Headers h = new Headers();\n+        h.put(\"Foo\", List.of(\"Bar\"));\n@@ -62,4 +80,2 @@\n-        final var list = new ArrayList<String>();\n-        list.add(null);\n-        assertThrows(NPE, () -> h0.putAll(Map.of(\"a\", list)));\n-        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\n\"))));\n+        final var mapNullKey = new HashMap<String, List<String>>();\n+        mapNullKey.put(null, List.of(\"Bar\"));\n@@ -67,6 +83,65 @@\n-        final var h1 = new Headers();\n-        h1.put(\"a\", List.of(\"1\"));\n-        h1.put(\"b\", List.of(\"2\"));\n-        final var h2 = new Headers();\n-        h2.putAll(Map.of(\"a\", List.of(\"1\"), \"b\", List.of(\"2\")));\n-        assertEquals(h1, h2);\n+        final var mapNullList = new HashMap<String, List<String>>();\n+        mapNullList.put(\"Foo\", null);\n+\n+        final var listWithNull = new LinkedList<String>();\n+        listWithNull.add(null);\n+\n+        final var mapNullInList = new HashMap<String, List<String>>();\n+        mapNullInList.put(\"Foo\", listWithNull);\n+\n+        assertThrows(NPE, () -> h.add(null, \"Bar\"));\n+        assertThrows(NPE, () -> h.add(\"Foo\", null));\n+\n+        assertThrows(NPE, () -> h.compute(null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.compute(\"Foo\", (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.computeIfAbsent(null, (k) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.computeIfAbsent(\"Foo-foo\", (k) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.computeIfPresent(null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.computeIfPresent(\"Foo\", (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.containsKey(null));\n+\n+        assertThrows(NPE, () -> h.containsValue(null));\n+\n+        assertThrows(NPE, () -> h.get(null));\n+\n+        assertThrows(NPE, () -> h.getFirst(null));\n+\n+        assertThrows(NPE, () -> h.getOrDefault(null, List.of(\"Bar\")));\n+\n+        assertThrows(NPE, () -> h.merge(null, List.of(\"Bar\"), (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo-foo\", null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo-foo\", listWithNull, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo\", List.of(\"Bar\"), (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.put(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.put(\"Foo\", null));\n+        assertThrows(NPE, () -> h.put(\"Foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.putAll(mapNullKey));\n+        assertThrows(NPE, () -> h.putAll(mapNullList));\n+        assertThrows(NPE, () -> h.putAll(mapNullInList));\n+\n+        assertThrows(NPE, () -> h.putIfAbsent(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.putIfAbsent(\"Foo-foo\", null));\n+        assertThrows(NPE, () -> h.putIfAbsent(\"Foo-foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.remove(null));\n+\n+        assertThrows(NPE, () -> h.remove(null, List.of(\"Bar\")));\n+\n+        assertThrows(NPE, () -> h.replace(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", null));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.replace(null, List.of(\"Bar\"), List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", List.of(\"Bar\"), null));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", List.of(\"Bar\"), listWithNull));\n+\n+        assertThrows(NPE, () -> h.replaceAll((k, v) -> listWithNull));\n+        assertThrows(NPE, () -> h.replaceAll((k, v) -> null));\n+\n+        assertThrows(NPE, () -> h.set(null, \"Bar\"));\n+        assertThrows(NPE, () -> h.set(\"Foo\", null));\n@@ -75,9 +150,7 @@\n-    @Test\n-    public static void testReplaceAll() {\n-        final var h1 = new Headers();\n-        h1.put(\"a\", List.of(\"1\"));\n-        h1.put(\"b\", List.of(\"2\"));\n-        final var list = new ArrayList<String>();\n-        list.add(null);\n-        assertThrows(NPE, () -> h1.replaceAll((k, v) -> list));\n-        assertThrows(IAE, () -> h1.replaceAll((k, v) -> List.of(\"\\n\")));\n+    @DataProvider\n+    public Object[][] respHeadersWithNull() {\n+        return new Object[][] {\n+                {\"Foo\", null},\n+                {null, \"Bar\"}\n+        };\n+    }\n@@ -85,8 +158,48 @@\n-        h1.replaceAll((k, v) -> {\n-            String s = h1.get(k).get(0);\n-            return List.of(s+s);\n-        });\n-        final var h2 = new Headers();\n-        h2.put(\"a\", List.of(\"11\"));\n-        h2.put(\"b\", List.of(\"22\"));\n-        assertEquals(h1, h2);\n+    \/**\n+     * Confirms exchange fails if response headers contain a null key or value.\n+     *\/\n+    @Test(dataProvider = \"respHeadersWithNull\")\n+    public void testNullResponseHeaders(String headerKey, String headerVal)\n+            throws Exception {\n+        var handler = new Handler(headerKey, headerVal);\n+        var server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            assertThrows(IOE, () -> client.send(request, HttpResponse.BodyHandlers.ofString()));\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private class Handler implements HttpHandler {\n+        private String headerKey;\n+        private String headerVal;\n+\n+        public Handler(String key, String val) {\n+            headerKey = key;\n+            headerVal = val;\n+        }\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                exchange.getResponseHeaders().set(headerKey, headerVal);\n+                exchange.sendResponseHeaders(200, resp.length);\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    private static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n@@ -109,1 +222,1 @@\n-        return headers.stream()\n+        return headers.stream()  \/\/ cartesian product of headers\n@@ -116,1 +229,1 @@\n-        \/\/ testng's asserts(Map, Map) do not call Headers.equals\n+        \/\/ avoid testng's asserts(Map, Map) as they don't call Headers::equals\n@@ -127,0 +240,1 @@\n+        assertFalse(h.equals(null), \"null cannot be equal to Headers\");\n@@ -137,0 +251,40 @@\n+\n+    @Test\n+    public static void testPutAll() {\n+        final var h0 = new Headers();\n+        final var map = new HashMap<String, List<String>>();\n+        map.put(\"a\", null);\n+        assertThrows(NPE, () -> h0.putAll(map));\n+\n+        final var list = new ArrayList<String>();\n+        list.add(null);\n+        assertThrows(NPE, () -> h0.putAll(Map.of(\"a\", list)));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\n\"))));\n+\n+        final var h1 = new Headers();\n+        h1.put(\"a\", List.of(\"1\"));\n+        h1.put(\"b\", List.of(\"2\"));\n+        final var h2 = new Headers();\n+        h2.putAll(Map.of(\"a\", List.of(\"1\"), \"b\", List.of(\"2\")));\n+        assertTrue(h1.equals(h2));\n+    }\n+\n+    @Test\n+    public static void testReplaceAll() {\n+        final var h1 = new Headers();\n+        h1.put(\"a\", List.of(\"1\"));\n+        h1.put(\"b\", List.of(\"2\"));\n+        final var list = new ArrayList<String>();\n+        list.add(null);\n+        assertThrows(NPE, () -> h1.replaceAll((k, v) -> list));\n+        assertThrows(IAE, () -> h1.replaceAll((k, v) -> List.of(\"\\n\")));\n+\n+        h1.replaceAll((k, v) -> {\n+            String s = h1.get(k).get(0);\n+            return List.of(s+s);\n+        });\n+        final var h2 = new Headers();\n+        h2.put(\"a\", List.of(\"11\"));\n+        h2.put(\"b\", List.of(\"22\"));\n+        assertTrue(h1.equals(h2));\n+    }\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":190,"deletions":36,"binary":false,"changes":226,"status":"modified"}]}