{"files":[{"patch":"@@ -33,0 +33,1 @@\n+import java.util.Objects;\n@@ -34,0 +35,1 @@\n+import java.util.function.BiFunction;\n@@ -66,8 +68,2 @@\n- * <p> All methods in this class accept {@code null} values for keys and values.\n- * However, {@code null} keys will never will be present in HTTP request\n- * headers, and will not be output\/sent in response headers. Null values can be\n- * represented as either a {@code null} entry for the key (i.e. the list is\n- * {@code null}) or where the key has a list, but one (or more) of the list's\n- * values is {@code null}. Null values are output as a header line containing\n- * the key but no associated value.\n- *\n+ * <p> All methods in this class reject {@code null} values for keys and values.\n+ * {@code null} keys will never be present in HTTP request or response headers.\n@@ -91,3 +87,1 @@\n-        if (key == null) {\n-            return null;\n-        }\n+        Objects.requireNonNull(key);\n@@ -113,0 +107,1 @@\n+    @Override\n@@ -115,0 +110,1 @@\n+    @Override\n@@ -117,0 +113,1 @@\n+    @Override\n@@ -118,7 +115,2 @@\n-        if (key == null) {\n-            return false;\n-        }\n-        if (!(key instanceof String)) {\n-            return false;\n-        }\n-        return map.containsKey(normalize((String)key));\n+        Objects.requireNonNull(key);\n+        return key instanceof String k && map.containsKey(normalize(k));\n@@ -127,0 +119,1 @@\n+    @Override\n@@ -128,0 +121,1 @@\n+        Objects.requireNonNull(value);\n@@ -131,0 +125,1 @@\n+    @Override\n@@ -136,2 +131,3 @@\n-     * Returns the first value from the {@link List} of {@code String}\n-     * values for the given key (if at least one exists).\n+     * Returns the first value from the {@link List} of {@code String} values\n+     * for the given {@code key}, or {@code null} if no mapping for the\n+     * {@code key} exists.\n@@ -140,1 +136,2 @@\n-     * @return the first {@code String} value associated with the key\n+     * @return    the first {@code String} value associated with the key,\n+     *            or {@code null} if no mapping for the key exists\n@@ -144,1 +141,1 @@\n-        if (l == null) {\n+        if (l == null || l.size() == 0) {  \/\/ no mapping exists\n@@ -150,0 +147,1 @@\n+    @Override\n@@ -157,2 +155,2 @@\n-     * Adds the given value to the list of headers for the given key. If\n-     * the mapping does not already exist, then it is created.\n+     * Adds the given {@code value} to the list of headers for the given\n+     * {@code key}. If the mapping does not already exist, then it is created.\n@@ -160,1 +158,1 @@\n-     * @param key the header name\n+     * @param key   the header name\n@@ -199,2 +197,2 @@\n-     * Sets the given value as the sole header value for the given\n-     * key. If the mapping does not already exist, then it is created.\n+     * Sets the given {@code value} as the sole header value for the given\n+     * {@code key}. If the mapping does not already exist, then it is created.\n@@ -202,1 +200,1 @@\n-     * @param key the header name\n+     * @param key   the header name\n@@ -211,0 +209,1 @@\n+    @Override\n@@ -215,0 +214,1 @@\n+    @Override\n@@ -216,1 +216,1 @@\n-        map.putAll(t);\n+        t.forEach(this::put);\n@@ -219,0 +219,1 @@\n+    @Override\n@@ -221,0 +222,1 @@\n+    @Override\n@@ -223,0 +225,1 @@\n+    @Override\n@@ -225,0 +228,1 @@\n+    @Override\n@@ -229,1 +233,12 @@\n-    public boolean equals(Object o) {return map.equals(o);}\n+    @Override\n+    public void replaceAll(BiFunction<? super String, ? super List<String>, ? extends List<String>> function) {\n+        var f = function.andThen(values -> {\n+            Objects.requireNonNull(values);\n+            values.forEach(Headers::checkValue);\n+            return values;\n+        });\n+        Map.super.replaceAll(f);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) { return map.equals(o); }\n@@ -231,0 +246,1 @@\n+    @Override\n@@ -232,0 +248,9 @@\n+\n+    @Override\n+    public String toString() {\n+        final var sb = new StringBuilder(Headers.class.getSimpleName());\n+        sb.append(\" { \");\n+        sb.append(map.toString());\n+        sb.append(\" }\");\n+        return sb.toString();\n+    }\n","filename":"src\/jdk.httpserver\/share\/classes\/com\/sun\/net\/httpserver\/Headers.java","additions":55,"deletions":30,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8251496\n+ * @bug 8251496 8268960\n@@ -28,0 +28,3 @@\n+ * @modules jdk.httpserver\/com.sun.net.httpserver:+open\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.net.URIBuilder\n@@ -31,0 +34,17 @@\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CompletableFuture;\n@@ -32,0 +52,5 @@\n+import com.sun.net.httpserver.HttpExchange;\n+import com.sun.net.httpserver.HttpHandler;\n+import com.sun.net.httpserver.HttpServer;\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.annotations.DataProvider;\n@@ -34,0 +59,4 @@\n+import static java.net.http.HttpClient.Builder.NO_PROXY;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertThrows;\n@@ -38,0 +67,4 @@\n+    static final Class<IllegalArgumentException> IAE = IllegalArgumentException.class;\n+    static final Class<IOException> IOE = IOException.class;\n+    static final Class<NullPointerException> NPE = NullPointerException.class;\n+\n@@ -39,1 +72,1 @@\n-    public void TestDefaultConstructor() {\n+    public static void testDefaultConstructor() {\n@@ -43,0 +76,241 @@\n+\n+    @Test\n+    public static void testNull() {\n+        final Headers h = new Headers();\n+        h.put(\"Foo\", List.of(\"Bar\"));\n+\n+        final var mapNullKey = new HashMap<String, List<String>>();\n+        mapNullKey.put(null, List.of(\"Bar\"));\n+\n+        final var mapNullList = new HashMap<String, List<String>>();\n+        mapNullList.put(\"Foo\", null);\n+\n+        final var listWithNull = new LinkedList<String>();\n+        listWithNull.add(null);\n+\n+        final var mapNullInList = new HashMap<String, List<String>>();\n+        mapNullInList.put(\"Foo\", listWithNull);\n+\n+        assertThrows(NPE, () -> h.add(null, \"Bar\"));\n+        assertThrows(NPE, () -> h.add(\"Foo\", null));\n+\n+        assertThrows(NPE, () -> h.compute(null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.compute(\"Foo\", (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.computeIfAbsent(null, (k) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.computeIfAbsent(\"Foo-foo\", (k) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.computeIfPresent(null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.computeIfPresent(\"Foo\", (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.containsKey(null));\n+\n+        assertThrows(NPE, () -> h.containsValue(null));\n+\n+        assertThrows(NPE, () -> h.get(null));\n+\n+        assertThrows(NPE, () -> h.getFirst(null));\n+\n+        assertThrows(NPE, () -> h.getOrDefault(null, List.of(\"Bar\")));\n+\n+        assertThrows(NPE, () -> h.merge(null, List.of(\"Bar\"), (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo-foo\", null, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo-foo\", listWithNull, (k, v) -> List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.merge(\"Foo\", List.of(\"Bar\"), (k, v) -> listWithNull));\n+\n+        assertThrows(NPE, () -> h.put(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.put(\"Foo\", null));\n+        assertThrows(NPE, () -> h.put(\"Foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.putAll(mapNullKey));\n+        assertThrows(NPE, () -> h.putAll(mapNullList));\n+        assertThrows(NPE, () -> h.putAll(mapNullInList));\n+\n+        assertThrows(NPE, () -> h.putIfAbsent(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.putIfAbsent(\"Foo-foo\", null));\n+        assertThrows(NPE, () -> h.putIfAbsent(\"Foo-foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.remove(null));\n+\n+        assertThrows(NPE, () -> h.remove(null, List.of(\"Bar\")));\n+\n+        assertThrows(NPE, () -> h.replace(null, List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", null));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", listWithNull));\n+\n+        assertThrows(NPE, () -> h.replace(null, List.of(\"Bar\"), List.of(\"Bar\")));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", List.of(\"Bar\"), null));\n+        assertThrows(NPE, () -> h.replace(\"Foo\", List.of(\"Bar\"), listWithNull));\n+\n+        assertThrows(NPE, () -> h.replaceAll((k, v) -> listWithNull));\n+        assertThrows(NPE, () -> h.replaceAll((k, v) -> null));\n+\n+        assertThrows(NPE, () -> h.set(null, \"Bar\"));\n+        assertThrows(NPE, () -> h.set(\"Foo\", null));\n+    }\n+\n+    @DataProvider\n+    public Object[][] responseHeaders() {\n+        final var listWithNull = new LinkedList<String>();\n+        listWithNull.add(null);\n+        return new Object[][] {\n+                {null,  List.of(\"Bar\")},\n+                {\"Foo\", null},\n+                {\"Foo\", listWithNull}\n+        };\n+    }\n+\n+    \/**\n+     * Confirms HttpExchange::sendResponseHeaders throws NPE if response headers\n+     * contain a null key or value.\n+     *\/\n+    @Test(dataProvider = \"responseHeaders\")\n+    public void testNullResponseHeaders(String headerKey, List<String> headerVal)\n+            throws Exception {\n+        var handler = new Handler(headerKey, headerVal);\n+        var server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 0);\n+        server.createContext(\"\/\", handler);\n+        server.start();\n+        try {\n+            var client = HttpClient.newBuilder().proxy(NO_PROXY).build();\n+            var request = HttpRequest.newBuilder(uri(server, \"\")).build();\n+            assertThrows(IOE, () -> client.send(request, HttpResponse.BodyHandlers.ofString()));\n+            assertEquals(throwable.get().getClass(), NPE);\n+            assertTrue(Arrays.stream(throwable.get().getStackTrace())\n+                    .anyMatch(e -> e.getClassName().equals(\"sun.net.httpserver.HttpExchangeImpl\")\n+                            || e.getMethodName().equals(\"sendResponseHeaders\")));\n+        } finally {\n+            server.stop(0);\n+        }\n+    }\n+\n+    private static CompletableFuture<Throwable> throwable = new CompletableFuture<>();\n+\n+    private record Handler(String headerKey, List<String> headerVal) implements HttpHandler {\n+\n+        @Override\n+        public void handle(HttpExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody();\n+                 OutputStream os = exchange.getResponseBody()) {\n+                is.readAllBytes();\n+                var resp = \"hello world\".getBytes(StandardCharsets.UTF_8);\n+                putHeaders(exchange.getResponseHeaders(), headerKey, headerVal);\n+                try {\n+                    exchange.sendResponseHeaders(200, resp.length);\n+                } catch (Throwable t) {  \/\/ expect NPE\n+                    throwable.complete(t);\n+                    throw t;\n+                }\n+                os.write(resp);\n+            }\n+        }\n+    }\n+\n+    private static URI uri(HttpServer server, String path) {\n+        return URIBuilder.newBuilder()\n+                .host(\"localhost\")\n+                .port(server.getAddress().getPort())\n+                .scheme(\"http\")\n+                .path(\"\/\" + path)\n+                .buildUnchecked();\n+    }\n+\n+    \/**\n+     * Sets headers reflectively to be able to set a null key or value.\n+     *\/\n+    private static void putHeaders(Headers headers,\n+                                   String headerKey,\n+                                   List<String> headerVal) {\n+        try {\n+            final var map = new HashMap<String, List<String>>();\n+            map.put(headerKey, headerVal);\n+            var mapField = Headers.class.getDeclaredField(\"map\");\n+            mapField.setAccessible(true);\n+            mapField.set(headers, map);\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Could not set headers reflectively\", e);\n+        }\n+    }\n+\n+    @DataProvider\n+    public static Object[][] headerPairs() {\n+        final var h1 = new Headers();\n+        final var h2 = new Headers();\n+        final var h3 = new Headers();\n+        final var h4 = new Headers();\n+        final var h5 = new Headers();\n+        h1.put(\"Accept-Encoding\", List.of(\"gzip, deflate\"));\n+        h2.put(\"accept-encoding\", List.of(\"gzip, deflate\"));\n+        h3.put(\"AccePT-ENCoding\", List.of(\"gzip, deflate\"));\n+        h4.put(\"ACCept-EncodING\", List.of(\"gzip, deflate\"));\n+        h5.put(\"ACCEPT-ENCODING\", List.of(\"gzip, deflate\"));\n+\n+        final var headers = List.of(h1, h2, h3, h4, h5);\n+        return headers.stream()  \/\/ cartesian product of headers\n+                .flatMap(header1 -> headers.stream().map(header2 -> new Headers[] { header1, header2 }))\n+                .toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider = \"headerPairs\")\n+    public static void testEqualsAndHashCode(Headers h1, Headers h2) {\n+        \/\/ avoid testng's asserts(Map, Map) as they don't call Headers::equals\n+        assertTrue(h1.equals(h2), \"Headers differ\");\n+        assertEquals(h1.hashCode(), h2.hashCode(), \"hashCode differ for \"\n+                + List.of(h1, h2));\n+    }\n+\n+    @Test\n+    public static void testEqualsMap() {\n+        final var h = new Headers();\n+        final var m = new HashMap<String, List<String>>();\n+        assertTrue(h.equals(m));\n+        assertTrue(m.equals(h));\n+        assertFalse(h.equals(null), \"null cannot be equal to Headers\");\n+    }\n+\n+    @Test\n+    public static void testToString() {\n+        final var h = new Headers();\n+        h.put(\"Accept-Encoding\", List.of(\"gzip, deflate\"));\n+        assertTrue(h.toString().equals(\"Headers { {Accept-encoding=[gzip, deflate]} }\"));\n+    }\n+\n+    @Test\n+    public static void testPutAll() {\n+        final var h0 = new Headers();\n+        final var map = new HashMap<String, List<String>>();\n+        map.put(\"a\", null);\n+        assertThrows(NPE, () -> h0.putAll(map));\n+\n+        final var list = new ArrayList<String>();\n+        list.add(null);\n+        assertThrows(NPE, () -> h0.putAll(Map.of(\"a\", list)));\n+        assertThrows(IAE, () -> h0.putAll(Map.of(\"a\", List.of(\"\\n\"))));\n+\n+        final var h1 = new Headers();\n+        h1.put(\"a\", List.of(\"1\"));\n+        h1.put(\"b\", List.of(\"2\"));\n+        final var h2 = new Headers();\n+        h2.putAll(Map.of(\"a\", List.of(\"1\"), \"b\", List.of(\"2\")));\n+        assertTrue(h1.equals(h2));\n+    }\n+\n+    @Test\n+    public static void testReplaceAll() {\n+        final var h1 = new Headers();\n+        h1.put(\"a\", List.of(\"1\"));\n+        h1.put(\"b\", List.of(\"2\"));\n+        final var list = new ArrayList<String>();\n+        list.add(null);\n+        assertThrows(NPE, () -> h1.replaceAll((k, v) -> list));\n+        assertThrows(IAE, () -> h1.replaceAll((k, v) -> List.of(\"\\n\")));\n+\n+        h1.replaceAll((k, v) -> {\n+            String s = h1.get(k).get(0);\n+            return List.of(s+s);\n+        });\n+        final var h2 = new Headers();\n+        h2.put(\"a\", List.of(\"11\"));\n+        h2.put(\"b\", List.of(\"22\"));\n+        assertTrue(h1.equals(h2));\n+    }\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/HeadersTest.java","additions":277,"deletions":3,"binary":false,"changes":280,"status":"modified"}]}