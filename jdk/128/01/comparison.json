{"files":[{"patch":"@@ -1038,0 +1038,82 @@\n+void MacroAssembler::lookup_interface_method_in_stub(Register recv_klass,\n+                                                     Register resolved_klass,\n+                                                     Register holder_klass,\n+                                                     int itable_index,\n+                                                     Register method_result,\n+                                                     Register scan_temp,\n+                                                     Register count,\n+                                                     Label& L_no_such_interface\n+) {\n+  assert_different_registers(recv_klass, resolved_klass, holder_klass);\n+  assert_different_registers(method_result, scan_temp, count);\n+\n+  \/\/ Compute start of first itableOffsetEntry (which is at the end of the vtable)\n+  int vtable_base = in_bytes(Klass::vtable_start_offset());\n+  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int scan_step   = itableOffsetEntry::size() * wordSize;\n+  int vte_size    = vtableEntry::size_in_bytes();\n+  assert(vte_size == wordSize, \"else adjust times_vte_scale\");\n+\n+  ldrw(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+\n+  \/\/ %%% Could store the aligned, prescaled offset in the klassoop.\n+  lea(scan_temp, Address(recv_klass, scan_temp, Address::lsl(3)));\n+  add(scan_temp, scan_temp, vtable_base);\n+  mov(count, -2);\n+\n+  \/\/ Adjust recv_klass by scaled itable_index, so we can free itable_index.\n+  assert(itableMethodEntry::size() * wordSize == wordSize, \"adjust the scaling in the code below\");\n+  if (itable_index != 0) {\n+    lea(recv_klass, Address(recv_klass, itable_index, Address::lsl(3)));\n+  }\n+  if (itentry_off) {\n+    add(recv_klass, recv_klass, itentry_off);\n+  }\n+\n+  Label L_fast_loop, L_slow_loop, L_slow_loop_tail, L_exit;\n+\n+  cmp(holder_klass, resolved_klass);\n+  br(Assembler::NE, L_slow_loop);\n+\n+  \/\/ fast loop, check holder klass only\n+  bind(L_fast_loop);\n+  if (itableOffsetEntry::interface_offset_in_bytes() == 0 ) {\n+    ldr(method_result, Address(post(scan_temp, scan_step)));\n+  } else {\n+    ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+    add(scan_temp, scan_temp, scan_step);\n+  }\n+  cbz(method_result, L_no_such_interface);\n+  \/\/ check holder_klass\n+  cmp(holder_klass, method_result);\n+  br(Assembler::NE, L_fast_loop);\n+  \/\/ found, holder_klass can be free for other use\n+  ldrw(holder_klass, Address(scan_temp, -scan_step + itableOffsetEntry::offset_offset_in_bytes()));\n+  b(L_exit);\n+\n+  \/\/ slow loop, search both resolved_klass and holder_klass\n+  bind(L_slow_loop);\n+  if (itableOffsetEntry::interface_offset_in_bytes() == 0 ) {\n+    ldr(method_result, Address(post(scan_temp, scan_step)));\n+  } else {\n+    ldr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+    add(scan_temp, scan_temp, scan_step);\n+  }\n+  cbz(method_result, L_no_such_interface);\n+  \/\/ check resolved_klass\n+  cmp(resolved_klass, method_result);\n+  csinc(count, count, count, Assembler::NE);\n+  \/\/ check holder_klass\n+  cmp(holder_klass, method_result);\n+  br(Assembler::NE, L_slow_loop_tail);\n+  increment(count);\n+  \/\/ holder_klass can be free for other use\n+  ldrw(holder_klass, Address(scan_temp, -scan_step + itableOffsetEntry::offset_offset_in_bytes()));\n+  bind(L_slow_loop_tail);\n+  cbnz(count, L_slow_loop);\n+\n+  \/\/ Got a hit.\n+  bind(L_exit);\n+  ldr(method_result, Address(recv_klass, holder_klass, Address::uxtw(0)));\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -912,0 +912,10 @@\n+  \/\/ for itable_stub\n+  void lookup_interface_method_in_stub(Register recv_klass,\n+                                       Register resolved_klass,\n+                                       Register holder_klass,\n+                                       int itable_index,\n+                                       Register method_result,\n+                                       Register scan_temp,\n+                                       Register count,\n+                                       Label& no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  const Register resolved_klass_reg = rmethod; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = r13; \/\/ resolved interface klass (REFC)\n@@ -179,1 +179,1 @@\n-  const Register temp_reg2          = r15;\n+  const Register count_reg          = r15;\n@@ -193,19 +193,4 @@\n-  \/\/ Receiver subtype check against REFC.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             temp_reg2, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n-  \/\/ Get selected method from declaring class and itable index\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             rmethod, temp_reg,\n-                             L_no_such_interface);\n-\n-  const ptrdiff_t lookupSize = __ pc() - start_pc;\n+  __ lookup_interface_method_in_stub(\n+    recv_klass_reg, resolved_klass_reg, holder_klass_reg, itable_index,\n+    rmethod, temp_reg, count_reg,\n+    L_no_such_interface);\n@@ -215,1 +200,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize;\n+  const ptrdiff_t codesize = __ pc() - start_pc;\n","filename":"src\/hotspot\/cpu\/aarch64\/vtableStubs_aarch64.cpp","additions":7,"deletions":22,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -3457,0 +3457,67 @@\n+void MacroAssembler::lookup_interface_method_in_stub(Register recv_klass,\n+                                                     Register holder_klass,\n+                                                     Register resolved_klass,\n+                                                     int itable_index,\n+                                                     Register method_result,\n+                                                     Register scan_temp,\n+                                                     Register count,\n+                                                     Label& L_no_such_interface) {\n+  assert_different_registers(recv_klass, holder_klass, resolved_klass);\n+  assert_different_registers(method_result, scan_temp, count);\n+\n+  \/\/ Compute start of first itableOffsetEntry (which is at the end of the vtable)\n+  int vtable_base = in_bytes(Klass::vtable_start_offset());\n+  int itentry_off = itableMethodEntry::method_offset_in_bytes();\n+  int scan_step   = itableOffsetEntry::size() * wordSize;\n+  int vte_size    = vtableEntry::size_in_bytes();\n+  Address::ScaleFactor times_vte_scale = Address::times_ptr;\n+  Label L_fast_loop, L_slow_loop, L_next_check, L_slow_loop_tail, L_exit;\n+\n+  assert(vte_size == wordSize, \"else adjust times_vte_scale\");\n+\n+  movl(scan_temp, Address(recv_klass, Klass::vtable_length_offset()));\n+  lea(scan_temp, Address(recv_klass, scan_temp, times_vte_scale, vtable_base));\n+\n+  assert(itableMethodEntry::size() * wordSize == wordSize, \"adjust the scaling in the code below\");\n+  lea(recv_klass, Address(recv_klass, itable_index, Address::times_ptr, itentry_off));\n+  movl(count, 2);\n+\n+  cmpptr(holder_klass, resolved_klass);\n+  jcc(Assembler::notEqual, L_slow_loop);\n+\n+  \/\/ fast loop, check holder_klass only\n+  bind(L_fast_loop);\n+  movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+  testptr(method_result, method_result);\n+  jcc(Assembler::zero, L_no_such_interface);\n+  addptr(scan_temp, scan_step);\n+  cmpptr(holder_klass, method_result);\n+  jccb(Assembler::notEqual, L_fast_loop);\n+  movptr(holder_klass, Address(scan_temp, -scan_step + itableOffsetEntry::offset_offset_in_bytes()));\n+  jmp(L_exit);\n+\n+  \/\/ slow loop, search both resolved_klass and holder_klass\n+  bind(L_slow_loop);\n+  movptr(method_result, Address(scan_temp, itableOffsetEntry::interface_offset_in_bytes()));\n+  testptr(method_result, method_result);\n+  jcc(Assembler::zero, L_no_such_interface);\n+\n+  cmpptr(holder_klass, method_result);\n+  jccb(Assembler::notEqual, L_next_check);\n+  movptr(holder_klass, Address(scan_temp, itableOffsetEntry::offset_offset_in_bytes()));\n+  decrement(count);\n+\n+  bind(L_next_check);\n+  cmpptr(resolved_klass, method_result);\n+  jccb(Assembler::notEqual, L_slow_loop_tail);\n+  decrement(count);\n+\n+  bind(L_slow_loop_tail);\n+  addptr(scan_temp, scan_step);\n+  testl(count, count);\n+  jcc(Assembler::notZero, L_slow_loop);\n+\n+  \/\/ Got a hit.\n+  bind(L_exit);\n+  movptr(method_result, Address(recv_klass, holder_klass, Address::times_1));\n+}\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -539,0 +539,10 @@\n+  \/\/ for itable_stub\n+  void lookup_interface_method_in_stub(Register recv_klass,\n+                               Register holder_klass,\n+                               Register resolved_klass,\n+                               int itable_index,\n+                               Register method_result,\n+                               Register scan_temp,\n+                               Register count,\n+                               Label& no_such_interface);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-  const Register resolved_klass_reg = rbx; \/\/ resolved interface klass (REFC)\n+  const Register resolved_klass_reg = r14; \/\/ resolved interface klass (REFC)\n@@ -182,0 +182,3 @@\n+  const Register method = rbx;\n+  const Register count_reg = r13;\n+\n@@ -193,23 +196,3 @@\n-\n-  \/\/ Receiver subtype check against REFC.\n-  \/\/ Destroys recv_klass_reg value.\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface\n-                             recv_klass_reg, resolved_klass_reg, noreg,\n-                             \/\/ outputs:  scan temp. reg1, scan temp. reg2\n-                             recv_klass_reg, temp_reg,\n-                             L_no_such_interface,\n-                             \/*return_method=*\/false);\n-\n-  const ptrdiff_t  typecheckSize = __ pc() - start_pc;\n-  start_pc = __ pc();\n-\n-  \/\/ Get selected method from declaring class and itable index\n-  const Register method = rbx;\n-  __ load_klass(recv_klass_reg, j_rarg0, temp_reg);   \/\/ restore recv_klass_reg\n-  __ lookup_interface_method(\/\/ inputs: rec. class, interface, itable index\n-                             recv_klass_reg, holder_klass_reg, itable_index,\n-                             \/\/ outputs: method, scan temp. reg\n-                             method, temp_reg,\n-                             L_no_such_interface);\n-\n-  const ptrdiff_t  lookupSize = __ pc() - start_pc;\n+  __ lookup_interface_method_in_stub(recv_klass_reg, holder_klass_reg, resolved_klass_reg, itable_index,\n+                                     method, temp_reg, count_reg,\n+                                     L_no_such_interface);\n@@ -221,1 +204,1 @@\n-  const ptrdiff_t codesize = typecheckSize + lookupSize + index_dependent_slop;\n+  const ptrdiff_t codesize = __ pc() - start_pc + index_dependent_slop;\n","filename":"src\/hotspot\/cpu\/x86\/vtableStubs_x86_64.cpp","additions":8,"deletions":25,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -57,0 +58,11 @@\n+    interface SuperInterface {\n+        public int getInt();\n+    }\n+\n+    interface SuperInterface2 extends SuperInterface {\n+        default int getInt2() {return 2;}\n+    }\n+\n+    interface SubInterface extends SuperInterface2 {\n+    }\n+\n@@ -96,0 +108,70 @@\n+    class FirstClassNotInline implements AnInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return 1;\n+        }\n+    }\n+\n+    class SecondClassNotInline implements AnInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return 2;\n+        }\n+    }\n+\n+    class ThirdClassNotInline implements AnInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return -3;\n+        }\n+    }\n+\n+    class FourthClassNotInline implements AnInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return -4;\n+        }\n+    }\n+\n+    class FifthClassNotInline implements AnInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return -5;\n+        }\n+    }\n+\n+    class FirstSubClassNotInline implements SubInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return 1;\n+        }\n+    }\n+\n+    class SecondSubClassNotInline implements SubInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return 2;\n+        }\n+    }\n+\n+    class ThirdSubClassNotInline implements SubInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return -3;\n+        }\n+    }\n+\n+    class FourthSubClassNotInline implements SubInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return -4;\n+        }\n+    }\n+\n+    class FifthSubClassNotInline implements SubInterface {\n+        @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+        public int getInt() {\n+            return -5;\n+        }\n+    }\n+\n@@ -135,0 +217,2 @@\n+    public AnInterface[] as2 = new AnInterface[5];\n+    public SubInterface[] as3 = new SubInterface[5];\n@@ -156,0 +240,10 @@\n+        as2[0] = new FirstClassNotInline();\n+        as2[1] = new SecondClassNotInline();\n+        as2[2] = new ThirdClassNotInline();\n+        as2[3] = new FourthClassNotInline();\n+        as2[4] = new FifthClassNotInline();\n+        as3[0] = new FirstSubClassNotInline();\n+        as3[1] = new SecondSubClassNotInline();\n+        as3[2] = new ThirdSubClassNotInline();\n+        as3[3] = new FourthSubClassNotInline();\n+        as3[4] = new FifthSubClassNotInline();\n@@ -263,1 +357,1 @@\n-        for (int kk = 0; kk < 3; kk++) {\n+        for (int kk = 0; kk < 5; kk++) {\n@@ -268,0 +362,32 @@\n+    \/** Interface methods are not inline, test itable stub *\/\n+    @Benchmark\n+    public void testStubPoly3(Blackhole bh) {\n+        for (int kk = 0; kk < 3; kk++) {\n+            bh.consume(as2[kk].getInt());\n+        }\n+    }\n+\n+    \/** Interface methods are not inline, test itable stub *\/\n+    @Benchmark\n+    public void testStubPoly5(Blackhole bh) {\n+        for (int kk = 0; kk < 5; kk++) {\n+            bh.consume(as2[kk].getInt());\n+        }\n+    }\n+\n+    \/** Interface methods are not inline, test itable stub in slow loop*\/\n+    @Benchmark\n+    public void testSlowStubPoly3(Blackhole bh) {\n+        for (int kk = 0; kk < 3; kk++) {\n+            bh.consume(as3[kk].getInt());\n+        }\n+    }\n+\n+    \/** Interface methods are not inline, test itable stub in slow loop*\/\n+    @Benchmark\n+    public void testSlowStubPoly5(Blackhole bh) {\n+        for (int kk = 0; kk < 5; kk++) {\n+            bh.consume(as3[kk].getInt());\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/InterfaceCalls.java","additions":127,"deletions":1,"binary":false,"changes":128,"status":"modified"}]}