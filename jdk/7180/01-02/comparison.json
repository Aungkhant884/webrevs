{"files":[{"patch":"@@ -43,1 +43,0 @@\n-import java.util.ArrayList;\n@@ -45,3 +44,0 @@\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -54,0 +50,8 @@\n+\/*\n+ * The test verifies Instrumentation.retransformClasses() (and JVMTI function RetransformClasses)\n+ * correctly handles MethodParameter attribute:\n+ * - classfile bytes passed to transformers (and JVMTI ClassFileLoadHook event callback) contain the attribute;\n+ * - the attribute is updated.\n+ *\/\n+\n+\/\/ See ClassTransformer.transform(int) comment for @1 tag explanations.\n@@ -55,0 +59,2 @@\n+    \/\/ The class contains the only method, so we don't have issue with method sorting\n+    \/\/ and ClassFileReconstituter should restore the same bytes as original classbytes.\n@@ -87,5 +93,0 @@\n-\n-        DisassembledClassbytes disasm = new DisassembledClassbytes(originalClassBytes);\n-        log(\"original:\");\n-        disasm.print();\n-        assertTrue(\"MethodParameters not found\", !disasm.methodParameters().lines.isEmpty());\n@@ -98,1 +99,1 @@\n-    \/\/\n+    \/\/ Prints and verifies MethodParameters attribute using reflection.\n@@ -117,1 +118,3 @@\n-    private void reset() {\n+    \/\/ Retransforms target class using provided class bytes;\n+    \/\/ Returns class bytes passed to the transformer.\n+    private byte[] retransform(byte[] classBytes) throws Throwable {\n@@ -119,12 +122,0 @@\n-        newClassBytes = null;\n-    }\n-\n-    private byte[] getClassBytes() throws Throwable {\n-        reset();\n-        fInst.retransformClasses(targetClass);\n-        assertTrue(targetClassName + \" was not seen by transform()\", seenClassBytes != null);\n-        return seenClassBytes;\n-    }\n-\n-    private void setClassBytes(byte[] classBytes) throws Throwable {\n-        reset();\n@@ -134,0 +125,1 @@\n+        return seenClassBytes;\n@@ -136,72 +128,3 @@\n-    private static final String[] expectedDifferentStrings = {\n-            \"^Classfile .+$\",\n-            \"^[\\\\s]+SHA-256 checksum .[^\\\\s]+$\"\n-    };\n-\n-    private boolean expectedDifferent(String line) {\n-        for (String s: expectedDifferentStrings) {\n-            Pattern p = Pattern.compile(s);\n-            if (p.matcher(line).find()) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private void compareClassBytes(byte[] bytes1, byte[] bytes2) throws Throwable {\n-        if (bytes1.length != bytes2.length) {\n-            log(\"Class bytes have different length: \" + bytes1.length + \" != \" + bytes2.length);\n-        } else {\n-            int pos = Arrays.mismatch(bytes1, bytes2);\n-            if (pos < 0) {\n-                log(\"Class bytes are identical.\");\n-                return;\n-            }\n-            log(\"Class bytes are different (starting from \" + pos + \"): \" + bytes1.length + \" != \" + bytes2.length);\n-        }\n-\n-        log(\"Disassembly difference:\");\n-        \/\/ compare 'javap -v' output for the class files\n-        List<String> out1 = new DisassembledClassbytes(bytes1).lines;\n-        DisassembledClassbytes disasm2 = new DisassembledClassbytes(bytes2);\n-        List<String> out2 = disasm2.lines;\n-        boolean different = false;\n-        boolean orderChanged = false;\n-        int lineNum = 0;\n-        for (String line: out1) {\n-            if (!expectedDifferent(line)) {\n-                if (!out2.contains(line)) {\n-                    different = true;\n-                    System.out.println(\"< (\" + (lineNum + 1) + \") \" + line);\n-                } else {\n-                    if (lineNum < out2.size() && !out1.get(lineNum).equals(out2.get(lineNum))) {\n-                        \/\/ out2 contains line, but at different position\n-                        System.out.println(\"orig (\" + lineNum + \"): \" + line);\n-                        orderChanged = true;\n-                    }\n-                }\n-            }\n-            lineNum++;\n-        }\n-        lineNum = 0;\n-        for (String line: out2) {\n-            if (!expectedDifferent(line)) {\n-                if (!out1.contains(line)) {\n-                    different = true;\n-                    System.out.println(\"> (\" + (lineNum + 1) + \") \" + line);\n-                }\n-            }\n-            lineNum++;\n-        }\n-\n-        if (different) {\n-            log(\"from transformer:\");\n-            disasm2.print();\n-\n-            fail(targetClassName + \" did not match .class file\");\n-        }\n-        log(\"Disassembled files are equals\" + (orderChanged ? \" (order changed)\" : \"\"));\n-    }\n-\n-    private class DisassembledClassbytes {\n-        public final List<String> lines;\n+    \/\/ Prints dissassembled class bytes.\n+    private void printDisassembled(String description, byte[] bytes) throws Exception {\n+        log(description + \" -------------------\");\n@@ -209,55 +132,0 @@\n-        public DisassembledClassbytes(List<String> lines) {\n-            this.lines = lines;\n-        }\n-        public DisassembledClassbytes(byte[] classBytes) throws Throwable {\n-            this(disassembleClassBytes(classBytes));\n-        }\n-\n-        public void print() {\n-            log(\"DisassembledClassbytes -------------------\");\n-            lines.forEach(s -> log(s));\n-            log(\"==========================================\");\n-        }\n-\n-        public boolean contains(String s) {\n-            for (String line: lines) {\n-                if (line.contains(s)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        public DisassembledClassbytes getSection(String name) {\n-            List<String> result = new ArrayList<>();\n-            boolean inSection = false;\n-            String sectionPrefix = \"\";\n-            Pattern p = Pattern.compile(\"^( *)\" + name + \"\\\\b.*$\");\n-\n-            for (String line: lines) {\n-                if (inSection) {\n-                    if (line.startsWith(sectionPrefix)) {\n-                        result.add(line);\n-                    } else {\n-                        inSection = false; \/\/ and check if new section is started here\n-                    }\n-                }\n-                if (!inSection) {\n-                    Matcher m = p.matcher(line);\n-                    if (m.find()) {\n-                        inSection = true;\n-                        sectionPrefix = m.group(1) + \" \";\n-                        \/\/ add section header as well\n-                        result.add(line);\n-                    }\n-                }\n-            }\n-            return new DisassembledClassbytes(result);\n-        }\n-\n-        public DisassembledClassbytes methodParameters() {\n-            return getSection(\"MethodParameters\");\n-        }\n-    }\n-\n-    private List<String> disassembleClassBytes(byte[] bytes) throws Throwable {\n@@ -268,1 +136,0 @@\n-\n@@ -283,1 +150,2 @@\n-        return out.asLines();\n+        out.asLines().forEach(s -> log(s));\n+        log(\"==========================================\");\n@@ -286,0 +154,13 @@\n+    \/\/ Verifies class bytes are equal.\n+    private void compareClassBytes(byte[] expected, byte[] actual) throws Exception {\n+\n+        int pos = Arrays.mismatch(expected, actual);\n+        if (pos < 0) {\n+            log(\"Class bytes are identical.\");\n+            return;\n+        }\n+        log(\"Class bytes are different.\");\n+        printDisassembled(\"expected\", expected);\n+        printDisassembled(\"expected\", actual);\n+        fail(targetClassName + \" did not match .class file\");\n+    }\n@@ -292,0 +173,1 @@\n+        \/\/ sanity check\n@@ -293,0 +175,1 @@\n+        \/\/ sanity check\n@@ -295,2 +178,0 @@\n-        log(\"(-1)1st arg name = \" + targetClass.getMethods()[0].getParameters()[0].getName());\n-\n@@ -300,2 +181,1 @@\n-            log(\"Testcase 1: ensure ClassFileReconstiruter restores MethodParameters attribute\");\n-            byte[] classBytes = getClassBytes();\n+            log(\"Testcase 1: ensure ClassFileReconstituter restores MethodParameters attribute\");\n@@ -303,0 +183,1 @@\n+            byte[] classBytes = retransform(null);\n@@ -304,0 +185,1 @@\n+\n@@ -309,0 +191,1 @@\n+\n@@ -312,7 +195,2 @@\n-            DisassembledClassbytes disasm = new DisassembledClassbytes(classBytes);\n-            log(\"transformed class:\");\n-            disasm.print();\n-            assertTrue(\"MethodParameters not found\", !disasm.methodParameters().lines.isEmpty());\n-\n-            setClassBytes(classBytes);\n-\n+            retransform(classBytes);\n+            \/\/ MethodParameters attribute should be updated.\n@@ -320,0 +198,2 @@\n+\n+            log(\"\");\n@@ -324,0 +204,1 @@\n+            \/\/ compile without \"-parameters\"\n@@ -327,9 +208,2 @@\n-            DisassembledClassbytes disasm = new DisassembledClassbytes(classBytes);\n-            log(\"transformed class:\");\n-            disasm.print();\n-            \/\/ ensure there is no MethodParameters attr.\n-            assertTrue(\"MethodParameters found\", disasm.methodParameters().lines.isEmpty());\n-\n-            setClassBytes(classBytes);\n-\n-            \/\/ MethodParameters attribute should be deleted.\n+            retransform(classBytes);\n+            \/\/ MethodParameters attribute should be dropped.\n@@ -337,0 +211,2 @@\n+\n+            log(\"\");\n","filename":"test\/jdk\/java\/lang\/instrument\/RetransformWithMethodParametersTest.java","additions":48,"deletions":172,"binary":false,"changes":220,"status":"modified"}]}