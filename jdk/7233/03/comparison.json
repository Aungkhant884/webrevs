{"files":[{"patch":"@@ -256,1 +256,1 @@\n-        if (type.equals(typeElement.asType())) {\n+        if (utils.typeUtils.isSameType(type, typeElement.asType())) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -209,1 +209,1 @@\n-    VisibleMemberCache visibleMemberCache = null;\n+    private VisibleMemberCache visibleMemberCache;\n@@ -712,1 +712,1 @@\n-    public synchronized VisibleMemberTable getVisibleMemberTable(TypeElement te) {\n+    public VisibleMemberTable getVisibleMemberTable(TypeElement te) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-     * or  {@code --override-methods detail}.\n+     * or {@code --override-methods detail}.\n@@ -1051,1 +1051,1 @@\n-     * or  {@code --override-methods detail}.\n+     * or {@code --override-methods detail}.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import javax.lang.model.type.DeclaredType;\n@@ -49,1 +50,0 @@\n-import com.sun.tools.javac.code.Attribute;\n@@ -58,0 +58,1 @@\n+import com.sun.tools.javac.code.Type;\n@@ -204,5 +205,12 @@\n-    \/**\n-     * Return the type containing the method that this method overrides.\n-     * It may be a <code>TypeElement<\/code> or a <code>TypeParameterElement<\/code>.\n-     * @param method target\n-     * @return a type\n+    \/*\n+     * Returns the closest superclass (not the superinterface) that contains\n+     * a method that is both:\n+     *\n+     *   - overridden by the specified method, and\n+     *   - is not itself a *simple* override\n+     *\n+     * If no such class can be found, returns null.\n+     *\n+     * If the specified method belongs to an interface, the only considered\n+     * superclass is java.lang.Object no matter how many other interfaces\n+     * that interface extends.\n@@ -210,1 +218,1 @@\n-    public TypeMirror overriddenType(ExecutableElement method) {\n+    public DeclaredType overriddenType(ExecutableElement method) {\n@@ -216,3 +224,3 @@\n-        for (com.sun.tools.javac.code.Type t = javacTypes.supertype(origin.type);\n-                t.hasTag(TypeTag.CLASS);\n-                t = javacTypes.supertype(t)) {\n+        for (Type t = javacTypes.supertype(origin.type);\n+             t.hasTag(TypeTag.CLASS);\n+             t = javacTypes.supertype(t)) {\n@@ -220,1 +228,1 @@\n-            for (com.sun.tools.javac.code.Symbol sym2 : c.members().getSymbolsByName(sym.name)) {\n+            for (Symbol sym2 : c.members().getSymbolsByName(sym.name)) {\n@@ -227,1 +235,2 @@\n-                    return t;\n+                    assert t.hasTag(TypeTag.CLASS) && !t.isInterface();\n+                    return (Type.ClassType) t;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -111,6 +111,6 @@\n-     \/**\n-      * Handles the {@literal <TypeElement>} tag.\n-      *\n-      * @throws DocletException if there is a problem while building the documentation\n-      *\/\n-     protected void buildClassDoc() throws DocletException {\n+    \/**\n+     * Handles the {@literal <TypeElement>} tag.\n+     *\n+     * @throws DocletException if there is a problem while building the documentation\n+     *\/\n+    protected void buildClassDoc() throws DocletException {\n@@ -125,1 +125,1 @@\n-         Content contentTree = writer.getHeader(resources.getText(key) + \" \"\n+        Content contentTree = writer.getHeader(resources.getText(key) + \" \"\n@@ -140,5 +140,5 @@\n-     \/**\n-      * Build the class tree documentation.\n-      *\n-      * @param classContentTree the content tree to which the documentation will be added\n-      *\/\n+    \/**\n+     * Build the class tree documentation.\n+     *\n+     * @param classContentTree the content tree to which the documentation will be added\n+     *\/\n@@ -259,1 +259,1 @@\n-     private void copyDocFiles() throws DocletException {\n+    private void copyDocFiles() throws DocletException {\n@@ -273,1 +273,1 @@\n-     }\n+    }\n@@ -290,1 +290,1 @@\n-       writer.addClassDescription(classInfoTree);\n+        writer.addClassDescription(classInfoTree);\n@@ -299,1 +299,1 @@\n-       writer.addClassTagInfo(classInfoTree);\n+        writer.addClassTagInfo(classInfoTree);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import javax.lang.model.util.Types;\n@@ -169,1 +170,3 @@\n-                ((ExecutableElement) holder).getThrownTypes(), thrownTypes);\n+                writer.configuration().utils.typeUtils,\n+                ((ExecutableElement) holder).getThrownTypes(),\n+                thrownTypes);\n@@ -236,1 +239,2 @@\n-    private Map<String, TypeMirror> getSubstitutedThrownTypes(List<? extends TypeMirror> declaredThrownTypes,\n+    private Map<String, TypeMirror> getSubstitutedThrownTypes(Types types,\n+                                                              List<? extends TypeMirror> declaredThrownTypes,\n@@ -245,1 +249,1 @@\n-                if (!t1.equals(t2))\n+                if (!types.isSameType(t1, t2))\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,6 +48,1 @@\n-    public synchronized Throwable getCause() {\n-        return super.getCause();\n-    }\n-\n-    @Override\n-    public synchronized Throwable initCause(Throwable cause) {\n+    public Throwable initCause(Throwable cause) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/UncheckedDocletException.java","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-    private HashMap<String, TypeMirror> symtab = new HashMap<>();\n+    private final Map<String, TypeMirror> symtab = new HashMap<>();\n@@ -165,11 +165,4 @@\n-        TypeMirror type = symtab.get(signature);\n-        if (type == null) {\n-            TypeElement typeElement = elementUtils.getTypeElement(signature);\n-            if (typeElement == null)\n-                return null;\n-            type = typeElement.asType();\n-            if (type == null)\n-                return null;\n-            symtab.put(signature, type);\n-        }\n-        return type;\n+        return symtab.computeIfAbsent(signature, s -> {\n+            var typeElement = elementUtils.getTypeElement(s);\n+            return typeElement == null ? null : typeElement.asType();\n+        });\n@@ -182,1 +175,3 @@\n-    public TypeMirror getThrowableType() { return getSymbol(\"java.lang.Throwable\"); }\n+    public TypeMirror getThrowableType() {\n+        return getSymbol(\"java.lang.Throwable\");\n+    }\n@@ -244,3 +239,3 @@\n-     * @param t1 the candidate superclass.\n-     * @param t2 the target\n-     * @return true if t1 is a superclass of t2.\n+     * @param t1 the candidate subclass\n+     * @param t2 the candidate superclass\n+     * @return true if t1 is a superclass of t2\n@@ -264,2 +259,1 @@\n-                int j;\n-                for (j = 0 ; j < parameters1.size(); j++) {\n+                for (int j = 0; j < parameters1.size(); j++) {\n@@ -268,5 +262,2 @@\n-                    String t1 = getTypeName(v1.asType(), true);\n-                    String t2 = getTypeName(v2.asType(), true);\n-                    if (!(t1.equals(t2) ||\n-                            isTypeVariable(v1.asType()) || isTypeVariable(v2.asType()))) {\n-                        break;\n+                    if (!typeUtils.isSameType(v1.asType(), v2.asType())) {\n+                        return false;\n@@ -275,3 +266,1 @@\n-                if (j == parameters1.size()) {\n-                    return true;\n-                }\n+                return true;\n@@ -537,7 +526,4 @@\n-        ElementKind kind = e.getKind();\n-        switch (kind) {\n-            case CONSTRUCTOR: case METHOD: case INSTANCE_INIT:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (e.getKind()) {\n+            case CONSTRUCTOR, METHOD, INSTANCE_INIT -> true;\n+            default -> false;\n+        };\n@@ -547,9 +533,5 @@\n-        ElementKind kind = e.getKind();\n-        switch(kind) {\n-              case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:\n-              case LOCAL_VARIABLE: case PARAMETER:\n-              case RESOURCE_VARIABLE:\n-                  return true;\n-              default:\n-                  return false;\n-        }\n+        return switch (e.getKind()) {\n+            case ENUM_CONSTANT, EXCEPTION_PARAMETER, FIELD, LOCAL_VARIABLE,\n+                    PARAMETER, RESOURCE_VARIABLE -> true;\n+            default -> false;\n+        };\n@@ -559,6 +541,4 @@\n-        switch (e.getKind()) {\n-            case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:\n-                return true;\n-            default:\n-                return false;\n-        }\n+        return switch (e.getKind()) {\n+            case CLASS, ENUM, INTERFACE, ANNOTATION_TYPE, RECORD -> true;\n+            default -> false;\n+        };\n@@ -721,1 +701,1 @@\n-        return bound.equals(getObjectType()) && !isAnnotated(bound);\n+        return typeUtils.isSameType(bound, getObjectType()) && !isAnnotated(bound);\n@@ -786,3 +766,12 @@\n-    \/**\n-     * Return the type containing the method that this method overrides.\n-     * It may be a {@code TypeElement} or a {@code TypeParameterElement}.\n+    \/*\n+     * Returns the closest superclass (not the superinterface) that contains\n+     * a method that is both:\n+     *\n+     *   - overridden by the specified method, and\n+     *   - is not itself a *simple* override\n+     *\n+     * If no such class can be found, returns null.\n+     *\n+     * If the specified method belongs to an interface, the only considered\n+     * superclass is java.lang.Object no matter how many other interfaces\n+     * that interface extends.\n@@ -790,1 +779,1 @@\n-    public TypeMirror overriddenType(ExecutableElement method) {\n+    public DeclaredType overriddenType(ExecutableElement method) {\n@@ -809,1 +798,1 @@\n-     * originally defined this method, null if this method does\n+     * originally defined this method, or null if this method does\n@@ -823,2 +812,2 @@\n-                t.getKind() == DECLARED;\n-                t = getSuperType(asTypeElement(t))) {\n+             t.getKind() == DECLARED;\n+             t = getSuperType(asTypeElement(t))) {\n@@ -837,1 +826,1 @@\n-            if (t.equals(getObjectType()))\n+            if (typeUtils.isSameType(t, getObjectType()))\n@@ -919,1 +908,1 @@\n-        getAllInterfaces(te.asType(), results);\n+        addSuperInterfaces(te.asType(), results);\n@@ -923,2 +912,1 @@\n-    private void getAllInterfaces(TypeMirror type, Set<TypeMirror> results) {\n-        List<? extends TypeMirror> intfacs = typeUtils.directSupertypes(type);\n+    private void addSuperInterfaces(TypeMirror type, Set<TypeMirror> results) {\n@@ -926,2 +914,2 @@\n-        for (TypeMirror intfac : intfacs) {\n-            if (intfac == getObjectType())\n+        for (TypeMirror t : typeUtils.directSupertypes(type)) {\n+            if (typeUtils.isSameType(t, getObjectType()))\n@@ -929,1 +917,1 @@\n-            TypeElement e = asTypeElement(intfac);\n+            TypeElement e = asTypeElement(t);\n@@ -931,4 +919,4 @@\n-                if (isPublic(e) || isLinkable(e))\n-                    results.add(intfac);\n-\n-                getAllInterfaces(intfac, results);\n+                if (isPublic(e) || isLinkable(e)) {\n+                    results.add(t);\n+                }\n+                addSuperInterfaces(t, results);\n@@ -936,0 +924,2 @@\n+                \/\/ there can be at most one superclass and it is not null\n+                assert superType == null && t != null : superType;\n@@ -937,1 +927,1 @@\n-                superType = intfac;\n+                superType = t;\n@@ -942,1 +932,1 @@\n-            getAllInterfaces(superType, results);\n+            addSuperInterfaces(superType, results);\n@@ -1179,2 +1169,1 @@\n-        if (isInterface(te) || isAnnotationType(te) ||\n-                te.asType().equals(getObjectType())) {\n+        if (checkType(te)) {\n@@ -1190,0 +1179,5 @@\n+    private boolean checkType(TypeElement te) {\n+        return isInterface(te) || typeUtils.isSameType(te.asType(), getObjectType())\n+                || isAnnotationType(te);\n+    }\n+\n@@ -1191,2 +1185,1 @@\n-        if (isAnnotationType(te) || isInterface(te) ||\n-                te.asType().equals(getObjectType())) {\n+        if (checkType(te)) {\n@@ -1205,1 +1198,0 @@\n-\n@@ -1216,1 +1208,1 @@\n-     *         be found..\n+     *         be found.\n@@ -1236,1 +1228,1 @@\n-        if (te.asType().equals(superType)) {\n+        if (typeUtils.isSameType(te.asType(), superType)) {\n@@ -1484,4 +1476,8 @@\n-    \/**\n-     * Returns true if the method has no comments, or a lone &commat;inheritDoc.\n-     * @param m a method\n-     * @return true if there are no comments, false otherwise\n+    \/*\n+     * Returns true if the passed method does not change the specification it\n+     * inherited.\n+     *\n+     * If the passed method is not deprecated and has either no comment or a\n+     * comment consisting of single {@inheritDoc} tag, the inherited\n+     * specification is deemed unchanged and this method returns true;\n+     * otherwise this method returns false.\n@@ -2595,1 +2591,1 @@\n-     * The entries may come from the AST and DocCommentParser, or may be autromatically\n+     * The entries may come from the AST and DocCommentParser, or may be automatically\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":77,"deletions":81,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+import java.util.Collection;\n@@ -66,1 +67,1 @@\n- * javax.lang.models view of what can be documented about a\n+ * javax.lang.model's view of what can be documented about a\n@@ -71,1 +72,1 @@\n- * Members: these are the members from jx.l.m's view but\n+ * Members: these are the members from j.l.m's view but\n@@ -149,2 +150,2 @@\n-    final TypeElement te;\n-    final TypeElement parent;\n+    private final TypeElement te;\n+    private final TypeElement parent;\n@@ -152,4 +153,4 @@\n-    final BaseConfiguration config;\n-    final BaseOptions options;\n-    final Utils utils;\n-    final VisibleMemberCache mcache;\n+    private final BaseConfiguration config;\n+    private final BaseOptions options;\n+    private final Utils utils;\n+    private final VisibleMemberCache mcache;\n@@ -161,1 +162,1 @@\n-    private Map<Kind, List<Element>> visibleMembers = null;\n+    private Map<Kind, List<Element>> visibleMembers;\n@@ -165,1 +166,1 @@\n-    Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n+    private final Map<ExecutableElement, OverriddenMethodInfo> overriddenMethodTable\n@@ -181,1 +182,1 @@\n-    private synchronized void ensureInitialized() {\n+    private void ensureInitialized() {\n@@ -211,1 +212,1 @@\n-     * sole &commat;inheritDoc or devoid of any API comments.\n+     * sole {@code @inheritDoc} or devoid of any API comments.\n@@ -282,1 +283,1 @@\n-            return found.overridden;\n+            return found.overriddenMethod;\n@@ -288,1 +289,3 @@\n-     * Returns the simply overridden method.\n+     * {@return true if the specified method is NOT a simple override of some\n+     * other method, otherwise false}\n+     *\n@@ -290,1 +293,0 @@\n-     * @return the overridden method or null\n@@ -292,1 +294,1 @@\n-    public ExecutableElement getSimplyOverriddenMethod(ExecutableElement e) {\n+    public boolean isNotSimpleOverride(ExecutableElement e) {\n@@ -295,5 +297,2 @@\n-        OverriddenMethodInfo found = overriddenMethodTable.get(e);\n-        if (found != null && found.simpleOverride) {\n-            return found.overridden;\n-        }\n-        return null;\n+        var info = overriddenMethodTable.get(e);\n+        return info == null || !info.simpleOverride;\n@@ -309,1 +308,1 @@\n-     * @return the list of visible classes in this map.\n+     * @return the set of visible classes in this map\n@@ -530,4 +529,3 @@\n-            pvmt.overriddenMethodTable.entrySet().forEach(e -> {\n-                OverriddenMethodInfo p = e.getValue();\n-                if (!p.simpleOverride) { \/\/ consider only real overrides\n-                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(p.overridden,\n+            pvmt.overriddenMethodTable.forEach((method, methodInfo) -> {\n+                if (!methodInfo.simpleOverride) { \/\/ consider only real overrides\n+                    List<ExecutableElement> list = overriddenByTable.computeIfAbsent(methodInfo.overriddenMethod,\n@@ -535,1 +533,1 @@\n-                    list.add(e.getKey());\n+                    list.add(method);\n@@ -547,1 +545,1 @@\n-        \/\/ members of the overridenMethodTable field, so it must be\n+        \/\/ members of the overriddenMethodTable field, so it must be\n@@ -568,1 +566,1 @@\n-        List<Element> list = Stream.concat(localStream,inheritedMethodsList.stream())\n+        List<Element> list = Stream.concat(localStream, inheritedMethodsList.stream())\n@@ -578,1 +576,0 @@\n-        overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);\n@@ -853,1 +850,1 @@\n-                    .map(e -> clazz.cast(e))\n+                    .map(clazz::cast)\n@@ -970,1 +967,2 @@\n-    Map<ExecutableElement, SoftReference<ImplementedMethods>> implementMethodsFinders = new HashMap<>();\n+    private final Map<ExecutableElement, SoftReference<ImplementedMethods>>\n+            implementMethodsFinders = new HashMap<>();\n@@ -986,1 +984,1 @@\n-                .filter(m -> getSimplyOverriddenMethod(m) == null)\n+                .filter(this::isNotSimpleOverride)\n@@ -999,1 +997,1 @@\n-        private final List<ExecutableElement> methlist = new ArrayList<>();\n+        private final LinkedHashSet<ExecutableElement> methods = new LinkedHashSet<>();\n@@ -1002,1 +1000,3 @@\n-            TypeElement typeElement = utils.getEnclosingTypeElement(method);\n+            \/\/ ExecutableElement.getEnclosingElement() returns \"the class or\n+            \/\/ interface defining the executable\", which has to be TypeElement\n+            TypeElement typeElement = (TypeElement) method.getEnclosingElement();\n@@ -1004,7 +1004,0 @@\n-            \/*\n-             * Search for the method in the list of interfaces. If found check if it is\n-             * overridden by any other subinterface method which this class\n-             * implements. If it is not overridden, add it in the method list.\n-             * Do this recursively for all the extended interfaces for each interface\n-             * from the list.\n-             *\/\n@@ -1012,0 +1005,2 @@\n+                \/\/ TODO: this method also finds static methods which are pseudo-inherited;\n+                \/\/  this needs to be fixed\n@@ -1013,6 +1008,3 @@\n-                if (found != null) {\n-                    removeOverriddenMethod(found);\n-                    if (!overridingMethodFound(found)) {\n-                        methlist.add(found);\n-                        interfaces.put(found, interfaceType);\n-                    }\n+                if (found != null && !methods.contains(found)) {\n+                    methods.add(found);\n+                    interfaces.put(found, interfaceType);\n@@ -1024,1 +1016,1 @@\n-         * Return the list of interface methods which the method passed in the\n+         * Returns a collection of interface methods which the method passed in the\n@@ -1031,1 +1023,1 @@\n-         *<\/pre>\n+         * <\/pre>\n@@ -1033,1 +1025,1 @@\n-         * @return SortedSet<ExecutableElement> of implemented methods.\n+         * @return a collection of implemented methods\n@@ -1035,2 +1027,2 @@\n-        List<ExecutableElement> getImplementedMethods() {\n-            return methlist;\n+        Collection<ExecutableElement> getImplementedMethods() {\n+            return methods;\n@@ -1042,45 +1034,0 @@\n-\n-        \/**\n-         * Search in the method list and check if it contains a method which\n-         * is overridden by the method as parameter.  If found, remove the\n-         * overridden method from the method list.\n-         *\n-         * @param method Is this method overriding a method in the method list.\n-         *\/\n-        private void removeOverriddenMethod(ExecutableElement method) {\n-            TypeElement overriddenClass = utils.overriddenClass(method);\n-            if (overriddenClass != null) {\n-                for (int i = 0; i < methlist.size(); i++) {\n-                    TypeElement te = utils.getEnclosingTypeElement(methlist.get(i));\n-                    if (te == overriddenClass || utils.isSubclassOf(overriddenClass, te)) {\n-                        methlist.remove(i);  \/\/ remove overridden method\n-                        return;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Search in the already found methods' list and check if it contains\n-         * a method which is overriding the method parameter or is the method\n-         * parameter itself.\n-         *\n-         * @param method method to be searched\n-         *\/\n-        private boolean overridingMethodFound(ExecutableElement method) {\n-            TypeElement containingClass = utils.getEnclosingTypeElement(method);\n-            for (ExecutableElement listmethod : methlist) {\n-                if (containingClass == utils.getEnclosingTypeElement(listmethod)) {\n-                    \/\/ it's the same method.\n-                    return true;\n-                }\n-                TypeElement te = utils.overriddenClass(listmethod);\n-                if (te == null) {\n-                    continue;\n-                }\n-                if (te == containingClass || utils.isSubclassOf(te, containingClass)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n@@ -1089,17 +1036,2 @@\n-    \/**\n-     * A simple container to encapsulate an overridden method\n-     * and the type of override.\n-     *\/\n-    static class OverriddenMethodInfo {\n-        final ExecutableElement overridden;\n-        final boolean simpleOverride;\n-\n-        public OverriddenMethodInfo(ExecutableElement overridden, boolean simpleOverride) {\n-            this.overridden = overridden;\n-            this.simpleOverride = simpleOverride;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"OverriddenMethodInfo[\" + overridden + \",simple:\" + simpleOverride + \"]\";\n-        }\n+    private record OverriddenMethodInfo(ExecutableElement overriddenMethod,\n+                                        boolean simpleOverride) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java","additions":48,"deletions":116,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,1 +154,1 @@\n-                                    bound.equals(utils.getObjectType()) &&\n+                                    utils.typeUtils.isSameType(bound, utils.getObjectType()) &&\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/LinkFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -1302,3 +1302,3 @@\n-        checkInheritence(Grandpa.class, true, true);\n-        checkInheritence(Dad.class,     true, false);\n-        checkInheritence(Son.class,     true, true);\n+        checkInheritance(Grandpa.class, true, true);\n+        checkInheritance(Dad.class,     true, false);\n+        checkInheritance(Son.class,     true, true);\n@@ -3534,1 +3534,1 @@\n-    static void checkInheritence(AnnotatedElement e, boolean shouldHaveFoo, boolean shouldHaveBar) {\n+    static void checkInheritance(AnnotatedElement e, boolean shouldHaveFoo, boolean shouldHaveBar) {\n","filename":"test\/jdk\/java\/lang\/annotation\/UnitTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,2 @@\n- * In otherwords the TypeParameter in scope should be used ex: Interface<IE>, Parent<PE>\n-   and Child<CE>\n+ * In other words the TypeParameter in scope should be used ex: Interface<IE>, Parent<PE>\n+ * and Child<CE>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        public void foo();\n+    public void foo();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I2.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        public void foo();\n+    public void foo();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I3.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-        public void foo();\n+    public void foo();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I4.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    public static class P<K, V> extends GP {\n+   public static class P<K, V> extends GP {\n@@ -38,2 +38,2 @@\n-       \/** A nested class in parent *\/\n-       public class PN<K, V>{}\n+      \/** A nested class in parent *\/\n+      public class PN<K, V>{}\n@@ -41,5 +41,5 @@\n-       \/** A property in parent *\/\n-       private DoubleProperty rate;\n-       public final void setRate(double l){}\n-       public final double getRate(){return 1;}\n-       public DoubleProperty rateProperty() {return null;}\n+      \/** A property in parent *\/\n+      private DoubleProperty rate;\n+      public final void setRate(double l){}\n+      public final double getRate(){return 1;}\n+      public DoubleProperty rateProperty() {return null;}\n@@ -47,2 +47,2 @@\n-        \/** A ctor in parent *\/\n-       public P() {}\n+      \/** A ctor in parent *\/\n+      public P() {}\n@@ -50,5 +50,5 @@\n-       \/**\n-        * A ctor in parent.\n-        * @param s string\n-        *\/\n-       public P(String s) {}\n+      \/**\n+       * A ctor in parent.\n+       * @param s string\n+       *\/\n+      public P(String s) {}\n@@ -56,2 +56,2 @@\n-       \/** field0 in parent *\/\n-       public int field0;\n+      \/** field0 in parent *\/\n+      public int field0;\n@@ -59,2 +59,2 @@\n-       \/** field1 in parent *\/\n-       public int field1;\n+      \/** field1 in parent *\/\n+      public int field1;\n@@ -63,30 +63,2 @@\n-       \/\/ m0 in parent\n-       public void m0() {}\n-\n-       \/** m1 in parent *\/\n-       public void m1() {}\n-\n-       \/** m2 in parent *\/\n-       public void m2() {}\n-\n-       \/** m3 in parent *\/\n-       public void m3() {}\n-\n-       \/** m4 in parent\n-           @param k a key\n-           @param v a value\n-        *\/\n-       public void m4(K k, V v) {}\n-\n-       \/\/ No comment\n-       public void m5() {}\n-\n-       \/\/ No comment\n-       public void m6() {}\n-\n-        \/** {@inheritDoc} *\/\n-        public void m7() {}\n-\n-    }\n-\n-    public static class C extends P {\n+      \/\/ m0 in parent\n+      public void m0() {}\n@@ -94,1 +66,2 @@\n-       public C(String s) {}\n+      \/** m1 in parent *\/\n+      public void m1() {}\n@@ -96,1 +69,2 @@\n-       public int field1;\n+      \/** m2 in parent *\/\n+      public void m2() {}\n@@ -98,2 +72,2 @@\n-       \/** A modified method *\/\n-       public void m1() {}\n+      \/** m3 in parent *\/\n+      public void m3() {}\n@@ -101,2 +75,5 @@\n-       \/** {@inheritDoc} *\/\n-       public void m2() {}\n+      \/** m4 in parent\n+       @param k a key\n+       @param v a value\n+       *\/\n+      public void m4(K k, V v) {}\n@@ -104,2 +81,2 @@\n-       \/\/ No comment method\n-       public void m3() {}\n+      \/\/ No comment\n+      public void m5() {}\n@@ -107,1 +84,2 @@\n-       public void m4(String k, String v) {}\n+      \/\/ No comment\n+      public void m6() {}\n@@ -109,2 +87,2 @@\n-       \/\/ Do something else than the parent\n-       public void m5() {}\n+      \/** {@inheritDoc} *\/\n+      public void m7() {}\n@@ -112,21 +90,1 @@\n-       \/** A test of links to the methods in this class. <p>\n-        * {@link m0},\n-        * {@link m1},\n-        * {@link m2},\n-        * {@link m3},\n-        * {@link m4},\n-        * {@link m5},\n-        * {@link m6},\n-        * {@link m7},\n-        * End of links\n-        *\n-        * @see #m0()\n-        * @see #m1()\n-        * @see #m2()\n-        * @see #m3()\n-        * @see #m4(String k, String v)\n-        * @see #m5()\n-        * @see #m6()\n-        * @see #m7()\n-        *\/\n-       public void m6() {}\n+   }\n@@ -134,3 +92,45 @@\n-        \/** m7 in Child. *\/\n-        public void m7() {}\n-    }\n+   public static class C extends P {\n+\n+      public C(String s) {}\n+\n+      public int field1;\n+\n+      \/** A modified method *\/\n+      public void m1() {}\n+\n+      \/** {@inheritDoc} *\/\n+      public void m2() {}\n+\n+      \/\/ No comment method\n+      public void m3() {}\n+\n+      public void m4(String k, String v) {}\n+\n+      \/\/ Do something else than the parent\n+      public void m5() {}\n+\n+      \/** A test of links to the methods in this class. <p>\n+       * {@link m0},\n+       * {@link m1},\n+       * {@link m2},\n+       * {@link m3},\n+       * {@link m4},\n+       * {@link m5},\n+       * {@link m6},\n+       * {@link m7},\n+       * End of links\n+       *\n+       * @see #m0()\n+       * @see #m1()\n+       * @see #m2()\n+       * @see #m3()\n+       * @see #m4(String k, String v)\n+       * @see #m5()\n+       * @see #m6()\n+       * @see #m7()\n+       *\/\n+      public void m6() {}\n+\n+      \/** m7 in Child. *\/\n+      public void m7() {}\n+   }\n@@ -138,2 +138,2 @@\n-    \/** Tickle this {@link TestEnum#doSomething()} *\/\n-    public class DoubleProperty {}\n+   \/** Tickle this {@link TestEnum#doSomething()} *\/\n+   public class DoubleProperty {}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg5\/Classes.java","additions":87,"deletions":87,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-     public interface A {\n+    public interface A {\n@@ -29,2 +29,2 @@\n-         \/** field f in A *\/\n-         public int f = 0;\n+        \/** field f in A *\/\n+        public int f = 0;\n@@ -32,1 +32,1 @@\n-         public static String QUOTE = \"Winter is coming\";\n+        public static String QUOTE = \"Winter is coming\";\n@@ -34,2 +34,2 @@\n-         \/** a documented static method *\/\n-         public static void msd() {}\n+        \/** a documented static method *\/\n+        public static void msd() {}\n@@ -37,2 +37,2 @@\n-         \/* An undocumented static method *\/\n-         public static void msn() {}\n+        \/* An undocumented static method *\/\n+        public static void msn() {}\n@@ -40,7 +40,7 @@\n-         \/** A property in parent *\/\n-         DoubleProperty rate = null;\n-         public void setRate(double l);\n-         public double getRate();\n-         public DoubleProperty rateProperty();\n-         \/\/ A support class\n-         public interface DoubleProperty {}\n+        \/** A property in parent *\/\n+        DoubleProperty rate = null;\n+        public void setRate(double l);\n+        public double getRate();\n+        public DoubleProperty rateProperty();\n+        \/\/ A support class\n+        public interface DoubleProperty {}\n@@ -48,2 +48,2 @@\n-         \/** AA in A *\/\n-         public interface AA {}\n+        \/** AA in A *\/\n+        public interface AA {}\n@@ -51,2 +51,2 @@\n-         \/** m0 in A *\/\n-         public void m0();\n+        \/** m0 in A *\/\n+        public void m0();\n@@ -54,2 +54,2 @@\n-         \/** m1 in A *\/\n-         public void m1();\n+        \/** m1 in A *\/\n+        public void m1();\n@@ -57,2 +57,2 @@\n-         \/** m2 in A *\/\n-         public void m2();\n+        \/** m2 in A *\/\n+        public void m2();\n@@ -60,3 +60,3 @@\n-         \/** m3 in A *\/\n-         public void m3();\n-     }\n+        \/** m3 in A *\/\n+        public void m3();\n+    }\n@@ -64,3 +64,3 @@\n-     public interface B extends A {\n-         \/\/ No comment\n-         public void m0();\n+    public interface B extends A {\n+        \/\/ No comment\n+        public void m0();\n@@ -68,2 +68,2 @@\n-         \/** m1 in B *\/\n-         public void m1();\n+        \/** m1 in B *\/\n+        public void m1();\n@@ -71,2 +71,2 @@\n-         \/** {@inheritDoc} *\/\n-         public void m2();\n+        \/** {@inheritDoc} *\/\n+        public void m2();\n@@ -74,2 +74,2 @@\n-         \/** @throws Exception e *\/\n-         public void m3() throws Exception;\n+        \/** @throws Exception e *\/\n+        public void m3() throws Exception;\n@@ -77,3 +77,3 @@\n-         \/** n in B *\/\n-         public void n();\n-     }\n+        \/** n in B *\/\n+        public void n();\n+    }\n@@ -81,3 +81,3 @@\n-     public interface C extends A, B  {\n-         \/** m in C *\/\n-         public void m();\n+    public interface C extends A, B  {\n+        \/** m in C *\/\n+        public void m();\n@@ -85,3 +85,3 @@\n-         \/** o in C *\/\n-         public void o();\n-     }\n+        \/** o in C *\/\n+        public void o();\n+    }\n@@ -111,2 +111,2 @@\n-         \/** m in D *\/\n-         public void m();\n+        \/** m in D *\/\n+        public void m();\n@@ -114,2 +114,2 @@\n-         \/** n in D *\/\n-         public void n();\n+        \/** n in D *\/\n+        public void n();\n@@ -117,4 +117,4 @@\n-         \/\/ no comment\n-         public void o();\n-     }\n- }\n+        \/\/ no comment\n+        public void o();\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg5\/Interfaces.java","additions":53,"deletions":53,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,0 @@\n-\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg6\/Sub.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-                \/\/ Field inheritence from non-public superclass.\n+                \/\/ Field inheritance from non-public superclass.\n@@ -159,1 +159,1 @@\n-                \/\/ Field inheritence from non-public superclass.\n+                \/\/ Field inheritance from non-public superclass.\n@@ -164,1 +164,1 @@\n-                \/\/ Method inheritence from non-public superclass.\n+                \/\/ Method inheritance from non-public superclass.\n@@ -198,1 +198,1 @@\n-                \/\/ Field inheritence from non-public superinterface.\n+                \/\/ Field inheritance from non-public superinterface.\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     4496223 4496270 4618686 4720974 4812240 6253614 6253604\n+ * @summary <DESC>\n+ * @library ..\/..\/lib\n+ * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build javadoc.tester.*\n+ * @run main TestTagInheritance\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+\n+public class TestTagInheritance extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        TestTagInheritance tester = new TestTagInheritance();\n+        tester.runTests();\n+    }\n+\n+    @Test\n+    public void test() {\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", \"out\",\n+                \"-sourcepath\", testSrc,\n+                \"pkg\", \"firstSentence\", \"firstSentence2\");\n+        checkExit(Exit.OK);\n+\n+        \/\/Test bad inheritDoc tag warning.\n+        checkOutput(Output.OUT, true,\n+                \"warning: @inheritDoc used but testBadInheritDocTag() \"\n+                + \"does not override or implement any method.\");\n+\n+        \/\/Test valid usage of inheritDoc tag.\n+        for (int i = 1; i < 40; i++) {\n+            checkOutput(\"pkg\/TestTagInheritance.html\", true,\n+                    \"Test \" + i + \" passes\");\n+        }\n+\n+        \/\/First sentence test (6253614)\n+        checkOutput(\"firstSentence\/B.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence.<\/div>\"\"\");\n+\n+        \/\/Another first sentence test (6253604)\n+        checkOutput(\"firstSentence2\/C.html\", true,\n+                \"\"\"\n+                    <div class=\"block\">First sentence.<\/div>\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritance.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug     4496223 4496270 4618686 4720974 4812240 6253614 6253604\n- * @summary <DESC>\n- * @library ..\/..\/lib\n- * @modules jdk.javadoc\/jdk.javadoc.internal.tool\n- * @build javadoc.tester.*\n- * @run main TestTagInheritence\n- *\/\n-\n-\/\/ TODO: Inheritence should be Inheritance!   fix separately as noreg-trivial\n-import javadoc.tester.JavadocTester;\n-\n-public class TestTagInheritence extends JavadocTester {\n-\n-    public static void main(String... args) throws Exception {\n-        TestTagInheritence tester = new TestTagInheritence();\n-        tester.runTests();\n-    }\n-\n-    @Test\n-    public void test() {\n-        javadoc(\"-Xdoclint:none\",\n-                \"-d\", \"out\",\n-                \"-sourcepath\", testSrc,\n-                \"pkg\", \"firstSentence\", \"firstSentence2\");\n-        checkExit(Exit.OK);\n-\n-        \/\/Test bad inheritDoc tag warning.\n-        checkOutput(Output.OUT, true,\n-                \"warning: @inheritDoc used but testBadInheritDocTag() \"\n-                + \"does not override or implement any method.\");\n-\n-        \/\/Test valid usage of inheritDoc tag.\n-        for (int i = 1; i < 40; i++) {\n-            checkOutput(\"pkg\/TestTagInheritence.html\", true,\n-                    \"Test \" + i + \" passes\");\n-        }\n-\n-        \/\/First sentence test (6253614)\n-        checkOutput(\"firstSentence\/B.html\", true,\n-                \"\"\"\n-                    <div class=\"block\">First sentence.<\/div>\"\"\");\n-\n-        \/\/Another first sentence test (6253604)\n-        checkOutput(\"firstSentence2\/C.html\", true,\n-                \"\"\"\n-                    <div class=\"block\">First sentence.<\/div>\"\"\");\n-    }\n-}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritence.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-public class TestTagInheritence extends TestAbstractClass implements TestInterface{\n+public class TestTagInheritance extends TestAbstractClass implements TestInterface{\n@@ -31,1 +31,1 @@\n-  \/\/This method below tests tag inheritence from a class.\n+  \/\/This method below tests tag inheritance from a class.\n@@ -60,1 +60,1 @@\n-   * This method tests @inheritDoc with an inteface.  Here is the inherited comment:<br>\n+   * This method tests @inheritDoc with an interface.  Here is the inherited comment:<br>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/pkg\/TestTagInheritance.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/pkg\/TestTagInheritence.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/C.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/C.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/Foo.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/Foo.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/I.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/I.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/Iface.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/Iface.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * @run main TestThrowsTagInheritence\n+ * @run main TestThrowsTagInheritance\n@@ -36,1 +36,0 @@\n-\/\/ TODO: should be TestThrowsInheritance!\n@@ -39,1 +38,1 @@\n-public class TestThrowsTagInheritence extends JavadocTester {\n+public class TestThrowsTagInheritance extends JavadocTester {\n@@ -42,1 +41,1 @@\n-        TestThrowsTagInheritence tester = new TestThrowsTagInheritence();\n+        TestThrowsTagInheritance tester = new TestThrowsTagInheritance();\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/TestThrowsTagInheritance.java","additions":4,"deletions":5,"binary":false,"changes":9,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/TestThrowsTagInheritence.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Abstract.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/pkg\/Abstract.java","status":"renamed"},{"patch":"","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Extender.java","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritence\/pkg\/Extender.java","status":"renamed"}]}