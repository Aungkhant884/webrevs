[{"commit":{"message":"Fix ImplementedMethods.overridingMethodFound\n\nRemoves code from VisibleMemberTable.ImplementedMethods.overridingMethodFound; the removed code is dead for the reasons similar to those in the previous commit. This commit makes overridingMethodFound degrade to linear search, which could be substituted with hashing in a later commit."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"ad9b62731095fe5247466414dfea45c55d7cde47"},{"commit":{"message":"Remove ImplementedMethods::removeOverriddenMethod\n\nFirst of all, this commit has been tested and the before and after JDK API Documentation compared.\n\n`removeOverriddenMethod` does not seem to do any visible work and only confuses the reader. Here are some problems, all of which has been confirmed while debugging. Hopefully, the bellow bullet points in conjunction with the source code will help you see these problems.\n\nOutside:\n\n1. `removeOverriddenMethod` is private and is only used in one place: VisibleMemberTable.java:1015\n2. `VisibleMemberTable` passes `removeOverriddenMethod` with a direct interface method, an interface method that is either defined or overridden by an interface, but not passively inherited.\n\nInside:\n\n1. `overriddenClass` is either a class that first defined a method that the passed `method` overrides, or `null` if there's no such class.\n2. `overriddenClass` is searched for recursively, using only supertypes.\n3. Regardless of any interfaces it might extend, an interface's supertype is `java.lang.Object`; see, for example, `javax.lang.model.element.TypeElement#getSuperclass`.\n4. `method` belongs to an interface; see \"Outside\" (2).\n5. Given 1-4, the only class `overriddenClass` can be is `java.lang.Object`. This can happen, for example, if `method` is an interface-override of one of the methods defined in `java.lang.Object`. Typically those are `equals`, `hashCode` or `toString`.\n7. `isSubclassOf(a, b)` checks if `a` is a subtype of `b`.\n8. Since `a` is `java.lang.Object`, condition `b == a || isSubclassOf(a, b)` can be `true` only if `b` is also `java.lang.Object`. `java.lang.Object` is not a subclass of anything but itself.\n9. `b` can never be a class, let alone `java.lang.Object`. This is because `b` is an immediately enclosing type of an interface method (by construction of `methlist`), i.e. `b` is an interface.\n10. So the above check always fails, which means that `methlist.remove(i)` is never executed."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"fb1dc89ef5eaf40d029ca4affbed33644468b853"},{"commit":{"message":"Simplify VisibleMemberTable.ImplementedMethods\n\nAlso adds a TODO to remind us to investigate an important issue later; either in this or a follow-up PR."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"5585d95d23da22749eaae4bac67c760ce675a83e"},{"commit":{"message":"Fix confusing doc"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"2c162a1482598cfcbc7d6a5e6e9de56051fce335"},{"commit":{"message":"Merge branch 'master' into 8280713"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"1bafd6056f1823e8ae3d32da19cdee450feafcef"},{"commit":{"message":"Refine overriddenType(ExecutableElement)\n\nMakes it clear that the returned TypeMirror is DeclaredType which represents a class and never an interface."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"aee8e7d4c57221e889d51a229af1a18c9e5f936a"},{"commit":{"message":"Refactor how superinterfaces are collected\n\nImproves readability of Utils.getAllInterfaces and friends."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"65caedcb12011a346d8581e559c8704b11b44e3f"},{"commit":{"message":"Fix a typo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"252acbc47870d2130d94bbeca4d6d34e6c87e8d1"},{"commit":{"message":"Improve readability of VMT.getImplementedMethods\n\nGoing forward, we should probably change the term \"simple\" to something more appropriate. Using \"simple\" to describe an override that does not change the parent specification, does not cut it. If nothing else, the term should be defined (as well as its opposite: \"complex\"?) in the VisibleMemberTable's vocabulary."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"99da8c679a50fb739d77dce499c3f060ae8ec00b"},{"commit":{"message":"Modernize some switches in Utils"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"35a0e7c4bca7c855c2dc16862a1e3024dbc0f047"},{"commit":{"message":"Merge branch 'master' into 8280713"},"files":[],"sha":"382a202c24d7413d9f6766f4214fb371e1dcb348"},{"commit":{"message":"Fix indentation and typos\n\nAlso updates copyright years in some of the files previously touched in this branch."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/ClassBuilder.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/LinkFactory.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I2.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I3.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg3\/I4.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg5\/Classes.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg5\/Interfaces.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testOverriddenMethods\/pkg6\/Sub.java"}],"sha":"71ce63cf4f8fe678b4f63d1abe38d46eff0edb24"},{"commit":{"message":"Check type mirrors for equality correctly\n\nTypeMirror t1, t2 should be checked for equality using javax.lang.model.util.Types.isSameType(t1, t2), not t1.equals(t2). Unless any of t1 or t2 are wildcards, it is the case that t1.equals(t2) implies that isSameType(t1, t2).\n\nFor example, instances of Type$ErasedClassType and Type$ClassType that represent java.lang.Object aren't equal but are the same."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriterImpl.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/taglets\/ThrowsTaglet.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/links\/LinkFactory.java"}],"sha":"a8832ad3fa03b87c8f7bf86a0b4df07f4dbc2fb0"},{"commit":{"message":"Fix a typo"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"32e61c4df12abb6246c381f09fe2cdf14b07d715"},{"commit":{"message":"Further clarify comments for isSimpleOverride"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseOptions.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"c183be29dc1e30a3bc691565859bcbcc35c197ca"},{"commit":{"message":"Further clarify comments for overriddenType\n\nAlso fixes the bugs introduced in an earlier commit (4e2706d2)."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"aad7b6c4ab890fe43c164b898b3e7a1b371ace50"},{"commit":{"message":"Merge branch 'master' into 8280713"},"files":[],"sha":"38a12dff9a37d7531d209d6d8f2cf2635a205156"},{"commit":{"message":"Clarify comments for overriddenType\n\n - Removes confusing part of the comment that claims that overriddenType can return TypeParameterElement (this might be an error in translation from JDK 8: ParameterizedType as TypeParameterElement).\n - Clarifies Utils.isSimpleOverride\n - Downgrades doc comments to block comments"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"4e2706d2a5bfc70bcc1c75a898ffedf41acb7d55"},{"commit":{"message":"Fix spelling\n\nChanges _inheritEnce_ to _inheritAnce_ where it does not have side effects such as referring to a like-named misspelled JBS bug (e.g. test\/langtools\/tools\/javac\/GoodCovar.java and the respective JDK-5034529). Note, that in some cases the names of the misspelled tests appear in the respective bug's comments."},"files":[{"filename":"test\/jdk\/java\/lang\/annotation\/UnitTest.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPrivateClasses\/TestPrivateClasses.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritance.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/TestTagInheritence.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTagInheritence\/pkg\/TestTagInheritance.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/C.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/Foo.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/I.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/Iface.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/TestThrowsTagInheritance.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Abstract.java"},{"filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrowsInheritance\/pkg\/Extender.java"}],"sha":"3739b2a6a8233ba26ec848e72dd18f54eac6988f"},{"commit":{"message":"Improve readability of WorkArounds.overriddenType\n\nLeverages imports."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/WorkArounds.java"}],"sha":"c5f8f7a632c34d164fdc962a25048584100686f2"},{"commit":{"message":"Fix and simplify executableMembersEqual\n\nInstances of VariableElement should be compared using their types, not their type FQNs. For a type variable v, its FQN ( getTypeName(v.asType(), true) ) seems to degrade to the variable name. For example, when comparing static Set.of(E) to static EnumSet.of(E), executableMembersEqual used to return true because it didn't consider the type of Es. Although variables are called the same (E), for Set.of E is anything, whereas for EnumSet.of E is an enum."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"592595a65ca8dcaa38c7c73dfb9ffbafd57496ee"},{"commit":{"message":"Remove useless synchronization"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java"},{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/UncheckedDocletException.java"}],"sha":"d753182d127d412246095b92cc34c85f86609ce1"},{"commit":{"message":"Fix equality check in Utils.getAllInterfaces\n\nInstances of TypeMirror t1, t2 should be compared using javax.lang.model.util.Types.isSameType(t1, t2), not t1.equals(t2) let alone t1 == t2."},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"98cd21f2a1fdc0dd234d12e117c66abbfb8d82db"},{"commit":{"message":"Clean up Utils.getSymbol and friends\n\n - Makes symbol table `final` and simplifies its computation mechanics\n - Indents getThrowableType for consistentcy with similar methods"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java"}],"sha":"83040e53e3ea237a39d81fc49fd41547b9130ffc"},{"commit":{"message":"Initial commit\n\n - Makes VisibleMemberTable's fields `private` and `final` where possible\n - Removes `synchronized` from the ensureInitialized method as useless and confusing\n - Makes OverriddenMethodInfo a record and renames its components\n - Adds minor code improvements and fixes a few doc comment issues"},"files":[{"filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/VisibleMemberTable.java"}],"sha":"785282124b4127fc9597852a686845c78a67f472"}]