{"files":[{"patch":"@@ -83,0 +83,2 @@\n+#define EMPTY(ARG)        (0-ARG-1)==1 && (ARG+0)!=-2\n+\n@@ -89,1 +91,1 @@\n-#if IS_EMPTY_VALUE(VERSION_BUILD)\n+#if EMPTY(VERSION_BUILD)\n@@ -95,0 +97,2 @@\n+#undef EMPTY\n+\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,23 +28,0 @@\n-\/\/ For detecting in the preprocessor whether a macro definition is empty.\n-\/\/ Although it's meant for checking macro values, it can also be used on\n-\/\/ macros defined to identifiers or even C++ keywords, but it's not\n-\/\/ recommended that you use it in the latter case. For macros defined to\n-\/\/ raw C++ syntax (such as , . { or &) it will not work properly, if at\n-\/\/ all, since that is not what it is intended for.\n-\/\/\n-\/\/ - When the macro is defined but empty, it expands to ~(~+ 0) == 0 &&\n-\/\/ ~(~+ 1) == 1, which works out 0 == 0 && 1 == 1 (the double negation ~~\n-\/\/ being an identity operator).\n-\/\/ - When the macro is defined to a numeric value, say n, it expands to\n-\/\/ ~(~n + 0) == 0 && ~(~n + 1) == 1. On the left hand side of &&, the\n-\/\/ expression ~(~n + 0) == 0 evaluates to n == 0. But with n == 0, the\n-\/\/ right hand side evaluates to ~(~0 + 1) == 1, with ~0 being - 1 to\n-\/\/ ~(-1 + 1) == 1, then ~0 == 1 and finally - 1 == 1, which obviously\n-\/\/ is false.\n-\/\/ - When the macro is defined to a non - numeric value, the preprocessor\n-\/\/ reduces all unknown symbols to 0, and we get the previous case with n == 0\n-\/\/ once more. This works even for C++ keywords.\n-\/\/\n-\/\/ Weakness: This does not work with string literals or empty chars.\n-#define IS_EMPTY_VALUE(VALUE) ~(~VALUE + 0) == 0 && ~(~VALUE + 1) == 1\n-\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"}]}