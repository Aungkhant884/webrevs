{"files":[{"patch":"@@ -33,2 +33,2 @@\n-#define MATERIALIZE_COUNTER(name)          uint64_t InternalStats::_##name;\n-#define MATERIALIZE_ATOMIC_COUNTER(name)   volatile uint64_t InternalStats::_##name;\n+#define MATERIALIZE_COUNTER(name)          uintx InternalStats::_##name;\n+#define MATERIALIZE_ATOMIC_COUNTER(name)   volatile uintx InternalStats::_##name;\n@@ -44,1 +44,1 @@\n-#define PRINT_COUNTER(name)  st->print_cr(\"%s: \" UINT64_FORMAT \".\", xstr(name), _##name);\n+#define PRINT_COUNTER(name)  st->print_cr(\"%s: \" UINTX_FORMAT \".\", xstr(name), _##name);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/internalStats.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -98,2 +98,5 @@\n-#define DEFINE_COUNTER(name)          static uint64_t _##name;\n-#define DEFINE_ATOMIC_COUNTER(name)   static volatile uint64_t _##name;\n+\/\/ Note: We use uintx since 32bit platforms lack 64bit atomic add; this increases\n+\/\/  the possibility of counter overflows but the probability is very low for any counter\n+\/\/  but num_allocs; note that these counters are for human eyes only.\n+#define DEFINE_COUNTER(name)          static uintx _##name;\n+#define DEFINE_ATOMIC_COUNTER(name)   static volatile uintx _##name;\n","filename":"src\/hotspot\/share\/memory\/metaspace\/internalStats.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}