{"files":[{"patch":"@@ -482,2 +482,2 @@\n-  return metaspace::MetaspaceContext::context_nonclass() != NULL &&\n-      (using_class_space() ? Metaspace::class_space_is_initialized() : true);\n+  return metaspace::MetaspaceContext::context_nonclass() != NULL\n+      LP64_ONLY(&& (using_class_space() ? Metaspace::class_space_is_initialized() : true));\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -88,7 +88,0 @@\n-  \/\/ a mask to speed up searching for populated lists.\n-  \/\/ 0 marks an empty list, 1 for a non-empty one.\n-  typedef uint32_t mask_t;\n-  STATIC_ASSERT(num_lists <= sizeof(mask_t) * 8);\n-\n-  mask_t _mask;\n-\n@@ -97,1 +90,0 @@\n-\n@@ -129,11 +121,2 @@\n-    mask_t m = _mask >> i2;\n-    if (m > 0) {\n-      while ((m & 1) == 0) {\n-        assert(_blocks[i2] == NULL, \"mask mismatch\");\n-        i2++;\n-        m >>= 1;\n-      }\n-      \/\/ We must have found something.\n-      assert(i2 < num_lists, \"sanity.\");\n-      assert(_blocks[i2] != NULL, \"mask mismatch\");\n-      return i2;\n+    while (i2 < num_lists && _blocks[i2] == NULL) {\n+      i2 ++;\n@@ -141,1 +124,1 @@\n-    return -1;\n+    return i2 == num_lists ? -1 : i2;\n@@ -144,3 +127,0 @@\n-  void mask_set_bit(int bit) { _mask |= (((mask_t)1) << bit); }\n-  void mask_clr_bit(int bit) { _mask &= ~(((mask_t)1) << bit); }\n-\n@@ -149,1 +129,1 @@\n-  BinListImpl() : _mask(0) {\n+  BinListImpl() {\n@@ -163,1 +143,0 @@\n-    mask_set_bit(index);\n@@ -181,3 +160,0 @@\n-      if (_blocks[index] == NULL) {\n-        mask_clr_bit(index);\n-      }\n@@ -202,1 +178,1 @@\n-  bool is_empty() const { return _mask == 0; }\n+  bool is_empty() const { return count() == 0; }\n@@ -208,1 +184,0 @@\n-      assert(((_mask >> i) & 1) == ((_blocks[i] == 0) ? 0 : 1), \"sanity\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/binList.hpp","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -104,5 +104,0 @@\n-#ifdef ASSERT\n-    T old = Atomic::load_acquire(&_c);\n-    assert(old >= 1,\n-        \"underflow (\" UINT64_FORMAT \"-1)\", (uint64_t)old);\n-#endif\n@@ -117,5 +112,0 @@\n-#ifdef ASSERT\n-    T old = Atomic::load_acquire(&_c);\n-    assert(old >= v,\n-        \"underflow (\" UINT64_FORMAT \"+\" UINT64_FORMAT \")\", (uint64_t)old, (uint64_t)v);\n-#endif\n","filename":"src\/hotspot\/share\/memory\/metaspace\/counters.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-\/\/    or fully uncommitted (see Settings::uncommit_on_return_min_word_size()).\n+\/\/    or fully uncommitted.\n@@ -166,14 +166,0 @@\n-  \/\/ Find and removes a chunk in this list which has at least min_committed_words committed words.\n-  \/\/ Returns NULL if not found.\n-  Metachunk* find_matching(size_t min_committed_words) {\n-    Metachunk* c = _first;\n-    while (c != NULL && c->committed_words() > 0) {\n-      if (c->committed_words() <= min_committed_words) {\n-        remove(c);\n-        return c;\n-      }\n-      c = c->next();\n-    }\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeChunkList.hpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -219,1 +219,1 @@\n-  chunklevel_t level() const          { return _level; }\n+  chunklevel_t level() const      { return _level; }\n@@ -242,3 +242,0 @@\n-  bool ensure_fully_committed()           { return ensure_committed(word_size()); }\n-  bool ensure_fully_committed_locked()    { return ensure_committed_locked(word_size()); }\n-\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metachunk.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}