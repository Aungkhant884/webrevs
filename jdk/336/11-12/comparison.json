{"files":[{"patch":"@@ -205,1 +205,0 @@\n-        c->set_in_use(); \/\/ gets asserted in return_chunk().\n@@ -246,1 +245,1 @@\n-  assert(c->is_in_use(), \"Unexpected chunk state\");\n+  assert(c->is_in_use() || c->is_free(), \"Unexpected chunk state\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/chunkManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -118,3 +118,4 @@\n-    Metachunk* c = list_for_level(l)->first();\n-    if (c != NULL && c->committed_words() >= min_committed_words) {\n-      list_for_level(l)->remove(c);\n+    FreeChunkList* list = list_for_level(l);\n+    Metachunk* c = list->first_minimally_committed(min_committed_words);\n+    if (c != NULL) {\n+      list->remove(c);\n@@ -132,3 +133,4 @@\n-    Metachunk* c = list_for_level(l)->first();\n-    if (c != NULL && c->committed_words() >= min_committed_words) {\n-      list_for_level(l)->remove(c);\n+    FreeChunkList* list = list_for_level(l);\n+    Metachunk* c = list->first_minimally_committed(min_committed_words);\n+    if (c != NULL) {\n+      list->remove(c);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeChunkList.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,3 @@\n-\/\/  chunks to the front.\n+\/\/  chunks to the front. We do not use a more elaborate sorting on\n+\/\/  insert since that path is used during class unloading, hence timing\n+\/\/  sensitive.\n@@ -48,8 +50,4 @@\n-\/\/ (Small caveat: commit state of a chunk may change as a result of\n-\/\/  actions on neighboring chunks, if the chunk is smaller than a commit\n-\/\/  granule and therefore shares its granule with neighbors. So it may change\n-\/\/  after the chunk has been added to the list.\n-\/\/  It will never involuntarily uncommit: only chunks >= granule size are uncommitted.\n-\/\/  But it may get involuntarily committed if an in-granule neighbor is committed and\n-\/\/  causes committing of the whole granule.\n-\/\/  In practice this is not a big deal; it has very little consequence.)\n+\/\/ During retrieval (at class loading), we search the list for a chunk\n+\/\/  of at least n committed words to satisfy the caller requested\n+\/\/  committed word size. We stop searching at the first fully uncommitted\n+\/\/  chunk.\n@@ -57,2 +55,8 @@\n-\/\/ Beyond adding at either front or at back, we do not sort on insert, since the\n-\/\/  insert path is used during Metaspace reclamation which may happen at GC pause.\n+\/\/ Note that even though this is an O(n) search, partially committed chunks are\n+\/\/  very rare. A partially committed chunk is one spanning multiple commit\n+\/\/  granules, of which some are committed and some are not.\n+\/\/ If metaspace reclamation is on (MetaspaceReclaimPolicy=balanced|aggressive), these\n+\/\/  chunks will become uncommitted after they are returned to the ChunkManager.\n+\/\/ If metaspace reclamation is off (MetaspaceReclaimPolicy=none) they are fully\n+\/\/  committed when handed out and will not be uncommitted when returned to the\n+\/\/  ChunkManager.\n@@ -60,13 +64,2 @@\n-\/\/ During retrieval (at class loading), we search the list for a chunk of at least\n-\/\/  n committed words to satisfy the caller requested committed word size. We stop\n-\/\/  searching at the first fully uncommitted chunk.\n-\/\/\n-\/\/ Note that even though this is an O(n) search, in practice this is not a problem:\n-\/\/  - in all likelihood the requested commit word size is way smaller than even a single\n-\/\/    commit granule, so 99% of all searches would end at the first chunk (which is either\n-\/\/    uncommitted or committed to at least one commit granule size).\n-\/\/  - in all likelihood chunks, when added to this list, are either fully committed\n-\/\/    or fully uncommitted.\n-\/\/\n-\/\/ Should we ever encounter situations where the O(n) search is a bottleneck, this\n-\/\/  structure can easily be optimized (e.g. a BST). But for now lets keep this simple.\n+\/\/ Therefore in all likelihood the chunk lists only contain fully committed or\n+\/\/ fully uncommitted chunks; either way search will stop at the first chunk.\n@@ -146,1 +139,2 @@\n-    assert(_first == NULL || _first->level() == c->level(), \"wrong level\");\n+    assert(_first == NULL || _first->level() == c->level(),\n+           \"List should only contains chunks of the same level.\");\n@@ -169,0 +163,18 @@\n+  \/\/ Returns reference to the fist chunk in the list with a committed word\n+  \/\/ level >= min_committed_words, or NULL.\n+  Metachunk* first_minimally_committed(size_t min_committed_words) const {\n+    \/\/ Since uncommitted chunks are added to the back we can stop looking once\n+    \/\/  we encounter a fully uncommitted chunk.\n+    Metachunk* c = first();\n+    while (c != NULL &&\n+           c->committed_words() < min_committed_words &&\n+           c->committed_words() > 0) {\n+      c = c->next();\n+    }\n+    if (c != NULL &&\n+        c->committed_words() >= min_committed_words) {\n+      return c;\n+    }\n+    return NULL;\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace\/freeChunkList.hpp","additions":37,"deletions":25,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -291,0 +291,3 @@\n+      if (Settings::new_chunks_are_fully_committed()) {\n+        assert(new_chunk->is_fully_committed(), \"Chunk should be fully committed.\");\n+      }\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceArena.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -69,0 +69,4 @@\n+    if (Settings::new_chunks_are_fully_committed()) {\n+      ASSERT_TRUE(c->is_fully_committed());\n+    }\n+\n","filename":"test\/hotspot\/gtest\/metaspace\/metaspaceGtestContexts.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"memory\/metaspace\/metaspaceSettings.hpp\"\n@@ -35,0 +36,2 @@\n+using metaspace::FreeChunkList;\n+using metaspace::FreeChunkListVector;\n@@ -37,1 +40,1 @@\n-using metaspace::FreeChunkListVector;\n+using metaspace::Settings;\n@@ -115,1 +118,4 @@\n-  \/\/ Drain each list separately\n+  \/\/ Drain each list separately, front to back. While draining observe the order\n+  \/\/  in which the chunks come: since uncommitted chunks are added to the tail of\n+  \/\/  the list (see FreeChunkList::add_chunk()), no committed chunk should ever\n+  \/\/  follow an uncommitted chunk.\n@@ -123,1 +129,0 @@\n-      \/\/ Within a level, no committed chunk should follow an uncommitted chunk:\n@@ -143,1 +148,126 @@\n-  \/\/ TODO\n+}\n+\n+\/\/ Test, for a list populated with a mixture of fully\/partially\/uncommitted chunks,\n+\/\/ the retrieval-by-minimally-committed-words function.\n+TEST_VM(metaspace, freechunklist_retrieval) {\n+\n+  if (Settings::new_chunks_are_fully_committed()) {\n+    return;\n+  }\n+\n+  ChunkGtestContext context;\n+  FreeChunkList fcl;\n+  Metachunk* c = NULL;\n+\n+  \/\/ For a chunk level which allows us to have partially committed chunks...\n+  const size_t chunk_word_size = Settings::commit_granule_words() * 4;\n+  const chunklevel_t lvl = level_fitting_word_size(chunk_word_size);\n+\n+  \/\/ get some chunks:\n+\n+  \/\/ ...a completely uncommitted one ...\n+  Metachunk* c_0 = NULL;\n+  context.alloc_chunk_expect_success(&c_0, lvl, lvl, 0);\n+\n+  \/\/ ... a fully committed one ...\n+  Metachunk* c_full = NULL;\n+  context.alloc_chunk_expect_success(&c_full, lvl);\n+\n+  \/\/ ... a chunk with one commit granule committed ...\n+  Metachunk* c_1g = NULL;\n+  context.alloc_chunk_expect_success(&c_1g, lvl, lvl, Settings::commit_granule_words());\n+\n+  \/\/ ... a chunk with two commit granules committed.\n+  Metachunk* c_2g = NULL;\n+  context.alloc_chunk_expect_success(&c_2g, lvl, lvl, Settings::commit_granule_words() * 2);\n+\n+  LOG(\"c_0: \" METACHUNK_FULL_FORMAT, METACHUNK_FULL_FORMAT_ARGS(c_0));\n+  LOG(\"c_full: \" METACHUNK_FULL_FORMAT, METACHUNK_FULL_FORMAT_ARGS(c_full));\n+  LOG(\"c_1g: \" METACHUNK_FULL_FORMAT, METACHUNK_FULL_FORMAT_ARGS(c_1g));\n+  LOG(\"c_2g: \" METACHUNK_FULL_FORMAT, METACHUNK_FULL_FORMAT_ARGS(c_2g));\n+\n+\n+  \/\/ Simple check 1. Empty list should yield nothing.\n+  {\n+    c = fcl.first_minimally_committed(0);\n+    ASSERT_NULL(c);\n+  }\n+\n+  \/\/ Simple check 2. Just a single uncommitted chunk.\n+  {\n+    fcl.add(c_0);\n+    c = fcl.first_minimally_committed(0);\n+    ASSERT_EQ(c_0, c);\n+    c = fcl.first_minimally_committed(1);\n+    ASSERT_NULL(c);\n+    fcl.remove(c_0);\n+  }\n+\n+  \/\/ Now a check with a fully populated list.\n+  \/\/  For different insert orders, try to retrieve different chunks by minimal commit level\n+  \/\/  and check the result.\n+  for (int insert_order = 0; insert_order < 4; insert_order ++) {\n+\n+    switch (insert_order) {\n+    case 0:\n+      fcl.add(c_0);\n+      fcl.add(c_full);\n+      fcl.add(c_1g);\n+      fcl.add(c_2g);\n+      break;\n+    case 1:\n+      fcl.add(c_1g);\n+      fcl.add(c_2g);\n+      fcl.add(c_0);\n+      fcl.add(c_full);\n+      break;\n+    case 2:\n+      fcl.add(c_2g);\n+      fcl.add(c_1g);\n+      fcl.add(c_full);\n+      fcl.add(c_0);\n+      break;\n+    case 3:\n+      fcl.add(c_full);\n+      fcl.add(c_2g);\n+      fcl.add(c_1g);\n+      fcl.add(c_0);\n+      break;\n+    }\n+\n+    c = fcl.first_minimally_committed(0);\n+    ASSERT_TRUE(c == c_full || c == c_0 || c == c_1g || c == c_2g);\n+\n+    c = fcl.first_minimally_committed(1);\n+    ASSERT_TRUE(c == c_full || c == c_1g || c == c_2g);\n+\n+    c = fcl.first_minimally_committed(Settings::commit_granule_words());\n+    ASSERT_TRUE(c == c_full || c == c_1g || c == c_2g);\n+\n+    c = fcl.first_minimally_committed(Settings::commit_granule_words() + 1);\n+    ASSERT_TRUE(c == c_full || c == c_2g);\n+\n+    c = fcl.first_minimally_committed(Settings::commit_granule_words() * 2);\n+    ASSERT_TRUE(c == c_full || c == c_2g);\n+\n+    c = fcl.first_minimally_committed((Settings::commit_granule_words() * 2) + 1);\n+    ASSERT_TRUE(c == c_full);\n+\n+    c = fcl.first_minimally_committed(chunk_word_size);\n+    ASSERT_TRUE(c == c_full);\n+\n+    c = fcl.first_minimally_committed(chunk_word_size + 1);\n+    ASSERT_NULL(c);\n+\n+    fcl.remove(c_0);\n+    fcl.remove(c_full);\n+    fcl.remove(c_1g);\n+    fcl.remove(c_2g);\n+\n+  }\n+\n+  context.return_chunk(c_0);\n+  context.return_chunk(c_full);\n+  context.return_chunk(c_1g);\n+  context.return_chunk(c_2g);\n+\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metachunklist.cpp","additions":134,"deletions":4,"binary":false,"changes":138,"status":"modified"}]}