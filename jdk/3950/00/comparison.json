{"files":[{"patch":"@@ -295,0 +295,1 @@\n+  void internal_reset(size_t log2_size);\n@@ -391,0 +392,4 @@\n+  \/\/ Unsafe reset and resize the table. This method assumes that we\n+  \/\/ want to clear and maybe resize the internal table without the\n+  \/\/ overhead of clearing individual items in the table.\n+  void unsafe_reset(size_t size_log2 = 0);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -784,0 +784,14 @@\n+template <typename CONFIG, MEMFLAGS F>\n+inline void ConcurrentHashTable<CONFIG, F>::\n+  internal_reset(size_t log2_size)\n+{\n+  assert(_table != NULL, \"table failed\");\n+  assert(_log2_size_limit >= log2_size, \"bad ergo\");\n+\n+  delete _table;\n+  \/\/ Create and publish a new table\n+  InternalTable* table = new InternalTable(log2_size);\n+  _size_limit_reached = (log2_size == _log2_size_limit);\n+  Atomic::release_store(&_table, table);\n+}\n+\n@@ -1035,0 +1049,8 @@\n+template <typename CONFIG, MEMFLAGS F>\n+inline void ConcurrentHashTable<CONFIG, F>::\n+  unsafe_reset(size_t size_log2)\n+{\n+  size_t tmp = size_log2 == 0 ? _log2_start_size : size_log2;\n+  internal_reset(tmp);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -52,0 +52,37 @@\n+struct Config : public AllStatic {\n+  typedef uintptr_t Value;\n+  struct TableElement{\n+    TableElement * volatile _next;\n+    Value _value;\n+  };\n+\n+  static const uint nelements = 5;\n+  static TableElement* elements;\n+  static uint cur_index;\n+\n+  static uintx get_hash(const Value& value, bool* dead_hash) {\n+    return (uintx)value;\n+  }\n+  static void initialize() {\n+    elements = (TableElement*)::malloc(nelements * sizeof(TableElement));\n+  }\n+  static void* allocate_node(size_t size, const Value& value) {\n+    return (void*)&elements[cur_index++];\n+  }\n+\n+  static void free_node(void* memory, const Value& value) {\n+    return;\n+  }\n+\n+  static void reset() {\n+    cur_index = 0;\n+  }\n+\n+  static void bulk_free() {\n+    ::free(elements);\n+  }\n+};\n+\n+Config::TableElement* Config::elements = nullptr;\n+uint Config::cur_index = 0;\n+\n@@ -54,0 +91,1 @@\n+typedef ConcurrentHashTable<Config, mtInternal> CustomTestTable;\n@@ -78,1 +116,2 @@\n-static uintptr_t cht_get_copy(SimpleTestTable* cht, Thread* thr, SimpleTestLookup stl) {\n+template <typename T=SimpleTestTable>\n+static uintptr_t cht_get_copy(T* cht, Thread* thr, SimpleTestLookup stl) {\n@@ -84,1 +123,2 @@\n-static void cht_find(Thread* thr, SimpleTestTable* cht, uintptr_t val) {\n+template <typename T=SimpleTestTable>\n+static void cht_find(Thread* thr, T* cht, uintptr_t val) {\n@@ -91,1 +131,2 @@\n-static void cht_insert_and_find(Thread* thr, SimpleTestTable* cht, uintptr_t val) {\n+template <typename T=SimpleTestTable>\n+static void cht_insert_and_find(Thread* thr, T* cht, uintptr_t val) {\n@@ -223,0 +264,26 @@\n+static void cht_reset_shrink(Thread* thr) {\n+  uintptr_t val1 = 1;\n+  uintptr_t val2 = 2;\n+  uintptr_t val3 = 3;\n+  SimpleTestLookup stl1(val1), stl2(val2), stl3(val3);\n+\n+  Config::initialize();\n+  CustomTestTable* cht = new CustomTestTable();\n+\n+  cht_insert_and_find(thr, cht, val1);\n+  cht_insert_and_find(thr, cht, val2);\n+  cht_insert_and_find(thr, cht, val3);\n+\n+  cht->unsafe_reset();\n+  Config::reset();\n+\n+  EXPECT_EQ(cht_get_copy(cht, thr, stl1), (uintptr_t)0) << \"Table should have been reset\";\n+  \/\/ Re-inserted values should not be considered duplicates; table was reset.\n+  cht_insert_and_find(thr, cht, val1);\n+  cht_insert_and_find(thr, cht, val2);\n+  cht_insert_and_find(thr, cht, val3);\n+\n+  delete cht;\n+  Config::bulk_free();\n+}\n+\n@@ -397,0 +464,4 @@\n+TEST_VM(ConcurrentHashTable, basic_reset_shrink) {\n+  nomt_test_doer(cht_reset_shrink);\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":74,"deletions":3,"binary":false,"changes":77,"status":"modified"}]}