[{"commit":{"message":"Add an IR testcase\n\nChange-Id: If67d200754ed5a579510b46041b2ba8c3c4db22e"},"files":[{"filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestAutoVecCountingDownLoop.java"}],"sha":"ff69751bdfcf688f30145c51388419215c0a094d"},{"commit":{"message":"Merge branch 'master' into fg8284981\n\nChange-Id: I1bc92486ecc0da8917131cc55e9c5694d3c3eae5"},"files":[{"filename":"src\/hotspot\/share\/opto\/superword.cpp"}],"sha":"0cc4083b88a8cf6e9cf34c9fc5496be4e8fc899c"},{"commit":{"message":"8284981: Support the vectorization of some counting-down loops in SLP\n\nSLP can vectorize basic counting-down or counting-up loops. But\nfor the counting-down loop below, in which array index scale\nis negative and index starts from a constant value, SLP can't\nsucceed in vectorizing.\n\n```\n  private static final int SIZE = 2345;\n  private static int[] a = new int[SIZE];\n  private static int[] b = new int[SIZE];\n\n  public static void bar() {\n      for (int i = 1000; i > 0; i--) {\n          b[SIZE - i] = a[SIZE - i];\n      }\n  }\n```\n\nGenerally, it's necessary to find adjacent memory operations, i.e.\nload\/store, after unrolling in SLP. Constructing SWPointers[1] for\nall memory operations is a key step to determine if these memory\noperations are adjacent. To construct a SWPointer successfully,\nSLP should first recognize the pattern of the memory address and\nnormalize it. The address pattern of the memory operations in the\ncase above can be visualized as:\n\n             Phi\n             \/\n  ConL   ConvI2L\n     \\    \/\n      SubL   ConI\n        \\     \/\n        LShiftL\n\nwhich is equivalent to `(N - (long) i) << 2`. SLP recursively\nresolves the address mode by SWPointer::scaled_iv_plus_offset().\nWhen arriving at the `SubL` node, it accepts `SubI` only and finally\nrejects the pattern of the case above[2]. In this way, SLP can't\nconstruct effective SWPointers for these memory operations and\nthe process of vectorization breaks off.\n\nThe pattern like `(N - (long) i) << 2` is formal and easy to\nresolve. We add the pattern of SubL in the patch to vectorize\ncounting-down loops like the case above.\n\nAfter the patch, generated loop code for above case is like below on\naarch64:\n```\nLOOP: mov   w10, w12\n      sxtw  x12, w10\n      neg   x0, x12\n      lsl   x0, x0, #2\n      add   x1, x17, x0\n      ldr   q16, [x1, x2]\n      add   x0, x18, x0\n      str   q16, [x0, x2]\n      ldr   q16, [x1, x13]\n      str   q16, [x0, x13]\n      ldr   q16, [x1, x14]\n      str   q16, [x0, x14]\n      ldr   q16, [x1, x15]\n      sub   x12, x11, x12\n      lsl   x12, x12, #2\n      add   x3, x17, x12\n      str   q16, [x0, x15]\n      ldr   q16, [x3, x2]\n      add   x12, x18, x12\n      str   q16, [x12, x2]\n      ldr   q16, [x1, x16]\n      str   q16, [x0, x16]\n      ldr   q16, [x3, x14]\n      str   q16, [x12, x14]\n      ldr   q16, [x3, x15]\n      str   q16, [x12, x15]\n      sub   w12, w10, #0x20\n      cmp   w12, #0x1f\n      b.gt  LOOP\n```\n\nThis patch also works on x86 simd machines. We tested full jtreg on both\naarch64 and x86 platforms. All tests passed.\n\n[1] https:\/\/github.com\/openjdk\/jdk\/blob\/b56df2808d79dcc1e2d954fe38dd84228c683e8b\/src\/hotspot\/share\/opto\/superword.cpp#L3826\n[2] https:\/\/github.com\/openjdk\/jdk\/blob\/b56df2808d79dcc1e2d954fe38dd84228c683e8b\/src\/hotspot\/share\/opto\/superword.cpp#L3953\n\nChange-Id: Ifcd8f8351ec5b4f7676e6ef134d279a67358b0fb"},"files":[{"filename":"src\/hotspot\/share\/opto\/superword.cpp"},{"filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntVect.java"}],"sha":"0ee87952bbce81255ccf316c6420130e97b5534d"}]