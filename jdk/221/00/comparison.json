{"files":[{"patch":"@@ -148,1 +148,1 @@\n-    narrowKlass narrow_klass = *(obj->compressed_klass_addr());\n+    narrowKlass narrow_klass = obj->_metadata._compressed_klass;\n@@ -152,1 +152,1 @@\n-    return *(void**)(obj->klass_addr());\n+    return obj->_metadata._klass;\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,4 +81,0 @@\n-  static inline Klass** klass_addr(HeapWord* mem);\n-  static inline narrowKlass* compressed_klass_addr(HeapWord* mem);\n-  inline Klass** klass_addr();\n-  inline narrowKlass* compressed_klass_addr();\n@@ -87,1 +83,1 @@\n-  static inline void release_set_klass(HeapWord* mem, Klass* klass);\n+  static inline void release_set_klass(HeapWord* mem, Klass* k);\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,28 +116,0 @@\n-Klass** oopDesc::klass_addr(HeapWord* mem) {\n-  \/\/ Only used internally and with CMS and will not work with\n-  \/\/ UseCompressedOops\n-  assert(!UseCompressedClassPointers, \"only supported with uncompressed klass pointers\");\n-  ByteSize offset = byte_offset_of(oopDesc, _metadata._klass);\n-  return (Klass**) (((char*)mem) + in_bytes(offset));\n-}\n-\n-narrowKlass* oopDesc::compressed_klass_addr(HeapWord* mem) {\n-  assert(UseCompressedClassPointers, \"only called by compressed klass pointers\");\n-  ByteSize offset = byte_offset_of(oopDesc, _metadata._compressed_klass);\n-  return (narrowKlass*) (((char*)mem) + in_bytes(offset));\n-}\n-\n-Klass** oopDesc::klass_addr() {\n-  return klass_addr((HeapWord*)this);\n-}\n-\n-narrowKlass* oopDesc::compressed_klass_addr() {\n-  return compressed_klass_addr((HeapWord*)this);\n-}\n-\n-#define CHECK_SET_KLASS(k)                                                \\\n-  do {                                                                    \\\n-    assert(Universe::is_bootstrapping() || k != NULL, \"NULL Klass\");      \\\n-    assert(Universe::is_bootstrapping() || k->is_klass(), \"not a Klass\"); \\\n-  } while (0)\n-\n@@ -145,1 +117,1 @@\n-  CHECK_SET_KLASS(k);\n+  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n@@ -147,1 +119,1 @@\n-    *compressed_klass_addr() = CompressedKlassPointers::encode_not_null(k);\n+    _metadata._compressed_klass = CompressedKlassPointers::encode_not_null(k);\n@@ -149,1 +121,1 @@\n-    *klass_addr() = k;\n+    _metadata._klass = k;\n@@ -153,2 +125,3 @@\n-void oopDesc::release_set_klass(HeapWord* mem, Klass* klass) {\n-  CHECK_SET_KLASS(klass);\n+void oopDesc::release_set_klass(HeapWord* mem, Klass* k) {\n+  assert(Universe::is_bootstrapping() || (k != NULL && k->is_klass()), \"incorrect Klass\");\n+  char* raw_mem = ((char*)mem + klass_offset_in_bytes());\n@@ -156,2 +129,2 @@\n-    Atomic::release_store(compressed_klass_addr(mem),\n-                          CompressedKlassPointers::encode_not_null(klass));\n+    Atomic::release_store((narrowKlass*)raw_mem,\n+                          CompressedKlassPointers::encode_not_null(k));\n@@ -159,1 +132,1 @@\n-    Atomic::release_store(klass_addr(mem), klass);\n+    Atomic::release_store((Klass**)raw_mem, k);\n@@ -163,2 +136,0 @@\n-#undef CHECK_SET_KLASS\n-\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":9,"deletions":38,"binary":false,"changes":47,"status":"modified"}]}