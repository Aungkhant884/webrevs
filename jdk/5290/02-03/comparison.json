{"files":[{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary\n+ * VM Testbase keywords: [jpda, jdb]\n+ * VM Testbase readme:\n+ * DECSRIPTION\n+ * This tests the GDB-style auto-advance feature of `list', which is enabled and disabled through the `repeat' command.\n+ * The test consists of two program:\n+ *   list003.java - launches jdb and debuggee and executes test cases\n+ *   list003a.java - the debugged application\n+ * COMMENTS\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdb.list.list003.list003a\n+ * @run main\/othervm\n+ *      nsk.jdb.list.list003.list003\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -waittime=5\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -jdb=${test.jdk}\/bin\/jdb\n+ *      -jdb.option=\"-J-Duser.language=en -J-Duser.country=US\"\n+ *      -java.options=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -workdir=.\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n+package nsk.jdb.list.list003;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import static java.util.stream.Collectors.toList;\n+\n+import nsk.share.jdb.JdbTest;\n+import nsk.share.jdb.JdbCommand;\n+\n+\n+public class list003 extends JdbTest {\n+    static final String PACKAGE_NAME = \"nsk.jdb.list.list003\";\n+    static final String TEST_CLASS = PACKAGE_NAME + \".list003\";\n+    static final String DEBUGGEE_CLASS = TEST_CLASS + \"a\";\n+    static final String FIRST_BREAK = DEBUGGEE_CLASS + \".main\";\n+\n+    \/**\n+     * Represents a line output by the {@code list} command.\n+     *\/\n+    protected static record ListLine(int number, boolean active) {\n+        public static ListLine parse(String line) {\n+            String[] tokens = line.split(\"\\\\s+\");\n+            return new ListLine(\n+                Integer.parseInt(tokens[0]),\n+                tokens.length >= 2 && tokens[1].equals(\"=>\")\n+            );\n+        }\n+    }\n+\n+    protected static boolean isPrompt(String line) {\n+        return line.trim().equals(\"main[1]\");\n+    }\n+\n+    protected static List<ListLine> parseListOutput(String[] lines) {\n+        List<String> lineList = new ArrayList<>(Arrays.asList(lines));\n+        if (!isPrompt(lineList.remove(lineList.size() - 1))) {\n+            throw new AssertionError(\"Expected trailing prompt\");\n+        } else if (lineList.size() == 1 && lineList.get(0).equals(\"EOF\")) {\n+            return new ArrayList<>();\n+        } else {\n+            return lineList.stream().map(ListLine::parse).collect(toList());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String[] args, PrintStream out) {\n+        debuggeeClass = DEBUGGEE_CLASS;\n+        firstBreak = FIRST_BREAK;\n+        return new list003().runTest(args, out);\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        try {\n+            runCasesNoCleanup();\n+        } finally {\n+            jdb.contToExit(1);\n+        }\n+    }\n+\n+    protected void runCasesNoCleanup() {\n+        if (jdb.receiveReplyFor(JdbCommand.repeat + \"on\").length != 1) {\n+            throw new AssertionError(\"Missing or unexpected output\");\n+        }\n+\n+        List<ListLine> autoList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list));\n+        int lineNo = autoList.stream().filter(ListLine::active).findFirst().get().number();\n+        List<ListLine> manualList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list + (lineNo - 1)));\n+        if (manualList.stream().filter(ListLine::active).findFirst().get().number() != lineNo) {\n+            throw new AssertionError(\"Manual listing didn't mark the active source line\");\n+        }\n+\n+        \/\/ Verify that we can correctly list by auto-advance all the way to EOF\n+        List<ListLine> prevList = manualList;\n+        int reps;\n+        for (reps = 0; !prevList.isEmpty(); reps += 1) {\n+            \/\/ Exercise both explicit `list' and auto-repeat\n+            var command = reps % 2 == 0 ? JdbCommand.list : \"\";\n+\n+            List<ListLine> currList = parseListOutput(jdb.receiveReplyFor(command));\n+            if (currList.equals(prevList)) {\n+                \/\/ This guards against infinite looping\n+                throw new AssertionError(\"Consecutive listings were identical\");\n+            }\n+            int prevEnd = prevList.get(prevList.size() - 1).number();\n+            if (!currList.isEmpty() && currList.get(0).number() != prevEnd + 1) {\n+                throw new AssertionError(\"Consecutive listings weren't for consecutive source chunks\");\n+            }\n+            prevList = currList;\n+        }\n+        if (reps < 2) {\n+            throw new AssertionError(\"Didn't get enough consecutive list reps\");\n+        }\n+\n+        String[] lines = jdb.receiveReplyFor(JdbCommand.up);\n+        if (!lines[0].equals(\"End of stack.\") || !isPrompt(lines[1])) {\n+            throw new AssertionError(\"Unexpected output from `up'\");\n+        }\n+        List<ListLine> resetList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list));\n+        if (!resetList.stream().anyMatch(ListLine::active)) {\n+            throw new AssertionError(\"List target didn't reset to active line\");\n+        }\n+\n+        List<ListLine> listing = parseListOutput(jdb.receiveReplyFor(JdbCommand.list + \"1\"));\n+        if (!listing.stream().anyMatch(l -> l.number() == 1)) {\n+            throw new AssertionError(\"Manual listing displayed the wrong lines\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/list\/list003\/list003.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdb.list.list003;\n+\n+import nsk.share.Log;\n+import nsk.share.jdb.JdbArgumentHandler;\n+\n+import java.io.PrintStream;\n+\n+\n+\/* This is debuggee application *\/\n+public class list003a {\n+    static list003a _list003a = new list003a();\n+\n+    public static void main(String[] args) {\n+       System.exit(list003.JCK_STATUS_BASE + _list003a.runIt(args, System.out));\n+    }\n+\n+    public int runIt(String[] args, PrintStream out) {\n+        JdbArgumentHandler argumentHandler = new JdbArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        log.display(\"Debuggee PASSED\");\n+        return list003.PASSED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/list\/list003\/list003a.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary\n+ * VM Testbase keywords: [jpda, jdb]\n+ * VM Testbase readme:\n+ * DECSRIPTION\n+ * Tests the operation of the `repeat' commands, which print and change the status of GDB-style command repetition and\n+ * list auto-advance.  The particular behavior of `list' when repitition is on is tested in the `list' tests.\n+ * The test consists of two program:\n+ *   repeat001.java - launches jdb and debuggee and executes test cases\n+ *   repeat001a.java - the debugged application\n+ * COMMENTS\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdb.repeat.repeat001.repeat001a\n+ * @run main\/othervm\n+ *      nsk.jdb.repeat.repeat001.repeat001\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -waittime=5\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -jdb=${test.jdk}\/bin\/jdb\n+ *      -jdb.option=\"-J-Duser.language=en -J-Duser.country=US\"\n+ *      -java.options=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -workdir=.\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n+package nsk.jdb.repeat.repeat001;\n+\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+\n+import nsk.share.jdb.JdbTest;\n+import nsk.share.jdb.JdbCommand;\n+import jdk.test.lib.Utils;\n+\n+\n+public class repeat001 extends JdbTest {\n+    static final String PACKAGE_NAME = \"nsk.jdb.repeat.repeat001\";\n+    static final String TEST_CLASS = PACKAGE_NAME + \".repeat001\";\n+    static final String DEBUGGEE_CLASS = TEST_CLASS + \"a\";\n+    static final String FIRST_BREAK = DEBUGGEE_CLASS + \".main\";\n+\n+    public static void main(String[] args) {\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String[] args, PrintStream out) {\n+        debuggeeClass = DEBUGGEE_CLASS;\n+        firstBreak = FIRST_BREAK;\n+        return new repeat001().runTest(args, out);\n+    }\n+\n+    protected static boolean isPrompt(String line) {\n+        return line.trim().equals(\"main[1]\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        try {\n+            runCasesNoCleanup();\n+        } finally {\n+            jdb.contToExit(1);\n+        }\n+    }\n+\n+    protected void runCasesNoCleanup() {\n+        \/\/ Verify that repeat is off initially\n+        String[] reply = jdb.receiveReplyFor(JdbCommand.repeat);\n+        if (reply.length != 2 || !isPrompt(reply[1])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (!reply[0].equals(\"Repeat is off\")) {\n+            throw new AssertionError(\"Incorrect initial repeat setting\");\n+        }\n+\n+        \/\/ Verify that list auto-advance is disabled\n+        String[] firstList = jdb.receiveReplyFor(JdbCommand.list);\n+        String[] secondList = jdb.receiveReplyFor(JdbCommand.list);\n+        if (!Arrays.equals(firstList, secondList)) {\n+            throw new AssertionError(\"Listing inconsistent with repeat off\");\n+        }\n+\n+        \/\/ Verify that command repetition doesn't happen when disabled\n+        reply = jdb.receiveReplyFor(\"\");\n+        if (reply.length != 1 || !isPrompt(reply[0])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+\n+        reply = jdb.receiveReplyFor(JdbCommand.repeat + \"on\");\n+        if (reply.length != 1 || !isPrompt(reply[0])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+\n+        \/\/ Verify that repeat is reported on\n+        reply = jdb.receiveReplyFor(JdbCommand.repeat);\n+        if (reply.length != 2 || !isPrompt(reply[1])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (!reply[0].equals(\"Repeat is on\")) {\n+            throw new AssertionError(\"Incorrect repeat status reported\");\n+        }\n+\n+        \/\/ Verify that non-repeatable commands still don't repeat\n+        if (jdb.receiveReplyFor(JdbCommand.print + \"0\").length != 2) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (jdb.receiveReplyFor(\"\").length != 1) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+\n+        \/\/ Verify that repeated commands are repeatable\n+        \/\/ (`up' just prints `End of stack.' since we're stopped in `main')\n+        reply = jdb.receiveReplyFor(\"2 2 \" + JdbCommand.up);\n+        if (reply.length != 5 || !isPrompt(reply[4])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (!Arrays.equals(reply, jdb.receiveReplyFor(\"\"))) {\n+            throw new AssertionError(\"Repeated command didn't repeat correctly\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/repeat\/repeat001\/repeat001.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdb.repeat.repeat001;\n+\n+import nsk.share.Log;\n+import nsk.share.jdb.JdbArgumentHandler;\n+\n+import java.io.PrintStream;\n+\n+\n+\/* This is debuggee application *\/\n+public class repeat001a {\n+    static repeat001a _repeat001a = new repeat001a();\n+\n+    public static void main(String[] args) {\n+       System.exit(repeat001.JCK_STATUS_BASE + _repeat001a.runIt(args, System.out));\n+    }\n+\n+    public int runIt(String[] args, PrintStream out) {\n+        JdbArgumentHandler argumentHandler = new JdbArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        log.display(\"Debuggee PASSED\");\n+        return repeat001.PASSED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/repeat\/repeat001\/repeat001a.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -102,0 +102,2 @@\n+ *   repeat                    -- show whether GDB-style empty command repetition is enabled\n+ *   repeat <on|off>           -- enable\/disable GDB-style repetition\n@@ -148,0 +150,1 @@\n+    public static final String repeat       = \"repeat \";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/JdbCommand.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}