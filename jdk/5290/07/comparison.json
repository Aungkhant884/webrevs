{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,4 @@\n+    \/**\n+     * Number of lines to show before the target line during {@code list}.\n+     *\/\n+    protected static final int LIST_LINE_LOOKBEHIND = 4;\n@@ -1475,1 +1479,5 @@\n-    void commandList(StringTokenizer t) {\n+    \/**\n+     * @param lineHint source line number to target by default, or {@code null} to use the execution point\n+     * @return line hint to be used in a subsequent {@code list} command, if any\n+     *\/\n+    Integer commandList(StringTokenizer t, Integer lineHint) {\n@@ -1480,1 +1488,1 @@\n-            return;\n+            return null;\n@@ -1486,1 +1494,1 @@\n-            return;\n+            return null;\n@@ -1491,1 +1499,1 @@\n-            return;\n+            return null;\n@@ -1497,1 +1505,1 @@\n-            return;\n+            return null;\n@@ -1505,1 +1513,0 @@\n-            int lineno = loc.lineNumber();\n@@ -1507,1 +1514,5 @@\n-            if (t.hasMoreTokens()) {\n+            int lineno;\n+            var useDefault = !t.hasMoreTokens();\n+            if (useDefault) {\n+                lineno = lineHint == null ? loc.lineNumber() : lineHint;\n+            } else {\n@@ -1518,12 +1529,12 @@\n-                        List<Method> meths = refType.methodsByName(id);\n-                        if (meths == null || meths.size() == 0) {\n-                            MessageOutput.println(\"is not a valid line number or method name for\",\n-                                                  new Object [] {id, refType.name()});\n-                            return;\n-                        } else if (meths.size() > 1) {\n-                            MessageOutput.println(\"is an ambiguous method name in\",\n-                                                  new Object [] {id, refType.name()});\n-                            return;\n-                        }\n-                        loc = meths.get(0).location();\n-                        lineno = loc.lineNumber();\n+                    List<Method> meths = refType.methodsByName(id);\n+                    if (meths == null || meths.size() == 0) {\n+                        MessageOutput.println(\"is not a valid line number or method name for\",\n+                                              new Object [] {id, refType.name()});\n+                        return null;\n+                    } else if (meths.size() > 1) {\n+                        MessageOutput.println(\"is an ambiguous method name in\",\n+                                              new Object [] {id, refType.name()});\n+                        return null;\n+                    }\n+                    loc = meths.get(0).location();\n+                    lineno = loc.lineNumber();\n@@ -1532,2 +1543,2 @@\n-            int startLine = Math.max(lineno - 4, 1);\n-            int endLine = startLine + 9;\n+            int startLine = Math.max(lineno - LIST_LINE_LOOKBEHIND, 1);\n+            int endLine = startLine + 10;\n@@ -1536,4 +1547,16 @@\n-            } else if (Env.sourceLine(loc, lineno) == null) {\n-                MessageOutput.println(\"is an invalid line number for\",\n-                                      new Object [] {Integer.valueOf(lineno),\n-                                                     refType.name()});\n+            } else if (useDefault && Env.sourceLine(loc, startLine) == null) {\n+                \/*\n+                 * If we're out of range with a default line number then we've hit EOF on auto-advance.  Stay at this\n+                 * position until a different source location is requested, as in GDB.\n+                 *\/\n+                MessageOutput.println(\"EOF\");\n+                return lineno;\n+            } else if (!useDefault && Env.sourceLine(loc, lineno) == null) {\n+                MessageOutput.println(\n+                    \"is an invalid line number for\",\n+                    new Object[] {\n+                        Integer.valueOf(lineno),\n+                        refType.name()\n+                    }\n+                );\n+                return null;\n@@ -1541,1 +1564,1 @@\n-                for (int i = startLine; i <= endLine; i++) {\n+                for (int i = startLine; i < endLine; i++) {\n@@ -1544,1 +1567,2 @@\n-                        break;\n+                        \/\/ Next listing will start just out of range, triggering an EOF message.\n+                        return i + LIST_LINE_LOOKBEHIND;\n@@ -1546,1 +1570,1 @@\n-                    if (i == lineno) {\n+                    if (i == loc.lineNumber()) {\n@@ -1556,0 +1580,1 @@\n+                return endLine + LIST_LINE_LOOKBEHIND;  \/\/ start next listing with `endLine'\n@@ -1564,0 +1589,1 @@\n+        return null;\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Commands.java","additions":55,"deletions":29,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,15 @@\n+    \/**\n+     * Commands that are repeatable on empty input.\n+     *\/\n+    protected static final Set<String> REPEATABLE = Set.of(\n+        \"up\", \"down\", \"step\", \"stepi\", \"next\", \"cont\", \"list\", \"pop\", \"reenter\"\n+    );\n+\n+    \/**\n+     * Commands that reset the default source line to be displayed by {@code list}.\n+     *\/\n+    protected static final Set<String> LIST_RESET = Set.of(\n+        \"run\", \"suspend\", \"resume\", \"up\", \"down\", \"kill\", \"interrupt\", \"threadgroup\", \"step\", \"stepi\", \"next\", \"cont\",\n+        \"pop\", \"reenter\"\n+    );\n+\n@@ -62,0 +77,10 @@\n+    \/**\n+     * The number of the next source line to target for {@code list}, if any.\n+     *\/\n+    protected Integer nextListTarget = null;\n+\n+    \/**\n+     * Whether to repeat when the user enters an empty command.\n+     *\/\n+    protected boolean repeat = false;\n+\n@@ -338,0 +363,1 @@\n+        {\"repeat\",       \"y\",         \"y\"},\n@@ -411,1 +437,4 @@\n-    void executeCommand(StringTokenizer t) {\n+    \/**\n+     * @return the name (first token) of the command processed\n+     *\/\n+    String executeCommand(StringTokenizer t) {\n@@ -413,0 +442,1 @@\n+\n@@ -416,1 +446,0 @@\n-\n@@ -429,2 +458,2 @@\n-                    while (repeat-- > 0) {\n-                        executeCommand(new StringTokenizer(subcom));\n+                    for (int r = 0; r < repeat; r += 1) {\n+                        cmd = executeCommand(new StringTokenizer(subcom));\n@@ -438,0 +467,1 @@\n+\n@@ -451,1 +481,0 @@\n-\n@@ -553,1 +582,1 @@\n-                            evaluator.commandList(t);\n+                            nextListTarget = evaluator.commandList(t, repeat ? nextListTarget : null);\n@@ -599,0 +628,2 @@\n+                        } else if (cmd.equals(\"repeat\")) {\n+                            doRepeat(t);\n@@ -623,0 +654,6 @@\n+\n+        if (LIST_RESET.contains(cmd)) {\n+            nextListTarget = null;\n+        }\n+\n+        return cmd;\n@@ -664,1 +701,0 @@\n-\n@@ -676,0 +712,13 @@\n+    protected void doRepeat(StringTokenizer t) {\n+        if (t.hasMoreTokens()) {\n+            var choice = t.nextToken().toLowerCase();\n+            if ((choice.equals(\"on\") || choice.equals(\"off\")) && !t.hasMoreTokens()) {\n+                repeat = choice.equals(\"on\");\n+            } else {\n+                MessageOutput.println(\"repeat usage\");\n+            }\n+        } else {\n+            MessageOutput.println(repeat ? \"repeat is on\" : \"repeat is off\");\n+        }\n+    }\n+\n@@ -752,2 +801,0 @@\n-            String lastLine = null;\n-\n@@ -791,0 +838,3 @@\n+\n+            String lastLine = null;\n+            String lastCommandName = null;\n@@ -812,1 +862,5 @@\n-                    executeCommand(t);\n+                    lastCommandName = executeCommand(t);\n+                } else if (repeat && lastLine != null && REPEATABLE.contains(lastCommandName)) {\n+                    \/\/ We want list auto-advance even if the user started with a listing target.\n+                    String newCommand = lastCommandName.equals(\"list\") && nextListTarget != null ? \"list\" : lastLine;\n+                    executeCommand(new StringTokenizer(newCommand));\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTY.java","additions":65,"deletions":11,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,1 @@\n+        {\"EOF\", \"EOF\"},\n@@ -263,0 +264,3 @@\n+        {\"repeat is on\", \"Repeat is on\"},\n+        {\"repeat is off\", \"Repeat is off\"},\n+        {\"repeat usage\", \"Usage: repeat <on|off>\"},\n@@ -439,0 +443,2 @@\n+             \"repeat                    -- show whether GDB-style empty command repetition is enabled\\n\" +\n+             \"repeat <on|off>           -- enable\/disable GDB-style repetition\\n\" +\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,1 @@\n+        {\"EOF\", \"EOF\"},\n@@ -255,0 +256,3 @@\n+        {\"repeat is on\", \"Repeat is on\"},\n+        {\"repeat is off\", \"Repeat is off\"},\n+        {\"repeat usage\", \"Usage: repeat <on|off>\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_ja.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,0 +113,1 @@\n+        {\"EOF\", \"EOF\"},\n@@ -255,0 +256,3 @@\n+        {\"repeat is on\", \"Repeat is on\"},\n+        {\"repeat is off\", \"Repeat is off\"},\n+        {\"repeat usage\", \"Usage: repeat <on|off>\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources_zh_CN.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary\n+ * VM Testbase keywords: [jpda, jdb]\n+ * VM Testbase readme:\n+ * DECSRIPTION\n+ * This tests the GDB-style auto-advance feature of `list', which is enabled and disabled through the `repeat' command.\n+ * The test consists of two program:\n+ *   list003.java - launches jdb and debuggee and executes test cases\n+ *   list003a.java - the debugged application\n+ * COMMENTS\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdb.list.list003.list003a\n+ * @run main\/othervm\n+ *      nsk.jdb.list.list003.list003\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -waittime=5\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -jdb=${test.jdk}\/bin\/jdb\n+ *      -jdb.option=\"-J-Duser.language=en -J-Duser.country=US\"\n+ *      -java.options=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -workdir=.\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n+package nsk.jdb.list.list003;\n+\n+import java.io.PrintStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import static java.util.stream.Collectors.toList;\n+\n+import nsk.share.jdb.JdbTest;\n+import nsk.share.jdb.JdbCommand;\n+\n+\n+public class list003 extends JdbTest {\n+    static final String PACKAGE_NAME = \"nsk.jdb.list.list003\";\n+    static final String TEST_CLASS = PACKAGE_NAME + \".list003\";\n+    static final String DEBUGGEE_CLASS = TEST_CLASS + \"a\";\n+    static final String FIRST_BREAK = DEBUGGEE_CLASS + \".main\";\n+\n+    \/**\n+     * Represents a line output by the {@code list} command.\n+     *\/\n+    protected static record ListLine(int number, boolean active) {\n+        public static ListLine parse(String line) {\n+            String[] tokens = line.split(\"\\\\s+\");\n+            return new ListLine(\n+                Integer.parseInt(tokens[0]),\n+                tokens.length >= 2 && tokens[1].equals(\"=>\")\n+            );\n+        }\n+    }\n+\n+    protected static boolean isPrompt(String line) {\n+        return line.trim().equals(\"main[1]\");\n+    }\n+\n+    protected static List<ListLine> parseListOutput(String[] lines) {\n+        List<String> lineList = new ArrayList<>(Arrays.asList(lines));\n+        if (!isPrompt(lineList.remove(lineList.size() - 1))) {\n+            throw new AssertionError(\"Expected trailing prompt\");\n+        } else if (lineList.size() == 1 && lineList.get(0).equals(\"EOF\")) {\n+            return new ArrayList<>();\n+        } else {\n+            return lineList.stream().map(ListLine::parse).collect(toList());\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String[] args, PrintStream out) {\n+        debuggeeClass = DEBUGGEE_CLASS;\n+        firstBreak = FIRST_BREAK;\n+        return new list003().runTest(args, out);\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        try {\n+            runCasesNoCleanup();\n+        } finally {\n+            jdb.contToExit(1);\n+        }\n+    }\n+\n+    protected void runCasesNoCleanup() {\n+        if (jdb.receiveReplyFor(JdbCommand.repeat + \"on\").length != 1) {\n+            throw new AssertionError(\"Missing or unexpected output\");\n+        }\n+\n+        List<ListLine> autoList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list));\n+        int lineNo = autoList.stream().filter(ListLine::active).findFirst().get().number();\n+        List<ListLine> manualList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list + (lineNo - 1)));\n+        if (manualList.stream().filter(ListLine::active).findFirst().get().number() != lineNo) {\n+            throw new AssertionError(\"Manual listing didn't mark the active source line\");\n+        }\n+\n+        \/\/ Verify that we can correctly list by auto-advance all the way to EOF\n+        List<ListLine> prevList = manualList;\n+        int reps;\n+        for (reps = 0; !prevList.isEmpty(); reps += 1) {\n+            \/\/ Exercise both explicit `list' and auto-repeat\n+            var command = reps % 2 == 0 ? JdbCommand.list : \"\";\n+\n+            List<ListLine> currList = parseListOutput(jdb.receiveReplyFor(command));\n+            if (currList.equals(prevList)) {\n+                \/\/ This guards against infinite looping\n+                throw new AssertionError(\"Consecutive listings were identical\");\n+            }\n+            int prevEnd = prevList.get(prevList.size() - 1).number();\n+            if (!currList.isEmpty() && currList.get(0).number() != prevEnd + 1) {\n+                throw new AssertionError(\"Consecutive listings weren't for consecutive source chunks\");\n+            }\n+            prevList = currList;\n+        }\n+        if (reps < 2) {\n+            throw new AssertionError(\"Didn't get enough consecutive list reps\");\n+        }\n+\n+        String[] lines = jdb.receiveReplyFor(JdbCommand.up);\n+        if (!lines[0].equals(\"End of stack.\") || !isPrompt(lines[1])) {\n+            throw new AssertionError(\"Unexpected output from `up'\");\n+        }\n+        List<ListLine> resetList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list));\n+        if (!resetList.stream().anyMatch(ListLine::active)) {\n+            throw new AssertionError(\"List target didn't reset to active line\");\n+        }\n+\n+        List<ListLine> listing = parseListOutput(jdb.receiveReplyFor(JdbCommand.list + \"1\"));\n+        if (!listing.stream().anyMatch(l -> l.number() == 1)) {\n+            throw new AssertionError(\"Manual listing displayed the wrong lines\");\n+        }\n+\n+        List<ListLine> targetedList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list + \"1\"));\n+        autoList = parseListOutput(jdb.receiveReplyFor(JdbCommand.list));\n+        if (autoList.get(0).number() != targetedList.get(targetedList.size() - 1).number() + 1) {\n+            throw new AssertionError(\"Auto-advance didn't work after targeted list\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/list\/list003\/list003.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdb.list.list003;\n+\n+import nsk.share.Log;\n+import nsk.share.jdb.JdbArgumentHandler;\n+\n+import java.io.PrintStream;\n+\n+\n+\/* This is debuggee application *\/\n+public class list003a {\n+    static list003a _list003a = new list003a();\n+\n+    public static void main(String[] args) {\n+       System.exit(list003.JCK_STATUS_BASE + _list003a.runIt(args, System.out));\n+    }\n+\n+    public int runIt(String[] args, PrintStream out) {\n+        JdbArgumentHandler argumentHandler = new JdbArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        log.display(\"Debuggee PASSED\");\n+        return list003.PASSED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/list\/list003\/list003a.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ *\n+ * @summary\n+ * VM Testbase keywords: [jpda, jdb]\n+ * VM Testbase readme:\n+ * DECSRIPTION\n+ * Tests the operation of the `repeat' commands, which print and change the status of GDB-style command repetition and\n+ * list auto-advance.  The particular behavior of `list' when repitition is on is tested in the `list' tests.\n+ * The test consists of two program:\n+ *   repeat001.java - launches jdb and debuggee and executes test cases\n+ *   repeat001a.java - the debugged application\n+ * COMMENTS\n+ *\n+ * @library \/vmTestbase\n+ *          \/test\/lib\n+ * @build nsk.jdb.repeat.repeat001.repeat001a\n+ * @run main\/othervm\n+ *      nsk.jdb.repeat.repeat001.repeat001\n+ *      -arch=${os.family}-${os.simpleArch}\n+ *      -waittime=5\n+ *      -debugee.vmkind=java\n+ *      -transport.address=dynamic\n+ *      -jdb=${test.jdk}\/bin\/jdb\n+ *      -jdb.option=\"-J-Duser.language=en -J-Duser.country=US\"\n+ *      -java.options=\"${test.vm.opts} ${test.java.opts}\"\n+ *      -workdir=.\n+ *      -debugee.vmkeys=\"${test.vm.opts} ${test.java.opts}\"\n+ *\/\n+\n+package nsk.jdb.repeat.repeat001;\n+\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+\n+import nsk.share.jdb.JdbTest;\n+import nsk.share.jdb.JdbCommand;\n+import jdk.test.lib.Utils;\n+\n+\n+public class repeat001 extends JdbTest {\n+    static final String PACKAGE_NAME = \"nsk.jdb.repeat.repeat001\";\n+    static final String TEST_CLASS = PACKAGE_NAME + \".repeat001\";\n+    static final String DEBUGGEE_CLASS = TEST_CLASS + \"a\";\n+    static final String FIRST_BREAK = DEBUGGEE_CLASS + \".main\";\n+\n+    public static void main(String[] args) {\n+        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n+    }\n+\n+    public static int run(String[] args, PrintStream out) {\n+        debuggeeClass = DEBUGGEE_CLASS;\n+        firstBreak = FIRST_BREAK;\n+        return new repeat001().runTest(args, out);\n+    }\n+\n+    protected static boolean isPrompt(String line) {\n+        return line.trim().equals(\"main[1]\");\n+    }\n+\n+    @Override\n+    protected void runCases() {\n+        try {\n+            runCasesNoCleanup();\n+        } finally {\n+            jdb.contToExit(1);\n+        }\n+    }\n+\n+    protected void runCasesNoCleanup() {\n+        \/\/ Verify that repeat is off initially\n+        String[] reply = jdb.receiveReplyFor(JdbCommand.repeat);\n+        if (reply.length != 2 || !isPrompt(reply[1])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (!reply[0].equals(\"Repeat is off\")) {\n+            throw new AssertionError(\"Incorrect initial repeat setting\");\n+        }\n+\n+        \/\/ Verify that list auto-advance is disabled\n+        String[] firstList = jdb.receiveReplyFor(JdbCommand.list);\n+        String[] secondList = jdb.receiveReplyFor(JdbCommand.list);\n+        if (!Arrays.equals(firstList, secondList)) {\n+            throw new AssertionError(\"Listing inconsistent with repeat off\");\n+        }\n+\n+        \/\/ Verify that command repetition doesn't happen when disabled\n+        reply = jdb.receiveReplyFor(\"\");\n+        if (reply.length != 1 || !isPrompt(reply[0])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+\n+        reply = jdb.receiveReplyFor(JdbCommand.repeat + \"on\");\n+        if (reply.length != 1 || !isPrompt(reply[0])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+\n+        \/\/ Verify that repeat is reported on\n+        reply = jdb.receiveReplyFor(JdbCommand.repeat);\n+        if (reply.length != 2 || !isPrompt(reply[1])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (!reply[0].equals(\"Repeat is on\")) {\n+            throw new AssertionError(\"Incorrect repeat status reported\");\n+        }\n+\n+        \/\/ Verify that non-repeatable commands still don't repeat\n+        if (jdb.receiveReplyFor(JdbCommand.print + \"0\").length != 2) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (jdb.receiveReplyFor(\"\").length != 1) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+\n+        \/\/ Verify that repeated commands are repeatable\n+        \/\/ (`up' just prints `End of stack.' since we're stopped in `main')\n+        reply = jdb.receiveReplyFor(\"2 2 \" + JdbCommand.up);\n+        if (reply.length != 5 || !isPrompt(reply[4])) {\n+            throw new AssertionError(\"Unexpected output\");\n+        }\n+        if (!Arrays.equals(reply, jdb.receiveReplyFor(\"\"))) {\n+            throw new AssertionError(\"Repeated command didn't repeat correctly\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/repeat\/repeat001\/repeat001.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package nsk.jdb.repeat.repeat001;\n+\n+import nsk.share.Log;\n+import nsk.share.jdb.JdbArgumentHandler;\n+\n+import java.io.PrintStream;\n+\n+\n+\/* This is debuggee application *\/\n+public class repeat001a {\n+    static repeat001a _repeat001a = new repeat001a();\n+\n+    public static void main(String[] args) {\n+       System.exit(repeat001.JCK_STATUS_BASE + _repeat001a.runIt(args, System.out));\n+    }\n+\n+    public int runIt(String[] args, PrintStream out) {\n+        JdbArgumentHandler argumentHandler = new JdbArgumentHandler(args);\n+        Log log = new Log(out, argumentHandler);\n+\n+        log.display(\"Debuggee PASSED\");\n+        return repeat001.PASSED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/repeat\/repeat001\/repeat001a.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -102,0 +102,2 @@\n+ *   repeat                    -- show whether GDB-style empty command repetition is enabled\n+ *   repeat <on|off>           -- enable\/disable GDB-style repetition\n@@ -148,0 +150,1 @@\n+    public static final String repeat       = \"repeat \";\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/JdbCommand.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}