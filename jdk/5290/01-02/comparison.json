{"files":[{"patch":"@@ -451,1 +451,2 @@\n-             * Next check for an integer repetition prefix.\n+             * Next check for an integer repetition prefix.  If found,\n+             * recursively execute cmd that number of times.\n@@ -453,3 +454,1 @@\n-            boolean valid = true;\n-            int reps = 1;\n-            while (Character.isDigit(cmd.charAt(0)) && t.hasMoreTokens()) {\n+            if (Character.isDigit(cmd.charAt(0)) && t.hasMoreTokens()) {\n@@ -457,1 +456,6 @@\n-                    reps *= Integer.parseInt(cmd);  \/\/ nested repeats are possible\n+                    int repeat = Integer.parseInt(cmd);\n+                    String subcom = t.nextToken(\"\");\n+                    for (int r = 0; r < repeat; r += 1) {\n+                        cmd = executeCommand(new StringTokenizer(subcom));\n+                        showPrompt = false; \/\/ Bypass the printPrompt() below.\n+                    }\n@@ -459,1 +463,0 @@\n-                    valid = false;\n@@ -461,1 +464,0 @@\n-                    break;\n@@ -463,3 +465,1 @@\n-                cmd = t.nextToken().toLowerCase();\n-            }\n-            if (valid) {\n+            } else {\n@@ -467,172 +467,166 @@\n-                String argsLine = t.hasMoreTokens() ? t.nextToken(\"\") : \"\";\n-                for (int r = 0; r < reps; r += 1) {\n-                    \/*\n-                     * Check for an unknown command\n-                     *\/\n-                    if (commandNumber < 0) {\n-                        MessageOutput.println(\"Unrecognized command.  Try help...\", cmd);\n-                    } else if (!Env.connection().isOpen() && !isDisconnectCmd(commandNumber)) {\n-                        MessageOutput.println(\"Command not valid until the VM is started with the run command\",\n-                                              cmd);\n-                    } else if (Env.connection().isOpen() && !Env.vm().canBeModified() &&\n-                               !isReadOnlyCmd(commandNumber)) {\n-                        MessageOutput.println(\"Command is not supported on a read-only VM connection\",\n-                                              cmd);\n-                    } else {\n-                        Commands evaluator = new Commands();\n-                        var args = new StringTokenizer(argsLine);\n-                        try {\n-                            if (cmd.equals(\"print\")) {\n-                                evaluator.commandPrint(args, false);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"eval\")) {\n-                                evaluator.commandPrint(args, false);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"set\")) {\n-                                evaluator.commandSet(args);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"dump\")) {\n-                                evaluator.commandPrint(args, true);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"locals\")) {\n-                                evaluator.commandLocals();\n-                            } else if (cmd.equals(\"classes\")) {\n-                                evaluator.commandClasses();\n-                            } else if (cmd.equals(\"class\")) {\n-                                evaluator.commandClass(args);\n-                            } else if (cmd.equals(\"connectors\")) {\n-                                evaluator.commandConnectors(Bootstrap.virtualMachineManager());\n-                            } else if (cmd.equals(\"methods\")) {\n-                                evaluator.commandMethods(args);\n-                            } else if (cmd.equals(\"fields\")) {\n-                                evaluator.commandFields(args);\n-                            } else if (cmd.equals(\"threads\")) {\n-                                evaluator.commandThreads(args);\n-                            } else if (cmd.equals(\"thread\")) {\n-                                evaluator.commandThread(args);\n-                            } else if (cmd.equals(\"suspend\")) {\n-                                evaluator.commandSuspend(args);\n-                            } else if (cmd.equals(\"resume\")) {\n-                                evaluator.commandResume(args);\n-                            } else if (cmd.equals(\"cont\")) {\n-                                MessageOutput.printPrompt(true);\n-                                showPrompt = false;\n-                                evaluator.commandCont();\n-                            } else if (cmd.equals(\"threadgroups\")) {\n-                                evaluator.commandThreadGroups();\n-                            } else if (cmd.equals(\"threadgroup\")) {\n-                                evaluator.commandThreadGroup(args);\n-                            } else if (cmd.equals(\"catch\")) {\n-                                evaluator.commandCatchException(args);\n-                            } else if (cmd.equals(\"ignore\")) {\n-                                evaluator.commandIgnoreException(args);\n-                            } else if (cmd.equals(\"step\")) {\n-                                MessageOutput.printPrompt(true);\n-                                showPrompt = false;\n-                                evaluator.commandStep(args);\n-                            } else if (cmd.equals(\"stepi\")) {\n-                                MessageOutput.printPrompt(true);\n-                                showPrompt = false;\n-                                evaluator.commandStepi();\n-                            } else if (cmd.equals(\"next\")) {\n-                                MessageOutput.printPrompt(true);\n-                                showPrompt = false;\n-                                evaluator.commandNext();\n-                            } else if (cmd.equals(\"kill\")) {\n-                                showPrompt = false;        \/\/ asynchronous command\n-                                evaluator.commandKill(args);\n-                            } else if (cmd.equals(\"interrupt\")) {\n-                                evaluator.commandInterrupt(args);\n-                            } else if (cmd.equals(\"trace\")) {\n-                                evaluator.commandTrace(args);\n-                            } else if (cmd.equals(\"untrace\")) {\n-                                evaluator.commandUntrace(args);\n-                            } else if (cmd.equals(\"where\")) {\n-                                evaluator.commandWhere(args, false);\n-                            } else if (cmd.equals(\"wherei\")) {\n-                                evaluator.commandWhere(args, true);\n-                            } else if (cmd.equals(\"up\")) {\n-                                evaluator.commandUp(args);\n-                            } else if (cmd.equals(\"down\")) {\n-                                evaluator.commandDown(args);\n-                            } else if (cmd.equals(\"load\")) {\n-                                evaluator.commandLoad(args);\n-                            } else if (cmd.equals(\"run\")) {\n-                                evaluator.commandRun(args);\n-                                \/*\n-                                 * Fire up an event handler, if the connection was just\n-                                 * opened. Since this was done from the run command\n-                                 * we don't stop the VM on its VM start event (so\n-                                 * arg 2 is false).\n-                                 *\/\n-                                if ((handler == null) && Env.connection().isOpen()) {\n-                                    handler = new EventHandler(this, false);\n-                                }\n-                            } else if (cmd.equals(\"memory\")) {\n-                                evaluator.commandMemory();\n-                            } else if (cmd.equals(\"gc\")) {\n-                                evaluator.commandGC();\n-                            } else if (cmd.equals(\"stop\")) {\n-                                evaluator.commandStop(args);\n-                            } else if (cmd.equals(\"clear\")) {\n-                                evaluator.commandClear(args);\n-                            } else if (cmd.equals(\"watch\")) {\n-                                evaluator.commandWatch(args);\n-                            } else if (cmd.equals(\"unwatch\")) {\n-                                evaluator.commandUnwatch(args);\n-                            } else if (cmd.equals(\"list\")) {\n-                                nextListTarget = evaluator.commandList(args, repeat ? nextListTarget : null);\n-                            } else if (cmd.equals(\"lines\")) { \/\/ Undocumented command: useful for testing.\n-                                evaluator.commandLines(args);\n-                            } else if (cmd.equals(\"classpath\")) {\n-                                evaluator.commandClasspath(args);\n-                            } else if (cmd.equals(\"use\") || cmd.equals(\"sourcepath\")) {\n-                                evaluator.commandUse(args);\n-                            } else if (cmd.equals(\"monitor\")) {\n-                                monitorCommand(args);\n-                            } else if (cmd.equals(\"unmonitor\")) {\n-                                unmonitorCommand(args);\n-                            } else if (cmd.equals(\"lock\")) {\n-                                evaluator.commandLock(args);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"threadlocks\")) {\n-                                evaluator.commandThreadlocks(args);\n-                            } else if (cmd.equals(\"disablegc\")) {\n-                                evaluator.commandDisableGC(args);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"enablegc\")) {\n-                                evaluator.commandEnableGC(args);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"save\")) { \/\/ Undocumented command: useful for testing.\n-                                evaluator.commandSave(args);\n-                                showPrompt = false;        \/\/ asynchronous command\n-                            } else if (cmd.equals(\"bytecodes\")) { \/\/ Undocumented command: useful for testing.\n-                                evaluator.commandBytecodes(args);\n-                            } else if (cmd.equals(\"redefine\")) {\n-                                evaluator.commandRedefine(args);\n-                            } else if (cmd.equals(\"pop\")) {\n-                                evaluator.commandPopFrames(args, false);\n-                            } else if (cmd.equals(\"reenter\")) {\n-                                evaluator.commandPopFrames(args, true);\n-                            } else if (cmd.equals(\"extension\")) {\n-                                evaluator.commandExtension(args);\n-                            } else if (cmd.equals(\"exclude\")) {\n-                                evaluator.commandExclude(args);\n-                            } else if (cmd.equals(\"read\")) {\n-                                readCommand(args);\n-                            } else if (cmd.equals(\"dbgtrace\")) {\n-                                evaluator.commandDbgTrace(args);\n-                            } else if (cmd.equals(\"help\") || cmd.equals(\"?\")) {\n-                                help();\n-                            } else if (cmd.equals(\"version\")) {\n-                                evaluator.commandVersion(progname,\n-                                                         Bootstrap.virtualMachineManager());\n-                            } else if (cmd.equals(\"repeat\")) {\n-                                doRepeat(args);\n-                            } else if (cmd.equals(\"quit\") || cmd.equals(\"exit\")) {\n-                                if (handler != null) {\n-                                    handler.shutdown();\n-                                }\n-                                Env.shutdown();\n-                            } else {\n-                                MessageOutput.println(\"Unrecognized command.  Try help...\", cmd);\n+\n+                \/*\n+                 * Check for an unknown command\n+                 *\/\n+                if (commandNumber < 0) {\n+                    MessageOutput.println(\"Unrecognized command.  Try help...\", cmd);\n+                } else if (!Env.connection().isOpen() && !isDisconnectCmd(commandNumber)) {\n+                    MessageOutput.println(\"Command not valid until the VM is started with the run command\",\n+                                          cmd);\n+                } else if (Env.connection().isOpen() && !Env.vm().canBeModified() &&\n+                           !isReadOnlyCmd(commandNumber)) {\n+                    MessageOutput.println(\"Command is not supported on a read-only VM connection\",\n+                                          cmd);\n+                } else {\n+                    Commands evaluator = new Commands();\n+                    try {\n+                        if (cmd.equals(\"print\")) {\n+                            evaluator.commandPrint(t, false);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"eval\")) {\n+                            evaluator.commandPrint(t, false);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"set\")) {\n+                            evaluator.commandSet(t);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"dump\")) {\n+                            evaluator.commandPrint(t, true);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"locals\")) {\n+                            evaluator.commandLocals();\n+                        } else if (cmd.equals(\"classes\")) {\n+                            evaluator.commandClasses();\n+                        } else if (cmd.equals(\"class\")) {\n+                            evaluator.commandClass(t);\n+                        } else if (cmd.equals(\"connectors\")) {\n+                            evaluator.commandConnectors(Bootstrap.virtualMachineManager());\n+                        } else if (cmd.equals(\"methods\")) {\n+                            evaluator.commandMethods(t);\n+                        } else if (cmd.equals(\"fields\")) {\n+                            evaluator.commandFields(t);\n+                        } else if (cmd.equals(\"threads\")) {\n+                            evaluator.commandThreads(t);\n+                        } else if (cmd.equals(\"thread\")) {\n+                            evaluator.commandThread(t);\n+                        } else if (cmd.equals(\"suspend\")) {\n+                            evaluator.commandSuspend(t);\n+                        } else if (cmd.equals(\"resume\")) {\n+                            evaluator.commandResume(t);\n+                        } else if (cmd.equals(\"cont\")) {\n+                            MessageOutput.printPrompt(true);\n+                            showPrompt = false;\n+                            evaluator.commandCont();\n+                        } else if (cmd.equals(\"threadgroups\")) {\n+                            evaluator.commandThreadGroups();\n+                        } else if (cmd.equals(\"threadgroup\")) {\n+                            evaluator.commandThreadGroup(t);\n+                        } else if (cmd.equals(\"catch\")) {\n+                            evaluator.commandCatchException(t);\n+                        } else if (cmd.equals(\"ignore\")) {\n+                            evaluator.commandIgnoreException(t);\n+                        } else if (cmd.equals(\"step\")) {\n+                            MessageOutput.printPrompt(true);\n+                            showPrompt = false;\n+                            evaluator.commandStep(t);\n+                        } else if (cmd.equals(\"stepi\")) {\n+                            MessageOutput.printPrompt(true);\n+                            showPrompt = false;\n+                            evaluator.commandStepi();\n+                        } else if (cmd.equals(\"next\")) {\n+                            MessageOutput.printPrompt(true);\n+                            showPrompt = false;\n+                            evaluator.commandNext();\n+                        } else if (cmd.equals(\"kill\")) {\n+                            showPrompt = false;        \/\/ asynchronous command\n+                            evaluator.commandKill(t);\n+                        } else if (cmd.equals(\"interrupt\")) {\n+                            evaluator.commandInterrupt(t);\n+                        } else if (cmd.equals(\"trace\")) {\n+                            evaluator.commandTrace(t);\n+                        } else if (cmd.equals(\"untrace\")) {\n+                            evaluator.commandUntrace(t);\n+                        } else if (cmd.equals(\"where\")) {\n+                            evaluator.commandWhere(t, false);\n+                        } else if (cmd.equals(\"wherei\")) {\n+                            evaluator.commandWhere(t, true);\n+                        } else if (cmd.equals(\"up\")) {\n+                            evaluator.commandUp(t);\n+                        } else if (cmd.equals(\"down\")) {\n+                            evaluator.commandDown(t);\n+                        } else if (cmd.equals(\"load\")) {\n+                            evaluator.commandLoad(t);\n+                        } else if (cmd.equals(\"run\")) {\n+                            evaluator.commandRun(t);\n+                            \/*\n+                             * Fire up an event handler, if the connection was just\n+                             * opened. Since this was done from the run command\n+                             * we don't stop the VM on its VM start event (so\n+                             * arg 2 is false).\n+                             *\/\n+                            if ((handler == null) && Env.connection().isOpen()) {\n+                                handler = new EventHandler(this, false);\n+                            }\n+                        } else if (cmd.equals(\"memory\")) {\n+                            evaluator.commandMemory();\n+                        } else if (cmd.equals(\"gc\")) {\n+                            evaluator.commandGC();\n+                        } else if (cmd.equals(\"stop\")) {\n+                            evaluator.commandStop(t);\n+                        } else if (cmd.equals(\"clear\")) {\n+                            evaluator.commandClear(t);\n+                        } else if (cmd.equals(\"watch\")) {\n+                            evaluator.commandWatch(t);\n+                        } else if (cmd.equals(\"unwatch\")) {\n+                            evaluator.commandUnwatch(t);\n+                        } else if (cmd.equals(\"list\")) {\n+                            nextListTarget = evaluator.commandList(t, repeat ? nextListTarget : null);\n+                        } else if (cmd.equals(\"lines\")) { \/\/ Undocumented command: useful for testing.\n+                            evaluator.commandLines(t);\n+                        } else if (cmd.equals(\"classpath\")) {\n+                            evaluator.commandClasspath(t);\n+                        } else if (cmd.equals(\"use\") || cmd.equals(\"sourcepath\")) {\n+                            evaluator.commandUse(t);\n+                        } else if (cmd.equals(\"monitor\")) {\n+                            monitorCommand(t);\n+                        } else if (cmd.equals(\"unmonitor\")) {\n+                            unmonitorCommand(t);\n+                        } else if (cmd.equals(\"lock\")) {\n+                            evaluator.commandLock(t);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"threadlocks\")) {\n+                            evaluator.commandThreadlocks(t);\n+                        } else if (cmd.equals(\"disablegc\")) {\n+                            evaluator.commandDisableGC(t);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"enablegc\")) {\n+                            evaluator.commandEnableGC(t);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"save\")) { \/\/ Undocumented command: useful for testing.\n+                            evaluator.commandSave(t);\n+                            showPrompt = false;        \/\/ asynchronous command\n+                        } else if (cmd.equals(\"bytecodes\")) { \/\/ Undocumented command: useful for testing.\n+                            evaluator.commandBytecodes(t);\n+                        } else if (cmd.equals(\"redefine\")) {\n+                            evaluator.commandRedefine(t);\n+                        } else if (cmd.equals(\"pop\")) {\n+                            evaluator.commandPopFrames(t, false);\n+                        } else if (cmd.equals(\"reenter\")) {\n+                            evaluator.commandPopFrames(t, true);\n+                        } else if (cmd.equals(\"extension\")) {\n+                            evaluator.commandExtension(t);\n+                        } else if (cmd.equals(\"exclude\")) {\n+                            evaluator.commandExclude(t);\n+                        } else if (cmd.equals(\"read\")) {\n+                            readCommand(t);\n+                        } else if (cmd.equals(\"dbgtrace\")) {\n+                            evaluator.commandDbgTrace(t);\n+                        } else if (cmd.equals(\"help\") || cmd.equals(\"?\")) {\n+                            help();\n+                        } else if (cmd.equals(\"version\")) {\n+                            evaluator.commandVersion(progname,\n+                                                     Bootstrap.virtualMachineManager());\n+                        } else if (cmd.equals(\"repeat\")) {\n+                            doRepeat(t);\n+                        } else if (cmd.equals(\"quit\") || cmd.equals(\"exit\")) {\n+                            if (handler != null) {\n+                                handler.shutdown();\n@@ -640,9 +634,3 @@\n-                        } catch (VMCannotBeModifiedException rovm) {\n-                            MessageOutput.println(\"Command is not supported on a read-only VM connection\", cmd);\n-                        } catch (UnsupportedOperationException uoe) {\n-                            MessageOutput.println(\"Command is not supported on the target VM\", cmd);\n-                        } catch (VMNotConnectedException vmnse) {\n-                            MessageOutput.println(\"Command not valid until the VM is started with the run command\",\n-                                                  cmd);\n-                        } catch (Exception e) {\n-                            MessageOutput.printException(\"Internal exception:\", e);\n+                            Env.shutdown();\n+                        } else {\n+                            MessageOutput.println(\"Unrecognized command.  Try help...\", cmd);\n@@ -650,0 +638,9 @@\n+                    } catch (VMCannotBeModifiedException rovm) {\n+                        MessageOutput.println(\"Command is not supported on a read-only VM connection\", cmd);\n+                    } catch (UnsupportedOperationException uoe) {\n+                        MessageOutput.println(\"Command is not supported on the target VM\", cmd);\n+                    } catch (VMNotConnectedException vmnse) {\n+                        MessageOutput.println(\"Command not valid until the VM is started with the run command\",\n+                                              cmd);\n+                    } catch (Exception e) {\n+                        MessageOutput.printException(\"Internal exception:\", e);\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTY.java","additions":188,"deletions":191,"binary":false,"changes":379,"status":"modified"}]}