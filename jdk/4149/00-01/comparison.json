{"files":[{"patch":"@@ -70,1 +70,1 @@\n-void ConstantPool::copy_fields(const ConstantPool* orig, bool skip_version) {\n+void ConstantPool::copy_fields(const ConstantPool* orig) {\n@@ -76,8 +76,2 @@\n-  if (!skip_version) {\n-    \/\/ Copy class version.\n-    \/\/ We don't do this for redefined classes (skip_version == true)\n-    \/\/ because the class file version of the new class might be different\n-    \/\/ from the original class.\n-    set_major_version(orig->major_version());\n-    set_minor_version(orig->minor_version());\n-  }\n+  set_major_version(orig->major_version());\n+  set_minor_version(orig->minor_version());\n","filename":"src\/hotspot\/share\/oops\/constantPool.cpp","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-  void copy_fields(const ConstantPool* orig, bool skip_version = false);\n+  void copy_fields(const ConstantPool* orig);\n","filename":"src\/hotspot\/share\/oops\/constantPool.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1855,7 +1855,6 @@\n-  \/\/ Copy class version from scratch_cp to merge_cp\n-  merge_cp->set_minor_version(scratch_cp->minor_version());\n-  merge_cp->set_major_version(scratch_cp->major_version());\n-\n-  \/\/ Save fields from the old_cp.\n-  merge_cp->copy_fields(old_cp(), true \/* skip_version *\/);\n-  scratch_cp->copy_fields(old_cp(), true \/* skip_version *\/);\n+  \/\/ Set dynamic constants attribute from the original CP.\n+  if (old_cp->has_dynamic_constant()) {\n+    scratch_cp->set_has_dynamic_constant();\n+  }\n+  \/\/ Copy attributes from scratch_cp to merge_cp\n+  merge_cp->copy_fields(scratch_cp());\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8267555\n- * @requires vm.jvmti\n- * @summary Class redefinition with a different class file version\n- * @library \/test\/lib\n- * @compile TestClassOld.jasm TestClassNew.jasm\n- * @run main\/othervm -Djdk.attach.allowAttachSelf test.ClassVersionAfterRedefine\n- *\/\n-\n-package test;\n-\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.InputStream;\n-import java.lang.instrument.ClassDefinition;\n-import java.lang.instrument.Instrumentation;\n-import java.lang.reflect.Method;\n-import java.util.jar.Attributes;\n-import java.util.jar.JarEntry;\n-import java.util.jar.JarOutputStream;\n-import java.util.jar.Manifest;\n-\n-import com.sun.tools.attach.VirtualMachine;\n-import static jdk.test.lib.Asserts.assertTrue;\n-\n-public class ClassVersionAfterRedefine extends ClassLoader {\n-\n-    private static String myName = ClassVersionAfterRedefine.class.getName();\n-    private static Instrumentation instrumentation;\n-\n-    private static byte[] getBytecodes(String name) throws Exception {\n-        InputStream is = ClassVersionAfterRedefine.class.getResourceAsStream(name + \".class\");\n-        byte[] buf = is.readAllBytes();\n-        System.out.println(\"sizeof(\" + name + \".class) == \" + buf.length);\n-        return buf;\n-    }\n-\n-    private static int getStringIndex(String needle, byte[] buf) {\n-        return getStringIndex(needle, buf, 0);\n-    }\n-\n-    private static int getStringIndex(String needle, byte[] buf, int offset) {\n-        outer:\n-        for (int i = offset; i < buf.length - offset - needle.length(); i++) {\n-            for (int j = 0; j < needle.length(); j++) {\n-                if (buf[i + j] != (byte)needle.charAt(j)) continue outer;\n-            }\n-            return i;\n-        }\n-        return 0;\n-    }\n-\n-    private static void replaceString(byte[] buf, String name, int index) {\n-        for (int i = index; i < index + name.length(); i++) {\n-            buf[i] = (byte)name.charAt(i - index);\n-        }\n-    }\n-\n-    private static void replaceAllStrings(byte[] buf, String oldString, String newString) throws Exception {\n-        assertTrue(oldString.length() == newString.length(), \"must have same length\");\n-        int index = -1;\n-        while ((index = getStringIndex(oldString, buf, index + 1)) != 0) {\n-            replaceString(buf, newString, index);\n-        }\n-    }\n-\n-    public static void agentmain(String args, Instrumentation inst) {\n-        System.out.println(\"Loading Java Agent.\");\n-        instrumentation = inst;\n-    }\n-\n-    private static void loadInstrumentationAgent(String myName, byte[] buf) throws Exception {\n-        \/\/ Create agent jar file on the fly\n-        Manifest m = new Manifest();\n-        m.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n-        m.getMainAttributes().put(new Attributes.Name(\"Agent-Class\"), myName);\n-        m.getMainAttributes().put(new Attributes.Name(\"Can-Redefine-Classes\"), \"true\");\n-        File jarFile = File.createTempFile(\"agent\", \".jar\");\n-        jarFile.deleteOnExit();\n-        JarOutputStream jar = new JarOutputStream(new FileOutputStream(jarFile), m);\n-        jar.putNextEntry(new JarEntry(myName.replace('.', '\/') + \".class\"));\n-        jar.write(buf);\n-        jar.close();\n-        String pid = Long.valueOf(ProcessHandle.current().pid()).toString();\n-        System.out.println(\"Our pid is = \" + pid);\n-        VirtualMachine vm = VirtualMachine.attach(pid);\n-        System.out.println(jarFile.getAbsolutePath());\n-        vm.loadAgent(jarFile.getAbsolutePath());\n-    }\n-\n-    public static void main(String[] s) throws Exception {\n-\n-        byte[] buf = getBytecodes(myName.substring(myName.lastIndexOf(\".\") + 1));\n-        loadInstrumentationAgent(myName, buf);\n-\n-        buf = getBytecodes(\"TestClassOld\");\n-        \/\/ Poor man's renaming of class \"TestClassOld\" to \"TestClassXXX\"\n-        replaceAllStrings(buf, \"TestClassOld\", \"TestClassXXX\");\n-        ClassVersionAfterRedefine cvar = new ClassVersionAfterRedefine();\n-        Class<?> old = cvar.defineClass(null, buf, 0, buf.length);\n-        Method foo = old.getMethod(\"foo\");\n-        Object result = foo.invoke(null);\n-        assertTrue(\"java-lang-String\".equals(result));\n-        System.out.println(old.getSimpleName() + \".foo() = \" + result);\n-\n-        buf = getBytecodes(\"TestClassNew\");\n-        \/\/ Rename class \"TestClassNew\" to \"TestClassXXX\" so we can use it for\n-        \/\/ redefining the original version of \"TestClassXXX\" (i.e. \"TestClassOld\").\n-        replaceAllStrings(buf, \"TestClassNew\", \"TestClassXXX\");\n-        instrumentation.redefineClasses(new ClassDefinition(old, buf));\n-        result = foo.invoke(null);\n-        assertTrue(\"java.lang.String\".equals(result));\n-        System.out.println(old.getSimpleName() + \".foo() = \" + result);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ConstantPool\/ClassVersion\/ClassVersionAfterRedefine.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8267555\n+ * @requires vm.jvmti\n+ * @summary Class redefinition with a different class file version\n+ * @library \/test\/lib\n+ * @compile TestClassOld.jasm TestClassNew.jasm\n+ * @run main RedefineClassHelper\n+ * @run main\/othervm -javaagent:redefineagent.jar ClassVersionAfterRedefine\n+ *\/\n+\n+import java.io.InputStream;\n+import java.lang.reflect.Method;\n+\n+import static jdk.test.lib.Asserts.assertTrue;\n+\n+public class ClassVersionAfterRedefine extends ClassLoader {\n+\n+    private static String myName = ClassVersionAfterRedefine.class.getName();\n+\n+    private static byte[] getBytecodes(String name) throws Exception {\n+        InputStream is = ClassVersionAfterRedefine.class.getResourceAsStream(name + \".class\");\n+        byte[] buf = is.readAllBytes();\n+        System.out.println(\"sizeof(\" + name + \".class) == \" + buf.length);\n+        return buf;\n+    }\n+\n+    private static int getStringIndex(String needle, byte[] buf) {\n+        return getStringIndex(needle, buf, 0);\n+    }\n+\n+    private static int getStringIndex(String needle, byte[] buf, int offset) {\n+        outer:\n+        for (int i = offset; i < buf.length - offset - needle.length(); i++) {\n+            for (int j = 0; j < needle.length(); j++) {\n+                if (buf[i + j] != (byte)needle.charAt(j)) continue outer;\n+            }\n+            return i;\n+        }\n+        return 0;\n+    }\n+\n+    private static void replaceString(byte[] buf, String name, int index) {\n+        for (int i = index; i < index + name.length(); i++) {\n+            buf[i] = (byte)name.charAt(i - index);\n+        }\n+    }\n+\n+    private static void replaceAllStrings(byte[] buf, String oldString, String newString) throws Exception {\n+        assertTrue(oldString.length() == newString.length(), \"must have same length\");\n+        int index = -1;\n+        while ((index = getStringIndex(oldString, buf, index + 1)) != 0) {\n+            replaceString(buf, newString, index);\n+        }\n+    }\n+\n+    public static void main(String[] s) throws Exception {\n+\n+        byte[] buf = getBytecodes(\"TestClassOld\");\n+        \/\/ Poor man's renaming of class \"TestClassOld\" to \"TestClassXXX\"\n+        replaceAllStrings(buf, \"TestClassOld\", \"TestClassXXX\");\n+        ClassVersionAfterRedefine cvar = new ClassVersionAfterRedefine();\n+        Class<?> old = cvar.defineClass(null, buf, 0, buf.length);\n+        Method foo = old.getMethod(\"foo\");\n+        Object result = foo.invoke(null);\n+        assertTrue(\"java-lang-String\".equals(result));\n+        System.out.println(old.getSimpleName() + \".foo() = \" + result);\n+\n+        buf = getBytecodes(\"TestClassNew\");\n+        \/\/ Rename class \"TestClassNew\" to \"TestClassXXX\" so we can use it for\n+        \/\/ redefining the original version of \"TestClassXXX\" (i.e. \"TestClassOld\").\n+        replaceAllStrings(buf, \"TestClassNew\", \"TestClassXXX\");\n+        \/\/ Now redine the original version of \"TestClassXXX\" (i.e. \"TestClassOld\").\n+        RedefineClassHelper.redefineClass(old, buf);\n+        result = foo.invoke(null);\n+        assertTrue(\"java.lang.String\".equals(result));\n+        System.out.println(old.getSimpleName() + \".foo() = \" + result);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/ClassVersionAfterRedefine.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -24,2 +24,0 @@\n-package test;\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestClassNew.jasm","additions":0,"deletions":2,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ConstantPool\/ClassVersion\/TestClassNew.jasm","status":"renamed"},{"patch":"@@ -24,2 +24,0 @@\n-package test;\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/RedefineClasses\/TestClassOld.jasm","additions":0,"deletions":2,"binary":false,"changes":2,"previous_filename":"test\/hotspot\/jtreg\/runtime\/ConstantPool\/ClassVersion\/TestClassOld.jasm","status":"renamed"}]}