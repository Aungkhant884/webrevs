{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,27 @@\n+BufferNode::Allocator::PendingList::PendingList() :\n+  _tail(nullptr), _head(nullptr), _count(0) {}\n+\n+BufferNode::Allocator::PendingList::~PendingList() {\n+  delete_list(Atomic::load(&_head));\n+}\n+\n+size_t BufferNode::Allocator::PendingList::add(BufferNode* node) {\n+  assert(node->next() == nullptr, \"precondition\");\n+  BufferNode* old_head = Atomic::xchg(&_head, node);\n+  if (old_head != nullptr) {\n+    node->set_next(old_head);\n+  } else {\n+    assert(_tail == nullptr, \"invariant\");\n+    _tail = node;\n+  }\n+  return Atomic::add(&_count, size_t(1));\n+}\n+\n+BufferNodeList BufferNode::Allocator::PendingList::take_all() {\n+  BufferNodeList result{Atomic::load(&_head), _tail, Atomic::load(&_count)};\n+  Atomic::store(&_head, (BufferNode*)nullptr);\n+  _tail = nullptr;\n+  Atomic::store(&_count, size_t(0));\n+  return result;\n+}\n+\n@@ -61,1 +88,2 @@\n-  _pending_list(),\n+  _pending_lists(),\n+  _active_pending_list(0),\n@@ -63,1 +91,0 @@\n-  _pending_count(0),\n@@ -73,1 +100,0 @@\n-  delete_list(_pending_list.pop_all());\n@@ -112,1 +138,1 @@\n-\/\/ initially place released nodes on the _pending_list, and transfer\n+\/\/ initially place released nodes on the pending list, and transfer\n@@ -114,6 +140,3 @@\n-\/\/ permitted, with a lock bit to control access to that phase.  A\n-\/\/ transfer takes all the nodes from the _pending_list, synchronizes on\n-\/\/ the _free_list pops, and then adds the former pending nodes to the\n-\/\/ _free_list.  While that's happening, other threads might be adding\n-\/\/ other nodes to the _pending_list, to be dealt with by some later\n-\/\/ transfer.\n+\/\/ permitted, with a lock bit to control access to that phase.  While\n+\/\/ a transfer is in progress, other threads might be adding other nodes\n+\/\/ to the pending list, to be dealt with by some later transfer.\n@@ -133,5 +156,8 @@\n-  \/\/ Add to pending list. Update count first so no underflow in transfer.\n-  size_t pending_count = Atomic::add(&_pending_count, 1u);\n-  _pending_list.push(*node);\n-  if (pending_count > trigger_transfer) {\n-    try_transfer_pending();\n+  \/\/ The pending list is double-buffered.  Add node to the currently active\n+  \/\/ pending list, within a critical section so a transfer will wait until\n+  \/\/ we're done with what might be the pending list to be transferred.\n+  {\n+    GlobalCounter::CriticalSection cs(Thread::current());\n+    uint index = Atomic::load_acquire(&_active_pending_list);\n+    size_t count = _pending_lists[index].add(node);\n+    if (count <= trigger_transfer) return;\n@@ -139,0 +165,2 @@\n+  \/\/ Attempt transfer when number pending exceeds the transfer threshold.\n+  try_transfer_pending();\n@@ -141,1 +169,1 @@\n-\/\/ Try to transfer nodes from _pending_list to _free_list, with a\n+\/\/ Try to transfer nodes from the pending list to _free_list, with a\n@@ -154,16 +182,15 @@\n-  \/\/ Claim all the pending nodes.\n-  BufferNode* first = _pending_list.pop_all();\n-  if (first != NULL) {\n-    \/\/ Prepare to add the claimed nodes, and update _pending_count.\n-    BufferNode* last = first;\n-    size_t count = 1;\n-    for (BufferNode* next = first->next(); next != NULL; next = next->next()) {\n-      last = next;\n-      ++count;\n-    }\n-    Atomic::sub(&_pending_count, count);\n-\n-    \/\/ Wait for any in-progress pops, to avoid ABA for them.\n-    GlobalCounter::write_synchronize();\n-\n-    \/\/ Add synchronized nodes to _free_list.\n+  \/\/ Change which pending list is active.  Don't need an atomic RMW since\n+  \/\/ we have the lock and we're the only writer.\n+  uint index = Atomic::load(&_active_pending_list);\n+  uint new_active = (index + 1) % ARRAY_SIZE(_pending_lists);\n+  Atomic::release_store(&_active_pending_list, new_active);\n+\n+  \/\/ Wait for all critical sections in the buffer life-cycle to complete.\n+  \/\/ This includes _free_list pops and adding to the now inactive pending\n+  \/\/ list.\n+  GlobalCounter::write_synchronize();\n+\n+  \/\/ Transfer the inactive pending list to _free_list.\n+  BufferNodeList transfer_list = _pending_lists[index].take_all();\n+  size_t count = transfer_list._entry_count;\n+  if (count > 0) {\n@@ -172,1 +199,1 @@\n-    _free_list.prepend(*first, *last);\n+    _free_list.prepend(*transfer_list._head, *transfer_list._tail);\n@@ -174,1 +201,1 @@\n-             (\"Transferred %s pending to free: \" SIZE_FORMAT, name(), count);\n+             (\"Transferred %s pending to free: %zu\", name(), count);\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.cpp","additions":62,"deletions":35,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/bufferNodeList.hpp\"\n@@ -184,0 +185,20 @@\n+  class PendingList {\n+    BufferNode* _tail;\n+    DECLARE_PADDED_MEMBER(1, BufferNode* volatile, _head);\n+    DECLARE_PADDED_MEMBER(2, volatile size_t, _count);\n+\n+    NONCOPYABLE(PendingList);\n+\n+  public:\n+    PendingList();\n+    ~PendingList();\n+\n+    \/\/ Add node to the list.  Returns the number of nodes in the list.\n+    \/\/ Thread-safe against concurrent add operations.\n+    size_t add(BufferNode* node);\n+\n+    \/\/ Return the nodes in the list, leaving the list empty.\n+    \/\/ Not thread-safe.\n+    BufferNodeList take_all();\n+  };\n+\n@@ -186,1 +207,2 @@\n-  DECLARE_PADDED_MEMBER(1, Stack, _pending_list);\n+  PendingList _pending_lists[2];\n+  DECLARE_PADDED_MEMBER(1, volatile uint, _active_pending_list);\n@@ -188,3 +210,2 @@\n-  DECLARE_PADDED_MEMBER(3, volatile size_t, _pending_count);\n-  DECLARE_PADDED_MEMBER(4, volatile size_t, _free_count);\n-  DECLARE_PADDED_MEMBER(5, volatile bool, _transfer_lock);\n+  DECLARE_PADDED_MEMBER(3, volatile size_t, _free_count);\n+  DECLARE_PADDED_MEMBER(4, volatile bool, _transfer_lock);\n@@ -194,1 +215,1 @@\n-  void delete_list(BufferNode* list);\n+  static void delete_list(BufferNode* list);\n","filename":"src\/hotspot\/share\/gc\/shared\/ptrQueue.hpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"}]}