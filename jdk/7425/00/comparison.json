{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include <math.h>\n@@ -41,0 +42,1 @@\n+#include \"debug_assert.h\"\n@@ -2864,0 +2866,8 @@\n+inline static int scale_down_to_plus_inf(int what, int scale) {\n+    return (int)ceilf(what \/ (float)scale);\n+}\n+\n+inline static int scale_down_to_minus_inf(int what, int scale) {\n+    return (int)floorf(what \/ (float)scale);\n+}\n+\n@@ -2870,0 +2880,2 @@\n+    int skip_left = 0;\n+    int skip_top = 0;\n@@ -2873,0 +2885,18 @@\n+\n+        \/\/ Scale the coordinate and size carefully such that the captured area\n+        \/\/ is at least as large as requested. We trim off excess later by\n+        \/\/ using the skip_* variables.\n+        const int x_scaled = scale_down_to_minus_inf(x, win_scale);\n+        const int y_scaled = scale_down_to_minus_inf(y, win_scale);\n+        skip_left = x - x_scaled*win_scale;\n+        skip_top  = y - y_scaled*win_scale;\n+        DASSERT(skip_left >= 0 && skip_top >= 0);\n+\n+        const int x_right_scaled = scale_down_to_plus_inf(x + width, win_scale);\n+        const int width_scaled = x_right_scaled - x_scaled;\n+        DASSERT(width_scaled > 0);\n+\n+        const int y_bottom_scaled = scale_down_to_plus_inf(y + height, win_scale);\n+        const int height_scaled = y_bottom_scaled - y_scaled;\n+        DASSERT(height_scaled > 0);\n+\n@@ -2874,1 +2904,1 @@\n-            root, x, y, (int) (width \/ (float) win_scale + 0.5), (int) (height \/ (float) win_scale + 0.5));\n+            root, x_scaled, y_scaled, width_scaled, height_scaled);\n@@ -2909,1 +2939,2 @@\n-                        p = pix + (intptr_t) _y * stride + _x * nchan;\n+                        p = pix + (intptr_t) (_y + skip_top) * stride\n+                                + (_x + skip_left) * nchan;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk3_interface.c","additions":34,"deletions":3,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.awt.Point;\n@@ -34,0 +35,3 @@\n+import javax.imageio.ImageIO;\n+import java.io.File;\n+import java.io.IOException;\n@@ -38,2 +42,2 @@\n- * @bug 8073320\n- * @summary  Windows HiDPI support\n+ * @bug 8073320 8280861\n+ * @summary  Linux and Windows HiDPI support\n@@ -44,0 +48,2 @@\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 HiDPIRobotScreenCaptureTest\n+ * @run main\/othervm -Dsun.java2d.uiScale=2 HiDPIRobotScreenCaptureTest\n@@ -63,1 +69,8 @@\n-        frame.setBounds(40, 30, 400, 300);\n+        \/\/ Position the frame on prime number coordinates to avoid\n+        \/\/ them being multiple of the desktop scale; this tests Linux\n+        \/\/ color picker better.\n+        \/\/ Also, the position should be far enough from the top left\n+        \/\/ corner of the screen to reduce the chance of being repositioned\n+        \/\/ by the system because that area's occupied by the global\n+        \/\/ menu bar and such.\n+        frame.setBounds(83, 97, 400, 300);\n@@ -81,0 +94,7 @@\n+\n+                \/\/ Several distinct pixels next to one another\n+                \/\/ in order to test color picker's precision.\n+                for (int i = 1; i < 4; i++) {\n+                    g.setColor(COLORS[i]);\n+                    g.fillRect(i, 0, 1, 1);\n+                }\n@@ -89,1 +109,4 @@\n-        Thread.sleep(200);\n+        robot.delay(500);\n+\n+        final Point screenLocation = frame.getLocationOnScreen();\n+        checkPixelColors(robot, screenLocation.x, screenLocation.y);\n@@ -94,0 +117,1 @@\n+        System.out.println(\"Creating screen capture of \" + rect);\n@@ -104,3 +128,0 @@\n-        if (image.getRGB(w \/ 4, h \/ 4) != COLORS[0].getRGB()) {\n-            throw new RuntimeException(\"Wrong image color!\");\n-        }\n@@ -108,3 +129,13 @@\n-        if (image.getRGB(3 * w \/ 4, h \/ 4) != COLORS[1].getRGB()) {\n-            throw new RuntimeException(\"Wrong image color!\");\n-        }\n+        checkRectColor(image, new Rectangle(0, 0, w \/ 2, h \/ 2), COLORS[0]);\n+        checkRectColor(image, new Rectangle(w \/ 2, 0, w \/ 2, h \/ 2), COLORS[1]);\n+        checkRectColor(image, new Rectangle(0, h \/ 2, w \/ 2, h \/ 2), COLORS[2]);\n+        checkRectColor(image, new Rectangle(w \/ 2, h \/ 2, w \/ 2, h \/ 2), COLORS[3]);\n+    }\n+\n+    static void checkPixelColors(Robot robot, int x, int y) {\n+        for (int i = 0; i < 4; i++) {\n+            final Color actualColor = robot.getPixelColor(x + i, y);\n+            System.out.print(\"Checking color at \" + (x + i) + \", \" + y + \" to be equal to \" + COLORS[i]);\n+            if (!actualColor.equals(COLORS[i])) {\n+                System.out.println(\"... Mismatch: found \" + actualColor + \" instead\");\n+                throw new RuntimeException(\"Wrong screen pixel color\");\n@@ -112,2 +143,3 @@\n-        if (image.getRGB(w \/ 4, 3 * h \/ 4) != COLORS[2].getRGB()) {\n-            throw new RuntimeException(\"Wrong image color!\");\n+            } else {\n+                System.out.println(\"... OK\");\n+            }\n@@ -115,0 +147,1 @@\n+    }\n@@ -116,2 +149,26 @@\n-        if (image.getRGB(3 * w \/ 4, 3 * h \/ 4) != COLORS[3].getRGB()) {\n-            throw new RuntimeException(\"Wrong image color!\");\n+    private static final int OFFSET = 5;\n+    static void checkRectColor(BufferedImage image, Rectangle rect, Color expectedColor) {\n+        System.out.println(\"Checking rectangle \" + rect + \" to have color \" + expectedColor);\n+        final Point[] pointsToCheck = new Point[] {\n+                new Point(rect.x + OFFSET, rect.y + OFFSET),                           \/\/ top left corner\n+                new Point(rect.x + rect.width - OFFSET, rect.y + OFFSET),              \/\/ top right corner\n+                new Point(rect.x + rect.width \/ 2, rect.y + rect.height \/ 2),          \/\/ center\n+                new Point(rect.x + OFFSET, rect.y + rect.height - OFFSET),             \/\/ bottom left corner\n+                new Point(rect.x + rect.width - OFFSET, rect.y + rect.height - OFFSET) \/\/ bottom right corner\n+        };\n+\n+        for (final var point : pointsToCheck) {\n+            System.out.print(\"Checking color at \" + point + \" to be equal to \" + expectedColor);\n+            final int actualColor = image.getRGB(point.x, point.y);\n+            if (actualColor != expectedColor.getRGB()) {\n+                System.out.println(\"... Mismatch: found \" + new Color(actualColor) + \" instead. Check image.png.\");\n+                try {\n+                    ImageIO.write(image, \"png\", new File(\"image.png\"));\n+                } catch(IOException e) {\n+                    System.out.println(\"failed to save image.png.\");\n+                    e.printStackTrace();\n+                }\n+                throw new RuntimeException(\"Wrong image color!\");\n+            } else {\n+                System.out.println(\"... OK\");\n+            }\n@@ -120,1 +177,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/HiDPIRobotScreenCaptureTest.java","additions":73,"deletions":16,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-                    frame.setSize(200, 200);\n+                    frame.setSize(400, 400);\n","filename":"test\/jdk\/javax\/swing\/JPasswordField\/TestSelectedTextBackgroundColor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                    frame.setSize(200, 200);\n+                    frame.setSize(400, 400);\n","filename":"test\/jdk\/javax\/swing\/JProgressBar\/TestJProgressBarHighlightColor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-                    frame.setSize(200, 200);\n+                    frame.setSize(400, 400);\n","filename":"test\/jdk\/javax\/swing\/JSlider\/TestJSliderRendering.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-                    frame.setSize(200, 200);\n+                    frame.setSize(400, 400);\n","filename":"test\/jdk\/javax\/swing\/JSpinner\/TestSelectedTextBackgroundColor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -99,1 +99,1 @@\n-                    frame.setSize(200, 200);\n+                    frame.setSize(400, 400);\n","filename":"test\/jdk\/javax\/swing\/JTextPane\/TestJTextPaneBackgroundColor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -137,1 +137,1 @@\n-                    frame.setSize(200, 200);\n+                    frame.setSize(400, 400);\n","filename":"test\/jdk\/javax\/swing\/JToolTip\/TestTooltipBackgroundColor.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}