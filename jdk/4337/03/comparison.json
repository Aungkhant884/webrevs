{"files":[{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n+  if (_cb->frame_size() <= 0) {\n+    return false;\n+  }\n+\n+  *sender_sp = unextended_sp + _cb->frame_size();\n+  \/\/ Is sender_sp safe?\n+  if (thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  *sender_pc = (address)*((*sender_sp) - frame::return_addr_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset);\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (!fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n+  \/\/ which can be different from the sender unextended sp (the sp seen\n+  \/\/ by the sender) because of current frame local variables\n+  *sender_sp = fp + frame::sender_sp_offset;\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = (intptr_t*)*(fp + frame::interpreter_frame_sender_sp_offset);\n+  if (saved_fp) *saved_fp = (intptr_t**)(fp + frame::link_offset);\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -59,0 +59,2 @@\n+  ResourceMark rm;\n+\n@@ -120,37 +122,8 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n-      \/\/ which can be different from the sender unextended sp (the sp seen\n-      \/\/ by the sender) because of current frame local variables\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-      sender_unextended_sp = (intptr_t*) this->fp()[interpreter_frame_sender_sp_offset];\n-      saved_fp = (intptr_t*) this->fp()[link_offset];\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n-      if (_cb->frame_size() <= 0) {\n-        return false;\n-      }\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      sender_unextended_sp = sender_sp;\n-      sender_pc = (address) *(sender_sp-1);\n-      \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+    intptr_t*  sender_sp = NULL;\n+    intptr_t*  sender_unextended_sp = NULL;\n+    address    sender_pc = NULL;\n+    intptr_t** saved_fp =  NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, &sender_unextended_sp, &saved_fp)) {\n+      return false;\n@@ -159,1 +132,0 @@\n-\n@@ -167,1 +139,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -173,1 +145,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -202,1 +174,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -208,1 +180,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -456,0 +428,2 @@\n+  ResourceMark rm;\n+\n@@ -461,5 +435,0 @@\n-  intptr_t* l_sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = l_sender_sp;\n-\n-  \/\/ the return_address is always the word on the stack\n-  address sender_pc = (address) *(l_sender_sp-1);\n@@ -467,1 +436,7 @@\n-  intptr_t** saved_fp_addr = (intptr_t**) (l_sender_sp - frame::sender_sp_offset);\n+  intptr_t*  l_sender_sp;\n+  intptr_t*  l_unextended_sp;\n+  address    l_sender_pc;\n+  intptr_t** l_saved_fp;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, &l_unextended_sp, &l_saved_fp);\n@@ -488,1 +463,1 @@\n-  return frame(l_sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  return frame(l_sender_sp, l_unextended_sp, *l_saved_fp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":24,"deletions":49,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  *sender_sp = unextended_sp + _cb->frame_size();\n+  \/\/ Is sender_sp safe?\n+  if (thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ With our calling conventions, the return_address should\n+  \/\/ end up being the word on the stack\n+  *sender_pc = (address)*((*sender_sp) - frame::sender_sp_offset + frame::return_addr_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset + frame::link_offset);\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (!fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  *sender_sp = fp + frame::sender_sp_offset;\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  ResourceMark rm;\n+\n@@ -101,22 +103,4 @@\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      \/\/ With our calling conventions, the return_address should\n-      \/\/ end up being the word on the stack\n-      sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n@@ -391,0 +375,2 @@\n+  ResourceMark rm;\n+\n@@ -394,3 +380,0 @@\n-  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n-  intptr_t* sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = sender_sp;\n@@ -398,1 +381,1 @@\n-  address sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);\n+  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n@@ -400,3 +383,7 @@\n-  \/\/ This is the saved value of FP which may or may not really be an FP.\n-  \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n-  intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - sender_sp_offset + link_offset);\n+  intptr_t*  l_sender_sp;\n+  intptr_t*  l_unextended_sp;\n+  address    l_sender_pc;\n+  intptr_t** l_saved_fp;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, &l_unextended_sp, &l_saved_fp);\n@@ -416,1 +403,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, l_saved_fp);\n@@ -419,2 +406,2 @@\n-  assert(sender_sp != sp(), \"must have changed\");\n-  return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  assert(l_sender_sp != sp(), \"must have changed\");\n+  return frame(l_sender_sp, l_unextended_sp, *l_saved_fp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":19,"deletions":32,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  frame::abi_minframe* sender_abi = (frame::abi_minframe*) fp;\n+  *sender_sp = (intptr_t*) fp;\n+  *sender_pc = (address) sender_abi->lr;\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, sender_fp);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -55,0 +55,2 @@\n+  ResourceMark rm;\n+\n@@ -110,3 +112,7 @@\n-    abi_minframe* sender_abi = (abi_minframe*) fp;\n-    intptr_t* sender_sp = (intptr_t*) fp;\n-    address   sender_pc = (address) sender_abi->lr;;\n+    intptr_t* sender_sp = NULL;\n+    address   sender_pc = NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n+    }\n@@ -206,0 +212,2 @@\n+  ResourceMark rm;\n+\n@@ -209,2 +217,6 @@\n-  address pc = *compiled_sender_pc_addr(_cb);\n-  frame caller(compiled_sender_sp(_cb), pc);\n+\n+  intptr_t*  l_sender_sp;\n+  address    l_sender_pc;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, NULL, NULL);\n@@ -223,9 +235,1 @@\n-  return caller;\n-}\n-\n-intptr_t* frame::compiled_sender_sp(CodeBlob* cb) const {\n-  return sender_sp();\n-}\n-\n-address* frame::compiled_sender_pc_addr(CodeBlob* cb) const {\n-  return sender_pc_addr();\n+  return frame(l_sender_sp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":18,"deletions":14,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -387,8 +387,0 @@\n- private:\n-\n-  intptr_t* compiled_sender_sp(CodeBlob* cb) const;\n-  address*  compiled_sender_pc_addr(CodeBlob* cb) const;\n-  address*  sender_pc_addr(void) const;\n-\n- public:\n-\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -106,3 +106,0 @@\n-inline address* frame::sender_pc_addr() const {\n-  return (address*)&(callers_abi()->lr);\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  frame::z_abi_160* sender_abi = (frame::z_abi_160*) fp;\n+  *sender_sp = (intptr_t*) sender_abi->callers_sp;\n+  *sender_pc = (address) sender_abi->return_pc;\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, sender_fp);\n+}\n","filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -58,0 +58,2 @@\n+  ResourceMark rm;\n+\n@@ -113,3 +115,7 @@\n-    z_abi_160* sender_abi = (z_abi_160*) fp;\n-    intptr_t* sender_sp = (intptr_t*) sender_abi->callers_sp;\n-    address   sender_pc = (address) sender_abi->return_pc;\n+    intptr_t* sender_sp = NULL;\n+    address   sender_pc = NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n+    }\n@@ -217,0 +223,2 @@\n+  ResourceMark rm;\n+\n@@ -218,0 +226,1 @@\n+\n@@ -220,2 +229,5 @@\n-  address pc = *compiled_sender_pc_addr(_cb);\n-  frame caller(compiled_sender_sp(_cb), pc);\n+  intptr_t*  l_sender_sp;\n+  address    l_sender_pc;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, NULL, NULL);\n@@ -234,1 +246,1 @@\n-  return caller;\n+  return frame(l_sender_sp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n+  if (_cb->frame_size() <= 0) {\n+    return false;\n+  }\n+\n+  *sender_sp = unextended_sp + _cb->frame_size();\n+  \/\/ Is sender_sp safe?\n+  if (thread != NULL && !thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ On Intel the return_address is always the word on the stack\n+  *sender_pc = (address)*((*sender_sp) - frame::return_addr_offset);\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (saved_fp) *saved_fp = (intptr_t**)((*sender_sp) - frame::sender_sp_offset);\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (!fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address)*(fp + frame::return_addr_offset);\n+  \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n+  \/\/ which can be different from the sender unextended sp (the sp seen\n+  \/\/ by the sender) because of current frame local variables\n+  *sender_sp = fp + frame::sender_sp_offset;\n+\n+  if (sender_unextended_sp) *sender_unextended_sp = (intptr_t*)*(fp + frame::interpreter_frame_sender_sp_offset);\n+  if (saved_fp) *saved_fp = (intptr_t**)(fp + frame::link_offset);\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  ResourceMark rm;\n+\n@@ -109,38 +111,8 @@\n-    intptr_t* sender_sp = NULL;\n-    intptr_t* sender_unextended_sp = NULL;\n-    address   sender_pc = NULL;\n-    intptr_t* saved_fp =  NULL;\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n-      \/\/ which can be different from the sender unextended sp (the sp seen\n-      \/\/ by the sender) because of current frame local variables\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-      sender_unextended_sp = (intptr_t*) this->fp()[interpreter_frame_sender_sp_offset];\n-      saved_fp = (intptr_t*) this->fp()[link_offset];\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n-      if (_cb->frame_size() <= 0) {\n-        return false;\n-      }\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      sender_unextended_sp = sender_sp;\n-      \/\/ On Intel the return_address is always the word on the stack\n-      sender_pc = (address) *(sender_sp-1);\n-      \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+    intptr_t*  sender_sp = NULL;\n+    intptr_t*  sender_unextended_sp = NULL;\n+    address    sender_pc = NULL;\n+    intptr_t** saved_fp =  NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, &sender_unextended_sp, &saved_fp)) {\n+      return false;\n@@ -149,1 +121,0 @@\n-\n@@ -157,1 +128,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -163,1 +134,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -192,1 +163,1 @@\n-      if (!thread->is_in_stack_range_excl((address)saved_fp, (address)sender_sp)) {\n+      if (!thread->is_in_stack_range_excl((address)*saved_fp, (address)sender_sp)) {\n@@ -198,1 +169,1 @@\n-      frame sender(sender_sp, sender_unextended_sp, saved_fp, sender_pc);\n+      frame sender(sender_sp, sender_unextended_sp, *saved_fp, sender_pc);\n@@ -470,0 +441,2 @@\n+  ResourceMark rm;\n+\n@@ -473,3 +446,0 @@\n-  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n-  intptr_t* sender_sp = unextended_sp() + _cb->frame_size();\n-  intptr_t* unextended_sp = sender_sp;\n@@ -477,2 +447,1 @@\n-  \/\/ On Intel the return_address is always the word on the stack\n-  address sender_pc = (address) *(sender_sp-1);\n+  assert(_cb->frame_size() >= 0, \"must have non-zero frame size\");\n@@ -480,3 +449,7 @@\n-  \/\/ This is the saved value of EBP which may or may not really be an FP.\n-  \/\/ It is only an FP if the sender is an interpreter frame (or C1?).\n-  intptr_t** saved_fp_addr = (intptr_t**) (sender_sp - frame::sender_sp_offset);\n+  intptr_t*  l_sender_sp = NULL;\n+  intptr_t*  l_unextended_sp = NULL;\n+  address    l_sender_pc = NULL;\n+  intptr_t** l_saved_fp = NULL;\n+  _cb->frame_parser()->sender_frame(\n+    NULL, pc(), sp(), unextended_sp(), fp(), true,\n+      &l_sender_pc, &l_sender_sp, &l_unextended_sp, &l_saved_fp);\n@@ -496,1 +469,1 @@\n-    update_map_with_saved_link(map, saved_fp_addr);\n+    update_map_with_saved_link(map, l_saved_fp);\n@@ -499,2 +472,2 @@\n-  assert(sender_sp != sp(), \"must have changed\");\n-  return frame(sender_sp, unextended_sp, *saved_fp_addr, sender_pc);\n+  assert(l_sender_sp != sp(), \"must have changed\");\n+  return frame(l_sender_sp, l_unextended_sp, *l_saved_fp, l_sender_pc);\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":27,"deletions":54,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, sender_fp);\n+}\n","filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -56,4 +56,4 @@\n-  int code_size = InterpreterCodeSize;\n-  NOT_PRODUCT(code_size *= 4;)  \/\/ debug uses extra interpreter code space\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n-                         \"Interpreter\");\n+  \/\/ debug uses extra interpreter code space\n+  BufferBlob* blob = InterpreterBlob::create(InterpreterCodeSize NOT_PRODUCT( * 4));\n+  assert(blob != NULL, \"invariant\");\n+  _code = new StubQueue(new InterpreterCodeletInterface, blob, NULL);\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -310,0 +310,27 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of InterpreterBlob\n+\n+InterpreterBlob* InterpreterBlob::create(int buffer_size) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  InterpreterBlob* blob = NULL;\n+  unsigned int size = sizeof(InterpreterBlob);\n+  \/\/ align the size to CodeEntryAlignment\n+  size = CodeBlob::align_code_offset(size);\n+  size += align_up(buffer_size, 2 * oopSize);\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) InterpreterBlob(size);\n+    if (blob == NULL) {\n+      vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for Interpreter blob\");\n+    }\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of VtableBlob\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+\/\/    InterpreterBlob    : Used to hold Interpreter\n@@ -141,0 +142,1 @@\n+  virtual bool is_interpreter_blob() const            { return false; }\n@@ -196,0 +198,12 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser: public ResourceObj {\n+   protected:\n+    const CodeBlob* _cb;\n+   public:\n+    FrameParser(const CodeBlob* cb) : _cb(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+\n@@ -339,1 +353,0 @@\n-\n@@ -362,0 +375,6 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public CodeBlob::FrameParser {\n+   public:\n+    FrameParser(const RuntimeBlob* cb) : CodeBlob::FrameParser(cb) {}\n+  };\n+\n@@ -388,0 +407,1 @@\n+  friend class InterpreterBlob;\n@@ -411,0 +431,6 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public RuntimeBlob::FrameParser {\n+   public:\n+    FrameParser(const BufferBlob* cb) : RuntimeBlob::FrameParser(cb) {}\n+  };\n+\n@@ -467,0 +493,26 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ InterpreterBlob: used to hold Interpreter\n+\n+class InterpreterBlob: public BufferBlob {\n+private:\n+  InterpreterBlob(int size)                          : BufferBlob(\"Interpreter\", size) {}\n+\n+public:\n+  \/\/ Creation\n+  static InterpreterBlob* create(int buffer_size);\n+\n+  \/\/ Typing\n+  virtual bool is_interpreter_blob() const { return true; }\n+\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public BufferBlob::FrameParser {\n+   public:\n+    FrameParser(const InterpreterBlob* cb) : BufferBlob::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t*** saved_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -143,1 +143,6 @@\n-  _buffer = new StubQueue(new ICStubInterface, 10*K, InlineCacheBuffer_lock, \"InlineCacheBuffer\");\n+  int code_size = align_up((int)(10*K), 2*BytesPerWord);\n+  BufferBlob* blob = BufferBlob::create(\"InlineCacheBuffer\", code_size);\n+  if (blob == NULL) {\n+    vm_exit_out_of_memory(code_size, OOM_MALLOC_ERROR, \"CodeCache: no room for InlineCacheBuffer\");\n+  }\n+  _buffer = new StubQueue(new ICStubInterface, blob, InlineCacheBuffer_lock);\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,7 +67,2 @@\n-StubQueue::StubQueue(StubInterface* stub_interface, int buffer_size,\n-                     Mutex* lock, const char* name) : _mutex(lock) {\n-  intptr_t size = align_up(buffer_size, 2*BytesPerWord);\n-  BufferBlob* blob = BufferBlob::create(name, size);\n-  if( blob == NULL) {\n-    vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for %s\", name);\n-  }\n+StubQueue::StubQueue(StubInterface* stub_interface, BufferBlob* blob,\n+                     Mutex* lock) : _mutex(lock) {\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-  StubQueue(StubInterface* stub_interface, int buffer_size, Mutex* lock,\n-            const char* name);\n+  StubQueue(StubInterface* stub_interface, BufferBlob* blob, Mutex* lock);\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -48,4 +49,4 @@\n-  int code_size = InterpreterCodeSize;\n-  NOT_PRODUCT(code_size *= 4;)  \/\/ debug uses extra interpreter code space\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n-                        \"Interpreter\");\n+  \/\/ debug uses extra interpreter code space\n+  BufferBlob* blob = InterpreterBlob::create(InterpreterCodeSize NOT_PRODUCT( * 4));\n+  assert(blob != NULL, \"invariant\");\n+  _code = new StubQueue(new InterpreterCodeletInterface, blob, NULL);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}