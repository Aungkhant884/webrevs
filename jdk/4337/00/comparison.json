{"files":[{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n+  if (_cb->frame_size() <= 0) {\n+    return false;\n+  }\n+\n+  *sender_sp = (intptr_t*)(unextended_sp + _cb->frame_size());\n+  \/\/ Is sender_sp safe?\n+  if (!thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  *sender_pc = (address) (*sender_sp)[-1];\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (sender_fp) *sender_fp = (intptr_t*) (*sender_sp)[-frame::sender_sp_offset];\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (!fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address) fp[frame::return_addr_offset];\n+  \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n+  \/\/ which can be different from the sender unextended sp (the sp seen\n+  \/\/ by the sender) because of current frame local variables\n+  *sender_sp = (intptr_t*) &fp[frame::sender_sp_offset];\n+  if (sender_unextended_sp) *sender_unextended_sp = (intptr_t*) fp[frame::interpreter_frame_sender_sp_offset];\n+  if (sender_fp) *sender_fp = (intptr_t*) fp[frame::link_offset];\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/codeBlob_aarch64.cpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -59,0 +59,2 @@\n+  ResourceMark rm;\n+\n@@ -124,33 +126,4 @@\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n-      \/\/ which can be different from the sender unextended sp (the sp seen\n-      \/\/ by the sender) because of current frame local variables\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-      sender_unextended_sp = (intptr_t*) this->fp()[interpreter_frame_sender_sp_offset];\n-      saved_fp = (intptr_t*) this->fp()[link_offset];\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n-      if (_cb->frame_size() <= 0) {\n-        return false;\n-      }\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      sender_unextended_sp = sender_sp;\n-      sender_pc = (address) *(sender_sp-1);\n-      \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, &sender_unextended_sp, &saved_fp)) {\n+      return false;\n@@ -159,1 +132,0 @@\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":6,"deletions":34,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  *sender_sp = (intptr_t*)(unextended_sp + _cb->frame_size());\n+  \/\/ Is sender_sp safe?\n+  if (!thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ With our calling conventions, the return_address should\n+  \/\/ end up being the word on the stack\n+  *sender_pc = (address) (*sender_sp)[-frame::sender_sp_offset + frame::return_addr_offset];\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (!fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address) fp[frame::return_addr_offset];\n+  *sender_sp = (intptr_t*) &fp[frame::sender_sp_offset];\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/codeBlob_arm.cpp","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  ResourceMark rm;\n+\n@@ -101,22 +103,4 @@\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      \/\/ With our calling conventions, the return_address should\n-      \/\/ end up being the word on the stack\n-      sender_pc = (address) *(sender_sp - sender_sp_offset + return_addr_offset);\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":6,"deletions":22,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  frame::abi_minframe* sender_abi = (frame::abi_minframe*) fp;\n+  *sender_sp = (intptr_t*) fp;\n+  *sender_pc = (address) sender_abi->lr;\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, sender_fp);\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/codeBlob_ppc.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -55,0 +55,2 @@\n+  ResourceMark rm;\n+\n@@ -110,3 +112,7 @@\n-    abi_minframe* sender_abi = (abi_minframe*) fp;\n-    intptr_t* sender_sp = (intptr_t*) fp;\n-    address   sender_pc = (address) sender_abi->lr;;\n+    intptr_t* sender_sp = NULL;\n+    address   sender_pc = NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  frame::z_abi_160* sender_abi = (frame::z_abi_160*) fp;\n+  *sender_sp = (intptr_t*) sender_abi->callers_sp;\n+  *sender_pc = (address) sender_abi->return_pc;\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, sender_fp);\n+}\n","filename":"src\/hotspot\/cpu\/s390\/codeBlob_s390.cpp","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -58,0 +58,2 @@\n+  ResourceMark rm;\n+\n@@ -113,3 +115,7 @@\n-    z_abi_160* sender_abi = (z_abi_160*) fp;\n-    intptr_t* sender_sp = (intptr_t*) sender_abi->callers_sp;\n-    address   sender_pc = (address) sender_abi->return_pc;\n+    intptr_t* sender_sp = NULL;\n+    address   sender_pc = NULL;\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, NULL, NULL)) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  \/\/ must be some sort of compiled\/runtime frame\n+  \/\/ fp does not have to be safe (although it could be check for c1?)\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n+  if (_cb->frame_size() <= 0) {\n+    return false;\n+  }\n+\n+  *sender_sp = (intptr_t*)(unextended_sp + _cb->frame_size());\n+  \/\/ Is sender_sp safe?\n+  if (!thread->is_in_full_stack_checked((address)*sender_sp)) {\n+    return false;\n+  }\n+  \/\/ On Intel the return_address is always the word on the stack\n+  *sender_pc = (address) (*sender_sp)[-1];\n+  if (sender_unextended_sp) *sender_unextended_sp = *sender_sp;\n+  \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n+  if (sender_fp) *sender_fp = (intptr_t*) (*sender_sp)[-frame::sender_sp_offset];\n+\n+  return true;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+\n+  assert(sender_pc != NULL, \"invariant\");\n+  assert(sender_sp != NULL, \"invariant\");\n+\n+  \/\/ fp must be safe\n+  if (!fp_safe) {\n+    return false;\n+  }\n+\n+  *sender_pc = (address) fp[frame::return_addr_offset];\n+  \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n+  \/\/ which can be different from the sender unextended sp (the sp seen\n+  \/\/ by the sender) because of current frame local variables\n+  *sender_sp = (intptr_t*) &fp[frame::sender_sp_offset];\n+  if (sender_unextended_sp) *sender_unextended_sp = (intptr_t*) fp[frame::interpreter_frame_sender_sp_offset];\n+  if (sender_fp) *sender_fp = (intptr_t*) fp[frame::link_offset];\n+\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/x86\/codeBlob_x86.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -57,0 +57,2 @@\n+  ResourceMark rm;\n+\n@@ -113,34 +115,4 @@\n-\n-    if (is_interpreted_frame()) {\n-      \/\/ fp must be safe\n-      if (!fp_safe) {\n-        return false;\n-      }\n-\n-      sender_pc = (address) this->fp()[return_addr_offset];\n-      \/\/ for interpreted frames, the value below is the sender \"raw\" sp,\n-      \/\/ which can be different from the sender unextended sp (the sp seen\n-      \/\/ by the sender) because of current frame local variables\n-      sender_sp = (intptr_t*) addr_at(sender_sp_offset);\n-      sender_unextended_sp = (intptr_t*) this->fp()[interpreter_frame_sender_sp_offset];\n-      saved_fp = (intptr_t*) this->fp()[link_offset];\n-\n-    } else {\n-      \/\/ must be some sort of compiled\/runtime frame\n-      \/\/ fp does not have to be safe (although it could be check for c1?)\n-\n-      \/\/ check for a valid frame_size, otherwise we are unlikely to get a valid sender_pc\n-      if (_cb->frame_size() <= 0) {\n-        return false;\n-      }\n-\n-      sender_sp = _unextended_sp + _cb->frame_size();\n-      \/\/ Is sender_sp safe?\n-      if (!thread->is_in_full_stack_checked((address)sender_sp)) {\n-        return false;\n-      }\n-      sender_unextended_sp = sender_sp;\n-      \/\/ On Intel the return_address is always the word on the stack\n-      sender_pc = (address) *(sender_sp-1);\n-      \/\/ Note: frame::sender_sp_offset is only valid for compiled frame\n-      saved_fp = (intptr_t*) *(sender_sp - frame::sender_sp_offset);\n+    if (!_cb->frame_parser()->sender_frame(\n+          thread, _pc, (intptr_t*)sp, (intptr_t*)unextended_sp, (intptr_t*)fp, fp_safe,\n+            &sender_pc, &sender_sp, &sender_unextended_sp, &saved_fp)) {\n+      return false;\n@@ -149,1 +121,0 @@\n-\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":6,"deletions":35,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"code\/codeBlob.hpp\"\n+#include \"code\/compiledMethod.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"runtime\/frame.hpp\"\n+\n+bool CodeBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  ShouldNotCallThis();\n+  return false;\n+}\n+\n+bool InterpreterBlob::FrameParser::sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+    address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp) {\n+  return CodeBlob::FrameParser::sender_frame(thread, pc, sp, unextended_sp, fp, fp_safe,\n+                                             sender_pc, sender_sp, sender_unextended_sp, sender_fp);\n+}\n","filename":"src\/hotspot\/cpu\/zero\/codeBlob_zero.cpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -310,0 +310,27 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of InterpreterBlob\n+\n+InterpreterBlob* InterpreterBlob::create(int buffer_size) {\n+  ThreadInVMfromUnknown __tiv;  \/\/ get to VM state in case we block on CodeCache_lock\n+\n+  InterpreterBlob* blob = NULL;\n+  unsigned int size = sizeof(InterpreterBlob);\n+  \/\/ align the size to CodeEntryAlignment\n+  size = CodeBlob::align_code_offset(size);\n+  size += align_up(buffer_size, 2 * oopSize);\n+  {\n+    MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);\n+    blob = new (size) InterpreterBlob(size);\n+    if (blob == NULL) {\n+      vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for Interpreter blob\");\n+    }\n+  }\n+  \/\/ Track memory usage statistic after releasing CodeCache_lock\n+  MemoryService::track_code_cache_memory_usage();\n+\n+  return blob;\n+}\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Implementation of VtableBlob\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+\/\/    InterpreterBlob    : Used to hold Interpreter\n@@ -141,0 +142,1 @@\n+  virtual bool is_interpreter_blob() const            { return false; }\n@@ -196,0 +198,12 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser: public ResourceObj {\n+   protected:\n+    const CodeBlob* _cb;\n+   public:\n+    FrameParser(const CodeBlob* cb) : _cb(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+\n@@ -339,1 +353,0 @@\n-\n@@ -362,0 +375,6 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public CodeBlob::FrameParser {\n+   public:\n+    FrameParser(const RuntimeBlob* cb) : CodeBlob::FrameParser(cb) {}\n+  };\n+\n@@ -388,0 +407,1 @@\n+  friend class InterpreterBlob;\n@@ -411,0 +431,6 @@\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public RuntimeBlob::FrameParser {\n+   public:\n+    FrameParser(const BufferBlob* cb) : RuntimeBlob::FrameParser(cb) {}\n+  };\n+\n@@ -467,0 +493,26 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ InterpreterBlob: used to hold Interpreter\n+\n+class InterpreterBlob: public BufferBlob {\n+private:\n+  InterpreterBlob(int size)                          : BufferBlob(\"Interpreter\", size) {}\n+\n+public:\n+  \/\/ Creation\n+  static InterpreterBlob* create(int buffer_size);\n+\n+  \/\/ Typing\n+  virtual bool is_interpreter_blob() const { return true; }\n+\n+  \/\/ Profiling\/safepoint support\n+  class FrameParser : public BufferBlob::FrameParser {\n+   public:\n+    FrameParser(const InterpreterBlob* cb) : BufferBlob::FrameParser(cb) {}\n+    virtual bool sender_frame(JavaThread *thread, address pc, intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, bool fp_safe,\n+      address* sender_pc, intptr_t** sender_sp, intptr_t** sender_unextended_sp, intptr_t** sender_fp);\n+  };\n+\n+  virtual FrameParser* frame_parser() const { return new FrameParser(this); }\n+};\n+\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.hpp","additions":53,"deletions":1,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -143,1 +143,6 @@\n-  _buffer = new StubQueue(new ICStubInterface, 10*K, InlineCacheBuffer_lock, \"InlineCacheBuffer\");\n+  int code_size = align_up(10*K, 2*BytesPerWord);\n+  BufferBlob* blob = BufferBlob::create(\"InlineCacheBuffer\", code_size);\n+  if (blob == NULL) {\n+    vm_exit_out_of_memory(code_size, OOM_MALLOC_ERROR, \"CodeCache: no room for InlineCacheBuffer\");\n+  }\n+  _buffer = new StubQueue(new ICStubInterface, blob, InlineCacheBuffer_lock);\n","filename":"src\/hotspot\/share\/code\/icBuffer.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -67,7 +67,2 @@\n-StubQueue::StubQueue(StubInterface* stub_interface, int buffer_size,\n-                     Mutex* lock, const char* name) : _mutex(lock) {\n-  intptr_t size = align_up(buffer_size, 2*BytesPerWord);\n-  BufferBlob* blob = BufferBlob::create(name, size);\n-  if( blob == NULL) {\n-    vm_exit_out_of_memory(size, OOM_MALLOC_ERROR, \"CodeCache: no room for %s\", name);\n-  }\n+StubQueue::StubQueue(StubInterface* stub_interface, BufferBlob* blob,\n+                     Mutex* lock) : _mutex(lock) {\n","filename":"src\/hotspot\/share\/code\/stubs.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -176,2 +176,1 @@\n-  StubQueue(StubInterface* stub_interface, int buffer_size, Mutex* lock,\n-            const char* name);\n+  StubQueue(StubInterface* stub_interface, BufferBlob* blob, Mutex* lock);\n","filename":"src\/hotspot\/share\/code\/stubs.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/codeBlob.hpp\"\n@@ -48,4 +49,4 @@\n-  int code_size = InterpreterCodeSize;\n-  NOT_PRODUCT(code_size *= 4;)  \/\/ debug uses extra interpreter code space\n-  _code = new StubQueue(new InterpreterCodeletInterface, code_size, NULL,\n-                        \"Interpreter\");\n+  \/\/ debug uses extra interpreter code space\n+  BufferBlob* blob = InterpreterBlob::create(InterpreterCodeSize NOT_PRODUCT( * 4));\n+  assert(blob != NULL, \"invariant\");\n+  _code = new StubQueue(new InterpreterCodeletInterface, blob, NULL);\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreter.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}