{"files":[{"patch":"@@ -343,1 +343,1 @@\n-      if (ENQUEUE && !ctx->par_is_marked_strong(obj)) {\n+      if (ENQUEUE && !ctx->is_marked_strong(obj)) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,8 +48,1 @@\n-  ShenandoahMarkingContext* ctx = _heap->marking_context();\n-  uintptr_t mark = ctx->par_marking_bits(obj);\n-#ifdef ASSERT\n-  if (!ShenandoahMarkBitMap::is_marked_strong(mark)) {\n-    assert(ShenandoahMarkBitMap::is_marked_final(mark), \"must be marked final if not marked strong\");\n-  }\n-#endif\n-  cl->set_strong(ShenandoahMarkBitMap::is_marked_strong(mark));\n+  cl->set_strong(task->is_strong());\n@@ -74,1 +67,1 @@\n-    if (!ShenandoahMarkBitMap::is_marked_strong_and_final(mark)) {\n+    if (task->count_liveness()) {\n@@ -267,1 +260,1 @@\n-      bool marked;\n+      bool marked, marked_first;\n@@ -269,1 +262,1 @@\n-        marked = mark_context->mark_strong(obj);\n+        marked = mark_context->mark_strong(obj, marked_first);\n@@ -271,1 +264,1 @@\n-        marked = mark_context->mark_final(obj);\n+        marked = mark_context->mark_final(obj, marked_first);\n@@ -274,1 +267,1 @@\n-        bool pushed = q->push(ShenandoahMarkTask(obj));\n+        bool pushed = q->push(ShenandoahMarkTask(obj, marked_first, strong));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.inline.hpp","additions":6,"deletions":13,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-  return !_marking_context->par_is_marked(obj);\n+  return !_marking_context->is_marked(obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -150,1 +150,1 @@\n-  inline bool mark_strong(HeapWord* w);\n+  inline bool mark_strong(HeapWord* w, bool& marked_first);\n@@ -156,1 +156,1 @@\n-  inline bool mark_final(HeapWord* w);\n+  inline bool mark_final(HeapWord* w, bool& marked_first);\n@@ -163,16 +163,0 @@\n-  inline bool par_is_marked_strong(HeapWord* w)  const;\n-  inline bool par_is_marked_final(HeapWord* w) const;\n-  inline bool par_is_marked_strong_and_final(HeapWord* w) const;\n-  inline bool par_is_marked_strong_or_final(HeapWord* w) const;\n-\n-  static bool is_marked_strong(uintptr_t mark) {\n-    return (mark & 1) != 0;\n-  }\n-  static bool is_marked_final(uintptr_t mark) {\n-    return (mark & 2) != 0;\n-  }\n-  static bool is_marked_strong_and_final(uintptr_t mark) {\n-    return (mark & 3) == 3;\n-  }\n-  inline uintptr_t par_marking_bits(HeapWord* w) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-inline bool ShenandoahMarkBitMap::mark_strong(HeapWord* heap_addr) {\n+inline bool ShenandoahMarkBitMap::mark_strong(HeapWord* heap_addr, bool& marked_first) {\n@@ -46,0 +46,1 @@\n+  const bm_word_t mask_final = (bm_word_t)1 << (bit_in_word(bit) + 1);\n@@ -51,0 +52,1 @@\n+      marked_first = false;\n@@ -55,0 +57,1 @@\n+      marked_first = (cur_val & mask_final) == 0;\n@@ -61,1 +64,1 @@\n-inline bool ShenandoahMarkBitMap::mark_final(HeapWord* heap_addr) {\n+inline bool ShenandoahMarkBitMap::mark_final(HeapWord* heap_addr, bool& marked_first) {\n@@ -73,0 +76,1 @@\n+      marked_first = false;\n@@ -77,0 +81,1 @@\n+      marked_first = false;\n@@ -81,0 +86,1 @@\n+      marked_first = true;\n@@ -113,45 +119,0 @@\n-inline bool ShenandoahMarkBitMap::par_is_marked_strong(HeapWord* heap_addr)  const {\n-  check_mark(heap_addr);\n-  idx_t index = address_to_index(heap_addr);\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  bm_word_t word = load_word_ordered(addr, memory_order_acquire);\n-  return (word & bit_mask(index)) != 0;\n-}\n-\n-inline bool ShenandoahMarkBitMap::par_is_marked_final(HeapWord* heap_addr) const {\n-  check_mark(heap_addr);\n-  idx_t index = address_to_index(heap_addr) + 1;\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  bm_word_t word = load_word_ordered(addr, memory_order_acquire);\n-  return (word & bit_mask(index)) != 0;\n-}\n-\n-inline bool ShenandoahMarkBitMap::par_is_marked_strong_and_final(HeapWord* heap_addr) const {\n-  check_mark(heap_addr);\n-  idx_t index = address_to_index(heap_addr);\n-  verify_index(index);\n-  bm_word_t mask = (bm_word_t)3 << bit_in_word(index);\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  bm_word_t word = load_word_ordered(addr, memory_order_acquire);\n-  return (word & mask) == mask;\n-}\n-\n-inline bool ShenandoahMarkBitMap::par_is_marked_strong_or_final(HeapWord* heap_addr) const {\n-  check_mark(heap_addr);\n-  idx_t index = address_to_index(heap_addr);\n-  verify_index(index);\n-  bm_word_t mask = (bm_word_t)3 << bit_in_word(index);\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  bm_word_t word = load_word_ordered(addr, memory_order_acquire);\n-  return (word & mask) != 0;\n-}\n-\n-inline uintptr_t ShenandoahMarkBitMap::par_marking_bits(HeapWord* heap_addr) const {\n-  check_mark(heap_addr);\n-  idx_t index = address_to_index(heap_addr);\n-  verify_index(index);\n-  const volatile bm_word_t* const addr = word_addr(index);\n-  bm_word_t word = load_word_ordered(addr, memory_order_acquire);\n-  return word >> bit_in_word(index);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp","additions":8,"deletions":47,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  inline bool mark_strong(oop obj);\n-  inline bool mark_final(oop obj);\n+  inline bool mark_strong(oop obj, bool& marked_first);\n+  inline bool mark_final(oop obj, bool& marked_first);\n@@ -64,7 +64,0 @@\n-  \/\/ Paralles versions of marking accessors, to be used during marking (e.g. possible concurrent updates)\n-  inline bool par_is_marked(oop) const;\n-  inline bool par_is_marked_strong(oop obj) const;\n-  inline bool par_is_marked_final(oop obj) const;\n-  inline bool par_is_marked_strong_and_final(oop obj) const;\n-  inline uintptr_t par_marking_bits(oop obj) const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-inline bool ShenandoahMarkingContext::mark_strong(oop obj) {\n+inline bool ShenandoahMarkingContext::mark_strong(oop obj, bool& marked_first) {\n@@ -37,1 +37,1 @@\n-  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_strong(cast_from_oop<HeapWord*>(obj));\n+  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_strong(cast_from_oop<HeapWord*>(obj), marked_first);\n@@ -40,1 +40,1 @@\n-inline bool ShenandoahMarkingContext::mark_final(oop obj) {\n+inline bool ShenandoahMarkingContext::mark_final(oop obj, bool& marked_first) {\n@@ -42,1 +42,1 @@\n-  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_final(cast_from_oop<HeapWord*>(obj));\n+  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_final(cast_from_oop<HeapWord*>(obj), marked_first);\n@@ -61,21 +61,0 @@\n-inline bool ShenandoahMarkingContext::par_is_marked(oop obj) const {\n-  return allocated_after_mark_start(obj) || _mark_bit_map.par_is_marked_strong_or_final(cast_from_oop<HeapWord*>(obj));\n-}\n-\n-inline bool ShenandoahMarkingContext::par_is_marked_strong(oop obj) const {\n-  return allocated_after_mark_start(obj) || _mark_bit_map.par_is_marked_strong(cast_from_oop<HeapWord*>(obj));\n-}\n-\n-inline bool ShenandoahMarkingContext::par_is_marked_final(oop obj) const {\n-  return allocated_after_mark_start(obj) || _mark_bit_map.par_is_marked_final(cast_from_oop<HeapWord*>(obj));\n-}\n-\n-inline bool ShenandoahMarkingContext::par_is_marked_strong_and_final(oop obj) const {\n-  return allocated_after_mark_start(obj) || _mark_bit_map.par_is_marked_strong_and_final(cast_from_oop<HeapWord*>(obj));\n-}\n-\n-inline uintptr_t ShenandoahMarkingContext::par_marking_bits(oop obj) const {\n-  assert(!allocated_after_mark_start(obj), \"only on objects < TAMS\");\n-  return _mark_bit_map.par_marking_bits(cast_from_oop<HeapWord*>(obj));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  return lrb(CompressedOops::decode(heap_oop));\n+  return CompressedOops::decode(heap_oop);\n@@ -524,1 +524,1 @@\n-    MonitorLocker ml(Heap_lock);\n+    MonitorLocker ml(Heap_lock, Mutex::_no_safepoint_check_flag);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -146,0 +146,6 @@\n+  static const uintptr_t oop_decode_mask = right_n_bits(oop_bits) - 3;\n+  \/\/ When lowest bit is set, don't count liveness.\n+  static const uintptr_t count_liveness_decode_mask = 1;\n+  \/\/ When 2nd bit is set, mark as finalizable\n+  static const uintptr_t strong_decode_mask = 1 << 1;\n+\n@@ -147,3 +153,3 @@\n-  ObjArrayChunkedTask(oop o = NULL) {\n-    assert(decode_oop(encode_oop(o)) ==  o, \"oop can be encoded: \" PTR_FORMAT, p2i(o));\n-    _obj = encode_oop(o);\n+  ObjArrayChunkedTask(oop o = NULL, bool count_liveness = true, bool strong = true) {\n+    assert(decode_oop(encode_oop(o, count_liveness, strong)) ==  o, \"oop can be encoded: \" PTR_FORMAT, p2i(o));\n+    _obj = encode_oop(o, count_liveness, strong);\n@@ -152,1 +158,1 @@\n-    assert(decode_oop(encode_oop(o)) == o, \"oop can be encoded: \" PTR_FORMAT, p2i(o));\n+    assert(decode_oop(encode_oop(o, true, true)) == o, \"oop can be encoded: \" PTR_FORMAT, p2i(o));\n@@ -155,1 +161,1 @@\n-    _obj = encode_oop(o) | encode_chunk(chunk) | encode_pow(pow);\n+    _obj = encode_oop(o, true, true) | encode_chunk(chunk) | encode_pow(pow);\n@@ -161,1 +167,1 @@\n-    return (oop) reinterpret_cast<void*>((val >> oop_shift) & right_n_bits(oop_bits));\n+    return (oop) reinterpret_cast<void*>((val >> oop_shift) & oop_decode_mask);\n@@ -172,2 +178,10 @@\n-  inline uintptr_t encode_oop(oop obj) const {\n-    return ((uintptr_t)(void*) obj) << oop_shift;\n+  inline uintptr_t encode_oop(oop obj, bool count_liveness, bool strong) const {\n+    uintptr_t encoded_oop = ((uintptr_t)(void*) obj) << oop_shift;\n+    assert((encoded_oop & (count_liveness_decode_mask | strong_decode_mask)) == 0, \"need bit for encoding count-liveness and strong bits\");\n+    if (!count_liveness) {\n+      encoded_oop |= count_liveness_decode_mask;\n+    }\n+    if (!strong) {\n+      encoded_oop |= strong_decode_mask;\n+    }\n+    return encoded_oop;\n@@ -188,1 +202,2 @@\n-\n+  inline bool count_liveness() const { return (_obj & count_liveness_decode_mask) == 0; }\n+  inline bool is_strong() const      { return (_obj & strong_decode_mask) == 0; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":24,"deletions":9,"binary":false,"changes":33,"status":"modified"}]}