{"files":[{"patch":"@@ -265,1 +265,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr, bool weak) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr, bool native) {\n@@ -289,1 +289,1 @@\n-  if (UseCompressedOops && weak) {\n+  if (UseCompressedOops && !native) {\n@@ -360,1 +360,1 @@\n-      load_reference_barrier_native(masm, dst, src, (decorators & IN_NATIVE) == 0);\n+      load_reference_barrier_native(masm, dst, src, (decorators & IN_NATIVE) != 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr, bool weak);\n+  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address load_addr, bool native);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src, bool weak) {\n+void ShenandoahBarrierSetAssembler::load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src, bool native) {\n@@ -399,1 +399,1 @@\n-  if (UseCompressedOops && weak) {\n+  if (UseCompressedOops && !native) {\n@@ -525,1 +525,1 @@\n-      load_reference_barrier_native(masm, dst, src, (decorators & IN_NATIVE) == 0);\n+      load_reference_barrier_native(masm, dst, src, (decorators & IN_NATIVE) != 0);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src, bool weak);\n+  void load_reference_barrier_native(MacroAssembler* masm, Register dst, Address src, bool native);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,1 +91,0 @@\n-  \/\/assert(need_load_reference_barrier(decorators, type), \"Should be subset of LRB\");\n@@ -93,0 +92,5 @@\n+\n+  if (!ShenandoahLoadRefBarrier) {\n+    return false;\n+  }\n+\n@@ -114,7 +118,0 @@\n-bool ShenandoahBarrierSet::is_access_on_jlr_reference(DecoratorSet decorators, BasicType type) {\n-  \/\/ Only needed for references\n-  if (!is_reference_type(type)) return false;\n-\n-  return (decorators & (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -64,1 +64,0 @@\n-  static bool is_access_on_jlr_reference(DecoratorSet decorators, BasicType type);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -432,4 +432,0 @@\n-  rp->set_active_mt_degree(nworkers);\n-\n-  \/\/ enable (\"weak\") refs discovery\n-  rp->enable_discovery(true \/*verify_no_refs*\/);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1794,1 +1794,0 @@\n-    rp->disable_discovery();\n@@ -1796,1 +1795,0 @@\n-    rp->verify_no_references_recorded();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-    rp->disable_discovery();\n@@ -136,1 +135,0 @@\n-    rp->verify_no_references_recorded();\n@@ -249,1 +247,0 @@\n-  rp->enable_discovery(true \/*verify_no_refs*\/);\n@@ -251,1 +248,0 @@\n-  rp->set_active_mt_degree(heap->workers()->active_workers());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkCompact.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -156,10 +156,0 @@\n-void ShenandoahPacer::setup_for_preclean() {\n-  assert(ShenandoahPacing, \"Only be here when pacing is enabled\");\n-\n-  size_t initial = _heap->max_capacity();\n-  restart_with(initial, 1.0);\n-\n-  log_info(gc, ergo)(\"Pacer for Precleaning. Non-Taxable: \" SIZE_FORMAT \"%s\",\n-                     byte_size_in_proper_unit(initial), proper_unit_for_byte_size(initial));\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -82,1 +82,0 @@\n-  void setup_for_preclean();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  f(conc_preclean,                                  \"Concurrent Precleaning\")          \\\n-                                                                                       \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,2 +139,4 @@\n-  _discovered_list(NULL) {\n-\n+  _discovered_list(NULL),\n+  _encountered_count(),\n+  _discovered_count(),\n+  _enqueued_count() {\n@@ -145,0 +147,5 @@\n+  for (uint i = 0; i < reference_type_count; i++) {\n+    _encountered_count[i] = 0;\n+    _discovered_count[i] = 0;\n+    _enqueued_count[i] = 0;\n+  }\n@@ -300,1 +307,1 @@\n-bool ShenandoahReferenceProcessor::discover(oop reference, ReferenceType type) {\n+bool ShenandoahReferenceProcessor::discover(oop reference, ReferenceType type, uint worker_id) {\n@@ -306,2 +313,1 @@\n-  \/\/ Update statistics\n-  \/\/_discovered_count.get()[type]++;\n+  _ref_proc_thread_locals[worker_id].inc_discovered(type);\n@@ -324,1 +330,0 @@\n-  uint worker_id = ShenandoahThreadLocalData::worker_id(Thread::current());\n@@ -344,0 +349,2 @@\n+  uint worker_id = ShenandoahThreadLocalData::worker_id(Thread::current());\n+  _ref_proc_thread_locals->inc_encountered(type);\n@@ -346,1 +353,1 @@\n-    return discover<narrowOop>(reference, type);\n+    return discover<narrowOop>(reference, type, worker_id);\n@@ -348,1 +355,1 @@\n-    return discover<oop>(reference, type);\n+    return discover<oop>(reference, type, worker_id);\n@@ -366,1 +373,1 @@\n-T* ShenandoahReferenceProcessor::keep(oop reference, ReferenceType type) {\n+T* ShenandoahReferenceProcessor::keep(oop reference, ReferenceType type, uint worker_id) {\n@@ -370,1 +377,1 @@\n-  \/\/ TODO _enqueued_count.get()[type]++;\n+  _ref_proc_thread_locals[worker_id].inc_enqueued(type);\n@@ -398,1 +405,1 @@\n-      p = keep<T>(reference, type);\n+      p = keep<T>(reference, type, worker_id);\n@@ -460,1 +467,1 @@\n-  \/\/ collect_statistics();\n+  collect_statistics();\n@@ -498,0 +505,41 @@\n+template<typename T>\n+void ShenandoahReferenceProcessor::clean_discovered_list(T* list) {\n+  T discovered = *list;\n+  while (!CompressedOops::is_null(discovered)) {\n+    oop discovered_ref = CompressedOops::decode_not_null(discovered);\n+    set_oop_field<T>(list, oop(NULL));\n+    list = reference_discovered_addr<T>(discovered_ref);\n+    discovered = *list;\n+  }\n+}\n+\n+void ShenandoahReferenceProcessor::abandon_partial_discovery() {\n+  uint max_workers = ShenandoahHeap::heap()->max_workers();\n+  for (uint index = 0; index < max_workers; index++) {\n+    if (UseCompressedOops) {\n+      clean_discovered_list<narrowOop>(_ref_proc_thread_locals[index].discovered_list_addr<narrowOop>());\n+    } else {\n+      clean_discovered_list<oop>(_ref_proc_thread_locals[index].discovered_list_addr<oop>());\n+    }\n+  }\n+}\n+\n+void ShenandoahReferenceProcessor::collect_statistics() {\n+  Counters encountered = {};\n+  Counters discovered = {};\n+  Counters enqueued = {};\n+  uint max_workers = ShenandoahHeap::heap()->max_workers();\n+  for (uint i = 0; i < max_workers; i++) {\n+    for (size_t type = 0; type < reference_type_count; type++) {\n+      encountered[type] += _ref_proc_thread_locals[i].encountered((ReferenceType)type);\n+      discovered[type] += _ref_proc_thread_locals[i].discovered((ReferenceType)type);\n+      enqueued[type] += _ref_proc_thread_locals[i].enqueued((ReferenceType)type);\n+    }\n+  }\n+  log_info(gc,ref)(\"Encountered references: Soft: \" SIZE_FORMAT \", Weak: \" SIZE_FORMAT \", Final: \" SIZE_FORMAT \", Phantom: \" SIZE_FORMAT,\n+                   encountered[REF_SOFT], encountered[REF_WEAK], encountered[REF_FINAL], encountered[REF_PHANTOM]);\n+  log_info(gc,ref)(\"Discovered  references: Soft: \" SIZE_FORMAT \", Weak: \" SIZE_FORMAT \", Final: \" SIZE_FORMAT \", Phantom: \" SIZE_FORMAT,\n+                   discovered[REF_SOFT], discovered[REF_WEAK], discovered[REF_FINAL], discovered[REF_PHANTOM]);\n+  log_info(gc,ref)(\"Enqueued    references: Soft: \" SIZE_FORMAT \", Weak: \" SIZE_FORMAT \", Final: \" SIZE_FORMAT \", Phantom: \" SIZE_FORMAT,\n+                   enqueued[REF_SOFT], enqueued[REF_WEAK], enqueued[REF_FINAL], enqueued[REF_PHANTOM]);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":60,"deletions":12,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -33,0 +33,3 @@\n+static const size_t reference_type_count = REF_PHANTOM + 1;\n+typedef size_t Counters[reference_type_count];\n+\n@@ -36,0 +39,3 @@\n+  Counters _encountered_count;\n+  Counters _discovered_count;\n+  Counters _enqueued_count;\n@@ -51,0 +57,20 @@\n+\n+  size_t encountered(ReferenceType type) const {\n+    return _encountered_count[type];\n+  }\n+  size_t discovered(ReferenceType type) const {\n+    return _discovered_count[type];\n+  }\n+  size_t enqueued(ReferenceType type) const {\n+    return _enqueued_count[type];\n+  }\n+\n+  void inc_encountered(ReferenceType type) {\n+    _encountered_count[type]++;\n+  }\n+  void inc_discovered(ReferenceType type) {\n+    _discovered_count[type]++;\n+  }\n+  void inc_enqueued(ReferenceType type) {\n+    _enqueued_count[type]++;\n+  }\n@@ -81,1 +107,1 @@\n-  bool discover(oop reference, ReferenceType type);\n+  bool discover(oop reference, ReferenceType type, uint worker_id);\n@@ -86,1 +112,1 @@\n-  T* keep(oop reference, ReferenceType type);\n+  T* keep(oop reference, ReferenceType type, uint worker_id);\n@@ -93,0 +119,5 @@\n+  void collect_statistics();\n+\n+  template<typename T>\n+  void clean_discovered_list(T* list);\n+\n@@ -106,6 +137,1 @@\n-  \/\/ TODO: Temporary methods to allow transition.\n-  void set_active_mt_degree(uint num_workers) {};\n-  void enable_discovery(bool verify_no_refs) {};\n-  void disable_discovery() {}\n-  void abandon_partial_discovery() {}\n-  void verify_no_references_recorded() {}\n+  void abandon_partial_discovery();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.hpp","additions":34,"deletions":8,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -126,5 +126,0 @@\n-uint ShenandoahWorkerPolicy::calc_workers_for_conc_preclean() {\n-  \/\/ Precleaning is single-threaded\n-  return 1;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -71,3 +71,0 @@\n-  \/\/ Calculate workers for concurrent precleaning\n-  static uint calc_workers_for_conc_preclean();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkerPolicy.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -309,5 +309,0 @@\n-  product(bool, ShenandoahPreclean, true, DIAGNOSTIC,                       \\\n-          \"Do concurrent preclean phase before final mark: process \"        \\\n-          \"definitely alive references to avoid dealing with them during \"  \\\n-          \"pause.\")                                                         \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}