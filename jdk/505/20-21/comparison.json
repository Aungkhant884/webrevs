{"files":[{"patch":"@@ -77,1 +77,1 @@\n-\/\/    |---------oop---------|-pow-|--chunk---|\n+\/\/    |xx-------oop---------|-pow-|--chunk---|\n@@ -82,0 +82,5 @@\n+\/\/ Lower bits of oop are reserved to handle \"cnt_live\" and \"strong\" properties. Since this encoding\n+\/\/ stores uncompressed oops, those bits are always available. These bits default to zero for \"count liveness\"\n+\/\/ and \"strong\" set, that is they are inverted from their natural meaning. This improves the frequent case\n+\/\/ by avoiding additional math for strong\/counted-live references.\n+\/\/\n@@ -148,1 +153,3 @@\n-  static const uintptr_t oop_extract_mask       = right_n_bits(oop_bits) & ~((uintptr_t)3);\n+  static const uintptr_t oop_extract_mask       = right_n_bits(oop_bits) - 3;\n+  static const uintptr_t cnt_live_extract_mask  = 1 << 0;\n+  static const uintptr_t strong_extract_mask    = 1 << 1;\n@@ -154,3 +161,0 @@\n-  static const uintptr_t count_liveness_decode_mask = 1 << 0;\n-  static const uintptr_t strong_decode_mask         = 1 << 1;\n-\n@@ -176,1 +180,1 @@\n-    return (val & strong_decode_mask) != 0;\n+    return (val & strong_extract_mask) == 0;\n@@ -179,2 +183,2 @@\n-  inline bool decode_count_liveness(uintptr_t val) const {\n-    return (val & count_liveness_decode_mask) != 0;\n+  inline bool decode_cnt_live(uintptr_t val) const {\n+    return (val & cnt_live_extract_mask) == 0;\n@@ -186,2 +190,2 @@\n-    if (count_liveness) {\n-      encoded |= count_liveness_decode_mask;\n+    if (!count_liveness) {\n+      encoded |= cnt_live_extract_mask;\n@@ -189,2 +193,2 @@\n-    if (strong) {\n-      encoded |= strong_decode_mask;\n+    if (!strong) {\n+      encoded |= strong_extract_mask;\n@@ -204,2 +208,2 @@\n-  ShenandoahMarkTask(oop o = NULL, bool count_liveness = true, bool strong = true) {\n-    uintptr_t enc = encode_oop(o, count_liveness, strong);\n+  ShenandoahMarkTask(oop o = NULL, bool cnt_live = true, bool strong = true) {\n+    uintptr_t enc = encode_oop(o, cnt_live, strong);\n@@ -207,2 +211,1 @@\n-    assert(decode_not_chunked(enc), \"task should not be chunked\");\n-    assert(decode_count_liveness(enc) == count_liveness, \"count_liveness encoding should work\");\n+    assert(decode_cnt_live(enc) == cnt_live, \"cnt_live encoding should work\");\n@@ -210,0 +213,1 @@\n+    assert(decode_not_chunked(enc), \"task should not be chunked\");\n@@ -213,2 +217,2 @@\n-  ShenandoahMarkTask(oop o, bool count_liveness, bool strong, int chunk, int pow) {\n-    uintptr_t enc_oop = encode_oop(o, count_liveness, strong);\n+  ShenandoahMarkTask(oop o, bool cnt_live, bool strong, int chunk, int pow) {\n+    uintptr_t enc_oop = encode_oop(o, cnt_live, strong);\n@@ -219,0 +223,2 @@\n+    assert(decode_cnt_live(enc) == cnt_live, \"cnt_live encoding should work\");\n+    assert(decode_strong(enc) == strong, \"strong encoding should work\");\n@@ -222,2 +228,0 @@\n-    assert(decode_count_liveness(enc) == count_liveness, \"count_liveness encoding should work\");\n-    assert(decode_strong(enc) == strong, \"strong encoding should work\");\n@@ -236,1 +240,1 @@\n-  inline bool count_liveness() const { return decode_count_liveness(_obj); }\n+  inline bool count_liveness() const { return decode_cnt_live(_obj);       }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":25,"deletions":21,"binary":false,"changes":46,"status":"modified"}]}