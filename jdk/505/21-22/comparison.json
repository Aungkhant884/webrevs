{"files":[{"patch":"@@ -72,1 +72,1 @@\n-  msg.append(\"    %3s marked final\\n\",               ctx->is_marked_final(obj) ? \"\" : \"not\");\n+  msg.append(\"    %3s marked weak\\n\",                ctx->is_marked_weak(obj) ? \"\" : \"not\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,1 +260,2 @@\n-      bool marked, marked_first;\n+      bool skip_live = false;\n+      bool marked;\n@@ -262,1 +263,1 @@\n-        marked = mark_context->mark_strong(obj, marked_first);\n+        marked = mark_context->mark_strong(obj, \/* was_upgraded = *\/ skip_live);\n@@ -264,1 +265,1 @@\n-        marked = mark_context->mark_final(obj, marked_first);\n+        marked = mark_context->mark_weak(obj);\n@@ -267,1 +268,1 @@\n-        bool pushed = q->push(ShenandoahMarkTask(obj, marked_first, strong));\n+        bool pushed = q->push(ShenandoahMarkTask(obj, skip_live, strong));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.inline.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-  inline bool mark_strong(HeapWord* w, bool& marked_first);\n+  inline bool mark_strong(HeapWord* w, bool& was_upgraded);\n@@ -153,5 +153,5 @@\n-  \/\/ Mark word as 'final' if it hasn't been marked final or strong yet.\n-  \/\/ Return true if the word has been marked final, false if it has already been\n-  \/\/ marked strong or final or if another thread has beat us by marking it\n-  \/\/ strong or final.\n-  inline bool mark_final(HeapWord* w, bool& marked_first);\n+  \/\/ Mark word as 'weak' if it hasn't been marked weak or strong yet.\n+  \/\/ Return true if the word has been marked weak, false if it has already been\n+  \/\/ marked strong or weak or if another thread has beat us by marking it\n+  \/\/ strong or weak.\n+  inline bool mark_weak(HeapWord* heap_addr);\n@@ -159,0 +159,1 @@\n+  inline bool is_marked(HeapWord* addr) const;\n@@ -160,3 +161,1 @@\n-  inline bool is_marked_final(HeapWord* w) const;\n-  inline bool is_marked_strong_and_final(HeapWord* w) const;\n-  inline bool is_marked_strong_or_final(HeapWord* w) const;\n+  inline bool is_marked_weak(HeapWord* addr) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.hpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-inline bool ShenandoahMarkBitMap::mark_strong(HeapWord* heap_addr, bool& marked_first) {\n+inline bool ShenandoahMarkBitMap::mark_strong(HeapWord* heap_addr, bool& was_upgraded) {\n@@ -47,1 +47,1 @@\n-  const bm_word_t mask_final = (bm_word_t)1 << (bit_in_word(bit) + 1);\n+  const bm_word_t mask_weak = (bm_word_t)1 << (bit_in_word(bit) + 1);\n@@ -53,1 +53,1 @@\n-      marked_first = false;\n+      assert(!was_upgraded, \"Should be false already\");\n@@ -58,1 +58,1 @@\n-      marked_first = (cur_val & mask_final) == 0;\n+      was_upgraded = (cur_val & mask_weak) != 0;\n@@ -65,1 +65,1 @@\n-inline bool ShenandoahMarkBitMap::mark_final(HeapWord* heap_addr, bool& marked_first) {\n+inline bool ShenandoahMarkBitMap::mark_weak(HeapWord* heap_addr) {\n@@ -71,1 +71,1 @@\n-  const bm_word_t mask_final = (bm_word_t)1 << (bit_in_word(bit) + 1);\n+  const bm_word_t mask_weak = (bm_word_t)1 << (bit_in_word(bit) + 1);\n@@ -77,2 +77,1 @@\n-      marked_first = false;\n-      return false; \/\/ Already marked strong,\n+      return false;     \/\/ Already marked strong\n@@ -80,1 +79,1 @@\n-    const bm_word_t new_val = old_val | mask_final;\n+    const bm_word_t new_val = old_val | mask_weak;\n@@ -82,1 +81,0 @@\n-      marked_first = false;\n@@ -87,1 +85,0 @@\n-      marked_first = true;\n@@ -99,1 +96,1 @@\n-inline bool ShenandoahMarkBitMap::is_marked_final(HeapWord* addr) const {\n+inline bool ShenandoahMarkBitMap::is_marked_weak(HeapWord* addr) const {\n@@ -104,9 +101,1 @@\n-inline bool ShenandoahMarkBitMap::is_marked_strong_and_final(HeapWord* addr) const {\n-  check_mark(addr);\n-  idx_t index = address_to_index(addr);\n-  verify_index(index);\n-  bm_word_t mask = (bm_word_t)3 << bit_in_word(index);\n-  return (*word_addr(index) & mask) == mask;\n-}\n-\n-inline bool ShenandoahMarkBitMap::is_marked_strong_or_final(HeapWord* addr) const {\n+inline bool ShenandoahMarkBitMap::is_marked(HeapWord* addr) const {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.inline.hpp","additions":10,"deletions":21,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-  inline bool mark_strong(oop obj, bool& marked_first);\n-  inline bool mark_final(oop obj, bool& marked_first);\n+  inline bool mark_strong(oop obj, bool& was_upgraded);\n+  inline bool mark_weak(oop obj);\n@@ -61,2 +61,1 @@\n-  inline bool is_marked_final(oop obj) const;\n-  inline bool is_marked_strong_and_final(oop obj) const;\n+  inline bool is_marked_weak(oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-inline bool ShenandoahMarkingContext::mark_strong(oop obj, bool& marked_first) {\n+inline bool ShenandoahMarkingContext::mark_strong(oop obj, bool& was_upgraded) {\n@@ -33,1 +33,1 @@\n-  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_strong(cast_from_oop<HeapWord*>(obj), marked_first);\n+  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_strong(cast_from_oop<HeapWord*>(obj), was_upgraded);\n@@ -36,1 +36,1 @@\n-inline bool ShenandoahMarkingContext::mark_final(oop obj, bool& marked_first) {\n+inline bool ShenandoahMarkingContext::mark_weak(oop obj) {\n@@ -38,1 +38,1 @@\n-  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_final(cast_from_oop<HeapWord*>(obj), marked_first);\n+  return (! allocated_after_mark_start(obj)) && _mark_bit_map.mark_weak(cast_from_oop<HeapWord *>(obj));\n@@ -42,1 +42,1 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong_or_final(cast_from_oop<HeapWord*>(obj));\n+  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n@@ -49,6 +49,2 @@\n-inline bool ShenandoahMarkingContext::is_marked_final(oop obj) const {\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_final(cast_from_oop<HeapWord*>(obj));\n-}\n-\n-inline bool ShenandoahMarkingContext::is_marked_strong_and_final(oop obj) const {\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong_and_final(cast_from_oop<HeapWord*>(obj));\n+inline bool ShenandoahMarkingContext::is_marked_weak(oop obj) const {\n+  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_weak(cast_from_oop<HeapWord *>(obj));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -82,3 +82,3 @@\n-\/\/ Lower bits of oop are reserved to handle \"cnt_live\" and \"strong\" properties. Since this encoding\n-\/\/ stores uncompressed oops, those bits are always available. These bits default to zero for \"count liveness\"\n-\/\/ and \"strong\" set, that is they are inverted from their natural meaning. This improves the frequent case\n+\/\/ Lower bits of oop are reserved to handle \"skip_live\" and \"strong\" properties. Since this encoding\n+\/\/ stores uncompressed oops, those bits are always available. These bits default to zero for \"skip_live\"\n+\/\/ and \"strong\". For \"strong\", this inverts the natural boolean meaning. This improves the frequent case\n@@ -154,1 +154,1 @@\n-  static const uintptr_t cnt_live_extract_mask  = 1 << 0;\n+  static const uintptr_t skip_live_extract_mask = 1 << 0;\n@@ -184,1 +184,1 @@\n-    return (val & cnt_live_extract_mask) == 0;\n+    return (val & skip_live_extract_mask) == 0;\n@@ -187,1 +187,1 @@\n-  inline uintptr_t encode_oop(oop obj, bool count_liveness, bool strong) const {\n+  inline uintptr_t encode_oop(oop obj, bool skip_live, bool strong) const {\n@@ -190,2 +190,2 @@\n-    if (!count_liveness) {\n-      encoded |= cnt_live_extract_mask;\n+    if (skip_live) {\n+      encoded |= skip_live_extract_mask;\n@@ -208,2 +208,2 @@\n-  ShenandoahMarkTask(oop o = NULL, bool cnt_live = true, bool strong = true) {\n-    uintptr_t enc = encode_oop(o, cnt_live, strong);\n+  ShenandoahMarkTask(oop o = NULL, bool skip_live = false, bool strong = true) {\n+    uintptr_t enc = encode_oop(o, skip_live, strong);\n@@ -211,1 +211,1 @@\n-    assert(decode_cnt_live(enc) == cnt_live, \"cnt_live encoding should work\");\n+    assert(decode_cnt_live(enc) == !skip_live, \"skip_live encoding should work\");\n@@ -217,2 +217,2 @@\n-  ShenandoahMarkTask(oop o, bool cnt_live, bool strong, int chunk, int pow) {\n-    uintptr_t enc_oop = encode_oop(o, cnt_live, strong);\n+  ShenandoahMarkTask(oop o, bool skip_live, bool strong, int chunk, int pow) {\n+    uintptr_t enc_oop = encode_oop(o, skip_live, strong);\n@@ -223,1 +223,1 @@\n-    assert(decode_cnt_live(enc) == cnt_live, \"cnt_live encoding should work\");\n+    assert(decode_cnt_live(enc) == !skip_live, \"skip_live encoding should work\");\n@@ -268,2 +268,2 @@\n-  ShenandoahMarkTask(oop o = NULL, bool count_liveness = true, bool strong = true, int chunk = 0, int pow = 0):\n-    _obj(o), _count_liveness(count_liveness), _strong(strong), _chunk(chunk), _pow(pow) {\n+  ShenandoahMarkTask(oop o = NULL, bool skip_live = false, bool strong = true, int chunk = 0, int pow = 0):\n+    _obj(o), _count_liveness(!skip_live), _strong(strong), _chunk(chunk), _pow(pow) {\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahTaskqueue.hpp","additions":16,"deletions":16,"binary":false,"changes":32,"status":"modified"}]}