{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-            if (c.getClass() == ArrayList.class) {\n+            if (Collections.isTrustedCollection(c)) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1012,0 +1012,3 @@\n+    interface CollectionWrapper {\n+        Collection<?> getCollection();\n+    }\n@@ -1048,1 +1051,1 @@\n-    static class UnmodifiableCollection<E> implements Collection<E>, Serializable {\n+    static class UnmodifiableCollection<E> implements Collection<E>, CollectionWrapper, Serializable {\n@@ -1061,0 +1064,2 @@\n+        public Collection<?> getCollection()       {return c;}\n+\n@@ -2082,1 +2087,1 @@\n-    static class SynchronizedCollection<E> implements Collection<E>, Serializable {\n+    static class SynchronizedCollection<E> implements Collection<E>, CollectionWrapper, Serializable {\n@@ -2101,0 +2106,4 @@\n+        public Collection<?> getCollection() {\n+            return c;\n+        }\n+\n@@ -3144,1 +3153,1 @@\n-    static class CheckedCollection<E> implements Collection<E>, Serializable {\n+    static class CheckedCollection<E> implements Collection<E>, CollectionWrapper, Serializable {\n@@ -3170,0 +3179,2 @@\n+        public Collection<?> getCollection()              { return c; }\n+\n@@ -5697,1 +5708,1 @@\n-        implements Set<E>, Serializable\n+        implements Set<E>, CollectionWrapper, Serializable\n@@ -5710,0 +5721,2 @@\n+        public Collection<?> getCollection()     { return s; }\n+\n@@ -5782,1 +5795,1 @@\n-        implements Queue<E>, Serializable {\n+        implements Queue<E>, CollectionWrapper, Serializable {\n@@ -5788,0 +5801,1 @@\n+        public Collection<?> getCollection()               { return q; }\n@@ -5823,0 +5837,70 @@\n+\n+    private static final Set<String> trustedCollections = Set.of(\n+        \/\/ Lists\n+        \"java.util.Collections$EmptyList\",\n+        \"java.util.Collections$SingletonList\",\n+        \"java.util.Arrays$ArrayList\",\n+        \"java.util.ArrayList\",\n+        \"java.util.LinkedList\",\n+        \"java.util.Vector\",\n+        \"java.util.Stack\",\n+        \"java.util.concurrent.CopyOnWriteArrayList\",\n+\n+        \/\/ Sets\n+        \"java.util.HashSet\",\n+        \"java.util.LinkedHashSet\",\n+        \"java.util.TreeSet\",\n+        \"java.util.JumboEnumSet\",\n+        \"java.util.RegularEnumSet\",\n+        \"java.util.Collections$EmptySet\",\n+        \"java.util.Collections$SingletonSet\",\n+        \"java.util.concurrent.CopyOnWriteArraySet\",\n+        \"java.util.concurrent.ConcurrentSkipListSet\",\n+\n+        \/\/ Queue\n+        \"java.util.ArrayDeque\",\n+        \"java.util.PriorityQueue\",\n+        \"java.util.concurrent.ArrayBlockingQueue\",\n+        \"java.util.concurrent.ConcurrentLinkedQueue\",\n+        \"java.util.concurrent.ConcurrentLinkedDeque\",\n+        \"java.util.concurrent.DelayQueue\",\n+        \"java.util.concurrent.LinkedBlockingQueue\",\n+        \"java.util.concurrent.LinkedBlockingDeque\",\n+        \"java.util.concurrent.LinkedTransferQueue\",\n+        \"java.util.concurrent.PriorityBlockingQueue\",\n+        \"java.util.concurrent.SynchronousQueue\"\n+    );\n+\n+    private static final Set<String> trustedMaps = Set.of(\n+        \"java.util.Properties\",\n+        \"java.util.HashMap\",\n+        \"java.util.LinkedHashMap\",\n+        \"java.util.IdentityHashMap\",\n+        \"java.util.WeakHashMap\",\n+        \"java.util.Hashtable\",\n+        \"java.util.TreeMap\",\n+        \"java.util.EnumMap\",\n+        \"java.util.concurrent.ConcurrentHashMap\",\n+        \"java.util.concurrent.ConcurrentSkipListMap\"\n+    );\n+\n+    \/*\n+     * Checks whether the collection is trusted.\n+     * It is safe to assume that all methods of trusted collection are compliant\n+     *\/\n+    static boolean isTrustedCollection(Collection<?> coll) {\n+        if (coll.getClass().getModule() == Object.class.getModule()) {\n+            if (coll instanceof CollectionWrapper wrapper) {\n+                return isTrustedCollection(wrapper.getCollection());\n+            } else if (trustedCollections.contains(coll.getClass().getName())) {\n+                return true;\n+            } else if (coll instanceof ImmutableCollections.AbstractImmutableCollection<?>) {\n+                return true;\n+            } else if (coll instanceof Set<?> && coll.getClass().isMemberClass()) { \/\/ Map keys set or entries set\n+                return trustedMaps.contains(coll.getClass().getNestHost().getName());\n+            } else {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Collections.java","additions":89,"deletions":5,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -123,0 +123,3 @@\n+                public boolean isTrustedCollection(Collection<?> coll) {\n+                    return Collections.isTrustedCollection(coll);\n+                }\n@@ -173,0 +176,2 @@\n+        } else if (Collections.isTrustedCollection(coll)) {\n+            return listFromTrustedArray(coll.toArray());\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-        if (c.getClass() != ArrayList.class)\n+        if (!Collections.isTrustedCollection(c))\n","filename":"src\/java.base\/share\/classes\/java\/util\/PriorityQueue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-        if (c.getClass() == ArrayList.class) {\n+        if (Collections.isTrustedCollection(c)) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Vector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.ArrayList;\n@@ -143,1 +142,1 @@\n-            if (c.getClass() != java.util.ArrayList.class)\n+            if (!SharedSecrets.getJavaUtilCollectionAccess().isTrustedCollection(c))\n@@ -692,1 +691,4 @@\n-        if (c.getClass() != ArrayList.class) {\n+        if (cs.length == 0) {\n+            return 0;\n+        }\n+        if (!SharedSecrets.getJavaUtilCollectionAccess().isTrustedCollection(c)) {\n@@ -695,2 +697,0 @@\n-        if (cs.length == 0)\n-            return 0;\n@@ -746,2 +746,1 @@\n-            if (len == 0 && (c.getClass() == CopyOnWriteArrayList.class ||\n-                             c.getClass() == ArrayList.class)) {\n+            if (len == 0 && SharedSecrets.getJavaUtilCollectionAccess().isTrustedCollection(c)) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-        if (c.getClass() != java.util.ArrayList.class)\n+        if (!SharedSecrets.getJavaUtilCollectionAccess().isTrustedCollection(c))\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/PriorityBlockingQueue.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Collection;\n@@ -31,0 +32,1 @@\n+    boolean isTrustedCollection(Collection<?> coll);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaUtilCollectionAccess.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}