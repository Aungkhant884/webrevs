{"files":[{"patch":"@@ -3661,1 +3661,1 @@\n-    ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);\n+    ThreadStateTransition::transition_from_vm(thread, _thread_in_native);\n@@ -3881,5 +3881,2 @@\n-  \/\/ of in the JVM_ENTRY. But in this situation we have to do it manually. Notice, that by\n-  \/\/ using ThreadStateTransition::transition, we do a callback to the safepoint code if\n-  \/\/ needed.\n-\n-  ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_native);\n+  \/\/ of in the JVM_ENTRY. But in this situation we have to do it manually.\n+  ThreadStateTransition::transition_from_vm(thread, _thread_in_native);\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -120,1 +120,1 @@\n-         ThreadStateTransition::transition(_jthread, _saved_state, _thread_in_native);\n+         ThreadStateTransition::transition_from_vm(_jthread, _thread_in_native);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  thread->clear_pending_exception();\n+\n@@ -88,12 +91,1 @@\n-  ThreadStateTransition::transition_from_native(thread, _thread_in_Java);\n-\n-  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n-  \/\/ in OptimizedEntryBlob::FrameData. This way, we can decide if we need to do any pd actions\n-  \/\/ to prepare for stop\/suspend (cache sp, or other state).\n-  bool clear_pending_exception = true;\n-  if (thread->has_special_runtime_exit_condition()) {\n-    thread->handle_special_runtime_exit_condition();\n-    if (thread->has_pending_exception()) {\n-      clear_pending_exception = false;\n-    }\n-  }\n+  ThreadStateTransition::transition_from_native(thread, _thread_in_Java, true \/* check_asyncs *\/);\n@@ -114,5 +106,0 @@\n-  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n-  if (clear_pending_exception) {\n-    thread->clear_pending_exception();\n-  }\n-\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -79,6 +79,0 @@\n- public:\n-  ThreadStateTransition(JavaThread *thread) {\n-    _thread = thread;\n-    assert(thread != NULL, \"must be active Java thread\");\n-    assert(thread == Thread::current(), \"must be current thread\");\n-  }\n@@ -86,10 +80,3 @@\n-  \/\/ Change threadstate in a manner, so safepoint can detect changes.\n-  \/\/ Time-critical: called on exit from every runtime routine\n-  static inline void transition(JavaThread *thread, JavaThreadState from, JavaThreadState to) {\n-    assert(from != _thread_in_Java, \"use transition_from_java\");\n-    assert(from != _thread_in_native, \"use transition_from_native\");\n-    assert((from & 1) == 0 && (to & 1) == 0, \"odd numbers are transitions states\");\n-    assert(thread->thread_state() == from, \"coming from wrong thread state\");\n-\n-    \/\/ Check NoSafepointVerifier\n-    \/\/ This also clears unhandled oops if CheckUnhandledOops is used.\n+ private:\n+  static inline void transition_and_process(JavaThread *thread, JavaThreadState to, bool check_asyncs) {\n+    \/\/ Check NoSafepointVerifier. This also clears unhandled oops if CheckUnhandledOops is used.\n@@ -98,4 +85,2 @@\n-    \/\/ Change to transition state and ensure it is seen by the VM thread.\n-    thread->set_thread_state_fence((JavaThreadState)(from + 1));\n-\n-    SafepointMechanism::process_if_requested(thread);\n+    thread->set_thread_state_fence(_thread_in_vm);\n+    SafepointMechanism::process_if_requested_with_exit_check(thread, check_asyncs);\n@@ -105,3 +90,6 @@\n-  \/\/ Same as above, but assumes from = _thread_in_Java. This is simpler, since we\n-  \/\/ never block on entry to the VM. This will break the code, since e.g. preserve arguments\n-  \/\/ have not been setup.\n+ public:\n+  ThreadStateTransition(JavaThread *thread) : _thread(thread) {\n+    assert(thread != NULL, \"must be active Java thread\");\n+    assert(thread == Thread::current(), \"must be current thread\");\n+  }\n+\n@@ -110,0 +98,1 @@\n+    assert(to == _thread_in_vm || to == _thread_in_native, \"invalid transition\");\n@@ -113,2 +102,4 @@\n-  static inline void transition_from_native(JavaThread *thread, JavaThreadState to) {\n-    assert((to & 1) == 0, \"odd numbers are transitions states\");\n+  \/\/ We never install asynchronous exceptions when coming (back) in to the runtime\n+  \/\/ from native code because the runtime is not set up to handle exceptions floating\n+  \/\/ around at arbitrary points.\n+  static inline void transition_from_native(JavaThread *thread, JavaThreadState to, bool check_asyncs = true) {\n@@ -116,10 +107,3 @@\n-    assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native->vm transition\");\n-\n-    \/\/ Change to transition state and ensure it is seen by the VM thread.\n-    thread->set_thread_state_fence(_thread_in_native_trans);\n-\n-    \/\/ We never install asynchronous exceptions when coming (back) in\n-    \/\/ to the runtime from native code because the runtime is not set\n-    \/\/ up to handle exceptions floating around at arbitrary points.\n-    SafepointMechanism::process_if_requested_with_exit_check(thread, false \/* check asyncs *\/);\n-    thread->set_thread_state(to);\n+    assert(to == _thread_in_vm || to == _thread_in_Java, \"invalid transition\");\n+    assert(!thread->has_last_Java_frame() || thread->frame_anchor()->walkable(), \"Unwalkable stack in native transition\");\n+    transition_and_process(thread, to, to != _thread_in_Java ? false : check_asyncs);\n@@ -128,4 +112,15 @@\n- protected:\n-   void trans(JavaThreadState from, JavaThreadState to)  { transition(_thread, from, to); }\n-   void trans_from_java(JavaThreadState to)              { transition_from_java(_thread, to); }\n-   void trans_from_native(JavaThreadState to)            { transition_from_native(_thread, to); }\n+  static inline void transition_from_vm(JavaThread *thread, JavaThreadState to, bool check_asyncs = true) {\n+    assert(thread->thread_state() == _thread_in_vm, \"coming from wrong thread state\");\n+    if (to == _thread_in_Java) {\n+      transition_and_process(thread, _thread_in_Java, check_asyncs);\n+    } else {\n+      assert(to == _thread_in_native || to == _thread_blocked, \"invalid transition\");\n+      \/\/ Check NoSafepointVerifier. This also clears unhandled oops if CheckUnhandledOops is used.\n+      thread->check_possible_safepoint();\n+\n+      \/\/ Once we are in native\/blocked vm expects stack to be walkable\n+      thread->frame_anchor()->make_walkable(thread);\n+      OrderAccess::storestore(); \/\/ Keep thread_state change and make_walkable() separate.\n+      thread->set_thread_state(to);\n+    }\n+  }\n@@ -161,1 +156,1 @@\n-    trans_from_java(_thread_in_vm);\n+    transition_from_java(thread, _thread_in_vm);\n@@ -167,1 +162,0 @@\n-    trans(_thread_in_vm, _thread_in_Java);\n@@ -170,1 +164,1 @@\n-    if (_thread->has_special_runtime_exit_condition()) _thread->handle_special_runtime_exit_condition(_check_asyncs);\n+    transition_from_vm(_thread, _thread_in_Java, _check_asyncs);\n@@ -194,1 +188,1 @@\n-      ThreadStateTransition::transition(_thread, _thread_in_vm, _thread_in_native);\n+      ThreadStateTransition::transition_from_vm(_thread, _thread_in_native);\n@@ -204,1 +198,1 @@\n-    trans_from_native(_thread_in_vm);\n+    transition_from_native(thread, _thread_in_vm);\n@@ -207,1 +201,0 @@\n-    assert(_thread->thread_state() == _thread_in_vm, \"coming from wrong thread state\");\n@@ -210,5 +203,1 @@\n-    _thread->check_possible_safepoint();\n-    \/\/ Once we are in native vm expects stack to be walkable\n-    _thread->frame_anchor()->make_walkable(_thread);\n-    OrderAccess::storestore(); \/\/ Keep thread_state change and make_walkable() separate.\n-    _thread->set_thread_state(_thread_in_native);\n+    transition_from_vm(_thread, _thread_in_native);\n@@ -222,2 +211,0 @@\n-    \/\/ We are leaving the VM at this point and going directly to native code.\n-    \/\/ Block, if we are in the middle of a safepoint synchronization.\n@@ -225,4 +212,1 @@\n-    thread->frame_anchor()->make_walkable(thread);\n-    trans(_thread_in_vm, _thread_in_native);\n-    \/\/ Check for pending. async. exceptions or suspends.\n-    if (_thread->has_special_runtime_exit_condition()) _thread->handle_special_runtime_exit_condition(false);\n+    transition_from_vm(thread, _thread_in_native);\n@@ -230,1 +214,0 @@\n-\n@@ -232,1 +215,1 @@\n-    trans_from_native(_thread_in_vm);\n+    transition_from_native(_thread, _thread_in_vm);\n@@ -250,6 +233,1 @@\n-    assert(thread->thread_state() == _thread_in_vm, \"coming from wrong thread state\");\n-    thread->check_possible_safepoint();\n-    \/\/ Once we are blocked vm expects stack to be walkable\n-    thread->frame_anchor()->make_walkable(thread);\n-    OrderAccess::storestore(); \/\/ Keep thread_state change and make_walkable() separate.\n-    thread->set_thread_state(_thread_blocked);\n+    transition_from_vm(thread, _thread_blocked);\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":42,"deletions":64,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  bool clear_pending_exception = true;\n@@ -68,0 +67,3 @@\n+  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n+  thread->clear_pending_exception();\n+\n@@ -70,11 +72,1 @@\n-  ThreadStateTransition::transition(thread, _thread_in_vm, _thread_in_Java);\n-\n-  \/\/ Make sure that we handle asynchronous stops and suspends _before_ we clear all thread state\n-  \/\/ in JavaCallWrapper::JavaCallWrapper(). This way, we can decide if we need to do any pd actions\n-  \/\/ to prepare for stop\/suspend (flush register windows on sparcs, cache sp, or other state).\n-  if (thread->has_special_runtime_exit_condition()) {\n-    thread->handle_special_runtime_exit_condition();\n-    if (HAS_PENDING_EXCEPTION) {\n-      clear_pending_exception = false;\n-    }\n-  }\n+  ThreadStateTransition::transition_from_vm(thread, _thread_in_Java, true \/* check_asyncs *\/);\n@@ -107,5 +99,0 @@\n-  \/\/ clear any pending exception in thread (native calls start with no exception pending)\n-  if(clear_pending_exception) {\n-    _thread->clear_pending_exception();\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-      case _thread_in_vm_trans:\n+      case _thread_in_vm:\n@@ -136,1 +136,0 @@\n-      case _thread_new_trans:\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1230,1 +1230,3 @@\n-  ThreadStateTransition::transition(this, _thread_new, _thread_in_vm);\n+  assert(this->thread_state() == _thread_new, \"wrong thread state\");\n+  set_thread_state(_thread_in_vm);\n+\n@@ -1647,1 +1649,1 @@\n-      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in a recent unsafe memory access operation in compiled Java code\");\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation in compiled Java code\");\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    private static final String expectedErrorMsg = \"fault occurred in a recent unsafe memory access\";\n+    private static final String expectedErrorMsg = \"fault occurred in an unsafe memory access\";\n","filename":"test\/hotspot\/jtreg\/runtime\/Unsafe\/InternalErrorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}