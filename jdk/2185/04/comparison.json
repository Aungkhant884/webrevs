{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n@@ -31,2 +32,0 @@\n-#include \"gc\/shenandoah\/shenandoahCollectorPolicy.hpp\"\n-#include \"gc\/shenandoah\/shenandoahConcurrentRoots.hpp\"\n@@ -34,1 +33,1 @@\n-#include \"gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStackWatermark.hpp\"\n@@ -114,0 +113,4 @@\n+\n+    JavaThread* const jt = thread->as_Java_thread();\n+    StackWatermark* const watermark = new ShenandoahStackWatermark(jt);\n+    StackWatermarkSet::add_watermark(jt, watermark);\n@@ -125,0 +128,10 @@\n+\n+    \/\/ SATB protocol requires to keep alive reacheable oops from roots at the beginning of GC\n+    ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+    if (heap->is_concurrent_mark_in_progress()) {\n+      ShenandoahKeepAliveClosure oops;\n+      StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+    } else if (heap->is_concurrent_weak_root_in_progress() && heap->is_evacuation_in_progress()) {\n+      ShenandoahContextEvacuateUpdateRootsClosure oops;\n+      StackWatermarkSet::finish_processing(thread->as_Java_thread(), &oops, StackWatermarkKind::gc);\n+    }\n@@ -133,1 +146,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahBarrierSet.cpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+class ShenandoahBarrierSet;\n@@ -60,0 +61,12 @@\n+class ShenandoahKeepAliveClosure : public OopClosure {\n+private:\n+  ShenandoahBarrierSet* const _bs;\n+public:\n+  inline ShenandoahKeepAliveClosure();\n+  inline void do_oop(oop* p);\n+  inline void do_oop(narrowOop* p);\n+private:\n+  template <typename T>\n+  void do_oop_work(T* p);\n+};\n+\n@@ -73,1 +86,1 @@\n-class ShenandoahEvacuateUpdateRootsClosure: public BasicOopIterateClosure {\n+class ShenandoahEvacuateUpdateMetadataClosure: public BasicOopIterateClosure {\n@@ -75,2 +88,2 @@\n-  ShenandoahHeap* _heap;\n-  Thread* _thread;\n+  ShenandoahHeap* const _heap;\n+  Thread* const         _thread;\n@@ -78,1 +91,1 @@\n-  inline ShenandoahEvacuateUpdateRootsClosure();\n+  inline ShenandoahEvacuateUpdateMetadataClosure();\n@@ -87,1 +100,2 @@\n-class ShenandoahEvacUpdateOopStorageRootsClosure : public BasicOopIterateClosure {\n+\/\/ Context free version, cannot cache calling thread\n+class ShenandoahEvacuateUpdateRootsClosure : public BasicOopIterateClosure {\n@@ -89,2 +103,13 @@\n-  ShenandoahHeap* _heap;\n-  Thread* _thread;\n+  ShenandoahHeap* const _heap;\n+public:\n+  inline ShenandoahEvacuateUpdateRootsClosure();\n+  inline void do_oop(oop* p);\n+  inline void do_oop(narrowOop* p);\n+protected:\n+  template <typename T>\n+  inline void do_oop_work(T* p, Thread* thr);\n+};\n+\n+class ShenandoahContextEvacuateUpdateRootsClosure : public ShenandoahEvacuateUpdateRootsClosure {\n+private:\n+  Thread* const _thread;\n@@ -92,1 +117,1 @@\n-  inline ShenandoahEvacUpdateOopStorageRootsClosure();\n+  inline ShenandoahContextEvacuateUpdateRootsClosure();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.hpp","additions":33,"deletions":8,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shenandoah\/shenandoahBarrierSet.hpp\"\n@@ -30,0 +31,1 @@\n+#include \"gc\/shenandoah\/shenandoahEvacOOMHandler.inline.hpp\"\n@@ -67,0 +69,24 @@\n+ShenandoahKeepAliveClosure::ShenandoahKeepAliveClosure() :\n+  _bs(static_cast<ShenandoahBarrierSet*>(BarrierSet::barrier_set())) {\n+}\n+\n+void ShenandoahKeepAliveClosure::do_oop(oop* p) {\n+  do_oop_work(p);\n+}\n+\n+void ShenandoahKeepAliveClosure::do_oop(narrowOop* p) {\n+  do_oop_work(p);\n+}\n+\n+template <typename T>\n+void ShenandoahKeepAliveClosure::do_oop_work(T* p) {\n+  assert(ShenandoahHeap::heap()->is_concurrent_mark_in_progress(), \"Only for concurrent marking phase\");\n+  assert(!ShenandoahHeap::heap()->has_forwarded_objects(), \"Not expected\");\n+\n+  T o = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(o)) {\n+    oop obj = CompressedOops::decode_not_null(o);\n+    _bs->enqueue(obj);\n+  }\n+}\n+\n@@ -84,1 +110,1 @@\n-ShenandoahEvacuateUpdateRootsClosure<MO>::ShenandoahEvacuateUpdateRootsClosure() :\n+ShenandoahEvacuateUpdateMetadataClosure<MO>::ShenandoahEvacuateUpdateMetadataClosure() :\n@@ -90,1 +116,1 @@\n-void ShenandoahEvacuateUpdateRootsClosure<MO>::do_oop_work(T* p) {\n+void ShenandoahEvacuateUpdateMetadataClosure<MO>::do_oop_work(T* p) {\n@@ -94,0 +120,1 @@\n+  assert(_thread == Thread::current(), \"Wrong thread\");\n@@ -110,1 +137,1 @@\n-void ShenandoahEvacuateUpdateRootsClosure<MO>::do_oop(oop* p) {\n+void ShenandoahEvacuateUpdateMetadataClosure<MO>::do_oop(oop* p) {\n@@ -115,1 +142,1 @@\n-void ShenandoahEvacuateUpdateRootsClosure<MO>::do_oop(narrowOop* p) {\n+void ShenandoahEvacuateUpdateMetadataClosure<MO>::do_oop(narrowOop* p) {\n@@ -119,2 +146,2 @@\n-ShenandoahEvacUpdateOopStorageRootsClosure::ShenandoahEvacUpdateOopStorageRootsClosure() :\n-  _heap(ShenandoahHeap::heap()), _thread(Thread::current()) {\n+ShenandoahEvacuateUpdateRootsClosure::ShenandoahEvacuateUpdateRootsClosure() :\n+  _heap(ShenandoahHeap::heap()) {\n@@ -123,1 +150,2 @@\n-void ShenandoahEvacUpdateOopStorageRootsClosure::do_oop(oop* p) {\n+template <typename T>\n+void ShenandoahEvacuateUpdateRootsClosure::do_oop_work(T* p, Thread* t) {\n@@ -127,0 +155,1 @@\n+  assert(t == Thread::current(), \"Wrong thread\");\n@@ -128,2 +157,3 @@\n-  oop obj = RawAccess<>::oop_load(p);\n-  if (! CompressedOops::is_null(obj)) {\n+  T o = RawAccess<>::oop_load(p);\n+  if (!CompressedOops::is_null(o)) {\n+    oop obj = CompressedOops::decode_not_null(o);\n@@ -135,1 +165,1 @@\n-        resolved = _heap->evacuate_object(obj, _thread);\n+        resolved = _heap->evacuate_object(obj, t);\n@@ -137,2 +167,1 @@\n-\n-      Atomic::cmpxchg(p, obj, resolved);\n+      _heap->cas_oop(resolved, p, o);\n@@ -143,2 +172,23 @@\n-void ShenandoahEvacUpdateOopStorageRootsClosure::do_oop(narrowOop* p) {\n-  ShouldNotReachHere();\n+void ShenandoahEvacuateUpdateRootsClosure::do_oop(oop* p) {\n+  ShenandoahEvacOOMScope scope;\n+  do_oop_work(p, Thread::current());\n+}\n+\n+void ShenandoahEvacuateUpdateRootsClosure::do_oop(narrowOop* p) {\n+  ShenandoahEvacOOMScope scope;\n+  do_oop_work(p, Thread::current());\n+}\n+\n+ShenandoahContextEvacuateUpdateRootsClosure::ShenandoahContextEvacuateUpdateRootsClosure() :\n+  ShenandoahEvacuateUpdateRootsClosure(),\n+  _thread(Thread::current()) {\n+}\n+\n+void ShenandoahContextEvacuateUpdateRootsClosure::do_oop(oop* p) {\n+  ShenandoahEvacOOMScope scope;\n+  do_oop_work(p, _thread);\n+}\n+\n+void ShenandoahContextEvacuateUpdateRootsClosure::do_oop(narrowOop* p) {\n+  ShenandoahEvacOOMScope scope;\n+  do_oop_work(p, _thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":64,"deletions":14,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"gc\/shenandoah\/shenandoahVMOperations.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStackWatermark.hpp\"\n@@ -42,0 +42,1 @@\n+#include \"gc\/shenandoah\/shenandoahVMOperations.hpp\"\n@@ -81,0 +82,5 @@\n+  \/\/ Concurrent stack processing\n+  if (heap->is_evacuation_in_progress()) {\n+    entry_thread_roots();\n+  }\n+\n@@ -271,0 +277,14 @@\n+void ShenandoahConcurrentGC::entry_thread_roots() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  static const char* msg = \"Concurrent thread roots\";\n+  ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_thread_roots);\n+  EventMark em(\"%s\", msg);\n+\n+  ShenandoahWorkerScope scope(heap->workers(),\n+                              ShenandoahWorkerPolicy::calc_workers_for_conc_root_processing(),\n+                              msg);\n+\n+  heap->try_inject_alloc_failure();\n+  op_thread_roots();\n+}\n+\n@@ -463,8 +483,0 @@\n-  \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n-  \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n-  \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n-  if (UseTLAB) {\n-    ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_manage_tlabs);\n-    heap->tlabs_retire(ResizeTLAB);\n-  }\n-\n@@ -491,2 +503,1 @@\n-  _mark.mark_stw_roots();\n-\n+  ShenandoahStackWatermark::change_epoch_id();\n@@ -536,2 +547,5 @@\n-      \/\/ Arm nmethods for concurrent processing\n-      ShenandoahCodeRoots::arm_nmethods();\n+      \/\/ Verify before arming for concurrent processing.\n+      \/\/ Otherwise, verification can trigger stack processing.\n+      if (ShenandoahVerify) {\n+        heap->verifier()->verify_during_evacuation();\n+      }\n@@ -539,2 +553,3 @@\n-      \/\/ Should be gone after 8212879 and concurrent stack processing\n-      heap->evacuate_and_update_roots();\n+      \/\/ Arm nmethods\/stack for concurrent processing\n+      ShenandoahCodeRoots::arm_nmethods();\n+      ShenandoahStackWatermark::change_epoch_id();\n@@ -545,4 +560,0 @@\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n@@ -564,0 +575,45 @@\n+class ShenandoahConcurrentEvacThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* const _oops;\n+\n+public:\n+  ShenandoahConcurrentEvacThreadClosure(OopClosure* oops);\n+  void do_thread(Thread* thread);\n+};\n+\n+ShenandoahConcurrentEvacThreadClosure::ShenandoahConcurrentEvacThreadClosure(OopClosure* oops) :\n+  _oops(oops) {\n+}\n+\n+void ShenandoahConcurrentEvacThreadClosure::do_thread(Thread* thread) {\n+  JavaThread* const jt = thread->as_Java_thread();\n+  StackWatermarkSet::finish_processing(jt, _oops, StackWatermarkKind::gc);\n+}\n+\n+class ShenandoahConcurrentEvacUpdateThreadTask : public AbstractGangTask {\n+private:\n+  ShenandoahJavaThreadsIterator _java_threads;\n+\n+public:\n+  ShenandoahConcurrentEvacUpdateThreadTask() :\n+    AbstractGangTask(\"Shenandoah Evacuate\/Update Concurrent Thread Roots\"),\n+    _java_threads(ShenandoahPhaseTimings::conc_thread_roots) {\n+  }\n+\n+  void work(uint worker_id) {\n+    \/\/ ShenandoahEvacOOMScope has to be setup by ShenandoahContextEvacuateUpdateRootsClosure.\n+    \/\/ Otherwise, may deadlock with watermark lock\n+    ShenandoahContextEvacuateUpdateRootsClosure oops_cl;\n+    ShenandoahConcurrentEvacThreadClosure thr_cl(&oops_cl);\n+    _java_threads.threads_do(&thr_cl, worker_id);\n+  }\n+};\n+\n+void ShenandoahConcurrentGC::op_thread_roots() {\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  assert(heap->is_evacuation_in_progress(), \"Checked by caller\");\n+  ShenandoahGCWorkerPhase worker_phase(ShenandoahPhaseTimings::conc_thread_roots);\n+  ShenandoahConcurrentEvacUpdateThreadTask task;\n+  heap->workers()->run_task(&task);\n+}\n+\n@@ -683,1 +739,1 @@\n-      ShenandoahEvacuateUpdateRootsClosure<MO_RELEASE> keep_alive;\n+      ShenandoahEvacuateUpdateMetadataClosure<MO_RELEASE> keep_alive;\n@@ -744,2 +800,2 @@\n-  BarrierSetNMethod* const               _bs;\n-  ShenandoahEvacuateUpdateRootsClosure<> _cl;\n+  BarrierSetNMethod* const                  _bs;\n+  ShenandoahEvacuateUpdateMetadataClosure<> _cl;\n@@ -800,2 +856,2 @@\n-        ShenandoahEvacUpdateOopStorageRootsClosure cl;\n-        _vm_roots.oops_do<ShenandoahEvacUpdateOopStorageRootsClosure>(&cl, worker_id);\n+        ShenandoahContextEvacuateUpdateRootsClosure cl;\n+        _vm_roots.oops_do<ShenandoahContextEvacuateUpdateRootsClosure>(&cl, worker_id);\n@@ -805,1 +861,1 @@\n-        ShenandoahEvacuateUpdateRootsClosure<> cl;\n+        ShenandoahEvacuateUpdateMetadataClosure<> cl;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":81,"deletions":25,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+  void entry_thread_roots();\n@@ -92,0 +93,1 @@\n+  void op_thread_roots();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -207,19 +207,0 @@\n-void ShenandoahConcurrentMark::mark_stw_roots() {\n-  assert(Thread::current()->is_VM_thread(), \"Can only do this in VMThread\");\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at a safepoint\");\n-  assert(!ShenandoahHeap::heap()->has_forwarded_objects(), \"Not expected\");\n-\n-  ShenandoahGCPhase phase(ShenandoahPhaseTimings::scan_roots);\n-\n-  WorkGang* workers = ShenandoahHeap::heap()->workers();\n-  uint nworkers = workers->active_workers();\n-\n-  assert(nworkers <= task_queues()->size(), \"Just check\");\n-\n-  TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n-  task_queues()->reserve(nworkers);\n-\n-  ShenandoahInitMarkRootsTask mark_roots(nworkers, task_queues());\n-  workers->run_task(&mark_roots);\n-}\n-\n@@ -264,0 +245,2 @@\n+  TASKQUEUE_STATS_ONLY(task_queues()->reset_taskqueue_stats());\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":2,"deletions":19,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -43,3 +43,1 @@\n-\n-  \/\/ When concurrent stack processing is not supported\n-  void mark_stw_roots();\n+  \/\/ Concurrent mark roots\n@@ -47,1 +45,0 @@\n-\n@@ -53,1 +50,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -244,0 +244,10 @@\n+  \/\/ Retire the TLABs, which will force threads to reacquire their TLABs after the pause.\n+  \/\/ This is needed for two reasons. Strong one: new allocations would be with new freeset,\n+  \/\/ which would be outside the collection set, so no cset writes would happen there.\n+  \/\/ Weaker one: new allocations would happen past update watermark, and so less work would\n+  \/\/ be needed for reference updates (would update the large filler instead).\n+  if (UseTLAB) {\n+    ShenandoahGCPhase phase(ShenandoahPhaseTimings::degen_gc_final_manage_labs);\n+    heap->tlabs_retire(false);\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -613,0 +613,4 @@\n+  if (_safepoint_workers != NULL) {\n+    _safepoint_workers->threads_do(&init_gclabs);\n+    _safepoint_workers->set_initialize_gclab();\n+  }\n@@ -1120,19 +1124,0 @@\n-}\n-\n-class ShenandoahEvacuateUpdateRootsTask : public AbstractGangTask {\n-private:\n-  ShenandoahRootEvacuator* _rp;\n-\n-public:\n-  ShenandoahEvacuateUpdateRootsTask(ShenandoahRootEvacuator* rp) :\n-    AbstractGangTask(\"Shenandoah Evacuate\/Update Roots\"),\n-    _rp(rp) {}\n-\n-  void work(uint worker_id) {\n-    ShenandoahParallelWorkerSession worker_session(worker_id);\n-    ShenandoahEvacOOMScope oom_evac_scope;\n-    ShenandoahEvacuateUpdateRootsClosure<> cl;\n-    MarkingCodeBlobClosure blobsCl(&cl, CodeBlobToOopClosure::FixRelocations);\n-    _rp->roots_do(worker_id, &cl);\n-  }\n-};\n@@ -1140,11 +1125,2 @@\n-void ShenandoahHeap::evacuate_and_update_roots() {\n-#if COMPILER2_OR_JVMCI\n-  DerivedPointerTable::clear();\n-#endif\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Only iterate roots while world is stopped\");\n-  {\n-    \/\/ Include concurrent roots if current cycle can not process those roots concurrently\n-    ShenandoahRootEvacuator rp(workers()->active_workers(),\n-                               ShenandoahPhaseTimings::init_evac);\n-    ShenandoahEvacuateUpdateRootsTask roots_task(&rp);\n-    workers()->run_task(&roots_task);\n+  if (safepoint_workers() != NULL) {\n+    safepoint_workers()->threads_do(&cl);\n@@ -1152,4 +1128,0 @@\n-\n-#if COMPILER2_OR_JVMCI\n-  DerivedPointerTable::update_pointers();\n-#endif\n@@ -1669,11 +1641,0 @@\n-  \/\/ Retire the TLABs, which will force threads to reacquire their TLABs after the pause.\n-  \/\/ This is needed for two reasons. Strong one: new allocations would be with new freeset,\n-  \/\/ which would be outside the collection set, so no cset writes would happen there.\n-  \/\/ Weaker one: new allocations would happen past update watermark, and so less work would\n-  \/\/ be needed for reference updates (would update the large filler instead).\n-  if (UseTLAB) {\n-    ShenandoahGCPhase phase(concurrent ? ShenandoahPhaseTimings::final_manage_labs :\n-                                         ShenandoahPhaseTimings::degen_gc_final_manage_labs);\n-    tlabs_retire(false);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":6,"deletions":45,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -509,0 +509,5 @@\n+\/\/ ---------- Concurrent Stack Processing support\n+\/\/\n+public:\n+  bool uses_stack_watermark_barrier() const override { return true; }\n+\n@@ -597,2 +602,0 @@\n-  void evacuate_and_update_roots();\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -153,24 +153,0 @@\n-template <bool HAS_FWD>\n-class ShenandoahKeepNMethodMetadataAliveClosure : public OopClosure {\n-private:\n-  ShenandoahBarrierSet* const _bs;\n-public:\n-  ShenandoahKeepNMethodMetadataAliveClosure() :\n-    _bs(static_cast<ShenandoahBarrierSet*>(BarrierSet::barrier_set())) {\n-  }\n-\n-  virtual void do_oop(oop* p) {\n-    oop obj = RawAccess<>::oop_load(p);\n-    if (!CompressedOops::is_null(obj)) {\n-      if (HAS_FWD) {\n-        obj = ShenandoahBarrierSet::resolve_forwarded_not_null(obj);\n-      }\n-      _bs->enqueue(obj);\n-    }\n-  }\n-\n-  virtual void do_oop(narrowOop* p) {\n-    ShouldNotReachHere();\n-  }\n-};\n-\n@@ -184,7 +160,2 @@\n-    if (heap->has_forwarded_objects()) {\n-      ShenandoahKeepNMethodMetadataAliveClosure<true> cl;\n-      data->oops_do(&cl);\n-    } else {\n-      ShenandoahKeepNMethodMetadataAliveClosure<false> cl;\n-      data->oops_do(&cl);\n-    }\n+    ShenandoahKeepAliveClosure cl;\n+    data->oops_do(&cl);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.cpp","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  ShenandoahEvacuateUpdateRootsClosure<> cl;\n+  ShenandoahEvacuateUpdateMetadataClosure<> cl;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -117,0 +117,1 @@\n+    case conc_thread_roots:\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-  f(conc_mark_roots,                                \"  Roots \")                        \\\n+  f(conc_mark_roots,                                \"Concurrent Mark Roots \")          \\\n@@ -78,0 +78,3 @@\n+  f(conc_thread_roots,                              \"Concurrent Stack Processing\")     \\\n+  f(conc_thread_roots_work,                           \"  Threads\")                     \\\n+  SHENANDOAH_PAR_PHASE_DO(conc_thread_roots_work_,    \"    CT: \", f)                   \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahStackWatermark.hpp\"\n@@ -37,1 +38,1 @@\n-#include \"prims\/jvmtiExport.hpp\"\n+#include \"runtime\/stackWatermarkSet.inline.hpp\"\n@@ -40,0 +41,17 @@\n+ShenandoahJavaThreadsIterator::ShenandoahJavaThreadsIterator(ShenandoahPhaseTimings::Phase phase) :\n+  _threads(),\n+  _claimed(0),\n+  _phase(phase) {\n+}\n+\n+uint ShenandoahJavaThreadsIterator::claim() {\n+  return Atomic::fetch_and_add(&_claimed, 1u);\n+}\n+\n+void ShenandoahJavaThreadsIterator::threads_do(ThreadClosure* cl, uint worker_id) {\n+  ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::ThreadRoots, worker_id);\n+  for (uint i = claim(); i < _threads.length(); i = claim()) {\n+    cl->do_thread(_threads.thread_at(i));\n+  }\n+}\n+\n@@ -169,0 +187,20 @@\n+class ShenandoahConcurrentMarkThreadClosure : public ThreadClosure {\n+private:\n+  OopClosure* const _oops;\n+\n+public:\n+  ShenandoahConcurrentMarkThreadClosure(OopClosure* oops);\n+  void do_thread(Thread* thread);\n+};\n+\n+ShenandoahConcurrentMarkThreadClosure::ShenandoahConcurrentMarkThreadClosure(OopClosure* oops) :\n+  _oops(oops) {\n+}\n+\n+void ShenandoahConcurrentMarkThreadClosure::do_thread(Thread* thread) {\n+  assert(thread->is_Java_thread(), \"Must be\");\n+  JavaThread* const jt = thread->as_Java_thread();\n+\n+  StackWatermarkSet::finish_processing(jt, _oops, StackWatermarkKind::gc);\n+}\n+\n@@ -172,0 +210,1 @@\n+   _java_threads(phase),\n@@ -180,0 +219,1 @@\n+  update_tlab_stats();\n@@ -193,0 +233,4 @@\n+\n+  ShenandoahConcurrentMarkThreadClosure thr_cl(oops);\n+  _java_threads.threads_do(&thr_cl, worker_id);\n+\n@@ -205,16 +249,12 @@\n-ShenandoahRootEvacuator::ShenandoahRootEvacuator(uint n_workers,\n-                                                 ShenandoahPhaseTimings::Phase phase) :\n-  ShenandoahRootProcessor(phase),\n-  _thread_roots(phase, n_workers > 1) {\n-  nmethod::oops_do_marking_prologue();\n-}\n-\n-ShenandoahRootEvacuator::~ShenandoahRootEvacuator() {\n-  nmethod::oops_do_marking_epilogue();\n-}\n-\n-void ShenandoahRootEvacuator::roots_do(uint worker_id, OopClosure* oops) {\n-  \/\/ Always disarm on-stack nmethods, because we are evacuating\/updating them\n-  \/\/ here\n-  ShenandoahCodeBlobAndDisarmClosure codeblob_cl(oops);\n-  _thread_roots.oops_do(oops, &codeblob_cl, worker_id);\n+void ShenandoahConcurrentRootScanner::update_tlab_stats() {\n+  if (UseTLAB) {\n+    ThreadLocalAllocStats total;\n+    for (uint i = 0; i < _java_threads.length(); i ++) {\n+      Thread* thr = _java_threads.thread_at(i);\n+      if (thr->is_Java_thread()) {\n+        ShenandoahStackWatermark* wm = StackWatermarkSet::get<ShenandoahStackWatermark>(thr->as_Java_thread(), StackWatermarkKind::gc);\n+        total.update(wm->stats());\n+      }\n+    }\n+    total.publish();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":57,"deletions":17,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -68,0 +68,15 @@\n+class ShenandoahJavaThreadsIterator {\n+private:\n+  ThreadsListHandle             _threads;\n+  volatile uint                 _claimed;\n+  ShenandoahPhaseTimings::Phase _phase;\n+\n+  uint claim();\n+public:\n+  ShenandoahJavaThreadsIterator(ShenandoahPhaseTimings::Phase phase);\n+  void threads_do(ThreadClosure* cl, uint worker_id);\n+\n+  uint length() const { return _threads.length(); }\n+  Thread* thread_at(uint index) const { return _threads.thread_at(index); }\n+};\n+\n@@ -186,0 +201,1 @@\n+  ShenandoahJavaThreadsIterator             _java_threads;\n@@ -197,0 +213,3 @@\n+\n+private:\n+  void update_tlab_stats();\n@@ -218,11 +237,0 @@\n-\/\/ Evacuate all roots at a safepoint\n-class ShenandoahRootEvacuator : public ShenandoahRootProcessor {\n-private:\n-  ShenandoahThreadRoots                                     _thread_roots;\n-public:\n-  ShenandoahRootEvacuator(uint n_workers, ShenandoahPhaseTimings::Phase phase);\n-  ~ShenandoahRootEvacuator();\n-\n-  void roots_do(uint worker_id, OopClosure* oops);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahClosures.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahCodeRoots.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"gc\/shenandoah\/shenandoahStackWatermark.hpp\"\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+\n+uint32_t ShenandoahStackWatermark::_epoch_id = 1;\n+\n+ShenandoahOnStackCodeBlobClosure::ShenandoahOnStackCodeBlobClosure() :\n+    _bs_nm(BarrierSet::barrier_set()->barrier_set_nmethod()) {}\n+\n+void ShenandoahOnStackCodeBlobClosure::do_code_blob(CodeBlob* cb) {\n+  nmethod* const nm = cb->as_nmethod_or_null();\n+  if (nm != NULL) {\n+    const bool result = _bs_nm->nmethod_entry_barrier(nm);\n+    assert(result, \"NMethod on-stack must be alive\");\n+  }\n+}\n+\n+ThreadLocalAllocStats& ShenandoahStackWatermark::stats() {\n+  return _stats;\n+}\n+\n+uint32_t ShenandoahStackWatermark::epoch_id() const {\n+  return _epoch_id;\n+}\n+\n+void ShenandoahStackWatermark::change_epoch_id() {\n+  shenandoah_assert_safepoint();\n+  _epoch_id++;\n+}\n+\n+ShenandoahStackWatermark::ShenandoahStackWatermark(JavaThread* jt) :\n+  StackWatermark(jt, StackWatermarkKind::gc, _epoch_id),\n+  _heap(ShenandoahHeap::heap()),\n+  _stats(),\n+  _keep_alive_cl(),\n+  _evac_update_oop_cl(),\n+  _cb_cl() {}\n+\n+OopClosure* ShenandoahStackWatermark::closure_from_context(void* context) {\n+  if (context != NULL) {\n+    assert(_heap->is_concurrent_weak_root_in_progress() ||\n+           _heap->is_concurrent_mark_in_progress(),\n+           \"Only these two phases\");\n+    assert(Thread::current()->is_Worker_thread(), \"Unexpected thread passing in context: \" PTR_FORMAT, p2i(context));\n+    return reinterpret_cast<OopClosure*>(context);\n+  } else {\n+    if (_heap->is_concurrent_mark_in_progress()) {\n+      return &_keep_alive_cl;\n+    } else if (_heap->is_concurrent_weak_root_in_progress()) {\n+      assert(_heap->is_evacuation_in_progress(), \"Nothing to evacuate\");\n+      return &_evac_update_oop_cl;\n+    } else {\n+      ShouldNotReachHere();\n+      return NULL;\n+    }\n+  }\n+}\n+\n+void ShenandoahStackWatermark::start_processing_impl(void* context) {\n+  NoSafepointVerifier nsv;\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+\n+  \/\/ Process the non-frame part of the thread\n+  if (heap->is_concurrent_mark_in_progress()) {\n+    \/\/ We need to reset all TLABs because they might be below the TAMS, and we need to mark\n+    \/\/ the objects in them. Do not let mutators allocate any new objects in their current TLABs.\n+    \/\/ It is also a good place to resize the TLAB sizes for future allocations.\n+    retire_tlab();\n+\n+    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+  } else if (heap->is_concurrent_weak_root_in_progress()) {\n+    assert(heap->is_evacuation_in_progress(), \"Should not be armed\");\n+    \/\/ Retire the TLABs, which will force threads to reacquire their TLABs.\n+    \/\/ This is needed for two reasons. Strong one: new allocations would be with new freeset,\n+    \/\/ which would be outside the collection set, so no cset writes would happen there.\n+    \/\/ Weaker one: new allocations would happen past update watermark, and so less work would\n+    \/\/ be needed for reference updates (would update the large filler instead).\n+    retire_tlab();\n+\n+    _jt->oops_do_no_frames(closure_from_context(context), &_cb_cl);\n+  } else {\n+    ShouldNotReachHere();\n+  }\n+\n+  \/\/ Publishes the processing start to concurrent threads\n+  StackWatermark::start_processing_impl(context);\n+}\n+\n+void ShenandoahStackWatermark::retire_tlab() {\n+  \/\/ Retire TLAB\n+  if (UseTLAB) {\n+    _stats.reset();\n+    _jt->tlab().retire(&_stats);\n+    if (ResizeTLAB) {\n+      _jt->tlab().resize();\n+    }\n+  }\n+}\n+\n+void ShenandoahStackWatermark::process(const frame& fr, RegisterMap& register_map, void* context) {\n+  OopClosure* oops = closure_from_context(context);\n+  assert(oops != NULL, \"Should not get to here\");\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  assert((heap->is_concurrent_weak_root_in_progress() && heap->is_evacuation_in_progress()) ||\n+         heap->is_concurrent_mark_in_progress(),\n+         \"Only these two phases\");\n+  fr.oops_do(oops, &_cb_cl, &register_map, DerivedPointerIterationMode::_directly);\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.cpp","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHSTACKWATERMARK_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHSTACKWATERMARK_HPP\n+\n+#include \"gc\/shared\/barrierSet.hpp\"\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n+#include \"gc\/shenandoah\/shenandoahClosures.hpp\"\n+#include \"memory\/allocation.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/stackWatermark.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class frame;\n+class JavaThread;\n+\n+class ShenandoahOnStackCodeBlobClosure : public CodeBlobClosure {\n+private:\n+  BarrierSetNMethod* _bs_nm;\n+\n+  void do_code_blob(CodeBlob* cb);\n+public:\n+  ShenandoahOnStackCodeBlobClosure();\n+};\n+\n+class ShenandoahStackWatermark : public StackWatermark {\n+private:\n+  static uint32_t                      _epoch_id;\n+  ShenandoahHeap* const                _heap;\n+  ThreadLocalAllocStats                _stats;\n+\n+  \/\/ Closures\n+  ShenandoahKeepAliveClosure           _keep_alive_cl;\n+  ShenandoahEvacuateUpdateRootsClosure _evac_update_oop_cl;\n+  ShenandoahOnStackCodeBlobClosure     _cb_cl;\n+public:\n+  ShenandoahStackWatermark(JavaThread* jt);\n+  ThreadLocalAllocStats& stats();\n+\n+  static void change_epoch_id();\n+private:\n+  OopClosure* closure_from_context(void* context);\n+  uint32_t epoch_id() const;\n+  void start_processing_impl(void* context);\n+  void process(const frame& fr, RegisterMap& register_map, void* context);\n+\n+  void retire_tlab();\n+};\n+\n+#endif \/\/ SHARE_GC_SHENANDOAH_SHENANDOAHSTACKWATERMARK_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahStackWatermark.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -49,0 +49,1 @@\n+  virtual bool skip_thread_oop_barriers() const { return true; }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVMOperations.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}