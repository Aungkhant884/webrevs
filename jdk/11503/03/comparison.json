{"files":[{"patch":"@@ -629,1 +629,1 @@\n-  thread->print_stack();\n+  thread->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-  thr->print_stack();\n+  thr->print_jni_stack();\n@@ -196,1 +196,1 @@\n-      thr->print_stack();\n+      thr->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-    thr->print_stack();\n+    thr->print_jni_stack();\n","filename":"src\/hotspot\/share\/prims\/jniCheck.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1676,0 +1676,10 @@\n+\/\/ Print stack trace for checked JNI warnings and JNI fatal errors.\n+\/\/ This is the external format from above, but selecting the platform\n+\/\/ or vthread as applicable.\n+void JavaThread::print_jni_stack() {\n+  if (is_vthread_mounted()) {\n+    print_vthread_stack_on(tty);\n+  } else {\n+    print_stack_on(tty);\n+  }\n+}\n@@ -1709,0 +1719,42 @@\n+void JavaThread::print_vthread_stack_on(outputStream* st) {\n+  assert(is_vthread_mounted(), \"Caller should have checked this\");\n+  assert(has_last_Java_frame(), \"must be\");\n+\n+  Thread* current_thread = Thread::current();\n+  ResourceMark rm(current_thread);\n+  HandleMark hm(current_thread);\n+\n+  RegisterMap reg_map(this,\n+                      RegisterMap::UpdateMap::include,\n+                      RegisterMap::ProcessFrames::include,\n+                      RegisterMap::WalkContinuation::include);\n+  ContinuationEntry* cont_entry = last_continuation();\n+  vframe* start_vf = last_java_vframe(&reg_map);\n+  int count = 0;\n+  for (vframe* f = start_vf; f != NULL; f = f->sender()) {\n+    \/\/ Watch for end of vthread stack\n+    if (Continuation::is_continuation_enterSpecial(f->fr())) {\n+      assert(cont_entry == Continuation::get_continuation_entry_for_entry_frame(this, f->fr()), \"\");\n+      if (cont_entry->is_virtual_thread()) {\n+        break;\n+      }\n+      cont_entry = cont_entry->parent();\n+    }\n+    if (f->is_java_frame()) {\n+      javaVFrame* jvf = javaVFrame::cast(f);\n+      java_lang_Throwable::print_stack_element(st, jvf->method(), jvf->bci());\n+\n+      \/\/ Print out lock information\n+      if (JavaMonitorsInStackTrace) {\n+        jvf->print_lock_info_on(st, count);\n+      }\n+    } else {\n+      \/\/ Ignore non-Java frames\n+    }\n+\n+    \/\/ Bail-out case for too deep stacks if MaxJavaStackTraceDepth > 0\n+    count++;\n+    if (MaxJavaStackTraceDepth > 0 && MaxJavaStackTraceDepth == count) return;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -943,0 +943,6 @@\n+  void print_vthread_stack_on(outputStream* st);\n+\n+  \/\/ Print stack trace for checked JNI warnings and JNI fatal errors.\n+  \/\/ This is the external format from above, but selecting the platform\n+  \/\/ or vthread as applicable.\n+  void print_jni_stack();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +28,1 @@\n- * @bug 8269697\n+ * @bug 8269697 8292674\n@@ -29,0 +30,1 @@\n+ * @comment Tests reporting with regular thread and virtual thread.\n@@ -30,0 +32,1 @@\n+ * @enablePreview\n@@ -50,1 +53,1 @@\n-            test();\n+            test(args[0]);\n@@ -52,1 +55,2 @@\n-            runTest();\n+            runTest(false);\n+            runTest(true);\n@@ -56,1 +60,1 @@\n-    private static void runTest() {\n+    private static void runTest(boolean useVThread) {\n@@ -60,0 +64,1 @@\n+        pbArgs.add(\"--enable-preview\");\n@@ -62,1 +67,1 @@\n-        pbArgs.add(\"test\");\n+        pbArgs.add(useVThread ? \"vtest\" : \"test\");\n@@ -69,0 +74,1 @@\n+            analyzer.shouldContain(\"TestPrimitiveArrayCriticalWithBadParam.pin\");\n@@ -75,4 +81,19 @@\n-    private static void test() {\n-        Object[] objs = new Object[10];\n-        for (int i = 0; i < objs.length; i++) {\n-            objs[i] = new MyClass();\n+    private static void test(String mode) {\n+        Runnable r = () -> {\n+            Object[] objs = new Object[10];\n+            for (int i = 0; i < objs.length; i++) {\n+                objs[i] = new MyClass();\n+            }\n+            pin(objs);\n+            System.out.println(\"Object array pinned\");\n+            unpin(objs);\n+        };\n+        if (mode.equals(\"vtest\")) {\n+            Thread t = Thread.ofVirtual().start(r);\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                throw new Error(\"unexpected\", ex);\n+            }\n+        } else {\n+            r.run();\n@@ -80,3 +101,0 @@\n-        pin(objs);\n-        System.out.println(\"Object array pinned\");\n-        unpin(objs);\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestPrimitiveArrayCriticalWithBadParam.java","additions":30,"deletions":12,"binary":false,"changes":42,"status":"modified"}]}