{"files":[{"patch":"@@ -123,0 +123,36 @@\n+\/\/ Merge this HdrSeq into hdr2: clear optional and on-by-default\n+\/\/ Note: this method isn't intrinsically MT-safe; callers must take care\n+\/\/ of any mutual exclusion as necessary.\n+void HdrSeq::merge(HdrSeq& hdr2, bool clear_this) {\n+  for (int mag = 0; mag < MagBuckets; mag++) {\n+    if (_hdr[mag] != NULL) {\n+      int* that_bucket = hdr2._hdr[mag];\n+      if (that_bucket == NULL) {\n+        if (clear_this) {\n+          \/\/ the target doesn't have any values, swap in ours.\n+          \/\/ Could this cause native memory fragmentation?\n+          hdr2._hdr[mag] = _hdr[mag];\n+          _hdr[mag] = NULL;\n+        } else {\n+          \/\/ We can't clear this, so we create the entries & add in below\n+          that_bucket = NEW_C_HEAP_ARRAY(int, ValBuckets, mtInternal);\n+          for (int val = 0; val < ValBuckets; val++) {\n+            that_bucket[val] = _hdr[mag][val];\n+          }\n+          hdr2._hdr[mag] = that_bucket;\n+        }\n+      } else {\n+        \/\/ Add in our values into target\n+        for (int val = 0; val < ValBuckets; val++) {\n+          that_bucket[val] += _hdr[mag][val];\n+          if (clear_this) {\n+            _hdr[mag][val] = 0;\n+          }\n+        }\n+      }\n+    }\n+  }\n+  \/\/ Merge up the class hierarchy\n+  NumberSeq::merge(hdr2, clear_this);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -53,0 +53,3 @@\n+\n+  \/\/ Merge this HdrSeq into hdr2, optionally clearing this HdrSeq\n+  void merge(HdrSeq& hdr2, bool clear_this = true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNumberSeq.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -113,0 +113,28 @@\n+\n+void AbsSeq::merge(AbsSeq& abs2, bool clear_this) {\n+\n+  if (num() == 0) return;  \/\/ nothing to do\n+\n+  abs2._num += _num;\n+  abs2._sum += _sum;\n+  abs2._sum_of_squares += _sum_of_squares;\n+\n+  \/\/ Decaying stats need a bit more thought\n+  assert(abs2._alpha == _alpha, \"Caution: merge incompatible?\");\n+\n+  \/\/ Until JDK-... is fixed, we taint the decaying statistics\n+  if (abs2._davg != NAN) {\n+    abs2._davg = NAN;\n+    abs2._dvariance = NAN;\n+  }\n+\n+  if (clear_this) {\n+    _num = 0;\n+    _sum = 0;\n+    _sum_of_squares = 0;\n+    _davg = 0;\n+    _dvariance = 0;\n+  }\n+}\n+\n+\n@@ -140,0 +168,16 @@\n+void NumberSeq::merge(NumberSeq& nseq2, bool clear_this) {\n+\n+  if (num() == 0) return;  \/\/ nothing to do\n+\n+  nseq2._last = _last;   \/\/ this is newer than that\n+  nseq2._maximum = MAX2(_maximum, nseq2._maximum);\n+\n+  AbsSeq::merge(nseq2, clear_this);\n+\n+  if (clear_this) {\n+    _last = 0;\n+    _maximum = 0;\n+    assert(num() == 0, \"Not cleared\");\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.cpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -86,0 +86,3 @@\n+\n+  \/\/ Merge this AbsSeq into seq2, optionally clearing this AbsSeq\n+  void merge(AbsSeq& seq2, bool clear_this = true);\n@@ -105,0 +108,3 @@\n+\n+  \/\/ Merge this NumberSeq into seq2, optionally clearing this NumberSeq\n+  void merge(NumberSeq& seq2, bool clear_this = true);\n@@ -132,0 +138,3 @@\n+\n+  \/\/ Merge this AbsSeq into seq2, optionally clearing this AbsSeq\n+  void merge(AbsSeq& seq2, bool clear_this = true);\n","filename":"src\/hotspot\/share\/utilities\/numberSeq.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Amazon.com Inc. or its affiliates. All Rights Reserved.\n@@ -37,1 +36,25 @@\n-  HdrSeq seq;\n+  const double err = 0.5;\n+\n+  HdrSeq seq1;\n+  HdrSeq seq2;\n+  HdrSeq seq3;\n+\n+  void print() {\n+    if (seq1.num() > 0) {\n+      print(seq1, \"seq1\");\n+    }\n+    if (seq2.num() > 0) {\n+      print(seq2, \"seq2\");\n+    }\n+    if (seq3.num() > 0) {\n+      print(seq3, \"seq3\");\n+    }\n+  }\n+\n+  void print(HdrSeq& seq, const char* msg) {\n+    std::cout << \"[\";\n+    for (int i = 0; i <= 100; i += 10) {\n+      std::cout << \"\\t\" << seq.percentile(i);\n+    }\n+    std::cout << \" ] : \" << msg << \"\\n\";\n+  }\n@@ -41,2 +64,1 @@\n- protected:\n-  const double err = 0.5;\n+ public:\n@@ -44,3 +66,3 @@\n-    seq.add(0);\n-    seq.add(1);\n-    seq.add(10);\n+    seq1.add(0);\n+    seq1.add(1);\n+    seq1.add(10);\n@@ -48,1 +70,1 @@\n-      seq.add(100);\n+      seq1.add(100);\n@@ -50,8 +72,17 @@\n-    std::cout << \" p0 = \" << seq.percentile(0);\n-    std::cout << \" p10 = \" << seq.percentile(10);\n-    std::cout << \" p20 = \" << seq.percentile(20);\n-    std::cout << \" p30 = \" << seq.percentile(30);\n-    std::cout << \" p50 = \" << seq.percentile(50);\n-    std::cout << \" p80 = \" << seq.percentile(80);\n-    std::cout << \" p90 = \" << seq.percentile(90);\n-    std::cout << \" p100 = \" << seq.percentile(100);\n+    ShenandoahNumberSeqTest::print();\n+  }\n+};\n+\n+class ShenandoahNumberSeqMergeTest: public ShenandoahNumberSeqTest {\n+ public:\n+  ShenandoahNumberSeqMergeTest() {\n+    for (int i = 0; i < 80; i++) {\n+      seq1.add(1);\n+      seq3.add(1);\n+    }\n+\n+    for (int i = 0; i < 20; i++) {\n+      seq2.add(100);\n+      seq3.add(100);\n+    }\n+    ShenandoahNumberSeqTest::print();\n@@ -62,1 +93,1 @@\n-  EXPECT_EQ(seq.maximum(), 100);\n+  EXPECT_EQ(seq1.maximum(), 100);\n@@ -66,1 +97,1 @@\n-  EXPECT_EQ(0, seq.percentile(0));\n+  EXPECT_EQ(0, seq1.percentile(0));\n@@ -70,8 +101,36 @@\n-  EXPECT_NEAR(0, seq.percentile(10), err);\n-  EXPECT_NEAR(1, seq.percentile(20), err);\n-  EXPECT_NEAR(10, seq.percentile(30), err);\n-  EXPECT_NEAR(100, seq.percentile(40), err);\n-  EXPECT_NEAR(100, seq.percentile(50), err);\n-  EXPECT_NEAR(100, seq.percentile(75), err);\n-  EXPECT_NEAR(100, seq.percentile(90), err);\n-  EXPECT_NEAR(100, seq.percentile(100), err);\n+  EXPECT_NEAR(0, seq1.percentile(10), err);\n+  EXPECT_NEAR(1, seq1.percentile(20), err);\n+  EXPECT_NEAR(10, seq1.percentile(30), err);\n+  EXPECT_NEAR(100, seq1.percentile(40), err);\n+  EXPECT_NEAR(100, seq1.percentile(50), err);\n+  EXPECT_NEAR(100, seq1.percentile(75), err);\n+  EXPECT_NEAR(100, seq1.percentile(90), err);\n+  EXPECT_NEAR(100, seq1.percentile(100), err);\n+}\n+\n+TEST_VM_F(ShenandoahNumberSeqMergeTest, merge_test) {\n+  EXPECT_EQ(seq1.num(), 80);\n+  EXPECT_EQ(seq2.num(), 20);\n+  EXPECT_FALSE(isnan(seq2.davg()));  \/\/ Exercise the path; not a nan\n+  EXPECT_FALSE(isnan(seq2.dsd()));\n+  EXPECT_FALSE(isnan(seq2.dvariance()));\n+\n+  std::cout << \"Pre-merge: \\n\";\n+  print();\n+  seq1.merge(seq2);    \/\/ clears seq1, after merging into seq2\n+  std::cout << \"Post-merge: \\n\";\n+  print();\n+\n+  EXPECT_EQ(seq1.num(), 0);\n+  EXPECT_EQ(seq2.num(), 100);\n+  EXPECT_EQ(seq2.num(), seq3.num());\n+  EXPECT_TRUE(isnan(seq2.davg()));  \/\/ until we fix decayed stats\n+  EXPECT_TRUE(isnan(seq2.dvariance()));\n+\n+  EXPECT_EQ(seq2.maximum(), seq3.maximum());\n+  EXPECT_EQ(seq2.percentile(0), seq3.percentile(0));\n+  for (int i = 0; i <= 100; i += 10) {\n+    EXPECT_NEAR(seq2.percentile(i), seq3.percentile(i), err);\n+  }\n+  EXPECT_NEAR(seq2.avg(), seq3.avg(), err);\n+  EXPECT_NEAR(seq2.sd(),  seq3.sd(),  err);\n","filename":"test\/hotspot\/gtest\/gc\/shenandoah\/test_shenandoahNumberSeq.cpp","additions":86,"deletions":27,"binary":false,"changes":113,"status":"modified"}]}