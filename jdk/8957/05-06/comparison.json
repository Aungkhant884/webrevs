{"files":[{"patch":"@@ -82,13 +82,0 @@\n-void G1BlockOffsetTablePart::update() {\n-  HeapWord* next_addr = _hr->bottom();\n-  HeapWord* const limit = _hr->top();\n-\n-  HeapWord* prev_addr;\n-  while (next_addr < limit) {\n-    prev_addr = next_addr;\n-    next_addr  = prev_addr + block_size(prev_addr, _hr->parsable_bottom());\n-    update_for_block(prev_addr, next_addr);\n-  }\n-  assert(next_addr == limit, \"Should stop the scan at the limit.\");\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -158,2 +158,0 @@\n-  void update();\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -988,1 +988,1 @@\n-void G1CollectedHeap::abort_concurrent_cycle() {\n+bool G1CollectedHeap::abort_concurrent_cycle() {\n@@ -1005,1 +1005,1 @@\n-  concurrent_mark()->concurrent_cycle_abort();\n+  return concurrent_mark()->concurrent_cycle_abort();\n@@ -2411,1 +2411,1 @@\n-    default:                            ShouldNotReachHere();\n+    default:                             ShouldNotReachHere();\n@@ -2421,1 +2421,1 @@\n-    default:                            ShouldNotReachHere();\n+    default:                             ShouldNotReachHere();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -511,1 +511,1 @@\n-  void abort_concurrent_cycle();\n+  bool abort_concurrent_cycle();\n@@ -1237,1 +1237,1 @@\n-  bool is_marked_next(oop obj) const;\n+  bool is_marked(oop obj) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-inline bool G1CollectedHeap::is_marked_next(oop obj) const {\n+inline bool G1CollectedHeap::is_marked(oop obj) const {\n@@ -235,1 +235,1 @@\n-   return !is_marked_next(obj) && !hr->is_closed_archive();\n+   return !is_marked(obj) && !hr->is_closed_archive();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -629,0 +629,5 @@\n+      \/\/ When calling this concurrent to the application, pb must already be reset, so\n+      \/\/ resetting it again does not hurt. At a safepoint, when we clear the bitmap,\n+      \/\/ we must reset pb to be consistent with the (then cleared) marks.\n+      r->reset_parsable_bottom();\n+\n@@ -1105,1 +1110,1 @@\n-      size_t const obj_size_in_words = (size_t)cast_to_oop(hr->bottom())->size();\n+      size_t const obj_size_in_words = cast_to_oop(hr->bottom())->size();\n@@ -1238,1 +1243,0 @@\n-    _g1h->collector_state()->set_clearing_bitmap(true);\n@@ -1330,1 +1334,1 @@\n-      if (hr->used() > 0 && hr->max_live_bytes() == 0 && !hr->is_young() && !hr->is_closed_archive()) {\n+      if (hr->used() > 0 && hr->live_bytes() == 0 && !hr->is_young() && !hr->is_closed_archive()) {\n@@ -1440,0 +1444,1 @@\n+  _g1h->collector_state()->set_clearing_bitmap(true);\n@@ -1776,1 +1781,2 @@\n-        JavaThread::cast(thread)->nmethods_do(&_code_cl);\n+        \/\/JavaThread::cast(thread)->nmethods_do(&_code_cl);\n+        JavaThread::cast(thread)->oops_do_frames(&_cm_cl, &_code_cl);\n@@ -1998,1 +2004,1 @@\n-void G1ConcurrentMark::concurrent_cycle_abort() {\n+bool G1ConcurrentMark::concurrent_cycle_abort() {\n@@ -2009,8 +2015,1 @@\n-    return;\n-  }\n-\n-  \/\/ Clear all marks in the next bitmap for this full gc as it has been used by the\n-  \/\/ marking that is interrupted by this full gc.\n-  {\n-    GCTraceTime(Debug, gc) debug(\"Clear Next Bitmap\");\n-    clear_bitmap(_g1h->workers());\n+    return false;\n@@ -2034,0 +2033,1 @@\n+  return true;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -494,2 +494,3 @@\n-  \/\/ Abandon current marking iteration due to a Full GC.\n-  void concurrent_cycle_abort();\n+  \/\/ Abandon current marking iteration due to a Full GC. Returns true if we had to\n+  \/\/ actually abort the concurrent cycle.\n+  bool concurrent_cycle_abort();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-  return _g1h->is_marked_next(obj);\n+  return _g1h->is_marked(obj);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -232,2 +232,2 @@\n-      log_debug(gc, marking)(\"Scrub and rebuild region: \" HR_FORMAT \" pb: \" PTR_FORMAT,\n-                             HR_FORMAT_PARAMS(hr), p2i(pb));\n+      log_trace(gc, marking)(\"Scrub and rebuild region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT,\n+                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())));\n@@ -274,2 +274,2 @@\n-      log_debug(gc, marking)(\"Rebuild for humongous region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT,\n-                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())));\n+      log_trace(gc, marking)(\"Rebuild for humongous region: \" HR_FORMAT \" pb: \" PTR_FORMAT \" TARS: \" PTR_FORMAT,\n+                              HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr->hrm_index())));\n@@ -358,1 +358,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -172,2 +172,0 @@\n-  _heap->verify_before_full_collection(scope()->is_explicit_gc());\n-\n@@ -176,1 +174,19 @@\n-  _heap->abort_concurrent_cycle();\n+  bool aborted = _heap->abort_concurrent_cycle();\n+  \/\/ Verification needs the marks\/parsable_bottom (pb) values intact, so only clear\n+  \/\/ the bitmap after verification if required.\n+  \/\/ If we abort during marking, since pb is at bottom, verification won't use the\n+  \/\/ marks below tams. This is fine because the heap is still parsable (only filler\n+  \/\/ objects are dead then).\n+  \/\/ During remset rebuild and scrubbing we need to use the marks and pb to find\n+  \/\/ dead objects and parse the heap as we unloaded classes earlier.\n+  \/\/ After remset rebuild, the situation is mostly the same as during marking: pb\n+  \/\/ is at bottom of the regions and the heap is parsable. We may have extra marks\n+  \/\/ above tams (as it has been reset to bottom earlier) though. In that case we\n+  \/\/ simply do not check the marks above tams.\n+  _heap->verify_before_full_collection(scope()->is_explicit_gc());\n+  if (aborted) {\n+    \/\/ Clear all marks in the next bitmap for this full gc as it has been in use\n+    \/\/ by the concurrent cycle that is interrupted by this full gc.\n+    GCTraceTime(Debug, gc) debug(\"Clear Bitmap\");\n+    _heap->concurrent_mark()->clear_bitmap(_heap->workers());\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-        size_t obj_size = o->size();    \/\/ Make sure we don't overflow\n+        size_t obj_size = o->size();\n@@ -402,1 +402,1 @@\n-        if (r->max_live_bytes() < not_dead_yet_cl.live_bytes()) {\n+        if (r->live_bytes() < not_dead_yet_cl.live_bytes()) {\n@@ -404,1 +404,1 @@\n-                                HR_FORMAT_PARAMS(r), r->max_live_bytes(), not_dead_yet_cl.live_bytes());\n+                                HR_FORMAT_PARAMS(r), r->live_bytes(), not_dead_yet_cl.live_bytes());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -919,1 +919,1 @@\n-    bytes_to_copy = hr->max_live_bytes();\n+    bytes_to_copy = hr->live_bytes();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  return !requires_marking(entry, g1h) || g1h->is_marked_next(cast_to_oop(entry));\n+  return !requires_marking(entry, g1h) || g1h->is_marked(cast_to_oop(entry));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -280,0 +280,1 @@\n+  _garbage_bytes = 0;\n@@ -282,3 +283,2 @@\n-    \/\/ During concurrent start, we'll also explicitly mark all objects\n-    \/\/ we find to be self-forwarded in the marking bitmap. So all\n-    \/\/ objects need to be below TAMS.\n+    \/\/ Self-forwarding marks all objects. Adjust TAMS so that these marks are\n+    \/\/ below it.\n@@ -286,5 +286,5 @@\n-  } else if (during_conc_mark) {\n-    \/\/ During concurrent mark, all objects in the CSet (including\n-    \/\/ the ones we find to be self-forwarded) are implicitly live.\n-    \/\/ So all objects need to be above TAMS.\n-    _top_at_mark_start = bottom();\n+  } else {\n+    \/\/ Outside of the mixed phase all regions that had an evacuation failure must\n+    \/\/ be young regions, and their TAMS is always bottom. Similarly, before the\n+    \/\/ start of the mixed phase, we scrubbed and reset TAMS to bottom.\n+    assert(_top_at_mark_start == bottom(), \"must be\");\n@@ -298,0 +298,1 @@\n+  _garbage_bytes = used() - marked_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -147,0 +147,2 @@\n+  static bool obj_is_filler(oop obj);\n+\n@@ -183,2 +185,0 @@\n-  bool obj_is_scrubbed(oop obj) const;\n-\n@@ -188,3 +188,0 @@\n-  \/\/ Same as is_obj_dead(), but only for obj's in the unparsable area and also\n-  \/\/ returning the block size.\n-  bool is_obj_dead_size_in_unparsable(oop obj, HeapWord* pb, G1CMBitMap* bitmap, size_t& block_size) const;\n@@ -203,3 +200,3 @@\n-  void update_bot() {\n-    _bot_part.update();\n-  }\n+  \/\/ Update the BOT for the entire region - assumes that all objects are parsable\n+  \/\/ and contiguous for this region.\n+  void update_bot();\n@@ -343,0 +340,1 @@\n+  \/\/ An upper bound on the number of live bytes in the region.\n@@ -344,1 +342,1 @@\n-    return byte_size(bottom(), top()) - garbage_bytes();\n+    return used() - garbage_bytes();\n@@ -360,3 +358,0 @@\n-  \/\/ An upper bound on the number of live bytes in the region.\n-  size_t max_live_bytes() const { return used() - garbage_bytes(); }\n-\n@@ -370,0 +365,1 @@\n+  void reset_parsable_bottom();\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":8,"deletions":12,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-inline bool HeapRegion::obj_is_scrubbed(const oop obj) const {\n+inline bool HeapRegion::obj_is_filler(const oop obj) {\n@@ -139,16 +139,1 @@\n-  return obj_is_scrubbed(obj);\n-}\n-\n-inline bool HeapRegion::is_obj_dead_size_in_unparsable(const oop obj, HeapWord* const pb, G1CMBitMap* bitmap, size_t& block_size) const {\n-  assert(is_in_reserved(obj), \"Object \" PTR_FORMAT \" must be in region\", p2i(obj));\n-  assert(!is_closed_archive(), \"never walk CA regions for cross-references\");\n-  assert(obj_in_unparsable_area(obj, pb), \"must be\");\n-\n-  bool is_live = bitmap->is_marked(obj);\n-  if (is_live) {\n-    block_size = obj->size();\n-  } else {\n-    HeapWord* addr = cast_from_oop<HeapWord*>(obj);\n-    block_size = pointer_delta(next_live_in_unparsable(bitmap, addr, pb), addr);\n-  }\n-  return !is_live;\n+  return obj_is_filler(obj);\n@@ -204,0 +189,2 @@\n+  _garbage_bytes = 0;\n+\n@@ -257,0 +244,12 @@\n+inline void HeapRegion::update_bot() {\n+  HeapWord* next_addr = bottom();\n+\n+  HeapWord* prev_addr;\n+  while (next_addr < top()) {\n+    prev_addr = next_addr;\n+    next_addr  = prev_addr + cast_to_oop(prev_addr)->size();\n+    update_bot_for_block(prev_addr, next_addr);\n+  }\n+  assert(next_addr == top(), \"Should stop the scan at the limit.\");\n+}\n+\n@@ -279,0 +278,4 @@\n+inline void HeapRegion::reset_parsable_bottom() {\n+  Atomic::release_store(&_parsable_bottom, bottom());\n+}\n+\n@@ -290,4 +293,0 @@\n-  size_t new_garbage_bytes = byte_size(bottom(), _top_at_mark_start) - marked_bytes;\n-  assert(new_garbage_bytes >= _garbage_bytes, \"impossible\");\n-  _garbage_bytes = new_garbage_bytes;\n-\n@@ -295,0 +294,1 @@\n+  _garbage_bytes = byte_size(bottom(), _top_at_mark_start) - _marked_bytes;\n@@ -307,1 +307,1 @@\n-  Atomic::release_store(&_parsable_bottom, _bottom);\n+  reset_parsable_bottom();\n@@ -369,0 +369,1 @@\n+  G1CMBitMap* bitmap = G1CollectedHeap::heap()->concurrent_mark()->mark_bitmap();\n@@ -387,2 +388,1 @@\n-  G1CMBitMap* bitmap = G1CollectedHeap::heap()->concurrent_mark()->mark_bitmap();\n-  if (!in_gc_pause) {\n+  if (!bitmap->is_marked(cur)) {\n@@ -390,4 +390,0 @@\n-    \/\/ We might not have found a live object in the range to process. Return in that case.\n-    if (cur == end) {\n-      return end;\n-    }\n@@ -396,1 +392,3 @@\n-  while (true) {\n+  while (cur != end) {\n+    assert(bitmap->is_marked(cur), \"must be\");\n+\n@@ -400,2 +398,1 @@\n-    size_t block_size;\n-    bool is_dead = is_obj_dead_size_in_unparsable(obj, pb, bitmap, block_size);\n+    cur += obj->size();\n@@ -404,14 +401,5 @@\n-    cur += block_size;\n-    if (!is_dead) {\n-      \/\/ Process live object's references.\n-\n-      \/\/ Non-objArrays are usually marked imprecise at the object\n-      \/\/ start, in which case we need to iterate over them in full.\n-      \/\/ objArrays are precisely marked, but can still be iterated\n-      \/\/ over in full if completely covered.\n-      if (!obj->is_objArray() || (cast_from_oop<HeapWord*>(obj) >= start && cur <= end)) {\n-        obj->oop_iterate(cl);\n-      } else {\n-        obj->oop_iterate(cl, mr);\n-        is_precise = true;\n-      }\n+    if (!obj->is_objArray() || (cast_from_oop<HeapWord*>(obj) >= start && cur <= end)) {\n+      obj->oop_iterate(cl);\n+    } else {\n+      obj->oop_iterate(cl, mr);\n+      is_precise = true;\n@@ -419,0 +407,1 @@\n+\n@@ -422,0 +411,2 @@\n+\n+    cur = bitmap->get_next_marked_addr(cur, end);\n@@ -423,0 +414,1 @@\n+  return end;\n@@ -430,0 +422,3 @@\n+\/\/ Otherwise we would need to check for every object what the current location is;\n+\/\/ we expect that the amount of GCs executed during scrubbing is very low so such\n+\/\/ tests would be unnecessary almost all the time.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":40,"deletions":45,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -38,1 +38,4 @@\n-  G1UseFullMarking = G1UseConcMarking + 1\n+  G1UseFullMarking = G1UseConcMarking + 1,\n+  \/\/ Do not use mark bitmap for liveness at all as it may be invalid; assumes\n+  \/\/ that all objects are parsable.\n+  G1UseNoBitmap = G1UseConcMarking + 2\n","filename":"src\/hotspot\/share\/gc\/shared\/verifyOption.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"}]}