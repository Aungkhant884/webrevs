{"files":[{"patch":"@@ -110,1 +110,1 @@\n-    bool should_rebuild_or_scrub(HeapRegion* hr) {\n+    bool should_rebuild_or_scrub(HeapRegion* hr) const {\n@@ -173,5 +173,1 @@\n-      if (scrub_start != scrub_end) {\n-        \/\/ Only scrub if range is non-empty.\n-        hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-        assert(hr->obj_is_scrubbed(cast_to_oop(scrub_start)), \"Scrubbing failed\");\n-      }\n+      assert(scrub_start != scrub_end, \"must advance\");\n@@ -179,5 +175,1 @@\n-      \/\/ At this point make sure we are either at the scrubbing limit or that the next\n-      \/\/ object is live. Need to compare to the limit first to not accidentally query the\n-      \/\/ bitmap outside the committed heap.\n-      assert(scrub_end == limit || _bitmap->is_marked(scrub_end),\n-             \"We should either step to the next live object or the limit\");\n+      hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n@@ -195,1 +187,0 @@\n-          assert(!cast_to_oop(start)->is_gc_marked(), \"No live objects in G1 should be GC marked\");\n@@ -282,2 +273,3 @@\n-        \/\/ and the object should still be handled. The should handle state can change during\n-        \/\/ rebuild for humongous objects that are eagerly reclaimed so we need to check this.\n+        \/\/ and the object should still be handled. The should_rebuild_or_scrub() state can\n+        \/\/ change during rebuild for humongous objects that are eagerly reclaimed so we need to\n+        \/\/ check this.\n@@ -331,1 +323,1 @@\n-  G1RebuildRSAndScrubTask(G1ConcurrentMark* cm, bool should_rebuild, uint num_workers) :\n+  G1RebuildRSAndScrubTask(G1ConcurrentMark* cm, uint num_workers) :\n@@ -348,1 +340,1 @@\n-  G1RebuildRSAndScrubTask task(cm, true, num_workers);\n+  G1RebuildRSAndScrubTask task(cm, num_workers);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -187,3 +187,2 @@\n-    if (scrub_start != scrub_end) {\n-      hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n-    }\n+    assert(scrub_start != scrub_end, \"must advance\");\n+    hr->fill_range_with_dead_objects(scrub_start, scrub_end);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -809,15 +809,14 @@\n-  if (range_size >= CollectedHeap::min_fill_size()) {\n-    \/\/ Fill the dead range with objects. G1 might need to create two objects if\n-    \/\/ the range is larger than half a region, which is the max_fill_size().\n-    CollectedHeap::fill_with_objects(start, range_size);\n-    HeapWord* current = start;\n-    do {\n-      \/\/ Update the BOT if the a threshold is crossed.\n-      size_t obj_size = cast_to_oop(current)->size();\n-      update_bot_for_block(current, current + obj_size);\n-\n-      \/\/ Advance to the next object.\n-      current += obj_size;\n-      guarantee(current <= end, \"Should never go past end\");\n-    } while (current != end);\n-  }\n+\n+  \/\/ Fill the dead range with objects. G1 might need to create two objects if\n+  \/\/ the range is larger than half a region, which is the max_fill_size().\n+  CollectedHeap::fill_with_objects(start, range_size);\n+  HeapWord* current = start;\n+  do {\n+    \/\/ Update the BOT if the a threshold is crossed.\n+    size_t obj_size = cast_to_oop(current)->size();\n+    update_bot_for_block(current, current + obj_size);\n+\n+    \/\/ Advance to the next object.\n+    current += obj_size;\n+    guarantee(current <= end, \"Should never go past end\");\n+  } while (current != end);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-static idx_t compute_search_fwd_expected(idx_t search_start,\n+static idx_t compute_expected(idx_t search_start,\n@@ -111,4 +111,4 @@\n-static void test_search_fwd_ranges(BitMap& test_ones,\n-                                   BitMap& test_zeros,\n-                                   idx_t left,\n-                                   idx_t right) {\n+static void test_search_ranges(BitMap& test_ones,\n+                               BitMap& test_zeros,\n+                               idx_t left,\n+                               idx_t right) {\n@@ -171,1 +171,1 @@\n-          idx_t expected = compute_search_fwd_expected(start, end, left, right);\n+          idx_t expected = compute_expected(start, end, left, right);\n@@ -182,1 +182,1 @@\n-          idx_t expected2 = compute_search_fwd_expected(start2, end, left, right);\n+          idx_t expected2 = compute_expected(start2, end, left, right);\n@@ -197,1 +197,1 @@\n-TEST(BitMap, search_fwd) {\n+TEST(BitMap, search) {\n@@ -241,1 +241,1 @@\n-          test_search_fwd_ranges(test_ones, test_zeros, left, right);\n+          test_search_ranges(test_ones, test_zeros, left, right);\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_search.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"}]}