{"files":[{"patch":"@@ -1028,1 +1028,1 @@\n-  _verifier->verify_bitmap_clear(false \/* above_tams_only *\/);\n+  _verifier->verify_bitmap_clear(true \/* above_tams_only *\/);\n@@ -2961,2 +2961,1 @@\n-  MemRegion mr(hr->bottom(), hr->end());\n-  concurrent_mark()->clear_range_in_bitmap(mr);\n+  concurrent_mark()->clear_bitmap_for_region(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -630,7 +630,0 @@\n-      \/\/ When calling this concurrent to the application, pb must already be reset, so\n-      \/\/ resetting it again does not hurt. At a safepoint, when we clear the bitmap,\n-      \/\/ we must reset pb to be consistent with the (then cleared) marks.\n-      assert(!_suspendible || r->parsable_bottom_acquire() == r->bottom(),\n-             \"While concurrently clearing the bitmap, parsable bottom must already be reset.\");\n-      r->reset_parsable_bottom();\n-\n@@ -663,0 +656,2 @@\n+      r->note_end_of_clearing();\n+\n@@ -1884,1 +1879,1 @@\n-void G1ConcurrentMark::clear_range_in_bitmap(MemRegion mr) {\n+void G1ConcurrentMark::clear_bitmap_for_region(HeapRegion* hr) {\n@@ -1886,1 +1881,2 @@\n-  _mark_bitmap.clear_range(mr);\n+  _mark_bitmap.clear_range(MemRegion(hr->bottom(), hr->end()));\n+  hr->note_end_of_clearing();\n@@ -1889,2 +1885,1 @@\n-HeapRegion*\n-G1ConcurrentMark::claim_region(uint worker_id) {\n+HeapRegion* G1ConcurrentMark::claim_region(uint worker_id) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -578,1 +578,1 @@\n-  \/\/ Clears marks for all objects in the given range in the marking\n+  \/\/ Clears marks for all objects in the given region in the marking\n@@ -581,1 +581,1 @@\n-  void clear_range_in_bitmap(MemRegion mr);\n+  void clear_bitmap_for_region(HeapRegion* hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -285,1 +285,1 @@\n-    _top_at_mark_start = top();\n+    set_top_at_mark_start(top());\n@@ -290,1 +290,1 @@\n-    assert(_top_at_mark_start == bottom(), \"must be\");\n+    assert(top_at_mark_start() == bottom(), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -233,1 +233,1 @@\n-  HeapWord* _top_at_mark_start;\n+  HeapWord* volatile _top_at_mark_start;\n@@ -250,1 +250,1 @@\n-    _top_at_mark_start = bottom();\n+    set_top_at_mark_start(bottom());\n@@ -359,1 +359,2 @@\n-  HeapWord* top_at_mark_start() const { return _top_at_mark_start; }\n+  HeapWord* top_at_mark_start() const;\n+  void set_top_at_mark_start(HeapWord* value);\n@@ -382,0 +383,3 @@\n+  \/\/ Notify the region that the (corresponding) bitmap has been cleared.\n+  inline void note_end_of_clearing();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -192,1 +192,1 @@\n-  _top_at_mark_start = bottom();\n+  set_top_at_mark_start(bottom());\n@@ -270,0 +270,8 @@\n+inline HeapWord* HeapRegion::top_at_mark_start() const {\n+  return Atomic::load(&_top_at_mark_start);\n+}\n+\n+inline void HeapRegion::set_top_at_mark_start(HeapWord* value) {\n+  Atomic::store(&_top_at_mark_start, value);\n+}\n+\n@@ -286,1 +294,1 @@\n-    _top_at_mark_start = top();\n+    set_top_at_mark_start(top());\n@@ -295,1 +303,1 @@\n-  _garbage_bytes = byte_size(bottom(), _top_at_mark_start) - _marked_bytes;\n+  _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - _marked_bytes;\n@@ -298,1 +306,1 @@\n-    _parsable_bottom = _top_at_mark_start;\n+    _parsable_bottom = top_at_mark_start();\n@@ -300,1 +308,0 @@\n-  _top_at_mark_start = bottom();\n@@ -307,0 +314,11 @@\n+inline void HeapRegion::note_end_of_clearing() {\n+  \/\/ We do not need a release store here because\n+  \/\/\n+  \/\/ - if this method is called during concurrent bitmap clearing, we do not read\n+  \/\/ the bitmap any more for live\/dead information (we do not read the bitmap at\n+  \/\/ all at that point).\n+  \/\/ - otherwise we reclaim regions only during GC and we do not read tams and the\n+  \/\/ bitmap concurrently.\n+  set_top_at_mark_start(bottom());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"}]}