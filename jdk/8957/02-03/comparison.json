{"files":[{"patch":"@@ -82,1 +82,1 @@\n-void G1BlockOffsetTablePart::update(HeapWord* const pb) {\n+void G1BlockOffsetTablePart::update() {\n@@ -89,1 +89,1 @@\n-    next_addr  = prev_addr + block_size(prev_addr, pb);\n+    next_addr  = prev_addr + block_size(prev_addr, _hr->parsable_bottom());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  \/\/ \"pb\" is the current value of the region's parsable_bottom.\n@@ -157,1 +158,1 @@\n-  void update(HeapWord* pb);\n+  void update();\n@@ -166,0 +167,1 @@\n+  \/\/ \"pb\" is the current value of the region's parsable_bottom.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,4 +48,4 @@\n-\/\/ parsable_bottom: this is the TAMS of the recent marking for that region. Objects\n-\/\/                  below that may or may not be dead (as per mark bitmap).\n-\/\/                  This task needs to remove the dead objects, replacing them\n-\/\/                  with filler objects so that they can be walked through later.\n+\/\/ parsable_bottom (pb): this is the TAMS of the recent marking for that region. Objects\n+\/\/                       below that may or may not be dead (as per mark bitmap).\n+\/\/                       This task needs to remove the dead objects, replacing them\n+\/\/                       with filler objects so that they can be walked through later.\n@@ -173,2 +173,0 @@\n-      assert(scrub_start != scrub_end, \"must advance\");\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -78,7 +78,2 @@\n-  if (!obj->is_forwarded()) {\n-    \/\/ Object not moving, but clear the mark to allow reuse of the bitmap.\n-    clear_in_bitmap(obj);\n-    return size;\n-  }\n-\n-  HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n+  if (obj->is_forwarded()) {\n+    HeapWord* destination = cast_from_oop<HeapWord*>(obj->forwardee());\n@@ -86,4 +81,4 @@\n-  \/\/ copy object and reinit its mark\n-  HeapWord* obj_addr = cast_from_oop<HeapWord*>(obj);\n-  assert(obj_addr != destination, \"everything in this pass should be moving\");\n-  Copy::aligned_conjoint_words(obj_addr, destination, size);\n+    \/\/ copy object and reinit its mark\n+    HeapWord* obj_addr = cast_from_oop<HeapWord*>(obj);\n+    assert(obj_addr != destination, \"everything in this pass should be moving\");\n+    Copy::aligned_conjoint_words(obj_addr, destination, size);\n@@ -91,3 +86,4 @@\n-  \/\/ There is no need to transform stack chunks - marking already did that.\n-  cast_to_oop(destination)->init_mark();\n-  assert(cast_to_oop(destination)->klass() != NULL, \"should have a class\");\n+    \/\/ There is no need to transform stack chunks - marking already did that.\n+    cast_to_oop(destination)->init_mark();\n+    assert(cast_to_oop(destination)->klass() != NULL, \"should have a class\");\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":10,"deletions":14,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -134,11 +134,2 @@\n-    if (hr->is_young()) {\n-      \/\/ G1 updates the BOT for old region contents incrementally, but young regions\n-      \/\/ lack BOT information for performance reasons.\n-      \/\/ Recreate BOT information of high live ratio young regions here to keep expected\n-      \/\/ performance during scanning their card tables in the collection pauses later.\n-      hr->update_bot();\n-    }\n-\n-    if (_collector->is_skip_compacting(region_idx) &&\n-        hr->needs_scrubbing_during_full_gc()) {\n-      scrub_skip_compacting_region(hr);\n+    if (hr->needs_scrubbing_during_full_gc()) {\n+      scrub_skip_compacting_region(hr, hr->is_young());\n@@ -170,1 +161,1 @@\n-void G1FullGCPrepareTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr) {\n+void G1FullGCPrepareTask::G1ResetMetadataClosure::scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live) {\n@@ -180,1 +171,5 @@\n-      current_obj += current->size();\n+      size_t size = current->size();\n+      if (update_bot_for_live) {\n+        hr->update_bot_for_block(current_obj, current_obj + size);\n+      }\n+      current_obj += size;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -98,1 +98,4 @@\n-    void scrub_skip_compacting_region(HeapRegion* hr);\n+    \/\/ Scrub all runs of dead objects within the given region by putting filler\n+    \/\/ objects and updating the corresponding BOT. If update_bot_for_live is true,\n+    \/\/ also update the BOT for live objects.\n+    void scrub_skip_compacting_region(HeapRegion* hr, bool update_bot_for_live);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -227,1 +227,1 @@\n-      if (_hr->obj_in_scrubbing_area(o, _hr->parsable_bottom())) {\n+      if (_hr->obj_in_unparsable_area(o, _hr->parsable_bottom())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-  \/\/ All allocated blocks are occupied by objects in a HeapRegion\n+  \/\/ All allocated blocks are occupied by objects in a HeapRegion.\n@@ -185,2 +185,2 @@\n-  \/\/ Returns whether the given object is dead based on TAMS and mark word.\n-  \/\/ For an object to be considered dead it must be below TAMS and scrubbed.\n+  \/\/ Returns whether the given object is dead based on the given parsable_bottom (pb).\n+  \/\/ For an object to be considered dead it must be below pb and scrubbed.\n@@ -190,2 +190,3 @@\n-  \/\/ Returns the object size for all valid block starts\n-  \/\/ and the amount of unallocated words if called on top()\n+  \/\/ Returns the object size for all valid block starts. If parsable_bottom (pb)\n+  \/\/ is given, calculates the block size based on that parsable_bottom, not the\n+  \/\/ current value of this HeapRegion.\n@@ -201,1 +202,1 @@\n-    _bot_part.update(parsable_bottom());\n+    _bot_part.update();\n@@ -384,1 +385,1 @@\n-  \/\/ classes in this region?\n+  \/\/ classes or dead objects in this region?\n@@ -552,2 +553,2 @@\n-  inline bool obj_in_parsable_area(const HeapWord* addr, HeapWord* pb) const;\n-  inline bool obj_in_scrubbing_area(oop obj, HeapWord* pb) const;\n+  inline static bool obj_in_parsable_area(const HeapWord* addr, HeapWord* pb);\n+  inline static bool obj_in_unparsable_area(oop obj, HeapWord* pb);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-inline bool HeapRegion::obj_in_scrubbing_area(oop obj, HeapWord* const pb) const {\n-  return !obj_in_parsable_area(cast_from_oop<HeapWord*>(obj), pb);\n+inline bool HeapRegion::obj_in_unparsable_area(oop obj, HeapWord* const pb) {\n+  return !HeapRegion::obj_in_parsable_area(cast_from_oop<HeapWord*>(obj), pb);\n@@ -92,1 +92,1 @@\n-inline bool HeapRegion::obj_in_parsable_area(const HeapWord* addr, HeapWord* const pb) const {\n+inline bool HeapRegion::obj_in_parsable_area(const HeapWord* addr, HeapWord* const pb) {\n@@ -134,1 +134,1 @@\n-  if (obj_in_scrubbing_area(obj, pb)) {\n+  if (obj_in_unparsable_area(obj, pb)) {\n@@ -145,1 +145,1 @@\n-  assert(obj_in_scrubbing_area(obj, pb), \"must be\");\n+  assert(obj_in_unparsable_area(obj, pb), \"must be\");\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"}]}