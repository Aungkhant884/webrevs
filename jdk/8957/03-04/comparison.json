{"files":[{"patch":"@@ -105,2 +105,5 @@\n-    \/\/ Checks the top at rebuild start value for the given region. If the value\n-    \/\/ is NULL the region has either:\n+    \/\/ Returns whether the top at rebuild start value for the given region indicates\n+    \/\/ that there is some rebuild or scrubbing work.\n+    \/\/\n+    \/\/ Based on the results of G1RemSetTrackingPolicy::needs_scan_for_rebuild(),\n+    \/\/ the value may be changed to nullptr during rebuilding if the region has either:\n@@ -109,1 +112,0 @@\n-    \/\/ In these cases we do not need to scan through the given region.\n@@ -111,1 +113,1 @@\n-      return _cm->top_at_rebuild_start(hr->hrm_index()) != NULL;\n+      return _cm->top_at_rebuild_start(hr->hrm_index()) != nullptr;\n@@ -198,2 +200,0 @@\n-\n-      hr->note_end_of_scrubbing();\n@@ -232,0 +232,3 @@\n+      \/\/ Scrubbing completed for this region - notify that we are done with it, resetting\n+      \/\/ pb to bottom.\n+      hr->note_end_of_scrubbing();\n@@ -308,2 +311,1 @@\n-        \/\/ Old and open archive regions need to have their dead objects scrubbed\n-        \/\/ to make sure the region is parsable using object sizes.\n+        \/\/ This is a region with potentially unparsable (dead) objects.\n@@ -311,1 +313,2 @@\n-      } else if (hr->is_humongous()) {\n+      } else {\n+        assert(hr->is_humongous(), \"must be, but %u is %s\", hr->hrm_index(), hr->get_short_type_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -188,1 +188,3 @@\n-  bool is_obj_dead_size_below_pb(oop obj, HeapWord* pb, size_t& block_size) const;\n+  \/\/ Same as is_obj_dead(), but only for obj's in the unparsable area and also\n+  \/\/ returning the block size.\n+  bool is_obj_dead_size_in_unparsable(oop obj, HeapWord* pb, G1CMBitMap* bitmap, size_t& block_size) const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-inline bool HeapRegion::is_obj_dead_size_below_pb(const oop obj, HeapWord* const pb, size_t& block_size) const {\n+inline bool HeapRegion::is_obj_dead_size_in_unparsable(const oop obj, HeapWord* const pb, G1CMBitMap* bitmap, size_t& block_size) const {\n@@ -147,1 +147,0 @@\n-  G1CMBitMap* bitmap = G1CollectedHeap::heap()->concurrent_mark()->mark_bitmap();\n@@ -388,0 +387,1 @@\n+  G1CMBitMap* bitmap = G1CollectedHeap::heap()->concurrent_mark()->mark_bitmap();\n@@ -389,1 +389,0 @@\n-    G1CMBitMap* bitmap = G1CollectedHeap::heap()->concurrent_mark()->mark_bitmap();\n@@ -402,1 +401,1 @@\n-    bool is_dead = is_obj_dead_size_below_pb(obj, pb, block_size);\n+    bool is_dead = is_obj_dead_size_in_unparsable(obj, pb, bitmap, block_size);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/utilities\/test_bitMap_search.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}