{"files":[{"patch":"@@ -840,1 +840,0 @@\n-  size_t _total_next_live_bytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-class G1CMBitMapClosure : public MarkBitMapClosure {\n+class G1CMBitMapClosure {\n@@ -46,1 +46,1 @@\n-  G1CMBitMapClosure(G1CMTask *task, G1ConcurrentMark* cm) : MarkBitMapClosure(), _cm(cm), _task(task) { }\n+  G1CMBitMapClosure(G1CMTask *task, G1ConcurrentMark* cm) : _cm(cm), _task(task) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMarkBitMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-  template <class Closure, bool is_gc_active>\n+  template <class Closure, bool in_gc_pause>\n@@ -273,1 +273,1 @@\n-  template <class Closure, bool is_gc_active>\n+  template <class Closure, bool in_gc_pause>\n@@ -283,1 +283,1 @@\n-  template <class Closure, bool is_gc_active>\n+  template <class Closure, bool in_gc_pause>\n@@ -570,1 +570,1 @@\n-  template <bool is_gc_active, class Closure>\n+  template <bool in_gc_pause, class Closure>\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -315,1 +315,1 @@\n-template <class Closure, bool is_gc_active>\n+template <class Closure, bool in_gc_pause>\n@@ -328,1 +328,1 @@\n-  if (!is_gc_active && (obj->klass_or_null_acquire() == NULL)) {\n+  if (!in_gc_pause && (obj->klass_or_null_acquire() == NULL)) {\n@@ -336,1 +336,1 @@\n-  HeapWord* const pb = is_gc_active ? sr->parsable_bottom() : sr->parsable_bottom_acquire();\n+  HeapWord* const pb = in_gc_pause ? sr->parsable_bottom() : sr->parsable_bottom_acquire();\n@@ -363,1 +363,1 @@\n-template <class Closure, bool is_gc_active>\n+template <class Closure, bool in_gc_pause>\n@@ -388,1 +388,1 @@\n-  if (!is_gc_active) {\n+  if (!in_gc_pause) {\n@@ -431,1 +431,1 @@\n-template <class Closure, bool is_gc_active>\n+template <class Closure, bool in_gc_pause>\n@@ -438,1 +438,1 @@\n-  HeapWord* const pb = is_gc_active ? parsable_bottom() : parsable_bottom_acquire();\n+  HeapWord* const pb = in_gc_pause ? parsable_bottom() : parsable_bottom_acquire();\n@@ -445,1 +445,1 @@\n-    cur = oops_on_memregion_iterate_in_unparsable<Closure, is_gc_active>(mr, pb, cl);\n+    cur = oops_on_memregion_iterate_in_unparsable<Closure, in_gc_pause>(mr, pb, cl);\n@@ -483,1 +483,1 @@\n-template <bool is_gc_active, class Closure>\n+template <bool in_gc_pause, class Closure>\n@@ -490,1 +490,1 @@\n-    return do_oops_on_memregion_in_humongous<Closure, is_gc_active>(mr, cl);\n+    return do_oops_on_memregion_in_humongous<Closure, in_gc_pause>(mr, cl);\n@@ -502,1 +502,1 @@\n-  return oops_on_memregion_iterate<Closure, is_gc_active>(mr, cl);\n+  return oops_on_memregion_iterate<Closure, in_gc_pause>(mr, cl);\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,6 +32,0 @@\n-\/\/ Closure for iteration over set bits of a bitmap.\n-class MarkBitMapClosure {\n-public:\n-  virtual bool do_addr(HeapWord* const addr) = 0;\n-};\n-\n@@ -87,1 +81,0 @@\n-  inline bool iterate(MarkBitMapClosure* cl, MemRegion mr);\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,20 +36,0 @@\n-inline bool MarkBitMap::iterate(MarkBitMapClosure* cl, MemRegion mr) {\n-  assert(!mr.is_empty(), \"Does not support empty memregion to iterate over\");\n-  assert(_covered.contains(mr),\n-         \"Given MemRegion from \" PTR_FORMAT \" to \" PTR_FORMAT \" not contained in heap area\",\n-         p2i(mr.start()), p2i(mr.end()));\n-\n-  BitMap::idx_t const end_offset = addr_to_offset(mr.end());\n-  BitMap::idx_t offset = _bm.get_next_one_offset(addr_to_offset(mr.start()), end_offset);\n-\n-  while (offset < end_offset) {\n-    HeapWord* const addr = offset_to_addr(offset);\n-    if (!cl->do_addr(addr)) {\n-      return false;\n-    }\n-    size_t const obj_size = cast_to_oop(addr)->size();\n-    offset = _bm.get_next_one_offset(offset + (obj_size >> _shifter), end_offset);\n-  }\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/markBitMap.inline.hpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"}]}