{"files":[{"patch":"@@ -579,1 +579,1 @@\n-     *   top-level polls (argument \"srcs\" in method scan, with setup\n+     *   top-level polls (argument \"window\" in method scan, with setup\n@@ -581,5 +581,7 @@\n-     *   and previous two sources, and stop signalling when all were\n-     *   from the same source. And similarly not retry under multiple\n-     *   CAS failures by newly activated workers.  These mechanisms\n-     *   may result in transiently too few workers, but once workers\n-     *   poll from a new source, they rapidly reactivate others.\n+     *   and previous two sources (or INVALID_ID if none), and stop\n+     *   signalling when all were from the same source. Also, retries\n+     *   are suppressed on CAS failures by newly activated workers,\n+     *   which serves as a form of admission control.  These\n+     *   mechanisms may result in transiently too few workers, but\n+     *   once workers poll from a new source, they rapidly reactivate\n+     *   others.\n@@ -1009,1 +1011,0 @@\n-    static final int  SWIDTH          = 16;          \/\/ width of short\n@@ -1036,4 +1037,3 @@\n-    static final long WMASK           = ((long)SMASK) << 48; \/\/ must be negative\n-    static final long RESCAN          = 1L << 63;\n-    static final long RAN             = 1L << 62;\n-    static final long INVALID_HISTORY = ((((long)INVALID_ID) << 32) | \/\/ no 3rd\n+    static final long RESCAN          = 1L << 63; \/\/ must be negative\n+    static final long WMASK           = ~(((long)SMASK) << 48); \/\/ id bits only\n+    static final long NO_HISTORY      = ((((long)INVALID_ID) << 32) | \/\/ no 3rd\n@@ -1041,0 +1041,1 @@\n+\n@@ -1332,1 +1333,1 @@\n-            if ((room == 0 || room == m || a[m & (s - 1)] == null) &&\n+            if ((room == 0 || room >= m || a[m & (s - 1)] == null) &&\n@@ -2025,1 +2026,1 @@\n-            for (long window = INVALID_HISTORY | (r >>> 16);;) {\n+            for (long window = NO_HISTORY | (r >>> 16);;) {\n@@ -2029,1 +2030,1 @@\n-                if (window == (window = scan(w, window, r)) &&\n+                if (window == (window = scan(w, window & WMASK, r)) &&\n@@ -2042,1 +2043,1 @@\n-                        window = INVALID_HISTORY | (window & SMASK);\n+                        window = NO_HISTORY | (window & SMASK);\n@@ -2054,1 +2055,1 @@\n-     * @param window up to three queue indices and RAN indicator from last scan\n+     * @param window up to three queue indices\n@@ -2056,1 +2057,1 @@\n-     * @return the next window value to use, nonnegative if empty\n+     * @return the next window to use, with RESCAN set for rescan\n@@ -2061,4 +2062,1 @@\n-        int i = (short)window;                    \/\/ origin\n-        boolean running = (window & RAN) != 0L;   \/\/ true if last scan succeeded\n-        long next = window &= ~WMASK;             \/\/ default for empty scan\n-        outer: for (int l = n; l > 0; --l, i += step) {\n+        outer: for (int i = (short)window, l = n; l > 0; --l, i += step) {\n@@ -2069,1 +2067,1 @@\n-                    int b, k;\n+                    int b, k; Object o;\n@@ -2073,1 +2071,0 @@\n-                        Object o;                 \/\/ to check identities\n@@ -2077,1 +2074,1 @@\n-                                if (!contended && next >= 0L &&\n+                                if (!contended && window >= 0L &&\n@@ -2079,1 +2076,1 @@\n-                                    next |= RESCAN; \/\/ revisit\n+                                    window |= RESCAN; \/\/ revisit\n@@ -2086,3 +2083,3 @@\n-                            long nw = ((window << 16) | j) & ~WMASK;\n-                            next = nw | (RESCAN | RAN);\n-                            if ((window != nw || (short)(nw >> 32) != j) &&\n+                            long pw = window, nw = ((pw << 16) | j) & WMASK;\n+                            window = nw | RESCAN;\n+                            if ((nw != pw || (short)(nw >>> 32) != j) &&\n@@ -2090,0 +2087,1 @@\n+                            if (nw != pw && a[nk] != null)\n@@ -2095,3 +2093,3 @@\n-                        else                      \/\/ limit retries on contention\n-                            contended = (o == null && !running &&\n-                                         q.array == a && a[nk] != null);\n+                        else if ((contended = (o == null)) &&\n+                                  (short)(window >>> 16) == INVALID_ID)\n+                            break;               \/\/ contended and newly active\n@@ -2102,1 +2100,1 @@\n-        return next;\n+        return window;\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":30,"deletions":32,"binary":false,"changes":62,"status":"modified"}]}