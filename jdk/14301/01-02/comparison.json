{"files":[{"patch":"@@ -373,1 +373,1 @@\n-     * a simple spinlock (as one role of filed \"phase\") because\n+     * a simple spinlock (as one role of field \"phase\") because\n@@ -1259,0 +1259,3 @@\n+            if (clearThreadLocals)\n+                cfg |= CLEAR_TLS;\n+            this.config = cfg;\n@@ -1260,1 +1263,0 @@\n-            this.config = (clearThreadLocals) ? cfg | CLEAR_TLS : cfg;\n@@ -1267,1 +1269,2 @@\n-         *\/final int getPoolIndex() {\n+         *\/\n+        final int getPoolIndex() {\n@@ -1351,4 +1354,3 @@\n-            int b = base, p = top, s = p - 1, cap;\n-            if (p - b > 0 && a != null && (cap = a.length) > 0) {\n-                int m = cap - 1, nb;\n-                do {\n+            int b = base, p = top, cap;\n+            if (a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, s, nb; p - b > 0; ) {\n@@ -1357,1 +1359,1 @@\n-                                 a, slotOffset(m & s), null)) != null)\n+                                 a, slotOffset(m & (s = p - 1)), null)) != null)\n@@ -1370,1 +1372,1 @@\n-                } while (p - b > 0);\n+                }\n@@ -1389,1 +1391,1 @@\n-            boolean taken;\n+            boolean taken = false;\n@@ -1395,2 +1397,3 @@\n-                if (taken = (top == p && U.compareAndSetReference(\n-                                 a, slotOffset(k), task, null)))\n+                if (top == p &&\n+                    U.compareAndSetReference(a, slotOffset(k), task, null)) {\n+                    taken = true;\n@@ -1398,0 +1401,1 @@\n+                }\n@@ -1401,2 +1405,0 @@\n-            else\n-                taken = false;\n@@ -1447,1 +1449,1 @@\n-                        if (pool != null && a[nk] != null)\n+                        if (a[nk] != null && pool != null)\n@@ -1493,2 +1495,2 @@\n-                if ((task = nextLocalTask(fifo)) == null &&\n-                    src != null && (task = src.tryPoll()) != null)\n+                if ((task = nextLocalTask(fifo)) == null && src != null &&\n+                    (task = src.tryPoll()) != null)\n@@ -1506,1 +1508,0 @@\n-            boolean taken = false;\n@@ -1509,4 +1510,6 @@\n-            if (task != null && a != null && (cap = a.length) > 0 && d > 0) {\n-                for (int i = s; ; --i) {\n-                    ForkJoinTask<?> t; int k;\n-                    if ((t = a[k = i & (cap - 1)]) == task) {\n+            if (a != null && (cap = a.length) > 0) {\n+                for (int m = cap - 1, i = s; d > 0; --i, --d) {\n+                    ForkJoinTask<?> t; int k; boolean taken;\n+                    if ((t = a[k = i & m]) == null)\n+                        break;\n+                    if (t == task) {\n@@ -1516,2 +1519,3 @@\n-                        if (top == p &&\n-                            U.compareAndSetReference(a, pos, task, null)) {\n+                        if (taken =\n+                            (top == p &&\n+                             U.compareAndSetReference(a, pos, task, null))) {\n@@ -1526,1 +1530,1 @@\n-                                        a, slotOffset(s & (cap - 1)), null));\n+                                        a, slotOffset(s & m), null));\n@@ -1529,1 +1533,0 @@\n-                            taken = true;\n@@ -1533,0 +1536,2 @@\n+                        if (taken)\n+                            task.doExec();\n@@ -1535,2 +1540,0 @@\n-                    else if (t == null || --d == 0)\n-                        break;\n@@ -1539,2 +1542,0 @@\n-            if (taken)\n-                task.doExec();\n@@ -1549,1 +1550,1 @@\n-         * @return task status if known done; else 0\n+         * @return task status if known to be done\n@@ -1599,15 +1600,8 @@\n-            if (blocker != null) {\n-                for (;;) {\n-                    ForkJoinTask<?>[] a; int b, cap, k;\n-                    if ((a = array) == null || (cap = a.length) <= 0)\n-                        break;\n-                    ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n-                    U.loadFence();\n-                    if (t == null) {\n-                        if (top - b <= 0)\n-                            break;\n-                    }\n-                    else if (!(t instanceof CompletableFuture\n-                               .AsynchronousCompletionTask))\n-                        break;\n-                    if (blocker.isReleasable())\n+            for (;;) {\n+                ForkJoinTask<?>[] a; int b, cap, k;\n+                if ((a = array) == null || (cap = a.length) <= 0)\n+                    break;\n+                ForkJoinTask<?> t = a[k = (b = base) & (cap - 1)];\n+                U.loadFence();\n+                if (t == null) {\n+                    if (top - b <= 0)\n@@ -1615,5 +1609,10 @@\n-                    if (base == b && t != null &&\n-                        U.compareAndSetReference(a, slotOffset(k), t, null)) {\n-                        updateBase(b + 1);\n-                        t.doExec();\n-                    }\n+                }\n+                else if (!(t instanceof CompletableFuture\n+                           .AsynchronousCompletionTask))\n+                    break;\n+                if (blocker != null && blocker.isReleasable())\n+                    break;\n+                if (base == b && t != null &&\n+                    U.compareAndSetReference(a, slotOffset(k), t, null)) {\n+                    updateBase(b + 1);\n+                    t.doExec();\n@@ -1751,2 +1750,1 @@\n-            }\n-            else if (waits < SPIN_WAITS) {\n+            } else if (waits < SPIN_WAITS) {\n@@ -1755,2 +1753,1 @@\n-            }\n-            else {\n+            } else {\n@@ -1880,2 +1877,6 @@\n-                    for (ForkJoinTask<?> t; (t = w.nextLocalTask()) != null; )\n-                        ForkJoinTask.cancelIgnoringExceptions(t);\n+                    for (ForkJoinTask<?> t; (t = w.nextLocalTask()) != null; ) {\n+                         try {\n+                             t.cancel(false);\n+                         } catch (Throwable ignore) {\n+                         }\n+                    }\n@@ -1922,3 +1923,1 @@\n-            WorkQueue v = null, w = qs[i];\n-            if ((short)(c >>> RC_SHIFT) >= pc)\n-                break;\n+            WorkQueue w = qs[i], v = null;\n@@ -1930,3 +1929,3 @@\n-            else {\n-                if ((v = w) == null)\n-                    break;\n+            else if ((short)(c >>> RC_SHIFT) >= pc || (v = w) == null)\n+                break;\n+            else\n@@ -1934,1 +1933,0 @@\n-            }\n@@ -2005,1 +2003,1 @@\n-            else if ((e == prevRunState && (e & RS_LOCK) == 0 && swept) &&\n+            else if (e == prevRunState && (e & RS_LOCK) == 0 && swept &&\n@@ -2158,1 +2156,1 @@\n-            if (spins < 0) {                    \/\/ emulate LockSupport.park\n+            if (p == idlePhase) {               \/\/ emulate LockSupport.park\n@@ -2328,1 +2326,1 @@\n-                                        break;          \/\/ stale\n+                                        break;\n@@ -2554,1 +2552,1 @@\n-                else if (isQuiescent(false))\n+                else if (isQuiescent(true))\n@@ -2668,1 +2666,1 @@\n-                 (q = qs[r & EXTERNAL_ID_MASK & (n - 1)]) != null&& r != 0 &&\n+                 (q = qs[r & EXTERNAL_ID_MASK & (n - 1)]) != null && r != 0 &&\n@@ -2699,4 +2697,3 @@\n-        if ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) {\n-            if ((wt = (ForkJoinWorkerThread)t).pool == e)\n-                w = wt.workQueue;\n-        }\n+        if (((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) &&\n+            (wt = (ForkJoinWorkerThread)t).pool == e)\n+            w = wt.workQueue;\n@@ -2803,2 +2800,6 @@\n-                    for (ForkJoinTask<?> t; (t = q.poll(null)) != null; )\n-                        ForkJoinTask.cancelIgnoringExceptions(t);\n+                    for (ForkJoinTask<?> t; (t = q.poll(null)) != null; ) {\n+                        try {\n+                            t.cancel(false);\n+                        } catch (Throwable ignore) {\n+                        }\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":76,"deletions":75,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -427,1 +427,4 @@\n-                            cancelIgnoringExceptions(this);\n+                            try {\n+                                cancel(true);\n+                            } catch (Throwable ignore) {\n+                            }\n@@ -611,16 +614,0 @@\n-    \/**\n-     * Cancels with mayInterruptIfRunning, ignoring any exceptions\n-     * thrown by cancel. Used only when cancelling tasks upon pool or\n-     * worker thread termination. Cancel is spec'ed not to throw any\n-     * exceptions, but if it does anyway, we have no recourse, so\n-     * guard against this case.\n-     *\/\n-    static final void cancelIgnoringExceptions(ForkJoinTask<?> t) {\n-        if (t != null) {\n-            try {\n-                t.cancel(true);\n-            } catch (Throwable ignore) {\n-            }\n-        }\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":4,"deletions":17,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -716,2 +716,0 @@\n-java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java             8286352 linux-all,windows-x64\n-java\/util\/concurrent\/ExecutorService\/CloseTest.java             8288899 macosx-aarch64\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @summary Test ExecutorService.close, including default implementation\n+ * @summary Test implementations of ExecutorService.close\n@@ -28,1 +28,1 @@\n- * @run testng CloseTest\n+ * @run junit CloseTest\n@@ -40,0 +40,1 @@\n+import java.util.stream.Stream;\n@@ -41,23 +42,16 @@\n-import org.testng.annotations.AfterClass;\n-import org.testng.annotations.BeforeClass;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n-\n-public class CloseTest {\n-\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        var defaultThreadFactory = Executors.defaultThreadFactory();\n-        var virtualThreadFactory = Thread.ofVirtual().factory();\n-        return new Object[][] {\n-            \/\/ ensures that default close method is tested\n-            { new DelegatingExecutorService(Executors.newCachedThreadPool()), },\n-\n-            \/\/ implementations that may override close\n-            { new ForkJoinPool(), },\n-            { Executors.newFixedThreadPool(1), },\n-            { Executors.newCachedThreadPool(), },\n-            { Executors.newThreadPerTaskExecutor(defaultThreadFactory), },\n-            { Executors.newThreadPerTaskExecutor(virtualThreadFactory), },\n-        };\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class CloseTest {\n+\n+    static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                \/\/ ensures that default close method is tested\n+                new DelegatingExecutorService(Executors.newCachedThreadPool()),\n+\n+                \/\/ implementations that may override close\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n@@ -69,2 +63,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCloseWithNoTasks(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCloseWithNoTasks(ExecutorService executor) throws Exception {\n@@ -80,2 +75,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCloseWithRunningTasks(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCloseWithRunningTasks(ExecutorService executor) throws Exception {\n@@ -90,1 +86,1 @@\n-        assertEquals(future.resultNow(), \"foo\");\n+        assertEquals(\"foo\", future.resultNow());\n@@ -96,2 +92,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testShutdownBeforeClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testShutdownBeforeClose(ExecutorService executor) throws Exception {\n@@ -112,1 +109,1 @@\n-        assertEquals(future.resultNow(), \"foo\");\n+        assertEquals(\"foo\", future.resultNow());\n@@ -118,2 +115,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testTerminateBeforeClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testTerminateBeforeClose(ExecutorService executor) throws Exception {\n@@ -132,2 +130,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInterruptBeforeClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptBeforeClose(ExecutorService executor) throws Exception {\n@@ -152,1 +151,1 @@\n-        expectThrows(ExecutionException.class, future::get);\n+        assertThrows(ExecutionException.class, future::get);\n@@ -158,2 +157,4 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInterruptDuringClose(ExecutorService executor) throws Exception {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptDuringClose(ExecutorService executor) throws Exception {\n+        Phaser phaser = new Phaser(2);\n@@ -161,0 +162,1 @@\n+            phaser.arriveAndAwaitAdvance();\n@@ -164,0 +166,3 @@\n+        phaser.arriveAndAwaitAdvance();  \/\/ wait for task to start\n+\n+        \/\/ schedule main thread to be interrupted\n@@ -166,1 +171,1 @@\n-            try { Thread.sleep( Duration.ofMillis(500)); } catch (Exception ignore) { }\n+            try { Thread.sleep( Duration.ofMillis(100)); } catch (Exception ignore) { }\n@@ -169,0 +174,1 @@\n+\n@@ -178,1 +184,1 @@\n-        expectThrows(ExecutionException.class, future::get);\n+        assertThrows(ExecutionException.class, future::get);\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/CloseTest.java","additions":48,"deletions":42,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -0,0 +1,787 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test implementations of ExecutorService.invokeAll\/invokeAny\n+ * @run junit InvokeTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.*;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import static java.lang.Thread.State.*;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class InvokeTest {\n+\n+    private static ScheduledExecutorService scheduler;\n+\n+    @BeforeAll\n+    static void setup() throws Exception {\n+        scheduler = Executors.newSingleThreadScheduledExecutor();\n+    }\n+\n+    @AfterAll\n+    static void shutdown() {\n+        scheduler.shutdown();\n+    }\n+\n+    private static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete normally.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> \"bar\";\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertTrue(Set.of(\"foo\", \"bar\").contains(result));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete normally. The completion of the\n+     * first task should cancel remaining tasks.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertEquals(\"foo\", result);\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete with exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> { throw new FooException(); };\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                assertTrue(cause instanceof FooException);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where all tasks complete with exception. The completion\n+     * of the last task is delayed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny4(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> { throw new FooException(); };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                throw new FooException();\n+            };\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (ExecutionException e) {\n+                Throwable cause = e.getCause();\n+                assertTrue(cause instanceof FooException);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where some, not all, tasks complete normally.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny5(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertEquals(\"foo\", result);\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny where some, not all, tasks complete normally. The first\n+     * task to complete normally is delayed.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAny6(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            Callable<String> task1 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"foo\";\n+            };\n+            Callable<String> task2 = () -> { throw new FooException(); };\n+            String result = executor.invokeAny(List.of(task1, task2));\n+            assertEquals(\"foo\", result);\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny where all tasks complete normally before the timeout.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> \"bar\";\n+            String result = executor.invokeAny(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+            assertTrue(Set.of(\"foo\", \"bar\").contains(result));\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny where one task completes normally before the timeout.\n+     * The remaining tests should be cancelled.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            String result = executor.invokeAny(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+            assertEquals(\"foo\", result);\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny where timeout expires before any task completes.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithTimeout3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var task1Started = new AtomicBoolean();\n+            var task1Interrupted = new CountDownLatch(1);\n+            Callable<String> task1 = () -> {\n+                task1Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task1Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            \/\/ invokeAny should throw TimeoutException\n+            assertThrows(TimeoutException.class,\n+                    () -> executor.invokeAny(List.of(task1, task2), 100, TimeUnit.MILLISECONDS));\n+\n+            \/\/ tasks that started should be interrupted\n+            if (task1Started.get()) {\n+                task1Interrupted.await();\n+            }\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyWithInterruptSet(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"foo\";\n+            };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"bar\";\n+            };\n+            Thread.currentThread().interrupt();\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupting a thread blocked in invokeAny.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInterruptInvokeAny(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var task1Started = new AtomicBoolean();\n+            var task1Interrupted = new CountDownLatch(1);\n+            Callable<String> task1 = () -> {\n+                task1Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task1Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            scheduleInterruptAt(\"invokeAny\");\n+            try {\n+                executor.invokeAny(List.of(task1, task2));\n+                fail(\"invokeAny did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+\n+            \/\/ tasks that started should be interrupted\n+            if (task1Started.get()) {\n+                task1Interrupted.await();\n+            }\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny after ExecutorService has been shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyAfterShutdown(ExecutorService executor) throws Exception {\n+        executor.shutdown();\n+        Callable<String> task1 = () -> \"foo\";\n+        Callable<String> task2 = () -> \"bar\";\n+        assertThrows(RejectedExecutionException.class,\n+                () -> executor.invokeAny(List.of(task1, task2)));\n+    }\n+\n+    \/**\n+     * Test invokeAny with empty collection.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyEmpty1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            assertThrows(IllegalArgumentException.class, () -> executor.invokeAny(List.of()));\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAny with empty collection.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyEmpty2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> executor.invokeAny(List.of(), 1, TimeUnit.MINUTES));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny with null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyNull1(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            assertThrows(NullPointerException.class, () -> executor.invokeAny(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAny with null element\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAnyNull2(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            List<Callable<String>> list = new ArrayList<>();\n+            list.add(() -> \"foo\");\n+            list.add(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAny(null));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where all tasks complete normally.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"bar\";\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2));\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ check results\n+            List<String> results = futures.stream().map(Future::resultNow).toList();\n+            assertEquals(results, List.of(\"foo\", \"bar\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where all tasks complete with exception.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            class FooException extends Exception { }\n+            class BarException extends Exception { }\n+            Callable<String> task1 = () -> { throw new FooException(); };\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                throw new BarException();\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2));\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ check results\n+            Throwable e1 = assertThrows(ExecutionException.class, () -> futures.get(0).get());\n+            assertTrue(e1.getCause() instanceof FooException);\n+            Throwable e2 = assertThrows(ExecutionException.class, () -> futures.get(1).get());\n+            assertTrue(e2.getCause() instanceof BarException);\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where all tasks complete normally before the timeout expires.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMillis(50));\n+                return \"bar\";\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ check results\n+            List<String> results = futures.stream().map(Future::resultNow).toList();\n+            assertEquals(results, List.of(\"foo\", \"bar\"));\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll where some tasks do not complete before the timeout expires.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAll4(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            List<Future<String>> futures = executor.invokeAll(List.of(task1, task2), 1, TimeUnit.SECONDS);\n+            assertTrue(futures.size() == 2);\n+\n+            \/\/ task1 should be done\n+            assertTrue(futures.get(0).isDone());\n+\n+            \/\/ task2 should be cancelled and interrupted\n+            assertTrue(futures.get(1).isCancelled());\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"bar\";\n+            };\n+\n+            Thread.currentThread().interrupt();\n+            try {\n+                executor.invokeAll(List.of(task1, task2));\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed-invokeAll with interrupt status set.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt3(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+            Callable<String> task2 = () -> {\n+                Thread.sleep(Duration.ofMinutes(1));\n+                return \"bar\";\n+            };\n+\n+            Thread.currentThread().interrupt();\n+            try {\n+                executor.invokeAll(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt with thread blocked in invokeAll.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt4(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            scheduleInterruptAt(\"invokeAll\");\n+            try {\n+                executor.invokeAll(List.of(task1, task2));\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test interrupt with thread blocked in timed-invokeAll.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllInterrupt6(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            Callable<String> task1 = () -> \"foo\";\n+\n+            var task2Started = new AtomicBoolean();\n+            var task2Interrupted = new CountDownLatch(1);\n+            Callable<String> task2 = () -> {\n+                task2Started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    task2Interrupted.countDown();\n+                }\n+                return null;\n+            };\n+\n+            scheduleInterruptAt(\"invokeAll\");\n+            try {\n+                executor.invokeAll(List.of(task1, task2), 1, TimeUnit.MINUTES);\n+                fail(\"invokeAll did not throw\");\n+            } catch (InterruptedException expected) {\n+                assertFalse(Thread.currentThread().isInterrupted());\n+            } finally {\n+                Thread.interrupted(); \/\/ clear interrupt\n+            }\n+\n+            \/\/ if task2 started then it should have been interrupted\n+            if (task2Started.get()) {\n+                task2Interrupted.await();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test invokeAll after ExecutorService has been shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllAfterShutdown1(ExecutorService executor) throws Exception {\n+        executor.shutdown();\n+\n+        Callable<String> task1 = () -> \"foo\";\n+        Callable<String> task2 = () -> \"bar\";\n+        assertThrows(RejectedExecutionException.class,\n+                () -> executor.invokeAll(List.of(task1, task2)));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllAfterShutdown2(ExecutorService executor) throws Exception {\n+        executor.shutdown();\n+\n+        Callable<String> task1 = () -> \"foo\";\n+        Callable<String> task2 = () -> \"bar\";\n+        assertThrows(RejectedExecutionException.class,\n+                () -> executor.invokeAll(List.of(task1, task2), 1, TimeUnit.SECONDS));\n+    }\n+\n+    \/**\n+     * Test invokeAll with empty collection.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllEmpty1(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            List<Future<Object>> list = executor.invokeAll(List.of());\n+            assertTrue(list.size() == 0);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllEmpty2(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            List<Future<Object>> list = executor.invokeAll(List.of(), 1, TimeUnit.SECONDS);\n+            assertTrue(list.size() == 0);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull1(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            assertThrows(NullPointerException.class, () -> executor.invokeAll(null));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull2(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            List<Callable<String>> tasks = new ArrayList<>();\n+            tasks.add(() -> \"foo\");\n+            tasks.add(null);\n+            assertThrows(NullPointerException.class, () -> executor.invokeAll(tasks));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull3(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            assertThrows(NullPointerException.class,\n+                    () -> executor.invokeAll(null, 1, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull4(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            Callable<String> task = () -> \"foo\";\n+            assertThrows(NullPointerException.class,\n+                    () -> executor.invokeAll(List.of(task), 1, null));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testInvokeAllNull5(ExecutorService executor)throws Exception {\n+        try (executor) {\n+            List<Callable<String>> tasks = new ArrayList<>();\n+            tasks.add(() -> \"foo\");\n+            tasks.add(null);\n+            assertThrows(NullPointerException.class,\n+                    () -> executor.invokeAll(tasks, 1, TimeUnit.SECONDS));\n+        }\n+    }\n+\n+    \/**\n+     * Schedules the current thread to be interrupted when it waits (timed or untimed)\n+     * at the given method name.\n+     *\/\n+    private void scheduleInterruptAt(String methodName) {\n+        Thread target = Thread.currentThread();\n+        scheduler.submit(() -> {\n+            try {\n+                boolean found = false;\n+                while (!found) {\n+                    Thread.State state = target.getState();\n+                    assertTrue(state != TERMINATED);\n+                    if ((state == WAITING || state == TIMED_WAITING)\n+                            && contains(target.getStackTrace(), methodName)) {\n+                        found = true;\n+                    } else {\n+                        Thread.sleep(20);\n+                    }\n+                }\n+                target.interrupt();\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Returns true if the given stack trace contains an element for the given method name.\n+     *\/\n+    private boolean contains(StackTraceElement[] stack, String methodName) {\n+        return Arrays.stream(stack)\n+                .anyMatch(e -> methodName.equals(e.getMethodName()));\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/InvokeTest.java","additions":787,"deletions":0,"binary":false,"changes":787,"status":"added"},{"patch":"@@ -0,0 +1,370 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test implementations of ExecutorService.submit\/execute\n+ * @run junit SubmitTest\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.*;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class SubmitTest {\n+\n+    private static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n+    }\n+\n+    \/**\n+     * Test submit(Runnable) executes the task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnable(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var latch = new CountDownLatch(1);\n+            Future<?> future = executor.submit(latch::countDown);\n+            latch.await();\n+            assertNull(future.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Runnable) throws if executor is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableAfterShutdown(ExecutorService executor) {\n+        executor.shutdown();\n+        assertThrows(RejectedExecutionException.class, () -> executor.submit(() -> { }));\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Runnable) is not interrupted by cancel(false).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableWithCancelFalse(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var stop = new CountDownLatch(1);\n+            var done = new CountDownLatch(1);\n+            Future<?> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    stop.await();\n+                } catch (InterruptedException e) {\n+                    \/\/ ignore\n+                } finally {\n+                    done.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(false), task should not be interrupted\n+            future.cancel(false);\n+            assertFalse(done.await(500, TimeUnit.MILLISECONDS));\n+\n+            \/\/ let task finish\n+            stop.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Runnable) is interrupted by cancel(true).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableWithCancelTrue(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<?> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(true), task should be interrupted\n+            future.cancel(true);\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Runnable) is interrupted if executor is\n+     * stopped with shutdownNow.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableWithShutdownNow(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<?> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ shutdown forcefully, task should be interrupted\n+            executor.shutdownNow();\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Runnable) throws if task is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitRunnableNull(ExecutorService executor) {\n+        try (executor) {\n+            Runnable nullTask = null;\n+            assertThrows(NullPointerException.class, () -> executor.submit(nullTask));\n+            assertThrows(NullPointerException.class, () -> executor.submit(nullTask, Void.class));\n+        }\n+    }\n+\n+    \/\/\n+\n+    \/**\n+     * Test submit(Callable) executes the task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallable(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var latch = new CountDownLatch(1);\n+            Future<String> future = executor.submit(() -> {\n+                latch.countDown();\n+                return \"foo\";\n+            });\n+            latch.await();\n+            assertEquals(\"foo\", future.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Callable) throws if executor is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableAfterShutdown(ExecutorService executor) {\n+        executor.shutdown();\n+        assertThrows(RejectedExecutionException.class, () -> executor.submit(() -> null));\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Callable) is not interrupted by cancel(false).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableWithCancelFalse(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var stop = new CountDownLatch(1);\n+            var done = new CountDownLatch(1);\n+            Future<Void> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    stop.await();\n+                } finally {\n+                    done.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(false), task should not be interrupted\n+            future.cancel(false);\n+            assertFalse(done.await(500, TimeUnit.MILLISECONDS));\n+\n+            \/\/ let task finish\n+            stop.countDown();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Callable) is interrupted by cancel(true).\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableWithCancelTrue(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<Void> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ cancel(true), task should be interrupted\n+            future.cancel(true);\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test task submitted with submit(Callable) is interrupted if executor is\n+     * stopped with shutdownNow.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableWithShutdownNow(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            Future<Void> future = executor.submit(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                return null;\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ shutdown forcefully, task should be interrupted\n+            executor.shutdownNow();\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test submit(Callable) throws if task is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testSubmitCallableNull(ExecutorService executor) {\n+        try (executor) {\n+            Callable<Void> nullTask = null;\n+            assertThrows(NullPointerException.class, () -> executor.submit(nullTask));\n+        }\n+    }\n+\n+    \/\/\n+\n+    \/**\n+     * Test execute(Runnable) executes the task.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecute(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var latch = new CountDownLatch(1);\n+            executor.execute(latch::countDown);\n+            latch.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test execute(Runnable) throws if executor is shutdown.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecuteAfterShutdown(ExecutorService executor) {\n+        executor.shutdown();\n+        assertThrows(RejectedExecutionException.class, () -> executor.execute(() -> { }));\n+    }\n+\n+    \/**\n+     * Test task submitted with execute(Runnable) is interrupted if executor is\n+     * stopped with shutdownNow.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecuteWithShutdownNow(ExecutorService executor) throws Exception {\n+        try (executor) {\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            executor.execute(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+            });\n+\n+            \/\/ wait for task to start\n+            started.await();\n+\n+            \/\/ shutdown forcefully, task should be interrupted\n+            executor.shutdownNow();\n+            interrupted.await();\n+        }\n+    }\n+\n+    \/**\n+     * Test execute(Runnable) throws if task is null.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testExecuteNull(ExecutorService executor) {\n+        try (executor) {\n+            Runnable nullTask = null;\n+            assertThrows(NullPointerException.class, () -> executor.execute(nullTask));\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/ExecutorService\/SubmitTest.java","additions":370,"deletions":0,"binary":false,"changes":370,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @run testng DefaultMethods\n+ * @run junit DefaultMethods\n@@ -31,1 +31,7 @@\n-import java.util.concurrent.*;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.stream.Stream;\n@@ -34,3 +40,4 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -38,1 +45,1 @@\n-public class DefaultMethods {\n+class DefaultMethods {\n@@ -40,5 +47,4 @@\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        return new Object[][] {\n-            \/\/ ensures that default implementation is tested\n-            { new DelegatingExecutorService(Executors.newCachedThreadPool()), },\n+    static Stream<ExecutorService> executors() {\n+        return Stream.of(\n+                \/\/ ensures that default close method is tested\n+                new DelegatingExecutorService(Executors.newCachedThreadPool()),\n@@ -46,4 +52,5 @@\n-            \/\/ executors that may return a Future that overrides the methods\n-            { new ForkJoinPool(), },\n-            { Executors.newCachedThreadPool(), }\n-        };\n+                \/\/ executors that may return a Future that overrides the methods\n+                Executors.newCachedThreadPool(),\n+                Executors.newVirtualThreadPerTaskExecutor(),\n+                new ForkJoinPool()\n+        );\n@@ -55,2 +62,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testRunningTask(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testRunningTask(ExecutorService executor) {\n@@ -62,2 +70,2 @@\n-                expectThrows(IllegalStateException.class, future::resultNow);\n-                expectThrows(IllegalStateException.class, future::exceptionNow);\n+                assertThrows(IllegalStateException.class, future::resultNow);\n+                assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -73,2 +81,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCompletedTask1(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCompletedTask1(ExecutorService executor) {\n@@ -79,2 +88,2 @@\n-            assertEquals(future.resultNow(), \"foo\");\n-            expectThrows(IllegalStateException.class, future::exceptionNow);\n+            assertEquals(\"foo\", future.resultNow());\n+            assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -87,2 +96,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCompletedTask2(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCompletedTask2(ExecutorService executor) {\n@@ -93,2 +103,2 @@\n-            assertEquals(future.resultNow(), null);\n-            expectThrows(IllegalStateException.class, future::exceptionNow);\n+            assertNull(future.resultNow());\n+            assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -101,2 +111,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testFailedTask(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testFailedTask(ExecutorService executor) {\n@@ -107,1 +118,1 @@\n-            expectThrows(IllegalStateException.class, future::resultNow);\n+            assertThrows(IllegalStateException.class, future::resultNow);\n@@ -116,2 +127,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCancelledTask1(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCancelledTask1(ExecutorService executor) {\n@@ -124,2 +136,2 @@\n-                expectThrows(IllegalStateException.class, future::resultNow);\n-                expectThrows(IllegalStateException.class, future::exceptionNow);\n+                assertThrows(IllegalStateException.class, future::resultNow);\n+                assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -135,2 +147,3 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testCancelledTask2(ExecutorService executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"executors\")\n+    void testCancelledTask2(ExecutorService executor) {\n@@ -143,2 +156,2 @@\n-                expectThrows(IllegalStateException.class, future::resultNow);\n-                expectThrows(IllegalStateException.class, future::exceptionNow);\n+                assertThrows(IllegalStateException.class, future::resultNow);\n+                assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -155,1 +168,1 @@\n-    public void testCompletableFuture1() {\n+    void testCompletableFuture1() {\n@@ -158,2 +171,2 @@\n-        expectThrows(IllegalStateException.class, future::resultNow);\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertThrows(IllegalStateException.class, future::resultNow);\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -166,1 +179,1 @@\n-    public void testCompletableFuture2() {\n+    void testCompletableFuture2() {\n@@ -170,2 +183,2 @@\n-        assertEquals(future.resultNow(), \"foo\");\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertEquals(\"foo\", future.resultNow());\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -178,1 +191,1 @@\n-    public void testCompletableFuture3() {\n+    void testCompletableFuture3() {\n@@ -182,2 +195,2 @@\n-        assertEquals(future.resultNow(), null);\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertNull(future.resultNow());\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n@@ -190,1 +203,1 @@\n-    public void testCompletableFuture4() {\n+    void testCompletableFuture4() {\n@@ -194,1 +207,1 @@\n-        expectThrows(IllegalStateException.class, future::resultNow);\n+        assertThrows(IllegalStateException.class, future::resultNow);\n@@ -203,1 +216,1 @@\n-    public void testCompletableFuture5() {\n+    void testCompletableFuture5() {\n@@ -207,2 +220,2 @@\n-        expectThrows(IllegalStateException.class, future::resultNow);\n-        expectThrows(IllegalStateException.class, future::exceptionNow);\n+        assertThrows(IllegalStateException.class, future::resultNow);\n+        assertThrows(IllegalStateException.class, future::exceptionNow);\n","filename":"test\/jdk\/java\/util\/concurrent\/Future\/DefaultMethods.java","additions":66,"deletions":53,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,2 @@\n- * @run testng AsyncShutdownNow\n- * @summary Test invoking shutdownNow with threads blocked in Future.get,\n- *          invokeAll, and invokeAny\n+ * @summary Test ForkJoinPool.shutdownNow with threads blocked in invokeXXX and Future.get\n+ * @run junit AsyncShutdownNow\n@@ -31,0 +30,1 @@\n+import java.time.Duration;\n@@ -41,0 +41,1 @@\n+import java.util.stream.Stream;\n@@ -43,3 +44,3 @@\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-import static org.testng.Assert.*;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n@@ -47,1 +48,1 @@\n-public class AsyncShutdownNow {\n+class AsyncShutdownNow {\n@@ -51,1 +52,1 @@\n-        Thread.sleep(86400_000);\n+        Thread.sleep(Duration.ofDays(1));\n@@ -55,9 +56,5 @@\n-    \/**\n-     * The executors to test.\n-     *\/\n-    @DataProvider(name = \"executors\")\n-    public Object[][] executors() {\n-        return new Object[][] {\n-                { new ForkJoinPool() },\n-                { new ForkJoinPool(1) },\n-        };\n+    static Stream<ForkJoinPool> pools() {\n+        return Stream.of(\n+                new ForkJoinPool(),\n+                new ForkJoinPool(1)\n+        );\n@@ -67,1 +64,1 @@\n-     * Test shutdownNow with running task and thread blocked in Future::get.\n+     * Test shutdownNow with a running task and main thread blocked in Future::get.\n@@ -69,5 +66,5 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testFutureGet(ExecutorService executor) throws Exception {\n-        System.out.format(\"testFutureGet: %s%n\", executor);\n-        try (executor) {\n-            Future<?> future = executor.submit(SLEEP_FOR_A_DAY);\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testFutureGet(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n+            Future<?> future = pool.submit(SLEEP_FOR_A_DAY);\n@@ -75,2 +72,2 @@\n-            \/\/ shutdownNow when main thread waits in ForkJoinTask.get\n-            onWait(\"java.util.concurrent.ForkJoinTask.get\", executor::shutdownNow);\n+            \/\/ shutdownNow when main thread waits in ForkJoinTask.awaitDone\n+            onWait(\"java.util.concurrent.ForkJoinTask.awaitDone\", pool::shutdownNow);\n@@ -87,1 +84,1 @@\n-     * Test shutdownNow with running task and thread blocked in a timed Future::get.\n+     * Test shutdownNow with a running task and main thread blocked in a timed Future::get.\n@@ -89,5 +86,5 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testTimedFutureGet(ExecutorService executor) throws Exception {\n-        System.out.format(\"testTimedFutureGet: %s%n\", executor);\n-        try (executor) {\n-            Future<?> future = executor.submit(SLEEP_FOR_A_DAY);\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testTimedFutureGet(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n+            Future<?> future = pool.submit(SLEEP_FOR_A_DAY);\n@@ -95,2 +92,2 @@\n-            \/\/ shutdownNow when main thread waits in ForkJoinTask.get\n-            onWait(\"java.util.concurrent.ForkJoinTask.get\", executor::shutdownNow);\n+            \/\/ shutdownNow when main thread waits in ForkJoinTask.awaitDone\n+            onWait(\"java.util.concurrent.ForkJoinTask.awaitDone\", pool::shutdownNow);\n@@ -107,1 +104,1 @@\n-     * Test shutdownNow with thread blocked in invokeAll.\n+     * Test shutdownNow with running tasks and main thread blocked in invokeAll.\n@@ -109,7 +106,7 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAll(ExecutorService executor) throws Exception {\n-        System.out.format(\"testInvokeAll: %s%n\", executor);\n-        try (executor) {\n-            \/\/ shutdownNow when main thread waits in ForkJoinTask.quietlyJoin\n-            onWait(\"java.util.concurrent.ForkJoinTask.quietlyJoin\", executor::shutdownNow);\n-            List<Future<Void>> futures = executor.invokeAll(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testInvokeAll(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n+            \/\/ shutdownNow when main thread waits in ForkJoinTask.awaitDone\n+            onWait(\"java.util.concurrent.ForkJoinTask.awaitDone\", pool::shutdownNow);\n+            List<Future<Void>> futures = pool.invokeAll(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n@@ -129,1 +126,1 @@\n-     * Test shutdownNow with thread blocked in invokeAny.\n+     * Test shutdownNow with running tasks and main thread blocked in invokeAny.\n@@ -131,4 +128,4 @@\n-    @Test(dataProvider = \"executors\")\n-    public void testInvokeAny(ExecutorService executor) throws Exception {\n-        System.out.format(\"testInvokeAny: %s%n\", executor);\n-        try (executor) {\n+    @ParameterizedTest\n+    @MethodSource(\"pools\")\n+    void testInvokeAny(ForkJoinPool pool) throws Exception {\n+        try (pool) {\n@@ -136,1 +133,1 @@\n-            onWait(\"java.util.concurrent.ForkJoinTask.get\", executor::shutdownNow);\n+            onWait(\"java.util.concurrent.ForkJoinTask.get\", pool::shutdownNow);\n@@ -138,1 +135,1 @@\n-                executor.invokeAny(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n+                pool.invokeAny(List.of(SLEEP_FOR_A_DAY, SLEEP_FOR_A_DAY));\n","filename":"test\/jdk\/java\/util\/concurrent\/forkjoin\/AsyncShutdownNow.java","additions":46,"deletions":49,"binary":false,"changes":95,"status":"modified"}]}