{"files":[{"patch":"@@ -433,11 +433,18 @@\n-     * (only during worker creation and termination) under the runState\n-     * lock. It is otherwise concurrently readable but reads for use\n-     * in scans (see below) are always prefaced by a volatile read of\n-     * runState (or equivalent constructions), ensuring that its state is\n-     * current at the point it is used (which is all we require). To\n-     * simplify index-based operations, the array size is always a\n-     * power of two, and all readers must tolerate null slots.  Worker\n-     * queues are at odd indices. Worker phase ids masked with SMASK\n-     * match their index. Shared (submission) queues are at even\n-     * indices. Grouping them together in this way simplifies and\n-     * speeds up task scanning.\n+     * (only during worker creation and termination) under the\n+     * runState lock. It is otherwise concurrently readable but reads\n+     * for use in scans (see below) are always prefaced by a volatile\n+     * read of runState (or equivalent constructions), ensuring that\n+     * its state is current at the point it is used (which is all we\n+     * require). To simplify index-based operations, the array size is\n+     * always a power of two, and all readers must tolerate null\n+     * slots.  Worker queues are at odd indices. Worker phase ids\n+     * masked with SMASK match their index. Shared (submission) queues\n+     * are at even indices. Grouping them together in this way aids in\n+     * task scanning: At top-level, both kinds of queues should be\n+     * sampled with approximately the same probability, which is\n+     * simpler if they are all in the same array. But we also need to\n+     * identify what kind they are without looking at them, leading to\n+     * this odd\/even scheme. One disadvantage is that there are\n+     * usually many fewer submission queues, so there can be many\n+     * wasted probes (null slots). But this is still cheaper than\n+     * alternatives.\n@@ -456,1 +463,1 @@\n-     * these indices remain OK (with at most some unnecessary extra\n+     * these indices remain valid (with at most some unnecessary extra\n@@ -721,1 +728,1 @@\n-     * (i.e., steal back a task from and execute it) that could makje\n+     * (i.e., steal back a task from and execute it) that could make\n@@ -768,1 +775,1 @@\n-     * attempted only when it appears possible the the pool could\n+     * attempted only when it appears possible that the pool could\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":21,"deletions":14,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -252,7 +252,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            else {\n-                FailingFibAction f1 = new FailingFibAction(n - 1);\n-                FailingFibAction f2 = new FailingFibAction(n - 2);\n-                invokeAll(f1, f2);\n-                result = f1.result + f2.result;\n+            if (n > 1) {\n+                try {\n+                    FailingFibAction f1 = new FailingFibAction(n - 1);\n+                    FailingFibAction f2 = new FailingFibAction(n - 2);\n+                    invokeAll(f1, f2);\n+                    result = f1.result + f2.result;\n+                    return;\n+                } catch (CancellationException fallthrough) {\n+                }\n@@ -260,0 +262,1 @@\n+            throw new FJException();\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool19Test.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -235,7 +235,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            else {\n-                FailingFibAction f1 = new FailingFibAction(n - 1);\n-                FailingFibAction f2 = new FailingFibAction(n - 2);\n-                invokeAll(f1, f2);\n-                result = f1.result + f2.result;\n+            if (n > 1) {\n+                try {\n+                    FailingFibAction f1 = new FailingFibAction(n - 1);\n+                    FailingFibAction f2 = new FailingFibAction(n - 2);\n+                    invokeAll(f1, f2);\n+                    result = f1.result + f2.result;\n+                    return;\n+                } catch (CancellationException fallthrough) {\n+                }\n@@ -243,0 +245,1 @@\n+            throw new FJException();\n@@ -405,1 +408,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinPool8Test.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -499,1 +499,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n@@ -1248,1 +1250,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/ForkJoinTaskTest.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -225,7 +225,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            else {\n-                FailingFibAction f1 = new FailingFibAction(n - 1);\n-                FailingFibAction f2 = new FailingFibAction(n - 2);\n-                invokeAll(f1, f2);\n-                result = f1.result + f2.result;\n+            if (n > 1) {\n+                try {\n+                    FailingFibAction f1 = new FailingFibAction(n - 1);\n+                    FailingFibAction f2 = new FailingFibAction(n - 2);\n+                    invokeAll(f1, f2);\n+                    result = f1.result + f2.result;\n+                    return;\n+                } catch (CancellationException fallthrough) {\n+                }\n@@ -233,0 +235,1 @@\n+            throw new FJException();\n@@ -491,1 +494,3 @@\n-                } catch (NullPointerException success) {}\n+                } catch (NullPointerException success) {\n+                    f.join();\n+                }\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/RecursiveActionTest.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -243,5 +243,9 @@\n-            if (n <= 1)\n-                throw new FJException();\n-            FailingFibTask f1 = new FailingFibTask(n - 1);\n-            f1.fork();\n-            return new FibTask(n - 2).compute() + f1.join();\n+            if (n > 1) {\n+                try {\n+                    FailingFibTask f1 = new FailingFibTask(n - 1);\n+                    f1.fork();\n+                    return new FibTask(n - 2).compute() + f1.join();\n+                } catch (CancellationException fallthrough) {\n+                }\n+            }\n+            throw new FJException();\n","filename":"test\/jdk\/java\/util\/concurrent\/tck\/RecursiveTaskTest.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"}]}