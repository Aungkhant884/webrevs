{"files":[{"patch":"@@ -1995,2 +1995,0 @@\n-                                if (parallelism == 0)\n-                                    return false;\n@@ -1999,1 +1997,1 @@\n-                                continue outer;\n+                                return false;\n@@ -2030,2 +2028,3 @@\n-                if ((window = scan(w, window & WMASK, r)) >= 0L) {\n-                    if (((phase = awaitWork(w, phase)) & IDLE) != 0)\n+                if (window == (window = scan(w, window & WMASK, r)) &&\n+                    window >= 0L && phase != (phase = awaitWork(w, phase))) {\n+                    if ((phase & IDLE) != 0)\n@@ -2035,1 +2034,1 @@\n-            }\n+             }\n@@ -2056,1 +2055,1 @@\n-                for (boolean contended = false;;) {\n+                for (;;) {\n@@ -2063,4 +2062,3 @@\n-                            if (a[k] == null) {\n-                                if (!contended && window >= 0L &&\n-                                    (a[nk] != null || q.top - b > 0))\n-                                    window |= RESCAN; \/\/ revisit\n+                            if (a[k] == null) {   \/\/ revisit if another task\n+                                if (window >= 0L && a[nk] != null)\n+                                    window |= RESCAN;\n@@ -2082,3 +2080,2 @@\n-                        else if ((contended = (o == null)) &&\n-                                  (short)(window >>> 16) == INVALID_ID)\n-                            break;               \/\/ contended and newly active\n+                        else if (o == null)       \/\/ contended\n+                            break;                \/\/ retried unless newly active\n@@ -2100,26 +2097,27 @@\n-        long pc = ctl;\n-        int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n-        long qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n-        if (w != null) {                            \/\/ try to inactivate\n-            w.stackPred = (int)pc;                  \/\/ set ctl stack link\n-            w.phase = idlePhase;\n-            if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n-                w.phase = nextPhase;                \/\/ don't wait\n-            else {\n-                boolean quiescent = (qc & RC_MASK) <= 0L && quiescent();\n-                if ((p = w.phase) != nextPhase && (runState & STOP) == 0) {\n-                    WorkQueue[] qs = queues;\n-                    int n = (qs == null) ? 0 : qs.length, k = n | 0x1f;\n-                    while ((p = w.phase) != nextPhase && --k > 0)\n-                        Thread.onSpinWait(); \/\/ spin approx #accesses to signal\n-                    if (p != nextPhase) {           \/\/ recheck queues\n-                        for (int i = 0; i < n; ++i) {\n-                            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n-                            if ((q = qs[i]) != null && (a = q.array) != null &&\n-                                (cap = a.length) > 0 &&\n-                                a[q.base & (cap - 1)] != null) {\n-                                if (ctl == qc && compareAndSetCtl(qc, pc))\n-                                    w.phase = p = nextPhase; \/\/ release\n-                                break;\n-                            }\n-                        }\n+        if (w != null) {\n+            int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n+            long pc = ctl, qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+            w.stackPred = (int)pc;                   \/\/ set ctl stack link\n+            w.phase = idlePhase;                     \/\/ try to inactivate\n+            if (!compareAndSetCtl(pc, qc))           \/\/ contended enque\n+                return w.phase = p;                  \/\/ back out\n+            int ac = (short)(qc >>> RC_SHIFT);\n+            boolean quiescent = (ac <= 0 && quiescent());\n+            if ((runState & STOP) != 0)\n+                return idlePhase;\n+            int spins = ac + ((((int)(qc >>> TC_SHIFT)) & SMASK) << 1);\n+            while ((p = w.phase) == idlePhase && --spins > 0)\n+                Thread.onSpinWait();  \/\/ spin for approx #accesses to signal\n+            if (p == idlePhase) {\n+                long deadline = (!quiescent ? 0L :   \/\/ timeout for trim\n+                                 System.currentTimeMillis() + keepAlive);\n+                WorkQueue[] qs = queues;\n+                int n = (qs == null) ? 0 : qs.length;\n+                for (int i = 0; i < n; ++i) {        \/\/ recheck queues\n+                    WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+                    if ((q = qs[i]) != null &&\n+                        (a = q.array) != null && (cap = a.length) > 0 &&\n+                        a[q.base & (cap - 1)] != null &&\n+                        ctl == qc && compareAndSetCtl(qc, pc)) {\n+                        w.phase = (int)qc;           \/\/ release\n+                        break;\n@@ -2127,12 +2125,19 @@\n-                    if (p != nextPhase && (p = w.phase) != nextPhase) {\n-                        long deadline = (!quiescent ? 0L : \/\/ timeout for trim\n-                                         keepAlive + System.currentTimeMillis());\n-                        LockSupport.setCurrentBlocker(this);\n-                        w.parker = Thread.currentThread();\n-                        for (;;) {                  \/\/ emulate LockSupport.park\n-                            if ((runState & STOP) != 0 ||\n-                                (p = w.phase) == nextPhase)\n-                                break;\n-                            U.park(quiescent, deadline);\n-                            if ((p = w.phase) == nextPhase ||\n-                                (runState & STOP) != 0)\n+                }\n+                if ((p = w.phase) == idlePhase) {    \/\/ emulate LockSupport.park\n+                    LockSupport.setCurrentBlocker(this);\n+                    w.parker = Thread.currentThread();\n+                    for (;;) {\n+                        if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n+                            break;\n+                        U.park(quiescent, deadline);\n+                        if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n+                            break;\n+                        Thread.interrupted();        \/\/ clear for next park\n+                        if (quiescent && TIMEOUT_SLOP >\n+                            deadline - System.currentTimeMillis()) {\n+                            long sp = w.stackPred & LMASK;\n+                            long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n+                            if (((int)c & SMASK) == (idlePhase & SMASK) &&\n+                                compareAndSetCtl(c, nc)) {\n+                                w.source = DEREGISTERED;\n+                                w.phase = (int)c;\n@@ -2140,13 +2145,0 @@\n-                            Thread.interrupted();   \/\/ clear status for next park\n-                            if (quiescent && TIMEOUT_SLOP >\n-                                deadline - System.currentTimeMillis()) {\n-                                int id = idlePhase & SMASK;\n-                                long sp = w.stackPred & LMASK;\n-                                long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n-                                if (((int)c & SMASK) == id &&\n-                                    compareAndSetCtl(c, nc)) {\n-                                    w.source = DEREGISTERED; \/\/ sentinel\n-                                    w.phase = nextPhase;\n-                                    break;          \/\/ trim on timeout\n-                                }\n-                                deadline += keepAlive; \/\/ not head; restart timer\n@@ -2154,0 +2146,1 @@\n+                            deadline += keepAlive;   \/\/ not head; reset timer\n@@ -2155,2 +2148,0 @@\n-                        w.parker = null;\n-                        LockSupport.setCurrentBlocker(null);\n@@ -2158,0 +2149,2 @@\n+                    w.parker = null;\n+                    LockSupport.setCurrentBlocker(null);\n@@ -3285,1 +3278,1 @@\n-     * Uninterrupible version of {@code InvokeAll}. Executes the given\n+     * Uninterrupible version of {@code invokeAll}. Executes the given\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":61,"deletions":68,"binary":false,"changes":129,"status":"modified"}]}