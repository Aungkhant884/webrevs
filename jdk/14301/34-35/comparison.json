{"files":[{"patch":"@@ -579,7 +579,7 @@\n-     *   top-level polls (argument \"window\" in method scan) as an\n-     *   encoded sliding window of the last two sources, and stop\n-     *   signalling when the last two were from the same source. And\n-     *   similarly not retry when two CAS failures were from the same\n-     *   source.  These mechanisms may result in transiently too few\n-     *   workers, but once workers poll from a new source, they\n-     *   rapidly reactivate others.\n+     *   top-level polls (argument \"srcs\" in method scan, with setup\n+     *   in method runWorker) as an encoded sliding window of current\n+     *   and previous two sources, and stop signalling when all were\n+     *   from the same source. And similarly not retry under multiple\n+     *   CAS failures by newly activated workers.  These mechanisms\n+     *   may result in transiently too few workers, but once workers\n+     *   poll from a new source, they rapidly reactivate others.\n@@ -607,2 +607,1 @@\n-     * contention, as well as resetting origins to random values upon\n-     * any runState change.\n+     * contention.\n@@ -624,1 +623,4 @@\n-     * near-miss scenarios for inactivate\/activate races.\n+     * near-miss scenarios for inactivate\/activate races.  Because idle\n+     * workers are often not yet blocked (parked), we use the\n+     * WorkQueue parker field to advertise that a waiter actually\n+     * needs unparking upon signal.\n@@ -636,23 +638,18 @@\n-     * others including tryCompensate. Method isQuiescent() is used in\n-     * all of these contexts. It provides checks that all workers are\n-     * idle and there are no submissions that they could poll if they\n-     * were not idle, retrying on inconsistent reads of queues and\n-     * using the runState seqLock to retry on queue array updates.  (It\n-     * also reports quiescence if the pool is terminating.) A true\n-     * report means only that there was a moment at which quiescence\n-     * held.  False negatives are inevitable (for example when queues\n-     * indices lag updates, as described above), which is accommodated\n-     * when (tentatively) idle by scanning for work etc, and then\n-     * re-invoking. This includes cases in which the final unparked\n-     * thread (in awaitWork) uses isQuiescent() to check for tasks\n-     * that could have been added during a race window that would not\n-     * be accompanied by a signal, in which case re-activating itself\n-     * (or any other worker) to rescan. Method helpQuiesce acts\n-     * similarly but cannot rely on ctl counts to determine that all\n-     * workers are inactive because the caller and any others\n-     * executing helpQuiesce are not included in counts.\n-     *\n-     * The quiescence check in awaitWork also serves as a safeguard\n-     * when all other workers gave up prematurely and inactivated (due\n-     * to excessive contention) which will cause this thread to rescan\n-     * and wake up others.\n+     * others including tryCompensate. Method quiescent() is\n+     * used in all of these contexts. It provides checks that all\n+     * workers are idle and there are no submissions that they could\n+     * poll if they were not idle, retrying on inconsistent reads of\n+     * queues and using the runState seqLock to retry on queue array\n+     * updates.  (It also reports quiescence if the pool is\n+     * terminating.) A true report means only that there was a moment\n+     * at which quiescence held.  False negatives are inevitable (for\n+     * example when queues indices lag updates, as described above),\n+     * which is accommodated when (tentatively) idle by scanning for\n+     * work etc, and then re-invoking. This includes cases in which\n+     * the final unparked thread (in awaitWork) uses quiescent()\n+     * to check for tasks that could have been added during a race\n+     * window that would not be accompanied by a signal, in which case\n+     * re-activating itself (or any other worker) to rescan. Method\n+     * helpQuiesce acts similarly but cannot rely on ctl counts to\n+     * determine that all workers are inactive because the caller and\n+     * any others executing helpQuiesce are not included in counts.\n@@ -676,4 +673,0 @@\n-     * Parallelizing termination provides multiple attempts to cancel\n-     * tasks and workers when some are only boundedly unresponsive, in\n-     * addition to speeding termination when there are large numbers\n-     * of tasks that need to be cancelled.\n@@ -802,7 +795,7 @@\n-     * some System property parsing and with security processing that\n-     * takes far longer than the actual construction when\n-     * SecurityManagers are used or properties are set. The common\n-     * pool is distinguished by having a null workerNamePrefix (which\n-     * is an odd convention, but avoids the need to decode status in\n-     * factory classes).  It also has PRESET_SIZE config set if\n-     * parallelism was configured by system property.\n+     * some System property parsing and security processing that takes\n+     * far longer than the actual construction when SecurityManagers\n+     * are used or properties are set. The common pool is\n+     * distinguished by having a null workerNamePrefix (which is an\n+     * odd convention, but avoids the need to decode status in factory\n+     * classes).  It also has PRESET_SIZE config set if parallelism\n+     * was configured by system property.\n@@ -974,1 +967,1 @@\n-     * * Method isQuiescent() replaces previous quiescence-related\n+     * * Method quiescent() replaces previous quiescence-related\n@@ -1031,1 +1024,0 @@\n-    static final int RS_EPOCH         = 1 <<  4;   \/\/ version counter tag\n@@ -1043,0 +1035,6 @@\n+    \/\/ source history window packing used in scan() and runWorker()\n+    static final long WMASK           = ((long)SMASK) << 48; \/\/ must be negative\n+    static final long RESCAN          = 1L << 63;\n+    static final long RAN             = 1L << 62;\n+    static final long INVALID_HISTORY = ((((long)INVALID_ID) << 32) | \/\/ no 3rd\n+                                         (((long)INVALID_ID) << 16)); \/\/ no 2nd\n@@ -1047,1 +1045,0 @@\n-    static final long RESCAN          = 1L << 63; \/\/ window retry indicator\n@@ -1215,0 +1212,1 @@\n+        volatile Thread parker;    \/\/ set when parking in awaitWork\n@@ -1218,0 +1216,1 @@\n+        volatile int closed;       \/\/ nonzero if pool terminating or deregistered\n@@ -1237,0 +1236,1 @@\n+        private static final long CLOSED;\n@@ -1299,1 +1299,1 @@\n-            int s = top++, cap, m, d; ForkJoinTask<?>[] a;\n+            int s = top++, cap, m; ForkJoinTask<?>[] a;\n@@ -1301,1 +1301,1 @@\n-                if ((d = (m = cap - 1) - (s - base)) == 0)\n+                if ((m = cap - 1) == s - base)\n@@ -1311,0 +1311,2 @@\n+                    if (a[m & (s - 1)] == null && pool != null)\n+                        pool.signalWork();\n@@ -1312,2 +1314,0 @@\n-                if ((d == 0 || a[m & (s - 1)] == null) && pool != null)\n-                    pool.signalWork();\n@@ -1632,0 +1632,22 @@\n+        \/**\n+         * Unless already closed, sets closed status, cancels tasks,\n+         * and interrupts if a worker\n+         *\/\n+        final void close() {\n+            Thread o;\n+            if (closed == 0 && U.getAndSetInt(this, CLOSED, 1) == 0) {\n+                if ((o = owner) != null) {\n+                    try {\n+                        o.interrupt();\n+                    } catch (Throwable ignore) {\n+                    }\n+                }\n+                for (ForkJoinTask<?> t; (t = poll(null)) != null; ) {\n+                    try {\n+                        t.cancel(false);\n+                    } catch (Throwable ignore) {\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -1650,0 +1672,1 @@\n+            CLOSED = U.objectFieldOffset(klass, \"closed\");\n@@ -1742,1 +1765,1 @@\n-    private void unlockRunState() {            \/\/ increment lock bit\n+    private void unlockRunState() {              \/\/ increment lock bit\n@@ -1745,2 +1768,2 @@\n-    private int lockRunState() {             \/\/ lock and return current state\n-        int s, u;                            \/\/ locked when RS_LOCK set\n+    private int lockRunState() {                \/\/ lock and return current state\n+        int s, u;                               \/\/ locked when RS_LOCK set\n@@ -1878,0 +1901,1 @@\n+            w.closed = 1;\n@@ -1880,2 +1904,1 @@\n-                w.source = DEREGISTERED;\n-                if (phase != 0) {             \/\/ else failed to start\n+                if (phase != 0) {         \/\/ else failed to start\n@@ -1884,1 +1907,1 @@\n-                        reactivate(w);        \/\/ pool stopped before released\n+                        reactivate(w);    \/\/ pool stopped before released\n@@ -1947,0 +1970,1 @@\n+                    Thread t;\n@@ -1948,1 +1972,2 @@\n-                    U.unpark(v.owner);\n+                    if ((t = v.parker) != null)\n+                        U.unpark(t);\n@@ -1969,0 +1994,1 @@\n+                Thread t;\n@@ -1970,1 +1996,2 @@\n-                U.unpark(v.owner);\n+                if ((t = v.parker) != null)\n+                    U.unpark(t);\n@@ -1980,4 +2007,2 @@\n-     * submission queues are empty and unlocked, else ensure at least\n-     * one worker is active (if any exist)\n-     * @param transition trigger termination or advance generation if\n-     * quiescent\n+     * submission queues are empty and unlocked; if so, setting STOP\n+     * if shutdown is enabled\n@@ -1985,1 +2010,1 @@\n-    private boolean isQuiescent(boolean transition) {\n+    private boolean quiescent() {\n@@ -1989,2 +2014,1 @@\n-            recheck: for (int e, prevRunState = 0; ; prevRunState = e) {\n-                U.fullFence();\n+            for (int e, prevRunState = 0; ; prevRunState = e) {\n@@ -2001,5 +2025,6 @@\n-                        int p = e; WorkQueue q;\n-                        if ((q = qs[i]) != null &&\n-                            (((p = q.phase) & IDLE) == 0 ||\n-                             q.top - q.base > 0)) {\n-                            if (parallelism == 0)\n+                        int p; WorkQueue q;\n+                        if ((q = qs[i]) != null) {\n+                            if (((p = q.phase) & IDLE) == 0 ||\n+                                q.top - q.base > 0) {\n+                                if ((i & 1) == 0)\n+                                    signalWork();         \/\/ ensure live\n@@ -2007,2 +2032,2 @@\n-                            signalWork();                 \/\/ ensure live\n-                            break recheck;                \/\/ restart\n+                            }\n+                            sum += p & 0xffffffffL;\n@@ -2010,1 +2035,0 @@\n-                        sum += p & 0xffffffffL;\n@@ -2015,3 +2039,1 @@\n-                         casRunState(e, !transition ? e :\n-                                     (e & SHUTDOWN) != 0 ? e | STOP :\n-                                     e + RS_EPOCH))       \/\/ advance\n+                         casRunState(e, (e & SHUTDOWN) != 0 ? e | STOP : e))\n@@ -2034,19 +2056,14 @@\n-            long next = 0L;\n-            for (int e = 0;;) {\n-                int window;      \/\/ encodes origin and previous non-empty queue\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5; \/\/ xorshift\n-                if (e != (e = runState)) {\n-                    if ((e & STOP) != 0)          \/\/ terminating\n-                        break;                    \/\/ else use random origin\n-                    window = (INVALID_ID << 16) | (r >>> 16);\n-                }\n-                else\n-                    window = (int)next;           \/\/ continue from last scan\n-                if ((next = scan(w, window, (r << 1) | 1)) >= 0L) {\n-                    int idlePhase = phase + IDLE; \/\/ try to inactivate\n-                    long np = (phase + (IDLE << 1)) & LMASK;\n-                    long pc = ctl, qc = ((pc - RC_UNIT) & UMASK) | np;\n-                    w.stackPred = (int)pc;        \/\/ set ctl stack link\n-                    w.phase = idlePhase;          \/\/ try to enqueue\n-                    if (pc != compareAndExchangeCtl(pc, qc))\n-                        w.phase = phase;          \/\/ back out on contention\n+            for (long window = INVALID_HISTORY | (r >>> 16);;) {\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5;  \/\/ xorshift\n+                if ((runState & STOP) != 0)                \/\/ terminating\n+                    break;\n+                if ((window == (window = scan(w, window, r))) &&\n+                    window >= 0L) {                        \/\/ empty scan\n+                    long c = ctl;                          \/\/ try to inactivate\n+                    int idlePhase = phase + IDLE;\n+                    long qc = (((phase + (IDLE << 1)) & LMASK) |\n+                               ((c - RC_UNIT) & UMASK));\n+                    w.stackPred = (int)c;                  \/\/ set ctl stack link\n+                    w.phase = idlePhase;\n+                    if (!compareAndSetCtl(c, qc))\n+                        w.phase = phase;                   \/\/ contended; back out\n@@ -2054,1 +2071,3 @@\n-                        break;                    \/\/ worker exit\n+                        break;                             \/\/ worker exit\n+                    else                                   \/\/ clear history\n+                        window = INVALID_HISTORY | (window & SMASK);\n@@ -2063,1 +2082,1 @@\n-     * returning scan window and retry indicator.\n+     * returning next scan window and retry indicator.\n@@ -2066,3 +2085,3 @@\n-     * @param window encodes up to two previously non-empty scanned queues\n-     * @param step random array stride\n-     * @return the next window value to use, with highest bit set for rescan\n+     * @param window up to three queue indices and RAN indicator from last scan\n+     * @param r random seed\n+     * @return the next window value to use, nonnegative if empty\n@@ -2070,1 +2089,1 @@\n-    private long scan(WorkQueue w, int window, int step) {\n+    private long scan(WorkQueue w, long window, int r) {\n@@ -2072,3 +2091,5 @@\n-        int n = (qs == null) ? 0 : qs.length;\n-        long next = window & LMASK;               \/\/ default for empty scan\n-        outer: for (int i = window, l = n; l > 0; --l, i += step) {\n+        int n = (qs == null) ? 0 : qs.length, step = (r << 1) | 1;\n+        int i = (short)window;                    \/\/ origin\n+        boolean running = (window & RAN) != 0L;   \/\/ true if last scan succeeded\n+        long next = window &= ~WMASK;             \/\/ default for empty scan\n+        outer: for (int l = n; l > 0; --l, i += step) {\n@@ -2078,1 +2099,2 @@\n-                for (int b, k;;) {\n+                for (boolean contended = false;;) {\n+                    int b, k;\n@@ -2085,0 +2107,6 @@\n+                            if (q.array != a) {   \/\/ resized\n+                                next |= RESCAN;\n+                                break;\n+                            }\n+                            if (contended)        \/\/ reduce incoming contention\n+                                break;\n@@ -2086,1 +2114,1 @@\n-                                if ((next & RESCAN) == 0L &&\n+                                if (next >= 0L &&\n@@ -2093,1 +2121,1 @@\n-                                           a, slotOffset(k), t, null))) {\n+                                            a, slotOffset(k), t, null))) {\n@@ -2095,1 +2123,3 @@\n-                            if (window != (window = (window << 16) | j) &&\n+                            long nw = ((window << 16) | j) & ~WMASK;\n+                            next = nw | (RESCAN | RAN);\n+                            if ((window != nw || (short)(nw >> 32) != j) &&\n@@ -2097,2 +2127,1 @@\n-                                signalWork();     \/\/ propagate at most twice\/run\n-                            next = (window & LMASK) | RESCAN;\n+                                signalWork();     \/\/ limit propagation\n@@ -2103,9 +2132,2 @@\n-                        else if (o == null) {     \/\/ contended; limit rescans\n-                            int qw = (window << 16) | j;\n-                            if ((next & RESCAN) == 0L &&\n-                                (q.array != a ||  \/\/ resized\n-                                 (qw != window &&\n-                                  (a[nk] != null || q.top - q.base > 0))))\n-                                next = (qw & LMASK) | RESCAN;\n-                            break;\n-                        }\n+                        else if (!running)\n+                            contended = (o == null);\n@@ -2128,9 +2150,5 @@\n-        boolean quiescent = (queuedCtl & RC_MASK) <= 0L && isQuiescent(true);\n-        if (w != null && (p = w.phase) == idlePhase && (runState & STOP) == 0) {\n-            long deadline = (quiescent ?        \/\/ timeout for trim\n-                             keepAlive + System.currentTimeMillis() : 0L);\n-            int spins = ((((int)(queuedCtl >>> TC_SHIFT)) & SMASK) << 1) + 3;\n-            do {                      \/\/ spin for approx #accesses to scan+signal\n-                Thread.onSpinWait();\n-            } while ((p = w.phase) == idlePhase && --spins >= 0);\n-\n+        int spins = ((((int)(queuedCtl >>> TC_SHIFT)) & SMASK) << 1) | 0x2f;\n+        boolean quiescent = (queuedCtl & RC_MASK) <= 0L && quiescent();\n+        if (w != null && (runState & STOP) == 0) {\n+            while ((p = w.phase) == idlePhase && --spins > 0)\n+                Thread.onSpinWait(); \/\/ spin for approx #accesses to scan+signal\n@@ -2138,0 +2156,2 @@\n+                long deadline = (quiescent ?    \/\/ timeout for trim\n+                                 keepAlive + System.currentTimeMillis() : 0L);\n@@ -2139,0 +2159,1 @@\n+                w.parker = Thread.currentThread();\n@@ -2140,1 +2161,1 @@\n-                    if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n+                    if ((p = w.phase) != idlePhase)\n@@ -2143,1 +2164,1 @@\n-                    if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n+                    if ((p = w.phase) != idlePhase)\n@@ -2146,0 +2167,2 @@\n+                    if ((runState & STOP) != 0)\n+                        break;\n@@ -2159,0 +2182,1 @@\n+                w.parker = null;\n@@ -2212,1 +2236,1 @@\n-            WorkQueue[] qs; WorkQueue v; int i;\n+            WorkQueue[] qs; WorkQueue v; int i; Thread t;\n@@ -2217,1 +2241,2 @@\n-                U.unpark(v.owner);\n+                if ((t = v.parker) != null)\n+                    U.unpark(t);\n@@ -2517,1 +2542,1 @@\n-        if (!isQuiescent(false)) {\n+        if (!quiescent()) {\n@@ -2528,1 +2553,1 @@\n-                else if (isQuiescent(false))\n+                else if (quiescent())\n@@ -2541,0 +2566,1 @@\n+        tryTerminate(false, false);\n@@ -2759,1 +2785,1 @@\n-                if (isShutdown != 0 && isQuiescent(true))\n+                if (isShutdown != 0 && quiescent())\n@@ -2763,3 +2789,2 @@\n-        if ((e & (STOP | TERMINATED)) == STOP) {\n-            int r = (int)Thread.currentThread().threadId(); \/\/ stagger traversals\n-            WorkQueue[] qs = queues;\n+        if ((e & (STOP | TERMINATED)) == STOP) { \/\/ help terminate\n+            WorkQueue[] qs = queues; WorkQueue q;\n@@ -2767,17 +2792,3 @@\n-            for (int l = n; l > 0; --l, ++r) {\n-                int j; WorkQueue q; Thread o; \/\/ cancel tasks; interrupt workers\n-                if ((q = qs[r & SMASK & (n - 1)]) != null &&\n-                    q.source != DEREGISTERED) {\n-                    if ((o = q.owner) != null) {\n-                        try {\n-                            o.interrupt();\n-                        } catch (Throwable ignore) {\n-                        }\n-                    }\n-                    for (ForkJoinTask<?> t; (t = q.poll(null)) != null; ) {\n-                        try {\n-                            t.cancel(false);\n-                        } catch (Throwable ignore) {\n-                        }\n-                    }\n-                }\n+            for (int i = 0; i < n; ++i) {\n+                if ((q = qs[i]) != null)\n+                    q.close();\n@@ -3467,1 +3478,1 @@\n-        return isQuiescent(false);\n+        return quiescent();\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":168,"deletions":157,"binary":false,"changes":325,"status":"modified"}]}