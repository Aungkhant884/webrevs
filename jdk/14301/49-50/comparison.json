{"files":[{"patch":"@@ -616,12 +616,12 @@\n-     * is OK, given the above signalling rules that will eventually\n-     * maintain progress.  Blocking and unblocking via park\/unpark can\n-     * cause serious slowdowns when tasks are rapidly but irregularly\n-     * generated (which is often due to garbage collectors and other\n-     * activities). One way to ameliorate is for workers to rescan\n-     * multiple times, even when there are unlikely to be tasks. But\n-     * this causes enough memory traffic and CAS contention to prefer\n-     * using quieter short spinwaits in awaitWork and elsewhere.\n-     * Those in awaitWork are set to small values that only cover\n-     * near-miss scenarios for inactivate\/activate races.  Because idle\n-     * workers are often not yet blocked (parked), we use the\n-     * WorkQueue parker field to advertise that a waiter actually\n+     * is OK given, a secondary check (in awaitWork) needed to cover\n+     * deactivation\/signal races. Blocking and unblocking via\n+     * park\/unpark can cause serious slowdowns when tasks are rapidly\n+     * but irregularly generated (which is often due to garbage\n+     * collectors and other activities). One way to ameliorate is for\n+     * workers to rescan multiple times, even when there are unlikely\n+     * to be tasks. But this causes enough memory traffic and CAS\n+     * contention to prefer using quieter short spinwaits in awaitWork\n+     * and elsewhere.  Those in awaitWork are set to small values that\n+     * only cover near-miss scenarios for inactivate\/activate races.\n+     * Because idle workers are often not yet blocked (parked), we use\n+     * the WorkQueue parker field to advertise that a waiter actually\n@@ -2027,2 +2027,2 @@\n-                r ^= r << 13; r ^= r >>> 17; r ^= r << 5;  \/\/ xorshift\n-                if ((runState & STOP) != 0)                \/\/ terminating\n+                r ^= r << 13; r ^= r >>> 17; r ^= r << 5;   \/\/ xorshift\n+                if ((runState & STOP) != 0)                 \/\/ terminating\n@@ -2030,14 +2030,4 @@\n-                if (window == (window = scan(w, window & WMASK, r)) &&\n-                    window >= 0L) {                        \/\/ empty scan\n-                    long c = ctl;                          \/\/ try to inactivate\n-                    int idlePhase = phase + IDLE;\n-                    long qc = (((phase + (IDLE << 1)) & LMASK) |\n-                               ((c - RC_UNIT) & UMASK));\n-                    w.stackPred = (int)c;                  \/\/ set ctl stack link\n-                    w.phase = idlePhase;\n-                    if (!compareAndSetCtl(c, qc))\n-                        w.phase = phase;                   \/\/ contended; back out\n-                    else if ((phase = awaitWork(w, qc, idlePhase)) == idlePhase)\n-                        break;                             \/\/ worker exit\n-                    else                                   \/\/ clear history\n-                        window = NO_HISTORY | (window & SMASK);\n+                if ((window = scan(w, window & WMASK, r)) >= 0L) {\n+                    if (((phase = awaitWork(w, phase)) & IDLE) != 0)\n+                        break;                              \/\/ worker exit\n+                    window = NO_HISTORY | (window & SMASK); \/\/ clear history\n@@ -2087,1 +2077,0 @@\n-                            if (nw != pw && a[nk] != null)\n@@ -2104,1 +2093,1 @@\n-     * Awaits signal or termination.\n+     * Tries to inactivate, and if successful, awaits signal or termination.\n@@ -2106,3 +2095,3 @@\n-     * @param queuedCtl ctl at point of inactivation\n-     * @param idlePhase w's phase while idle\n-     * @return current phase, same as idlePhase for exit\n+     * @param w the worker (may be null if already terminated)\n+     * @param p current phase\n+     * @return current phase, with IDLE set if worker should exit\n@@ -2110,28 +2099,55 @@\n-    private int awaitWork(WorkQueue w, long queuedCtl, int idlePhase) {\n-        int p = idlePhase;\n-        int spins = ((((int)(queuedCtl >>> TC_SHIFT)) & SMASK) << 1) | 0x2f;\n-        boolean quiescent = (queuedCtl & RC_MASK) <= 0L && quiescent();\n-        if (w != null && (runState & STOP) == 0) {\n-            while ((p = w.phase) == idlePhase && --spins > 0)\n-                Thread.onSpinWait(); \/\/ spin for approx #accesses to scan+signal\n-            if (p == idlePhase) {               \/\/ emulate LockSupport.park\n-                long deadline = (quiescent ?    \/\/ timeout for trim\n-                                 keepAlive + System.currentTimeMillis() : 0L);\n-                LockSupport.setCurrentBlocker(this);\n-                w.parker = Thread.currentThread();\n-                for (;;) {\n-                    if ((runState & STOP) != 0 || (p = w.phase) != idlePhase)\n-                        break;\n-                    U.park(quiescent, deadline);\n-                    if ((p = w.phase) != idlePhase || (runState & STOP) != 0)\n-                        break;\n-                    Thread.interrupted();       \/\/ clear status for next park\n-                    if (quiescent &&            \/\/ trim on timeout\n-                        deadline - System.currentTimeMillis() < TIMEOUT_SLOP) {\n-                        int id = idlePhase & SMASK;\n-                        long sp = w.stackPred & LMASK;\n-                        long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n-                        if (((int)c & SMASK) == id && compareAndSetCtl(c, nc)) {\n-                            w.source = DEREGISTERED; \/\/ deregisterWorker sentinel\n-                            w.phase = idlePhase + IDLE;\n-                            break;\n+    private int awaitWork(WorkQueue w, int p) {\n+        long pc = ctl;\n+        int idlePhase = p + IDLE, nextPhase = p + (IDLE << 1);\n+        long qc = (nextPhase & LMASK) | ((pc - RC_UNIT) & UMASK);\n+        if (w != null) {                            \/\/ try to inactivate\n+            w.stackPred = (int)pc;                  \/\/ set ctl stack link\n+            w.phase = idlePhase;\n+            if (!compareAndSetCtl(pc, qc))          \/\/ contended enque\n+                w.phase = nextPhase;                \/\/ don't wait\n+            else {\n+                boolean quiescent = (qc & RC_MASK) <= 0L && quiescent();\n+                if ((p = w.phase) != nextPhase && (runState & STOP) == 0) {\n+                    WorkQueue[] qs = queues;\n+                    int n = (qs == null) ? 0 : qs.length, k = n | 0x1f;\n+                    while ((p = w.phase) != nextPhase && --k > 0)\n+                        Thread.onSpinWait(); \/\/ spin approx #accesses to signal\n+                    if (p != nextPhase) {           \/\/ recheck queues\n+                        for (int i = 0; i < n; ++i) {\n+                            WorkQueue q; ForkJoinTask<?>[] a; int cap;\n+                            if ((q = qs[i]) != null && (a = q.array) != null &&\n+                                (cap = a.length) > 0 &&\n+                                a[q.base & (cap - 1)] != null) {\n+                                if (ctl == qc && compareAndSetCtl(qc, pc))\n+                                    w.phase = p = nextPhase; \/\/ release\n+                                break;\n+                            }\n+                        }\n+                    }\n+                    if (p != nextPhase && (p = w.phase) != nextPhase) {\n+                        long deadline = (!quiescent ? 0L : \/\/ timeout for trim\n+                                         keepAlive + System.currentTimeMillis());\n+                        LockSupport.setCurrentBlocker(this);\n+                        w.parker = Thread.currentThread();\n+                        for (;;) {                  \/\/ emulate LockSupport.park\n+                            if ((runState & STOP) != 0 ||\n+                                (p = w.phase) == nextPhase)\n+                                break;\n+                            U.park(quiescent, deadline);\n+                            if ((p = w.phase) == nextPhase ||\n+                                (runState & STOP) != 0)\n+                                break;\n+                            Thread.interrupted();   \/\/ clear status for next park\n+                            if (quiescent && TIMEOUT_SLOP >\n+                                deadline - System.currentTimeMillis()) {\n+                                int id = idlePhase & SMASK;\n+                                long sp = w.stackPred & LMASK;\n+                                long c = ctl, nc = sp | (UMASK & (c - TC_UNIT));\n+                                if (((int)c & SMASK) == id &&\n+                                    compareAndSetCtl(c, nc)) {\n+                                    w.source = DEREGISTERED; \/\/ sentinel\n+                                    w.phase = nextPhase;\n+                                    break;          \/\/ trim on timeout\n+                                }\n+                                deadline += keepAlive; \/\/ not head; restart timer\n+                            }\n@@ -2139,1 +2155,2 @@\n-                        deadline += keepAlive;  \/\/ not at head; restart timer\n+                        w.parker = null;\n+                        LockSupport.setCurrentBlocker(null);\n@@ -2142,2 +2159,0 @@\n-                w.parker = null;\n-                LockSupport.setCurrentBlocker(null);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":79,"deletions":64,"binary":false,"changes":143,"status":"modified"}]}