{"files":[{"patch":"@@ -55,0 +55,1 @@\n+import java.util.concurrent.locks.Lock;\n@@ -194,1 +195,1 @@\n- * negative caching TTL value when needed.\n+ * negative caching TTL value when needed or extend the usage of the stale data.\n@@ -196,1 +197,1 @@\n- * <p> Two Java security properties control the TTL values used for\n+ * <p> Three Java security properties control the TTL values used for\n@@ -208,0 +209,18 @@\n+ * <dt><b>networkaddress.cache.stale.ttl<\/b><\/dt>\n+ * <dd>Indicates the caching policy for stale names. The value is specified as\n+ * an integer to indicate the number of seconds the stale names will be kept in\n+ * the cache. The name is considered stale if it expired and attempts to refresh\n+ * it were unsuccessful. This property is useful if it is preferable to use a\n+ * stale name rather than result of unsuccessful name lookup. The default\n+ * setting is to cache for an implementation specific period of time.\n+ * <p>\n+ * If the value of this property is larger than \"networkaddress.cache.ttl\" then\n+ * \"networkaddress.cache.ttl\" will be used as a refresh interval of the name in\n+ * the cache. For example, if this property is set to 1 day and\n+ * \"networkaddress.cache.ttl\" is set to 30 seconds, then the positive response\n+ * will be cached for 1 day but an attempt to refresh it will be done every\n+ * 30 seconds.\n+ * <p>\n+ * A value of 0 (zero) or if the property is not set means do not use stale\n+ * names. Negative values are ignored.\n+ * <\/dd>\n@@ -936,1 +955,1 @@\n-    private static final NavigableSet<CachedAddresses> expirySet =\n+    private static final NavigableSet<CachedLookup> expirySet =\n@@ -944,2 +963,5 @@\n-    \/\/ a holder for cached addresses with required metadata\n-    private static final class CachedAddresses  implements Addresses, Comparable<CachedAddresses> {\n+    \/**\n+     * A cached result of a name service lookup. The result can be either valid\n+     * addresses or invalid (ie a failed lookup) containing no addresses.\n+     *\/\n+    private static class CachedLookup implements Addresses, Comparable<CachedLookup> {\n@@ -948,2 +970,6 @@\n-        final InetAddress[] inetAddresses;\n-        final long expiryTime; \/\/ time of expiry (in terms of System.nanoTime())\n+        volatile InetAddress[] inetAddresses;\n+        \/**\n+         * Time of expiry (in terms of System.nanoTime()). Can be modified only\n+         * when the record is not added to the \"expirySet\".\n+         *\/\n+        volatile long expiryTime;\n@@ -952,1 +978,1 @@\n-        CachedAddresses(String host, InetAddress[] inetAddresses, long expiryTime) {\n+        CachedLookup(String host, InetAddress[] inetAddresses, long expiryTime) {\n@@ -967,1 +993,1 @@\n-        public int compareTo(CachedAddresses other) {\n+        public int compareTo(CachedLookup other) {\n@@ -978,0 +1004,100 @@\n+\n+        \/**\n+         * Checks if the current cache record is expired or not. Expired records\n+         * are removed from the expirySet and cache.\n+         *\n+         * @return {@code true} if the record was removed\n+         *\/\n+        public boolean tryRemoveExpiredAddress(long now) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((expiryTime - now) < 0L) {\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(this)) {\n+                    \/\/ ... remove from cache\n+                    cache.remove(host, this);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * A cached valid lookup containing addresses whose validity may be\n+     * temporarily extended by an additional stale period pending the mapping\n+     * being refreshed or updated.\n+     *\/\n+    private static final class ValidCachedLookup extends CachedLookup {\n+        \/**\n+         * Time to refresh (in terms of System.nanoTime()).\n+         *\/\n+        private volatile long refreshTime;\n+        \/**\n+         * For how long the stale data should be used after TTL expiration.\n+         * Initially equal to the expiryTime, but increased over time after each\n+         * successful lookup.\n+         *\/\n+        private volatile long staleTime;\n+\n+        \/**\n+         * only one thread is doing lookup to name service\n+         * for particular host at any time.\n+         *\/\n+        private final Lock lookupLock = new ReentrantLock();\n+\n+        ValidCachedLookup(String host, InetAddress[] inetAddresses,\n+                          long staleTime, long refreshTime)\n+        {\n+            super(host, inetAddresses, staleTime);\n+            this.refreshTime = refreshTime;\n+            this.staleTime = staleTime;\n+        }\n+\n+        @Override\n+        public InetAddress[] get() {\n+            long now = System.nanoTime();\n+            if ((refreshTime - now) < 0L && lookupLock.tryLock()) {\n+                try {\n+                    \/\/ cachePolicy is in [s] - we need [ns]\n+                    refreshTime = now + InetAddressCachePolicy.get() * 1000_000_000L;\n+                    \/\/ getAddressesFromNameService returns non-empty\/non-null value\n+                    inetAddresses = getAddressesFromNameService(host);\n+                    \/\/ don't update the \"expirySet\", will do that later\n+                    staleTime = refreshTime + InetAddressCachePolicy.getStale() * 1000_000_000L;\n+                } catch (UnknownHostException ignore) {\n+                } finally {\n+                    lookupLock.unlock();\n+                }\n+            }\n+            return inetAddresses;\n+        }\n+\n+        \/**\n+         * Overrides the parent method to skip deleting the record from the\n+         * cache if the stale data can still be used. Note to update the\n+         * \"expiryTime\" field we have to remove the record from the expirySet\n+         * and add it back. It is not necessary to remove\/add it here, we can do\n+         * that in the \"get()\" method above, but extracting it minimizes\n+         * contention on \"expirySet\".\n+         *\/\n+        @Override\n+        public boolean tryRemoveExpiredAddress(long now) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((expiryTime - now) < 0L) {\n+                if ((staleTime - now) < 0L) {\n+                    return super.tryRemoveExpiredAddress(now);\n+                }\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(this)) {\n+                    expiryTime = staleTime;\n+                    expirySet.add(this);\n+                }\n+            }\n+            return false;\n+        }\n@@ -1024,9 +1150,24 @@\n-                        CachedAddresses cachedAddresses = new CachedAddresses(\n-                            host,\n-                            inetAddresses,\n-                            cachePolicy == InetAddressCachePolicy.FOREVER\n-                            ? 0L\n-                            \/\/ cachePolicy is in [s] - we need [ns]\n-                            : System.nanoTime() + 1000_000_000L * cachePolicy\n-                        );\n-                        if (cache.replace(host, this, cachedAddresses) &&\n+                        long now = System.nanoTime();\n+                        long expiryTime =\n+                                cachePolicy == InetAddressCachePolicy.FOREVER ?\n+                                0L\n+                                \/\/ cachePolicy is in [s] - we need [ns]\n+                                : now + 1000_000_000L * cachePolicy;\n+                        CachedLookup cachedLookup;\n+                        if (InetAddressCachePolicy.getStale() > 0 &&\n+                                ex == null && expiryTime > 0)\n+                        {\n+                            long refreshTime = expiryTime;\n+                            \/\/  staleCachePolicy is in [s] - we need [ns]\n+                            expiryTime = refreshTime + 1000_000_000L *\n+                                    InetAddressCachePolicy.getStale();\n+                            cachedLookup = new ValidCachedLookup(host,\n+                                                                 inetAddresses,\n+                                                                 expiryTime,\n+                                                                 refreshTime);\n+                        } else {\n+                            cachedLookup = new CachedLookup(host,\n+                                                            inetAddresses,\n+                                                            expiryTime);\n+                        }\n+                        if (cache.replace(host, this, cachedLookup) &&\n@@ -1035,1 +1176,1 @@\n-                            expirySet.add(cachedAddresses);\n+                            expirySet.add(cachedLookup);\n@@ -1641,12 +1782,2 @@\n-        for (CachedAddresses caddrs : expirySet) {\n-            \/\/ compare difference of time instants rather than\n-            \/\/ time instants directly, to avoid possible overflow.\n-            \/\/ (see System.nanoTime() recommendations...)\n-            if ((caddrs.expiryTime - now) < 0L) {\n-                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n-                \/\/ so removing while iterating is OK...\n-                if (expirySet.remove(caddrs)) {\n-                    \/\/ ... remove from cache\n-                    cache.remove(caddrs.host, caddrs);\n-                }\n-            } else {\n+        for (CachedLookup caddrs : expirySet) {\n+            if (!caddrs.tryRemoveExpiredAddress(now)) {\n@@ -1665,1 +1796,1 @@\n-                if (addrs instanceof CachedAddresses) {\n+                if (addrs instanceof CachedLookup) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":163,"deletions":32,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,0 +270,8 @@\n+\t<LI><P><B>{@systemProperty networkaddress.cache.stale.ttl}<\/B> (default: see below)<BR>\n+\tValue is an integer corresponding to the number of seconds the stale names\n+\twill be kept in the cache. The name is considered stale if it expired and\n+\tattempts to refresh it were unsuccessful. This property is useful if it is\n+\tpreferable to use a stale name rather than result of unsuccessful name lookup.\n+\tA value of 0 (zero) or if the property is not set means do not use stale\n+\tnames. Negative values are ignored.\n+\tThe default value is implementation-specific.<\/P>\n@@ -276,1 +284,1 @@\n-<P>Since these 2 properties are part of the security policy, they are\n+<P>Since these 3 properties are part of the security policy, they are\n","filename":"src\/java.base\/share\/classes\/java\/net\/doc-files\/net-properties.html","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -39,0 +40,6 @@\n+    \/\/ Controls the cache stale policy for successful lookups only\n+    private static final String cacheStalePolicyProp =\n+        \"networkaddress.cache.stale.ttl\";\n+    private static final String cacheStalePolicyPropFallback =\n+        \"sun.net.inetaddr.stale.ttl\";\n+\n@@ -62,0 +69,9 @@\n+    \/* The Java-level namelookup cache stale policy:\n+     *\n+     * any positive value: the number of seconds to use the stale names\n+     * zero: do not use stale names\n+     *\n+     * default value is never (NEVER).\n+     *\/\n+    private static volatile int staleCachePolicy = NEVER;\n+\n@@ -88,25 +104,1 @@\n-\n-        Integer tmp = java.security.AccessController.doPrivileged(\n-          new PrivilegedAction<Integer>() {\n-            public Integer run() {\n-                try {\n-                    String tmpString = Security.getProperty(cachePolicyProp);\n-                    if (tmpString != null) {\n-                        return Integer.valueOf(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-\n-                try {\n-                    String tmpString = System.getProperty(cachePolicyPropFallback);\n-                    if (tmpString != null) {\n-                        return Integer.decode(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-                return null;\n-            }\n-          });\n-\n+        Integer tmp = getProperty(cachePolicyProp, cachePolicyPropFallback);\n@@ -124,23 +116,2 @@\n-        tmp = java.security.AccessController.doPrivileged (\n-          new PrivilegedAction<Integer>() {\n-            public Integer run() {\n-                try {\n-                    String tmpString = Security.getProperty(negativeCachePolicyProp);\n-                    if (tmpString != null) {\n-                        return Integer.valueOf(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-\n-                try {\n-                    String tmpString = System.getProperty(negativeCachePolicyPropFallback);\n-                    if (tmpString != null) {\n-                        return Integer.decode(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-                return null;\n-            }\n-          });\n+        tmp = getProperty(negativeCachePolicyProp,\n+                          negativeCachePolicyPropFallback);\n@@ -152,0 +123,37 @@\n+        if (cachePolicy > 0) {\n+            tmp = getProperty(cacheStalePolicyProp,\n+                              cacheStalePolicyPropFallback);\n+            if (tmp != null) {\n+                staleCachePolicy = tmp;\n+            }\n+        }\n+    }\n+\n+    private static Integer getProperty(String cachePolicyProp,\n+                                       String cachePolicyPropFallback)\n+    {\n+        return java.security.AccessController.doPrivileged(\n+                new PrivilegedAction<Integer>() {\n+                    public Integer run() {\n+                        try {\n+                            String tmpString = Security.getProperty(\n+                                    cachePolicyProp);\n+                            if (tmpString != null) {\n+                                return Integer.valueOf(tmpString);\n+                            }\n+                        } catch (NumberFormatException ignored) {\n+                            \/\/ Ignore\n+                        }\n+\n+                        try {\n+                            String tmpString = System.getProperty(\n+                                    cachePolicyPropFallback);\n+                            if (tmpString != null) {\n+                                return Integer.decode(tmpString);\n+                            }\n+                        } catch (NumberFormatException ignored) {\n+                            \/\/ Ignore\n+                        }\n+                        return null;\n+                    }\n+                });\n@@ -158,0 +166,4 @@\n+    public static int getStale() {\n+        return staleCachePolicy;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/InetAddressCachePolicy.java","additions":61,"deletions":49,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -360,0 +360,11 @@\n+#\n+# The Java-level namelookup cache stale policy:\n+#\n+# any positive value: the number of seconds to use the stale names\n+# zero: do not use stale names\n+# negative values are ignored\n+#\n+# default value is 0 (NEVER).\n+#\n+#networkaddress.cache.stale.ttl=0\n+\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run testng\/othervm -Djava.security.properties=${test.src}\/NeverCache.props\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/NeverCache.props\n@@ -42,1 +42,19 @@\n- * @run testng\/othervm -Djava.security.properties=${test.src}\/ForeverCache.props\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/ForeverCache.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreMinusStale.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnorePositiveStale.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreZeroStale.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreMinusStale.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnorePositiveStale.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreZeroStale.props\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesCachingTest.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import impl.SimpleResolverProviderImpl;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test that stale InetAddress caching security properties work as\n+ *          expected when a custom resolver is installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry\n+ *  simple.provider\/impl.SimpleResolverProviderImpl AddressesStaleCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/CacheStale.props AddressesStaleCachingTest\n+ *\/\n+public class AddressesStaleCachingTest {\n+\n+    private static class Lookup {\n+        private final byte[] address;\n+        private final long timestamp;\n+\n+        private Lookup(byte[] address, long timestamp) {\n+            this.address = address;\n+            this.timestamp = timestamp;\n+        }\n+    }\n+\n+    \/**\n+     * Validates successful and unsuccessful lookups when the stale cache is\n+     * enabled.\n+     *\/\n+    @Test\n+    public void testRefresh() throws Exception{\n+        \/\/ The first request is to save the data into the cache\n+        Lookup first = doLookup(false, 0);\n+\n+        Thread.sleep(10000); \/\/ intentionally big delay > x2 stale property\n+        \/\/ The refreshTime is expired, we will do the successful lookup.\n+        Lookup second = doLookup(false, 0);\n+        Assert.assertNotEquals(first.timestamp, second.timestamp,\n+                               \"Two lookups are expected\");\n+\n+        Thread.sleep(10000); \/\/ intentionally big delay > x2 stale property\n+        \/\/ The refreshTime is expired again, we will do the failed lookup.\n+        Lookup third = doLookup(true, 0);\n+        Assert.assertNotEquals(second.timestamp, third.timestamp,\n+                               \"Two lookups are expected\");\n+\n+        \/\/ The stale cache is enabled, so we should get valid\/same data for\n+        \/\/ all requests(even for the failed request).\n+        Assert.assertEquals(first.address, second.address,\n+                            \"Same address is expected\");\n+        Assert.assertEquals(second.address, third.address,\n+                            \"Same address is expected\");\n+    }\n+\n+    \/**\n+     * Validates that only one thread is blocked during \"refresh\", all others\n+     * will continue to use the \"stale\" data.\n+     *\/\n+    @Test\n+    public void testOnlyOneThreadIsBlockedDuringRefresh() throws Exception {\n+        long timeout = System.nanoTime() + TimeUnit.SECONDS.toNanos(12);\n+        doLookup(false, timeout);\n+        Thread.sleep(9000);\n+\n+        CountDownLatch blockServer = new CountDownLatch(1);\n+        SimpleResolverProviderImpl.setBlocker(blockServer);\n+\n+        Thread ts[] = new Thread[10];\n+        CountDownLatch wait9 = new CountDownLatch(ts.length - 1);\n+        CountDownLatch wait10 = new CountDownLatch(ts.length);\n+        CountDownLatch start = new CountDownLatch(ts.length);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = new Thread(() -> {\n+                start.countDown();\n+                try {\n+                    start.await();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                doLookup(true, timeout);\n+                wait9.countDown();\n+                wait10.countDown();\n+            });\n+        }\n+        for (Thread t : ts) {\n+            t.start();\n+        }\n+        if (!wait9.await(10, TimeUnit.SECONDS)) {\n+            blockServer.countDown();\n+            throw new RuntimeException(\"Some threads hang\");\n+        }\n+        blockServer.countDown();\n+        if (!wait10.await(10, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"The last thread hangs\");\n+        }\n+    }\n+\n+    private static Lookup doLookup(boolean error, long timeout) {\n+        SimpleResolverProviderImpl.setUnreachableServer(error);\n+        try {\n+            byte[] firstAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n+            long firstTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+\n+            byte[] secondAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n+            long secondTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+\n+            Assert.assertEquals(firstAddress, secondAddress,\n+                                \"Same address is expected\");\n+            if (timeout == 0 || timeout - System.nanoTime() > 0) {\n+                Assert.assertEquals(firstTimestamp, secondTimestamp,\n+                        \"Only one positive lookup is expected with caching enabled\");\n+            }\n+            return new Lookup(firstAddress, firstTimestamp);\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesStaleCachingTest.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=7\n+networkaddress.cache.negative.ttl=3\n+networkaddress.cache.stale.ttl=30\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/CacheStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCache.props","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ForeverCache.props","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreMinusStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnorePositiveStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreZeroStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCache.props","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/NeverCache.props","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreMinusStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnorePositiveStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreZeroStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -44,0 +45,2 @@\n+    private static volatile boolean unreachableServer;\n+    private static volatile CountDownLatch blocker;\n@@ -54,0 +57,7 @@\n+                if (blocker != null) {\n+                    try {\n+                        blocker.await();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n@@ -56,0 +66,3 @@\n+                if (unreachableServer) {\n+                    throw new UnknownHostException(\"unreachableServer\");\n+                }\n@@ -62,0 +75,3 @@\n+                if (unreachableServer) {\n+                    throw new UnknownHostException(\"unreachableServer\");\n+                }\n@@ -76,0 +92,8 @@\n+    public static void setUnreachableServer(boolean unreachableServer) {\n+        SimpleResolverProviderImpl.unreachableServer = unreachableServer;\n+    }\n+\n+    public static void setBlocker(CountDownLatch blocker) {\n+        SimpleResolverProviderImpl.blocker = blocker;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/simple\/simple.provider\/impl\/SimpleResolverProviderImpl.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}