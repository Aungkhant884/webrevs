{"files":[{"patch":"@@ -942,1 +942,5 @@\n-        final long expiryTime; \/\/ time of expiry (in terms of System.nanoTime())\n+        \/**\n+         * Time of expiry (in terms of System.nanoTime()). Can be modified only\n+         * when the record is not added to the \"expirySet\".\n+         *\/\n+        volatile long expiryTime;\n@@ -971,0 +975,20 @@\n+\n+        \/**\n+         * Checks if the current cache record is expired or not. Expired records\n+         * are removed from the expirySet and cache.\n+         *\/\n+        public boolean expired(long now) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((expiryTime - now) < 0L) {\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(this)) {\n+                    \/\/ ... remove from cache\n+                    cache.remove(host, this);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n@@ -978,0 +1002,7 @@\n+        \/**\n+         * For how long the stale data should be used after TTL expiration.\n+         * Initially equal to the expiryTime, but increased over time after each\n+         * successful lookup.\n+         *\/\n+        private volatile long staleTime;\n+\n@@ -985,1 +1016,1 @@\n-                       long expiryTime, long refreshTime)\n+                       long staleTime, long refreshTime)\n@@ -987,1 +1018,1 @@\n-            super(host, inetAddresses, expiryTime);\n+            super(host, inetAddresses, staleTime);\n@@ -989,0 +1020,1 @@\n+            this.staleTime = staleTime;\n@@ -992,1 +1024,1 @@\n-        public InetAddress[] get() throws UnknownHostException {\n+        public InetAddress[] get() {\n@@ -1000,0 +1032,2 @@\n+                    \/\/ don't update the \"expirySet\", will do that later\n+                    staleTime = refreshTime + InetAddressCachePolicy.getStale() * 1000_000_000L;\n@@ -1007,0 +1041,27 @@\n+\n+        \/**\n+         * Overrides the parent method to skip deleting the record from the\n+         * cache if the staled data can still be used. Note to update the\n+         * \"expiryTime\" field we have to remove the record from the expirySet\n+         * and add it back. It is not necessary to remove\/add it here, we can do\n+         * that in the \"get()\" method above, but extracting it minimizes\n+         * contention on \"expirySet\".\n+         *\/\n+        @Override\n+        public boolean expired(long now) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((expiryTime - now) < 0L) {\n+                if ((staleTime - now) < 0L) {\n+                    return super.expired(now);\n+                }\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(this)) {\n+                    expiryTime = staleTime;\n+                    expirySet.add(this);\n+                }\n+            }\n+            return false;\n+        }\n@@ -1060,1 +1121,1 @@\n-                        if (InetAddressCachePolicy.getExtended() > 0 &&\n+                        if (InetAddressCachePolicy.getStale() > 0 &&\n@@ -1064,3 +1125,3 @@\n-                            \/\/  cacheExtendedPolicy is in [s] - we need [ns]\n-                            expiryTime = now + 1000_000_000L *\n-                                    InetAddressCachePolicy.getExtended();\n+                            \/\/  staleCachePolicy is in [s] - we need [ns]\n+                            expiryTime = refreshTime + 1000_000_000L *\n+                                    InetAddressCachePolicy.getStale();\n@@ -1672,11 +1733,1 @@\n-            \/\/ compare difference of time instants rather than\n-            \/\/ time instants directly, to avoid possible overflow.\n-            \/\/ (see System.nanoTime() recommendations...)\n-            if ((caddrs.expiryTime - now) < 0L) {\n-                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n-                \/\/ so removing while iterating is OK...\n-                if (expirySet.remove(caddrs)) {\n-                    \/\/ ... remove from cache\n-                    cache.remove(caddrs.host, caddrs);\n-                }\n-            } else {\n+            if (!caddrs.expired(now)) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":70,"deletions":19,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -40,5 +40,5 @@\n-    \/\/ Controls the cache extended policy for successful lookups only\n-    private static final String cacheExtendedPolicyProp =\n-        \"networkaddress.cache.extended.ttl\";\n-    private static final String cacheExtendedPolicyPropFallback =\n-        \"sun.net.inetaddr.extended.ttl\";\n+    \/\/ Controls the cache stale policy for successful lookups only\n+    private static final String cacheStalePolicyProp =\n+        \"networkaddress.cache.stale.ttl\";\n+    private static final String cacheStalePolicyPropFallback =\n+        \"sun.net.inetaddr.stale.ttl\";\n@@ -69,1 +69,1 @@\n-    \/* The Java-level namelookup cache extended policy for successful lookups:\n+    \/* The Java-level namelookup cache stale policy for successful lookups:\n@@ -75,1 +75,1 @@\n-    private static volatile int extendedCachePolicy = NEVER;\n+    private static volatile int staleCachePolicy = NEVER;\n@@ -124,2 +124,2 @@\n-            tmp = getProperty(cacheExtendedPolicyProp,\n-                              cacheExtendedPolicyPropFallback);\n+            tmp = getProperty(cacheStalePolicyProp,\n+                              cacheStalePolicyPropFallback);\n@@ -127,1 +127,1 @@\n-                extendedCachePolicy = (int) Math.max(tmp, max);\n+                staleCachePolicy = (int) Math.max(tmp, max);\n@@ -166,2 +166,2 @@\n-    public static int getExtended() {\n-        return extendedCachePolicy;\n+    public static int getStale() {\n+        return staleCachePolicy;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/InetAddressCachePolicy.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreMinusExtended.props\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreMinusStale.props\n@@ -48,1 +48,1 @@\n- *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnorePositiveExtended.props\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnorePositiveStale.props\n@@ -51,1 +51,1 @@\n- *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreZeroExtended.props\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreZeroStale.props\n@@ -54,1 +54,1 @@\n- *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreMinusExtended.props\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreMinusStale.props\n@@ -57,1 +57,1 @@\n- *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnorePositiveExtended.props\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnorePositiveStale.props\n@@ -60,1 +60,1 @@\n- *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreZeroExtended.props\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreZeroStale.props\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesCachingTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,144 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.InetAddress;\n-import java.net.UnknownHostException;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-import impl.SimpleResolverProviderImpl;\n-import org.testng.Assert;\n-import org.testng.annotations.Test;\n-\n-\n-\/*\n- * @test\n- * @summary Test that extended InetAddress caching security properties work as\n- *          expected when a custom resolver is installed.\n- * @library lib providers\/simple\n- * @build test.library\/testlib.ResolutionRegistry\n- *  simple.provider\/impl.SimpleResolverProviderImpl AddressesExtendedCachingTest\n- * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/CacheExtended.props AddressesExtendedCachingTest\n- *\/\n-public class AddressesExtendedCachingTest {\n-\n-    private static class Lookup {\n-        private final byte[] address;\n-        private final long timestamp;\n-\n-        private Lookup(byte[] address, long timestamp) {\n-            this.address = address;\n-            this.timestamp = timestamp;\n-        }\n-    }\n-\n-    \/**\n-     * Validates successful and unsuccessful lookups when the extended cache is\n-     * enabled.\n-     *\/\n-    @Test\n-    public void testRefresh() throws Exception{\n-        \/\/ The first request is to save the data into the cache\n-        Lookup first = doLookup(false);\n-\n-        Thread.sleep(10000); \/\/ intentionally big delay > x2 extended property\n-        \/\/ The refreshTime is expired, we will do the successful lookup.\n-        Lookup second = doLookup(false);\n-        Assert.assertNotEquals(first.timestamp, second.timestamp,\n-                               \"Two lookups are expected\");\n-\n-        Thread.sleep(10000); \/\/ intentionally big delay > x2 extended property\n-        \/\/ The refreshTime is expired again, we will do the failed lookup.\n-        Lookup third = doLookup(true);\n-        Assert.assertNotEquals(second.timestamp, third.timestamp,\n-                               \"Two lookups are expected\");\n-\n-        \/\/ The extended cache is enabled, so we should get valid\/same data for\n-        \/\/ all requests(even for the failed request).\n-        Assert.assertEquals(first.address, second.address,\n-                            \"Same address is expected\");\n-        Assert.assertEquals(second.address, third.address,\n-                            \"Same address is expected\");\n-    }\n-\n-    \/**\n-     * Validates that only one thread is blocked during \"refresh\", all others\n-     * will continue to use the \"stale\" data.\n-     *\/\n-    @Test\n-    public void testOnlyOneThreadIsBlockedDuringRefresh() throws Exception {\n-        doLookup(false);\n-        Thread.sleep(5000);\n-\n-        CountDownLatch blockServer = new CountDownLatch(1);\n-        SimpleResolverProviderImpl.setBlocker(blockServer);\n-\n-        Thread ts[] = new Thread[10];\n-        CountDownLatch wait9 = new CountDownLatch(ts.length - 1);\n-        CountDownLatch wait10 = new CountDownLatch(ts.length);\n-        CountDownLatch start = new CountDownLatch(ts.length);\n-        for (int i = 0; i < ts.length; i++) {\n-            ts[i] = new Thread(() -> {\n-                start.countDown();\n-                try {\n-                    start.await();\n-                } catch (InterruptedException e) {\n-                    throw new RuntimeException(e);\n-                }\n-                doLookup(true);\n-                wait9.countDown();\n-                wait10.countDown();\n-            });\n-        }\n-        for (Thread t : ts) {\n-            t.start();\n-        }\n-        if (!wait9.await(10, TimeUnit.SECONDS)) {\n-            blockServer.countDown();\n-            throw new RuntimeException(\"Some threads hang\");\n-        }\n-        blockServer.countDown();\n-        if (!wait10.await(10, TimeUnit.SECONDS)) {\n-            throw new RuntimeException(\"The last thread hangs\");\n-        }\n-    }\n-\n-    private static Lookup doLookup(boolean error) {\n-        SimpleResolverProviderImpl.setUnreachableServer(error);\n-        try {\n-            byte[] firstAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n-            long firstTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n-\n-            byte[] secondAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n-            long secondTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n-\n-            Assert.assertEquals(firstAddress, secondAddress,\n-                                \"Same address is expected\");\n-            Assert.assertEquals(firstTimestamp, secondTimestamp,\n-                                \"Only one positive lookup is expected with caching enabled\");\n-            return new Lookup(firstAddress, firstTimestamp);\n-        } catch (UnknownHostException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesExtendedCachingTest.java","additions":0,"deletions":144,"binary":false,"changes":144,"status":"deleted"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import impl.SimpleResolverProviderImpl;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test that stale InetAddress caching security properties work as\n+ *          expected when a custom resolver is installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry\n+ *  simple.provider\/impl.SimpleResolverProviderImpl AddressesStaleCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/CacheStale.props AddressesStaleCachingTest\n+ *\/\n+public class AddressesStaleCachingTest {\n+\n+    private static class Lookup {\n+        private final byte[] address;\n+        private final long timestamp;\n+\n+        private Lookup(byte[] address, long timestamp) {\n+            this.address = address;\n+            this.timestamp = timestamp;\n+        }\n+    }\n+\n+    \/**\n+     * Validates successful and unsuccessful lookups when the stale cache is\n+     * enabled.\n+     *\/\n+    @Test\n+    public void testRefresh() throws Exception{\n+        \/\/ The first request is to save the data into the cache\n+        Lookup first = doLookup(false);\n+\n+        Thread.sleep(10000); \/\/ intentionally big delay > x2 stale property\n+        \/\/ The refreshTime is expired, we will do the successful lookup.\n+        Lookup second = doLookup(false);\n+        Assert.assertNotEquals(first.timestamp, second.timestamp,\n+                               \"Two lookups are expected\");\n+\n+        Thread.sleep(10000); \/\/ intentionally big delay > x2 stale property\n+        \/\/ The refreshTime is expired again, we will do the failed lookup.\n+        Lookup third = doLookup(true);\n+        Assert.assertNotEquals(second.timestamp, third.timestamp,\n+                               \"Two lookups are expected\");\n+\n+        \/\/ The stale cache is enabled, so we should get valid\/same data for\n+        \/\/ all requests(even for the failed request).\n+        Assert.assertEquals(first.address, second.address,\n+                            \"Same address is expected\");\n+        Assert.assertEquals(second.address, third.address,\n+                            \"Same address is expected\");\n+    }\n+\n+    \/**\n+     * Validates that only one thread is blocked during \"refresh\", all others\n+     * will continue to use the \"stale\" data.\n+     *\/\n+    @Test\n+    public void testOnlyOneThreadIsBlockedDuringRefresh() throws Exception {\n+        doLookup(false);\n+        Thread.sleep(5000);\n+\n+        CountDownLatch blockServer = new CountDownLatch(1);\n+        SimpleResolverProviderImpl.setBlocker(blockServer);\n+\n+        Thread ts[] = new Thread[10];\n+        CountDownLatch wait9 = new CountDownLatch(ts.length - 1);\n+        CountDownLatch wait10 = new CountDownLatch(ts.length);\n+        CountDownLatch start = new CountDownLatch(ts.length);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = new Thread(() -> {\n+                start.countDown();\n+                try {\n+                    start.await();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                doLookup(true);\n+                wait9.countDown();\n+                wait10.countDown();\n+            });\n+        }\n+        for (Thread t : ts) {\n+            t.start();\n+        }\n+        if (!wait9.await(10, TimeUnit.SECONDS)) {\n+            blockServer.countDown();\n+            throw new RuntimeException(\"Some threads hang\");\n+        }\n+        blockServer.countDown();\n+        if (!wait10.await(10, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"The last thread hangs\");\n+        }\n+    }\n+\n+    private static Lookup doLookup(boolean error) {\n+        SimpleResolverProviderImpl.setUnreachableServer(error);\n+        try {\n+            byte[] firstAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n+            long firstTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+\n+            byte[] secondAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n+            long secondTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+\n+            Assert.assertEquals(firstAddress, secondAddress,\n+                                \"Same address is expected\");\n+            Assert.assertEquals(firstTimestamp, secondTimestamp,\n+                                \"Only one positive lookup is expected with caching enabled\");\n+            return new Lookup(firstAddress, firstTimestamp);\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesStaleCachingTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=2\n-networkaddress.cache.negative.ttl=3\n-networkaddress.cache.extended.ttl=30\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/CacheExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=2\n+networkaddress.cache.negative.ttl=3\n+networkaddress.cache.stale.ttl=30\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/CacheStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=-1\n-networkaddress.cache.negative.ttl=-1\n-networkaddress.cache.extended.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreMinusExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreMinusStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=-1\n-networkaddress.cache.negative.ttl=-1\n-networkaddress.cache.extended.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnorePositiveExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnorePositiveStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=-1\n-networkaddress.cache.negative.ttl=-1\n-networkaddress.cache.extended.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreZeroExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreZeroStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=0\n-networkaddress.cache.negative.ttl=0\n-networkaddress.cache.extended.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreMinusExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreMinusStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=0\n-networkaddress.cache.negative.ttl=0\n-networkaddress.cache.extended.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnorePositiveExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnorePositiveStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -1,3 +0,0 @@\n-networkaddress.cache.ttl=0\n-networkaddress.cache.negative.ttl=0\n-networkaddress.cache.extended.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreZeroExtended.props","additions":0,"deletions":3,"binary":false,"changes":3,"status":"deleted"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreZeroStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"}]}