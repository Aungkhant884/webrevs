{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import java.util.concurrent.locks.Lock;\n@@ -937,1 +938,1 @@\n-    private static final class CachedAddresses  implements Addresses, Comparable<CachedAddresses> {\n+    private static class CachedAddresses  implements Addresses, Comparable<CachedAddresses> {\n@@ -940,2 +941,6 @@\n-        final InetAddress[] inetAddresses;\n-        final long expiryTime; \/\/ time of expiry (in terms of System.nanoTime())\n+        volatile InetAddress[] inetAddresses;\n+        \/**\n+         * Time of expiry (in terms of System.nanoTime()). Can be modified only\n+         * when the record is not added to the \"expirySet\".\n+         *\/\n+        volatile long expiryTime;\n@@ -970,0 +975,93 @@\n+\n+        \/**\n+         * Checks if the current cache record is expired or not. Expired records\n+         * are removed from the expirySet and cache.\n+         *\/\n+        public boolean expired(long now) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((expiryTime - now) < 0L) {\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(this)) {\n+                    \/\/ ... remove from cache\n+                    cache.remove(host, this);\n+                }\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    private static final class ValidAddresses extends CachedAddresses {\n+        \/**\n+         * Time to refresh (in terms of System.nanoTime()).\n+         *\/\n+        private volatile long refreshTime;\n+        \/**\n+         * For how long the stale data should be used after TTL expiration.\n+         * Initially equal to the expiryTime, but increased over time after each\n+         * successful lookup.\n+         *\/\n+        private volatile long staleTime;\n+\n+        \/**\n+         * only one thread is doing lookup to name service\n+         * for particular host at any time.\n+         *\/\n+        private final Lock lookupLock = new ReentrantLock();\n+\n+        ValidAddresses(String host, InetAddress[] inetAddresses,\n+                       long staleTime, long refreshTime)\n+        {\n+            super(host, inetAddresses, staleTime);\n+            this.refreshTime = refreshTime;\n+            this.staleTime = staleTime;\n+        }\n+\n+        @Override\n+        public InetAddress[] get() {\n+            long now = System.nanoTime();\n+            if ((refreshTime - now) < 0L && lookupLock.tryLock()) {\n+                try {\n+                    \/\/ cachePolicy is in [s] - we need [ns]\n+                    refreshTime = now + InetAddressCachePolicy.get() * 1000_000_000L;\n+                    \/\/ getAddressesFromNameService returns non-empty\/non-null value\n+                    inetAddresses = getAddressesFromNameService(host);\n+                    \/\/ don't update the \"expirySet\", will do that later\n+                    staleTime = refreshTime + InetAddressCachePolicy.getStale() * 1000_000_000L;\n+                } catch (UnknownHostException ignore) {\n+                } finally {\n+                    lookupLock.unlock();\n+                }\n+            }\n+            return inetAddresses;\n+        }\n+\n+        \/**\n+         * Overrides the parent method to skip deleting the record from the\n+         * cache if the staled data can still be used. Note to update the\n+         * \"expiryTime\" field we have to remove the record from the expirySet\n+         * and add it back. It is not necessary to remove\/add it here, we can do\n+         * that in the \"get()\" method above, but extracting it minimizes\n+         * contention on \"expirySet\".\n+         *\/\n+        @Override\n+        public boolean expired(long now) {\n+            \/\/ compare difference of time instants rather than\n+            \/\/ time instants directly, to avoid possible overflow.\n+            \/\/ (see System.nanoTime() recommendations...)\n+            if ((expiryTime - now) < 0L) {\n+                if ((staleTime - now) < 0L) {\n+                    return super.expired(now);\n+                }\n+                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n+                \/\/ so removing while iterating is OK...\n+                if (expirySet.remove(this)) {\n+                    expiryTime = staleTime;\n+                    expirySet.add(this);\n+                }\n+            }\n+            return false;\n+        }\n@@ -1016,8 +1114,23 @@\n-                        CachedAddresses cachedAddresses = new CachedAddresses(\n-                            host,\n-                            inetAddresses,\n-                            cachePolicy == InetAddressCachePolicy.FOREVER\n-                            ? 0L\n-                            \/\/ cachePolicy is in [s] - we need [ns]\n-                            : System.nanoTime() + 1000_000_000L * cachePolicy\n-                        );\n+                        long now = System.nanoTime();\n+                        long expiryTime =\n+                                cachePolicy == InetAddressCachePolicy.FOREVER ?\n+                                0L\n+                                \/\/ cachePolicy is in [s] - we need [ns]\n+                                : now + 1000_000_000L * cachePolicy;\n+                        CachedAddresses cachedAddresses;\n+                        if (InetAddressCachePolicy.getStale() > 0 &&\n+                                ex == null && expiryTime > 0)\n+                        {\n+                            long refreshTime = expiryTime;\n+                            \/\/  staleCachePolicy is in [s] - we need [ns]\n+                            expiryTime = refreshTime + 1000_000_000L *\n+                                    InetAddressCachePolicy.getStale();\n+                            cachedAddresses = new ValidAddresses(host,\n+                                                                 inetAddresses,\n+                                                                 expiryTime,\n+                                                                 refreshTime);\n+                        } else {\n+                            cachedAddresses = new CachedAddresses(host,\n+                                                                  inetAddresses,\n+                                                                  expiryTime);\n+                        }\n@@ -1620,11 +1733,1 @@\n-            \/\/ compare difference of time instants rather than\n-            \/\/ time instants directly, to avoid possible overflow.\n-            \/\/ (see System.nanoTime() recommendations...)\n-            if ((caddrs.expiryTime - now) < 0L) {\n-                \/\/ ConcurrentSkipListSet uses weakly consistent iterator,\n-                \/\/ so removing while iterating is OK...\n-                if (expirySet.remove(caddrs)) {\n-                    \/\/ ... remove from cache\n-                    cache.remove(caddrs.host, caddrs);\n-                }\n-            } else {\n+            if (!caddrs.expired(now)) {\n","filename":"src\/java.base\/share\/classes\/java\/net\/InetAddress.java","additions":126,"deletions":23,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -39,0 +40,6 @@\n+    \/\/ Controls the cache stale policy for successful lookups only\n+    private static final String cacheStalePolicyProp =\n+        \"networkaddress.cache.stale.ttl\";\n+    private static final String cacheStalePolicyPropFallback =\n+        \"sun.net.inetaddr.stale.ttl\";\n+\n@@ -62,0 +69,8 @@\n+    \/* The Java-level namelookup cache stale policy for successful lookups:\n+     *\n+     * any positive value: the number of seconds to cache an address for\n+     *\n+     * default value is never (NEVER).\n+     *\/\n+    private static volatile int staleCachePolicy = NEVER;\n+\n@@ -88,25 +103,1 @@\n-\n-        Integer tmp = java.security.AccessController.doPrivileged(\n-          new PrivilegedAction<Integer>() {\n-            public Integer run() {\n-                try {\n-                    String tmpString = Security.getProperty(cachePolicyProp);\n-                    if (tmpString != null) {\n-                        return Integer.valueOf(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-\n-                try {\n-                    String tmpString = System.getProperty(cachePolicyPropFallback);\n-                    if (tmpString != null) {\n-                        return Integer.decode(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-                return null;\n-            }\n-          });\n-\n+        Integer tmp = getProperty(cachePolicyProp, cachePolicyPropFallback);\n@@ -124,23 +115,2 @@\n-        tmp = java.security.AccessController.doPrivileged (\n-          new PrivilegedAction<Integer>() {\n-            public Integer run() {\n-                try {\n-                    String tmpString = Security.getProperty(negativeCachePolicyProp);\n-                    if (tmpString != null) {\n-                        return Integer.valueOf(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-\n-                try {\n-                    String tmpString = System.getProperty(negativeCachePolicyPropFallback);\n-                    if (tmpString != null) {\n-                        return Integer.decode(tmpString);\n-                    }\n-                } catch (NumberFormatException ignored) {\n-                    \/\/ Ignore\n-                }\n-                return null;\n-            }\n-          });\n+        tmp = getProperty(negativeCachePolicyProp,\n+                          negativeCachePolicyPropFallback);\n@@ -152,0 +122,38 @@\n+        long max = TimeUnit.DAYS.toSeconds(7);\n+        if (cachePolicy > 0 && cachePolicy < max) {\n+            tmp = getProperty(cacheStalePolicyProp,\n+                              cacheStalePolicyPropFallback);\n+            if (tmp != null && tmp > cachePolicy) {\n+                staleCachePolicy = (int) Math.max(tmp, max);\n+            }\n+        }\n+    }\n+\n+    private static Integer getProperty(String cachePolicyProp,\n+                                       String cachePolicyPropFallback)\n+    {\n+        return java.security.AccessController.doPrivileged(\n+                new PrivilegedAction<Integer>() {\n+                    public Integer run() {\n+                        try {\n+                            String tmpString = Security.getProperty(\n+                                    cachePolicyProp);\n+                            if (tmpString != null) {\n+                                return Integer.valueOf(tmpString);\n+                            }\n+                        } catch (NumberFormatException ignored) {\n+                            \/\/ Ignore\n+                        }\n+\n+                        try {\n+                            String tmpString = System.getProperty(\n+                                    cachePolicyPropFallback);\n+                            if (tmpString != null) {\n+                                return Integer.decode(tmpString);\n+                            }\n+                        } catch (NumberFormatException ignored) {\n+                            \/\/ Ignore\n+                        }\n+                        return null;\n+                    }\n+                });\n@@ -158,0 +166,4 @@\n+    public static int getStale() {\n+        return staleCachePolicy;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/InetAddressCachePolicy.java","additions":61,"deletions":49,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run testng\/othervm -Djava.security.properties=${test.src}\/NeverCache.props\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/NeverCache.props\n@@ -42,1 +42,19 @@\n- * @run testng\/othervm -Djava.security.properties=${test.src}\/ForeverCache.props\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/ForeverCache.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreMinusStale.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnorePositiveStale.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/NeverCacheIgnoreZeroStale.props\n+ *  -Dtest.cachingDisabled=true AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreMinusStale.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnorePositiveStale.props\n+ *  -Dtest.cachingDisabled=false AddressesCachingTest\n+ * @run testng\/othervm\n+ *  -Djava.security.properties=${test.src}\/props\/ForeverCacheIgnoreZeroStale.props\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesCachingTest.java","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import impl.SimpleResolverProviderImpl;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+\/*\n+ * @test\n+ * @summary Test that stale InetAddress caching security properties work as\n+ *          expected when a custom resolver is installed.\n+ * @library lib providers\/simple\n+ * @build test.library\/testlib.ResolutionRegistry\n+ *  simple.provider\/impl.SimpleResolverProviderImpl AddressesStaleCachingTest\n+ * @run testng\/othervm -Djava.security.properties=${test.src}\/props\/CacheStale.props AddressesStaleCachingTest\n+ *\/\n+public class AddressesStaleCachingTest {\n+\n+    private static class Lookup {\n+        private final byte[] address;\n+        private final long timestamp;\n+\n+        private Lookup(byte[] address, long timestamp) {\n+            this.address = address;\n+            this.timestamp = timestamp;\n+        }\n+    }\n+\n+    \/**\n+     * Validates successful and unsuccessful lookups when the stale cache is\n+     * enabled.\n+     *\/\n+    @Test\n+    public void testRefresh() throws Exception{\n+        \/\/ The first request is to save the data into the cache\n+        Lookup first = doLookup(false);\n+\n+        Thread.sleep(10000); \/\/ intentionally big delay > x2 stale property\n+        \/\/ The refreshTime is expired, we will do the successful lookup.\n+        Lookup second = doLookup(false);\n+        Assert.assertNotEquals(first.timestamp, second.timestamp,\n+                               \"Two lookups are expected\");\n+\n+        Thread.sleep(10000); \/\/ intentionally big delay > x2 stale property\n+        \/\/ The refreshTime is expired again, we will do the failed lookup.\n+        Lookup third = doLookup(true);\n+        Assert.assertNotEquals(second.timestamp, third.timestamp,\n+                               \"Two lookups are expected\");\n+\n+        \/\/ The stale cache is enabled, so we should get valid\/same data for\n+        \/\/ all requests(even for the failed request).\n+        Assert.assertEquals(first.address, second.address,\n+                            \"Same address is expected\");\n+        Assert.assertEquals(second.address, third.address,\n+                            \"Same address is expected\");\n+    }\n+\n+    \/**\n+     * Validates that only one thread is blocked during \"refresh\", all others\n+     * will continue to use the \"stale\" data.\n+     *\/\n+    @Test\n+    public void testOnlyOneThreadIsBlockedDuringRefresh() throws Exception {\n+        doLookup(false);\n+        Thread.sleep(5000);\n+\n+        CountDownLatch blockServer = new CountDownLatch(1);\n+        SimpleResolverProviderImpl.setBlocker(blockServer);\n+\n+        Thread ts[] = new Thread[10];\n+        CountDownLatch wait9 = new CountDownLatch(ts.length - 1);\n+        CountDownLatch wait10 = new CountDownLatch(ts.length);\n+        CountDownLatch start = new CountDownLatch(ts.length);\n+        for (int i = 0; i < ts.length; i++) {\n+            ts[i] = new Thread(() -> {\n+                start.countDown();\n+                try {\n+                    start.await();\n+                } catch (InterruptedException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                doLookup(true);\n+                wait9.countDown();\n+                wait10.countDown();\n+            });\n+        }\n+        for (Thread t : ts) {\n+            t.start();\n+        }\n+        if (!wait9.await(10, TimeUnit.SECONDS)) {\n+            blockServer.countDown();\n+            throw new RuntimeException(\"Some threads hang\");\n+        }\n+        blockServer.countDown();\n+        if (!wait10.await(10, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"The last thread hangs\");\n+        }\n+    }\n+\n+    private static Lookup doLookup(boolean error) {\n+        SimpleResolverProviderImpl.setUnreachableServer(error);\n+        try {\n+            byte[] firstAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n+            long firstTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+\n+            byte[] secondAddress = InetAddress.getByName(\"javaTest.org\").getAddress();\n+            long secondTimestamp = SimpleResolverProviderImpl.getLastLookupTimestamp();\n+\n+            Assert.assertEquals(firstAddress, secondAddress,\n+                                \"Same address is expected\");\n+            Assert.assertEquals(firstTimestamp, secondTimestamp,\n+                                \"Only one positive lookup is expected with caching enabled\");\n+            return new Lookup(firstAddress, firstTimestamp);\n+        } catch (UnknownHostException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/AddressesStaleCachingTest.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=2\n+networkaddress.cache.negative.ttl=3\n+networkaddress.cache.stale.ttl=30\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/CacheStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCache.props","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/ForeverCache.props","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreMinusStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnorePositiveStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=-1\n+networkaddress.cache.negative.ttl=-1\n+networkaddress.cache.stale.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/ForeverCacheIgnoreZeroStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCache.props","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/NeverCache.props","status":"renamed"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=-1\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreMinusStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=10000\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnorePositiveStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -0,0 +1,3 @@\n+networkaddress.cache.ttl=0\n+networkaddress.cache.negative.ttl=0\n+networkaddress.cache.stale.ttl=0\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/props\/NeverCacheIgnoreZeroStale.props","additions":3,"deletions":0,"binary":false,"changes":3,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.CountDownLatch;\n@@ -44,0 +45,2 @@\n+    private static volatile boolean unreachableServer;\n+    private static volatile CountDownLatch blocker;\n@@ -56,0 +59,10 @@\n+                if (unreachableServer) {\n+                    throw new UnknownHostException(\"unreachableServer\");\n+                }\n+                if (blocker != null) {\n+                    try {\n+                        blocker.await();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n@@ -62,0 +75,3 @@\n+                if (unreachableServer) {\n+                    throw new UnknownHostException(\"unreachableServer\");\n+                }\n@@ -76,0 +92,8 @@\n+    public static void setUnreachableServer(boolean unreachableServer) {\n+        SimpleResolverProviderImpl.unreachableServer = unreachableServer;\n+    }\n+\n+    public static void setBlocker(CountDownLatch blocker) {\n+        SimpleResolverProviderImpl.blocker = blocker;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/spi\/InetAddressResolverProvider\/providers\/simple\/simple.provider\/impl\/SimpleResolverProviderImpl.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"}]}