{"files":[{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsHeapVerifier.hpp\"\n+#include \"classfile\/classLoaderDataGraph.hpp\"\n+#include \"classfile\/javaClasses.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/fieldStreams.inline.hpp\"\n+#include \"oops\/klass.inline.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/fieldDescriptor.inline.hpp\"\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+\/\/ CDSHeapVerifier is used to check for problems where an archived object references a\n+\/\/ static field that may be reinitialized at runtime. In the following example,\n+\/\/      Foo.get.test()\n+\/\/ correctly returns true when CDS disabled, but incorrectly returns false when CDS is enabled.\n+\/\/\n+\/\/ class Foo {\n+\/\/     final Foo archivedFoo; \/\/ this field is archived by CDS\n+\/\/     Bar bar;\n+\/\/     static {\n+\/\/         CDS.initializeFromArchive(Foo.class);\n+\/\/         if (archivedFoo == null) {\n+\/\/             archivedFoo = new Foo();\n+\/\/             archivedFoo.bar = Bar.bar;\n+\/\/         }\n+\/\/     }\n+\/\/     static Foo get() { return archivedFoo; }\n+\/\/     boolean test() {\n+\/\/         return bar == Bar.bar;\n+\/\/     }\n+\/\/ }\n+\/\/\n+\/\/ class Bar {\n+\/\/     \/\/ this field is initialized in both CDS dump time and runtime.\n+\/\/     static final Bar bar = new Bar;\n+\/\/ }\n+\/\/\n+\/\/ The check itself is simple:\n+\/\/ [1] CDSHeapVerifier::do_klass() collects all static fields\n+\/\/ [2] CDSHeapVerifier::do_entry() checks all the archived objects. None of them\n+\/\/     should be in [1]\n+\/\/\n+\/\/ However, it's legal for *some* static fields to be references. This leads to the\n+\/\/ table of ADD_EXCL below.\n+\/\/\n+\/\/ [A] In most of the cases, the module bootstrap code will update the static field\n+\/\/     to point to part of the archived module graph. E.g.,\n+\/\/     - java\/lang\/System::bootLayer\n+\/\/     - jdk\/internal\/loader\/ClassLoaders::BOOT_LOADER\n+\/\/ [B] A final static String that's explicitly initialized inside <clinit>, but\n+\/\/     its value is deterministic and is always the same string literal.\n+\/\/ [C] A non-final static string that is assigned a string literal during class\n+\/\/     initialization; this string is never changed during -Xshare:dump.\n+\/\/ [D] Simple caches whose value doesn't matter.\n+\/\/ [E] Other cases (see comments in-line below).\n+\n+CDSHeapVerifier::CDSHeapVerifier() : _archived_objs(0), _problems(0)\n+{\n+# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, NULL}; add(e); }\n+\n+  \/\/ Unfortunately this needs to be manually maintained. If\n+  \/\/ test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumTest.java fails,\n+  \/\/ you might need to fix the core library code, or fix the ADD_EXCL entries below.\n+  \/\/\n+  \/\/       class                                         field                     type\n+  ADD_EXCL(\"java\/lang\/ClassLoader\",                      \"scl\");                   \/\/ A \n+  ADD_EXCL(\"java\/lang\/invoke\/InvokerBytecodeGenerator\",  \"DONTINLINE_SIG\",         \/\/ B\n+                                                         \"FORCEINLINE_SIG\",        \/\/ B\n+                                                         \"HIDDEN_SIG\",             \/\/ B\n+                                                         \"INJECTEDPROFILE_SIG\",    \/\/ B\n+                                                         \"LF_COMPILED_SIG\");       \/\/ B\n+  ADD_EXCL(\"java\/lang\/Module\",                           \"ALL_UNNAMED_MODULE\",     \/\/ A\n+                                                         \"ALL_UNNAMED_MODULE_SET\", \/\/ A\n+                                                         \"EVERYONE_MODULE\",        \/\/ A\n+                                                         \"EVERYONE_SET\");          \/\/ A\n+  ADD_EXCL(\"java\/lang\/System\",                           \"bootLayer\");             \/\/ A\n+  ADD_EXCL(\"java\/lang\/VersionProps\",                     \"VENDOR_URL_BUG\",         \/\/ C\n+                                                         \"VENDOR_URL_VM_BUG\",      \/\/ C\n+                                                         \"VENDOR_VERSION\");        \/\/ C\n+  ADD_EXCL(\"java\/net\/URL$DefaultFactory\",                \"PREFIX\");                \/\/ B FIXME: JDK-8276561\n+\n+  \/\/ A dummy object used by HashSet. The value doesn't matter and it's never\n+  \/\/ tested for equality.\n+  ADD_EXCL(\"java\/util\/HashSet\",                          \"PRESENT\");               \/\/ E\n+  ADD_EXCL(\"jdk\/internal\/loader\/BuiltinClassLoader\",     \"packageToModule\");       \/\/ A\n+  ADD_EXCL(\"jdk\/internal\/loader\/ClassLoaders\",           \"BOOT_LOADER\",            \/\/ A\n+                                                         \"APP_LOADER\",             \/\/ A\n+                                                         \"PLATFORM_LOADER\");       \/\/ A\n+  ADD_EXCL(\"jdk\/internal\/loader\/URLClassPath\",           \"JAVA_VERSION\");          \/\/ B\n+  ADD_EXCL(\"jdk\/internal\/module\/Builder\",                \"cachedVersion\");         \/\/ D\n+  ADD_EXCL(\"jdk\/internal\/module\/ModuleLoaderMap$Mapper\", \"APP_CLASSLOADER\",        \/\/ A\n+                                                         \"APP_LOADER_INDEX\",       \/\/ A\n+                                                         \"PLATFORM_CLASSLOADER\",   \/\/ A\n+                                                         \"PLATFORM_LOADER_INDEX\"); \/\/ A\n+  ADD_EXCL(\"jdk\/internal\/module\/ServicesCatalog\",        \"CLV\");                   \/\/ A\n+\n+  \/\/ This just points to an empty Map\n+  ADD_EXCL(\"jdk\/internal\/reflect\/Reflection\",            \"methodFilterMap\");       \/\/ E\n+  ADD_EXCL(\"jdk\/internal\/util\/StaticProperty\",           \"FILE_ENCODING\");         \/\/ C\n+\n+  \/\/ Integer for 0 and 1 are in java\/lang\/Integer$IntegerCache and are archived\n+  ADD_EXCL(\"sun\/invoke\/util\/ValueConversions\",           \"ONE_INT\",                \/\/ E\n+                                                         \"ZERO_INT\");              \/\/ E\n+  ADD_EXCL(\"sun\/security\/util\/SecurityConstants\",        \"PROVIDER_VER\");          \/\/ C\n+\n+\n+# undef ADD_EXCL\n+\n+  ClassLoaderDataGraph::classes_do(this);\n+}\n+\n+CDSHeapVerifier::~CDSHeapVerifier() {\n+  if (_problems > 0) {\n+    log_warning(cds, heap)(\"Scanned %d objects. Found %d case(s) where \"\n+                           \"an object points to a static field that may be \"\n+                           \"reinitialized at runtime.\", _archived_objs, _problems);\n+  }\n+}\n+\n+\/\/ Remember all the static object fields of every class that are currently\n+\/\/ loaded.\n+void CDSHeapVerifier::do_klass(Klass* k) {\n+  if (k->is_instance_klass()) {\n+    InstanceKlass* ik = InstanceKlass::cast(k);\n+    oop mirror = ik->java_mirror();\n+    int n = 0;\n+    const char** exclusions = find_exclusion(ik);\n+\n+    if (HeapShared::is_subgraph_root_class(ik)) {\n+      \/\/ ik is inside one of the ArchivableStaticFieldInfo tables\n+      \/\/ in heapShared.cpp. We assume such classes are programmed to\n+      \/\/ update their static fields correctly at runtime.\n+      return;\n+    }\n+\n+    ResourceMark rm;\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() == T_OBJECT) {\n+          oop static_obj_field = mirror->obj_field(fd.offset());\n+          if (static_obj_field != NULL) {\n+            Klass* klass = static_obj_field->klass();\n+            if (exclusions != NULL) {\n+              bool excluded = false;\n+              for (const char** p = exclusions; *p != NULL; p++) {\n+                if (fd.name()->equals(*p)) {\n+                  excluded = true;\n+                  break;\n+                }\n+              }\n+              if (excluded) {\n+                continue;\n+              }\n+            }\n+\n+            if (fd.is_final() && java_lang_String::is_instance(static_obj_field) && fd.has_initial_value()) {\n+              \/\/ This field looks like like this in the Java source:\n+              \/\/    static final SOME_STRING = \"a string literal\";\n+              \/\/ This string literal has been stored in the shared string table, so it's OK\n+              \/\/ for the archived objects to refer to it.\n+              continue;\n+            }\n+            if (fd.is_final() && java_lang_Class::is_instance(static_obj_field)) {\n+              \/\/ This field points to an archived mirror.\n+              continue;\n+            }\n+            if (klass->has_archived_enum_objs()) {\n+              \/\/ This klass is a subclass of java.lang.Enum. If any instance of this klass\n+              \/\/ has been archived, we will archive all static fields of this klass.\n+              \/\/ See HeapShared::initialize_enum_klass().\n+              continue;\n+            }\n+\n+            \/\/ This field *may* be initialized to a different value at runtime. Remember it\n+            \/\/ and check later if it appears in the archived object graph.\n+            StaticFieldInfo info = {ik, fd.name()};\n+            _table.put(static_obj_field, info);\n+          }\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+inline bool CDSHeapVerifier::do_entry(oop& orig_obj, HeapShared::CachedOopInfo& value) {\n+  _archived_objs++;\n+\n+  StaticFieldInfo* info = _table.get(orig_obj);\n+  if (info != NULL) {\n+    ResourceMark rm;\n+    LogStream ls(Log(cds, heap)::warning());\n+    ls.print_cr(\"Archive heap points to a static field that may be reinitialized at runtime:\");\n+    ls.print_cr(\"Field: %s::%s\", info->_holder->name()->as_C_string(), info->_name->as_C_string());\n+    ls.print(\"Value: \");\n+    orig_obj->print_on(&ls);\n+    ls.print_cr(\"--- trace begin ---\");\n+    trace_to_root(orig_obj, NULL, &value);\n+    ls.print_cr(\"--- trace end ---\");\n+    ls.cr();\n+    _problems ++;\n+  }\n+\n+  return true; \/* keep on iterating *\/\n+}\n+\n+int CDSHeapVerifier::trace_to_root(oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p) {\n+  int level = 0;\n+  LogStream ls(Log(cds, heap)::warning());\n+  if (p->_referrer != NULL) {\n+    HeapShared::CachedOopInfo* ref = HeapShared::archived_object_cache()->get(p->_referrer);\n+    assert(ref != NULL, \"sanity\");\n+    level = trace_to_root(p->_referrer, orig_obj, ref) + 1;\n+  } else if (java_lang_String::is_instance(orig_obj)) {\n+    ls.print_cr(\"[%2d] (shared string table)\", level++);\n+  }\n+  Klass* k = orig_obj->klass();\n+  ResourceMark rm;\n+  ls.print(\"[%2d] \", level);\n+  orig_obj->print_address_on(&ls);\n+  ls.print(\" %s\", k->internal_name());\n+  if (orig_field != NULL) {\n+    if (k->is_instance_klass()) {\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+        if (!fs.access_flags().is_static()) {\n+          fieldDescriptor& fd = fs.field_descriptor();\n+          if (fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY) {\n+            oop obj_field = orig_obj->obj_field(fd.offset());\n+            if (obj_field == orig_field) {\n+              ls.print(\"::%s (offset = %d)\", fd.name()->as_C_string(), fd.offset());\n+              break;\n+            }\n+          }\n+        }\n+      }\n+    } else {\n+      assert(orig_obj->is_objArray(), \"must be\");\n+      objArrayOop array = (objArrayOop)orig_obj;\n+      for (int i = 0; i < array->length(); i++) {\n+        if (array->obj_at(i) == orig_field) {\n+          ls.print(\" @[%d]\", i);\n+          break;\n+        }\n+      }\n+    }\n+  }\n+  ls.cr();\n+\n+  return level;\n+}\n+\n+void CDSHeapVerifier::verify() {\n+  CDSHeapVerifier verf;\n+  HeapShared::archived_object_cache()->iterate(&verf);\n+}\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARED_CDS_CDSHEAPVERIFIER_HPP\n+#define SHARED_CDS_CDSHEAPVERIFIER_HPP\n+\n+#include \"cds\/heapShared.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/resourceHash.hpp\"\n+\n+class InstanceKlass;\n+class Symbol;\n+\n+#if INCLUDE_CDS_JAVA_HEAP\n+\n+class CDSHeapVerifier : public KlassClosure {\n+  int _archived_objs;\n+  int _problems;\n+\n+  struct StaticFieldInfo {\n+    InstanceKlass* _holder;\n+    Symbol* _name;\n+  };\n+\n+  ResourceHashtable<oop, StaticFieldInfo,\n+      15889, \/\/ prime number\n+      ResourceObj::C_HEAP,\n+      mtClassShared,\n+      HeapShared::oop_hash> _table;\n+\n+  GrowableArray<const char**> _exclusions;\n+\n+  void add(const char** excl) {\n+    _exclusions.append(excl);\n+  }\n+\n+  const char** find_exclusion(InstanceKlass* ik) {\n+    for (int i = 0; i < _exclusions.length(); i++) {\n+      const char** excl = _exclusions.at(i);\n+      if (ik->name()->equals(excl[0])) {\n+        return &excl[1];\n+      }\n+    }\n+    return NULL;\n+  }\n+  int trace_to_root(oop orig_obj, oop orig_field, HeapShared::CachedOopInfo* p);\n+\n+  CDSHeapVerifier();\n+  ~CDSHeapVerifier();\n+\n+public:\n+\n+  \/\/ Overrides KlassClosure::do_klass()\n+  virtual void do_klass(Klass* k);\n+\n+  \/\/ For ResourceHashtable::iterate()\n+  inline bool do_entry(oop& orig_obj, HeapShared::CachedOopInfo& value);\n+\n+  static void verify();\n+};\n+\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+#endif \/\/ SHARED_CDS_CDSHEAPVERIFIER_HPP\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/runTimeClassInfo.hpp\"\n@@ -48,0 +49,1 @@\n+  clone._enum_klass_static_fields = NULL;\n@@ -64,0 +66,1 @@\n+  assert(_enum_klass_static_fields == NULL, \"This should not happen with jcmd VM.cds dumping\");\n@@ -67,0 +70,6 @@\n+size_t DumpTimeClassInfo::runtime_info_bytesize() const {\n+  return RunTimeClassInfo::byte_size(_klass, num_verifier_constraints(),\n+                                     num_loader_constraints(),\n+                                     num_enum_klass_static_fields());\n+}\n+\n@@ -147,0 +156,12 @@\n+void DumpTimeClassInfo::add_enum_klass_static_field(int archived_heap_root_index) {\n+  if (_enum_klass_static_fields == NULL) {\n+    _enum_klass_static_fields = new (ResourceObj::C_HEAP, mtClass) GrowableArray<int>(20, mtClass);\n+  }\n+  _enum_klass_static_fields->append(archived_heap_root_index);\n+}\n+\n+int DumpTimeClassInfo::enum_klass_static_field(int which_field) {\n+  assert(_enum_klass_static_fields != NULL, \"must be\");\n+  return _enum_klass_static_fields->at(which_field);\n+}\n+\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  GrowableArray<int>*                  _enum_klass_static_fields;\n@@ -95,0 +96,1 @@\n+    _enum_klass_static_fields = NULL;\n@@ -100,1 +102,2 @@\n-\n+  void add_enum_klass_static_field(int archived_heap_root_index);\n+  int  enum_klass_static_field(int which_field);\n@@ -103,4 +106,4 @@\n-  int num_verifier_constraints() {\n-    if (_verifier_constraint_flags != NULL) {\n-      return _verifier_constraint_flags->length();\n-    } else {\n+private:\n+  template <typename T>\n+  static int array_length_or_zero(GrowableArray<T>* array) {\n+    if (array == NULL) {\n@@ -108,0 +111,2 @@\n+    } else {\n+      return array->length();\n@@ -111,6 +116,12 @@\n-  int num_loader_constraints() {\n-    if (_loader_constraints != NULL) {\n-      return _loader_constraints->length();\n-    } else {\n-      return 0;\n-    }\n+public:\n+\n+  int num_verifier_constraints() const {\n+    return array_length_or_zero(_verifier_constraint_flags);\n+  }\n+\n+  int num_loader_constraints() const {\n+    return array_length_or_zero(_loader_constraints);\n+  }\n+\n+  int num_enum_klass_static_fields() const {\n+    return array_length_or_zero(_enum_klass_static_fields);\n@@ -155,0 +166,1 @@\n+\n@@ -156,0 +168,1 @@\n+  size_t runtime_info_bytesize() const;\n@@ -158,1 +171,0 @@\n-\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/cdsHeapVerifier.hpp\"\n@@ -45,1 +46,0 @@\n-#include \"logging\/logMessage.hpp\"\n@@ -142,5 +142,18 @@\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\/\/\n-\/\/ Java heap object archiving support\n-\/\/\n-\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+static bool is_subgraph_root_class_of(ArchivableStaticFieldInfo fields[], int num, InstanceKlass* ik) {\n+  for (int i = 0; i < num; i++) {\n+    if (fields[i].klass == ik) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool HeapShared::is_subgraph_root_class(InstanceKlass* ik) {\n+  return is_subgraph_root_class_of(closed_archive_subgraph_entry_fields,\n+                                   num_closed_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(open_archive_subgraph_entry_fields,\n+                                   num_open_archive_subgraph_entry_fields, ik) ||\n+         is_subgraph_root_class_of(fmg_open_archive_subgraph_entry_fields,\n+                                   num_fmg_open_archive_subgraph_entry_fields, ik);\n+}\n+\n@@ -203,1 +216,1 @@\n-  oop* p = cache->get(obj);\n+  CachedOopInfo* p = cache->get(obj);\n@@ -205,1 +218,1 @@\n-    return *p;\n+    return p->_obj;\n@@ -308,1 +321,2 @@\n-    cache->put(obj, archived_oop);\n+    CachedOopInfo info = make_cached_oop_info(archived_oop);\n+    cache->put(obj, info);\n@@ -342,0 +356,88 @@\n+\/\/ -- Handling of Enum objects\n+\/\/ Java Enum classes have synthetic <clinit> methods that look like this\n+\/\/     enum MyEnum {FOO, BAR}\n+\/\/     MyEnum::<clinint> {\n+\/\/        \/*static final MyEnum*\/ MyEnum::FOO = new MyEnum(\"FOO\");\n+\/\/        \/*static final MyEnum*\/ MyEnum::BAR = new MyEnum(\"BAR\");\n+\/\/     }\n+\/\/\n+\/\/ If MyEnum::FOO object is referenced by any of the archived subgraphs, we must\n+\/\/ ensure the archived value equals (in object address) to the runtime value of\n+\/\/ MyEnum::FOO.\n+\/\/\n+\/\/ However, since MyEnum::<clinint> is synthetically generated by javac, there's\n+\/\/ no way of programatically handling this inside the Java code (as you would handle\n+\/\/ ModuleLayer::EMPTY_LAYER, for example).\n+\/\/\n+\/\/ Instead, we archive all static field of such Enum classes. At runtime,\n+\/\/ HeapShared::initialize_enum_klass() will skip the <clinit> method and pull\n+\/\/ the static fields out of the archived heap.\n+void HeapShared::check_enum_obj(int level,\n+                                KlassSubGraphInfo* subgraph_info,\n+                                oop orig_obj,\n+                                bool is_closed_archive) {\n+  Klass* k = orig_obj->klass();\n+  Klass* relocated_k = ArchiveBuilder::get_relocated_klass(k);\n+  if (!k->is_instance_klass()) {\n+    return;\n+  }\n+  InstanceKlass* ik = InstanceKlass::cast(k);\n+  if (ik->java_super() == vmClasses::Enum_klass() && !ik->has_archived_enum_objs()) {\n+    ResourceMark rm;\n+    ik->set_has_archived_enum_objs();\n+    relocated_k->set_has_archived_enum_objs();\n+    oop mirror = ik->java_mirror();\n+\n+    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n+      if (fs.access_flags().is_static()) {\n+        fieldDescriptor& fd = fs.field_descriptor();\n+        if (fd.field_type() != T_OBJECT && fd.field_type() != T_ARRAY) {\n+          guarantee(false, \"static field %s::%s must be T_OBJECT or T_ARRAY\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop oop_field = mirror->obj_field(fd.offset());\n+        if (oop_field == NULL) {\n+          guarantee(false, \"static field %s::%s must not be null\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        } else if (oop_field->klass() != ik && oop_field->klass() != ik->array_klass_or_null()) {\n+          guarantee(false, \"static field %s::%s is of the wrong type\",\n+                    ik->external_name(), fd.name()->as_C_string());\n+        }\n+        oop archived_oop_field = archive_reachable_objects_from(level, subgraph_info, oop_field, is_closed_archive);\n+        int root_index = append_root(archived_oop_field);\n+        log_info(cds, heap)(\"Archived enum obj @%d %s::%s (\" INTPTR_FORMAT \" -> \" INTPTR_FORMAT \")\",\n+                            root_index, ik->external_name(), fd.name()->as_C_string(),\n+                            p2i((oopDesc*)oop_field), p2i((oopDesc*)archived_oop_field));\n+        SystemDictionaryShared::add_enum_klass_static_field(ik, root_index);\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ See comments in HeapShared::check_enum_obj()\n+bool HeapShared::initialize_enum_klass(InstanceKlass* k, TRAPS) {\n+  if (!is_fully_available()) {\n+    return false;\n+  }\n+\n+  RunTimeClassInfo* info = RunTimeClassInfo::get_for(k);\n+  assert(info != NULL, \"sanity\");\n+\n+  if (log_is_enabled(Info, cds, heap)) {\n+    ResourceMark rm;\n+    log_info(cds, heap)(\"Initializing Enum class: %s\", k->external_name());\n+  }\n+\n+  oop mirror = k->java_mirror();\n+  int i = 0;\n+  for (JavaFieldStream fs(k); !fs.done(); fs.next()) {\n+    if (fs.access_flags().is_static()) {\n+      int root_index = info->enum_klass_static_field_root_index_at(i++);\n+      fieldDescriptor& fd = fs.field_descriptor();\n+      assert(fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY, \"must be\");\n+      mirror->obj_field_put(fd.offset(), get_root(root_index, \/*clear=*\/true));\n+    }\n+  }\n+  return true;\n+}\n+\n@@ -380,0 +482,1 @@\n+    CDSHeapVerifier::verify();\n@@ -891,0 +994,5 @@\n+\n+  \/\/ The following are for maintaining a stack for determining\n+  \/\/ CachedOopInfo::_referrer\n+  static WalkOopAndArchiveClosure* _current;\n+  WalkOopAndArchiveClosure* _last;\n@@ -900,1 +1008,7 @@\n-    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {}\n+    _orig_referencing_obj(orig), _archived_referencing_obj(archived) {\n+    _last = _current;\n+    _current = this;\n+  }\n+  ~WalkOopAndArchiveClosure() {\n+    _current = _last;\n+  }\n@@ -937,0 +1051,5 @@\n+\n+ public:\n+  static WalkOopAndArchiveClosure* current()  { return _current;              }\n+  oop orig_referencing_obj()                  { return _orig_referencing_obj; }\n+  KlassSubGraphInfo* subgraph_info()          { return _subgraph_info;        }\n@@ -939,0 +1058,13 @@\n+WalkOopAndArchiveClosure* WalkOopAndArchiveClosure::_current = NULL;\n+\n+HeapShared::CachedOopInfo HeapShared::make_cached_oop_info(oop orig_obj) {\n+  CachedOopInfo info;\n+  WalkOopAndArchiveClosure* walker = WalkOopAndArchiveClosure::current();\n+\n+  info._subgraph_info = (walker == NULL) ? NULL : walker->subgraph_info();\n+  info._referrer = (walker == NULL) ? NULL : walker->orig_referencing_obj();\n+  info._obj = orig_obj;\n+\n+  return info;\n+}\n+\n@@ -1064,0 +1196,2 @@\n+\n+  check_enum_obj(level + 1, subgraph_info, orig_obj, is_closed_archive);\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":144,"deletions":10,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+class KlassSubGraphInfo;\n@@ -196,1 +197,1 @@\n-\n+  static bool is_subgraph_root_class(InstanceKlass* ik);\n@@ -231,0 +232,7 @@\n+  struct CachedOopInfo {\n+    KlassSubGraphInfo* _subgraph_info;\n+    oop _referrer;\n+    oop _obj;\n+    CachedOopInfo() :_subgraph_info(), _referrer(), _obj() {}\n+  };\n+\n@@ -232,0 +240,4 @@\n+  static void check_enum_obj(int level,\n+                             KlassSubGraphInfo* subgraph_info,\n+                             oop orig_obj,\n+                             bool is_closed_archive);\n@@ -236,1 +248,1 @@\n-  typedef ResourceHashtable<oop, oop,\n+  typedef ResourceHashtable<oop, CachedOopInfo,\n@@ -275,1 +287,1 @@\n-\n+  static CachedOopInfo make_cached_oop_info(oop orig_obj);\n@@ -472,0 +484,1 @@\n+  static bool initialize_enum_klass(InstanceKlass* k, TRAPS) NOT_CDS_JAVA_HEAP_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":16,"deletions":3,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -67,0 +67,9 @@\n+  if (_klass->has_archived_enum_objs()) {\n+    int num = info.num_enum_klass_static_fields();\n+    set_num_enum_klass_static_fields(num);\n+    for (int i = 0; i < num; i++) {\n+      int root_index = info.enum_klass_static_field(i);\n+      set_enum_klass_static_field_root_index_at(i, root_index);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -67,0 +67,4 @@\n+  struct RTEnumKlassStaticFields {\n+    int _num;\n+    int _root_indices[1];\n+  };\n@@ -72,5 +76,6 @@\n-  \/\/ optional CrcInfo              _crc;  (only for UNREGISTERED classes)\n-  \/\/ optional InstanceKlass*       _nest_host\n-  \/\/ optional RTLoaderConstraint   _loader_constraint_types[_num_loader_constraints]\n-  \/\/ optional RTVerifierConstraint _verifier_constraints[_num_verifier_constraints]\n-  \/\/ optional char                 _verifier_constraint_flags[_num_verifier_constraints]\n+  \/\/ optional CrcInfo                 _crc;  (only for UNREGISTERED classes)\n+  \/\/ optional InstanceKlass*          _nest_host\n+  \/\/ optional RTLoaderConstraint      _loader_constraint_types[_num_loader_constraints]\n+  \/\/ optional RTVerifierConstraint    _verifier_constraints[_num_verifier_constraints]\n+  \/\/ optional char                    _verifier_constraint_flags[_num_verifier_constraints]\n+  \/\/ optional RTEnumKlassStaticFields _enum_klass_static_fields;\n@@ -80,1 +85,1 @@\n-    return sizeof(RunTimeClassInfo);\n+    return align_up(sizeof(RunTimeClassInfo), wordSize);\n@@ -83,1 +88,1 @@\n-    return sizeof(RTVerifierConstraint) * num_verifier_constraints;\n+    return align_up(sizeof(RTVerifierConstraint) * num_verifier_constraints, wordSize);\n@@ -86,1 +91,1 @@\n-    return sizeof(char) * num_verifier_constraints;\n+    return align_up(sizeof(char) * num_verifier_constraints, wordSize);\n@@ -89,1 +94,5 @@\n-    return sizeof(RTLoaderConstraint) * num_loader_constraints;\n+    return align_up(sizeof(RTLoaderConstraint) * num_loader_constraints, wordSize);\n+  }\n+  static size_t enum_klass_static_fields_size(int num_fields) {\n+    size_t size = num_fields <= 0 ? 0 : sizeof(RTEnumKlassStaticFields) + (num_fields - 1) * sizeof(int);\n+    return align_up(size, wordSize);\n@@ -91,0 +100,1 @@\n+\n@@ -101,1 +111,2 @@\n-  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints) {\n+  static size_t byte_size(InstanceKlass* klass, int num_verifier_constraints, int num_loader_constraints,\n+                          int num_enum_klass_static_fields) {\n@@ -107,1 +118,2 @@\n-           verifier_constraint_flags_size(num_verifier_constraints);\n+           verifier_constraint_flags_size(num_verifier_constraints) +\n+           enum_klass_static_fields_size(num_enum_klass_static_fields);\n@@ -116,1 +128,1 @@\n-      return crc_offset() + crc_size(_klass);\n+    return crc_offset() + crc_size(_klass);\n@@ -128,0 +140,3 @@\n+  size_t enum_klass_static_fields_offset() const {\n+    return verifier_constraint_flags_offset() + verifier_constraint_flags_size(_num_verifier_constraints);\n+  }\n@@ -137,0 +152,5 @@\n+  RTEnumKlassStaticFields* enum_klass_static_fields_addr() const {\n+    assert(_klass->has_archived_enum_objs(), \"sanity\");\n+    return (RTEnumKlassStaticFields*)(address(this) + enum_klass_static_fields_offset());\n+  }\n+\n@@ -190,0 +210,17 @@\n+  int num_enum_klass_static_fields(int i) const {\n+    return enum_klass_static_fields_addr()->_num;\n+  }\n+\n+  void set_num_enum_klass_static_fields(int num) {\n+    enum_klass_static_fields_addr()->_num = num;\n+  }\n+\n+  int enum_klass_static_field_root_index_at(int i) const {\n+    assert(0 <= i && i < enum_klass_static_fields_addr()->_num, \"must be\");\n+    return enum_klass_static_fields_addr()->_root_indices[i];\n+  }\n+\n+  void set_enum_klass_static_field_root_index_at(int i, int root_index) {\n+    assert(0 <= i && i < enum_klass_static_fields_addr()->_num, \"must be\");\n+    enum_klass_static_fields_addr()->_root_indices[i] = root_index;\n+  }\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":49,"deletions":12,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -791,0 +791,7 @@\n+void SystemDictionaryShared::add_enum_klass_static_field(InstanceKlass* ik, int root_index) {\n+  assert(DumpSharedSpaces, \"static dump only\");\n+  DumpTimeClassInfo* info = SystemDictionaryShared::find_or_allocate_info_for_locked(ik);\n+  assert(info != NULL, \"must be\");\n+  info->add_enum_klass_static_field(root_index);\n+}\n+\n@@ -1172,1 +1179,1 @@\n-      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = info.runtime_info_bytesize();\n@@ -1281,1 +1288,1 @@\n-      size_t byte_size = RunTimeClassInfo::byte_size(info._klass, info.num_verifier_constraints(), info.num_loader_constraints());\n+      size_t byte_size = info.runtime_info_bytesize();\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -196,0 +196,3 @@\n+  static bool has_archived_enum_objs(InstanceKlass* ik);\n+  static void set_has_archived_enum_objs(InstanceKlass* ik);\n+\n@@ -246,0 +249,1 @@\n+  static void add_enum_klass_static_field(InstanceKlass* ik, int root_index);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -139,0 +139,1 @@\n+  do_klass(Enum_klass,                                  java_lang_Enum                                        ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -702,0 +702,1 @@\n+  template(java_lang_Enum,                                  \"java\/lang\/Enum\")                                     \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -1506,0 +1507,11 @@\n+#if INCLUDE_CDS\n+  \/\/ This is needed to ensure the consistency of the archived heap objects.\n+  if (has_archived_enum_objs()) {\n+    assert(is_shared(), \"must be\");\n+    bool initialized = HeapShared::initialize_enum_klass(this, CHECK);\n+    if (initialized) {\n+      return;\n+    }\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -173,3 +173,4 @@\n-    _archived_lambda_proxy_is_available = 2,\n-    _has_value_based_class_annotation = 4,\n-    _verified_at_dump_time = 8\n+    _archived_lambda_proxy_is_available    = 1 << 1,\n+    _has_value_based_class_annotation      = 1 << 2,\n+    _verified_at_dump_time                 = 1 << 3,\n+    _has_archived_enum_objs                = 1 << 4\n@@ -339,0 +340,7 @@\n+  void set_has_archived_enum_objs() {\n+    CDS_ONLY(_shared_class_flags |= _has_archived_enum_objs;)\n+  }\n+  bool has_archived_enum_objs() const {\n+    CDS_ONLY(return (_shared_class_flags & _has_archived_enum_objs) != 0;)\n+    NOT_CDS(return false;)\n+  }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleDescriptor.Requires;\n+import java.lang.module.ModuleDescriptor.Requires.Modifier;\n+import java.util.Optional;\n+\n+public class ArchivedEnumApp {\n+    public static void main(final String[] args) throws Exception {\n+        \/\/ Validate the archiving of the synthetic Modifier.$VALUES field:\n+        for (Modifier mod : Modifier.values()) {\n+            check(mod);\n+        }\n+        if (Modifier.values().length != 4) {\n+            throw new RuntimeException(\"Modifier.$VALUES.length expeced: 4, actual: \" + Modifier.values().length);\n+        }\n+\n+        \/\/ All 4 enums must exist in synthetic Modifier.$VALUES\n+        check_in_array(Modifier.MANDATED);\n+        check_in_array(Modifier.STATIC);\n+        check_in_array(Modifier.SYNTHETIC);\n+        check_in_array(Modifier.TRANSITIVE);\n+\n+        \/\/ Find this module from (archived) boot layer\n+        String moduleName = \"java.management\";\n+        Optional<Module> module = ModuleLayer.boot().findModule(moduleName);\n+        if (module.isEmpty()) {\n+            throw new RuntimeException(moduleName + \" module is missing in boot layer\");\n+        }\n+        ModuleDescriptor md = module.get().getDescriptor();\n+        System.out.println(\"Module: \" + md);\n+        for (Requires r : md.requires()) {\n+            System.out.println(\"Requires: \" + r);\n+            for (Modifier mod : r.modifiers()) {\n+                System.out.println(\"   modifier: \" + mod);\n+                check(mod);\n+            }\n+        }\n+\n+        System.out.println(\"Success\");\n+    }\n+\n+    static void check(Modifier mod) {\n+        \/\/ The archived Enum object must equal to one of the following\n+        \/\/ four values.\n+        if (mod != Modifier.MANDATED &&\n+            mod != Modifier.STATIC &&\n+            mod != Modifier.SYNTHETIC &&\n+            mod != Modifier.TRANSITIVE) {\n+\n+            System.out.println(\"mod                 = \" + info(mod));\n+            System.out.println(\"Modifier.MANDATED   = \" + info(Modifier.MANDATED));\n+            System.out.println(\"Modifier.STATIC     = \" + info(Modifier.STATIC));\n+            System.out.println(\"Modifier.SYNTHETIC  = \" + info(Modifier.SYNTHETIC));\n+            System.out.println(\"Modifier.TRANSITIVE = \" + info(Modifier.TRANSITIVE));\n+\n+            throw new RuntimeException(\"Archived enum object does not match static fields in enum class: \" + info(mod));\n+        }\n+    }\n+\n+    static void check_in_array(Modifier mod) {\n+        for (Modifier m : Modifier.values()) {\n+            if (mod == m) {\n+                return;\n+            }\n+        }\n+        throw new RuntimeException(\"Enum object is not in $VALUES array: \" + info(mod));\n+    }\n+\n+    static String info(Object o) {\n+        return \"@0x\" + Integer.toHexString(System.identityHashCode(o)) + \" \" + o;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumApp.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8275731\n+ * @summary Enum objects that are stored in the archived module graph should match\n+ *          the static final fields in the Enum class.\n+ * @modules java.management\n+ * @requires vm.cds.write.archived.java.heap\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build ArchivedEnumApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar ArchivedEnumApp.jar ArchivedEnumApp\n+ * @run driver ArchivedEnumTest\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ArchivedEnumTest {\n+    public static void main(String[] args) throws Exception {\n+        String appJar = ClassFileInstaller.getJarPath(\"ArchivedEnumApp.jar\");\n+\n+        OutputAnalyzer out = TestCommon.testDump(appJar,\n+                                                 TestCommon.list(\"ArchivedEnumApp\"));\n+        \/\/ Note: You can get the following line to fail by commenting out\n+        \/\/ the ADD_EXCL(...) lines in cdsHeapVerifier.cpp\n+        out.shouldNotContain(\"object points to a static field that may be reinitialized at runtime\");\n+\n+        TestCommon.run(\"-cp\", appJar,\n+                       \"-Xlog:cds=debug\",\n+                       \"-Xlog:cds+heap\",\n+                       \"ArchivedEnumApp\").assertNormalExit(\"Success\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/ArchivedEnumTest.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"}]}