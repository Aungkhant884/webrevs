{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, NULL}; add(e); }\n+# define ADD_EXCL(...) { static const char* e[] = {__VA_ARGS__, NULL}; add_exclusion(e); }\n@@ -148,0 +148,51 @@\n+class CDSHeapVerifier::CheckStaticFields : public FieldClosure {\n+  CDSHeapVerifier* _verifier;\n+  InstanceKlass* _ik;\n+  const char** _exclusions;\n+public:\n+  CheckStaticFields(CDSHeapVerifier* verifier, InstanceKlass* ik)\n+    : _verifier(verifier), _ik(ik) {\n+    _exclusions = _verifier->find_exclusion(_ik);\n+  }\n+\n+  void do_field(fieldDescriptor* fd) {\n+    if (fd->field_type() != T_OBJECT) {\n+      return;\n+    }\n+\n+    oop static_obj_field = _ik->java_mirror()->obj_field(fd->offset());\n+    if (static_obj_field != NULL) {\n+      Klass* klass = static_obj_field->klass();\n+      if (_exclusions != NULL) {\n+        for (const char** p = _exclusions; *p != NULL; p++) {\n+          if (fd->name()->equals(*p)) {\n+            return;\n+          }\n+        }\n+      }\n+\n+      if (fd->is_final() && java_lang_String::is_instance(static_obj_field) && fd->has_initial_value()) {\n+        \/\/ This field looks like like this in the Java source:\n+        \/\/    static final SOME_STRING = \"a string literal\";\n+        \/\/ This string literal has been stored in the shared string table, so it's OK\n+        \/\/ for the archived objects to refer to it.\n+        return;\n+      }\n+      if (fd->is_final() && java_lang_Class::is_instance(static_obj_field)) {\n+        \/\/ This field points to an archived mirror.\n+        return;\n+      }\n+      if (klass->has_archived_enum_objs()) {\n+        \/\/ This klass is a subclass of java.lang.Enum. If any instance of this klass\n+        \/\/ has been archived, we will archive all static fields of this klass.\n+        \/\/ See HeapShared::initialize_enum_klass().\n+        return;\n+      }\n+\n+      \/\/ This field *may* be initialized to a different value at runtime. Remember it\n+      \/\/ and check later if it appears in the archived object graph.\n+      _verifier->add_static_obj_field(_ik, static_obj_field, fd->name());\n+    }\n+  }\n+};\n+\n@@ -153,3 +204,0 @@\n-    oop mirror = ik->java_mirror();\n-    int n = 0;\n-    const char** exclusions = find_exclusion(ik);\n@@ -164,47 +212,2 @@\n-    ResourceMark rm;\n-    for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n-      if (fs.access_flags().is_static()) {\n-        fieldDescriptor& fd = fs.field_descriptor();\n-        if (fd.field_type() == T_OBJECT) {\n-          oop static_obj_field = mirror->obj_field(fd.offset());\n-          if (static_obj_field != NULL) {\n-            Klass* klass = static_obj_field->klass();\n-            if (exclusions != NULL) {\n-              bool excluded = false;\n-              for (const char** p = exclusions; *p != NULL; p++) {\n-                if (fd.name()->equals(*p)) {\n-                  excluded = true;\n-                  break;\n-                }\n-              }\n-              if (excluded) {\n-                continue;\n-              }\n-            }\n-\n-            if (fd.is_final() && java_lang_String::is_instance(static_obj_field) && fd.has_initial_value()) {\n-              \/\/ This field looks like like this in the Java source:\n-              \/\/    static final SOME_STRING = \"a string literal\";\n-              \/\/ This string literal has been stored in the shared string table, so it's OK\n-              \/\/ for the archived objects to refer to it.\n-              continue;\n-            }\n-            if (fd.is_final() && java_lang_Class::is_instance(static_obj_field)) {\n-              \/\/ This field points to an archived mirror.\n-              continue;\n-            }\n-            if (klass->has_archived_enum_objs()) {\n-              \/\/ This klass is a subclass of java.lang.Enum. If any instance of this klass\n-              \/\/ has been archived, we will archive all static fields of this klass.\n-              \/\/ See HeapShared::initialize_enum_klass().\n-              continue;\n-            }\n-\n-            \/\/ This field *may* be initialized to a different value at runtime. Remember it\n-            \/\/ and check later if it appears in the archived object graph.\n-            StaticFieldInfo info = {ik, fd.name()};\n-            _table.put(static_obj_field, info);\n-          }\n-        }\n-      }\n-    }\n+    CheckStaticFields csf(this, ik);\n+    ik->do_local_static_fields(&csf);\n@@ -214,0 +217,5 @@\n+void CDSHeapVerifier::add_static_obj_field(InstanceKlass* ik, oop field, Symbol* name) {\n+  StaticFieldInfo info = {ik, name};\n+  _table.put(field, info);\n+}\n+\n@@ -235,0 +243,20 @@\n+class CDSHeapVerifier::TraceFields : public FieldClosure {\n+  oop _orig_obj;\n+  oop _orig_field;\n+  LogStream* _ls;\n+\n+public:\n+  TraceFields(oop orig_obj, oop orig_field, LogStream* ls)\n+    : _orig_obj(orig_obj), _orig_field(orig_field), _ls(ls) {}\n+\n+  void do_field(fieldDescriptor* fd) {\n+    if (fd->field_type() == T_OBJECT || fd->field_type() == T_ARRAY) {\n+      oop obj_field = _orig_obj->obj_field(fd->offset());\n+      if (obj_field == _orig_field) {\n+        _ls->print(\"::%s (offset = %d)\", fd->name()->as_C_string(), fd->offset());\n+      }\n+    }\n+  }\n+};\n+\n+\/\/ Hint: to exercise this function, uncomment out one of the ADD_EXCL lines above.\n@@ -252,13 +280,2 @@\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      for (JavaFieldStream fs(ik); !fs.done(); fs.next()) {\n-        if (!fs.access_flags().is_static()) {\n-          fieldDescriptor& fd = fs.field_descriptor();\n-          if (fd.field_type() == T_OBJECT || fd.field_type() == T_ARRAY) {\n-            oop obj_field = orig_obj->obj_field(fd.offset());\n-            if (obj_field == orig_field) {\n-              ls.print(\"::%s (offset = %d)\", fd.name()->as_C_string(), fd.offset());\n-              break;\n-            }\n-          }\n-        }\n-      }\n+      TraceFields clo(orig_obj, orig_field, &ls);;\n+      InstanceKlass::cast(k)->do_nonstatic_fields(&clo);\n@@ -281,0 +298,1 @@\n+#ifdef ASSERT\n@@ -285,0 +303,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.cpp","additions":84,"deletions":65,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,3 @@\n+  class CheckStaticFields;\n+  class TraceFields;\n+\n@@ -55,1 +58,1 @@\n-  void add(const char** excl) {\n+  void add_exclusion(const char** excl) {\n@@ -58,0 +61,1 @@\n+  void add_static_obj_field(InstanceKlass* ik, oop field, Symbol* name);\n@@ -81,1 +85,1 @@\n-  static void verify();\n+  static void verify() NOT_DEBUG_RETURN;\n","filename":"src\/hotspot\/share\/cds\/cdsHeapVerifier.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"}]}