{"files":[{"patch":"@@ -218,2 +218,15 @@\n-      $1SYSROOT_CFLAGS=\"-isysroot [$]$1SYSROOT\"\n-      $1SYSROOT_LDFLAGS=\"-isysroot [$]$1SYSROOT\"\n+      if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\"; then\n+        # -isysroot has no effect on linux\n+        # https:\/\/bugs.llvm.org\/show_bug.cgi?id=11503\n+        $1SYSROOT_CFLAGS=\"--sysroot=[$]$1SYSROOT\"\n+        $1SYSROOT_LDFLAGS=\"--sysroot=[$]$1SYSROOT\"\n+        if test -d \"$DEVKIT_TOOLCHAIN_PATH\"; then\n+          # In devkits, gcc is not located in the sysroot.\n+          # use --gcc-toolchain to let clang find the gcc installation.\n+          $1SYSROOT_CFLAGS=\"[$]$1SYSROOT_CFLAGS --gcc-toolchain=$DEVKIT_TOOLCHAIN_PATH\/..\"\n+          $1SYSROOT_LDFLAGS=\"[$]$1SYSROOT_LDFLAGS --gcc-toolchain=$DEVKIT_TOOLCHAIN_PATH\/..\"\n+        fi\n+      else\n+        $1SYSROOT_CFLAGS=\"-isysroot [$]$1SYSROOT\"\n+        $1SYSROOT_LDFLAGS=\"-isysroot [$]$1SYSROOT\"\n+      fi\n","filename":"make\/autoconf\/flags.m4","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-DEFAULT_VERSION_FEATURE=18\n+DEFAULT_VERSION_FEATURE=19\n@@ -36,2 +36,2 @@\n-DEFAULT_VERSION_DATE=2022-03-22\n-DEFAULT_VERSION_CLASSFILE_MAJOR=62  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n+DEFAULT_VERSION_DATE=2022-09-20\n+DEFAULT_VERSION_CLASSFILE_MAJOR=63  # \"`$EXPR $DEFAULT_VERSION_FEATURE + 44`\"\n@@ -40,2 +40,2 @@\n-DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"17 18\"\n-DEFAULT_JDK_SOURCE_TARGET_VERSION=18\n+DEFAULT_ACCEPTABLE_BOOT_VERSIONS=\"17 18 19\"\n+DEFAULT_JDK_SOURCE_TARGET_VERSION=19\n","filename":"make\/conf\/version-numbers.conf","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,742 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name java.base\n+header exports java\/io,java\/lang,java\/lang\/annotation,java\/lang\/constant,java\/lang\/invoke,java\/lang\/module,java\/lang\/ref,java\/lang\/reflect,java\/lang\/runtime,java\/math,java\/net,java\/net\/spi,java\/nio,java\/nio\/channels,java\/nio\/channels\/spi,java\/nio\/charset,java\/nio\/charset\/spi,java\/nio\/file,java\/nio\/file\/attribute,java\/nio\/file\/spi,java\/security,java\/security\/cert,java\/security\/interfaces,java\/security\/spec,java\/text,java\/text\/spi,java\/time,java\/time\/chrono,java\/time\/format,java\/time\/temporal,java\/time\/zone,java\/util,java\/util\/concurrent,java\/util\/concurrent\/atomic,java\/util\/concurrent\/locks,java\/util\/function,java\/util\/jar,java\/util\/random,java\/util\/regex,java\/util\/spi,java\/util\/stream,java\/util\/zip,javax\/crypto,javax\/crypto\/interfaces,javax\/crypto\/spec,javax\/net,javax\/net\/ssl,javax\/security\/auth,javax\/security\/auth\/callback,javax\/security\/auth\/login,javax\/security\/auth\/spi,javax\/security\/auth\/x500,javax\/security\/cert,jdk\/internal\/event[jdk.jfr],jdk\/internal\/vm\/vector[jdk.incubator.vector] uses java\/lang\/System$LoggerFinder,java\/net\/ContentHandlerFactory,java\/net\/spi\/InetAddressResolverProvider,java\/net\/spi\/URLStreamHandlerProvider,java\/nio\/channels\/spi\/AsynchronousChannelProvider,java\/nio\/channels\/spi\/SelectorProvider,java\/nio\/charset\/spi\/CharsetProvider,java\/nio\/file\/spi\/FileSystemProvider,java\/nio\/file\/spi\/FileTypeDetector,java\/security\/Provider,java\/text\/spi\/BreakIteratorProvider,java\/text\/spi\/CollatorProvider,java\/text\/spi\/DateFormatProvider,java\/text\/spi\/DateFormatSymbolsProvider,java\/text\/spi\/DecimalFormatSymbolsProvider,java\/text\/spi\/NumberFormatProvider,java\/time\/chrono\/AbstractChronology,java\/time\/chrono\/Chronology,java\/time\/zone\/ZoneRulesProvider,java\/util\/random\/RandomGenerator,java\/util\/spi\/CalendarDataProvider,java\/util\/spi\/CalendarNameProvider,java\/util\/spi\/CurrencyNameProvider,java\/util\/spi\/LocaleNameProvider,java\/util\/spi\/ResourceBundleControlProvider,java\/util\/spi\/ResourceBundleProvider,java\/util\/spi\/TimeZoneNameProvider,java\/util\/spi\/ToolProvider,javax\/security\/auth\/spi\/LoginModule,jdk\/internal\/logger\/DefaultLoggerFinder,sun\/text\/spi\/JavaTimeDateTimePatternProvider,sun\/util\/locale\/provider\/LocaleDataMetaInfo,sun\/util\/resources\/LocaleData$CommonResourceBundleProvider,sun\/util\/resources\/LocaleData$SupplementaryResourceBundleProvider,sun\/util\/spi\/CalendarProvider provides interface\\u0020;java\/nio\/file\/spi\/FileSystemProvider\\u0020;impls\\u0020;jdk\/internal\/jrtfs\/JrtFileSystemProvider,interface\\u0020;java\/util\/random\/RandomGenerator\\u0020;impls\\u0020;java\/security\/SecureRandom\\u005C;u002C;java\/util\/Random\\u005C;u002C;java\/util\/SplittableRandom target linux-amd64 flags 8000\n+\n+class name java\/io\/FileInputStream\n+method name transferTo descriptor (Ljava\/io\/OutputStream;)J thrownTypes java\/io\/IOException flags 1\n+\n+class name java\/io\/ObjectInputStream$GetField\n+-method name get descriptor (Ljava\/lang\/String;Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+method name get descriptor (Ljava\/lang\/String;Ljava\/lang\/Object;)Ljava\/lang\/Object; thrownTypes java\/io\/IOException,java\/lang\/ClassNotFoundException flags 401\n+\n+class name java\/io\/PrintStream\n+header extends java\/io\/FilterOutputStream implements java\/lang\/Appendable,java\/io\/Closeable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+method name charset descriptor ()Ljava\/nio\/charset\/Charset; flags 1\n+\n+class name java\/lang\/AbstractStringBuilder\n+header extends java\/lang\/Object implements java\/lang\/Appendable,java\/lang\/CharSequence flags 420\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/Compiler\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Deprecated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;MODULE;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;TYPE;})\n+\n+class name java\/lang\/Enum\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V flags 14 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"18\")\n+\n+class name java\/lang\/IllegalCallerException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/LayerInstantiationException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/Math\n+method name divideExact descriptor (II)I flags 9\n+method name divideExact descriptor (JJ)J flags 9\n+method name floorDivExact descriptor (II)I flags 9\n+method name floorDivExact descriptor (JJ)J flags 9\n+method name ceilDivExact descriptor (II)I flags 9\n+method name ceilDivExact descriptor (JJ)J flags 9\n+method name unsignedMultiplyHigh descriptor (JJ)J flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name ceilDiv descriptor (II)I flags 9\n+method name ceilDiv descriptor (JI)J flags 9\n+method name ceilDiv descriptor (JJ)J flags 9\n+method name ceilMod descriptor (II)I flags 9\n+method name ceilMod descriptor (JI)I flags 9\n+method name ceilMod descriptor (JJ)J flags 9\n+\n+class name java\/lang\/NamedPackage\n+header extends java\/lang\/Object flags 20\n+\n+class name java\/lang\/Object\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/lang\/Runtime\n+-method name exec descriptor (Ljava\/lang\/String;)Ljava\/lang\/Process;\n+-method name exec descriptor (Ljava\/lang\/String;[Ljava\/lang\/String;)Ljava\/lang\/Process;\n+-method name exec descriptor (Ljava\/lang\/String;[Ljava\/lang\/String;Ljava\/io\/File;)Ljava\/lang\/Process;\n+-method name runFinalization descriptor ()V\n+method name exec descriptor (Ljava\/lang\/String;)Ljava\/lang\/Process; thrownTypes java\/io\/IOException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")\n+method name exec descriptor (Ljava\/lang\/String;[Ljava\/lang\/String;)Ljava\/lang\/Process; thrownTypes java\/io\/IOException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")\n+method name exec descriptor (Ljava\/lang\/String;[Ljava\/lang\/String;Ljava\/io\/File;)Ljava\/lang\/Process; thrownTypes java\/io\/IOException flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")\n+method name runFinalization descriptor ()V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"18\")\n+\n+class name java\/lang\/StrictMath\n+method name divideExact descriptor (II)I flags 9\n+method name divideExact descriptor (JJ)J flags 9\n+method name floorDivExact descriptor (II)I flags 9\n+method name floorDivExact descriptor (JJ)J flags 9\n+method name ceilDivExact descriptor (II)I flags 9\n+method name ceilDivExact descriptor (JJ)J flags 9\n+method name unsignedMultiplyHigh descriptor (JJ)J flags 9\n+method name ceilDiv descriptor (II)I flags 9\n+method name ceilDiv descriptor (JI)J flags 9\n+method name ceilDiv descriptor (JJ)J flags 9\n+method name ceilMod descriptor (II)I flags 9\n+method name ceilMod descriptor (JI)I flags 9\n+method name ceilMod descriptor (JJ)J flags 9\n+\n+class name java\/lang\/SuppressWarnings\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;PARAMETER;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;MODULE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)\n+\n+class name java\/lang\/System\n+-method name runFinalization descriptor ()V\n+method name runFinalization descriptor ()V flags 9 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"18\")\n+\n+class name java\/lang\/Thread\n+-method name stop descriptor ()V\n+method name stop descriptor ()V flags 11 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/lang\/constant\/ClassDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfField sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfField<Ljava\/lang\/constant\/ClassDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+\n+class name java\/lang\/constant\/ConstantDesc\n+header extends java\/lang\/Object sealed true flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/constant\/DirectMethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/MethodHandleDesc nestMembers java\/lang\/constant\/DirectMethodHandleDesc$Kind sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodHandleDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc sealed true flags 601\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+\n+class name java\/lang\/constant\/MethodTypeDesc\n+header extends java\/lang\/Object implements java\/lang\/constant\/ConstantDesc,java\/lang\/invoke\/TypeDescriptor$OfMethod sealed true flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/constant\/ConstantDesc;Ljava\/lang\/invoke\/TypeDescriptor$OfMethod<Ljava\/lang\/constant\/ClassDesc;Ljava\/lang\/constant\/MethodTypeDesc;>;\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfMethod outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfMethod flags 609\n+innerclass innerClass java\/lang\/invoke\/TypeDescriptor$OfField outerClass java\/lang\/invoke\/TypeDescriptor innerClassName OfField flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/CallSite\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/LambdaMetafactory\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/invoke\/MethodHandle\n+-method name asType descriptor (Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/MethodHandle;\n+method name asType descriptor (Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/MethodHandle; flags 11\n+\n+class name java\/lang\/invoke\/StringConcatException\n+header extends java\/lang\/Exception flags 21\n+\n+class name java\/lang\/module\/Configuration\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/module\/FindException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/InvalidModuleDescriptorException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ModuleReader\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 601\n+\n+class name java\/lang\/module\/ModuleReference\n+header extends java\/lang\/Object flags 421\n+\n+class name java\/lang\/module\/ResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/module\/ResolvedModule\n+header extends java\/lang\/Object flags 31\n+\n+class name java\/lang\/reflect\/AccessibleObject\n+header extends java\/lang\/Object implements java\/lang\/reflect\/AnnotatedElement flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/lang\/reflect\/AnnotatedElement\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/Executable\n+header extends java\/lang\/reflect\/AccessibleObject implements java\/lang\/reflect\/Member,java\/lang\/reflect\/GenericDeclaration sealed true flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/reflect\/InaccessibleObjectException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name java\/lang\/reflect\/Method\n+-method name invoke descriptor (Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+method name invoke descriptor (Ljava\/lang\/Object;[Ljava\/lang\/Object;)Ljava\/lang\/Object; thrownTypes java\/lang\/IllegalAccessException,java\/lang\/reflect\/InvocationTargetException flags 81 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;@Ljdk\/internal\/vm\/annotation\/ForceInline;@Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n+class name java\/net\/DatagramSocket\n+header extends java\/lang\/Object implements java\/io\/Closeable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+\n+class name java\/net\/InetAddress\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/net\/spi\/InetAddressResolver$LookupPolicy outerClass java\/net\/spi\/InetAddressResolver innerClassName LookupPolicy flags 19\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/net\/ServerSocket\n+-method name setSoTimeout descriptor (I)V\n+-method name getSoTimeout descriptor ()I\n+-method name setReceiveBufferSize descriptor (I)V\n+-method name getReceiveBufferSize descriptor ()I\n+method name setSoTimeout descriptor (I)V thrownTypes java\/net\/SocketException flags 1\n+method name getSoTimeout descriptor ()I thrownTypes java\/io\/IOException flags 1\n+method name setReceiveBufferSize descriptor (I)V thrownTypes java\/net\/SocketException flags 1\n+method name getReceiveBufferSize descriptor ()I thrownTypes java\/net\/SocketException flags 1\n+\n+class name java\/net\/SocketImpl\n+header extends java\/lang\/Object implements java\/net\/SocketOptions flags 421\n+\n+class name java\/net\/spi\/InetAddressResolver\n+header extends java\/lang\/Object nestMembers java\/net\/spi\/InetAddressResolver$LookupPolicy flags 601\n+innerclass innerClass java\/net\/spi\/InetAddressResolver$LookupPolicy outerClass java\/net\/spi\/InetAddressResolver innerClassName LookupPolicy flags 19\n+method name lookupByName descriptor (Ljava\/lang\/String;Ljava\/net\/spi\/InetAddressResolver$LookupPolicy;)Ljava\/util\/stream\/Stream; thrownTypes java\/net\/UnknownHostException flags 401 signature (Ljava\/lang\/String;Ljava\/net\/spi\/InetAddressResolver$LookupPolicy;)Ljava\/util\/stream\/Stream<Ljava\/net\/InetAddress;>;\n+method name lookupByAddress descriptor ([B)Ljava\/lang\/String; thrownTypes java\/net\/UnknownHostException flags 401\n+\n+class name java\/net\/spi\/InetAddressResolver$LookupPolicy\n+header extends java\/lang\/Object nestHost java\/net\/spi\/InetAddressResolver flags 31\n+innerclass innerClass java\/net\/spi\/InetAddressResolver$LookupPolicy outerClass java\/net\/spi\/InetAddressResolver innerClassName LookupPolicy flags 19\n+field name IPV4 descriptor I constantValue 1 flags 19\n+field name IPV6 descriptor I constantValue 2 flags 19\n+field name IPV4_FIRST descriptor I constantValue 4 flags 19\n+field name IPV6_FIRST descriptor I constantValue 8 flags 19\n+method name of descriptor (I)Ljava\/net\/spi\/InetAddressResolver$LookupPolicy; flags 9\n+method name characteristics descriptor ()I flags 1\n+\n+class name java\/net\/spi\/InetAddressResolverProvider\n+header extends java\/lang\/Object nestMembers java\/net\/spi\/InetAddressResolverProvider$Configuration flags 421\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+method name get descriptor (Ljava\/net\/spi\/InetAddressResolverProvider$Configuration;)Ljava\/net\/spi\/InetAddressResolver; flags 401\n+method name name descriptor ()Ljava\/lang\/String; flags 401\n+method name <init> descriptor ()V flags 4\n+\n+class name java\/net\/spi\/InetAddressResolverProvider$Configuration\n+header extends java\/lang\/Object nestHost java\/net\/spi\/InetAddressResolverProvider sealed true flags 601\n+innerclass innerClass java\/net\/spi\/InetAddressResolverProvider$Configuration outerClass java\/net\/spi\/InetAddressResolverProvider innerClassName Configuration flags 609\n+method name builtinResolver descriptor ()Ljava\/net\/spi\/InetAddressResolver; flags 401\n+method name lookupLocalHostName descriptor ()Ljava\/lang\/String; flags 401\n+\n+class name java\/net\/spi\/URLStreamHandlerProvider\n+header extends java\/lang\/Object implements java\/net\/URLStreamHandlerFactory flags 421\n+\n+class name java\/nio\/CharBuffer\n+header extends java\/nio\/Buffer implements java\/lang\/Comparable,java\/lang\/Appendable,java\/lang\/CharSequence,java\/lang\/Readable flags 421 signature Ljava\/nio\/Buffer;Ljava\/lang\/Comparable<Ljava\/nio\/CharBuffer;>;Ljava\/lang\/Appendable;Ljava\/lang\/CharSequence;Ljava\/lang\/Readable;\n+innerclass innerClass java\/util\/Spliterator$OfInt outerClass java\/util\/Spliterator innerClassName OfInt flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/nio\/charset\/Charset\n+method name forName descriptor (Ljava\/lang\/String;Ljava\/nio\/charset\/Charset;)Ljava\/nio\/charset\/Charset; flags 9\n+\n+class name java\/security\/Certificate\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/Identity\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 421 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"1.2\")\n+\n+class name java\/security\/KeyStore\n+method name getAttributes descriptor (Ljava\/lang\/String;)Ljava\/util\/Set; thrownTypes java\/security\/KeyStoreException flags 11 signature (Ljava\/lang\/String;)Ljava\/util\/Set<Ljava\/security\/KeyStore$Entry$Attribute;>;\n+\n+class name java\/security\/KeyStoreSpi\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/KeyStore$LoadStoreParameter outerClass java\/security\/KeyStore innerClassName LoadStoreParameter flags 609\n+innerclass innerClass java\/security\/KeyStore$ProtectionParameter outerClass java\/security\/KeyStore innerClassName ProtectionParameter flags 609\n+innerclass innerClass java\/security\/KeyStore$PasswordProtection outerClass java\/security\/KeyStore innerClassName PasswordProtection flags 9\n+innerclass innerClass java\/security\/KeyStore$CallbackHandlerProtection outerClass java\/security\/KeyStore innerClassName CallbackHandlerProtection flags 9\n+innerclass innerClass java\/security\/KeyStore$TrustedCertificateEntry outerClass java\/security\/KeyStore innerClassName TrustedCertificateEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$PrivateKeyEntry outerClass java\/security\/KeyStore innerClassName PrivateKeyEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$SecretKeyEntry outerClass java\/security\/KeyStore innerClassName SecretKeyEntry flags 19\n+innerclass innerClass java\/security\/KeyStore$Entry outerClass java\/security\/KeyStore innerClassName Entry flags 609\n+innerclass innerClass java\/security\/KeyStore$Entry$Attribute outerClass java\/security\/KeyStore$Entry innerClassName Attribute flags 609\n+method name engineGetAttributes descriptor (Ljava\/lang\/String;)Ljava\/util\/Set; flags 1 signature (Ljava\/lang\/String;)Ljava\/util\/Set<Ljava\/security\/KeyStore$Entry$Attribute;>;\n+\n+class name java\/security\/SecureRandomParameters\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/security\/SignedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/security\/cert\/CertificateRevokedException\n+header extends java\/security\/cert\/CertificateException flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/security\/cert\/URICertStoreParameters\n+header extends java\/lang\/Object implements java\/security\/cert\/CertStoreParameters flags 31\n+\n+class name java\/security\/interfaces\/RSAKey\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/MGF1ParameterSpec\n+-field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+-field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec;\n+field name SHA512_224 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+field name SHA512_256 descriptor Ljava\/security\/spec\/MGF1ParameterSpec; flags 19\n+\n+class name java\/security\/spec\/PSSParameterSpec\n+-field name TRAILER_FIELD_BC descriptor I\n+-method name toString descriptor ()Ljava\/lang\/String;\n+field name TRAILER_FIELD_BC descriptor I constantValue 1 flags 19\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+\n+class name java\/security\/spec\/RSAKeyGenParameterSpec\n+-method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (ILjava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getKeyParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAMultiPrimePrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;[Ljava\/security\/spec\/RSAOtherPrimeInfo;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateCrtKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+\n+class name java\/security\/spec\/RSAPrivateKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/security\/spec\/RSAPublicKeySpec\n+-method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V\n+-method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec;\n+method name <init> descriptor (Ljava\/math\/BigInteger;Ljava\/math\/BigInteger;Ljava\/security\/spec\/AlgorithmParameterSpec;)V flags 1\n+method name getParams descriptor ()Ljava\/security\/spec\/AlgorithmParameterSpec; flags 1\n+\n+class name java\/text\/DateFormatSymbols\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/text\/RuleBasedCollator\n+header extends java\/text\/Collator flags 21\n+innerclass innerClass java\/text\/Normalizer$Form outerClass java\/text\/Normalizer innerClassName Form flags 4019\n+\n+class name java\/time\/Duration\n+method name isPositive descriptor ()Z flags 1\n+\n+class name java\/time\/chrono\/ChronoLocalDate\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDate;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/chrono\/ChronoLocalDateTime\n+header extends java\/lang\/Object implements java\/time\/temporal\/Temporal,java\/time\/temporal\/TemporalAdjuster,java\/lang\/Comparable flags 601 signature <D::Ljava\/time\/chrono\/ChronoLocalDate;>Ljava\/lang\/Object;Ljava\/time\/temporal\/Temporal;Ljava\/time\/temporal\/TemporalAdjuster;Ljava\/lang\/Comparable<Ljava\/time\/chrono\/ChronoLocalDateTime<*>;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/time\/format\/DecimalStyle\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/time\/temporal\/TemporalAdjusters\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Comparator\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/DoubleSummaryStatistics\n+header extends java\/lang\/Object implements java\/util\/function\/DoubleConsumer flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/GregorianCalendar\n+header extends java\/util\/Calendar flags 21\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/HashMap\n+header extends java\/util\/AbstractMap implements java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/util\/AbstractMap<TK;TV;>;Ljava\/util\/Map<TK;TV;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/util\/HashSet\n+header extends java\/util\/AbstractSet implements java\/util\/Set,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/Set<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/Locale$IsoCountryCode\n+header extends java\/lang\/Enum nestHost java\/util\/Locale sealed true flags 4421 signature Ljava\/lang\/Enum<Ljava\/util\/Locale$IsoCountryCode;>;\n+innerclass innerClass java\/util\/Locale$IsoCountryCode outerClass java\/util\/Locale innerClassName IsoCountryCode flags 4409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/Observable\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/Observer\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/TimeZone\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/util\/Locale$Category outerClass java\/util\/Locale innerClassName Category flags 4019\n+\n+class name java\/util\/TreeSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/util\/concurrent\/ConcurrentMap\n+header extends java\/lang\/Object implements java\/util\/Map flags 601 signature <K:Ljava\/lang\/Object;V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/Map<TK;TV;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ConcurrentSkipListSet\n+header extends java\/util\/AbstractSet implements java\/util\/NavigableSet,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/util\/AbstractSet<TE;>;Ljava\/util\/NavigableSet<TE;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/CountedCompleter\n+header extends java\/util\/concurrent\/ForkJoinTask flags 421 signature <T:Ljava\/lang\/Object;>Ljava\/util\/concurrent\/ForkJoinTask<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/ThreadPoolExecutor\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/util\/concurrent\/atomic\/AtomicBoolean\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReference\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <V:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/atomic\/AtomicReferenceArray\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 signature <E:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/io\/Serializable;\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/concurrent\/locks\/StampedLock\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I1)\n+-method name tryWriteLock descriptor ()J\n+-method name writeLockInterruptibly descriptor ()J\n+-method name tryReadLock descriptor ()J\n+-method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J\n+-method name readLockInterruptibly descriptor ()J\n+-method name unlock descriptor (J)V\n+method name tryWriteLock descriptor ()J flags 1\n+method name writeLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name tryReadLock descriptor ()J flags 1\n+method name tryReadLock descriptor (JLjava\/util\/concurrent\/TimeUnit;)J thrownTypes java\/lang\/InterruptedException flags 1\n+method name readLockInterruptibly descriptor ()J thrownTypes java\/lang\/InterruptedException flags 1\n+method name unlock descriptor (J)V flags 1\n+\n+class name java\/util\/function\/BiConsumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiFunction\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BiPredicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;U:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/BinaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/BiFunction flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction<TT;TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Consumer\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoublePredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/DoubleUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Function\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;R:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/IntUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongConsumer\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongPredicate\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/LongUnaryOperator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/Predicate\n+header extends java\/lang\/Object flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/function\/UnaryOperator\n+header extends java\/lang\/Object implements java\/util\/function\/Function flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljava\/util\/function\/Function<TT;TT;>; runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/AbstractResourceBundleProvider\n+header extends java\/lang\/Object implements java\/util\/spi\/ResourceBundleProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/spi\/CurrencyNameProvider\n+header extends java\/util\/spi\/LocaleServiceProvider flags 421\n+innerclass innerClass java\/util\/ResourceBundle$Control outerClass java\/util\/ResourceBundle innerClassName Control flags 9\n+\n+class name java\/util\/spi\/ResourceBundleProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/util\/spi\/ToolProvider\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/zip\/CRC32C\n+header extends java\/lang\/Object implements java\/util\/zip\/Checksum flags 31\n+\n+class name javax\/crypto\/AEADBadTagException\n+header extends javax\/crypto\/BadPaddingException flags 21\n+\n+class name javax\/crypto\/BadPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/CipherInputStream\n+header extends java\/io\/FilterInputStream flags 21\n+\n+class name javax\/crypto\/CipherOutputStream\n+header extends java\/io\/FilterOutputStream flags 21\n+\n+class name javax\/crypto\/CipherSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/EncryptedPrivateKeyInfo\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanism\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/ExemptionMechanismSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/IllegalBlockSizeException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/KeyAgreement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyAgreementSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/KeyGenerator\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/KeyGeneratorSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/Mac\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/MacSpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/NoSuchPaddingException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/NullCipher\n+header extends javax\/crypto\/Cipher flags 21\n+\n+class name javax\/crypto\/SealedObject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/crypto\/SecretKey\n+header extends java\/lang\/Object implements java\/security\/Key,javax\/security\/auth\/Destroyable flags 601\n+\n+class name javax\/crypto\/SecretKeyFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+\n+class name javax\/crypto\/SecretKeyFactorySpi\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/crypto\/ShortBufferException\n+header extends java\/security\/GeneralSecurityException flags 21\n+\n+class name javax\/crypto\/interfaces\/DHKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPrivateKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PrivateKey flags 601\n+\n+class name javax\/crypto\/interfaces\/DHPublicKey\n+header extends java\/lang\/Object implements javax\/crypto\/interfaces\/DHKey,java\/security\/PublicKey flags 601\n+\n+class name javax\/crypto\/interfaces\/PBEKey\n+header extends java\/lang\/Object implements javax\/crypto\/SecretKey flags 601\n+\n+class name javax\/crypto\/spec\/DESKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DESedeKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHGenParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPrivateKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/DHPublicKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/GCMParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/IvParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/OAEPParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+innerclass innerClass javax\/crypto\/spec\/PSource$PSpecified outerClass javax\/crypto\/spec\/PSource innerClassName PSpecified flags 19\n+\n+class name javax\/crypto\/spec\/PBEKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec flags 21\n+\n+class name javax\/crypto\/spec\/PBEParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC2ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/RC5ParameterSpec\n+header extends java\/lang\/Object implements java\/security\/spec\/AlgorithmParameterSpec flags 21\n+\n+class name javax\/crypto\/spec\/SecretKeySpec\n+header extends java\/lang\/Object implements java\/security\/spec\/KeySpec,javax\/crypto\/SecretKey flags 21\n+\n+class name javax\/security\/auth\/Subject\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name doAs descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;)Ljava\/lang\/Object;\n+-method name doAs descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;)Ljava\/lang\/Object;\n+method name current descriptor ()Ljavax\/security\/auth\/Subject; flags 9\n+method name callAs descriptor (Ljavax\/security\/auth\/Subject;Ljava\/util\/concurrent\/Callable;)Ljava\/lang\/Object; thrownTypes java\/util\/concurrent\/CompletionException flags 9 signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/util\/concurrent\/Callable<TT;>;)TT;\n+method name doAs descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction;)Ljava\/lang\/Object; flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedAction<TT;>;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"18\")\n+method name doAs descriptor (Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction;)Ljava\/lang\/Object; thrownTypes java\/security\/PrivilegedActionException flags 9 deprecated true signature <T:Ljava\/lang\/Object;>(Ljavax\/security\/auth\/Subject;Ljava\/security\/PrivilegedExceptionAction<TT;>;)TT; runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"18\")\n+\n+class name javax\/security\/auth\/login\/LoginContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/security\/auth\/login\/AppConfigurationEntry$LoginModuleControlFlag outerClass javax\/security\/auth\/login\/AppConfigurationEntry innerClassName LoginModuleControlFlag flags 9\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/internal\/vm\/vector\/VectorSupport\n+header extends java\/lang\/Object nestMembers jdk\/internal\/vm\/vector\/VectorSupport$VectorMask,jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle,jdk\/internal\/vm\/vector\/VectorSupport$Vector,jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload,jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies flags 21\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+-method name broadcastCoerced descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;IJLjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$BroadcastOperation;)Ljava\/lang\/Object;\n+-method name shuffleIota descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;IIIILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;\n+-method name shuffleToVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)Ljava\/lang\/Object;\n+-method name indexVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+-method name reductionCoerced descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljava\/util\/function\/Function;)J\n+-method name extract descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VecExtractOp;)J\n+-method name insert descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;IJLjdk\/internal\/vm\/vector\/VectorSupport$VecInsertOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+-method name unaryOp descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljava\/util\/function\/Function;)Ljava\/lang\/Object;\n+-method name binaryOp descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction;)Ljava\/lang\/Object;\n+-method name ternaryOp descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljava\/lang\/Object;Ljava\/lang\/Object;Ljdk\/internal\/vm\/vector\/VectorSupport$TernaryOperation;)Ljava\/lang\/Object;\n+-method name load descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;JLjava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadOperation;)Ljava\/lang\/Object;\n+-method name loadWithMap descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Class;Ljava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljava\/lang\/Object;I[IILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorOperationWithMap;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+-method name storeWithMap descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Class;Ljava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljava\/lang\/Object;I[IILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperationWithMap;)V\n+-method name test descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljava\/lang\/Object;Ljava\/util\/function\/BiFunction;)Z\n+-method name compare descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorCompareOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;\n+-method name rearrangeOp descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorRearrangeOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+-method name blend descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorBlendOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+-method name broadcastInt descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorBroadcastIntOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;\n+-method name maybeRebox descriptor (Ljava\/lang\/Object;)Ljava\/lang\/Object;\n+-method name maskReductionCoerced descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMaskOp;)I\n+field name VECTOR_OP_MASK_TOLONG descriptor I constantValue 22 flags 19\n+field name VECTOR_OP_LROTATE descriptor I constantValue 23 flags 19\n+field name VECTOR_OP_RROTATE descriptor I constantValue 24 flags 19\n+method name broadcastCoerced descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;IJLjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$BroadcastOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload; flags 9 signature <VM:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TVM;>;Ljava\/lang\/Class<TE;>;IJTS;Ljdk\/internal\/vm\/vector\/VectorSupport$BroadcastOperation<TVM;TS;>;)TVM; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name shuffleIota descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;IIIILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle; flags 9 signature <E:Ljava\/lang\/Object;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;SH:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle<TE;>;>(Ljava\/lang\/Class<TE;>;Ljava\/lang\/Class<+TSH;>;TS;IIIILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleIotaOperation<TS;TSH;>;)TSH; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name shuffleToVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;SH:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;>;Ljava\/lang\/Class<TE;>;Ljava\/lang\/Class<+TSH;>;TSH;ILjdk\/internal\/vm\/vector\/VectorSupport$ShuffleToVectorOperation<TV;TSH;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name indexVector descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;E:Ljava\/lang\/Object;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TE;>;ITV;ITS;Ljdk\/internal\/vm\/vector\/VectorSupport$IndexOperation<TV;TS;>;)TV;\n+method name reductionCoerced descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$ReductionOperation;)J flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TV;>;Ljava\/lang\/Class<+TM;>;Ljava\/lang\/Class<TE;>;ITV;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$ReductionOperation<TV;TM;>;)J runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name extract descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VecExtractOp;)J flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TE;>;ITV;ILjdk\/internal\/vm\/vector\/VectorSupport$VecExtractOp<TV;>;)J runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name insert descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;IJLjdk\/internal\/vm\/vector\/VectorSupport$VecInsertOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TE;>;ITV;IJLjdk\/internal\/vm\/vector\/VectorSupport$VecInsertOp<TV;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name unaryOp descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$UnaryOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TV;>;Ljava\/lang\/Class<+TM;>;Ljava\/lang\/Class<TE;>;ITV;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$UnaryOperation<TV;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name binaryOp descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload; flags 9 signature <VM:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TVM;>;Ljava\/lang\/Class<+TM;>;Ljava\/lang\/Class<TE;>;ITVM;TVM;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$BinaryOperation<TVM;TM;>;)TVM; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name ternaryOp descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$TernaryOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TV;>;Ljava\/lang\/Class<+TM;>;Ljava\/lang\/Class<TE;>;ITV;TV;TV;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$TernaryOperation<TV;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name load descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;JLjava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload; flags 9 signature <C:Ljava\/lang\/Object;VM:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;E:Ljava\/lang\/Object;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;>(Ljava\/lang\/Class<+TVM;>;Ljava\/lang\/Class<TE;>;ILjava\/lang\/Object;JTC;ITS;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadOperation<TC;TVM;TS;>;)TVM; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name loadMasked descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorMaskedOperation;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <C:Ljava\/lang\/Object;V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<*>;E:Ljava\/lang\/Object;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ILjava\/lang\/Object;JTM;TC;ITS;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorMaskedOperation<TC;TV;TS;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name loadWithMap descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Class;Ljava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/lang\/Object;I[IILjdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorOperationWithMap;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <C:Ljava\/lang\/Object;V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<*>;W:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<Ljava\/lang\/Integer;>;S:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ILjava\/lang\/Class<+Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<Ljava\/lang\/Integer;>;>;Ljava\/lang\/Object;JTW;TM;TC;I[IITS;Ljdk\/internal\/vm\/vector\/VectorSupport$LoadVectorOperationWithMap<TC;TV;TS;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name storeMasked descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/lang\/Object;ILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorMaskedOperation;)V flags 9 signature <C:Ljava\/lang\/Object;V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ILjava\/lang\/Object;JTV;TM;TC;ILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorMaskedOperation<TC;TV;TM;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name storeWithMap descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjava\/lang\/Class;Ljava\/lang\/Object;JLjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/lang\/Object;I[IILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperationWithMap;)V flags 9 signature <C:Ljava\/lang\/Object;V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;W:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<Ljava\/lang\/Integer;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ILjava\/lang\/Class<+Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<Ljava\/lang\/Integer;>;>;Ljava\/lang\/Object;JTW;TV;TM;TC;I[IILjdk\/internal\/vm\/vector\/VectorSupport$StoreVectorOperationWithMap<TC;TV;TM;>;)V runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name test descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljava\/util\/function\/BiFunction;)Z flags 9 signature <M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<*>;Ljava\/lang\/Class<*>;ITM;TM;Ljava\/util\/function\/BiFunction<TM;TM;Ljava\/lang\/Boolean;>;)Z runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name compare descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorCompareOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ITV;TV;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorCompareOp<TV;TM;>;)TM; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name rearrangeOp descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorRearrangeOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;SH:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TSH;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ITV;TSH;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorRearrangeOp<TV;TSH;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name blend descriptor (Ljava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$Vector;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorBlendOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(Ljava\/lang\/Class<+TV;>;Ljava\/lang\/Class<TM;>;Ljava\/lang\/Class<TE;>;ITV;TV;TM;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorBlendOp<TV;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name broadcastInt descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$Vector;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorBroadcastIntOp;)Ljdk\/internal\/vm\/vector\/VectorSupport$Vector; flags 9 signature <V:Ljdk\/internal\/vm\/vector\/VectorSupport$Vector<TE;>;M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TV;>;Ljava\/lang\/Class<+TM;>;Ljava\/lang\/Class<TE;>;ITV;ITM;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorBroadcastIntOp<TV;TM;>;)TV; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name maybeRebox descriptor (Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;)Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload; flags 9 signature <VP:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorPayload;>(TVP;)TVP; runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+method name maskReductionCoerced descriptor (ILjava\/lang\/Class;Ljava\/lang\/Class;ILjdk\/internal\/vm\/vector\/VectorSupport$VectorMask;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMaskOp;)J flags 9 signature <M:Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;E:Ljava\/lang\/Object;>(ILjava\/lang\/Class<+TM;>;Ljava\/lang\/Class<*>;ITM;Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMaskOp<TM;>;)J runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/IntrinsicCandidate;\n+\n","filename":"make\/data\/symbols\/java.base-I.sym.txt","additions":742,"deletions":0,"binary":false,"changes":742,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/annotation\/processing\/AbstractProcessor\n+header extends java\/lang\/Object implements javax\/annotation\/processing\/Processor flags 421\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/annotation\/processing\/Generated\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;SOURCE;)@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;PACKAGE;eLjava\/lang\/annotation\/ElementType;TYPE;eLjava\/lang\/annotation\/ElementType;METHOD;eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;eLjava\/lang\/annotation\/ElementType;FIELD;eLjava\/lang\/annotation\/ElementType;LOCAL_VARIABLE;eLjava\/lang\/annotation\/ElementType;PARAMETER;})\n+\n+class name javax\/annotation\/processing\/Messager\n+method name printError descriptor (Ljava\/lang\/CharSequence;)V flags 1\n+method name printError descriptor (Ljava\/lang\/CharSequence;Ljavax\/lang\/model\/element\/Element;)V flags 1\n+method name printWarning descriptor (Ljava\/lang\/CharSequence;)V flags 1\n+method name printWarning descriptor (Ljava\/lang\/CharSequence;Ljavax\/lang\/model\/element\/Element;)V flags 1\n+method name printNote descriptor (Ljava\/lang\/CharSequence;)V flags 1\n+method name printNote descriptor (Ljava\/lang\/CharSequence;Ljavax\/lang\/model\/element\/Element;)V flags 1\n+\n+class name javax\/lang\/model\/SourceVersion\n+field name RELEASE_18 descriptor Ljavax\/lang\/model\/SourceVersion; flags 4019\n+method name valueOf descriptor (Ljava\/lang\/Runtime$Version;)Ljavax\/lang\/model\/SourceVersion; flags 9\n+method name runtimeVersion descriptor ()Ljava\/lang\/Runtime$Version; flags 1\n+\n+class name javax\/lang\/model\/element\/ExecutableElement\n+method name getEnclosingElement descriptor ()Ljavax\/lang\/model\/element\/Element; flags 401\n+\n+class name javax\/lang\/model\/element\/Modifier\n+header extends java\/lang\/Enum sealed true flags 4021 signature Ljava\/lang\/Enum<Ljavax\/lang\/model\/element\/Modifier;>;\n+\n+class name javax\/lang\/model\/element\/UnknownAnnotationValueException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownDirectiveException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass javax\/lang\/model\/element\/ModuleElement$Directive outerClass javax\/lang\/model\/element\/ModuleElement innerClassName Directive flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/element\/UnknownElementException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypeException\n+header extends javax\/lang\/model\/type\/MirroredTypesException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/MirroredTypesException\n+header extends java\/lang\/RuntimeException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/type\/UnknownTypeException\n+header extends javax\/lang\/model\/UnknownEntityException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/AbstractAnnotationValueVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/AbstractElementVisitor14\n+header extends javax\/lang\/model\/util\/AbstractElementVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor14\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor9 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor6\n+header extends java\/lang\/Object implements javax\/lang\/model\/type\/TypeVisitor flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/lang\/model\/type\/TypeVisitor<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_6;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor7\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor6 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor6<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_7;)\n+\n+class name javax\/lang\/model\/util\/AbstractTypeVisitor8\n+header extends javax\/lang\/model\/util\/AbstractTypeVisitor7 flags 421 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/AbstractTypeVisitor7<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_8;)\n+\n+class name javax\/lang\/model\/util\/ElementKindVisitor14\n+header extends javax\/lang\/model\/util\/ElementKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/ElementScanner14\n+header extends javax\/lang\/model\/util\/ElementScanner9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/ElementScanner9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/Elements\n+method name getOutermostTypeElement descriptor (Ljavax\/lang\/model\/element\/Element;)Ljavax\/lang\/model\/element\/TypeElement; flags 1\n+method name getFileObjectOf descriptor (Ljavax\/lang\/model\/element\/Element;)Ljavax\/tools\/JavaFileObject; flags 1\n+\n+class name javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14\n+header extends javax\/lang\/model\/util\/SimpleAnnotationValueVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleAnnotationValueVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/SimpleElementVisitor14\n+header extends javax\/lang\/model\/util\/SimpleElementVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleElementVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/SimpleTypeVisitor14\n+header extends javax\/lang\/model\/util\/SimpleTypeVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/SimpleTypeVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/lang\/model\/util\/TypeKindVisitor14\n+header extends javax\/lang\/model\/util\/TypeKindVisitor9 flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljavax\/lang\/model\/util\/TypeKindVisitor9<TR;TP;>; runtimeAnnotations @Ljavax\/annotation\/processing\/SupportedSourceVersion;(value=eLjavax\/lang\/model\/SourceVersion;RELEASE_18;)\n+\n+class name javax\/tools\/DocumentationTool$Location\n+field name SNIPPET_PATH descriptor Ljavax\/tools\/DocumentationTool$Location; flags 4019\n+\n+class name javax\/tools\/ForwardingJavaFileManager\n+method name getJavaFileForOutputForOriginatingFiles descriptor (Ljavax\/tools\/JavaFileManager$Location;Ljava\/lang\/String;Ljavax\/tools\/JavaFileObject$Kind;[Ljavax\/tools\/FileObject;)Ljavax\/tools\/JavaFileObject; thrownTypes java\/io\/IOException flags 81\n+method name getFileForOutputForOriginatingFiles descriptor (Ljavax\/tools\/JavaFileManager$Location;Ljava\/lang\/String;Ljava\/lang\/String;[Ljavax\/tools\/FileObject;)Ljavax\/tools\/FileObject; thrownTypes java\/io\/IOException flags 81\n+\n+class name javax\/tools\/JavaFileManager\n+method name getJavaFileForOutputForOriginatingFiles descriptor (Ljavax\/tools\/JavaFileManager$Location;Ljava\/lang\/String;Ljavax\/tools\/JavaFileObject$Kind;[Ljavax\/tools\/FileObject;)Ljavax\/tools\/JavaFileObject; thrownTypes java\/io\/IOException flags 81\n+method name getFileForOutputForOriginatingFiles descriptor (Ljavax\/tools\/JavaFileManager$Location;Ljava\/lang\/String;Ljava\/lang\/String;[Ljavax\/tools\/FileObject;)Ljavax\/tools\/FileObject; thrownTypes java\/io\/IOException flags 81\n+\n+class name javax\/tools\/SimpleJavaFileObject\n+header extends java\/lang\/Object implements javax\/tools\/JavaFileObject flags 21\n+innerclass innerClass javax\/tools\/JavaFileObject$Kind outerClass javax\/tools\/JavaFileObject innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/tools\/ToolProvider\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.compiler-I.sym.txt","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/datatransfer\/Clipboard\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/datatransfer\/DataFlavor\n+header extends java\/lang\/Object implements java\/io\/Externalizable,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.datatransfer-I.sym.txt","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,922 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/awt\/AWTKeyStroke\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/AttributeValue\n+header extends java\/lang\/Object flags 420\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/BorderLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/CheckboxGroup\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Color\n+header extends java\/lang\/Object implements java\/awt\/Paint,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/ContainerOrderFocusTraversalPolicy\n+header extends java\/awt\/FocusTraversalPolicy implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Dimension\n+header extends java\/awt\/geom\/Dimension2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/DisplayMode\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Event\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FlowLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/FontMetrics\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Graphics\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/awt\/GridBagLayoutInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name java\/awt\/GridLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/HeadlessException\n+header extends java\/lang\/UnsupportedOperationException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Insets\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/MenuShortcut\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/Point\n+header extends java\/awt\/geom\/Point2D implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/PrintJob\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name java\/awt\/Rectangle\n+header extends java\/awt\/geom\/Rectangle2D implements java\/awt\/Shape,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/SystemColor\n+header extends java\/awt\/Color implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/TexturePaint\n+header extends java\/lang\/Object implements java\/awt\/Paint flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/color\/ColorSpace\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/color\/ICC_ColorSpace\n+header extends java\/awt\/color\/ColorSpace flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name java\/awt\/color\/ICC_Profile\n+-method name finalize descriptor ()V\n+\n+class name java\/awt\/desktop\/AboutEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AboutHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/AppEvent\n+header extends java\/util\/EventObject flags 21\n+\n+class name java\/awt\/desktop\/AppForegroundEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppForegroundListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppHiddenEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppHiddenListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/AppReopenedEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/AppReopenedListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/FilesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 21\n+\n+class name java\/awt\/desktop\/OpenFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/OpenURIEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/OpenURIHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PreferencesEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/PreferencesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/PrintFilesEvent\n+header extends java\/awt\/desktop\/FilesEvent flags 31\n+\n+class name java\/awt\/desktop\/PrintFilesHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/QuitHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitResponse\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/desktop\/QuitStrategy\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Ljava\/awt\/desktop\/QuitStrategy;>;\n+\n+class name java\/awt\/desktop\/ScreenSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/ScreenSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemEventListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name java\/awt\/desktop\/SystemSleepEvent\n+header extends java\/awt\/desktop\/AppEvent flags 31\n+\n+class name java\/awt\/desktop\/SystemSleepListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/desktop\/UserSessionListener\n+header extends java\/lang\/Object implements java\/awt\/desktop\/SystemEventListener flags 601\n+\n+class name java\/awt\/dnd\/DragGestureEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragGestureRecognizer\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name java\/awt\/dnd\/DragSource\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDragEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/dnd\/DropTargetDropEvent\n+header extends java\/awt\/dnd\/DropTargetEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ActionEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/AdjustmentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ComponentEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ContainerEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/HierarchyEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/InputMethodEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/ItemEvent\n+header extends java\/awt\/AWTEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/MouseWheelEvent\n+header extends java\/awt\/event\/MouseEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/PaintEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/event\/WindowEvent\n+header extends java\/awt\/event\/ComponentEvent flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/FontRenderContext\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/awt\/RenderingHints$Key outerClass java\/awt\/RenderingHints innerClassName Key flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/GraphicAttribute\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/ImageGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/NumericShaper$Range\n+header extends java\/lang\/Enum nestHost java\/awt\/font\/NumericShaper sealed true flags 4021 signature Ljava\/lang\/Enum<Ljava\/awt\/font\/NumericShaper$Range;>;\n+innerclass innerClass java\/awt\/font\/NumericShaper$Range outerClass java\/awt\/font\/NumericShaper innerClassName Range flags 4009\n+\n+class name java\/awt\/font\/ShapeGraphicAttribute\n+header extends java\/awt\/font\/GraphicAttribute flags 31\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+\n+class name java\/awt\/font\/TextHitInfo\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/font\/TextMeasurer\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/AffineTransform\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Double outerClass java\/awt\/geom\/Point2D innerClassName Double flags 9\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/geom\/Area\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/geom\/RectangularShape\n+header extends java\/lang\/Object implements java\/awt\/Shape,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/awt\/image\/AbstractMultiResolutionImage\n+header extends java\/awt\/Image implements java\/awt\/image\/MultiResolutionImage flags 421\n+\n+class name java\/awt\/image\/BandCombineOp\n+header extends java\/lang\/Object implements java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BandedSampleModel\n+header extends java\/awt\/image\/ComponentSampleModel flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BaseMultiResolutionImage\n+header extends java\/awt\/image\/AbstractMultiResolutionImage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/BufferedImageFilter\n+header extends java\/awt\/image\/ImageFilter implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ByteLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ColorConvertOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/ColorModel\n+-method name finalize descriptor ()V\n+\n+class name java\/awt\/image\/ComponentColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ComponentSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ConvolveOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+\n+class name java\/awt\/image\/DataBufferUShort\n+header extends java\/awt\/image\/DataBuffer flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/DirectColorModel\n+header extends java\/awt\/image\/PackedColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ImageFilter\n+header extends java\/lang\/Object implements java\/awt\/image\/ImageConsumer,java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/IndexColorModel\n+header extends java\/awt\/image\/ColorModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name finalize descriptor ()V\n+\n+class name java\/awt\/image\/Kernel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/LookupOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiPixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/MultiResolutionImage\n+header extends java\/lang\/Object flags 601\n+\n+class name java\/awt\/image\/PackedColorModel\n+header extends java\/awt\/image\/ColorModel flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/Raster\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ReplicateScaleFilter\n+header extends java\/awt\/image\/ImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/RescaleOp\n+header extends java\/lang\/Object implements java\/awt\/image\/BufferedImageOp,java\/awt\/image\/RasterOp flags 21\n+innerclass innerClass java\/awt\/geom\/Point2D$Float outerClass java\/awt\/geom\/Point2D innerClassName Float flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SampleModel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/ShortLookupTable\n+header extends java\/awt\/image\/LookupTable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/image\/SinglePixelPackedSampleModel\n+header extends java\/awt\/image\/SampleModel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/awt\/print\/Paper\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Double outerClass java\/awt\/geom\/Rectangle2D innerClassName Double flags 9\n+\n+class name java\/beans\/BeanProperty\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;METHOD;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/Beans\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/DefaultPersistenceDelegate\n+header extends java\/beans\/PersistenceDelegate flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Encoder\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/EventSetDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/Expression\n+header extends java\/beans\/Statement flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/FeatureDescriptor\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+\n+class name java\/beans\/IndexedPropertyDescriptor\n+header extends java\/beans\/PropertyDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/JavaBean\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name java\/beans\/PropertyDescriptor\n+header extends java\/beans\/FeatureDescriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/beans\/SimpleBeanInfo\n+header extends java\/lang\/Object implements java\/beans\/BeanInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibilityProvider\n+header extends java\/lang\/Object flags 421\n+\n+class name javax\/accessibility\/AccessibleBundle\n+header extends java\/lang\/Object flags 421 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/accessibility\/AccessibleRelationSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/accessibility\/AccessibleStateSet\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/metadata\/IIOMetadata\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGHuffmanTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/jpeg\/JPEGQTable\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFDirectory\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 21\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFField\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFImageReadParam\n+header extends javax\/imageio\/ImageReadParam flags 31\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTag\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/plugins\/tiff\/TIFFTagSet\n+header extends java\/lang\/Object flags 21\n+\n+class name javax\/imageio\/spi\/ImageReaderWriterSpi\n+header extends javax\/imageio\/spi\/IIOServiceProvider flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/imageio\/spi\/ServiceRegistry\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/imageio\/stream\/FileCacheImageInputStream\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/imageio\/stream\/FileImageInputStream\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/imageio\/stream\/FileImageOutputStream\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/imageio\/stream\/ImageInputStreamImpl\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/imageio\/stream\/MemoryCacheImageInputStream\n+-method name finalize descriptor ()V\n+method name finalize descriptor ()V thrownTypes java\/lang\/Throwable flags 4 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(forRemoval=Ztrue,since=\"9\")\n+\n+class name javax\/print\/attribute\/DateTimeSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/EnumSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/IntegerSyntax\n+header extends java\/lang\/Object implements java\/io\/Serializable,java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/attribute\/standard\/MediaPrintableArea\n+header extends java\/lang\/Object implements javax\/print\/attribute\/DocAttribute,javax\/print\/attribute\/PrintRequestAttribute,javax\/print\/attribute\/PrintJobAttribute flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/print\/event\/PrintEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MetaMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/MidiMessage\n+header extends java\/lang\/Object implements java\/lang\/Cloneable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/Sequence\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/ShortMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/midi\/SysexMessage\n+header extends javax\/sound\/midi\/MidiMessage flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/sound\/sampled\/ReverbType\n+header extends java\/lang\/Object flags 21 classAnnotations @Ljdk\/Profile+Annotation;(value=I4)\n+\n+class name javax\/sound\/sampled\/spi\/FormatConversionProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/sound\/sampled\/AudioFormat$Encoding outerClass javax\/sound\/sampled\/AudioFormat innerClassName Encoding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/BoxLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DebugGraphics\n+header extends java\/awt\/Graphics flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultBoundedRangeModel\n+header extends java\/lang\/Object implements javax\/swing\/BoundedRangeModel,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/DefaultListSelectionModel\n+header extends java\/lang\/Object implements javax\/swing\/ListSelectionModel,java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GrayFilter\n+header extends java\/awt\/image\/RGBImageFilter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GroupLayout\n+header extends java\/lang\/Object implements java\/awt\/LayoutManager2 nestMembers javax\/swing\/GroupLayout$ParallelGroup,javax\/swing\/GroupLayout$SequentialGroup,javax\/swing\/GroupLayout$Group,javax\/swing\/GroupLayout$Spring,javax\/swing\/GroupLayout$Alignment flags 21\n+innerclass innerClass javax\/swing\/GroupLayout$Alignment outerClass javax\/swing\/GroupLayout innerClassName Alignment flags 4019\n+innerclass innerClass javax\/swing\/GroupLayout$ParallelGroup outerClass javax\/swing\/GroupLayout innerClassName ParallelGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$SequentialGroup outerClass javax\/swing\/GroupLayout innerClassName SequentialGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/GroupLayout$Group\n+header extends javax\/swing\/GroupLayout$Spring nestHost javax\/swing\/GroupLayout flags 421\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+\n+class name javax\/swing\/GroupLayout$ParallelGroup\n+header extends javax\/swing\/GroupLayout$Group nestHost javax\/swing\/GroupLayout flags 21\n+innerclass innerClass javax\/swing\/GroupLayout$ParallelGroup outerClass javax\/swing\/GroupLayout innerClassName ParallelGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Alignment outerClass javax\/swing\/GroupLayout innerClassName Alignment flags 4019\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+\n+class name javax\/swing\/GroupLayout$SequentialGroup\n+header extends javax\/swing\/GroupLayout$Group nestHost javax\/swing\/GroupLayout flags 21\n+innerclass innerClass javax\/swing\/GroupLayout$SequentialGroup outerClass javax\/swing\/GroupLayout innerClassName SequentialGroup flags 1\n+innerclass innerClass javax\/swing\/GroupLayout$Group outerClass javax\/swing\/GroupLayout innerClassName Group flags 401\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+innerclass innerClass javax\/swing\/LayoutStyle$ComponentPlacement outerClass javax\/swing\/LayoutStyle innerClassName ComponentPlacement flags 4019\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name javax\/swing\/GroupLayout$Spring\n+header extends java\/lang\/Object nestHost javax\/swing\/GroupLayout flags 420\n+innerclass innerClass javax\/swing\/GroupLayout$Spring outerClass javax\/swing\/GroupLayout innerClassName Spring flags 40a\n+innerclass innerClass javax\/swing\/GroupLayout$Alignment outerClass javax\/swing\/GroupLayout innerClassName Alignment flags 4019\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+\n+class name javax\/swing\/JList$AccessibleJList$AccessibleJListChild\n+-method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction;\n+method name getAccessibleAction descriptor ()Ljavax\/accessibility\/AccessibleAction; flags 1\n+\n+class name javax\/swing\/JTextPane\n+header extends javax\/swing\/JEditorPane flags 21 runtimeAnnotations @Ljava\/beans\/JavaBean;(description=\"A\\u005C;u0020;text\\u005C;u0020;component\\u005C;u0020;that\\u005C;u0020;can\\u005C;u0020;be\\u005C;u0020;marked\\u005C;u0020;up\\u005C;u0020;with\\u005C;u0020;attributes\\u005C;u0020;that\\u005C;u0020;are\\u005C;u0020;graphically\\u005C;u0020;represented.\")@Ljavax\/swing\/SwingContainer;\n+\n+class name javax\/swing\/LookAndFeel\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/text\/JTextComponent$KeyBinding outerClass javax\/swing\/text\/JTextComponent innerClassName KeyBinding flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/MenuSelectionManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SizeRequirements\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SortingFocusTraversalPolicy\n+header extends javax\/swing\/InternalFrameFocusTraversalPolicy flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/SwingContainer\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;TYPE;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/swing\/UIClientPropertyKey\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/swing\/border\/LineBorder\n+header extends javax\/swing\/border\/AbstractBorder flags 21\n+innerclass innerClass java\/awt\/geom\/RoundRectangle2D$Float outerClass java\/awt\/geom\/RoundRectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Rectangle2D$Float outerClass java\/awt\/geom\/Rectangle2D innerClassName Float flags 9\n+innerclass innerClass java\/awt\/geom\/Path2D$Float outerClass java\/awt\/geom\/Path2D innerClassName Float flags 9\n+\n+class name javax\/swing\/event\/EventListenerList\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListDataEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/ListSelectionEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/event\/TreeModelEvent\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/filechooser\/FileNameExtensionFilter\n+header extends javax\/swing\/filechooser\/FileFilter flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicArrowButton\n+header extends javax\/swing\/JButton implements javax\/swing\/SwingConstants flags 21\n+innerclass innerClass java\/awt\/geom\/Path2D$Double outerClass java\/awt\/geom\/Path2D innerClassName Double flags 9\n+\n+class name javax\/swing\/plaf\/basic\/BasicButtonUI\n+header extends javax\/swing\/plaf\/ButtonUI flags 21\n+innerclass innerClass java\/awt\/Component$BaselineResizeBehavior outerClass java\/awt\/Component innerClassName BaselineResizeBehavior flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicPasswordFieldUI\n+header extends javax\/swing\/plaf\/basic\/BasicTextFieldUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicVerticalLayoutManager\n+header extends javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicHorizontalLayoutManager nestHost javax\/swing\/plaf\/basic\/BasicSplitPaneUI flags 21\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicHorizontalLayoutManager outerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI innerClassName BasicHorizontalLayoutManager flags 1\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI$BasicVerticalLayoutManager outerClass javax\/swing\/plaf\/basic\/BasicSplitPaneUI innerClassName BasicVerticalLayoutManager flags 1\n+\n+class name javax\/swing\/plaf\/basic\/BasicToolBarSeparatorUI\n+header extends javax\/swing\/plaf\/basic\/BasicSeparatorUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/metal\/MetalButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalCheckBoxUI\n+header extends javax\/swing\/plaf\/metal\/MetalRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalRadioButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicRadioButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalTabbedPaneUI$TabbedPaneLayout\n+header extends javax\/swing\/plaf\/basic\/BasicTabbedPaneUI$TabbedPaneLayout nestHost javax\/swing\/plaf\/metal\/MetalTabbedPaneUI flags 21\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicTabbedPaneUI$TabbedPaneLayout outerClass javax\/swing\/plaf\/basic\/BasicTabbedPaneUI innerClassName TabbedPaneLayout flags 1\n+innerclass innerClass javax\/swing\/plaf\/metal\/MetalTabbedPaneUI$TabbedPaneLayout outerClass javax\/swing\/plaf\/metal\/MetalTabbedPaneUI innerClassName TabbedPaneLayout flags 1\n+\n+class name javax\/swing\/plaf\/metal\/MetalToggleButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicToggleButtonUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolBarUI$MetalContainerListener\n+header extends javax\/swing\/plaf\/basic\/BasicToolBarUI$ToolBarContListener nestHost javax\/swing\/plaf\/metal\/MetalToolBarUI flags 21\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicToolBarUI$ToolBarContListener outerClass javax\/swing\/plaf\/basic\/BasicToolBarUI innerClassName ToolBarContListener flags 4\n+innerclass innerClass javax\/swing\/plaf\/metal\/MetalToolBarUI$MetalContainerListener outerClass javax\/swing\/plaf\/metal\/MetalToolBarUI innerClassName MetalContainerListener flags 4\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolBarUI$MetalRolloverListener\n+header extends javax\/swing\/plaf\/basic\/BasicToolBarUI$PropertyListener nestHost javax\/swing\/plaf\/metal\/MetalToolBarUI flags 21\n+innerclass innerClass javax\/swing\/plaf\/basic\/BasicToolBarUI$PropertyListener outerClass javax\/swing\/plaf\/basic\/BasicToolBarUI innerClassName PropertyListener flags 4\n+innerclass innerClass javax\/swing\/plaf\/metal\/MetalToolBarUI$MetalRolloverListener outerClass javax\/swing\/plaf\/metal\/MetalToolBarUI innerClassName MetalRolloverListener flags 4\n+\n+class name javax\/swing\/plaf\/metal\/MetalToolTipUI\n+header extends javax\/swing\/plaf\/basic\/BasicToolTipUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/multi\/MultiLookAndFeel\n+header extends javax\/swing\/LookAndFeel flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthButtonUI\n+header extends javax\/swing\/plaf\/basic\/BasicButtonUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthIcon\n+header extends java\/lang\/Object implements javax\/swing\/Icon flags 601\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuItemUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuItemUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthMenuUI\n+header extends javax\/swing\/plaf\/basic\/BasicMenuUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/plaf\/synth\/SynthSeparatorUI\n+header extends javax\/swing\/plaf\/SeparatorUI implements java\/beans\/PropertyChangeListener,javax\/swing\/plaf\/synth\/SynthUI flags 21\n+innerclass innerClass javax\/swing\/JToolBar$Separator outerClass javax\/swing\/JToolBar innerClassName Separator flags 9\n+\n+class name javax\/swing\/plaf\/synth\/SynthStyle\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/swing\/UIDefaults$LazyInputMap outerClass javax\/swing\/UIDefaults innerClassName LazyInputMap flags 9\n+innerclass innerClass javax\/swing\/UIDefaults$LazyValue outerClass javax\/swing\/UIDefaults innerClassName LazyValue flags 609\n+\n+class name javax\/swing\/table\/AbstractTableModel\n+header extends java\/lang\/Object implements javax\/swing\/table\/TableModel,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/AbstractWriter\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/BoxView\n+header extends javax\/swing\/text\/CompositeView flags 21\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/CompositeView\n+header extends javax\/swing\/text\/View flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/DateFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/DateFormat$Field outerClass java\/text\/DateFormat innerClassName Field flags 9\n+\n+class name javax\/swing\/text\/IconView\n+header extends javax\/swing\/text\/View flags 21\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/LayoutQueue\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/NumberFormatter\n+header extends javax\/swing\/text\/InternationalFormatter flags 21\n+innerclass innerClass java\/text\/NumberFormat$Field outerClass java\/text\/NumberFormat innerClassName Field flags 9\n+innerclass innerClass javax\/swing\/text\/DocumentFilter$FilterBypass outerClass javax\/swing\/text\/DocumentFilter innerClassName FilterBypass flags 409\n+innerclass innerClass java\/text\/AttributedCharacterIterator$Attribute outerClass java\/text\/AttributedCharacterIterator innerClassName Attribute flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/Segment\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/text\/CharacterIterator,java\/lang\/CharSequence flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabSet\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/TabStop\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/View\n+header extends java\/lang\/Object implements javax\/swing\/SwingConstants flags 421\n+innerclass innerClass javax\/swing\/text\/Position$Bias outerClass javax\/swing\/text\/Position innerClassName Bias flags 19\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$ElementChange outerClass javax\/swing\/event\/DocumentEvent innerClassName ElementChange flags 609\n+innerclass innerClass javax\/swing\/event\/DocumentEvent$EventType outerClass javax\/swing\/event\/DocumentEvent innerClassName EventType flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/InlineView\n+header extends javax\/swing\/text\/LabelView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ListView\n+header extends javax\/swing\/text\/html\/BlockView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$ListPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName ListPainter flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/MinimalHTMLWriter\n+header extends javax\/swing\/text\/AbstractWriter flags 21\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ParagraphConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ParagraphConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$CharacterConstants outerClass javax\/swing\/text\/StyleConstants innerClassName CharacterConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$FontConstants outerClass javax\/swing\/text\/StyleConstants innerClassName FontConstants flags 9\n+innerclass innerClass javax\/swing\/text\/StyleConstants$ColorConstants outerClass javax\/swing\/text\/StyleConstants innerClassName ColorConstants flags 9\n+innerclass innerClass javax\/swing\/text\/AbstractDocument$BranchElement outerClass javax\/swing\/text\/AbstractDocument innerClassName BranchElement flags 1\n+innerclass innerClass javax\/swing\/text\/StyleContext$NamedStyle outerClass javax\/swing\/text\/StyleContext innerClassName NamedStyle flags 1\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/ObjectView\n+header extends javax\/swing\/text\/ComponentView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/Option\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/ParagraphView\n+header extends javax\/swing\/text\/ParagraphView flags 21\n+innerclass innerClass javax\/swing\/text\/html\/StyleSheet$BoxPainter outerClass javax\/swing\/text\/html\/StyleSheet innerClassName BoxPainter flags 9\n+innerclass innerClass javax\/swing\/text\/html\/CSS$Attribute outerClass javax\/swing\/text\/html\/CSS innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/ContentModel\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/DocumentParser\n+header extends javax\/swing\/text\/html\/parser\/Parser flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTMLEditorKit$ParserCallback outerClass javax\/swing\/text\/html\/HTMLEditorKit innerClassName ParserCallback flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/Parser\n+header extends java\/lang\/Object implements javax\/swing\/text\/html\/parser\/DTDConstants flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Attribute outerClass javax\/swing\/text\/html\/HTML innerClassName Attribute flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/text\/html\/parser\/TagElement\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass javax\/swing\/text\/html\/HTML$Tag outerClass javax\/swing\/text\/html\/HTML innerClassName Tag flags 9\n+innerclass innerClass javax\/swing\/text\/html\/HTML$UnknownTag outerClass javax\/swing\/text\/html\/HTML innerClassName UnknownTag flags 9\n+\n+class name javax\/swing\/tree\/DefaultTreeModel\n+header extends java\/lang\/Object implements java\/io\/Serializable,javax\/swing\/tree\/TreeModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/swing\/tree\/DefaultTreeSelectionModel\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable,javax\/swing\/tree\/TreeSelectionModel flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/tree\/TreePath\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/AbstractUndoableEdit\n+header extends java\/lang\/Object implements javax\/swing\/undo\/UndoableEdit,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/CompoundEdit\n+header extends javax\/swing\/undo\/AbstractUndoableEdit flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/swing\/undo\/UndoableEditSupport\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.desktop-I.sym.txt","additions":922,"deletions":0,"binary":false,"changes":922,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/java.instrument-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.instrument-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,55 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/util\/logging\/ErrorManager\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/LoggingMXBean\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+\n+class name java\/util\/logging\/LoggingPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/MemoryHandler\n+header extends java\/util\/logging\/Handler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SimpleFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/SocketHandler\n+header extends java\/util\/logging\/StreamHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/util\/logging\/XMLFormatter\n+header extends java\/util\/logging\/Formatter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.logging-I.sym.txt","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,269 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/lang\/management\/LockInfo\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/ManagementPermission\n+header extends java\/security\/BasicPermission flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MemoryMXBean\n+-method name getObjectPendingFinalizationCount descriptor ()I\n+method name getObjectPendingFinalizationCount descriptor ()I flags 401 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")\n+\n+class name java\/lang\/management\/MemoryUsage\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/MonitorInfo\n+header extends java\/lang\/management\/LockInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/lang\/management\/RuntimeMXBean\n+header extends java\/lang\/Object implements java\/lang\/management\/PlatformManagedObject flags 601\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Attribute\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/AttributeList\n+header extends java\/util\/ArrayList flags 21 signature Ljava\/util\/ArrayList<Ljava\/lang\/Object;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadAttributeValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadBinaryOpValueExpException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/BadStringOperationException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ConstructorParameters\n+header extends java\/lang\/Object implements java\/lang\/annotation\/Annotation flags 2601 runtimeAnnotations @Ljava\/lang\/annotation\/Documented;@Ljava\/lang\/annotation\/Target;(value={eLjava\/lang\/annotation\/ElementType;CONSTRUCTOR;})@Ljava\/lang\/annotation\/Retention;(value=eLjava\/lang\/annotation\/RetentionPolicy;RUNTIME;)\n+\n+class name javax\/management\/ImmutableDescriptor\n+header extends java\/lang\/Object implements javax\/management\/Descriptor flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanAttributeInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanConstructorInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanNotificationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanOperationInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanParameterInfo\n+header extends javax\/management\/MBeanFeatureInfo implements java\/lang\/Cloneable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanPermission\n+header extends java\/security\/Permission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerDelegate\n+header extends java\/lang\/Object implements javax\/management\/MBeanServerDelegateMBean,javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanServerPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/MBeanTrustPermission\n+header extends java\/security\/BasicPermission flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Notification\n+header extends java\/util\/EventObject flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/ObjectInstance\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/Query\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StandardEmitterMBean\n+header extends javax\/management\/StandardMBean implements javax\/management\/NotificationEmitter flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/StringValueExp\n+header extends java\/lang\/Object implements javax\/management\/ValueExp flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/loading\/DefaultLoaderRepository\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/loading\/MLetContent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/InvalidTargetObjectTypeException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/modelmbean\/XMLParseException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/ArrayType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataInvocationHandler\n+header extends java\/lang\/Object implements java\/lang\/reflect\/InvocationHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/CompositeData,java\/io\/Serializable flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/CompositeType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/CompositeData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanAttributeInfoSupport\n+header extends javax\/management\/MBeanAttributeInfo implements javax\/management\/openmbean\/OpenMBeanAttributeInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/OpenMBeanOperationInfoSupport\n+header extends javax\/management\/MBeanOperationInfo implements javax\/management\/openmbean\/OpenMBeanOperationInfo flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/SimpleType\n+header extends javax\/management\/openmbean\/OpenType flags 31 signature <T:Ljava\/lang\/Object;>Ljavax\/management\/openmbean\/OpenType<TT;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularDataSupport\n+header extends java\/lang\/Object implements javax\/management\/openmbean\/TabularData,java\/util\/Map,java\/lang\/Cloneable,java\/io\/Serializable flags 21 signature Ljava\/lang\/Object;Ljavax\/management\/openmbean\/TabularData;Ljava\/util\/Map<Ljava\/lang\/Object;Ljava\/lang\/Object;>;Ljava\/lang\/Cloneable;Ljava\/io\/Serializable;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/openmbean\/TabularType\n+header extends javax\/management\/openmbean\/OpenType flags 21 signature Ljavax\/management\/openmbean\/OpenType<Ljavax\/management\/openmbean\/TabularData;>;\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RelationNotification\n+header extends javax\/management\/Notification flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RelationSupport\n+header extends java\/lang\/Object implements javax\/management\/relation\/RelationSupportMBean,javax\/management\/MBeanRegistration flags 21\n+innerclass innerClass java\/lang\/System$Logger outerClass java\/lang\/System innerClassName Logger flags 609\n+innerclass innerClass java\/lang\/System$Logger$Level outerClass java\/lang\/System$Logger innerClassName Level flags 4019\n+\n+class name javax\/management\/relation\/Role\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleInfo\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/relation\/RoleResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+\n+class name javax\/management\/relation\/RoleUnresolved\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXConnectorServerFactory\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/util\/ServiceLoader$Provider outerClass java\/util\/ServiceLoader innerClassName Provider flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal,java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/JMXServiceURL\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/NotificationResult\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/management\/remote\/TargetedNotification\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.management-I.sym.txt","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/java.management.rmi-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.management.rmi-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,76 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/naming\/BinaryRefAddr\n+header extends javax\/naming\/RefAddr flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Binding\n+header extends javax\/naming\/NameClassPair flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompositeName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/CompoundName\n+header extends java\/lang\/Object implements javax\/naming\/Name flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/LinkException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NameClassPair\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/NamingException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/RefAddr\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/Reference\n+header extends java\/lang\/Object implements java\/lang\/Cloneable,java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/AttributeModificationException\n+header extends javax\/naming\/NamingException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/ModificationItem\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/naming\/directory\/SearchResult\n+header extends javax\/naming\/Binding flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.naming-I.sym.txt","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/net\/http\/HttpRequest$Builder\n+header extends java\/lang\/Object nestHost java\/net\/http\/HttpRequest flags 601\n+innerclass innerClass java\/net\/http\/HttpRequest$BodyPublishers outerClass java\/net\/http\/HttpRequest innerClassName BodyPublishers flags 9\n+innerclass innerClass java\/net\/http\/HttpRequest$BodyPublisher outerClass java\/net\/http\/HttpRequest innerClassName BodyPublisher flags 609\n+innerclass innerClass java\/net\/http\/HttpRequest$Builder outerClass java\/net\/http\/HttpRequest innerClassName Builder flags 609\n+innerclass innerClass java\/net\/http\/HttpClient$Version outerClass java\/net\/http\/HttpClient innerClassName Version flags 4019\n+method name HEAD descriptor ()Ljava\/net\/http\/HttpRequest$Builder; flags 1\n+\n","filename":"make\/data\/symbols\/java.net.http-I.sym.txt","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name java\/rmi\/RemoteException\n+header extends java\/io\/IOException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/dgc\/VMID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ObjID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/RemoteObject\n+header extends java\/lang\/Object implements java\/rmi\/Remote,java\/io\/Serializable flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/ServerCloneException\n+header extends java\/lang\/CloneNotSupportedException flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name java\/rmi\/server\/UID\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.rmi-I.sym.txt","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/java.scripting-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.scripting-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/java.security.jgss-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.security.jgss-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/java.security.sasl-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.security.sasl-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/java.smartcardio-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.smartcardio-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/java.sql-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.sql-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/java.sql.rowset-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/java.sql.rowset-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,158 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/catalog\/Catalog\n+header extends java\/lang\/Object flags 601\n+\n+class name javax\/xml\/catalog\/CatalogException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name javax\/xml\/catalog\/CatalogFeatures\n+header extends java\/lang\/Object nestMembers javax\/xml\/catalog\/CatalogFeatures$Builder,javax\/xml\/catalog\/CatalogFeatures$Feature flags 21\n+innerclass innerClass javax\/xml\/catalog\/CatalogFeatures$Builder outerClass javax\/xml\/catalog\/CatalogFeatures innerClassName Builder flags 9\n+innerclass innerClass javax\/xml\/catalog\/CatalogFeatures$Feature outerClass javax\/xml\/catalog\/CatalogFeatures innerClassName Feature flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/catalog\/CatalogManager\n+header extends java\/lang\/Object flags 31\n+\n+class name javax\/xml\/catalog\/CatalogResolver\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,javax\/xml\/stream\/XMLResolver,javax\/xml\/transform\/URIResolver,org\/w3c\/dom\/ls\/LSResourceResolver flags 601\n+\n+class name javax\/xml\/datatype\/DatatypeFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/datatype\/Duration\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/xml\/datatype\/DatatypeConstants$Field outerClass javax\/xml\/datatype\/DatatypeConstants innerClassName Field flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/namespace\/QName\n+header extends java\/lang\/Object implements java\/io\/Serializable flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilder\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/DocumentBuilderFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParser\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/parsers\/SAXParserFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/stream\/XMLEventReader\n+header extends java\/lang\/Object implements java\/util\/Iterator flags 601 signature Ljava\/lang\/Object;Ljava\/util\/Iterator<Ljava\/lang\/Object;>;\n+\n+class name javax\/xml\/stream\/XMLInputFactory\n+-method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory;\n+method name newFactory descriptor ()Ljavax\/xml\/stream\/XMLInputFactory; thrownTypes javax\/xml\/stream\/FactoryConfigurationError flags 9\n+\n+class name javax\/xml\/stream\/XMLStreamException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/Transformer\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/transform\/TransformerException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/validation\/SchemaFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/xpath\/XPath\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathException\n+header extends java\/lang\/Exception flags 21\n+innerclass innerClass java\/io\/ObjectOutputStream$PutField outerClass java\/io\/ObjectOutputStream innerClassName PutField flags 409\n+innerclass innerClass java\/io\/ObjectInputStream$GetField outerClass java\/io\/ObjectInputStream innerClassName GetField flags 409\n+\n+class name javax\/xml\/xpath\/XPathExpression\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/xml\/xpath\/XPathEvaluationResult$XPathResultType outerClass javax\/xml\/xpath\/XPathEvaluationResult innerClassName XPathResultType flags 4019\n+\n+class name javax\/xml\/xpath\/XPathFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name setProperty descriptor (Ljava\/lang\/String;Ljava\/lang\/String;)V flags 1\n+method name getProperty descriptor (Ljava\/lang\/String;)Ljava\/lang\/String; flags 1\n+\n+class name javax\/xml\/xpath\/XPathNodes\n+header extends java\/lang\/Object implements java\/lang\/Iterable flags 601 signature Ljava\/lang\/Object;Ljava\/lang\/Iterable<Lorg\/w3c\/dom\/Node;>;\n+\n+class name org\/w3c\/dom\/ElementTraversal\n+header extends java\/lang\/Object flags 601\n+\n+class name org\/xml\/sax\/AttributeList\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/DocumentHandler\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/HandlerBase\n+header extends java\/lang\/Object implements org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/DocumentHandler,org\/xml\/sax\/ErrorHandler flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/Parser\n+header extends java\/lang\/Object flags 601 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/ext\/Attributes2Impl\n+header extends org\/xml\/sax\/helpers\/AttributesImpl implements org\/xml\/sax\/ext\/Attributes2 flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/AttributeListImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/AttributeList flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/AttributesImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/Attributes flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/ParserFactory\n+header extends java\/lang\/Object flags 21 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"1.5\")\n+\n+class name org\/xml\/sax\/helpers\/XMLFilterImpl\n+header extends java\/lang\/Object implements org\/xml\/sax\/XMLFilter,org\/xml\/sax\/EntityResolver,org\/xml\/sax\/DTDHandler,org\/xml\/sax\/ContentHandler,org\/xml\/sax\/ErrorHandler flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name org\/xml\/sax\/helpers\/XMLReaderFactory\n+header extends java\/lang\/Object flags 31 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"9\")\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.xml-I.sym.txt","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name javax\/xml\/crypto\/NodeSetData\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/Data,java\/lang\/Iterable flags 601 signature <T:Ljava\/lang\/Object;>Ljava\/lang\/Object;Ljavax\/xml\/crypto\/Data;Ljava\/lang\/Iterable<TT;>;\n+\n+class name javax\/xml\/crypto\/dom\/DOMCryptoContext\n+header extends java\/lang\/Object implements javax\/xml\/crypto\/XMLCryptoContext flags 21\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/XMLSignatureFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name javax\/xml\/crypto\/dsig\/keyinfo\/KeyInfoFactory\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/security\/Provider$Service outerClass java\/security\/Provider innerClassName Service flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/java.xml.crypto-I.sym.txt","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/java\/accessibility\/util\/AWTEventMonitor\n+-field name componentWithFocus descriptor Ljava\/awt\/Component;\n+-field name componentListener descriptor Ljava\/awt\/event\/ComponentListener;\n+-field name containerListener descriptor Ljava\/awt\/event\/ContainerListener;\n+-field name focusListener descriptor Ljava\/awt\/event\/FocusListener;\n+-field name keyListener descriptor Ljava\/awt\/event\/KeyListener;\n+-field name mouseListener descriptor Ljava\/awt\/event\/MouseListener;\n+-field name mouseMotionListener descriptor Ljava\/awt\/event\/MouseMotionListener;\n+-field name windowListener descriptor Ljava\/awt\/event\/WindowListener;\n+-field name actionListener descriptor Ljava\/awt\/event\/ActionListener;\n+-field name adjustmentListener descriptor Ljava\/awt\/event\/AdjustmentListener;\n+-field name itemListener descriptor Ljava\/awt\/event\/ItemListener;\n+-field name textListener descriptor Ljava\/awt\/event\/TextListener;\n+\n+class name com\/sun\/java\/accessibility\/util\/AccessibilityListenerList\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/java\/accessibility\/util\/EventID\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/java\/accessibility\/util\/GUIInitializedListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/TopLevelWindowListener\n+header extends java\/lang\/Object implements java\/util\/EventListener flags 601\n+\n+class name com\/sun\/java\/accessibility\/util\/Translator\n+header extends javax\/accessibility\/AccessibleContext implements javax\/accessibility\/Accessible,javax\/accessibility\/AccessibleComponent flags 21\n+\n","filename":"make\/data\/symbols\/jdk.accessibility-I.sym.txt","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.attach-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.attach-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,373 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/source\/doctree\/AuthorTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/BlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/CommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DeprecatedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocCommentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocRootTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/DocTree$Kind\n+field name SNIPPET descriptor Lcom\/sun\/source\/doctree\/DocTree$Kind; flags 4019\n+\n+class name com\/sun\/source\/doctree\/DocTreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+method name visitSnippet descriptor (Lcom\/sun\/source\/doctree\/SnippetTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SnippetTree;TP;)TR;\n+\n+class name com\/sun\/source\/doctree\/DocTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EndElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/EntityTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/TextTree flags 601\n+\n+class name com\/sun\/source\/doctree\/HiddenTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/IndexTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InheritDocTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/InlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LinkTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ParamTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ReferenceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SeeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialDataTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialFieldTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SerialTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SinceTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SnippetTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+method name getAttributes descriptor ()Ljava\/util\/List; flags 401 signature ()Ljava\/util\/List<+Lcom\/sun\/source\/doctree\/DocTree;>;\n+method name getBody descriptor ()Lcom\/sun\/source\/doctree\/TextTree; flags 401\n+\n+class name com\/sun\/source\/doctree\/StartElementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/SummaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/TextTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ThrowsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownBlockTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UnknownInlineTagTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/ValueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/InlineTagTree flags 601\n+\n+class name com\/sun\/source\/doctree\/VersionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/BlockTagTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotatedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/AnnotationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayAccessTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ArrayTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/AssertTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/AssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BinaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/BlockTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/BreakTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CatchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/CompilationUnitTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/CompoundAssignmentTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ConditionalExpressionTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ContinueTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/DirectiveTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/DoWhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EmptyStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/EnhancedForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ErroneousTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExportsTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ExpressionStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ForLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/IdentifierTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ImportTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/InstanceOfTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/IntersectionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/LabeledStatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/LineMap\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/LiteralTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MemberSelectTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodInvocationTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/MethodTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ModifiersTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/NewArrayTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/NewClassTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/OpensTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/PackageTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParameterizedTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ParenthesizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/PrimitiveTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/ProvidesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/RequiresTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/ReturnTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/Scope\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/tree\/StatementTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/SwitchTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/SynchronizedTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/ThrowTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TreeVisitor\n+header extends java\/lang\/Object flags 601 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+\n+class name com\/sun\/source\/tree\/TryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeCastTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/TypeParameterTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UnaryTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/ExpressionTree flags 601\n+\n+class name com\/sun\/source\/tree\/UnionTypeTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/tree\/UsesTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/DirectiveTree flags 601\n+\n+class name com\/sun\/source\/tree\/VariableTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WhileLoopTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/StatementTree flags 601\n+\n+class name com\/sun\/source\/tree\/WildcardTree\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/Tree flags 601\n+\n+class name com\/sun\/source\/util\/DocSourcePositions\n+header extends java\/lang\/Object implements com\/sun\/source\/util\/SourcePositions flags 601\n+\n+class name com\/sun\/source\/util\/DocTreeFactory\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass com\/sun\/source\/doctree\/AttributeTree$ValueKind outerClass com\/sun\/source\/doctree\/AttributeTree innerClassName ValueKind flags 4019\n+method name newSnippetTree descriptor (Ljava\/util\/List;Lcom\/sun\/source\/doctree\/TextTree;)Lcom\/sun\/source\/doctree\/SnippetTree; flags 401 signature (Ljava\/util\/List<+Lcom\/sun\/source\/doctree\/DocTree;>;Lcom\/sun\/source\/doctree\/TextTree;)Lcom\/sun\/source\/doctree\/SnippetTree;\n+\n+class name com\/sun\/source\/util\/DocTreePathScanner\n+header extends com\/sun\/source\/util\/DocTreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/DocTreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/DocTreeScanner\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+method name visitSnippet descriptor (Lcom\/sun\/source\/doctree\/SnippetTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SnippetTree;TP;)TR;\n+\n+class name com\/sun\/source\/util\/DocTrees\n+header extends com\/sun\/source\/util\/Trees flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/source\/util\/JavacTask\n+header extends java\/lang\/Object implements javax\/tools\/JavaCompiler$CompilationTask flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+\n+class name com\/sun\/source\/util\/Plugin\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/SimpleDocTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/doctree\/DocTreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/doctree\/DocTreeVisitor<TR;TP;>;\n+method name visitSnippet descriptor (Lcom\/sun\/source\/doctree\/SnippetTree;Ljava\/lang\/Object;)Ljava\/lang\/Object; flags 1 signature (Lcom\/sun\/source\/doctree\/SnippetTree;TP;)TR;\n+\n+class name com\/sun\/source\/util\/SimpleTreeVisitor\n+header extends java\/lang\/Object implements com\/sun\/source\/tree\/TreeVisitor flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Ljava\/lang\/Object;Lcom\/sun\/source\/tree\/TreeVisitor<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/SourcePositions\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TaskListener\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/source\/util\/TreePathScanner\n+header extends com\/sun\/source\/util\/TreeScanner flags 21 signature <R:Ljava\/lang\/Object;P:Ljava\/lang\/Object;>Lcom\/sun\/source\/util\/TreeScanner<TR;TP;>;\n+\n+class name com\/sun\/source\/util\/Trees\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass javax\/tools\/JavaCompiler$CompilationTask outerClass javax\/tools\/JavaCompiler innerClassName CompilationTask flags 609\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+\n+class name com\/sun\/tools\/javac\/Main\n+header extends java\/lang\/Object flags 21\n+\n","filename":"make\/data\/symbols\/jdk.compiler-I.sym.txt","additions":373,"deletions":0,"binary":false,"changes":373,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.dynalink-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.dynalink-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,110 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.httpserver\n+header exports com\/sun\/net\/httpserver,com\/sun\/net\/httpserver\/spi requires name\\u0020;java.base\\u0020;flags\\u0020;8000 uses com\/sun\/net\/httpserver\/spi\/HttpServerProvider target linux-amd64 moduleMainClass sun\/net\/httpserver\/simpleserver\/Main flags 8000\n+\n+class name com\/sun\/net\/httpserver\/Filter\n+method name adaptRequest descriptor (Ljava\/lang\/String;Ljava\/util\/function\/UnaryOperator;)Lcom\/sun\/net\/httpserver\/Filter; flags 9 signature (Ljava\/lang\/String;Ljava\/util\/function\/UnaryOperator<Lcom\/sun\/net\/httpserver\/Request;>;)Lcom\/sun\/net\/httpserver\/Filter;\n+\n+class name com\/sun\/net\/httpserver\/Headers\n+header extends java\/lang\/Object implements java\/util\/Map flags 21 signature Ljava\/lang\/Object;Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;\n+innerclass innerClass java\/util\/Map$Entry outerClass java\/util\/Map innerClassName Entry flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name <init> descriptor (Ljava\/util\/Map;)V flags 1 signature (Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;)V\n+method name replaceAll descriptor (Ljava\/util\/function\/BiFunction;)V flags 1 signature (Ljava\/util\/function\/BiFunction<-Ljava\/lang\/String;-Ljava\/util\/List<Ljava\/lang\/String;>;+Ljava\/util\/List<Ljava\/lang\/String;>;>;)V\n+method name toString descriptor ()Ljava\/lang\/String; flags 1\n+method name of descriptor ([Ljava\/lang\/String;)Lcom\/sun\/net\/httpserver\/Headers; flags 89\n+method name of descriptor (Ljava\/util\/Map;)Lcom\/sun\/net\/httpserver\/Headers; flags 9 signature (Ljava\/util\/Map<Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;>;)Lcom\/sun\/net\/httpserver\/Headers;\n+\n+class name com\/sun\/net\/httpserver\/HttpContext\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpExchange\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable,com\/sun\/net\/httpserver\/Request flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpHandler\n+header extends java\/lang\/Object flags 601\n+\n+class name com\/sun\/net\/httpserver\/HttpHandlers\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name handleOrElse descriptor (Ljava\/util\/function\/Predicate;Lcom\/sun\/net\/httpserver\/HttpHandler;Lcom\/sun\/net\/httpserver\/HttpHandler;)Lcom\/sun\/net\/httpserver\/HttpHandler; flags 9 signature (Ljava\/util\/function\/Predicate<Lcom\/sun\/net\/httpserver\/Request;>;Lcom\/sun\/net\/httpserver\/HttpHandler;Lcom\/sun\/net\/httpserver\/HttpHandler;)Lcom\/sun\/net\/httpserver\/HttpHandler;\n+method name of descriptor (ILcom\/sun\/net\/httpserver\/Headers;Ljava\/lang\/String;)Lcom\/sun\/net\/httpserver\/HttpHandler; flags 9\n+\n+class name com\/sun\/net\/httpserver\/HttpPrincipal\n+header extends java\/lang\/Object implements java\/security\/Principal flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/net\/httpserver\/HttpServer\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name create descriptor (Ljava\/net\/InetSocketAddress;ILjava\/lang\/String;Lcom\/sun\/net\/httpserver\/HttpHandler;[Lcom\/sun\/net\/httpserver\/Filter;)Lcom\/sun\/net\/httpserver\/HttpServer; thrownTypes java\/io\/IOException flags 89\n+\n+class name com\/sun\/net\/httpserver\/HttpsConfigurator\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/net\/httpserver\/HttpsExchange\n+header extends com\/sun\/net\/httpserver\/HttpExchange flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsParameters\n+header extends java\/lang\/Object flags 421\n+\n+class name com\/sun\/net\/httpserver\/HttpsServer\n+header extends com\/sun\/net\/httpserver\/HttpServer flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name create descriptor (Ljava\/net\/InetSocketAddress;ILjava\/lang\/String;Lcom\/sun\/net\/httpserver\/HttpHandler;[Lcom\/sun\/net\/httpserver\/Filter;)Lcom\/sun\/net\/httpserver\/HttpsServer; thrownTypes java\/io\/IOException flags 89\n+\n+class name com\/sun\/net\/httpserver\/Request\n+header extends java\/lang\/Object flags 601\n+method name getRequestURI descriptor ()Ljava\/net\/URI; flags 401\n+method name getRequestMethod descriptor ()Ljava\/lang\/String; flags 401\n+method name getRequestHeaders descriptor ()Lcom\/sun\/net\/httpserver\/Headers; flags 401\n+method name with descriptor (Ljava\/lang\/String;Ljava\/util\/List;)Lcom\/sun\/net\/httpserver\/Request; flags 1 signature (Ljava\/lang\/String;Ljava\/util\/List<Ljava\/lang\/String;>;)Lcom\/sun\/net\/httpserver\/Request;\n+\n+class name com\/sun\/net\/httpserver\/SimpleFileServer\n+header extends java\/lang\/Object nestMembers com\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel flags 31\n+innerclass innerClass com\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel outerClass com\/sun\/net\/httpserver\/SimpleFileServer innerClassName OutputLevel flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+method name createFileServer descriptor (Ljava\/net\/InetSocketAddress;Ljava\/nio\/file\/Path;Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel;)Lcom\/sun\/net\/httpserver\/HttpServer; flags 9\n+method name createFileHandler descriptor (Ljava\/nio\/file\/Path;)Lcom\/sun\/net\/httpserver\/HttpHandler; flags 9\n+method name createOutputFilter descriptor (Ljava\/io\/OutputStream;Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel;)Lcom\/sun\/net\/httpserver\/Filter; flags 9\n+\n+class name com\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel\n+header extends java\/lang\/Enum nestHost com\/sun\/net\/httpserver\/SimpleFileServer flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel;>;\n+innerclass innerClass com\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel outerClass com\/sun\/net\/httpserver\/SimpleFileServer innerClassName OutputLevel flags 4019\n+field name NONE descriptor Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel; flags 4019\n+field name INFO descriptor Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel; flags 4019\n+field name VERBOSE descriptor Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel; flags 4019\n+method name values descriptor ()[Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel; flags 9\n+method name valueOf descriptor (Ljava\/lang\/String;)Lcom\/sun\/net\/httpserver\/SimpleFileServer$OutputLevel; flags 9\n+\n+class name com\/sun\/net\/httpserver\/spi\/HttpServerProvider\n+header extends java\/lang\/Object flags 421\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/jdk.httpserver-I.sym.txt","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,582 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/foreign\/AbstractLayout\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/MemoryLayout flags 420\n+innerclass innerClass java\/lang\/constant\/DirectMethodHandleDesc$Kind outerClass java\/lang\/constant\/DirectMethodHandleDesc innerClassName Kind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name <init> descriptor (Ljava\/util\/OptionalLong;JLjava\/util\/Map;)V\n+-method name attribute descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name attributes descriptor ()Ljava\/util\/stream\/Stream;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/AbstractLayout;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/MemoryLayout;\n+method name <init> descriptor (Ljava\/util\/OptionalLong;JLjava\/util\/Optional;)V flags 1 signature (Ljava\/util\/OptionalLong;JLjava\/util\/Optional<Ljava\/lang\/String;>;)V\n+method name byteSize descriptor ()J flags 1\n+\n+class name jdk\/incubator\/foreign\/Addressable\n+header extends java\/lang\/Object sealed true flags 601\n+\n+class name jdk\/incubator\/foreign\/CLinker\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/SymbolLookup sealed true flags 601\n+-field name C_CHAR descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_SHORT descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_INT descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_LONG descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_LONG_LONG descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_FLOAT descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_DOUBLE descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_POINTER descriptor Ljdk\/incubator\/foreign\/ValueLayout;\n+-field name C_VA_LIST descriptor Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/Addressable;Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle;\n+-method name asVarArg descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljava\/lang\/String;\n+-method name getInstance descriptor ()Ljdk\/incubator\/foreign\/CLinker;\n+-method name systemLookup descriptor ()Ljdk\/incubator\/foreign\/SymbolLookup;\n+-method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/Addressable;Ljdk\/incubator\/foreign\/SegmentAllocator;Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle;\n+-method name downcallHandle descriptor (Ljava\/lang\/invoke\/MethodType;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle;\n+-method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toCString descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toJavaString descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljava\/lang\/String;\n+-method name allocateMemory descriptor (J)Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name freeMemory descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)V\n+method name systemCLinker descriptor ()Ljdk\/incubator\/foreign\/CLinker; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 1 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/NativeSymbol;>;\n+method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/NativeSymbol;Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 1\n+method name downcallHandle descriptor (Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodHandle; flags 401\n+method name upcallStub descriptor (Ljava\/lang\/invoke\/MethodHandle;Ljdk\/incubator\/foreign\/FunctionDescriptor;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/NativeSymbol; flags 401\n+method name downcallType descriptor (Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodType; flags 9\n+method name upcallType descriptor (Ljdk\/incubator\/foreign\/FunctionDescriptor;)Ljava\/lang\/invoke\/MethodType; flags 9\n+\n+-class name jdk\/incubator\/foreign\/CLinker$TypeKind\n+\n+-class name jdk\/incubator\/foreign\/CLinker$VaList\n+\n+-class name jdk\/incubator\/foreign\/CLinker$VaList$Builder\n+\n+class name jdk\/incubator\/foreign\/FunctionDescriptor\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable sealed true flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name TRIVIAL_ATTRIBUTE_NAME descriptor Ljava\/lang\/String;\n+-method name attribute descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name attributes descriptor ()Ljava\/util\/stream\/Stream;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/FunctionDescriptor;\n+-method name withAppendedArgumentLayouts descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/FunctionDescriptor;\n+-method name withReturnLayout descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/FunctionDescriptor;\n+-method name withVoidReturnLayout descriptor ()Ljdk\/incubator\/foreign\/FunctionDescriptor;\n+method name asVariadic descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/FunctionDescriptor; flags 81\n+method name firstVariadicArgumentIndex descriptor ()I flags 1\n+method name appendArgumentLayouts descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/FunctionDescriptor; flags 81\n+method name insertArgumentLayouts descriptor (I[Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/FunctionDescriptor; flags 81\n+method name changeReturnLayout descriptor (Ljdk\/incubator\/foreign\/MemoryLayout;)Ljdk\/incubator\/foreign\/FunctionDescriptor; flags 1\n+method name dropReturnLayout descriptor ()Ljdk\/incubator\/foreign\/FunctionDescriptor; flags 1\n+\n+class name jdk\/incubator\/foreign\/GroupLayout\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/GroupLayout;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/AbstractLayout;\n+-method name attributes descriptor ()Ljava\/util\/stream\/Stream;\n+-method name attribute descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/MemoryLayout;\n+method name byteSize descriptor ()J flags 1041\n+\n+-class name jdk\/incubator\/foreign\/MemoryAccess\n+\n+class name jdk\/incubator\/foreign\/MemoryAddress\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfByte outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfBoolean outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfChar outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfShort outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfFloat outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+-method name address descriptor ()Ljdk\/incubator\/foreign\/MemoryAddress;\n+-method name segmentOffset descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)J\n+-method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope;\n+-method name asSegment descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name asSegment descriptor (JLjava\/lang\/Runnable;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name isNative descriptor ()Z\n+method name getUtf8String descriptor (J)Ljava\/lang\/String; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setUtf8String descriptor (JLjava\/lang\/String;)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;J)B flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;JB)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean;J)Z flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean;JZ)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;J)C flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;JC)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;J)S flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;JS)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;J)I flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;JI)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;J)F flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;JF)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;J)J flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;JJ)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;J)D flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;JD)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;JLjdk\/incubator\/foreign\/Addressable;)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;J)C flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;JC)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;J)S flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;JS)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;J)I flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;JI)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;J)F flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;JF)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;J)J flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;JJ)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;J)D flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;JD)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;JLjdk\/incubator\/foreign\/Addressable;)V flags 401 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name jdk\/incubator\/foreign\/MemoryHandles\n+-method name varHandle descriptor (Ljava\/lang\/Class;Ljava\/nio\/ByteOrder;)Ljava\/lang\/invoke\/VarHandle;\n+-method name varHandle descriptor (Ljava\/lang\/Class;JLjava\/nio\/ByteOrder;)Ljava\/lang\/invoke\/VarHandle;\n+-method name asAddressVarHandle descriptor (Ljava\/lang\/invoke\/VarHandle;)Ljava\/lang\/invoke\/VarHandle;\n+method name varHandle descriptor (Ljdk\/incubator\/foreign\/ValueLayout;)Ljava\/lang\/invoke\/VarHandle; flags 9\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout\n+header extends java\/lang\/Object implements java\/lang\/constant\/Constable nestMembers jdk\/incubator\/foreign\/MemoryLayout$PathElement sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfBoolean outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfChar outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfByte outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfShort outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfFloat outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-field name LAYOUT_NAME descriptor Ljava\/lang\/String;\n+-method name byteSize descriptor ()J\n+-method name varHandle descriptor (Ljava\/lang\/Class;[Ljdk\/incubator\/foreign\/MemoryLayout$PathElement;)Ljava\/lang\/invoke\/VarHandle;\n+-method name attribute descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/MemoryLayout;\n+-method name attributes descriptor ()Ljava\/util\/stream\/Stream;\n+-method name valueLayout descriptor (JLjava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout;\n+method name byteSize descriptor ()J flags 401\n+method name varHandle descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout$PathElement;)Ljava\/lang\/invoke\/VarHandle; flags 81\n+method name valueLayout descriptor (Ljava\/lang\/Class;Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 9 signature (Ljava\/lang\/Class<*>;Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout;\n+\n+class name jdk\/incubator\/foreign\/MemoryLayout$PathElement\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/MemoryLayout sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+-class name jdk\/incubator\/foreign\/MemoryLayouts\n+\n+class name jdk\/incubator\/foreign\/MemorySegment\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+innerclass innerClass java\/nio\/channels\/FileChannel$MapMode outerClass java\/nio\/channels\/FileChannel innerClassName MapMode flags 9\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfByte outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfBoolean outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfChar outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfShort outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfFloat outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name toByteArray descriptor ()[B\n+-method name copyFrom descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)V\n+-method name asSlice descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name asSlice descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name toShortArray descriptor ()[S\n+-method name toCharArray descriptor ()[C\n+-method name toIntArray descriptor ()[I\n+-method name toFloatArray descriptor ()[F\n+-method name toLongArray descriptor ()[J\n+-method name toDoubleArray descriptor ()[D\n+-method name asReadOnly descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name isReadOnly descriptor ()Z\n+-method name globalNativeSegment descriptor ()Ljdk\/incubator\/foreign\/MemorySegment;\n+method name asReadOnly descriptor ()Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name isReadOnly descriptor ()Z flags 401\n+method name asOverlappingSlice descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name segmentOffset descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)J flags 401\n+method name copyFrom descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;)[B flags 401\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;)[S flags 401\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;)[C flags 401\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;)[I flags 401\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;)[F flags 401\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;)[J flags 401\n+method name toArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;)[D flags 401\n+method name getUtf8String descriptor (J)Ljava\/lang\/String; flags 1\n+method name setUtf8String descriptor (JLjava\/lang\/String;)V flags 1\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/MemorySegment; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name copy descriptor (Ljdk\/incubator\/foreign\/MemorySegment;JLjdk\/incubator\/foreign\/MemorySegment;JJ)V flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name copy descriptor (Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/ValueLayout;JLjdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/ValueLayout;JJ)V flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;J)B flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;JB)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean;J)Z flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean;JZ)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;J)C flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;JC)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;J)S flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;JS)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;J)I flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;JI)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;J)F flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;JF)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;J)J flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;JJ)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;J)D flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;JD)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name get descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name set descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;JLjdk\/incubator\/foreign\/Addressable;)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;J)C flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;JC)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;J)S flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;JS)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;J)I flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;JI)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;J)F flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;JF)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;J)J flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;JJ)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;J)D flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;JD)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name getAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;J)Ljdk\/incubator\/foreign\/MemoryAddress; flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name setAtIndex descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;JLjdk\/incubator\/foreign\/Addressable;)V flags 1 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name copy descriptor (Ljdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/ValueLayout;JLjava\/lang\/Object;II)V flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name copy descriptor (Ljava\/lang\/Object;ILjdk\/incubator\/foreign\/MemorySegment;Ljdk\/incubator\/foreign\/ValueLayout;JI)V flags 9 runtimeAnnotations @Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name jdk\/incubator\/foreign\/NativeSymbol\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable sealed true flags 601\n+method name name descriptor ()Ljava\/lang\/String; flags 401\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name address descriptor ()Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name ofAddress descriptor (Ljava\/lang\/String;Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/NativeSymbol; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+\n+class name jdk\/incubator\/foreign\/ResourceScope\n+header extends java\/lang\/Object implements java\/lang\/AutoCloseable sealed true flags 601\n+-method name isImplicit descriptor ()Z\n+-method name acquire descriptor ()Ljdk\/incubator\/foreign\/ResourceScope$Handle;\n+-method name release descriptor (Ljdk\/incubator\/foreign\/ResourceScope$Handle;)V\n+method name keepAlive descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)V flags 401\n+\n+-class name jdk\/incubator\/foreign\/ResourceScope$Handle\n+\n+class name jdk\/incubator\/foreign\/SegmentAllocator\n+header extends java\/lang\/Object flags 601 runtimeAnnotations @Ljava\/lang\/FunctionalInterface;\n+innerclass innerClass jdk\/incubator\/foreign\/MemoryLayout$PathElement outerClass jdk\/incubator\/foreign\/MemoryLayout innerClassName PathElement flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfByte outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfChar outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfShort outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfFloat outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;B)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;C)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;S)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;I)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;F)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;D)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[B)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[S)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[C)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[I)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[F)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[J)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[D)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout;[Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment;\n+-method name arenaAllocator descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator;\n+-method name arenaAllocator descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator;\n+-method name ofSegment descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/SegmentAllocator;\n+-method name ofScope descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator;\n+method name allocateUtf8String descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocate descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfByte;[B)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfShort;[S)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfChar;[C)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;[I)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfFloat;[F)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;[J)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name allocateArray descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;[D)Ljdk\/incubator\/foreign\/MemorySegment; flags 1\n+method name newNativeArena descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name newNativeArena descriptor (JLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name newNativeArena descriptor (JJLjdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name prefixAllocator descriptor (Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name nativeAllocator descriptor (Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+method name implicitAllocator descriptor ()Ljdk\/incubator\/foreign\/SegmentAllocator; flags 9\n+\n+class name jdk\/incubator\/foreign\/SequenceLayout\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/SequenceLayout;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/AbstractLayout;\n+-method name attributes descriptor ()Ljava\/util\/stream\/Stream;\n+-method name attribute descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/MemoryLayout;\n+method name byteSize descriptor ()J flags 1041\n+\n+class name jdk\/incubator\/foreign\/SymbolLookup\n+-method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+method name lookup descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional; flags 401 signature (Ljava\/lang\/String;)Ljava\/util\/Optional<Ljdk\/incubator\/foreign\/NativeSymbol;>;\n+\n+class name jdk\/incubator\/foreign\/VaList\n+header extends java\/lang\/Object implements jdk\/incubator\/foreign\/Addressable nestMembers jdk\/incubator\/foreign\/VaList$Builder sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/VaList$Builder outerClass jdk\/incubator\/foreign\/VaList innerClassName Builder flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+method name nextVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;)I flags 401\n+method name nextVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;)J flags 401\n+method name nextVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;)D flags 401\n+method name nextVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;)Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name nextVarg descriptor (Ljdk\/incubator\/foreign\/GroupLayout;Ljdk\/incubator\/foreign\/SegmentAllocator;)Ljdk\/incubator\/foreign\/MemorySegment; flags 401\n+method name skip descriptor ([Ljdk\/incubator\/foreign\/MemoryLayout;)V flags 481\n+method name scope descriptor ()Ljdk\/incubator\/foreign\/ResourceScope; flags 401\n+method name copy descriptor ()Ljdk\/incubator\/foreign\/VaList; flags 401\n+method name address descriptor ()Ljdk\/incubator\/foreign\/MemoryAddress; flags 401\n+method name ofAddress descriptor (Ljdk\/incubator\/foreign\/MemoryAddress;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/VaList; flags 9 runtimeAnnotations @Ljdk\/internal\/reflect\/CallerSensitive;\n+method name make descriptor (Ljava\/util\/function\/Consumer;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/VaList; flags 9 signature (Ljava\/util\/function\/Consumer<Ljdk\/incubator\/foreign\/VaList$Builder;>;Ljdk\/incubator\/foreign\/ResourceScope;)Ljdk\/incubator\/foreign\/VaList;\n+method name empty descriptor ()Ljdk\/incubator\/foreign\/VaList; flags 9\n+\n+class name jdk\/incubator\/foreign\/VaList$Builder\n+header extends java\/lang\/Object nestHost jdk\/incubator\/foreign\/VaList sealed true flags 601\n+innerclass innerClass jdk\/incubator\/foreign\/VaList$Builder outerClass jdk\/incubator\/foreign\/VaList innerClassName Builder flags 609\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+method name addVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfInt;I)Ljdk\/incubator\/foreign\/VaList$Builder; flags 401\n+method name addVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfLong;J)Ljdk\/incubator\/foreign\/VaList$Builder; flags 401\n+method name addVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfDouble;D)Ljdk\/incubator\/foreign\/VaList$Builder; flags 401\n+method name addVarg descriptor (Ljdk\/incubator\/foreign\/ValueLayout$OfAddress;Ljdk\/incubator\/foreign\/Addressable;)Ljdk\/incubator\/foreign\/VaList$Builder; flags 401\n+method name addVarg descriptor (Ljdk\/incubator\/foreign\/GroupLayout;Ljdk\/incubator\/foreign\/MemorySegment;)Ljdk\/incubator\/foreign\/VaList$Builder; flags 401\n+\n+class name jdk\/incubator\/foreign\/ValueLayout\n+header extends jdk\/incubator\/foreign\/AbstractLayout implements jdk\/incubator\/foreign\/MemoryLayout nestMembers jdk\/incubator\/foreign\/ValueLayout$OfAddress,jdk\/incubator\/foreign\/ValueLayout$OfDouble,jdk\/incubator\/foreign\/ValueLayout$OfLong,jdk\/incubator\/foreign\/ValueLayout$OfFloat,jdk\/incubator\/foreign\/ValueLayout$OfInt,jdk\/incubator\/foreign\/ValueLayout$OfShort,jdk\/incubator\/foreign\/ValueLayout$OfChar,jdk\/incubator\/foreign\/ValueLayout$OfByte,jdk\/incubator\/foreign\/ValueLayout$OfBoolean sealed true flags 21\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfByte outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfByte flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfBoolean outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfChar outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfChar flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfShort outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfShort flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfFloat outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/ValueLayout;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/AbstractLayout;\n+-method name attributes descriptor ()Ljava\/util\/stream\/Stream;\n+-method name attribute descriptor (Ljava\/lang\/String;)Ljava\/util\/Optional;\n+-method name withAttribute descriptor (Ljava\/lang\/String;Ljava\/lang\/constant\/Constable;)Ljdk\/incubator\/foreign\/MemoryLayout;\n+field name ADDRESS descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfAddress; flags 19\n+field name JAVA_BYTE descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfByte; flags 19\n+field name JAVA_BOOLEAN descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean; flags 19\n+field name JAVA_CHAR descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfChar; flags 19\n+field name JAVA_SHORT descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfShort; flags 19\n+field name JAVA_INT descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfInt; flags 19\n+field name JAVA_LONG descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfLong; flags 19\n+field name JAVA_FLOAT descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfFloat; flags 19\n+field name JAVA_DOUBLE descriptor Ljdk\/incubator\/foreign\/ValueLayout$OfDouble; flags 19\n+method name carrier descriptor ()Ljava\/lang\/Class; flags 1 signature ()Ljava\/lang\/Class<*>;\n+method name byteSize descriptor ()J flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfAddress\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfAddress outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfAddress flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfAddress; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfAddress; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfAddress; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfBoolean\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfBoolean outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfBoolean flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfBoolean; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfByte\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfByte outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfByte flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfByte; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfByte; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfByte; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfChar\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfChar outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfChar flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfChar; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfChar; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfChar; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfDouble\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfDouble outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfDouble flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfDouble; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfDouble; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfDouble; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfFloat\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfFloat outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfFloat flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfFloat; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfFloat; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfFloat; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfInt\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfInt outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfInt flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfInt; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfInt; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfInt; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfLong\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfLong outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfLong flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfLong; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfLong; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfLong; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n+class name jdk\/incubator\/foreign\/ValueLayout$OfShort\n+header extends jdk\/incubator\/foreign\/ValueLayout nestHost jdk\/incubator\/foreign\/ValueLayout flags 31\n+innerclass innerClass jdk\/incubator\/foreign\/ValueLayout$OfShort outerClass jdk\/incubator\/foreign\/ValueLayout innerClassName OfShort flags 19\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout$OfShort; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout$OfShort; flags 1\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout$OfShort; flags 1\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withOrder descriptor (Ljava\/nio\/ByteOrder;)Ljdk\/incubator\/foreign\/ValueLayout; flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/MemoryLayout; flags 1041\n+method name isPadding descriptor ()Z flags 1041\n+method name bitSize descriptor ()J flags 1041\n+method name hasSize descriptor ()Z flags 1041\n+method name byteSize descriptor ()J flags 1041\n+method name withBitAlignment descriptor (J)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+method name withName descriptor (Ljava\/lang\/String;)Ljdk\/incubator\/foreign\/AbstractLayout; flags 1041\n+\n","filename":"make\/data\/symbols\/jdk.incubator.foreign-I.sym.txt","additions":582,"deletions":0,"binary":false,"changes":582,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/incubator\/vector\/ByteVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Byte;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector;\n+-method name compare descriptor (Ljdk\/incubator\/vector\/VectorOperators$Comparison;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/VectorMask;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Byte;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ByteVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Byte;>;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Byte;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Byte;>;)Ljdk\/incubator\/vector\/ByteVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+\n+class name jdk\/incubator\/vector\/DoubleVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Double;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/DoubleVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/DoubleVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/DoubleVector;\n+-method name compare descriptor (Ljdk\/incubator\/vector\/VectorOperators$Comparison;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/VectorMask;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/DoubleVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Double;>;)Ljdk\/incubator\/vector\/DoubleVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/DoubleVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Double;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Double;>;)Ljdk\/incubator\/vector\/DoubleVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/DoubleVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Double;>;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Double;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Double;>;)Ljdk\/incubator\/vector\/DoubleVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+\n+class name jdk\/incubator\/vector\/FloatVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Float;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/FloatVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/FloatVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/FloatVector;\n+-method name compare descriptor (Ljdk\/incubator\/vector\/VectorOperators$Comparison;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/VectorMask;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/FloatVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Float;>;)Ljdk\/incubator\/vector\/FloatVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/FloatVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Float;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Float;>;)Ljdk\/incubator\/vector\/FloatVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/FloatVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Float;>;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Float;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Float;>;)Ljdk\/incubator\/vector\/FloatVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+\n+class name jdk\/incubator\/vector\/IntVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Integer;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/IntVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/IntVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/IntVector;\n+-method name compare descriptor (Ljdk\/incubator\/vector\/VectorOperators$Comparison;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/VectorMask;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/IntVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Integer;>;)Ljdk\/incubator\/vector\/IntVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/IntVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Integer;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Integer;>;)Ljdk\/incubator\/vector\/IntVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/IntVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Integer;>;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Integer;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Integer;>;)Ljdk\/incubator\/vector\/IntVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+\n+class name jdk\/incubator\/vector\/LongVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Long;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/LongVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/LongVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/LongVector;\n+-method name compare descriptor (Ljdk\/incubator\/vector\/VectorOperators$Comparison;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/VectorMask;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/LongVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Long;>;)Ljdk\/incubator\/vector\/LongVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/LongVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Long;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Long;>;)Ljdk\/incubator\/vector\/LongVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/LongVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Long;>;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Long;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Long;>;)Ljdk\/incubator\/vector\/LongVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+\n+class name jdk\/incubator\/vector\/ShortVector\n+header extends jdk\/incubator\/vector\/AbstractVector flags 421 signature Ljdk\/incubator\/vector\/AbstractVector<Ljava\/lang\/Short;>;\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Operator outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Operator flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Unary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Unary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Comparison outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Comparison flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Associative outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Associative flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Binary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Binary flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$Vector outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName Vector flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Ternary outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Ternary flags 609\n+innerclass innerClass jdk\/incubator\/vector\/VectorOperators$Test outerClass jdk\/incubator\/vector\/VectorOperators innerClassName Test flags 609\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorShuffle outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorShuffle flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector;\n+-method name compare descriptor (Ljdk\/incubator\/vector\/VectorOperators$Comparison;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/VectorMask;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+-method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Short;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/ShortVector; flags 401 signature (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Short;>;Ljdk\/incubator\/vector\/Vector<Ljava\/lang\/Short;>;Ljdk\/incubator\/vector\/VectorMask<Ljava\/lang\/Short;>;)Ljdk\/incubator\/vector\/ShortVector;\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Ternary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Binary;Ljdk\/incubator\/vector\/Vector;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+method name lanewise descriptor (Ljdk\/incubator\/vector\/VectorOperators$Unary;Ljdk\/incubator\/vector\/VectorMask;)Ljdk\/incubator\/vector\/Vector; flags 1041\n+\n+class name jdk\/incubator\/vector\/VectorMask\n+header extends jdk\/internal\/vm\/vector\/VectorSupport$VectorMask flags 421 signature <E:Ljava\/lang\/Object;>Ljdk\/internal\/vm\/vector\/VectorSupport$VectorMask<TE;>;\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorMask outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorMask flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorSpecies outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorSpecies flags 9\n+innerclass innerClass jdk\/internal\/vm\/vector\/VectorSupport$VectorPayload outerClass jdk\/internal\/vm\/vector\/VectorSupport innerClassName VectorPayload flags 9\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n","filename":"make\/data\/symbols\/jdk.incubator.vector-I.sym.txt","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.jartool-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.jartool-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,37 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/javadoc\/doclet\/Reporter\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass javax\/tools\/Diagnostic$Kind outerClass javax\/tools\/Diagnostic innerClassName Kind flags 4019\n+method name print descriptor (Ljavax\/tools\/Diagnostic$Kind;Lcom\/sun\/source\/util\/DocTreePath;IIILjava\/lang\/String;)V flags 1\n+\n+class name jdk\/javadoc\/doclet\/StandardDoclet\n+header extends java\/lang\/Object implements jdk\/javadoc\/doclet\/Doclet flags 21\n+innerclass innerClass jdk\/javadoc\/doclet\/Doclet$Option outerClass jdk\/javadoc\/doclet\/Doclet innerClassName Option flags 609\n+\n","filename":"make\/data\/symbols\/jdk.javadoc-I.sym.txt","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.jconsole-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.jconsole-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/jdk.jdi-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.jdi-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.jlink\n+header requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.internal.opt\\u0020;flags\\u0020;0,name\\u0020;jdk.jdeps\\u0020;flags\\u0020;0 uses jdk\/tools\/jlink\/plugin\/Plugin provides interface\\u0020;java\/util\/spi\/ToolProvider\\u0020;impls\\u0020;jdk\/tools\/jmod\/Main$JmodToolProvider\\u005C;u002C;jdk\/tools\/jlink\/internal\/Main$JlinkToolProvider,interface\\u0020;jdk\/tools\/jlink\/plugin\/Plugin\\u0020;impls\\u0020;jdk\/tools\/jlink\/internal\/plugins\/DefaultStripDebugPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripJavaDebugAttributesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludePlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeFilesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeJmodSectionPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/LegalNoticeFilePlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripNativeCommandsPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/OrderResourcesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/DefaultCompressPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ExcludeVMPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/IncludeLocalesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/GenerateJLIClassesPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/ReleaseInfoPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/AddOptionsPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorBugURLPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorVMBugURLPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/VendorVersionPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/CDSPlugin\\u005C;u002C;jdk\/tools\/jlink\/internal\/plugins\/StripNativeDebugSymbolsPlugin target linux-amd64 flags 8000\n+\n","filename":"make\/data\/symbols\/jdk.jlink-I.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name jdk\/jshell\/DeclarationSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/Diag\n+header extends java\/lang\/Object flags 421\n+\n+class name jdk\/jshell\/EvalException\n+header extends jdk\/jshell\/JShellException flags 21\n+\n+class name jdk\/jshell\/ExpressionSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/ImportSnippet\n+header extends jdk\/jshell\/PersistentSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/JShellException\n+header extends java\/lang\/Exception flags 21\n+\n+class name jdk\/jshell\/MethodSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/PersistentSnippet\n+header extends jdk\/jshell\/Snippet flags 421\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/SnippetEvent\n+header extends java\/lang\/Object flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$Status outerClass jdk\/jshell\/Snippet innerClassName Status flags 4019\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/StatementSnippet\n+header extends jdk\/jshell\/Snippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/TypeDeclSnippet\n+header extends jdk\/jshell\/DeclarationSnippet flags 21\n+innerclass innerClass jdk\/jshell\/Snippet$SubKind outerClass jdk\/jshell\/Snippet innerClassName SubKind flags 4019\n+\n+class name jdk\/jshell\/execution\/FailOverExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiDefaultExecutionControl\n+header extends jdk\/jshell\/execution\/JdiExecutionControl flags 21\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$RunException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName RunException flags 409\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name jdk\/jshell\/execution\/JdiExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/execution\/LoaderDelegate\n+header extends java\/lang\/Object flags 601\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassBytecodes outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassBytecodes flags 19\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$ClassInstallException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName ClassInstallException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$NotImplementedException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName NotImplementedException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$EngineTerminationException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName EngineTerminationException flags 9\n+innerclass innerClass jdk\/jshell\/spi\/ExecutionControl$InternalException outerClass jdk\/jshell\/spi\/ExecutionControl innerClassName InternalException flags 9\n+\n+class name jdk\/jshell\/execution\/LocalExecutionControlProvider\n+header extends java\/lang\/Object implements jdk\/jshell\/spi\/ExecutionControlProvider flags 21\n+\n+class name jdk\/jshell\/spi\/ExecutionControlProvider\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/ExecutionEnv\n+header extends java\/lang\/Object flags 601\n+\n+class name jdk\/jshell\/spi\/SPIResolutionException\n+header extends java\/lang\/RuntimeException flags 21\n+\n+class name jdk\/jshell\/tool\/JavaShellToolBuilder\n+header extends java\/lang\/Object flags 601\n+\n","filename":"make\/data\/symbols\/jdk.jshell-I.sym.txt","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.jsobject-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.jsobject-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/jdk.management-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.management-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,31 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+module name jdk.management.jfr\n+header exports jdk\/management\/jfr requires name\\u0020;java.base\\u0020;flags\\u0020;8000,name\\u0020;jdk.management\\u0020;flags\\u0020;0,name\\u0020;java.management\\u0020;flags\\u0020;20,name\\u0020;jdk.jfr\\u0020;flags\\u0020;20 provides interface\\u0020;sun\/management\/spi\/PlatformMBeanProvider\\u0020;impls\\u0020;jdk\/management\/jfr\/internal\/FlightRecorderMXBeanProvider target linux-amd64 flags 8000\n+\n","filename":"make\/data\/symbols\/jdk.management.jfr-I.sym.txt","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.net-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.net-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/jdk.sctp-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.sctp-H.sym.txt","status":"copied"},{"patch":"","filename":"make\/data\/symbols\/jdk.security.auth-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.security.auth-H.sym.txt","status":"copied"},{"patch":"@@ -0,0 +1,47 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/security\/jgss\/AuthorizationDataEntry\n+header extends java\/lang\/Object flags 31\n+innerclass innerClass java\/lang\/invoke\/MethodHandles$Lookup outerClass java\/lang\/invoke\/MethodHandles innerClassName Lookup flags 19\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSContext\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSContext flags 601\n+\n+class name com\/sun\/security\/jgss\/ExtendedGSSCredential\n+header extends java\/lang\/Object implements org\/ietf\/jgss\/GSSCredential flags 601\n+\n+class name com\/sun\/security\/jgss\/GSSUtil\n+header extends java\/lang\/Object flags 21\n+\n+class name com\/sun\/security\/jgss\/InquireSecContextPermission\n+header extends java\/security\/BasicPermission flags 31\n+\n+class name com\/sun\/security\/jgss\/InquireType\n+header extends java\/lang\/Enum flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/security\/jgss\/InquireType;>;\n+\n","filename":"make\/data\/symbols\/jdk.security.jgss-I.sym.txt","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+#\n+# Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+# ##########################################################\n+# ### THIS FILE IS AUTOMATICALLY GENERATED. DO NOT EDIT. ###\n+# ##########################################################\n+#\n+class name com\/sun\/nio\/file\/ExtendedCopyOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/CopyOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedCopyOption;>;Ljava\/nio\/file\/CopyOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedOpenOption\n+header extends java\/lang\/Enum implements java\/nio\/file\/OpenOption flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedOpenOption;>;Ljava\/nio\/file\/OpenOption; classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name com\/sun\/nio\/file\/ExtendedWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/ExtendedWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name com\/sun\/nio\/file\/SensitivityWatchEventModifier\n+header extends java\/lang\/Enum implements java\/nio\/file\/WatchEvent$Modifier flags 4031 signature Ljava\/lang\/Enum<Lcom\/sun\/nio\/file\/SensitivityWatchEventModifier;>;Ljava\/nio\/file\/WatchEvent$Modifier; classAnnotations @Lsun\/Proprietary+Annotation;\n+innerclass innerClass java\/nio\/file\/WatchEvent$Modifier outerClass java\/nio\/file\/WatchEvent innerClassName Modifier flags 609\n+\n+class name sun\/misc\/SignalHandler\n+header extends java\/lang\/Object flags 601 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n+class name sun\/misc\/Unsafe\n+-method name objectFieldOffset descriptor (Ljava\/lang\/reflect\/Field;)J\n+-method name staticFieldOffset descriptor (Ljava\/lang\/reflect\/Field;)J\n+-method name staticFieldBase descriptor (Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object;\n+method name objectFieldOffset descriptor (Ljava\/lang\/reflect\/Field;)J flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")@Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name staticFieldOffset descriptor (Ljava\/lang\/reflect\/Field;)J flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")@Ljdk\/internal\/vm\/annotation\/ForceInline;\n+method name staticFieldBase descriptor (Ljava\/lang\/reflect\/Field;)Ljava\/lang\/Object; flags 1 deprecated true runtimeAnnotations @Ljava\/lang\/Deprecated;(since=\"18\")@Ljdk\/internal\/vm\/annotation\/ForceInline;\n+\n+class name sun\/reflect\/ReflectionFactory\n+header extends java\/lang\/Object flags 21 classAnnotations @Lsun\/Proprietary+Annotation;\n+\n","filename":"make\/data\/symbols\/jdk.unsupported-I.sym.txt","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"","filename":"make\/data\/symbols\/jdk.xml.dom-I.sym.txt","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"make\/data\/symbols\/jdk.xml.dom-H.sym.txt","status":"copied"},{"patch":"@@ -32,1 +32,1 @@\n-generate platforms 7:8:9:A:B:C:D:E:F:G:H\n+generate platforms 7:8:9:A:B:C:D:E:F:G:H:I\n@@ -44,0 +44,1 @@\n+platform version I base H files java.base-I.sym.txt:java.compiler-I.sym.txt:java.datatransfer-I.sym.txt:java.desktop-I.sym.txt:java.instrument-I.sym.txt:java.logging-I.sym.txt:java.management-I.sym.txt:java.management.rmi-I.sym.txt:java.naming-I.sym.txt:java.net.http-I.sym.txt:java.rmi-I.sym.txt:java.scripting-I.sym.txt:java.security.jgss-I.sym.txt:java.security.sasl-I.sym.txt:java.smartcardio-I.sym.txt:java.sql-I.sym.txt:java.sql.rowset-I.sym.txt:java.xml-I.sym.txt:java.xml.crypto-I.sym.txt:jdk.accessibility-I.sym.txt:jdk.attach-I.sym.txt:jdk.compiler-I.sym.txt:jdk.dynalink-I.sym.txt:jdk.httpserver-I.sym.txt:jdk.incubator.foreign-I.sym.txt:jdk.incubator.vector-I.sym.txt:jdk.jartool-I.sym.txt:jdk.javadoc-I.sym.txt:jdk.jconsole-I.sym.txt:jdk.jdi-I.sym.txt:jdk.jlink-I.sym.txt:jdk.jshell-I.sym.txt:jdk.jsobject-I.sym.txt:jdk.management-I.sym.txt:jdk.management.jfr-I.sym.txt:jdk.net-I.sym.txt:jdk.sctp-I.sym.txt:jdk.security.auth-I.sym.txt:jdk.security.jgss-I.sym.txt:jdk.unsupported-I.sym.txt:jdk.xml.dom-I.sym.txt\n","filename":"make\/data\/symbols\/symbols","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -8568,1 +8568,1 @@\n-    __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);\n+    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n@@ -8571,1 +8571,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8593,1 +8593,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8611,1 +8611,1 @@\n-    __ mov($tmp$$FloatRegister, __ T1D, 0, $src$$Register);\n+    __ mov($tmp$$FloatRegister, __ D, 0, $src$$Register);\n@@ -8614,1 +8614,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n@@ -8636,1 +8636,1 @@\n-    __ mov($dst$$Register, $tmp$$FloatRegister, __ T1D, 0);\n+    __ mov($dst$$Register, $tmp$$FloatRegister, __ D, 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-            \"mov      $dst, T2S, 1, rscratch2\\t#convert 2D to 2I vector\"\n+            \"mov      $dst, S, 1, rscratch2\\t#convert 2D to 2I vector\"\n@@ -523,1 +523,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2S, 1, rscratch2);\n+    __ mov(as_FloatRegister($dst$$reg), __ S, 1, rscratch2);\n@@ -1706,1 +1706,1 @@\n-            \"mov    $dst, T8B, $idx, $val\\t# insert into vector(8B)\" %}\n+            \"mov    $dst, B, $idx, $val\\t# insert into vector(8B)\" %}\n@@ -1712,1 +1712,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T8B, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n@@ -1723,1 +1723,1 @@\n-            \"mov    $dst, T16B, $idx, $val\\t# insert into vector(16B)\" %}\n+            \"mov    $dst, B, $idx, $val\\t# insert into vector(16B)\" %}\n@@ -1729,1 +1729,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T16B, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ B, $idx$$constant, $val$$Register);\n@@ -1740,1 +1740,1 @@\n-            \"mov    $dst, T4H, $idx, $val\\t# insert into vector(4S)\" %}\n+            \"mov    $dst, H, $idx, $val\\t# insert into vector(4S)\" %}\n@@ -1746,1 +1746,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T4H, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n@@ -1757,1 +1757,1 @@\n-            \"mov    $dst, T8H, $idx, $val\\t# insert into vector(8S)\" %}\n+            \"mov    $dst, H, $idx, $val\\t# insert into vector(8S)\" %}\n@@ -1763,1 +1763,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T8H, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ H, $idx$$constant, $val$$Register);\n@@ -1774,1 +1774,1 @@\n-            \"mov    $dst, T2S, $idx, $val\\t# insert into vector(2I)\" %}\n+            \"mov    $dst, S, $idx, $val\\t# insert into vector(2I)\" %}\n@@ -1780,1 +1780,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n@@ -1791,1 +1791,1 @@\n-            \"mov    $dst, T4S, $idx, $val\\t# insert into vector(4I)\" %}\n+            \"mov    $dst, S, $idx, $val\\t# insert into vector(4I)\" %}\n@@ -1797,1 +1797,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T4S, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ S, $idx$$constant, $val$$Register);\n@@ -1808,1 +1808,1 @@\n-            \"mov    $dst, T2D, $idx, $val\\t# insert into vector(2L)\" %}\n+            \"mov    $dst, D, $idx, $val\\t# insert into vector(2L)\" %}\n@@ -1814,1 +1814,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D, $idx$$constant, $val$$Register);\n@@ -2047,1 +2047,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, 0, $tmp2$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D, 0, $tmp2$$Register);\n@@ -2051,1 +2051,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, 1, $tmp2$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D, 1, $tmp2$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon.ad","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -299,1 +299,1 @@\n-            \"mov      $dst, T2S, 1, rscratch2\\t#convert 2D to 2I vector\"\n+            \"mov      $dst, S, 1, rscratch2\\t#convert 2D to 2I vector\"\n@@ -308,1 +308,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2S, 1, rscratch2);\n+    __ mov(as_FloatRegister($dst$$reg), __ S, 1, rscratch2);\n@@ -871,1 +871,1 @@\n-            \"mov    $dst, T$1`'iTYPE2SIMD($2), $idx, $val\\t# insert into vector($1$2)\" %}\n+            \"mov    $dst, iTYPE2SIMD($2), $idx, $val\\t# insert into vector($1$2)\" %}\n@@ -877,1 +877,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T$1`'iTYPE2SIMD($2), $idx$$constant, $val$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ iTYPE2SIMD($2), $idx$$constant, $val$$Register);\n@@ -1006,1 +1006,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, 0, $tmp2$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D, 0, $tmp2$$Register);\n@@ -1010,1 +1010,1 @@\n-    __ mov(as_FloatRegister($dst$$reg), __ T2D, 1, $tmp2$$Register);\n+    __ mov(as_FloatRegister($dst$$reg), __ D, 1, $tmp2$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_neon_ad.m4","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2759,1 +2759,2 @@\n-  void mov(FloatRegister Vd, SIMD_Arrangement T, int index, Register Xn) {\n+  void mov(FloatRegister Vd, SIMD_RegVariant T, int index, Register Xn) {\n+    guarantee(T != Q, \"invalid register variant\");\n@@ -2761,1 +2762,1 @@\n-    f(0b01001110000, 31, 21), f(((1 << (T >> 1)) | (index << ((T >> 1) + 1))), 20, 16);\n+    f(0b01001110000, 31, 21), f(((1 << T) | (index << (T + 1))), 20, 16);\n@@ -2767,6 +2768,3 @@\n-  void mov(Register Xd, FloatRegister Vn, SIMD_Arrangement T, int index) {\n-    guarantee(T >= T2S && T < T1Q, \"only D and S arrangements are supported\");\n-    starti;\n-    f(0, 31), f((T >= T1D) ? 1:0, 30), f(0b001110000, 29, 21);\n-    f(((1 << (T >> 1)) | (index << ((T >> 1) + 1))), 20, 16);\n-    f(0b001111, 15, 10), rf(Vn, 5), rf(Xd, 0);\n+  void mov(Register Xd, FloatRegister Vn, SIMD_RegVariant T, int index) {\n+    guarantee(T == S || T == D, \"invalid register variant\");\n+    umov(Xd, Vn, T, index);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -307,1 +307,1 @@\n-void C1_MacroAssembler::verified_entry() {\n+void C1_MacroAssembler::verified_entry(bool breakAtEntry) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3370,1 +3370,1 @@\n-      mov(v16, T4S, 0, crc);\n+      mov(v16, S, 0, crc);\n@@ -3474,1 +3474,1 @@\n-      mov(tmp, v0, T1D, 0);\n+      mov(tmp, v0, D, 0);\n@@ -3477,1 +3477,1 @@\n-      mov(tmp, v0, T1D, 1);\n+      mov(tmp, v0, D, 1);\n@@ -3480,1 +3480,1 @@\n-      mov(tmp, v1, T1D, 0);\n+      mov(tmp, v1, D, 0);\n@@ -3483,1 +3483,1 @@\n-      mov(tmp, v1, T1D, 1);\n+      mov(tmp, v1, D, 1);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -6396,0 +6396,12 @@\n+  \/\/ Support for spin waits.\n+  address generate_spin_wait() {\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"spin_wait\");\n+    address start = __ pc();\n+\n+    __ spin_wait();\n+    __ ret(lr);\n+\n+    return start;\n+  }\n+\n@@ -7714,0 +7726,2 @@\n+    StubRoutines::aarch64::_spin_wait = generate_spin_wait();\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -60,0 +60,4 @@\n+\n+static void empty_spin_wait() { }\n+address StubRoutines::aarch64::_spin_wait = CAST_FROM_FN_PTR(address, empty_spin_wait);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+  static address _spin_wait;\n+\n@@ -180,0 +182,4 @@\n+  static address spin_wait() {\n+    return _spin_wait;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -491,0 +491,19 @@\n+\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n+\n+  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n+  get_compatible_board(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len);\n+  desc_len = (int)strlen(_cpu_desc);\n+  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _features_string);\n+\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -156,0 +156,3 @@\n+\n+  static void initialize_cpu_information(void);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"vm_version_ext_aarch64.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_sockets = 0;\n-bool VM_Version_Ext::_initialized = false;\n-char VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  int core_id = -1;\n-  int chip_id = -1;\n-  int len = 0;\n-  char* src_string = NULL;\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"AArch64\");\n-\n-  int desc_len = snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"AArch64 \");\n-  VM_Version::get_compatible_board(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len);\n-  desc_len = (int)strlen(_cpu_desc);\n-  snprintf(_cpu_desc + desc_len, CPU_DETAILED_DESC_BUF_SIZE - desc_len, \" %s\", _features_string);\n-\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_ext_aarch64.cpp","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_AARCH64_VM_VERSION_EXT_AARCH64_HPP\n-#define CPU_AARCH64_VM_VERSION_EXT_AARCH64_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n- public:\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-  static void initialize_cpu_information(void);\n-\n-};\n-\n-#endif \/\/ CPU_AARCH64_VM_VERSION_EXT_AARCH64_HPP\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_ext_aarch64.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -49,1 +49,1 @@\n-  RelocationHolder rspec;\n+  RelocationHolder rspec = RelocationHolder::none;\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm_32.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,2 +72,2 @@\n-void C1_MacroAssembler::verified_entry() {\n-  if (C1Breakpoint) {\n+void C1_MacroAssembler::verified_entry(bool breakAtEntry) {\n+  if (breakAtEntry) {\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -350,0 +350,14 @@\n+\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_arm_32.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"vm_version_ext_arm.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_sockets = 0;\n-bool VM_Version_Ext::_initialized = false;\n-char VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  int core_id = -1;\n-  int chip_id = -1;\n-  int len = 0;\n-  char* src_string = NULL;\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"ARM%d\", _arm_arch);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_ext_arm.cpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ARM_VM_VERSION_EXT_ARM_HPP\n-#define CPU_ARM_VM_VERSION_EXT_ARM_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n- public:\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-  static void initialize_cpu_information(void);\n-\n-};\n-\n-#endif \/\/ CPU_ARM_VM_VERSION_EXT_ARM_HPP\n","filename":"src\/hotspot\/cpu\/arm\/vm_version_ext_arm.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -945,1 +945,2 @@\n-        __ lis(R0, oop_addr.value() >> 16); \/\/ Don't care about sign extend (will use stw).\n+        \/\/ Don't care about sign extend (will use stw).\n+        __ lis(R0, 0); \/\/ Will get patched.\n@@ -947,1 +948,1 @@\n-        __ ori(R0, R0, oop_addr.value() & 0xffff);\n+        __ ori(R0, R0, 0); \/\/ Will get patched.\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-void C1_MacroAssembler::verified_entry() {\n-  if (C1Breakpoint) illtrap();\n+void C1_MacroAssembler::verified_entry(bool breakAtEntry) {\n+  if (breakAtEntry) illtrap();\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-\/\/ Get compressed oop or klass constant.\n+\/\/ Get compressed oop constant.\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -260,1 +260,1 @@\n-  \/\/ Patch narrow oop constants. Use this also for narrow klass.\n+  \/\/ Patch narrow oop constants.\n","filename":"src\/hotspot\/cpu\/ppc\/nativeInst_ppc.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5956,1 +5956,1 @@\n-    __ lis($dst$$Register, (int)(short)(($src$$constant >> 16) & 0xffff));\n+    __ lis($dst$$Register, 0); \/\/ Will get patched.\n@@ -5969,5 +5969,3 @@\n-    assert(__ oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n-    int oop_index = __ oop_recorder()->find_index((jobject)$src2$$constant);\n-    RelocationHolder rspec = oop_Relocation::spec(oop_index);\n-    __ relocate(rspec, 1);\n-    __ ori($dst$$Register, $src1$$Register, $src2$$constant & 0xffff);\n+    AddressLiteral addrlit = __ constant_oop_address((jobject)$src2$$constant);\n+    __ relocate(addrlit.rspec(), \/*compressed format*\/ 1);\n+    __ ori($dst$$Register, $src1$$Register, 0); \/\/ Will get patched.\n@@ -6088,6 +6086,3 @@\n-    intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);\n-    assert(__ oop_recorder() != NULL, \"this assembler needs an OopRecorder\");\n-    int klass_index = __ oop_recorder()->find_index((Klass *)$src1$$constant);\n-    RelocationHolder rspec = metadata_Relocation::spec(klass_index);\n-\n-    __ relocate(rspec, 1);\n+    \/\/ Notify OOP recorder (don't need the relocation)\n+    AddressLiteral md = __ constant_metadata_address((Klass*)$src1$$constant);\n+    intptr_t Csrc = CompressedKlassPointers::encode((Klass*)md.value());\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":7,"deletions":12,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -36,16 +36,1 @@\n-  \/\/ The following comment is from the declaration of DataRelocation:\n-  \/\/\n-  \/\/  \"The \"o\" (displacement) argument is relevant only to split relocations\n-  \/\/   on RISC machines.  In some CPUs (SPARC), the set-hi and set-lo ins'ns\n-  \/\/   can encode more than 32 bits between them.  This allows compilers to\n-  \/\/   share set-hi instructions between addresses that differ by a small\n-  \/\/   offset (e.g., different static variables in the same class).\n-  \/\/   On such machines, the \"x\" argument to set_value on all set-lo\n-  \/\/   instructions must be the same as the \"x\" argument for the\n-  \/\/   corresponding set-hi instructions.  The \"o\" arguments for the\n-  \/\/   set-hi instructions are ignored, and must not affect the high-half\n-  \/\/   immediate constant.  The \"o\" arguments for the set-lo instructions are\n-  \/\/   added into the low-half immediate constant, and must not overflow it.\"\n-  \/\/\n-  \/\/ Currently we don't support splitting of relocations, so o must be\n-  \/\/ zero:\n+  \/\/ Currently we don't support splitting of relocations.\n@@ -58,6 +43,2 @@\n-      assert(type() == relocInfo::oop_type || type() == relocInfo::metadata_type,\n-             \"how to encode else?\");\n-      narrowOop no = (type() == relocInfo::oop_type) ?\n-          CompressedOops::encode(cast_to_oop(x)) :\n-          \/\/ Type punning compressed klass pointer as narrowOop.\n-          CompressedOops::narrow_oop_cast(CompressedKlassPointers::encode((Klass*)x));\n+      assert(type() == relocInfo::oop_type, \"how to encode else?\");\n+      narrowOop no = CompressedOops::encode(cast_to_oop(x));\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jvm.h\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/vm_version.hpp\"\n-#include \"vm_version_ext_ppc.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int   VM_Version_Ext::_no_of_threads = 0;\n-int   VM_Version_Ext::_no_of_cores = 0;\n-int   VM_Version_Ext::_no_of_sockets = 0;\n-bool  VM_Version_Ext::_initialized = false;\n-char  VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char  VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-\/\/ get cpu information.\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", features_string());\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ext_ppc.cpp","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_PPC_VM_VERSION_EXT_PPC_HPP\n-#define CPU_PPC_VM_VERSION_EXT_PPC_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#define CPU_INFO        \"cpu_info\"\n-#define CPU_TYPE        \"fpu_type\"\n-#define CPU_DESCRIPTION \"implementation\"\n-#define CHIP_ID         \"chip_id\"\n-#define CORE_ID         \"core_id\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n-  static void initialize_cpu_information(void);\n-\n- public:\n-\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-};\n-\n-#endif \/\/ CPU_PPC_VM_VERSION_EXT_PPC_HPP\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ext_ppc.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -770,0 +770,15 @@\n+\n+\/\/ get cpu information.\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"PowerPC POWER%lu\", PowerArchitecturePPC64);\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"PPC %s\", features_string());\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -131,0 +131,2 @@\n+\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/ppc\/vm_version_ppc.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,2 +76,2 @@\n-void C1_MacroAssembler::verified_entry() {\n-  if (C1Breakpoint) z_illtrap(0xC1);\n+void C1_MacroAssembler::verified_entry(bool breakAtEntry) {\n+  if (breakAtEntry) z_illtrap(0xC1);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"jvm.h\"\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"vm_version_ext_s390.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int   VM_Version_Ext::_no_of_threads = 0;\n-int   VM_Version_Ext::_no_of_cores = 0;\n-int   VM_Version_Ext::_no_of_sockets = 0;\n-bool  VM_Version_Ext::_initialized = false;\n-char  VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char  VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-\/\/ get cpu information.\n-void  VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", features_string());\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_ext_s390.cpp","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,62 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_S390_VM_VERSION_EXT_S390_HPP\n-#define CPU_S390_VM_VERSION_EXT_S390_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-#define CPU_INFO        \"cpu_info\"\n-#define CPU_TYPE        \"fpu_type\"\n-#define CPU_DESCRIPTION \"implementation\"\n-#define CHIP_ID         \"chip_id\"\n-#define CORE_ID         \"core_id\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n-  static void initialize_cpu_information(void);\n-\n- public:\n-\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-};\n-\n-#endif \/\/ CPU_S390_VM_VERSION_EXT_S390_HPP\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_ext_s390.hpp","additions":0,"deletions":62,"binary":false,"changes":62,"status":"deleted"},{"patch":"@@ -1493,0 +1493,16 @@\n+\n+\n+\/\/ get cpu information.\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE, \"s390 %s\", VM_Version::get_model_string());\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"s390 %s\", features_string());\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -536,0 +536,2 @@\n+\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/s390\/vm_version_s390.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-  RelocationHolder rspec;\n+  RelocationHolder rspec = RelocationHolder::none;\n@@ -11104,0 +11104,4 @@\n+\/\/ Register is a class, but it would be assigned numerical value.\n+\/\/ \"0\" is assigned for xmm0. Thus we need to ignore -Wnonnull.\n+PRAGMA_DIAG_PUSH\n+PRAGMA_NONNULL_IGNORED\n@@ -11127,0 +11131,1 @@\n+PRAGMA_DIAG_POP\n@@ -11295,0 +11300,14 @@\n+void Assembler::pext(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F3, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n+void Assembler::pdep(Register dst, Register src1, Register src2) {\n+  assert(VM_Version::supports_bmi2(), \"bit manipulation instructions not supported\");\n+  InstructionAttr attributes(AVX_128bit, \/* vex_w *\/ true, \/* legacy_mode *\/ true, \/* no_mask_reg *\/ true, \/* uses_vl *\/ false);\n+  int encode = vex_prefix_and_encode(dst->encoding(), src1->encoding(), src2->encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &attributes);\n+  emit_int16((unsigned char)0xF5, (0xC0 | encode));\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2187,0 +2187,3 @@\n+  void pdep(Register dst, Register src1, Register src2);\n+  void pext(Register dst, Register src1, Register src2);\n+\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -334,2 +334,2 @@\n-void C1_MacroAssembler::verified_entry() {\n-  if (C1Breakpoint || VerifyFPU) {\n+void C1_MacroAssembler::verified_entry(bool breakAtEntry) {\n+  if (breakAtEntry || VerifyFPU) {\n@@ -339,1 +339,1 @@\n-    \/\/ C1Breakpoint and VerifyFPU have one byte first instruction.\n+    \/\/ Breakpoint and VerifyFPU have one byte first instruction.\n@@ -345,1 +345,1 @@\n-  if (C1Breakpoint)int3();\n+  if (breakAtEntry) int3();\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -4156,0 +4156,39 @@\n+void C2_MacroAssembler::vector_long_to_maskvec(XMMRegister dst, Register src, Register rtmp1,\n+                                               Register rtmp2, XMMRegister xtmp, int mask_len,\n+                                               int vec_enc) {\n+  int index = 0;\n+  int vindex = 0;\n+  mov64(rtmp1, 0x0101010101010101L);\n+  pdep(rtmp1, src, rtmp1);\n+  if (mask_len > 8) {\n+    movq(rtmp2, src);\n+    vpxor(xtmp, xtmp, xtmp, vec_enc);\n+    movq(xtmp, rtmp1);\n+  }\n+  movq(dst, rtmp1);\n+\n+  mask_len -= 8;\n+  while (mask_len > 0) {\n+    assert ((mask_len & 0x7) == 0, \"mask must be multiple of 8\");\n+    index++;\n+    if ((index % 2) == 0) {\n+      pxor(xtmp, xtmp);\n+    }\n+    mov64(rtmp1, 0x0101010101010101L);\n+    shrq(rtmp2, 8);\n+    pdep(rtmp1, rtmp2, rtmp1);\n+    pinsrq(xtmp, rtmp1, index % 2);\n+    vindex = index \/ 2;\n+    if (vindex) {\n+      \/\/ Write entire 16 byte vector when both 64 bit\n+      \/\/ lanes are update to save redundant instructions.\n+      if (index % 2) {\n+        vinsertf128(dst, dst, xtmp, vindex);\n+      }\n+    } else {\n+      vmovdqu(dst, xtmp);\n+    }\n+    mask_len -= 8;\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":39,"deletions":0,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -233,0 +233,2 @@\n+  void vector_long_to_maskvec(XMMRegister dst, Register src, Register rtmp1,\n+                              Register rtmp2, XMMRegister xtmp, int mask_len, int vec_enc);\n@@ -234,0 +236,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong_narrow), arg0, arg1);\n+      __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong_narrow), arg0, arg1);\n@@ -425,1 +425,1 @@\n-      __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong), arg0, arg1);\n+      __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_strong), arg0, arg1);\n@@ -436,1 +436,1 @@\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom), arg0, arg1);\n+    __ super_call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::load_reference_barrier_phantom), arg0, arg1);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shenandoah\/shenandoahBarrierSetAssembler_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-#include \"vm_version_ext_x86.hpp\"\n+#include \"vm_version_x86.hpp\"\n@@ -104,1 +104,1 @@\n-  if (VM_Version_Ext::supports_tscinv_ext()) {\n+  if (VM_Version::supports_tscinv_ext()) {\n@@ -106,1 +106,1 @@\n-    tsc_freq = (double)VM_Version_Ext::maximum_qualified_cpu_frequency();\n+    tsc_freq = (double)VM_Version::maximum_qualified_cpu_frequency();\n@@ -174,1 +174,1 @@\n-  return VM_Version_Ext::supports_tscinv_ext();\n+  return VM_Version::supports_tscinv_ext();\n@@ -201,1 +201,1 @@\n-    VM_Version_Ext::initialize();\n+    VM_Version::initialize_tsc();\n","filename":"src\/hotspot\/cpu\/x86\/rdtsc_x86.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -448,0 +448,15 @@\n+address TemplateInterpreterGenerator::generate_currentThread() {\n+\n+  address entry_point = __ pc();\n+\n+  __ movptr(rax, Address(r15_thread, JavaThread::threadObj_offset()));\n+\n+  __ resolve_oop_handle(rax, rscratch1);\n+\n+  __ pop(rcx);\n+  __ mov(rsp, r13);\n+  __ jmp(rcx);\n+\n+  return entry_point;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86_64.cpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,982 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"jvm.h\"\n-#include \"utilities\/macros.hpp\"\n-#include \"asm\/macroAssembler.hpp\"\n-#include \"asm\/macroAssembler.inline.hpp\"\n-#include \"code\/codeBlob.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"runtime\/java.hpp\"\n-#include \"runtime\/stubCodeGenerator.hpp\"\n-#include \"vm_version_ext_x86.hpp\"\n-\n-typedef enum {\n-   CPU_FAMILY_8086_8088  = 0,\n-   CPU_FAMILY_INTEL_286  = 2,\n-   CPU_FAMILY_INTEL_386  = 3,\n-   CPU_FAMILY_INTEL_486  = 4,\n-   CPU_FAMILY_PENTIUM    = 5,\n-   CPU_FAMILY_PENTIUMPRO = 6,    \/\/ Same family several models\n-   CPU_FAMILY_PENTIUM_4  = 0xF\n-} FamilyFlag;\n-\n-typedef enum {\n-  RDTSCP_FLAG  = 0x08000000, \/\/ bit 27\n-  INTEL64_FLAG = 0x20000000  \/\/ bit 29\n-} _featureExtendedEdxFlag;\n-\n-#define CPUID_STANDARD_FN   0x0\n-#define CPUID_STANDARD_FN_1 0x1\n-#define CPUID_STANDARD_FN_4 0x4\n-#define CPUID_STANDARD_FN_B 0xb\n-\n-#define CPUID_EXTENDED_FN   0x80000000\n-#define CPUID_EXTENDED_FN_1 0x80000001\n-#define CPUID_EXTENDED_FN_2 0x80000002\n-#define CPUID_EXTENDED_FN_3 0x80000003\n-#define CPUID_EXTENDED_FN_4 0x80000004\n-#define CPUID_EXTENDED_FN_7 0x80000007\n-#define CPUID_EXTENDED_FN_8 0x80000008\n-\n-typedef enum {\n-   FPU_FLAG     = 0x00000001,\n-   VME_FLAG     = 0x00000002,\n-   DE_FLAG      = 0x00000004,\n-   PSE_FLAG     = 0x00000008,\n-   TSC_FLAG     = 0x00000010,\n-   MSR_FLAG     = 0x00000020,\n-   PAE_FLAG     = 0x00000040,\n-   MCE_FLAG     = 0x00000080,\n-   CX8_FLAG     = 0x00000100,\n-   APIC_FLAG    = 0x00000200,\n-   SEP_FLAG     = 0x00000800,\n-   MTRR_FLAG    = 0x00001000,\n-   PGE_FLAG     = 0x00002000,\n-   MCA_FLAG     = 0x00004000,\n-   CMOV_FLAG    = 0x00008000,\n-   PAT_FLAG     = 0x00010000,\n-   PSE36_FLAG   = 0x00020000,\n-   PSNUM_FLAG   = 0x00040000,\n-   CLFLUSH_FLAG = 0x00080000,\n-   DTS_FLAG     = 0x00200000,\n-   ACPI_FLAG    = 0x00400000,\n-   MMX_FLAG     = 0x00800000,\n-   FXSR_FLAG    = 0x01000000,\n-   SSE_FLAG     = 0x02000000,\n-   SSE2_FLAG    = 0x04000000,\n-   SS_FLAG      = 0x08000000,\n-   HTT_FLAG     = 0x10000000,\n-   TM_FLAG      = 0x20000000\n-} FeatureEdxFlag;\n-\n-static BufferBlob* cpuid_brand_string_stub_blob;\n-static const int   cpuid_brand_string_stub_size = 550;\n-\n-extern \"C\" {\n-  typedef void (*getCPUIDBrandString_stub_t)(void*);\n-}\n-\n-static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;\n-\n-class VM_Version_Ext_StubGenerator: public StubCodeGenerator {\n- public:\n-\n-  VM_Version_Ext_StubGenerator(CodeBuffer *c) : StubCodeGenerator(c) {}\n-\n-  address generate_getCPUIDBrandString(void) {\n-    \/\/ Flags to test CPU type.\n-    const uint32_t HS_EFL_AC           = 0x40000;\n-    const uint32_t HS_EFL_ID           = 0x200000;\n-    \/\/ Values for when we don't have a CPUID instruction.\n-    const int      CPU_FAMILY_SHIFT = 8;\n-    const uint32_t CPU_FAMILY_386   = (3 << CPU_FAMILY_SHIFT);\n-    const uint32_t CPU_FAMILY_486   = (4 << CPU_FAMILY_SHIFT);\n-\n-    Label detect_486, cpu486, detect_586, done, ext_cpuid;\n-\n-    StubCodeMark mark(this, \"VM_Version_Ext\", \"getCPUIDNameInfo_stub\");\n-#   define __ _masm->\n-\n-    address start = __ pc();\n-\n-    \/\/\n-    \/\/ void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);\n-    \/\/\n-    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n-\n-    __ push(rbp);\n-#ifdef _LP64\n-    __ mov(rbp, c_rarg0); \/\/ cpuid_info address\n-#else\n-    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n-#endif\n-    __ push(rbx);\n-    __ push(rsi);\n-    __ pushf();          \/\/ preserve rbx, and flags\n-    __ pop(rax);\n-    __ push(rax);\n-    __ mov(rcx, rax);\n-    \/\/\n-    \/\/ if we are unable to change the AC flag, we have a 386\n-    \/\/\n-    __ xorl(rax, HS_EFL_AC);\n-    __ push(rax);\n-    __ popf();\n-    __ pushf();\n-    __ pop(rax);\n-    __ cmpptr(rax, rcx);\n-    __ jccb(Assembler::notEqual, detect_486);\n-\n-    __ movl(rax, CPU_FAMILY_386);\n-    __ jmp(done);\n-\n-    \/\/\n-    \/\/ If we are unable to change the ID flag, we have a 486 which does\n-    \/\/ not support the \"cpuid\" instruction.\n-    \/\/\n-    __ bind(detect_486);\n-    __ mov(rax, rcx);\n-    __ xorl(rax, HS_EFL_ID);\n-    __ push(rax);\n-    __ popf();\n-    __ pushf();\n-    __ pop(rax);\n-    __ cmpptr(rcx, rax);\n-    __ jccb(Assembler::notEqual, detect_586);\n-\n-    __ bind(cpu486);\n-    __ movl(rax, CPU_FAMILY_486);\n-    __ jmp(done);\n-\n-    \/\/\n-    \/\/ At this point, we have a chip which supports the \"cpuid\" instruction\n-    \/\/\n-    __ bind(detect_586);\n-    __ xorl(rax, rax);\n-    __ cpuid();\n-    __ orl(rax, rax);\n-    __ jcc(Assembler::equal, cpu486);   \/\/ if cpuid doesn't support an input\n-                                        \/\/ value of at least 1, we give up and\n-                                        \/\/ assume a 486\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000000) for processor brand string detection\n-    \/\/\n-    __ bind(ext_cpuid);\n-    __ movl(rax, CPUID_EXTENDED_FN);\n-    __ cpuid();\n-    __ cmpl(rax, CPUID_EXTENDED_FN_4);\n-    __ jcc(Assembler::below, done);\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000002)  \/\/ first 16 bytes in brand string\n-    \/\/\n-    __ movl(rax, CPUID_EXTENDED_FN_2);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_0_offset())));\n-    __ movl(Address(rsi, 0), rax);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_1_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_2_offset())));\n-    __ movl(Address(rsi, 0), rcx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_3_offset())));\n-    __ movl(Address(rsi,0), rdx);\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000003) \/\/ next 16 bytes in brand string\n-    \/\/\n-    __ movl(rax, CPUID_EXTENDED_FN_3);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_4_offset())));\n-    __ movl(Address(rsi, 0), rax);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_5_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_6_offset())));\n-    __ movl(Address(rsi, 0), rcx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_7_offset())));\n-    __ movl(Address(rsi,0), rdx);\n-\n-    \/\/\n-    \/\/ Extended cpuid(0x80000004) \/\/ last 16 bytes in brand string\n-    \/\/\n-    __ movl(rax, CPUID_EXTENDED_FN_4);\n-    __ cpuid();\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_8_offset())));\n-    __ movl(Address(rsi, 0), rax);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_9_offset())));\n-    __ movl(Address(rsi, 0), rbx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_10_offset())));\n-    __ movl(Address(rsi, 0), rcx);\n-    __ lea(rsi, Address(rbp, in_bytes(VM_Version_Ext::proc_name_11_offset())));\n-    __ movl(Address(rsi,0), rdx);\n-\n-    \/\/\n-    \/\/ return\n-    \/\/\n-    __ bind(done);\n-    __ popf();\n-    __ pop(rsi);\n-    __ pop(rbx);\n-    __ pop(rbp);\n-    __ ret(0);\n-\n-#   undef __\n-\n-    return start;\n-  };\n-};\n-\n-\n-\/\/ VM_Version_Ext statics\n-const size_t VM_Version_Ext::VENDOR_LENGTH = 13;\n-const size_t VM_Version_Ext::CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);\n-const size_t VM_Version_Ext::CPU_TYPE_DESC_BUF_SIZE = 256;\n-const size_t VM_Version_Ext::CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-char* VM_Version_Ext::_cpu_brand_string = NULL;\n-int64_t VM_Version_Ext::_max_qualified_cpu_frequency = 0;\n-\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_packages = 0;\n-\n-void VM_Version_Ext::initialize(void) {\n-  ResourceMark rm;\n-\n-  cpuid_brand_string_stub_blob = BufferBlob::create(\"getCPUIDBrandString_stub\", cpuid_brand_string_stub_size);\n-  if (cpuid_brand_string_stub_blob == NULL) {\n-    vm_exit_during_initialization(\"Unable to allocate getCPUIDBrandString_stub\");\n-  }\n-  CodeBuffer c(cpuid_brand_string_stub_blob);\n-  VM_Version_Ext_StubGenerator g(&c);\n-  getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,\n-                                   g.generate_getCPUIDBrandString());\n-}\n-\n-const char* VM_Version_Ext::cpu_model_description(void) {\n-  uint32_t cpu_family = extended_cpu_family();\n-  uint32_t cpu_model = extended_cpu_model();\n-  const char* model = NULL;\n-\n-  if (cpu_family == CPU_FAMILY_PENTIUMPRO) {\n-    for (uint32_t i = 0; i <= cpu_model; i++) {\n-      model = _model_id_pentium_pro[i];\n-      if (model == NULL) {\n-        break;\n-      }\n-    }\n-  }\n-  return model;\n-}\n-\n-const char* VM_Version_Ext::cpu_brand_string(void) {\n-  if (_cpu_brand_string == NULL) {\n-    _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);\n-    if (NULL == _cpu_brand_string) {\n-      return NULL;\n-    }\n-    int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);\n-    if (ret_val != OS_OK) {\n-      FREE_C_HEAP_ARRAY(char, _cpu_brand_string);\n-      _cpu_brand_string = NULL;\n-    }\n-  }\n-  return _cpu_brand_string;\n-}\n-\n-const char* VM_Version_Ext::cpu_brand(void) {\n-  const char*  brand  = NULL;\n-\n-  if ((_cpuid_info.std_cpuid1_ebx.value & 0xFF) > 0) {\n-    int brand_num = _cpuid_info.std_cpuid1_ebx.value & 0xFF;\n-    brand = _brand_id[0];\n-    for (int i = 0; brand != NULL && i <= brand_num; i += 1) {\n-      brand = _brand_id[i];\n-    }\n-  }\n-  return brand;\n-}\n-\n-bool VM_Version_Ext::cpu_is_em64t(void) {\n-  return ((_cpuid_info.ext_cpuid1_edx.value & INTEL64_FLAG) == INTEL64_FLAG);\n-}\n-\n-bool VM_Version_Ext::is_netburst(void) {\n-  return (is_intel() && (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));\n-}\n-\n-bool VM_Version_Ext::supports_tscinv_ext(void) {\n-  if (!supports_tscinv_bit()) {\n-    return false;\n-  }\n-\n-  if (is_intel()) {\n-    return true;\n-  }\n-\n-  if (is_amd()) {\n-    return !is_amd_Barcelona();\n-  }\n-\n-  if (is_hygon()) {\n-    return true;\n-  }\n-\n-  return false;\n-}\n-\n-void VM_Version_Ext::resolve_cpu_information_details(void) {\n-\n-  \/\/ in future we want to base this information on proper cpu\n-  \/\/ and cache topology enumeration such as:\n-  \/\/ Intel 64 Architecture Processor Topology Enumeration\n-  \/\/ which supports system cpu and cache topology enumeration\n-  \/\/ either using 2xAPICIDs or initial APICIDs\n-\n-  \/\/ currently only rough cpu information estimates\n-  \/\/ which will not necessarily reflect the exact configuration of the system\n-\n-  \/\/ this is the number of logical hardware threads\n-  \/\/ visible to the operating system\n-  _no_of_threads = os::processor_count();\n-\n-  \/\/ find out number of threads per cpu package\n-  int threads_per_package = threads_per_core() * cores_per_cpu();\n-\n-  \/\/ use amount of threads visible to the process in order to guess number of sockets\n-  _no_of_packages = _no_of_threads \/ threads_per_package;\n-\n-  \/\/ process might only see a subset of the total number of threads\n-  \/\/ from a single processor package. Virtualization\/resource management for example.\n-  \/\/ If so then just write a hard 1 as num of pkgs.\n-  if (0 == _no_of_packages) {\n-    _no_of_packages = 1;\n-  }\n-\n-  \/\/ estimate the number of cores\n-  _no_of_cores = cores_per_cpu() * _no_of_packages;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  if (_no_of_threads == 0) {\n-   resolve_cpu_information_details();\n-  }\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  if (_no_of_cores == 0) {\n-    resolve_cpu_information_details();\n-  }\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  if (_no_of_packages == 0) {\n-    resolve_cpu_information_details();\n-  }\n-  return _no_of_packages;\n-}\n-\n-const char* VM_Version_Ext::cpu_family_description(void) {\n-  int cpu_family_id = extended_cpu_family();\n-  if (is_amd()) {\n-    if (cpu_family_id < ExtendedFamilyIdLength_AMD) {\n-      return _family_id_amd[cpu_family_id];\n-    }\n-  }\n-  if (is_intel()) {\n-    if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {\n-      return cpu_model_description();\n-    }\n-    if (cpu_family_id < ExtendedFamilyIdLength_INTEL) {\n-      return _family_id_intel[cpu_family_id];\n-    }\n-  }\n-  if (is_hygon()) {\n-    return \"Dhyana\";\n-  }\n-  return \"Unknown x86\";\n-}\n-\n-int VM_Version_Ext::cpu_type_description(char* const buf, size_t buf_len) {\n-  assert(buf != NULL, \"buffer is NULL!\");\n-  assert(buf_len >= CPU_TYPE_DESC_BUF_SIZE, \"buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!\");\n-\n-  const char* cpu_type = NULL;\n-  const char* x64 = NULL;\n-\n-  if (is_intel()) {\n-    cpu_type = \"Intel\";\n-    x64 = cpu_is_em64t() ? \" Intel64\" : \"\";\n-  } else if (is_amd()) {\n-    cpu_type = \"AMD\";\n-    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n-  } else if (is_hygon()) {\n-    cpu_type = \"Hygon\";\n-    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n-  } else {\n-    cpu_type = \"Unknown x86\";\n-    x64 = cpu_is_em64t() ? \" x86_64\" : \"\";\n-  }\n-\n-  jio_snprintf(buf, buf_len, \"%s %s%s SSE SSE2%s%s%s%s%s%s%s%s\",\n-    cpu_type,\n-    cpu_family_description(),\n-    supports_ht() ? \" (HT)\" : \"\",\n-    supports_sse3() ? \" SSE3\" : \"\",\n-    supports_ssse3() ? \" SSSE3\" : \"\",\n-    supports_sse4_1() ? \" SSE4.1\" : \"\",\n-    supports_sse4_2() ? \" SSE4.2\" : \"\",\n-    supports_sse4a() ? \" SSE4A\" : \"\",\n-    is_netburst() ? \" Netburst\" : \"\",\n-    is_intel_family_core() ? \" Core\" : \"\",\n-    x64);\n-\n-  return OS_OK;\n-}\n-\n-int VM_Version_Ext::cpu_extended_brand_string(char* const buf, size_t buf_len) {\n-  assert(buf != NULL, \"buffer is NULL!\");\n-  assert(buf_len >= CPU_EBS_MAX_LENGTH, \"buffer len should at least be == CPU_EBS_MAX_LENGTH!\");\n-  assert(getCPUIDBrandString_stub != NULL, \"not initialized\");\n-\n-  \/\/ invoke newly generated asm code to fetch CPU Brand String\n-  getCPUIDBrandString_stub(&_cpuid_info);\n-\n-  \/\/ fetch results into buffer\n-  *((uint32_t*) &buf[0])  = _cpuid_info.proc_name_0;\n-  *((uint32_t*) &buf[4])  = _cpuid_info.proc_name_1;\n-  *((uint32_t*) &buf[8])  = _cpuid_info.proc_name_2;\n-  *((uint32_t*) &buf[12]) = _cpuid_info.proc_name_3;\n-  *((uint32_t*) &buf[16]) = _cpuid_info.proc_name_4;\n-  *((uint32_t*) &buf[20]) = _cpuid_info.proc_name_5;\n-  *((uint32_t*) &buf[24]) = _cpuid_info.proc_name_6;\n-  *((uint32_t*) &buf[28]) = _cpuid_info.proc_name_7;\n-  *((uint32_t*) &buf[32]) = _cpuid_info.proc_name_8;\n-  *((uint32_t*) &buf[36]) = _cpuid_info.proc_name_9;\n-  *((uint32_t*) &buf[40]) = _cpuid_info.proc_name_10;\n-  *((uint32_t*) &buf[44]) = _cpuid_info.proc_name_11;\n-\n-  return OS_OK;\n-}\n-\n-size_t VM_Version_Ext::cpu_write_support_string(char* const buf, size_t buf_len) {\n-  guarantee(buf != NULL, \"buffer is NULL!\");\n-  guarantee(buf_len > 0, \"buffer len not enough!\");\n-\n-  unsigned int flag = 0;\n-  unsigned int fi = 0;\n-  size_t       written = 0;\n-  const char*  prefix = \"\";\n-\n-#define WRITE_TO_BUF(string)                                                          \\\n-  {                                                                                   \\\n-    int res = jio_snprintf(&buf[written], buf_len - written, \"%s%s\", prefix, string); \\\n-    if (res < 0) {                                                                    \\\n-      return buf_len - 1;                                                             \\\n-    }                                                                                 \\\n-    written += res;                                                                   \\\n-    if (prefix[0] == '\\0') {                                                          \\\n-      prefix = \", \";                                                                  \\\n-    }                                                                                 \\\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n-    if (flag == HTT_FLAG && (((_cpuid_info.std_cpuid1_ebx.value >> 16) & 0xff) <= 1)) {\n-      continue; \/* no hyperthreading *\/\n-    } else if (flag == SEP_FLAG && (cpu_family() == CPU_FAMILY_PENTIUMPRO && ((_cpuid_info.std_cpuid1_eax.value & 0xff) < 0x33))) {\n-      continue; \/* no fast system call *\/\n-    }\n-    if ((_cpuid_info.std_cpuid1_edx.value & flag) && strlen(_feature_edx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_edx_id[fi]);\n-    }\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n-    if ((_cpuid_info.std_cpuid1_ecx.value & flag) && strlen(_feature_ecx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_ecx_id[fi]);\n-    }\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n-    if ((_cpuid_info.ext_cpuid1_ecx.value & flag) && strlen(_feature_extended_ecx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_extended_ecx_id[fi]);\n-    }\n-  }\n-\n-  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n-    if ((_cpuid_info.ext_cpuid1_edx.value & flag) && strlen(_feature_extended_edx_id[fi]) > 0) {\n-      WRITE_TO_BUF(_feature_extended_edx_id[fi]);\n-    }\n-  }\n-\n-  if (supports_tscinv_bit()) {\n-      WRITE_TO_BUF(\"Invariant TSC\");\n-  }\n-\n-  return written;\n-}\n-\n-\/**\n- * Write a detailed description of the cpu to a given buffer, including\n- * feature set.\n- *\/\n-int VM_Version_Ext::cpu_detailed_description(char* const buf, size_t buf_len) {\n-  assert(buf != NULL, \"buffer is NULL!\");\n-  assert(buf_len >= CPU_DETAILED_DESC_BUF_SIZE, \"buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!\");\n-\n-  static const char* unknown = \"<unknown>\";\n-  char               vendor_id[VENDOR_LENGTH];\n-  const char*        family = NULL;\n-  const char*        model = NULL;\n-  const char*        brand = NULL;\n-  int                outputLen = 0;\n-\n-  family = cpu_family_description();\n-  if (family == NULL) {\n-    family = unknown;\n-  }\n-\n-  model = cpu_model_description();\n-  if (model == NULL) {\n-    model = unknown;\n-  }\n-\n-  brand = cpu_brand_string();\n-\n-  if (brand == NULL) {\n-    brand = cpu_brand();\n-    if (brand == NULL) {\n-      brand = unknown;\n-    }\n-  }\n-\n-  *((uint32_t*) &vendor_id[0]) = _cpuid_info.std_vendor_name_0;\n-  *((uint32_t*) &vendor_id[4]) = _cpuid_info.std_vendor_name_2;\n-  *((uint32_t*) &vendor_id[8]) = _cpuid_info.std_vendor_name_1;\n-  vendor_id[VENDOR_LENGTH-1] = '\\0';\n-\n-  outputLen = jio_snprintf(buf, buf_len, \"Brand: %s, Vendor: %s\\n\"\n-    \"Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\\n\"\n-    \"Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\\n\"\n-    \"Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n-    \"Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n-    \"Supports: \",\n-    brand,\n-    vendor_id,\n-    family,\n-    extended_cpu_family(),\n-    model,\n-    extended_cpu_model(),\n-    cpu_stepping(),\n-    _cpuid_info.std_cpuid1_eax.bits.ext_family,\n-    _cpuid_info.std_cpuid1_eax.bits.ext_model,\n-    _cpuid_info.std_cpuid1_eax.bits.proc_type,\n-    _cpuid_info.std_cpuid1_eax.value,\n-    _cpuid_info.std_cpuid1_ebx.value,\n-    _cpuid_info.std_cpuid1_ecx.value,\n-    _cpuid_info.std_cpuid1_edx.value,\n-    _cpuid_info.ext_cpuid1_eax,\n-    _cpuid_info.ext_cpuid1_ebx,\n-    _cpuid_info.ext_cpuid1_ecx,\n-    _cpuid_info.ext_cpuid1_edx);\n-\n-  if (outputLen < 0 || (size_t) outputLen >= buf_len - 1) {\n-    if (buf_len > 0) { buf[buf_len-1] = '\\0'; }\n-    return OS_ERR;\n-  }\n-\n-  cpu_write_support_string(&buf[outputLen], buf_len - outputLen);\n-\n-  return OS_OK;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  char cpu_type_desc[CPU_TYPE_DESC_BUF_SIZE];\n-  size_t cpu_desc_len = sizeof(cpu_type_desc);\n-\n-  cpu_type_description(cpu_type_desc, cpu_desc_len);\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_desc_len, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, cpu_type_desc, cpu_desc_len);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  char cpu_detailed_desc_buffer[CPU_DETAILED_DESC_BUF_SIZE];\n-  size_t cpu_detailed_desc_len = sizeof(cpu_detailed_desc_buffer);\n-\n-  cpu_detailed_description(cpu_detailed_desc_buffer, cpu_detailed_desc_len);\n-\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, cpu_detailed_desc_len, mtTracing);\n-\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-\n-  strncpy(tmp, cpu_detailed_desc_buffer, cpu_detailed_desc_len);\n-  return tmp;\n-}\n-\n-\/**\n- *  For information about extracting the frequency from the cpu brand string, please see:\n- *\n- *    Intel Processor Identification and the CPUID Instruction\n- *    Application Note 485\n- *    May 2012\n- *\n- * The return value is the frequency in Hz.\n- *\/\n-int64_t VM_Version_Ext::max_qualified_cpu_freq_from_brand_string(void) {\n-  const char* const brand_string = cpu_brand_string();\n-  if (brand_string == NULL) {\n-    return 0;\n-  }\n-  const int64_t MEGA = 1000000;\n-  int64_t multiplier = 0;\n-  int64_t frequency = 0;\n-  uint8_t idx = 0;\n-  \/\/ The brand string buffer is at most 48 bytes.\n-  \/\/ -2 is to prevent buffer overrun when looking for y in yHz, as z is +2 from y.\n-  for (; idx < 48-2; ++idx) {\n-    \/\/ Format is either \"x.xxyHz\" or \"xxxxyHz\", where y=M, G, T and x are digits.\n-    \/\/ Search brand string for \"yHz\" where y is M, G, or T.\n-    if (brand_string[idx+1] == 'H' && brand_string[idx+2] == 'z') {\n-      if (brand_string[idx] == 'M') {\n-        multiplier = MEGA;\n-      } else if (brand_string[idx] == 'G') {\n-        multiplier = MEGA * 1000;\n-      } else if (brand_string[idx] == 'T') {\n-        multiplier = MEGA * MEGA;\n-      }\n-      break;\n-    }\n-  }\n-  if (multiplier > 0) {\n-    \/\/ Compute freqency (in Hz) from brand string.\n-    if (brand_string[idx-3] == '.') { \/\/ if format is \"x.xx\"\n-      frequency =  (brand_string[idx-4] - '0') * multiplier;\n-      frequency += (brand_string[idx-2] - '0') * multiplier \/ 10;\n-      frequency += (brand_string[idx-1] - '0') * multiplier \/ 100;\n-    } else { \/\/ format is \"xxxx\"\n-      frequency =  (brand_string[idx-4] - '0') * 1000;\n-      frequency += (brand_string[idx-3] - '0') * 100;\n-      frequency += (brand_string[idx-2] - '0') * 10;\n-      frequency += (brand_string[idx-1] - '0');\n-      frequency *= multiplier;\n-    }\n-  }\n-  return frequency;\n-}\n-\n-\n-int64_t VM_Version_Ext::maximum_qualified_cpu_frequency(void) {\n-  if (_max_qualified_cpu_frequency == 0) {\n-    _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();\n-  }\n-  return _max_qualified_cpu_frequency;\n-}\n-\n-const char* const VM_Version_Ext::_family_id_intel[ExtendedFamilyIdLength_INTEL] = {\n-  \"8086\/8088\",\n-  \"\",\n-  \"286\",\n-  \"386\",\n-  \"486\",\n-  \"Pentium\",\n-  \"Pentium Pro\",   \/\/or Pentium-M\/Woodcrest depeding on model\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Pentium 4\"\n-};\n-\n-const char* const VM_Version_Ext::_family_id_amd[ExtendedFamilyIdLength_AMD] = {\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"5x86\",\n-  \"K5\/K6\",\n-  \"Athlon\/AthlonXP\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Opteron\/Athlon64\",\n-  \"Opteron QC\/Phenom\",  \/\/ Barcelona et.al.\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Zen\"\n-};\n-\/\/ Partially from Intel 64 and IA-32 Architecture Software Developer's Manual,\n-\/\/ September 2013, Vol 3C Table 35-1\n-const char* const VM_Version_Ext::_model_id_pentium_pro[] = {\n-  \"\",\n-  \"Pentium Pro\",\n-  \"\",\n-  \"Pentium II model 3\",\n-  \"\",\n-  \"Pentium II model 5\/Xeon\/Celeron\",\n-  \"Celeron\",\n-  \"Pentium III\/Pentium III Xeon\",\n-  \"Pentium III\/Pentium III Xeon\",\n-  \"Pentium M model 9\",    \/\/ Yonah\n-  \"Pentium III, model A\",\n-  \"Pentium III, model B\",\n-  \"\",\n-  \"Pentium M model D\",    \/\/ Dothan\n-  \"\",\n-  \"Core 2\",               \/\/ 0xf Woodcrest\/Conroe\/Merom\/Kentsfield\/Clovertown\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Celeron\",              \/\/ 0x16 Celeron 65nm\n-  \"Core 2\",               \/\/ 0x17 Penryn \/ Harpertown\n-  \"\",\n-  \"\",\n-  \"Core i7\",              \/\/ 0x1A CPU_MODEL_NEHALEM_EP\n-  \"Atom\",                 \/\/ 0x1B Z5xx series Silverthorn\n-  \"\",\n-  \"Core 2\",               \/\/ 0x1D Dunnington (6-core)\n-  \"Nehalem\",              \/\/ 0x1E CPU_MODEL_NEHALEM\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Westmere\",             \/\/ 0x25 CPU_MODEL_WESTMERE\n-  \"\",\n-  \"\",\n-  \"\",                     \/\/ 0x28\n-  \"\",\n-  \"Sandy Bridge\",         \/\/ 0x2a \"2nd Generation Intel Core i7, i5, i3\"\n-  \"\",\n-  \"Westmere-EP\",          \/\/ 0x2c CPU_MODEL_WESTMERE_EP\n-  \"Sandy Bridge-EP\",      \/\/ 0x2d CPU_MODEL_SANDYBRIDGE_EP\n-  \"Nehalem-EX\",           \/\/ 0x2e CPU_MODEL_NEHALEM_EX\n-  \"Westmere-EX\",          \/\/ 0x2f CPU_MODEL_WESTMERE_EX\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Ivy Bridge\",           \/\/ 0x3a\n-  \"\",\n-  \"Haswell\",              \/\/ 0x3c \"4th Generation Intel Core Processor\"\n-  \"\",                     \/\/ 0x3d \"Next Generation Intel Core Processor\"\n-  \"Ivy Bridge-EP\",        \/\/ 0x3e \"Next Generation Intel Xeon Processor E7 Family\"\n-  \"\",                     \/\/ 0x3f \"Future Generation Intel Xeon Processor\"\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Haswell\",              \/\/ 0x45 \"4th Generation Intel Core Processor\"\n-  \"Haswell\",              \/\/ 0x46 \"4th Generation Intel Core Processor\"\n-  NULL\n-};\n-\n-\/* Brand ID is for back compability\n- * Newer CPUs uses the extended brand string *\/\n-const char* const VM_Version_Ext::_brand_id[] = {\n-  \"\",\n-  \"Celeron processor\",\n-  \"Pentium III processor\",\n-  \"Intel Pentium III Xeon processor\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Intel Pentium 4 processor\",\n-  NULL\n-};\n-\n-\n-const char* const VM_Version_Ext::_feature_edx_id[] = {\n-  \"On-Chip FPU\",\n-  \"Virtual Mode Extensions\",\n-  \"Debugging Extensions\",\n-  \"Page Size Extensions\",\n-  \"Time Stamp Counter\",\n-  \"Model Specific Registers\",\n-  \"Physical Address Extension\",\n-  \"Machine Check Exceptions\",\n-  \"CMPXCHG8B Instruction\",\n-  \"On-Chip APIC\",\n-  \"\",\n-  \"Fast System Call\",\n-  \"Memory Type Range Registers\",\n-  \"Page Global Enable\",\n-  \"Machine Check Architecture\",\n-  \"Conditional Mov Instruction\",\n-  \"Page Attribute Table\",\n-  \"36-bit Page Size Extension\",\n-  \"Processor Serial Number\",\n-  \"CLFLUSH Instruction\",\n-  \"\",\n-  \"Debug Trace Store feature\",\n-  \"ACPI registers in MSR space\",\n-  \"Intel Architecture MMX Technology\",\n-  \"Fast Float Point Save and Restore\",\n-  \"Streaming SIMD extensions\",\n-  \"Streaming SIMD extensions 2\",\n-  \"Self-Snoop\",\n-  \"Hyper Threading\",\n-  \"Thermal Monitor\",\n-  \"\",\n-  \"Pending Break Enable\"\n-};\n-\n-const char* const VM_Version_Ext::_feature_extended_edx_id[] = {\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"SYSCALL\/SYSRET\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Execute Disable Bit\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"RDTSCP\",\n-  \"\",\n-  \"Intel 64 Architecture\",\n-  \"\",\n-  \"\"\n-};\n-\n-const char* const VM_Version_Ext::_feature_ecx_id[] = {\n-  \"Streaming SIMD Extensions 3\",\n-  \"PCLMULQDQ\",\n-  \"64-bit DS Area\",\n-  \"MONITOR\/MWAIT instructions\",\n-  \"CPL Qualified Debug Store\",\n-  \"Virtual Machine Extensions\",\n-  \"Safer Mode Extensions\",\n-  \"Enhanced Intel SpeedStep technology\",\n-  \"Thermal Monitor 2\",\n-  \"Supplemental Streaming SIMD Extensions 3\",\n-  \"L1 Context ID\",\n-  \"\",\n-  \"Fused Multiply-Add\",\n-  \"CMPXCHG16B\",\n-  \"xTPR Update Control\",\n-  \"Perfmon and Debug Capability\",\n-  \"\",\n-  \"Process-context identifiers\",\n-  \"Direct Cache Access\",\n-  \"Streaming SIMD extensions 4.1\",\n-  \"Streaming SIMD extensions 4.2\",\n-  \"x2APIC\",\n-  \"MOVBE\",\n-  \"Popcount instruction\",\n-  \"TSC-Deadline\",\n-  \"AESNI\",\n-  \"XSAVE\",\n-  \"OSXSAVE\",\n-  \"AVX\",\n-  \"F16C\",\n-  \"RDRAND\",\n-  \"\"\n-};\n-\n-const char* const VM_Version_Ext::_feature_extended_ecx_id[] = {\n-  \"LAHF\/SAHF instruction support\",\n-  \"Core multi-processor legacy mode\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"Advanced Bit Manipulations: LZCNT\",\n-  \"SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ\",\n-  \"Misaligned SSE mode\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\",\n-  \"\"\n-};\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_ext_x86.cpp","additions":0,"deletions":982,"binary":false,"changes":982,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_X86_VM_VERSION_EXT_X86_HPP\n-#define CPU_X86_VM_VERSION_EXT_X86_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-#include \"utilities\/sizes.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n-\n-  enum {\n-    ExtendedFamilyIdLength_INTEL = 16,\n-    ExtendedFamilyIdLength_AMD   = 24\n-  };\n-\n- private:\n-  static const size_t      VENDOR_LENGTH;\n-  static const size_t      CPU_EBS_MAX_LENGTH;\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE;\n-\n-  static const char* const _family_id_intel[ExtendedFamilyIdLength_INTEL];\n-  static const char* const _family_id_amd[ExtendedFamilyIdLength_AMD];\n-  static const char* const _brand_id[];\n-  static const char* const _model_id_pentium_pro[];\n-\n-  static const char* const _feature_edx_id[];\n-  static const char* const _feature_extended_edx_id[];\n-  static const char* const _feature_ecx_id[];\n-  static const char* const _feature_extended_ecx_id[];\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_packages;\n-  static char*             _cpu_brand_string;\n-  static int64_t           _max_qualified_cpu_frequency;\n-\n-  static const char* cpu_family_description(void);\n-  static const char* cpu_model_description(void);\n-  static const char* cpu_brand(void);\n-  static const char* cpu_brand_string(void);\n-\n-  static int cpu_type_description(char* const buf, size_t buf_len);\n-  static int cpu_detailed_description(char* const buf, size_t buf_len);\n-  static int cpu_extended_brand_string(char* const buf, size_t buf_len);\n-\n-  static bool cpu_is_em64t(void);\n-  static bool is_netburst(void);\n-\n-  \/\/ Returns bytes written excluding termninating null byte.\n-  static size_t cpu_write_support_string(char* const buf, size_t buf_len);\n-  static void resolve_cpu_information_details(void);\n-  static int64_t max_qualified_cpu_freq_from_brand_string(void);\n-\n- public:\n-  \/\/ Offsets for cpuid asm stub brand string\n-  static ByteSize proc_name_0_offset() { return byte_offset_of(CpuidInfo, proc_name_0); }\n-  static ByteSize proc_name_1_offset() { return byte_offset_of(CpuidInfo, proc_name_1); }\n-  static ByteSize proc_name_2_offset() { return byte_offset_of(CpuidInfo, proc_name_2); }\n-  static ByteSize proc_name_3_offset() { return byte_offset_of(CpuidInfo, proc_name_3); }\n-  static ByteSize proc_name_4_offset() { return byte_offset_of(CpuidInfo, proc_name_4); }\n-  static ByteSize proc_name_5_offset() { return byte_offset_of(CpuidInfo, proc_name_5); }\n-  static ByteSize proc_name_6_offset() { return byte_offset_of(CpuidInfo, proc_name_6); }\n-  static ByteSize proc_name_7_offset() { return byte_offset_of(CpuidInfo, proc_name_7); }\n-  static ByteSize proc_name_8_offset() { return byte_offset_of(CpuidInfo, proc_name_8); }\n-  static ByteSize proc_name_9_offset() { return byte_offset_of(CpuidInfo, proc_name_9); }\n-  static ByteSize proc_name_10_offset() { return byte_offset_of(CpuidInfo, proc_name_10); }\n-  static ByteSize proc_name_11_offset() { return byte_offset_of(CpuidInfo, proc_name_11); }\n-\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static int64_t maximum_qualified_cpu_frequency(void);\n-\n-  static bool supports_tscinv_ext(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-\n-  static void initialize();\n-};\n-\n-#endif \/\/ CPU_X86_VM_VERSION_EXT_X86_HPP\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_ext_x86.hpp","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -86,0 +86,13 @@\n+#define CPUID_STANDARD_FN   0x0\n+#define CPUID_STANDARD_FN_1 0x1\n+#define CPUID_STANDARD_FN_4 0x4\n+#define CPUID_STANDARD_FN_B 0xb\n+\n+#define CPUID_EXTENDED_FN   0x80000000\n+#define CPUID_EXTENDED_FN_1 0x80000001\n+#define CPUID_EXTENDED_FN_2 0x80000002\n+#define CPUID_EXTENDED_FN_3 0x80000003\n+#define CPUID_EXTENDED_FN_4 0x80000004\n+#define CPUID_EXTENDED_FN_7 0x80000007\n+#define CPUID_EXTENDED_FN_8 0x80000008\n+\n@@ -629,0 +642,143 @@\n+#   undef __\n+\n+    return start;\n+  };\n+\n+\n+  address generate_getCPUIDBrandString(void) {\n+    \/\/ Flags to test CPU type.\n+    const uint32_t HS_EFL_AC           = 0x40000;\n+    const uint32_t HS_EFL_ID           = 0x200000;\n+    \/\/ Values for when we don't have a CPUID instruction.\n+    const int      CPU_FAMILY_SHIFT = 8;\n+    const uint32_t CPU_FAMILY_386   = (3 << CPU_FAMILY_SHIFT);\n+    const uint32_t CPU_FAMILY_486   = (4 << CPU_FAMILY_SHIFT);\n+\n+    Label detect_486, cpu486, detect_586, done, ext_cpuid;\n+\n+    StubCodeMark mark(this, \"VM_Version\", \"getCPUIDNameInfo_stub\");\n+#   define __ _masm->\n+\n+    address start = __ pc();\n+\n+    \/\/\n+    \/\/ void getCPUIDBrandString(VM_Version::CpuidInfo* cpuid_info);\n+    \/\/\n+    \/\/ LP64: rcx and rdx are first and second argument registers on windows\n+\n+    __ push(rbp);\n+#ifdef _LP64\n+    __ mov(rbp, c_rarg0); \/\/ cpuid_info address\n+#else\n+    __ movptr(rbp, Address(rsp, 8)); \/\/ cpuid_info address\n+#endif\n+    __ push(rbx);\n+    __ push(rsi);\n+    __ pushf();          \/\/ preserve rbx, and flags\n+    __ pop(rax);\n+    __ push(rax);\n+    __ mov(rcx, rax);\n+    \/\/\n+    \/\/ if we are unable to change the AC flag, we have a 386\n+    \/\/\n+    __ xorl(rax, HS_EFL_AC);\n+    __ push(rax);\n+    __ popf();\n+    __ pushf();\n+    __ pop(rax);\n+    __ cmpptr(rax, rcx);\n+    __ jccb(Assembler::notEqual, detect_486);\n+\n+    __ movl(rax, CPU_FAMILY_386);\n+    __ jmp(done);\n+\n+    \/\/\n+    \/\/ If we are unable to change the ID flag, we have a 486 which does\n+    \/\/ not support the \"cpuid\" instruction.\n+    \/\/\n+    __ bind(detect_486);\n+    __ mov(rax, rcx);\n+    __ xorl(rax, HS_EFL_ID);\n+    __ push(rax);\n+    __ popf();\n+    __ pushf();\n+    __ pop(rax);\n+    __ cmpptr(rcx, rax);\n+    __ jccb(Assembler::notEqual, detect_586);\n+\n+    __ bind(cpu486);\n+    __ movl(rax, CPU_FAMILY_486);\n+    __ jmp(done);\n+\n+    \/\/\n+    \/\/ At this point, we have a chip which supports the \"cpuid\" instruction\n+    \/\/\n+    __ bind(detect_586);\n+    __ xorl(rax, rax);\n+    __ cpuid();\n+    __ orl(rax, rax);\n+    __ jcc(Assembler::equal, cpu486);   \/\/ if cpuid doesn't support an input\n+                                        \/\/ value of at least 1, we give up and\n+                                        \/\/ assume a 486\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000000) for processor brand string detection\n+    \/\/\n+    __ bind(ext_cpuid);\n+    __ movl(rax, CPUID_EXTENDED_FN);\n+    __ cpuid();\n+    __ cmpl(rax, CPUID_EXTENDED_FN_4);\n+    __ jcc(Assembler::below, done);\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000002)  \/\/ first 16 bytes in brand string\n+    \/\/\n+    __ movl(rax, CPUID_EXTENDED_FN_2);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_0_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_1_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_2_offset())));\n+    __ movl(Address(rsi, 0), rcx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_3_offset())));\n+    __ movl(Address(rsi,0), rdx);\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000003) \/\/ next 16 bytes in brand string\n+    \/\/\n+    __ movl(rax, CPUID_EXTENDED_FN_3);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_4_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_5_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_6_offset())));\n+    __ movl(Address(rsi, 0), rcx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_7_offset())));\n+    __ movl(Address(rsi,0), rdx);\n+\n+    \/\/\n+    \/\/ Extended cpuid(0x80000004) \/\/ last 16 bytes in brand string\n+    \/\/\n+    __ movl(rax, CPUID_EXTENDED_FN_4);\n+    __ cpuid();\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_8_offset())));\n+    __ movl(Address(rsi, 0), rax);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_9_offset())));\n+    __ movl(Address(rsi, 0), rbx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_10_offset())));\n+    __ movl(Address(rsi, 0), rcx);\n+    __ lea(rsi, Address(rbp, in_bytes(VM_Version::proc_name_11_offset())));\n+    __ movl(Address(rsi,0), rdx);\n+\n+    \/\/\n+    \/\/ return\n+    \/\/\n+    __ bind(done);\n+    __ popf();\n+    __ pop(rsi);\n+    __ pop(rbx);\n+    __ pop(rbp);\n+    __ ret(0);\n+\n@@ -1892,0 +2048,2 @@\n+static bool _vm_version_initialized = false;\n+\n@@ -1914,0 +2072,377 @@\n+  _vm_version_initialized = true;\n+}\n+\n+typedef enum {\n+   CPU_FAMILY_8086_8088  = 0,\n+   CPU_FAMILY_INTEL_286  = 2,\n+   CPU_FAMILY_INTEL_386  = 3,\n+   CPU_FAMILY_INTEL_486  = 4,\n+   CPU_FAMILY_PENTIUM    = 5,\n+   CPU_FAMILY_PENTIUMPRO = 6,    \/\/ Same family several models\n+   CPU_FAMILY_PENTIUM_4  = 0xF\n+} FamilyFlag;\n+\n+typedef enum {\n+  RDTSCP_FLAG  = 0x08000000, \/\/ bit 27\n+  INTEL64_FLAG = 0x20000000  \/\/ bit 29\n+} _featureExtendedEdxFlag;\n+\n+typedef enum {\n+   FPU_FLAG     = 0x00000001,\n+   VME_FLAG     = 0x00000002,\n+   DE_FLAG      = 0x00000004,\n+   PSE_FLAG     = 0x00000008,\n+   TSC_FLAG     = 0x00000010,\n+   MSR_FLAG     = 0x00000020,\n+   PAE_FLAG     = 0x00000040,\n+   MCE_FLAG     = 0x00000080,\n+   CX8_FLAG     = 0x00000100,\n+   APIC_FLAG    = 0x00000200,\n+   SEP_FLAG     = 0x00000800,\n+   MTRR_FLAG    = 0x00001000,\n+   PGE_FLAG     = 0x00002000,\n+   MCA_FLAG     = 0x00004000,\n+   CMOV_FLAG    = 0x00008000,\n+   PAT_FLAG     = 0x00010000,\n+   PSE36_FLAG   = 0x00020000,\n+   PSNUM_FLAG   = 0x00040000,\n+   CLFLUSH_FLAG = 0x00080000,\n+   DTS_FLAG     = 0x00200000,\n+   ACPI_FLAG    = 0x00400000,\n+   MMX_FLAG     = 0x00800000,\n+   FXSR_FLAG    = 0x01000000,\n+   SSE_FLAG     = 0x02000000,\n+   SSE2_FLAG    = 0x04000000,\n+   SS_FLAG      = 0x08000000,\n+   HTT_FLAG     = 0x10000000,\n+   TM_FLAG      = 0x20000000\n+} FeatureEdxFlag;\n+\n+static BufferBlob* cpuid_brand_string_stub_blob;\n+static const int   cpuid_brand_string_stub_size = 550;\n+\n+extern \"C\" {\n+  typedef void (*getCPUIDBrandString_stub_t)(void*);\n+}\n+\n+static getCPUIDBrandString_stub_t getCPUIDBrandString_stub = NULL;\n+\n+\/\/ VM_Version statics\n+enum {\n+  ExtendedFamilyIdLength_INTEL = 16,\n+  ExtendedFamilyIdLength_AMD   = 24\n+};\n+\n+const size_t VENDOR_LENGTH = 13;\n+const size_t CPU_EBS_MAX_LENGTH = (3 * 4 * 4 + 1);\n+static char* _cpu_brand_string = NULL;\n+static int64_t _max_qualified_cpu_frequency = 0;\n+\n+static int _no_of_threads = 0;\n+static int _no_of_cores = 0;\n+\n+const char* const _family_id_intel[ExtendedFamilyIdLength_INTEL] = {\n+  \"8086\/8088\",\n+  \"\",\n+  \"286\",\n+  \"386\",\n+  \"486\",\n+  \"Pentium\",\n+  \"Pentium Pro\",   \/\/or Pentium-M\/Woodcrest depeding on model\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Pentium 4\"\n+};\n+\n+const char* const _family_id_amd[ExtendedFamilyIdLength_AMD] = {\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"5x86\",\n+  \"K5\/K6\",\n+  \"Athlon\/AthlonXP\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Opteron\/Athlon64\",\n+  \"Opteron QC\/Phenom\",  \/\/ Barcelona et.al.\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Zen\"\n+};\n+\/\/ Partially from Intel 64 and IA-32 Architecture Software Developer's Manual,\n+\/\/ September 2013, Vol 3C Table 35-1\n+const char* const _model_id_pentium_pro[] = {\n+  \"\",\n+  \"Pentium Pro\",\n+  \"\",\n+  \"Pentium II model 3\",\n+  \"\",\n+  \"Pentium II model 5\/Xeon\/Celeron\",\n+  \"Celeron\",\n+  \"Pentium III\/Pentium III Xeon\",\n+  \"Pentium III\/Pentium III Xeon\",\n+  \"Pentium M model 9\",    \/\/ Yonah\n+  \"Pentium III, model A\",\n+  \"Pentium III, model B\",\n+  \"\",\n+  \"Pentium M model D\",    \/\/ Dothan\n+  \"\",\n+  \"Core 2\",               \/\/ 0xf Woodcrest\/Conroe\/Merom\/Kentsfield\/Clovertown\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Celeron\",              \/\/ 0x16 Celeron 65nm\n+  \"Core 2\",               \/\/ 0x17 Penryn \/ Harpertown\n+  \"\",\n+  \"\",\n+  \"Core i7\",              \/\/ 0x1A CPU_MODEL_NEHALEM_EP\n+  \"Atom\",                 \/\/ 0x1B Z5xx series Silverthorn\n+  \"\",\n+  \"Core 2\",               \/\/ 0x1D Dunnington (6-core)\n+  \"Nehalem\",              \/\/ 0x1E CPU_MODEL_NEHALEM\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Westmere\",             \/\/ 0x25 CPU_MODEL_WESTMERE\n+  \"\",\n+  \"\",\n+  \"\",                     \/\/ 0x28\n+  \"\",\n+  \"Sandy Bridge\",         \/\/ 0x2a \"2nd Generation Intel Core i7, i5, i3\"\n+  \"\",\n+  \"Westmere-EP\",          \/\/ 0x2c CPU_MODEL_WESTMERE_EP\n+  \"Sandy Bridge-EP\",      \/\/ 0x2d CPU_MODEL_SANDYBRIDGE_EP\n+  \"Nehalem-EX\",           \/\/ 0x2e CPU_MODEL_NEHALEM_EX\n+  \"Westmere-EX\",          \/\/ 0x2f CPU_MODEL_WESTMERE_EX\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Ivy Bridge\",           \/\/ 0x3a\n+  \"\",\n+  \"Haswell\",              \/\/ 0x3c \"4th Generation Intel Core Processor\"\n+  \"\",                     \/\/ 0x3d \"Next Generation Intel Core Processor\"\n+  \"Ivy Bridge-EP\",        \/\/ 0x3e \"Next Generation Intel Xeon Processor E7 Family\"\n+  \"\",                     \/\/ 0x3f \"Future Generation Intel Xeon Processor\"\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Haswell\",              \/\/ 0x45 \"4th Generation Intel Core Processor\"\n+  \"Haswell\",              \/\/ 0x46 \"4th Generation Intel Core Processor\"\n+  NULL\n+};\n+\n+\/* Brand ID is for back compability\n+ * Newer CPUs uses the extended brand string *\/\n+const char* const _brand_id[] = {\n+  \"\",\n+  \"Celeron processor\",\n+  \"Pentium III processor\",\n+  \"Intel Pentium III Xeon processor\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Intel Pentium 4 processor\",\n+  NULL\n+};\n+\n+\n+const char* const _feature_edx_id[] = {\n+  \"On-Chip FPU\",\n+  \"Virtual Mode Extensions\",\n+  \"Debugging Extensions\",\n+  \"Page Size Extensions\",\n+  \"Time Stamp Counter\",\n+  \"Model Specific Registers\",\n+  \"Physical Address Extension\",\n+  \"Machine Check Exceptions\",\n+  \"CMPXCHG8B Instruction\",\n+  \"On-Chip APIC\",\n+  \"\",\n+  \"Fast System Call\",\n+  \"Memory Type Range Registers\",\n+  \"Page Global Enable\",\n+  \"Machine Check Architecture\",\n+  \"Conditional Mov Instruction\",\n+  \"Page Attribute Table\",\n+  \"36-bit Page Size Extension\",\n+  \"Processor Serial Number\",\n+  \"CLFLUSH Instruction\",\n+  \"\",\n+  \"Debug Trace Store feature\",\n+  \"ACPI registers in MSR space\",\n+  \"Intel Architecture MMX Technology\",\n+  \"Fast Float Point Save and Restore\",\n+  \"Streaming SIMD extensions\",\n+  \"Streaming SIMD extensions 2\",\n+  \"Self-Snoop\",\n+  \"Hyper Threading\",\n+  \"Thermal Monitor\",\n+  \"\",\n+  \"Pending Break Enable\"\n+};\n+\n+const char* const _feature_extended_edx_id[] = {\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"SYSCALL\/SYSRET\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Execute Disable Bit\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"RDTSCP\",\n+  \"\",\n+  \"Intel 64 Architecture\",\n+  \"\",\n+  \"\"\n+};\n+\n+const char* const _feature_ecx_id[] = {\n+  \"Streaming SIMD Extensions 3\",\n+  \"PCLMULQDQ\",\n+  \"64-bit DS Area\",\n+  \"MONITOR\/MWAIT instructions\",\n+  \"CPL Qualified Debug Store\",\n+  \"Virtual Machine Extensions\",\n+  \"Safer Mode Extensions\",\n+  \"Enhanced Intel SpeedStep technology\",\n+  \"Thermal Monitor 2\",\n+  \"Supplemental Streaming SIMD Extensions 3\",\n+  \"L1 Context ID\",\n+  \"\",\n+  \"Fused Multiply-Add\",\n+  \"CMPXCHG16B\",\n+  \"xTPR Update Control\",\n+  \"Perfmon and Debug Capability\",\n+  \"\",\n+  \"Process-context identifiers\",\n+  \"Direct Cache Access\",\n+  \"Streaming SIMD extensions 4.1\",\n+  \"Streaming SIMD extensions 4.2\",\n+  \"x2APIC\",\n+  \"MOVBE\",\n+  \"Popcount instruction\",\n+  \"TSC-Deadline\",\n+  \"AESNI\",\n+  \"XSAVE\",\n+  \"OSXSAVE\",\n+  \"AVX\",\n+  \"F16C\",\n+  \"RDRAND\",\n+  \"\"\n+};\n+\n+const char* const _feature_extended_ecx_id[] = {\n+  \"LAHF\/SAHF instruction support\",\n+  \"Core multi-processor legacy mode\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"Advanced Bit Manipulations: LZCNT\",\n+  \"SSE4A: MOVNTSS, MOVNTSD, EXTRQ, INSERTQ\",\n+  \"Misaligned SSE mode\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\",\n+  \"\"\n+};\n+\n+void VM_Version::initialize_tsc(void) {\n+  ResourceMark rm;\n+\n+  cpuid_brand_string_stub_blob = BufferBlob::create(\"getCPUIDBrandString_stub\", cpuid_brand_string_stub_size);\n+  if (cpuid_brand_string_stub_blob == NULL) {\n+    vm_exit_during_initialization(\"Unable to allocate getCPUIDBrandString_stub\");\n+  }\n+  CodeBuffer c(cpuid_brand_string_stub_blob);\n+  VM_Version_StubGenerator g(&c);\n+  getCPUIDBrandString_stub = CAST_TO_FN_PTR(getCPUIDBrandString_stub_t,\n+                                   g.generate_getCPUIDBrandString());\n+}\n+\n+const char* VM_Version::cpu_model_description(void) {\n+  uint32_t cpu_family = extended_cpu_family();\n+  uint32_t cpu_model = extended_cpu_model();\n+  const char* model = NULL;\n+\n+  if (cpu_family == CPU_FAMILY_PENTIUMPRO) {\n+    for (uint32_t i = 0; i <= cpu_model; i++) {\n+      model = _model_id_pentium_pro[i];\n+      if (model == NULL) {\n+        break;\n+      }\n+    }\n+  }\n+  return model;\n@@ -1915,0 +2450,376 @@\n+\n+const char* VM_Version::cpu_brand_string(void) {\n+  if (_cpu_brand_string == NULL) {\n+    _cpu_brand_string = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_EBS_MAX_LENGTH, mtInternal);\n+    if (NULL == _cpu_brand_string) {\n+      return NULL;\n+    }\n+    int ret_val = cpu_extended_brand_string(_cpu_brand_string, CPU_EBS_MAX_LENGTH);\n+    if (ret_val != OS_OK) {\n+      FREE_C_HEAP_ARRAY(char, _cpu_brand_string);\n+      _cpu_brand_string = NULL;\n+    }\n+  }\n+  return _cpu_brand_string;\n+}\n+\n+const char* VM_Version::cpu_brand(void) {\n+  const char*  brand  = NULL;\n+\n+  if ((_cpuid_info.std_cpuid1_ebx.value & 0xFF) > 0) {\n+    int brand_num = _cpuid_info.std_cpuid1_ebx.value & 0xFF;\n+    brand = _brand_id[0];\n+    for (int i = 0; brand != NULL && i <= brand_num; i += 1) {\n+      brand = _brand_id[i];\n+    }\n+  }\n+  return brand;\n+}\n+\n+bool VM_Version::cpu_is_em64t(void) {\n+  return ((_cpuid_info.ext_cpuid1_edx.value & INTEL64_FLAG) == INTEL64_FLAG);\n+}\n+\n+bool VM_Version::is_netburst(void) {\n+  return (is_intel() && (extended_cpu_family() == CPU_FAMILY_PENTIUM_4));\n+}\n+\n+bool VM_Version::supports_tscinv_ext(void) {\n+  if (!supports_tscinv_bit()) {\n+    return false;\n+  }\n+\n+  if (is_intel()) {\n+    return true;\n+  }\n+\n+  if (is_amd()) {\n+    return !is_amd_Barcelona();\n+  }\n+\n+  if (is_hygon()) {\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void VM_Version::resolve_cpu_information_details(void) {\n+\n+  \/\/ in future we want to base this information on proper cpu\n+  \/\/ and cache topology enumeration such as:\n+  \/\/ Intel 64 Architecture Processor Topology Enumeration\n+  \/\/ which supports system cpu and cache topology enumeration\n+  \/\/ either using 2xAPICIDs or initial APICIDs\n+\n+  \/\/ currently only rough cpu information estimates\n+  \/\/ which will not necessarily reflect the exact configuration of the system\n+\n+  \/\/ this is the number of logical hardware threads\n+  \/\/ visible to the operating system\n+  _no_of_threads = os::processor_count();\n+\n+  \/\/ find out number of threads per cpu package\n+  int threads_per_package = threads_per_core() * cores_per_cpu();\n+\n+  \/\/ use amount of threads visible to the process in order to guess number of sockets\n+  _no_of_sockets = _no_of_threads \/ threads_per_package;\n+\n+  \/\/ process might only see a subset of the total number of threads\n+  \/\/ from a single processor package. Virtualization\/resource management for example.\n+  \/\/ If so then just write a hard 1 as num of pkgs.\n+  if (0 == _no_of_sockets) {\n+    _no_of_sockets = 1;\n+  }\n+\n+  \/\/ estimate the number of cores\n+  _no_of_cores = cores_per_cpu() * _no_of_sockets;\n+}\n+\n+\n+const char* VM_Version::cpu_family_description(void) {\n+  int cpu_family_id = extended_cpu_family();\n+  if (is_amd()) {\n+    if (cpu_family_id < ExtendedFamilyIdLength_AMD) {\n+      return _family_id_amd[cpu_family_id];\n+    }\n+  }\n+  if (is_intel()) {\n+    if (cpu_family_id == CPU_FAMILY_PENTIUMPRO) {\n+      return cpu_model_description();\n+    }\n+    if (cpu_family_id < ExtendedFamilyIdLength_INTEL) {\n+      return _family_id_intel[cpu_family_id];\n+    }\n+  }\n+  if (is_hygon()) {\n+    return \"Dhyana\";\n+  }\n+  return \"Unknown x86\";\n+}\n+\n+int VM_Version::cpu_type_description(char* const buf, size_t buf_len) {\n+  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf_len >= CPU_TYPE_DESC_BUF_SIZE, \"buffer len should at least be == CPU_TYPE_DESC_BUF_SIZE!\");\n+\n+  const char* cpu_type = NULL;\n+  const char* x64 = NULL;\n+\n+  if (is_intel()) {\n+    cpu_type = \"Intel\";\n+    x64 = cpu_is_em64t() ? \" Intel64\" : \"\";\n+  } else if (is_amd()) {\n+    cpu_type = \"AMD\";\n+    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n+  } else if (is_hygon()) {\n+    cpu_type = \"Hygon\";\n+    x64 = cpu_is_em64t() ? \" AMD64\" : \"\";\n+  } else {\n+    cpu_type = \"Unknown x86\";\n+    x64 = cpu_is_em64t() ? \" x86_64\" : \"\";\n+  }\n+\n+  jio_snprintf(buf, buf_len, \"%s %s%s SSE SSE2%s%s%s%s%s%s%s%s\",\n+    cpu_type,\n+    cpu_family_description(),\n+    supports_ht() ? \" (HT)\" : \"\",\n+    supports_sse3() ? \" SSE3\" : \"\",\n+    supports_ssse3() ? \" SSSE3\" : \"\",\n+    supports_sse4_1() ? \" SSE4.1\" : \"\",\n+    supports_sse4_2() ? \" SSE4.2\" : \"\",\n+    supports_sse4a() ? \" SSE4A\" : \"\",\n+    is_netburst() ? \" Netburst\" : \"\",\n+    is_intel_family_core() ? \" Core\" : \"\",\n+    x64);\n+\n+  return OS_OK;\n+}\n+\n+int VM_Version::cpu_extended_brand_string(char* const buf, size_t buf_len) {\n+  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf_len >= CPU_EBS_MAX_LENGTH, \"buffer len should at least be == CPU_EBS_MAX_LENGTH!\");\n+  assert(getCPUIDBrandString_stub != NULL, \"not initialized\");\n+\n+  \/\/ invoke newly generated asm code to fetch CPU Brand String\n+  getCPUIDBrandString_stub(&_cpuid_info);\n+\n+  \/\/ fetch results into buffer\n+  *((uint32_t*) &buf[0])  = _cpuid_info.proc_name_0;\n+  *((uint32_t*) &buf[4])  = _cpuid_info.proc_name_1;\n+  *((uint32_t*) &buf[8])  = _cpuid_info.proc_name_2;\n+  *((uint32_t*) &buf[12]) = _cpuid_info.proc_name_3;\n+  *((uint32_t*) &buf[16]) = _cpuid_info.proc_name_4;\n+  *((uint32_t*) &buf[20]) = _cpuid_info.proc_name_5;\n+  *((uint32_t*) &buf[24]) = _cpuid_info.proc_name_6;\n+  *((uint32_t*) &buf[28]) = _cpuid_info.proc_name_7;\n+  *((uint32_t*) &buf[32]) = _cpuid_info.proc_name_8;\n+  *((uint32_t*) &buf[36]) = _cpuid_info.proc_name_9;\n+  *((uint32_t*) &buf[40]) = _cpuid_info.proc_name_10;\n+  *((uint32_t*) &buf[44]) = _cpuid_info.proc_name_11;\n+\n+  return OS_OK;\n+}\n+\n+size_t VM_Version::cpu_write_support_string(char* const buf, size_t buf_len) {\n+  guarantee(buf != NULL, \"buffer is NULL!\");\n+  guarantee(buf_len > 0, \"buffer len not enough!\");\n+\n+  unsigned int flag = 0;\n+  unsigned int fi = 0;\n+  size_t       written = 0;\n+  const char*  prefix = \"\";\n+\n+#define WRITE_TO_BUF(string)                                                          \\\n+  {                                                                                   \\\n+    int res = jio_snprintf(&buf[written], buf_len - written, \"%s%s\", prefix, string); \\\n+    if (res < 0) {                                                                    \\\n+      return buf_len - 1;                                                             \\\n+    }                                                                                 \\\n+    written += res;                                                                   \\\n+    if (prefix[0] == '\\0') {                                                          \\\n+      prefix = \", \";                                                                  \\\n+    }                                                                                 \\\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n+    if (flag == HTT_FLAG && (((_cpuid_info.std_cpuid1_ebx.value >> 16) & 0xff) <= 1)) {\n+      continue; \/* no hyperthreading *\/\n+    } else if (flag == SEP_FLAG && (cpu_family() == CPU_FAMILY_PENTIUMPRO && ((_cpuid_info.std_cpuid1_eax.value & 0xff) < 0x33))) {\n+      continue; \/* no fast system call *\/\n+    }\n+    if ((_cpuid_info.std_cpuid1_edx.value & flag) && strlen(_feature_edx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_edx_id[fi]);\n+    }\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n+    if ((_cpuid_info.std_cpuid1_ecx.value & flag) && strlen(_feature_ecx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_ecx_id[fi]);\n+    }\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000 ; flag <<= 1, fi++) {\n+    if ((_cpuid_info.ext_cpuid1_ecx.value & flag) && strlen(_feature_extended_ecx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_extended_ecx_id[fi]);\n+    }\n+  }\n+\n+  for (flag = 1, fi = 0; flag <= 0x20000000; flag <<= 1, fi++) {\n+    if ((_cpuid_info.ext_cpuid1_edx.value & flag) && strlen(_feature_extended_edx_id[fi]) > 0) {\n+      WRITE_TO_BUF(_feature_extended_edx_id[fi]);\n+    }\n+  }\n+\n+  if (supports_tscinv_bit()) {\n+      WRITE_TO_BUF(\"Invariant TSC\");\n+  }\n+\n+  return written;\n+}\n+\n+\/**\n+ * Write a detailed description of the cpu to a given buffer, including\n+ * feature set.\n+ *\/\n+int VM_Version::cpu_detailed_description(char* const buf, size_t buf_len) {\n+  assert(buf != NULL, \"buffer is NULL!\");\n+  assert(buf_len >= CPU_DETAILED_DESC_BUF_SIZE, \"buffer len should at least be == CPU_DETAILED_DESC_BUF_SIZE!\");\n+\n+  static const char* unknown = \"<unknown>\";\n+  char               vendor_id[VENDOR_LENGTH];\n+  const char*        family = NULL;\n+  const char*        model = NULL;\n+  const char*        brand = NULL;\n+  int                outputLen = 0;\n+\n+  family = cpu_family_description();\n+  if (family == NULL) {\n+    family = unknown;\n+  }\n+\n+  model = cpu_model_description();\n+  if (model == NULL) {\n+    model = unknown;\n+  }\n+\n+  brand = cpu_brand_string();\n+\n+  if (brand == NULL) {\n+    brand = cpu_brand();\n+    if (brand == NULL) {\n+      brand = unknown;\n+    }\n+  }\n+\n+  *((uint32_t*) &vendor_id[0]) = _cpuid_info.std_vendor_name_0;\n+  *((uint32_t*) &vendor_id[4]) = _cpuid_info.std_vendor_name_2;\n+  *((uint32_t*) &vendor_id[8]) = _cpuid_info.std_vendor_name_1;\n+  vendor_id[VENDOR_LENGTH-1] = '\\0';\n+\n+  outputLen = jio_snprintf(buf, buf_len, \"Brand: %s, Vendor: %s\\n\"\n+    \"Family: %s (0x%x), Model: %s (0x%x), Stepping: 0x%x\\n\"\n+    \"Ext. family: 0x%x, Ext. model: 0x%x, Type: 0x%x, Signature: 0x%8.8x\\n\"\n+    \"Features: ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n+    \"Ext. features: eax: 0x%8.8x, ebx: 0x%8.8x, ecx: 0x%8.8x, edx: 0x%8.8x\\n\"\n+    \"Supports: \",\n+    brand,\n+    vendor_id,\n+    family,\n+    extended_cpu_family(),\n+    model,\n+    extended_cpu_model(),\n+    cpu_stepping(),\n+    _cpuid_info.std_cpuid1_eax.bits.ext_family,\n+    _cpuid_info.std_cpuid1_eax.bits.ext_model,\n+    _cpuid_info.std_cpuid1_eax.bits.proc_type,\n+    _cpuid_info.std_cpuid1_eax.value,\n+    _cpuid_info.std_cpuid1_ebx.value,\n+    _cpuid_info.std_cpuid1_ecx.value,\n+    _cpuid_info.std_cpuid1_edx.value,\n+    _cpuid_info.ext_cpuid1_eax,\n+    _cpuid_info.ext_cpuid1_ebx,\n+    _cpuid_info.ext_cpuid1_ecx,\n+    _cpuid_info.ext_cpuid1_edx);\n+\n+  if (outputLen < 0 || (size_t) outputLen >= buf_len - 1) {\n+    if (buf_len > 0) { buf[buf_len-1] = '\\0'; }\n+    return OS_ERR;\n+  }\n+\n+  cpu_write_support_string(&buf[outputLen], buf_len - outputLen);\n+\n+  return OS_OK;\n+}\n+\n+\n+\/\/ Fill in Abstract_VM_Version statics\n+void VM_Version::initialize_cpu_information() {\n+  assert(_vm_version_initialized, \"should have initialized VM_Version long ago\");\n+  assert(!_initialized, \"shouldn't be initialized yet\");\n+  resolve_cpu_information_details();\n+\n+  \/\/ initialize cpu_name and cpu_desc\n+  cpu_type_description(_cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n+  cpu_detailed_description(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n+  _initialized = true;\n+}\n+\n+\/**\n+ *  For information about extracting the frequency from the cpu brand string, please see:\n+ *\n+ *    Intel Processor Identification and the CPUID Instruction\n+ *    Application Note 485\n+ *    May 2012\n+ *\n+ * The return value is the frequency in Hz.\n+ *\/\n+int64_t VM_Version::max_qualified_cpu_freq_from_brand_string(void) {\n+  const char* const brand_string = cpu_brand_string();\n+  if (brand_string == NULL) {\n+    return 0;\n+  }\n+  const int64_t MEGA = 1000000;\n+  int64_t multiplier = 0;\n+  int64_t frequency = 0;\n+  uint8_t idx = 0;\n+  \/\/ The brand string buffer is at most 48 bytes.\n+  \/\/ -2 is to prevent buffer overrun when looking for y in yHz, as z is +2 from y.\n+  for (; idx < 48-2; ++idx) {\n+    \/\/ Format is either \"x.xxyHz\" or \"xxxxyHz\", where y=M, G, T and x are digits.\n+    \/\/ Search brand string for \"yHz\" where y is M, G, or T.\n+    if (brand_string[idx+1] == 'H' && brand_string[idx+2] == 'z') {\n+      if (brand_string[idx] == 'M') {\n+        multiplier = MEGA;\n+      } else if (brand_string[idx] == 'G') {\n+        multiplier = MEGA * 1000;\n+      } else if (brand_string[idx] == 'T') {\n+        multiplier = MEGA * MEGA;\n+      }\n+      break;\n+    }\n+  }\n+  if (multiplier > 0) {\n+    \/\/ Compute freqency (in Hz) from brand string.\n+    if (brand_string[idx-3] == '.') { \/\/ if format is \"x.xx\"\n+      frequency =  (brand_string[idx-4] - '0') * multiplier;\n+      frequency += (brand_string[idx-2] - '0') * multiplier \/ 10;\n+      frequency += (brand_string[idx-1] - '0') * multiplier \/ 100;\n+    } else { \/\/ format is \"xxxx\"\n+      frequency =  (brand_string[idx-4] - '0') * 1000;\n+      frequency += (brand_string[idx-3] - '0') * 100;\n+      frequency += (brand_string[idx-2] - '0') * 10;\n+      frequency += (brand_string[idx-1] - '0');\n+      frequency *= multiplier;\n+    }\n+  }\n+  return frequency;\n+}\n+\n+\n+int64_t VM_Version::maximum_qualified_cpu_frequency(void) {\n+  if (_max_qualified_cpu_frequency == 0) {\n+    _max_qualified_cpu_frequency = max_qualified_cpu_freq_from_brand_string();\n+  }\n+  return _max_qualified_cpu_frequency;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.cpp","additions":911,"deletions":0,"binary":false,"changes":911,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-enum Extended_Family {\n+  enum Extended_Family {\n@@ -1056,0 +1056,39 @@\n+\n+  static const char* cpu_family_description(void);\n+  static const char* cpu_model_description(void);\n+  static const char* cpu_brand(void);\n+  static const char* cpu_brand_string(void);\n+\n+  static int cpu_type_description(char* const buf, size_t buf_len);\n+  static int cpu_detailed_description(char* const buf, size_t buf_len);\n+  static int cpu_extended_brand_string(char* const buf, size_t buf_len);\n+\n+  static bool cpu_is_em64t(void);\n+  static bool is_netburst(void);\n+\n+  \/\/ Returns bytes written excluding termninating null byte.\n+  static size_t cpu_write_support_string(char* const buf, size_t buf_len);\n+  static void resolve_cpu_information_details(void);\n+  static int64_t max_qualified_cpu_freq_from_brand_string(void);\n+\n+ public:\n+  \/\/ Offsets for cpuid asm stub brand string\n+  static ByteSize proc_name_0_offset() { return byte_offset_of(CpuidInfo, proc_name_0); }\n+  static ByteSize proc_name_1_offset() { return byte_offset_of(CpuidInfo, proc_name_1); }\n+  static ByteSize proc_name_2_offset() { return byte_offset_of(CpuidInfo, proc_name_2); }\n+  static ByteSize proc_name_3_offset() { return byte_offset_of(CpuidInfo, proc_name_3); }\n+  static ByteSize proc_name_4_offset() { return byte_offset_of(CpuidInfo, proc_name_4); }\n+  static ByteSize proc_name_5_offset() { return byte_offset_of(CpuidInfo, proc_name_5); }\n+  static ByteSize proc_name_6_offset() { return byte_offset_of(CpuidInfo, proc_name_6); }\n+  static ByteSize proc_name_7_offset() { return byte_offset_of(CpuidInfo, proc_name_7); }\n+  static ByteSize proc_name_8_offset() { return byte_offset_of(CpuidInfo, proc_name_8); }\n+  static ByteSize proc_name_9_offset() { return byte_offset_of(CpuidInfo, proc_name_9); }\n+  static ByteSize proc_name_10_offset() { return byte_offset_of(CpuidInfo, proc_name_10); }\n+  static ByteSize proc_name_11_offset() { return byte_offset_of(CpuidInfo, proc_name_11); }\n+\n+  static int64_t maximum_qualified_cpu_frequency(void);\n+\n+  static bool supports_tscinv_ext(void);\n+\n+  static void initialize_tsc();\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/x86\/vm_version_x86.hpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1845,0 +1845,8 @@\n+    case Op_VectorLongToMask:\n+      if (UseAVX < 1 || !is_LP64) {\n+        return false;\n+      }\n+      if (UseAVX < 3 && !VM_Version::supports_bmi2()) {\n+        return false;\n+      }\n+      break;\n@@ -9537,0 +9545,40 @@\n+\n+instruct long_to_maskLE8_avx(vec dst, rRegL src, rRegL rtmp1, rRegL rtmp2, vec xtmp) %{\n+  predicate(n->bottom_type()->isa_vectmask() == NULL && Matcher::vector_length(n) <= 8);\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, TEMP xtmp);\n+  format %{ \"long_to_mask_avx $dst, $src\\t! using $rtmp1, $rtmp2, $xtmp as TEMP\" %}\n+  ins_encode %{\n+    int mask_len = Matcher::vector_length(this);\n+    int vec_enc  = vector_length_encoding(mask_len);\n+    __ vector_long_to_maskvec($dst$$XMMRegister, $src$$Register, $rtmp1$$Register,\n+                              $rtmp2$$Register, xnoreg, mask_len, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+\n+instruct long_to_maskGT8_avx(vec dst, rRegL src, rRegL rtmp1, rRegL rtmp2, vec xtmp1, rFlagsReg cr) %{\n+  predicate(n->bottom_type()->isa_vectmask() == NULL && Matcher::vector_length(n) > 8);\n+  match(Set dst (VectorLongToMask src));\n+  effect(TEMP dst, TEMP rtmp1, TEMP rtmp2, TEMP xtmp1, KILL cr);\n+  format %{ \"long_to_mask_avx $dst, $src\\t! using $rtmp1, $rtmp2, $xtmp1, as TEMP\" %}\n+  ins_encode %{\n+    int mask_len = Matcher::vector_length(this);\n+    assert(mask_len <= 32, \"invalid mask length\");\n+    int vec_enc  = vector_length_encoding(mask_len);\n+    __ vector_long_to_maskvec($dst$$XMMRegister, $src$$Register, $rtmp1$$Register,\n+                              $rtmp2$$Register, $xtmp1$$XMMRegister, mask_len, vec_enc);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct long_to_mask_evex(kReg dst, rRegL src) %{\n+  predicate(n->bottom_type()->isa_vectmask());\n+  match(Set dst (VectorLongToMask src));\n+  format %{ \"long_to_mask_evex $dst, $src\\t!\" %}\n+  ins_encode %{\n+    __ kmov($dst$$KRegister, $src$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n@@ -9556,0 +9604,1 @@\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"runtime\/os.hpp\"\n-#include \"vm_version_ext_zero.hpp\"\n-\n-\/\/ VM_Version_Ext statics\n-int VM_Version_Ext::_no_of_threads = 0;\n-int VM_Version_Ext::_no_of_cores = 0;\n-int VM_Version_Ext::_no_of_sockets = 0;\n-bool VM_Version_Ext::_initialized = false;\n-char VM_Version_Ext::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n-char VM_Version_Ext::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n-\n-void VM_Version_Ext::initialize_cpu_information(void) {\n-  \/\/ do nothing if cpu info has been initialized\n-  if (_initialized) {\n-    return;\n-  }\n-\n-  int core_id = -1;\n-  int chip_id = -1;\n-  int len = 0;\n-  char* src_string = NULL;\n-\n-  _no_of_cores  = os::processor_count();\n-  _no_of_threads = _no_of_cores;\n-  _no_of_sockets = _no_of_cores;\n-  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n-  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n-  _initialized = true;\n-}\n-\n-int VM_Version_Ext::number_of_threads(void) {\n-  initialize_cpu_information();\n-  return _no_of_threads;\n-}\n-\n-int VM_Version_Ext::number_of_cores(void) {\n-  initialize_cpu_information();\n-  return _no_of_cores;\n-}\n-\n-int VM_Version_Ext::number_of_sockets(void) {\n-  initialize_cpu_information();\n-  return _no_of_sockets;\n-}\n-\n-const char* VM_Version_Ext::cpu_name(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n-  return tmp;\n-}\n-\n-const char* VM_Version_Ext::cpu_description(void) {\n-  initialize_cpu_information();\n-  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n-  if (NULL == tmp) {\n-    return NULL;\n-  }\n-  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n-  return tmp;\n-}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_ext_zero.cpp","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,54 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef CPU_ZERO_VM_VERSION_EXT_ZERO_HPP\n-#define CPU_ZERO_VM_VERSION_EXT_ZERO_HPP\n-\n-#include \"runtime\/vm_version.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class VM_Version_Ext : public VM_Version {\n- private:\n-  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n-  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n-\n-  static int               _no_of_threads;\n-  static int               _no_of_cores;\n-  static int               _no_of_sockets;\n-  static bool              _initialized;\n-  static char              _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n-  static char              _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n-\n- public:\n-  static int number_of_threads(void);\n-  static int number_of_cores(void);\n-  static int number_of_sockets(void);\n-\n-  static const char* cpu_name(void);\n-  static const char* cpu_description(void);\n-  static void initialize_cpu_information(void);\n-\n-};\n-\n-#endif \/\/ CPU_ZERO_VM_VERSION_EXT_ZERO_HPP\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_ext_zero.hpp","additions":0,"deletions":54,"binary":false,"changes":54,"status":"deleted"},{"patch":"@@ -124,0 +124,14 @@\n+\n+void VM_Version::initialize_cpu_information(void) {\n+  \/\/ do nothing if cpu info has been initialized\n+  if (_initialized) {\n+    return;\n+  }\n+\n+  _no_of_cores  = os::processor_count();\n+  _no_of_threads = _no_of_cores;\n+  _no_of_sockets = _no_of_cores;\n+  snprintf(_cpu_name, CPU_TYPE_DESC_BUF_SIZE - 1, \"Zero VM\");\n+  snprintf(_cpu_desc, CPU_DETAILED_DESC_BUF_SIZE, \"%s\", _features_string);\n+  _initialized = true;\n+}\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,2 @@\n+\n+  static void initialize_cpu_information(void);\n","filename":"src\/hotspot\/cpu\/zero\/vm_version_zero.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,7 +66,0 @@\n-#ifdef ASSERT\n-  \/\/ We expect no reposition failures so kill vm if we get one.\n-  \/\/\n-  bool valid_reposition_failure() {\n-    return false;\n-  }\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -744,1 +744,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n@@ -858,1 +858,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -33,2 +34,0 @@\n-#include CPU_HEADER(vm_version_ext)\n-\n@@ -866,5 +865,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/aix\/os_perf_aix.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -70,8 +70,0 @@\n-#ifdef ASSERT\n-  \/\/ We expect no reposition failures so kill vm if we get one.\n-  \/\/\n-  bool valid_reposition_failure() {\n-    return false;\n-  }\n-#endif \/\/ ASSERT\n-\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -592,1 +592,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n@@ -685,1 +685,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -30,1 +31,0 @@\n-#include CPU_HEADER(vm_version_ext)\n@@ -374,5 +374,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/bsd\/os_perf_bsd.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,7 +58,1 @@\n-#ifdef ASSERT\n-  \/\/ We expect no reposition failures so kill vm if we get one.\n-  \/\/\n-  bool valid_reposition_failure() {\n-    return false;\n-  }\n-#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -789,1 +789,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n@@ -918,1 +918,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -33,2 +34,0 @@\n-#include CPU_HEADER(vm_version_ext)\n-\n@@ -930,5 +929,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1613,3 +1613,1 @@\n-      \/\/ OS-level \"spurious wakeups\" are ignored unless the archaic\n-      \/\/ FilterSpuriousWakeups is set false. That flag should be obsoleted.\n-      if (!FilterSpuriousWakeups) break;\n+      \/\/ OS-level \"spurious wakeups\" are ignored\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,7 +52,0 @@\n-#ifdef ASSERT\n-  \/\/ We expect no reposition failures so kill vm if we get one\n-  \/\/\n-  bool valid_reposition_failure() {\n-    return false;\n-  }\n-#endif \/\/ ASSERT\n","filename":"src\/hotspot\/os\/windows\/osThread_windows.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -37,1 +38,0 @@\n-#include CPU_HEADER(vm_version_ext)\n@@ -1437,5 +1437,6 @@\n-  _cpu_info->set_number_of_hardware_threads(VM_Version_Ext::number_of_threads());\n-  _cpu_info->set_number_of_cores(VM_Version_Ext::number_of_cores());\n-  _cpu_info->set_number_of_sockets(VM_Version_Ext::number_of_sockets());\n-  _cpu_info->set_cpu_name(VM_Version_Ext::cpu_name());\n-  _cpu_info->set_cpu_description(VM_Version_Ext::cpu_description());\n+  VM_Version::initialize_cpu_information();\n+  _cpu_info->set_number_of_hardware_threads(VM_Version::number_of_threads());\n+  _cpu_info->set_number_of_cores(VM_Version::number_of_cores());\n+  _cpu_info->set_number_of_sockets(VM_Version::number_of_sockets());\n+  _cpu_info->set_cpu_name(VM_Version::cpu_name());\n+  _cpu_info->set_cpu_description(VM_Version::cpu_description());\n","filename":"src\/hotspot\/os\/windows\/os_perf_windows.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -571,1 +571,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n@@ -674,1 +674,1 @@\n-  OSThread* osthread = new OSThread(NULL, NULL);\n+  OSThread* osthread = new OSThread();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -385,1 +385,14 @@\n-    return 0;\n+    using spin_wait_func_ptr_t = void (*)();\n+    spin_wait_func_ptr_t func = CAST_TO_FN_PTR(spin_wait_func_ptr_t, StubRoutines::aarch64::spin_wait());\n+    assert(func != nullptr, \"StubRoutines::aarch64::spin_wait must not be null.\");\n+    (*func)();\n+    \/\/ If StubRoutines::aarch64::spin_wait consists of only a RET,\n+    \/\/ SpinPause can be considered as implemented. There will be a sequence\n+    \/\/ of instructions for:\n+    \/\/ - call of SpinPause\n+    \/\/ - load of StubRoutines::aarch64::spin_wait stub pointer\n+    \/\/ - indirect call of the stub\n+    \/\/ - return from the stub\n+    \/\/ - return from SpinPause\n+    \/\/ So '1' always is returned.\n+    return 1;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4237,2 +4237,2 @@\n-    \"VectorMaskWrapper\", \"VectorMaskCmp\", \"VectorReinterpret\",\"LoadVectorMasked\",\"StoreVectorMasked\",\n-    \"FmaVD\", \"FmaVF\",\"PopCountVI\",\n+    \"VectorMaskWrapper\",\"VectorMaskCmp\",\"VectorReinterpret\",\"LoadVectorMasked\",\"StoreVectorMasked\",\n+    \"FmaVD\",\"FmaVF\",\"PopCountVI\",\"VectorLongToMask\",\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-\/\/  slots and registers to their frame location\n+\/\/  slots and registers) to their frame location\n","filename":"src\/hotspot\/share\/c1\/c1_FrameMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3094,1 +3094,1 @@\n-  \/\/ necesary if std_entry is also a backward branch target because\n+  \/\/ necessary if std_entry is also a backward branch target because\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -898,5 +898,0 @@\n-void BlockList::blocks_do(void f(BlockBegin*)) {\n-  for (int i = length() - 1; i >= 0; i--) f(at(i));\n-}\n-\n-\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -140,1 +140,0 @@\n-  void blocks_do(void f(BlockBegin*));\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -610,1 +610,1 @@\n-      _masm->verified_entry();\n+      _masm->verified_entry(compilation()->directive()->BreakAtExecuteOption);\n","filename":"src\/hotspot\/share\/c1\/c1_LIRAssembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-  void verified_entry();\n+  void verified_entry(bool breakAtEntry);\n","filename":"src\/hotspot\/share\/c1\/c1_MacroAssembler.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -508,1 +508,1 @@\n-  \/\/ method parameters are not linked in instructions list, so process them separateley\n+  \/\/ method parameters are not linked in instructions list, so process them separately\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,1 +119,0 @@\n-  void kill_exception();\n","filename":"src\/hotspot\/share\/c1\/c1_ValueMap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -599,1 +599,1 @@\n-    _loaded_cld_handles.append(OopHandle(Universe::vm_global(), cld->holder_phantom()));\n+    _loaded_cld_handles.append(OopHandle(Universe::vm_global(), cld->holder()));\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -142,0 +142,2 @@\n+#define JAVA_19_VERSION                   63\n+\n@@ -4530,1 +4532,0 @@\n-  const bool major_gte_14  = _major_version >= JAVA_14_VERSION;\n@@ -4786,1 +4787,1 @@\n-\/\/ be taken as a fieldname. Allow '\/' if slash_ok is true.\n+\/\/ be taken as a fieldname. Allow non-trailing '\/'s if slash_ok is true.\n@@ -4860,1 +4861,1 @@\n-  return (not_first_ch) ? p : NULL;\n+  return (not_first_ch && !last_is_slash) ? p : NULL;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -618,2 +618,3 @@\n-\/\/ Tell the GC to keep this klass alive while iterating ClassLoaderDataGraph\n-oop ClassLoaderData::holder_phantom() const {\n+\/\/ Tell the GC to keep this klass alive. Needed while iterating ClassLoaderDataGraph,\n+\/\/ and any runtime code that uses klasses.\n+oop ClassLoaderData::holder() const {\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-  oop holder_phantom() const;\n+  oop holder() const;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-      _holder = Handle(_thread, cld->holder_phantom());\n+      _holder = Handle(_thread, cld->holder());\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -872,2 +872,2 @@\n-  do_intrinsic(_VectorBroadcastCoerced, jdk_internal_vm_vector_VectorSupport, vector_broadcast_coerced_name, vector_broadcast_coerced_sig, F_S)\\\n-   do_signature(vector_broadcast_coerced_sig, \"(Ljava\/lang\/Class;\"                                                                             \\\n+  do_intrinsic(_VectorFromBitsCoerced, jdk_internal_vm_vector_VectorSupport, vector_frombits_coerced_name, vector_frombits_coerced_sig, F_S)   \\\n+   do_signature(vector_frombits_coerced_sig, \"(Ljava\/lang\/Class;\"                                                                              \\\n@@ -877,0 +877,1 @@\n+                                               \"I\"                                                                                             \\\n@@ -878,1 +879,1 @@\n-                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$BroadcastOperation;)\"                                    \\\n+                                               \"Ljdk\/internal\/vm\/vector\/VectorSupport$FromBitsCoercedOperation;)\"                              \\\n@@ -880,1 +881,1 @@\n-   do_name(vector_broadcast_coerced_name, \"broadcastCoerced\")                                                                                  \\\n+   do_name(vector_frombits_coerced_name, \"fromBitsCoerced\")                                                                                    \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -337,0 +337,10 @@\n+#ifdef COMPILER1\n+    if (C1Breakpoint) {\n+      \/\/ If the directives didn't have 'BreakAtExecute',\n+      \/\/ the command 'C1Breakpoint' would become effective.\n+      if (!_modified[BreakAtExecuteIndex]) {\n+         set.cloned()->BreakAtExecuteOption = true;\n+      }\n+    }\n+#endif\n+\n@@ -340,0 +350,2 @@\n+      \/\/ If the directives didn't have 'BreakAtCompile' or 'BreakAtExecute',\n+      \/\/ the sub-command 'Break' of the 'CompileCommand' would become effective.\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -100,2 +100,0 @@\n-  bool bailout = false;\n-\n@@ -258,4 +256,0 @@\n-      case Bytecodes::_breakpoint:\n-        \/\/ Bail out of there are breakpoints in here.\n-        bailout = true;\n-        break;\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -152,4 +152,2 @@\n-    oop obj = cast_to_oop(q);\n-    if (obj->klass_or_null_acquire() == NULL) {\n-      return q;\n-    }\n+    assert(cast_to_oop(q)->klass_or_null() != nullptr,\n+        \"start of block must be an initialized object\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1BlockOffsetTable.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2960,0 +2960,5 @@\n+void G1CollectedHeap::clear_prev_bitmap_for_region(HeapRegion* hr) {\n+  MemRegion mr(hr->bottom(), hr->end());\n+  concurrent_mark()->clear_range_in_prev_bitmap(mr);\n+}\n+\n@@ -2966,2 +2971,1 @@\n-    MemRegion mr(hr->bottom(), hr->end());\n-    concurrent_mark()->clear_range_in_prev_bitmap(mr);\n+    clear_prev_bitmap_for_region(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -625,0 +625,2 @@\n+  void clear_prev_bitmap_for_region(HeapRegion* hr);\n+\n@@ -1255,0 +1257,3 @@\n+  \/\/ Mark the live object that failed evacuation in the prev bitmap.\n+  inline void mark_evac_failure_object(const oop obj, uint worker_id) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/g1\/g1ConcurrentMark.inline.hpp\"\n@@ -250,0 +251,7 @@\n+inline void G1CollectedHeap::mark_evac_failure_object(const oop obj, uint worker_id) const {\n+    \/\/ All objects failing evacuation are live. What we'll do is\n+    \/\/ that we'll update the prev marking info so that they are\n+    \/\/ all under PTAMS and explicitly marked.\n+    _cm->par_mark_in_prev_bitmap(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -566,1 +566,1 @@\n-  inline void mark_in_prev_bitmap(oop p);\n+  inline void par_mark_in_prev_bitmap(oop p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -271,3 +271,2 @@\n-inline void G1ConcurrentMark::mark_in_prev_bitmap(oop p) {\n-  assert(!_prev_mark_bitmap->is_marked(p), \"sanity\");\n- _prev_mark_bitmap->mark(p);\n+inline void G1ConcurrentMark::par_mark_in_prev_bitmap(oop p) {\n+  _prev_mark_bitmap->par_mark(p);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -253,0 +253,4 @@\n+\/\/ An initial guess at the rate for pause-time card refinement for one\n+\/\/ thread, used when computing the default initial green zone value.\n+const double InitialPauseTimeCardRefinementRate = 200.0;\n+\n@@ -254,2 +258,1 @@\n-  size_t green = G1ConcRefinementGreenZone;\n-  const char* name = \"G1ConcRefinementGreenZone\";\n+  size_t green;\n@@ -257,2 +260,7 @@\n-    green = ParallelGCThreads;\n-    name = \"ParallelGCThreads\";\n+    const double rate = InitialPauseTimeCardRefinementRate * ParallelGCThreads;\n+    \/\/ The time budget for pause-time card refinement.\n+    const double ms = MaxGCPauseMillis * (G1RSetUpdatingPauseTimePercent \/ 100.0);\n+    green = rate * ms;\n+  } else {\n+    green = configuration_buffers_to_cards(G1ConcRefinementGreenZone,\n+                                           \"G1ConcRefinementGreenZone\");\n@@ -260,1 +268,0 @@\n-  green = configuration_buffers_to_cards(green, name);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-class RemoveSelfForwardPtrObjClosure: public ObjectClosure {\n+class RemoveSelfForwardPtrObjClosure {\n@@ -63,1 +63,1 @@\n-  \/\/ Iterate over the live objects in the region to find self-forwarded objects\n+  \/\/ Handle the marked objects in the region. These are self-forwarded objects\n@@ -69,1 +69,1 @@\n-  void do_object(oop obj) {\n+  size_t apply(oop obj) {\n@@ -78,6 +78,3 @@\n-    \/\/ We consider all objects that we find self-forwarded to be\n-    \/\/ live. What we'll do is that we'll update the prev marking\n-    \/\/ info so that they are all under PTAMS and explicitly marked.\n-    if (!_cm->is_marked_in_prev_bitmap(obj)) {\n-      _cm->mark_in_prev_bitmap(obj);\n-    }\n+\n+    \/\/ Zapping clears the bitmap, make sure it didn't clear too much.\n+    assert(_cm->is_marked_in_prev_bitmap(obj), \"should be correctly marked\");\n@@ -95,1 +92,1 @@\n-      _cm->mark_in_next_bitmap(_worker_id, _hr, obj);\n+      _cm->mark_in_next_bitmap(_worker_id, obj);\n@@ -105,0 +102,1 @@\n+    return obj_size;\n@@ -164,2 +162,5 @@\n-    \/\/ Iterates evac failure objs which are recorded during evacuation.\n-    hr->process_and_drop_evac_failure_objs(&rspc);\n+\n+    \/\/ All objects that failed evacuation has been marked in the prev bitmap.\n+    \/\/ Use the bitmap to apply the above closure to all failing objects.\n+    G1CMBitMap* bitmap = const_cast<G1CMBitMap*>(_g1h->concurrent_mark()->prev_mark_bitmap());\n+    hr->apply_to_marked_objects(bitmap, &rspc);\n@@ -175,0 +176,1 @@\n+    assert(_evac_failure_regions->contains(hr->hrm_index()), \"precondition\");\n@@ -176,2 +178,1 @@\n-    if (_evac_failure_regions->contains(hr->hrm_index())) {\n-      hr->clear_index_in_opt_cset();\n+    hr->clear_index_in_opt_cset();\n@@ -179,2 +180,2 @@\n-      bool during_concurrent_start = _g1h->collector_state()->in_concurrent_start_gc();\n-      bool during_concurrent_mark = _g1h->collector_state()->mark_or_rebuild_in_progress();\n+    bool during_concurrent_start = _g1h->collector_state()->in_concurrent_start_gc();\n+    bool during_concurrent_mark = _g1h->collector_state()->mark_or_rebuild_in_progress();\n@@ -182,3 +183,2 @@\n-      hr->note_self_forwarding_removal_start(during_concurrent_start,\n-                                             during_concurrent_mark);\n-      _g1h->verifier()->check_bitmaps(\"Self-Forwarding Ptr Removal\", hr);\n+    hr->note_self_forwarding_removal_start(during_concurrent_start,\n+                                           during_concurrent_mark);\n@@ -186,1 +186,1 @@\n-      hr->reset_bot();\n+    hr->reset_bot();\n@@ -188,1 +188,1 @@\n-      size_t live_bytes = remove_self_forward_ptr_by_walking_hr(hr, during_concurrent_start);\n+    size_t live_bytes = remove_self_forward_ptr_by_walking_hr(hr, during_concurrent_start);\n@@ -190,2 +190,5 @@\n-      hr->rem_set()->clean_strong_code_roots(hr);\n-      hr->rem_set()->clear_locked(true);\n+    hr->rem_set()->clean_strong_code_roots(hr);\n+    hr->rem_set()->clear_locked(true);\n+\n+    hr->note_self_forwarding_removal_end(live_bytes);\n+    _g1h->verifier()->check_bitmaps(\"Self-Forwarding Ptr Removal\", hr);\n@@ -193,2 +196,0 @@\n-      hr->note_self_forwarding_removal_end(live_bytes);\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailure.cpp","additions":26,"deletions":25,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-#include \"utilities\/quickSort.hpp\"\n-\n-\n-const G1SegmentedArrayAllocOptions G1EvacFailureObjectsSet::_alloc_options =\n-  G1SegmentedArrayAllocOptions((uint)sizeof(OffsetInRegion), SegmentLength, UINT_MAX, Alignment);\n-\n-G1SegmentedArrayFreeList<mtGC> G1EvacFailureObjectsSet::_free_segment_list;\n-\n-#ifdef ASSERT\n-void G1EvacFailureObjectsSet::assert_is_valid_offset(size_t offset) const {\n-  const uint max_offset = 1u << (HeapRegion::LogOfHRGrainBytes - LogHeapWordSize);\n-  assert(offset < max_offset, \"must be, but is \" SIZE_FORMAT, offset);\n-}\n-#endif\n-\n-oop G1EvacFailureObjectsSet::from_offset(OffsetInRegion offset) const {\n-  assert_is_valid_offset(offset);\n-  return cast_to_oop(_bottom + offset);\n-}\n-\n-G1EvacFailureObjectsSet::OffsetInRegion G1EvacFailureObjectsSet::to_offset(oop obj) const {\n-  const HeapWord* o = cast_from_oop<const HeapWord*>(obj);\n-  size_t offset = pointer_delta(o, _bottom);\n-  assert(obj == from_offset(static_cast<OffsetInRegion>(offset)), \"must be\");\n-  return static_cast<OffsetInRegion>(offset);\n-}\n-\n-G1EvacFailureObjectsSet::G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom) :\n-  DEBUG_ONLY(_region_idx(region_idx) COMMA)\n-  _bottom(bottom),\n-  _offsets(&_alloc_options, &_free_segment_list)  {\n-  assert(HeapRegion::LogOfHRGrainBytes < 32, \"must be\");\n-}\n-\n-\/\/ Helper class to join, sort and iterate over the previously collected segmented\n-\/\/ array of objects that failed evacuation.\n-class G1EvacFailureObjectsIterationHelper {\n-  typedef G1EvacFailureObjectsSet::OffsetInRegion OffsetInRegion;\n-\n-  G1EvacFailureObjectsSet* _objects_set;\n-  const G1SegmentedArray<OffsetInRegion, mtGC>* _segments;\n-  OffsetInRegion* _offset_array;\n-  uint _array_length;\n-\n-  static int order_oop(OffsetInRegion a, OffsetInRegion b) {\n-    return static_cast<int>(a-b);\n-  }\n-\n-  void join_and_sort() {\n-    _segments->iterate_segments(*this);\n-\n-    QuickSort::sort(_offset_array, _array_length, order_oop, true);\n-  }\n-\n-  void iterate(ObjectClosure* closure) {\n-    for (uint i = 0; i < _array_length; i++) {\n-      oop cur = _objects_set->from_offset(_offset_array[i]);\n-      closure->do_object(cur);\n-    }\n-  }\n-\n-public:\n-  G1EvacFailureObjectsIterationHelper(G1EvacFailureObjectsSet* collector) :\n-    _objects_set(collector),\n-    _segments(&_objects_set->_offsets),\n-    _offset_array(nullptr),\n-    _array_length(0) { }\n-\n-  void process_and_drop(ObjectClosure* closure) {\n-    uint num = _segments->num_allocated_slots();\n-    _offset_array = NEW_C_HEAP_ARRAY(OffsetInRegion, num, mtGC);\n-\n-    join_and_sort();\n-    assert(_array_length == num, \"must be %u, %u\", _array_length, num);\n-    iterate(closure);\n-\n-    FREE_C_HEAP_ARRAY(OffsetInRegion, _offset_array);\n-  }\n-\n-  \/\/ Callback of G1SegmentedArray::iterate_segments\n-  void do_segment(G1SegmentedArraySegment<mtGC>* segment, uint length) {\n-    segment->copy_to(&_offset_array[_array_length]);\n-    _array_length += length;\n-  }\n-};\n-\n-void G1EvacFailureObjectsSet::process_and_drop(ObjectClosure* closure) {\n-  assert_at_safepoint();\n-\n-  G1EvacFailureObjectsIterationHelper helper(this);\n-  helper.process_and_drop(closure);\n-\n-  _offsets.drop_all();\n-}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.cpp","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n-#define SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n-\n-#include \"gc\/g1\/g1SegmentedArray.hpp\"\n-#include \"memory\/iterator.hpp\"\n-#include \"oops\/oop.hpp\"\n-\n-class G1EvacFailureObjectsIterationHelper;\n-\n-\/\/ This class collects addresses of objects that failed evacuation in a specific\n-\/\/ heap region.\n-\/\/ Provides sorted iteration of these objects for processing during the remove\n-\/\/ self forwards phase.\n-class G1EvacFailureObjectsSet {\n-  friend class G1EvacFailureObjectsIterationHelper;\n-\n-public:\n-  \/\/ Storage type of an object that failed evacuation within a region. Given\n-  \/\/ heap region size and possible object locations within a region, it is\n-  \/\/ sufficient to use an uint here to save some space instead of full pointers.\n-  typedef uint OffsetInRegion;\n-\n-private:\n-  static const uint SegmentLength = 256;\n-  static const uint Alignment = 4;\n-\n-  static const G1SegmentedArrayAllocOptions _alloc_options;\n-\n-  \/\/ This free list is shared among evacuation failure process in all regions.\n-  static G1SegmentedArrayFreeList<mtGC> _free_segment_list;\n-\n-  DEBUG_ONLY(const uint _region_idx;)\n-\n-  \/\/ Region bottom\n-  const HeapWord* _bottom;\n-\n-  \/\/ Offsets within region containing objects that failed evacuation.\n-  G1SegmentedArray<OffsetInRegion, mtGC> _offsets;\n-\n-  void assert_is_valid_offset(size_t offset) const NOT_DEBUG_RETURN;\n-  \/\/ Converts between an offset within a region and an oop address.\n-  oop from_offset(OffsetInRegion offset) const;\n-  OffsetInRegion to_offset(oop obj) const;\n-\n-public:\n-  G1EvacFailureObjectsSet(uint region_idx, HeapWord* bottom);\n-\n-  \/\/ Record an object that failed evacuation.\n-  inline void record(oop obj);\n-\n-  \/\/ Apply the given ObjectClosure to all objects that failed evacuation and\n-  \/\/ empties the list after processing.\n-  \/\/ Objects are passed in increasing address order.\n-  void process_and_drop(ObjectClosure* closure);\n-};\n-\n-\n-#endif \/\/SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.hpp","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Huawei and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n-#define SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n-\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n-#include \"gc\/g1\/g1CollectedHeap.hpp\"\n-#include \"gc\/g1\/g1SegmentedArray.inline.hpp\"\n-#include \"gc\/g1\/heapRegion.inline.hpp\"\n-\n-void G1EvacFailureObjectsSet::record(oop obj) {\n-  assert(obj != NULL, \"must be\");\n-  assert(_region_idx == G1CollectedHeap::heap()->heap_region_containing(obj)->hrm_index(), \"must be\");\n-  OffsetInRegion* e = _offsets.allocate();\n-  *e = to_offset(obj);\n-}\n-\n-#endif \/\/SHARE_GC_G1_G1EVACFAILUREOBJECTSSET_INLINE_HPP\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacFailureObjectsSet.inline.hpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -61,0 +61,5 @@\n+void G1FullGCCompactTask::G1CompactRegionClosure::clear_in_prev_bitmap(oop obj) {\n+  assert(_bitmap->is_marked(obj), \"Should only compact marked objects\");\n+  _bitmap->clear(obj);\n+}\n+\n@@ -64,1 +69,2 @@\n-    \/\/ Object not moving\n+    \/\/ Object not moving, but clear the mark to allow reuse of the bitmap.\n+    clear_in_prev_bitmap(obj);\n@@ -77,0 +83,3 @@\n+  \/\/ Clear the mark for the compacted object to allow reuse of the\n+  \/\/ bitmap without an additional clearing step.\n+  clear_in_prev_bitmap(obj);\n@@ -85,0 +94,7 @@\n+    \/\/ The compaction closure not only copies the object to the new\n+    \/\/ location, but also clears the bitmap for it. This is needed\n+    \/\/ for bitmap verification and to be able to use the prev_bitmap\n+    \/\/ for evacuation failures in the next young collection. Testing\n+    \/\/ showed that it was better overall to clear bit by bit, compared\n+    \/\/ to clearing the whole region at the end. This difference was\n+    \/\/ clearly seen for regions with few marks.\n@@ -87,5 +103,0 @@\n-    \/\/ Clear the liveness information for this region if necessary i.e. if we actually look at it\n-    \/\/ for bitmap verification. Otherwise it is sufficient that we move the TAMS to bottom().\n-    if (G1VerifyBitmaps) {\n-      collector()->mark_bitmap()->clear_region(hr);\n-    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-\n+    void clear_in_prev_bitmap(oop object);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  _mark_stats_cache.reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCMarker.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -619,3 +619,5 @@\n-    \/\/ Records evac failure objs, this will help speed up iteration\n-    \/\/ of these objs later in *remove self forward* phase of post evacuation.\n-    r->record_evac_failure_obj(old);\n+\n+    \/\/ Objects failing evacuation will turn into old objects since the regions\n+    \/\/ are relabeled as such. We mark the failing objects in the prev bitmap and\n+    \/\/ later use it to handle all failed objects.\n+    _g1h->mark_evac_failure_object(old, _worker_id);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  _cache(NULL),\n@@ -35,2 +34,0 @@\n-  _cache_hits(0),\n-  _cache_misses(0),\n@@ -42,0 +39,1 @@\n+  reset();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionMarkStatsCache.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1262,0 +1262,40 @@\n+  \/\/ Closure to clear the prev bitmap for any old region in the collection set.\n+  \/\/ This is needed to be able to use the bitmap for evacuation failure handling.\n+  class G1ClearBitmapClosure : public HeapRegionClosure {\n+    G1CollectedHeap* _g1h;\n+    void assert_bitmap_clear(HeapRegion* hr, const G1CMBitMap* bitmap) {\n+      assert(bitmap->get_next_marked_addr(hr->bottom(), hr->end()) == hr->end(),\n+             \"Bitmap should have no mark for young regions\");\n+    }\n+  public:\n+    G1ClearBitmapClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+\n+    bool do_heap_region(HeapRegion* hr) {\n+      assert(_g1h->is_in_cset(hr), \"Should only be used iterating the collection set\");\n+      \/\/ Young regions should always have cleared bitmaps, so only clear old.\n+      if (hr->is_old()) {\n+        _g1h->clear_prev_bitmap_for_region(hr);\n+      } else {\n+        assert(hr->is_young(), \"Should only be young and old regions in collection set\");\n+        assert_bitmap_clear(hr, _g1h->concurrent_mark()->prev_mark_bitmap());\n+      }\n+      return false;\n+    }\n+  };\n+\n+  \/\/ Helper to allow two closure to be applied when\n+  \/\/ iterating through the collection set.\n+  class G1CombinedClosure : public HeapRegionClosure {\n+    HeapRegionClosure* _closure1;\n+    HeapRegionClosure* _closure2;\n+  public:\n+    G1CombinedClosure(HeapRegionClosure* cl1, HeapRegionClosure* cl2) :\n+      _closure1(cl1),\n+      _closure2(cl2) { }\n+\n+    bool do_heap_region(HeapRegion* hr) {\n+      return _closure1->do_heap_region(hr) ||\n+             _closure2->do_heap_region(hr);\n+    }\n+  };\n+\n@@ -1429,3 +1469,6 @@\n-        G1MergeCardSetClosure cl(_scan_state);\n-        g1h->collection_set_iterate_increment_from(&cl, &_hr_claimer, worker_id);\n-        stats = cl.stats();\n+        G1MergeCardSetClosure merge(_scan_state);\n+        G1ClearBitmapClosure clear(g1h);\n+        G1CombinedClosure combined(&merge, &clear);\n+\n+        g1h->collection_set_iterate_increment_from(&combined, &_hr_claimer, worker_id);\n+        stats = merge.stats();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":46,"deletions":3,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -110,4 +110,0 @@\n-void HeapRegion::process_and_drop_evac_failure_objs(ObjectClosure* closure) {\n-  _evac_failure_objs.process_and_drop(closure);\n-}\n-\n@@ -249,2 +245,1 @@\n-  _node_index(G1NUMA::UnknownNodeIndex),\n-  _evac_failure_objs(hrm_index, _bottom)\n+  _node_index(G1NUMA::UnknownNodeIndex)\n@@ -658,0 +653,2 @@\n+  \/\/ We cast p to an oop, so region-bottom must be an obj-start.\n+  assert(!is_region_humongous || is_starts_humongous(), \"invariant\");\n@@ -739,5 +736,0 @@\n-void HeapRegion::verify() const {\n-  bool dummy = false;\n-  verify(VerifyOption_G1UsePrevMarking, \/* failures *\/ &dummy);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.hpp\"\n@@ -271,2 +270,0 @@\n-  G1EvacFailureObjectsSet _evac_failure_objs;\n-\n@@ -569,5 +566,0 @@\n-  \/\/ Record an object that failed evacuation within this region.\n-  void record_evac_failure_obj(oop obj);\n-  \/\/ Applies the given closure to all previously recorded objects\n-  \/\/ that failed evacuation in ascending address order.\n-  void process_and_drop_evac_failure_objs(ObjectClosure* closure);\n@@ -621,3 +613,0 @@\n-  \/\/ Verify using the \"prev\" marking information\n-  void verify() const;\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.hpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/g1\/g1EvacFailureObjectsSet.inline.hpp\"\n@@ -107,6 +106,2 @@\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-\n-  if (!this->is_in(p)) {\n-    assert(is_continues_humongous(), \"This case can only happen for humongous regions\");\n-    return (p == humongous_start_region()->bottom());\n-  }\n+  assert(p >= bottom() && p < top(), \"precondition\");\n+  assert(!is_continues_humongous(), \"p must point to block-start\");\n@@ -121,1 +116,1 @@\n-    return !g1h->is_obj_dead(cast_to_oop(p), this);\n+    return !G1CollectedHeap::heap()->is_obj_dead(cast_to_oop(p), this);\n@@ -123,1 +118,1 @@\n-  return p < top();\n+  return true;\n@@ -446,4 +441,0 @@\n-inline void HeapRegion::record_evac_failure_obj(oop obj) {\n-  _evac_failure_objs.record(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.inline.hpp","additions":4,"deletions":13,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -71,7 +71,1 @@\n-\n-  if (_raw_base == NULL) {\n-    vm_exit_during_initialization(\"Could not get raw_base address\");\n-  }\n-\n-  MemTracker::record_virtual_memory_type((address)_raw_base, mtGC);\n-\n+  assert(_raw_base != nullptr, \"set from the backing_store\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.cpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  \/\/ The committed (old-gen heap) virtual space this object-start-array covers.\n","filename":"src\/hotspot\/share\/gc\/parallel\/objectStartArray.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -648,2 +648,4 @@\n-  VirtualSpaceSummary old_summary(old->reserved().start(), old_committed_end, old->reserved().end());\n-  SpaceSummary old_space(old->reserved().start(), old_committed_end, old->used_in_bytes());\n+  HeapWord* old_reserved_start = old->reserved().start();\n+  HeapWord* old_reserved_end = old->reserved().end();\n+  VirtualSpaceSummary old_summary(old_reserved_start, old_committed_end, old_reserved_end);\n+  SpaceSummary old_space(old_reserved_start, old_committed_end, old->used_in_bytes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -58,3 +58,0 @@\n-  develop(uintx, GCWorkerDelayMillis, 0,                                    \\\n-          \"Delay in scheduling GC workers (in milliseconds)\")               \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallel_globals.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -168,1 +168,0 @@\n-  int dirty_card_count = 0;\n@@ -198,10 +197,0 @@\n-#ifdef ASSERT\n-    if (GCWorkerDelayMillis > 0) {\n-      \/\/ Delay 1 worker so that it proceeds after all the work\n-      \/\/ has been completed.\n-      if (stripe_number < 2) {\n-        os::naked_sleep(GCWorkerDelayMillis);\n-      }\n-    }\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCardTable.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -53,4 +53,0 @@\n-  \/\/ The old gen can grow to max_gen_size().  _reserve reflects only\n-  \/\/ the current maximum that can be committed.\n-  assert(_reserved.byte_size() <= max_gen_size(), \"Consistency check\");\n-\n@@ -72,11 +68,2 @@\n-  \/\/\n-  \/\/ Basic memory initialization\n-  \/\/\n-\n-  MemRegion limit_reserved((HeapWord*)virtual_space()->low_boundary(),\n-                           heap_word_size(max_gen_size()));\n-  assert(limit_reserved.byte_size() == max_gen_size(),\n-    \"word vs bytes confusion\");\n-  \/\/\n-  \/\/ Object start stuff\n-  \/\/\n+  MemRegion const reserved_mr = reserved();\n+  assert(reserved_mr.byte_size() == max_gen_size(), \"invariant\");\n@@ -84,1 +71,2 @@\n-  start_array()->initialize(limit_reserved);\n+  \/\/ Object start stuff: for all reserved memory\n+  start_array()->initialize(reserved_mr);\n@@ -86,2 +74,3 @@\n-  _reserved = MemRegion((HeapWord*)virtual_space()->low_boundary(),\n-                        (HeapWord*)virtual_space()->high_boundary());\n+  \/\/ Card table stuff: for all committed memory\n+  MemRegion committed_mr((HeapWord*)virtual_space()->low(),\n+                         (HeapWord*)virtual_space()->high());\n@@ -89,6 +78,0 @@\n-  \/\/\n-  \/\/ Card table stuff\n-  \/\/\n-\n-  MemRegion cmr((HeapWord*)virtual_space()->low(),\n-                (HeapWord*)virtual_space()->high());\n@@ -101,1 +84,1 @@\n-    SpaceMangler::mangle_region(cmr);\n+    SpaceMangler::mangle_region(committed_mr);\n@@ -106,1 +89,1 @@\n-  ct->resize_covered_region(cmr);\n+  ct->resize_covered_region(committed_mr);\n@@ -112,6 +95,4 @@\n-  guarantee(ct->is_card_aligned(_reserved.start()), \"generation must be card aligned\");\n-  if (_reserved.end() != heap->reserved_region().end()) {\n-    \/\/ Don't check at the very end of the heap as we'll assert that we're probing off\n-    \/\/ the end if we try.\n-    guarantee(ct->is_card_aligned(_reserved.end()), \"generation must be card aligned\");\n-  }\n+  guarantee(ct->is_card_aligned(reserved_mr.start()), \"generation must be card aligned\");\n+  \/\/ Check the heap layout documented at `class ParallelScavengeHeap`.\n+  assert(reserved_mr.end() != heap->reserved_region().end(), \"invariant\");\n+  guarantee(ct->is_card_aligned(reserved_mr.end()), \"generation must be card aligned\");\n@@ -124,1 +105,1 @@\n-  object_space()->initialize(cmr,\n+  object_space()->initialize(committed_mr,\n@@ -131,1 +112,1 @@\n-  start_array()->set_covered_region(cmr);\n+  start_array()->set_covered_region(committed_mr);\n@@ -317,1 +298,0 @@\n-  assert(max_gen_size() >= reserved().byte_size(), \"max new size problem?\");\n@@ -403,1 +383,0 @@\n-  PSOldGen* _old_gen;\n@@ -407,2 +386,2 @@\n-  VerifyObjectStartArrayClosure(PSOldGen* old_gen, ObjectStartArray* start_array) :\n-    _old_gen(old_gen), _start_array(start_array) { }\n+  VerifyObjectStartArrayClosure(ObjectStartArray* start_array) :\n+    _start_array(start_array) { }\n@@ -418,1 +397,1 @@\n-  VerifyObjectStartArrayClosure check( this, &_start_array );\n+  VerifyObjectStartArrayClosure check(&_start_array);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.cpp","additions":18,"deletions":39,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-\n@@ -39,1 +38,0 @@\n-  MemRegion                _reserved;          \/\/ Used for simple containment tests\n@@ -102,1 +100,5 @@\n-  MemRegion reserved() const { return _reserved; }\n+  MemRegion reserved() const {\n+    return MemRegion((HeapWord*)(_virtual_space->low_boundary()),\n+                     (HeapWord*)(_virtual_space->high_boundary()));\n+  }\n+\n@@ -107,1 +109,1 @@\n-    return _virtual_space->contains((void *)p);\n+    return _virtual_space->is_in_committed((void *)p);\n@@ -111,1 +113,1 @@\n-    return reserved().contains(p);\n+    return _virtual_space->is_in_reserved(p);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psOldGen.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1044,1 +1044,1 @@\n-    ct->clear(MemRegion(old_mr.start(), old_mr.end()));\n+    ct->clear(old_mr);\n@@ -1046,1 +1046,1 @@\n-    ct->invalidate(MemRegion(old_mr.start(), old_mr.end()));\n+    ct->invalidate(old_mr);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-size_t PSPromotionLAB::filler_header_size;\n-\n@@ -48,4 +46,0 @@\n-  \/\/ Initialize after VM starts up because header_size depends on compressed\n-  \/\/ oops.\n-  filler_header_size = align_object_size(typeArrayOopDesc::header_size(T_INT));\n-\n@@ -59,2 +53,2 @@\n-    assert(lab.word_size() >= filler_header_size, \"lab is too small\");\n-    end = end - filler_header_size;\n+    assert(lab.word_size() >= CollectedHeap::min_dummy_object_size(), \"lab is too small\");\n+    end = end - CollectedHeap::min_dummy_object_size();\n@@ -84,14 +78,2 @@\n-  HeapWord* tlab_end = end() + filler_header_size;\n-  typeArrayOop filler_oop = (typeArrayOop) cast_to_oop(top());\n-  filler_oop->set_mark(markWord::prototype());\n-  filler_oop->set_klass(Universe::intArrayKlassObj());\n-  const size_t array_length =\n-    pointer_delta(tlab_end, top()) - typeArrayOopDesc::header_size(T_INT);\n-  assert( (array_length * (HeapWordSize\/sizeof(jint))) < (size_t)max_jint, \"array too big in PSPromotionLAB\");\n-  filler_oop->set_length((int)(array_length * (HeapWordSize\/sizeof(jint))));\n-\n-#ifdef ASSERT\n-  \/\/ Note that we actually DO NOT want to use the aligned header size!\n-  HeapWord* elt_words = cast_from_oop<HeapWord*>(filler_oop) + typeArrayOopDesc::header_size(T_INT);\n-  Copy::fill_to_words(elt_words, array_length, 0xDEAABABE);\n-#endif\n+  HeapWord* tlab_end = end() + CollectedHeap::min_dummy_object_size();\n+  CollectedHeap::fill_with_object(top(), tlab_end, trueInDebug);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.cpp","additions":4,"deletions":22,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -42,2 +42,0 @@\n-  static size_t filler_header_size;\n-\n@@ -109,1 +107,0 @@\n-  PSOldPromotionLAB(ObjectStartArray* start_array) : _start_array(start_array) { }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionLAB.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -222,7 +222,0 @@\n-#ifdef ASSERT\n-            \/\/ Delay the initialization of the promotion lab (plab).\n-            \/\/ This exposes uninitialized plabs to card table processing.\n-            if (GCWorkerDelayMillis > 0) {\n-              os::naked_sleep(GCWorkerDelayMillis);\n-            }\n-#endif\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -69,5 +69,0 @@\n-bool PSVirtualSpace::contains(void* p) const {\n-  char* const cp = (char*)p;\n-  return cp >= committed_low_addr() && cp < committed_high_addr();\n-}\n-\n@@ -146,7 +141,3 @@\n-  if (grows_up()) {\n-    assert(reserved_low_addr() == committed_low_addr(), \"bad low addrs\");\n-    assert(reserved_high_addr() >= committed_high_addr(), \"bad high addrs\");\n-  } else {\n-    assert(reserved_high_addr() == committed_high_addr(), \"bad high addrs\");\n-    assert(reserved_low_addr() <= committed_low_addr(), \"bad low addrs\");\n-  }\n+  \/\/ committed addr grows up\n+  assert(reserved_low_addr() == committed_low_addr(), \"bad low addrs\");\n+  assert(reserved_high_addr() >= committed_high_addr(), \"bad high addrs\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -78,1 +78,7 @@\n-  bool contains(void* p)      const;\n+  bool is_in_committed(const void* p) const {\n+    return (p >= committed_low_addr()) && (p < committed_high_addr());\n+  }\n+\n+  bool is_in_reserved(const void* p) const {\n+    return (p >= reserved_low_addr()) && (p < reserved_high_addr());\n+  }\n@@ -88,0 +94,1 @@\n+  \/\/ Return size in bytes\n@@ -106,2 +113,0 @@\n-  virtual bool grows_up() const   { return true; }\n-          bool grows_down() const { return !grows_up(); }\n","filename":"src\/hotspot\/share\/gc\/parallel\/psVirtualspace.hpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    return _virtual_space->contains((void *)p);\n+    return _virtual_space->is_in_committed(p);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psYoungGen.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-  nonstatic_field(PSOldGen,                    _reserved,                                     MemRegion)                             \\\n","filename":"src\/hotspot\/share\/gc\/parallel\/vmStructs_parallelgc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -496,4 +496,0 @@\n-size_t CollectedHeap::min_dummy_object_size() const {\n-  return oopDesc::header_size();\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -292,1 +292,4 @@\n-  virtual size_t min_dummy_object_size() const;\n+  static constexpr size_t min_dummy_object_size() {\n+    return oopDesc::header_size();\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -97,3 +97,0 @@\n-  \/\/ Allocate the object aligned to \"alignment_in_bytes\".\n-  inline HeapWord* allocate_aligned(size_t word_sz, unsigned short alignment_in_bytes);\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-    id = WorkerThread::current()->id();\n+    id = WorkerThread::worker_id();\n","filename":"src\/hotspot\/share\/gc\/shared\/referenceProcessor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -733,32 +733,0 @@\n-void ContiguousSpace::allocate_temporary_filler(int factor) {\n-  \/\/ allocate temporary type array decreasing free size with factor 'factor'\n-  assert(factor >= 0, \"just checking\");\n-  size_t size = pointer_delta(end(), top());\n-\n-  \/\/ if space is full, return\n-  if (size == 0) return;\n-\n-  if (factor > 0) {\n-    size -= size\/factor;\n-  }\n-  size = align_object_size(size);\n-\n-  const size_t array_header_size = typeArrayOopDesc::header_size(T_INT);\n-  if (size >= align_object_size(array_header_size)) {\n-    size_t length = (size - array_header_size) * (HeapWordSize \/ sizeof(jint));\n-    \/\/ allocate uninitialized int array\n-    typeArrayOop t = (typeArrayOop) cast_to_oop(allocate(size));\n-    assert(t != NULL, \"allocation should succeed\");\n-    t->set_mark(markWord::prototype());\n-    t->set_klass(Universe::intArrayKlassObj());\n-    t->set_length((int)length);\n-  } else {\n-    assert(size == CollectedHeap::min_fill_size(),\n-           \"size for smallest fake object doesn't match\");\n-    instanceOop obj = (instanceOop) cast_to_oop(allocate(size));\n-    obj->set_mark(markWord::prototype());\n-    obj->set_klass_gap(0);\n-    obj->set_klass(vmClasses::Object_klass());\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -535,4 +535,0 @@\n-\n-  \/\/ Used to increase collection frequency.  \"factor\" of 0 means entire\n-  \/\/ space.\n-  void allocate_temporary_filler(int factor);\n","filename":"src\/hotspot\/share\/gc\/shared\/space.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  \/\/ Get worker id.\n+  \/\/ Get and set worker id.\n@@ -64,0 +64,1 @@\n+  WorkerThread::set_worker_id(worker_id);\n@@ -94,1 +95,1 @@\n-WorkerThread* WorkerThreads::create_worker(uint id) {\n+WorkerThread* WorkerThreads::create_worker(uint name_suffix) {\n@@ -99,1 +100,1 @@\n-  WorkerThread* const worker = new WorkerThread(_name, id, &_dispatcher);\n+  WorkerThread* const worker = new WorkerThread(_name, name_suffix, &_dispatcher);\n@@ -106,0 +107,2 @@\n+  on_create_worker(worker);\n+\n@@ -149,4 +152,5 @@\n-WorkerThread::WorkerThread(const char* name_prefix, uint id, WorkerTaskDispatcher* dispatcher) :\n-    _dispatcher(dispatcher),\n-    _id(id) {\n-  set_name(\"%s#%d\", name_prefix, id);\n+THREAD_LOCAL uint WorkerThread::_worker_id = UINT_MAX;\n+\n+WorkerThread::WorkerThread(const char* name_prefix, uint name_suffix, WorkerTaskDispatcher* dispatcher) :\n+    _dispatcher(dispatcher) {\n+  set_name(\"%s#%u\", name_prefix, name_suffix);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -94,0 +94,2 @@\n+  WorkerThread* create_worker(uint name_suffix);\n+\n@@ -95,1 +97,1 @@\n-  virtual WorkerThread* create_worker(uint id);\n+  virtual void on_create_worker(WorkerThread* worker) {}\n@@ -120,0 +122,2 @@\n+  friend class WorkerTaskDispatcher;\n+\n@@ -121,2 +125,1 @@\n-  WorkerTaskDispatcher* const _dispatcher;\n-  const uint                  _id;\n+  static THREAD_LOCAL uint _worker_id;\n@@ -124,4 +127,1 @@\n-public:\n-  static WorkerThread* current() {\n-    return WorkerThread::cast(Thread::current());\n-  }\n+  WorkerTaskDispatcher* const _dispatcher;\n@@ -129,4 +129,1 @@\n-  static WorkerThread* cast(Thread* t) {\n-    assert(t->is_Worker_thread(), \"incorrect cast to WorkerThread\");\n-    return static_cast<WorkerThread*>(t);\n-  }\n+  static void set_worker_id(uint worker_id) { _worker_id = worker_id; }\n@@ -134,1 +131,2 @@\n-  WorkerThread(const char* name_prefix, uint id, WorkerTaskDispatcher* dispatcher);\n+public:\n+  static uint worker_id() { return _worker_id; }\n@@ -136,1 +134,1 @@\n-  uint id() const                        { return _id; }\n+  WorkerThread(const char* name_prefix, uint which, WorkerTaskDispatcher* dispatcher);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -68,12 +68,2 @@\n-  if (ShenandoahGCHeuristics != NULL) {\n-    if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-      return new ShenandoahAggressiveHeuristics();\n-    } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-      return new ShenandoahStaticHeuristics();\n-    } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-      return new ShenandoahAdaptiveHeuristics();\n-    } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-      return new ShenandoahCompactHeuristics();\n-    } else {\n-      vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-    }\n+  if (ShenandoahGCHeuristics == NULL) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n@@ -81,1 +71,10 @@\n-  ShouldNotReachHere();\n+  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+    return new ShenandoahAggressiveHeuristics();\n+  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+    return new ShenandoahStaticHeuristics();\n+  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+    return new ShenandoahAdaptiveHeuristics();\n+  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+    return new ShenandoahCompactHeuristics();\n+  }\n+  vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahIUMode.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -58,2 +59,2 @@\n-  if (ShenandoahGCHeuristics != NULL) {\n-    return new ShenandoahPassiveHeuristics();\n+  if (ShenandoahGCHeuristics == NULL) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n@@ -61,2 +62,1 @@\n-  ShouldNotReachHere();\n-  return NULL;\n+  return new ShenandoahPassiveHeuristics();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahPassiveMode.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -56,12 +56,2 @@\n-  if (ShenandoahGCHeuristics != NULL) {\n-    if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n-      return new ShenandoahAggressiveHeuristics();\n-    } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n-      return new ShenandoahStaticHeuristics();\n-    } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n-      return new ShenandoahAdaptiveHeuristics();\n-    } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n-      return new ShenandoahCompactHeuristics();\n-    } else {\n-      vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n-    }\n+  if (ShenandoahGCHeuristics == NULL) {\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option (null)\");\n@@ -69,1 +59,10 @@\n-  ShouldNotReachHere();\n+  if (strcmp(ShenandoahGCHeuristics, \"aggressive\") == 0) {\n+    return new ShenandoahAggressiveHeuristics();\n+  } else if (strcmp(ShenandoahGCHeuristics, \"static\") == 0) {\n+    return new ShenandoahStaticHeuristics();\n+  } else if (strcmp(ShenandoahGCHeuristics, \"adaptive\") == 0) {\n+    return new ShenandoahAdaptiveHeuristics();\n+  } else if (strcmp(ShenandoahGCHeuristics, \"compact\") == 0) {\n+    return new ShenandoahCompactHeuristics();\n+  }\n+  vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCHeuristics option\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/mode\/shenandoahSATBMode.cpp","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -419,1 +419,1 @@\n-    ShouldNotReachHere();\n+    vm_exit_during_initialization(\"Unknown -XX:ShenandoahGCMode option (null)\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -340,1 +341,0 @@\n-  assert(worker_id != ShenandoahThreadLocalData::INVALID_WORKER_ID, \"need valid worker ID\");\n@@ -364,1 +364,1 @@\n-  uint worker_id = ShenandoahThreadLocalData::worker_id(Thread::current());\n+  uint worker_id = WorkerThread::worker_id();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -95,23 +95,0 @@\n-ShenandoahRootScanner::ShenandoahRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase) :\n-  ShenandoahRootProcessor(phase),\n-  _thread_roots(phase, n_workers > 1) {\n-  nmethod::oops_do_marking_prologue();\n-}\n-\n-ShenandoahRootScanner::~ShenandoahRootScanner() {\n-  nmethod::oops_do_marking_epilogue();\n-}\n-\n-void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops) {\n-  MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);\n-  roots_do(worker_id, oops, &blobs_cl);\n-}\n-\n-void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops, CodeBlobClosure* code, ThreadClosure *tc) {\n-  assert(ShenandoahSafepoint::is_at_shenandoah_safepoint(), \"Must be at a safepoint\");\n-\n-  ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);\n-  ResourceMark rm;\n-  _thread_roots.threads_do(&tc_cl, worker_id);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":0,"deletions":23,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -145,14 +145,0 @@\n-class ShenandoahRootScanner : public ShenandoahRootProcessor {\n-private:\n-  ShenandoahThreadRoots                                     _thread_roots;\n-\n-public:\n-  ShenandoahRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase);\n-  ~ShenandoahRootScanner();\n-\n-  void roots_do(uint worker_id, OopClosure* cl);\n-\n-private:\n-  void roots_do(uint worker_id, OopClosure* oops, CodeBlobClosure* code, ThreadClosure* tc = NULL);\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":0,"deletions":14,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,3 +39,0 @@\n-public:\n-  static const uint INVALID_WORKER_ID = uint(-1);\n-\n@@ -50,1 +47,0 @@\n-  uint  _worker_id;\n@@ -61,1 +57,0 @@\n-    _worker_id(INVALID_WORKER_ID),\n@@ -106,10 +101,0 @@\n-  static void set_worker_id(Thread* thread, uint id) {\n-    assert(thread->is_Worker_thread(), \"Must be a worker thread\");\n-    data(thread)->_worker_id = id;\n-  }\n-\n-  static uint worker_id(Thread* thread) {\n-    assert(thread->is_Worker_thread(), \"Must be a worker thread\");\n-    return data(thread)->_worker_id;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -149,4 +149,2 @@\n-ShenandoahWorkerSession::ShenandoahWorkerSession(uint worker_id) : _worker_id(worker_id) {\n-  Thread* thr = Thread::current();\n-  assert(ShenandoahThreadLocalData::worker_id(thr) == ShenandoahThreadLocalData::INVALID_WORKER_ID, \"Already set\");\n-  ShenandoahThreadLocalData::set_worker_id(thr, worker_id);\n+ShenandoahWorkerSession::ShenandoahWorkerSession(uint worker_id) {\n+  assert(worker_id == WorkerThread::worker_id(), \"Wrong worker id\");\n@@ -160,8 +158,1 @@\n-  _event.commit(GCId::current(), _worker_id, ShenandoahPhaseTimings::phase_name(ShenandoahGCPhase::current_phase()));\n-}\n-ShenandoahWorkerSession::~ShenandoahWorkerSession() {\n-#ifdef ASSERT\n-  Thread* thr = Thread::current();\n-  assert(ShenandoahThreadLocalData::worker_id(thr) != ShenandoahThreadLocalData::INVALID_WORKER_ID, \"Must be set\");\n-  ShenandoahThreadLocalData::set_worker_id(thr, ShenandoahThreadLocalData::INVALID_WORKER_ID);\n-#endif\n+  _event.commit(GCId::current(), WorkerThread::worker_id(), ShenandoahPhaseTimings::phase_name(ShenandoahGCPhase::current_phase()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2021, Red Hat, Inc. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/workerThread.hpp\"\n@@ -176,2 +177,0 @@\n-  uint _worker_id;\n-\n@@ -179,1 +178,0 @@\n-  ~ShenandoahWorkerSession();\n@@ -182,4 +180,1 @@\n-    Thread* thr = Thread::current();\n-    uint id = ShenandoahThreadLocalData::worker_id(thr);\n-    assert(id != ShenandoahThreadLocalData::INVALID_WORKER_ID, \"Worker session has not been created\");\n-    return id;\n+    return WorkerThread::worker_id();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n-WorkerThread* ShenandoahWorkerThreads::create_worker(uint id) {\n-  WorkerThread* worker = WorkerThreads::create_worker(id);\n+void ShenandoahWorkerThreads::on_create_worker(WorkerThread* worker) {\n@@ -80,1 +79,0 @@\n-  return worker;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-  \/\/ Create a GC worker.\n@@ -65,1 +64,1 @@\n-  WorkerThread* create_worker(uint id);\n+  void on_create_worker(WorkerThread* worker);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahWorkGroup.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -137,0 +137,3 @@\n+#ifdef AMD64\n+      case vmIntrinsics::_currentThread:     return java_lang_Thread_currentThread;\n+#endif\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    java_lang_Thread_currentThread,                             \/\/ implementation of java.lang.Thread.currentThread()\n","filename":"src\/hotspot\/share\/interpreter\/abstractInterpreter.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1032,1 +1032,0 @@\n-      \/\/ The return type of arraylength is wrong in the bytecodes table (T_VOID).\n","filename":"src\/hotspot\/share\/interpreter\/bytecodeUtils.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -474,1 +474,1 @@\n-  def(_arraylength         , \"arraylength\"         , \"b\"    , NULL    , T_VOID   ,  0, true );\n+  def(_arraylength         , \"arraylength\"         , \"b\"    , NULL    , T_INT    ,  0, true );\n","filename":"src\/hotspot\/share\/interpreter\/bytecodes.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -204,1 +204,3 @@\n-\n+#ifdef AMD64\n+  method_entry(java_lang_Thread_currentThread)\n+#endif\n@@ -434,0 +436,5 @@\n+#ifdef AMD64\n+  case Interpreter::java_lang_Thread_currentThread\n+                                           : entry_point = generate_currentThread(); break;\n+#endif\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -97,0 +97,3 @@\n+#ifdef AMD64\n+  address generate_currentThread();\n+#endif\n","filename":"src\/hotspot\/share\/interpreter\/templateInterpreterGenerator.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-static int thread_id_offset = invalid_offset;\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -561,2 +561,2 @@\n-  declare_constant(Deoptimization::Reason_LIMIT)                          \\\n-  declare_constant(Deoptimization::_support_large_access_byte_array_virtualization)               \\\n+  declare_constant(Deoptimization::Reason_TRAP_HISTORY_LENGTH)            \\\n+  declare_constant(Deoptimization::_support_large_access_byte_array_virtualization) \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -256,2 +256,1 @@\n-    _misc_has_resolved_methods                = 1 << 13, \/\/ resolved methods table entries added for this class\n-    _misc_has_contended_annotations           = 1 << 14  \/\/ has @Contended annotation\n+    _misc_has_contended_annotations           = 1 << 13  \/\/ has @Contended annotation\n@@ -369,4 +368,0 @@\n-  void clear_shared_loading_failed() {\n-    _misc_flags &= ~_misc_shared_loading_failed;\n-  }\n-\n@@ -381,0 +376,1 @@\n+    assert(!has_nonstatic_fields(), \"set once\");\n@@ -383,2 +379,0 @@\n-    } else {\n-      _misc_flags &= ~_misc_has_nonstatic_fields;\n@@ -566,0 +560,1 @@\n+    assert(!should_verify_class(), \"set once\");\n@@ -568,2 +563,0 @@\n-    } else {\n-      _misc_flags &= ~_misc_should_verify_class;\n@@ -698,0 +691,1 @@\n+    assert(!is_contended(), \"set once\");\n@@ -700,2 +694,0 @@\n-    } else {\n-      _misc_flags &= ~_misc_is_contended;\n@@ -736,0 +728,1 @@\n+    assert(!has_contended_annotations(), \"set once\");\n@@ -738,2 +731,0 @@\n-    } else {\n-      _misc_flags &= ~_misc_has_contended_annotations;\n@@ -792,1 +783,1 @@\n-    return (_misc_flags & _misc_has_resolved_methods) != 0;\n+    return _access_flags.has_resolved_methods();\n@@ -796,1 +787,1 @@\n-    _misc_flags |= _misc_has_resolved_methods;\n+    _access_flags.set_has_resolved_methods();\n@@ -865,0 +856,1 @@\n+    assert(!has_nonstatic_concrete_methods(), \"set once\");\n@@ -867,2 +859,0 @@\n-    } else {\n-      _misc_flags &= ~_misc_has_nonstatic_concrete_methods;\n@@ -876,0 +866,1 @@\n+    assert(!declares_nonstatic_concrete_methods(), \"set once\");\n@@ -878,2 +869,0 @@\n-    } else {\n-      _misc_flags &= ~_misc_declares_nonstatic_concrete_methods;\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -120,2 +120,2 @@\n-  \/\/ vtable length\n-  int _vtable_len;\n+  \/\/ Processed access flags, for use by Class.getModifiers.\n+  jint        _modifier_flags;\n@@ -157,1 +157,4 @@\n-  jint        _modifier_flags;  \/\/ Processed access flags, for use by Class.getModifiers.\n+  int _vtable_len;              \/\/ vtable length. This field may be read very often when we\n+                                \/\/ have lots of itable dispatches (e.g., lambdas and streams).\n+                                \/\/ Keep it away from the beginning of a Klass to avoid cacheline\n+                                \/\/ contention that may happen when a nearby object is modified.\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -34,4 +34,1 @@\n-\/\/ This loads the klass's holder as a phantom. This is useful when a weak Klass\n-\/\/ pointer has been \"peeked\" and then must be kept alive before it may\n-\/\/ be used safely.  All uses of klass_holder need to apply the appropriate barriers,\n-\/\/ except during GC.\n+\/\/ This loads and keeps the klass's loader alive.\n@@ -39,1 +36,1 @@\n-  return class_loader_data()->holder_phantom();\n+  return class_loader_data()->holder();\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/deoptimization.hpp\"\n@@ -1968,1 +1969,1 @@\n-    _trap_hist_limit    = 25 JVMCI_ONLY(+5),   \/\/ decoupled from Deoptimization::Reason_LIMIT\n+    _trap_hist_limit    = Deoptimization::Reason_TRAP_HISTORY_LENGTH,\n@@ -1983,0 +1984,1 @@\n+      \/\/ JVMCI separates trap history for OSR compilations from normal compilations\n@@ -1999,1 +2001,1 @@\n-      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      assert((uint)reason < ARRAY_SIZE(_trap_hist._array), \"oob\");\n@@ -2006,1 +2008,1 @@\n-      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      assert((uint)reason < ARRAY_SIZE(_trap_hist._array), \"oob\");\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-  static int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n+  static constexpr int header_size() { return sizeof(oopDesc)\/HeapWordSize; }\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,10 +305,0 @@\n-    \/\/ Convert \"(a-b)+(b-c)\" into \"(a-c)\"\n-    if (op2 == Op_Sub(bt) && in1->in(2) == in2->in(1)) {\n-      assert(in1->in(1) != this && in2->in(2) != this,\"dead loop in AddINode::Ideal\/AddLNode::Ideal\");\n-      return SubNode::make(in1->in(1), in2->in(2), bt);\n-    }\n-    \/\/ Convert \"(a-b)+(c-a)\" into \"(c-b)\"\n-    if (op2 == Op_Sub(bt) && in1->in(1) == in2->in(2)) {\n-      assert(in1->in(2) != this && in2->in(1) != this,\"dead loop in AddINode::Ideal\/AddLNode::Ideal\");\n-      return SubNode::make(in2->in(1), in1->in(2), bt);\n-    }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -51,0 +51,3 @@\n+const char* C2Compiler::retry_no_iterative_escape_analysis() {\n+  return \"retry without iterative escape analysis\";\n+}\n@@ -102,0 +105,1 @@\n+  bool do_iterative_escape_analysis = DoEscapeAnalysis;\n@@ -107,1 +111,1 @@\n-    Options options(subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n+    Options options(subsume_loads, do_escape_analysis, do_iterative_escape_analysis, eliminate_boxing, do_locks_coarsening, install_code);\n@@ -128,0 +132,6 @@\n+      if (C.failure_reason_is(retry_no_iterative_escape_analysis())) {\n+        assert(do_iterative_escape_analysis, \"must make progress\");\n+        do_iterative_escape_analysis = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -693,1 +703,1 @@\n-  case vmIntrinsics::_VectorBroadcastCoerced:\n+  case vmIntrinsics::_VectorFromBitsCoerced:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  static const char* retry_no_iterative_escape_analysis();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -431,0 +431,1 @@\n+macro(VectorLongToMask)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -502,0 +502,6 @@\n+  if (do_iterative_escape_analysis() != DoEscapeAnalysis && PrintOpto) {\n+    \/\/ Recompiling without iterative escape analysis\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without iterative escape analysis**\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -2164,7 +2170,3 @@\n-    ConnectionGraph::do_analysis(this, &igvn);\n-\n-    if (failing())  return;\n-\n-    \/\/ Optimize out fields loads from scalar replaceable allocations.\n-    igvn.optimize();\n-    print_method(PHASE_ITER_GVN_AFTER_EA, 2);\n+    bool progress;\n+    do {\n+      ConnectionGraph::do_analysis(this, &igvn);\n@@ -2172,1 +2174,1 @@\n-    if (failing())  return;\n+      if (failing())  return;\n@@ -2174,5 +2176,1 @@\n-    if (congraph() != NULL && macro_count() > 0) {\n-      TracePhase tp(\"macroEliminate\", &timers[_t_macroEliminate]);\n-      PhaseMacroExpand mexp(igvn);\n-      mexp.eliminate_macro_nodes();\n-      igvn.set_delay_transform(false);\n+      int mcount = macro_count(); \/\/ Record number of allocations and locks before IGVN\n@@ -2180,0 +2178,1 @@\n+      \/\/ Optimize out fields loads from scalar replaceable allocations.\n@@ -2181,1 +2180,1 @@\n-      print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);\n+      print_method(PHASE_ITER_GVN_AFTER_EA, 2);\n@@ -2184,1 +2183,18 @@\n-    }\n+\n+      if (congraph() != NULL && macro_count() > 0) {\n+        TracePhase tp(\"macroEliminate\", &timers[_t_macroEliminate]);\n+        PhaseMacroExpand mexp(igvn);\n+        mexp.eliminate_macro_nodes();\n+        igvn.set_delay_transform(false);\n+\n+        igvn.optimize();\n+        print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);\n+\n+        if (failing())  return;\n+      }\n+      progress = do_iterative_escape_analysis() &&\n+                 (macro_count() < mcount) &&\n+                 ConnectionGraph::has_candidates(this);\n+      \/\/ Try again if candidates exist and made progress\n+      \/\/ by removing some allocations and\/or locks.\n+    } while (progress);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -171,0 +171,1 @@\n+  const bool _do_iterative_escape_analysis;  \/\/ Do iterative escape analysis.\n@@ -176,0 +177,1 @@\n+          bool do_iterative_escape_analysis,\n@@ -180,0 +182,1 @@\n+          _do_iterative_escape_analysis(do_iterative_escape_analysis),\n@@ -189,0 +192,1 @@\n+       \/* do_iterative_escape_analysis = *\/ false,\n@@ -537,0 +541,1 @@\n+  bool              do_iterative_escape_analysis() const  { return _options._do_iterative_escape_analysis; }\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-ConnectionGraph::ConnectionGraph(Compile * C, PhaseIterGVN *igvn) :\n+ConnectionGraph::ConnectionGraph(Compile * C, PhaseIterGVN *igvn, int invocation) :\n@@ -52,0 +52,3 @@\n+  _invocation(invocation),\n+  _build_iterations(0),\n+  _build_time(0.),\n@@ -99,1 +102,5 @@\n-  ConnectionGraph* congraph = new(C->comp_arena()) ConnectionGraph(C, igvn);\n+  int invocation = 0;\n+  if (C->congraph() != NULL) {\n+    invocation = C->congraph()->_invocation + 1;\n+  }\n+  ConnectionGraph* congraph = new(C->comp_arena()) ConnectionGraph(C, igvn, invocation);\n@@ -1329,2 +1336,2 @@\n-    assert(ExitEscapeAnalysisOnTimeout, \"infinite EA connection graph build (%f sec, %d iterations) with %d nodes and worklist size %d\",\n-           _build_time, _build_iterations, nodes_size(), ptnodes_worklist.length());\n+    assert(ExitEscapeAnalysisOnTimeout, \"infinite EA connection graph build during invocation %d (%f sec, %d iterations) with %d nodes and worklist size %d\",\n+           _invocation, _build_time, _build_iterations, nodes_size(), ptnodes_worklist.length());\n@@ -1335,6 +1342,0 @@\n-#ifdef ASSERT\n-  if (Verbose && PrintEscapeAnalysis) {\n-    tty->print_cr(\"EA: %d iterations and %f sec to build connection graph with %d nodes and worklist size %d\",\n-                  _build_iterations, _build_time, nodes_size(), ptnodes_worklist.length());\n-  }\n-#endif\n@@ -2648,1 +2649,1 @@\n-      C->record_failure(C2Compiler::retry_no_escape_analysis());\n+      C->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n@@ -3219,1 +3220,1 @@\n-        _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n+        _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n@@ -3239,1 +3240,1 @@\n-        _compile->record_failure(C2Compiler::retry_no_escape_analysis());\n+        _compile->record_failure(_invocation > 0 ? C2Compiler::retry_no_iterative_escape_analysis() : C2Compiler::retry_no_escape_analysis());\n@@ -3695,0 +3696,3 @@\n+        tty->print_cr(\"invocation #%d: %d iterations and %f sec to build connection graph with %d nodes and worklist size %d\",\n+                      _invocation, _build_iterations, _build_time, nodes_size(), ptnodes_worklist.length());\n+        tty->cr();\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":17,"deletions":13,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -343,0 +343,1 @@\n+  int              _invocation; \/\/ Current number of analysis invocation\n@@ -572,1 +573,1 @@\n-  ConnectionGraph(Compile *C, PhaseIterGVN *igvn);\n+  ConnectionGraph(Compile *C, PhaseIterGVN *igvn, int iteration);\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -655,2 +655,2 @@\n-  case vmIntrinsics::_VectorBroadcastCoerced:\n-    return inline_vector_broadcast_coerced();\n+  case vmIntrinsics::_VectorFromBitsCoerced:\n+    return inline_vector_frombits_coerced();\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  bool inline_vector_broadcast_coerced();\n+  bool inline_vector_frombits_coerced();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  if (AndIL_shift_and_mask(phase, in(2), in(1), T_INT)) {\n+  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_INT, true)) {\n@@ -556,0 +556,6 @@\n+  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+\n@@ -610,6 +616,0 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_INT);\n-  if (progress != NULL) {\n-    return progress;\n-  }\n-\n@@ -649,1 +649,1 @@\n-  if (AndIL_shift_and_mask(phase, in(2), in(1), T_LONG)) {\n+  if (AndIL_shift_and_mask_is_always_zero(phase, in(1), in(2), T_LONG, true)) {\n@@ -696,0 +696,6 @@\n+  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n+  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n+  if (progress != NULL) {\n+    return progress;\n+  }\n+\n@@ -732,6 +738,0 @@\n-  \/\/ pattern similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-  Node* progress = AndIL_add_shift_and_mask(phase, T_LONG);\n-  if (progress != NULL) {\n-    return progress;\n-  }\n-\n@@ -1717,5 +1717,14 @@\n-\/\/ Helper method to transform:\n-\/\/ patterns similar to (v << 2) & 3 to 0\n-\/\/ and\n-\/\/ patterns similar to (v1 + (v2 << 2)) & 3 transformed to v1 & 3\n-bool MulNode::AndIL_shift_and_mask(PhaseGVN* phase, Node* mask, Node* shift, BasicType bt) {\n+\/\/ Given an expression (AndX shift mask) or (AndX mask shift),\n+\/\/ determine if the AndX must always produce zero, because the\n+\/\/ the shift (x<<N) is bitwise disjoint from the mask #M.\n+\/\/ The X in AndX must be I or L, depending on bt.\n+\/\/ Specifically, the following cases fold to zero,\n+\/\/ when the shift value N is large enough to zero out\n+\/\/ all the set positions of the and-mask M.\n+\/\/   (AndI (LShiftI _ #N) #M) => #0\n+\/\/   (AndL (LShiftL _ #N) #M) => #0\n+\/\/   (AndL (ConvI2L (LShiftI _ #N)) #M) => #0\n+\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n+\/\/ Because the optimization might work for a non-constant\n+\/\/ mask M, we check the AndX for both operand orders.\n+bool MulNode::AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse) {\n@@ -1730,1 +1739,2 @@\n-  if (bt == T_LONG && shift != NULL && shift->Opcode() == Op_ConvI2L) {\n+  BasicType shift_bt = bt;\n+  if (bt == T_LONG && shift->Opcode() == Op_ConvI2L) {\n@@ -1732,2 +1742,2 @@\n-    shift = shift->in(1);\n-    if (shift == NULL) {\n+    Node* val = shift->in(1);\n+    if (val == NULL) {\n@@ -1736,0 +1746,4 @@\n+    if (val->Opcode() == Op_LShiftI) {\n+      shift_bt = T_INT;\n+      shift = val;\n+    }\n@@ -1737,1 +1751,7 @@\n-  if (shift->Opcode() != Op_LShift(bt)) {\n+  if (shift->Opcode() != Op_LShift(shift_bt)) {\n+    if (check_reverse &&\n+        (mask->Opcode() == Op_LShift(bt) ||\n+         (bt == T_LONG && mask->Opcode() == Op_ConvI2L))) {\n+      \/\/ try it the other way around\n+      return AndIL_shift_and_mask_is_always_zero(phase, mask, shift, bt, false);\n+    }\n@@ -1749,1 +1769,1 @@\n-  jint shift_con = shift2_t->is_int()->get_con() & ((bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n+  jint shift_con = shift2_t->is_int()->get_con() & ((shift_bt == T_INT ? BitsPerJavaInteger : BitsPerJavaLong) - 1);\n@@ -1757,2 +1777,14 @@\n-\/\/ Helper method to transform:\n-\/\/ patterns similar to (v1 + (v2 << 2)) & 3 to v1 & 3\n+\/\/ Given an expression (AndX (AddX v1 (LShiftX v2 #N)) #M)\n+\/\/ determine if the AndX must always produce (AndX v1 #M),\n+\/\/ because the shift (v2<<N) is bitwise disjoint from the mask #M.\n+\/\/ The X in AndX will be I or L, depending on bt.\n+\/\/ Specifically, the following cases fold,\n+\/\/ when the shift value N is large enough to zero out\n+\/\/ all the set positions of the and-mask M.\n+\/\/   (AndI (AddI v1 (LShiftI _ #N)) #M) => (AndI v1 #M)\n+\/\/   (AndL (AddI v1 (LShiftL _ #N)) #M) => (AndL v1 #M)\n+\/\/   (AndL (AddL v1 (ConvI2L (LShiftI _ #N))) #M) => (AndL v1 #M)\n+\/\/ The M and N values must satisfy ((-1 << N) & M) == 0.\n+\/\/ Because the optimization might work for a non-constant\n+\/\/ mask M, and because the AddX operands can come in either\n+\/\/ order, we check for every operand order.\n@@ -1760,5 +1792,16 @@\n-  Node* in1 = in(1);\n-  Node* in2 = in(2);\n-  if (in1 != NULL && in2 != NULL && in1->Opcode() == Op_Add(bt)) {\n-    Node* add1 = in1->in(1);\n-    Node* add2 = in1->in(2);\n+  Node* add = in(1);\n+  Node* mask = in(2);\n+  if (add == NULL || mask == NULL) {\n+    return NULL;\n+  }\n+  int addidx = 0;\n+  if (add->Opcode() == Op_Add(bt)) {\n+    addidx = 1;\n+  } else if (mask->Opcode() == Op_Add(bt)) {\n+    mask = add;\n+    addidx = 2;\n+    add = in(addidx);\n+  }\n+  if (addidx > 0) {\n+    Node* add1 = add->in(1);\n+    Node* add2 = add->in(2);\n@@ -1766,2 +1809,2 @@\n-      if (AndIL_shift_and_mask(phase, in2, add1, bt)) {\n-        set_req_X(1, add2, phase);\n+      if (AndIL_shift_and_mask_is_always_zero(phase, add1, mask, bt, false)) {\n+        set_req_X(addidx, add2, phase);\n@@ -1769,2 +1812,2 @@\n-      } else if (AndIL_shift_and_mask(phase, in2, add2, bt)) {\n-        set_req_X(1, add1, phase);\n+      } else if (AndIL_shift_and_mask_is_always_zero(phase, add2, mask, bt, false)) {\n+        set_req_X(addidx, add1, phase);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":78,"deletions":35,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-  static bool AndIL_shift_and_mask(PhaseGVN* phase, Node* mask, Node* shift, BasicType bt);\n+  static bool AndIL_shift_and_mask_is_always_zero(PhaseGVN* phase, Node* shift, Node* mask, BasicType bt, bool check_reverse);\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,1 +244,1 @@\n-    \/\/ Usually the initialization shoudl be to n->Value(this) instead,\n+    \/\/ Usually the initialization should be to n->Value(this) instead,\n","filename":"src\/hotspot\/share\/opto\/phaseX.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -438,0 +438,8 @@\n+  \/\/ Convert \"(A+X) - (X+B)\" into \"A - B\"\n+  if( op1 == Op_AddL && op2 == Op_AddL && in1->in(2) == in2->in(1) )\n+    return new SubLNode( in1->in(1), in2->in(2) );\n+\n+  \/\/ Convert \"(X+A) - (B+X)\" into \"A - B\"\n+  if( op1 == Op_AddL && op2 == Op_AddL && in1->in(1) == in2->in(2) )\n+    return new SubLNode( in1->in(2), in2->in(1) );\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -792,2 +792,2 @@\n-\/\/ M broadcastCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,\n-\/\/                    long bits, S s,\n+\/\/ M fromBitsCoerced(Class<? extends M> vmClass, Class<E> elementType, int length,\n+\/\/                    long bits, int mode, S s,\n@@ -795,1 +795,1 @@\n-bool LibraryCallKit::inline_vector_broadcast_coerced() {\n+bool LibraryCallKit::inline_vector_frombits_coerced() {\n@@ -799,0 +799,5 @@\n+  const TypeLong*    bits_type    = gvn().type(argument(3))->isa_long();\n+  \/\/ Mode argument determines the mode of operation it can take following values:-\n+  \/\/ MODE_BROADCAST for vector Vector.boradcast and VectorMask.maskAll operations.\n+  \/\/ MODE_BITS_COERCED_LONG_TO_MASK for VectorMask.fromLong operation.\n+  const TypeInt*     mode         = gvn().type(argument(5))->isa_int();\n@@ -800,2 +805,3 @@\n-  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL ||\n-      vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL || !vlen->is_con()) {\n+  if (vector_klass == NULL || elem_klass == NULL || vlen == NULL || mode == NULL ||\n+      bits_type == NULL || vector_klass->const_oop() == NULL || elem_klass->const_oop() == NULL ||\n+      !vlen->is_con() || !mode->is_con()) {\n@@ -803,1 +809,1 @@\n-      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s\",\n+      tty->print_cr(\"  ** missing constant: vclass=%s etype=%s vlen=%s bitwise=%s\",\n@@ -806,1 +812,2 @@\n-                    NodeClassNames[argument(2)->Opcode()]);\n+                    NodeClassNames[argument(2)->Opcode()],\n+                    NodeClassNames[argument(5)->Opcode()]);\n@@ -829,3 +836,6 @@\n-  \/\/ TODO When mask usage is supported, VecMaskNotUsed needs to be VecMaskUseLoad.\n-  if (!arch_supports_vector(VectorNode::replicate_opcode(elem_bt), num_elem, elem_bt,\n-                            (is_vector_mask(vbox_klass) ? VecMaskUseStore : VecMaskNotUsed), true \/*has_scalar_args*\/)) {\n+  bool is_mask = is_vector_mask(vbox_klass);\n+  int  bcast_mode = mode->get_con();\n+  VectorMaskUseType checkFlags = (VectorMaskUseType)(is_mask ? VecMaskUseAll : VecMaskNotUsed);\n+  int opc = bcast_mode == VectorSupport::MODE_BITS_COERCED_LONG_TO_MASK ? Op_VectorLongToMask : VectorNode::replicate_opcode(elem_bt);\n+\n+  if (!arch_supports_vector(opc, num_elem, elem_bt, checkFlags, true \/*has_scalar_args*\/)) {\n@@ -833,1 +843,1 @@\n-      tty->print_cr(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d\",\n+      tty->print_cr(\"  ** not supported: arity=0 op=broadcast vlen=%d etype=%s ismask=%d bcast_mode=%d\",\n@@ -835,1 +845,2 @@\n-                    is_vector_mask(vbox_klass) ? 1 : 0);\n+                    is_mask ? 1 : 0,\n+                    bcast_mode);\n@@ -840,19 +851,12 @@\n-  Node* bits = argument(3); \/\/ long\n-  Node* elem = NULL;\n-  switch (elem_bt) {\n-    case T_BOOLEAN: \/\/ fall-through\n-    case T_BYTE:    \/\/ fall-through\n-    case T_SHORT:   \/\/ fall-through\n-    case T_CHAR:    \/\/ fall-through\n-    case T_INT: {\n-      elem = gvn().transform(new ConvL2INode(bits));\n-      break;\n-    }\n-    case T_DOUBLE: {\n-      elem = gvn().transform(new MoveL2DNode(bits));\n-      break;\n-    }\n-    case T_FLOAT: {\n-      bits = gvn().transform(new ConvL2INode(bits));\n-      elem = gvn().transform(new MoveI2FNode(bits));\n-      break;\n+  Node* broadcast = NULL;\n+  Node* bits = argument(3);\n+  Node* elem = bits;\n+\n+  if (opc == Op_VectorLongToMask) {\n+    const TypeVect* vt = TypeVect::makemask(elem_bt, num_elem);\n+    if (vt->isa_vectmask()) {\n+      broadcast = gvn().transform(new VectorLongToMaskNode(elem, vt));\n+    } else {\n+      const TypeVect* mvt = TypeVect::make(T_BOOLEAN, num_elem);\n+      broadcast = gvn().transform(new VectorLongToMaskNode(elem, mvt));\n+      broadcast = gvn().transform(new VectorLoadMaskNode(broadcast, vt));\n@@ -860,3 +864,24 @@\n-    case T_LONG: {\n-      elem = bits; \/\/ no conversion needed\n-      break;\n+  } else {\n+    switch (elem_bt) {\n+      case T_BOOLEAN: \/\/ fall-through\n+      case T_BYTE:    \/\/ fall-through\n+      case T_SHORT:   \/\/ fall-through\n+      case T_CHAR:    \/\/ fall-through\n+      case T_INT: {\n+        elem = gvn().transform(new ConvL2INode(bits));\n+        break;\n+      }\n+      case T_DOUBLE: {\n+        elem = gvn().transform(new MoveL2DNode(bits));\n+        break;\n+      }\n+      case T_FLOAT: {\n+        bits = gvn().transform(new ConvL2INode(bits));\n+        elem = gvn().transform(new MoveI2FNode(bits));\n+        break;\n+      }\n+      case T_LONG: {\n+        \/\/ no conversion needed\n+        break;\n+      }\n+      default: fatal(\"%s\", type2name(elem_bt));\n@@ -864,1 +889,2 @@\n-    default: fatal(\"%s\", type2name(elem_bt));\n+    broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_mask);\n+    broadcast = gvn().transform(broadcast);\n@@ -867,3 +893,0 @@\n-  Node* broadcast = VectorNode::scalar2vector(elem, num_elem, Type::get_const_basic_type(elem_bt), is_vector_mask(vbox_klass));\n-  broadcast = gvn().transform(broadcast);\n-\n@@ -2496,15 +2519,1 @@\n-          \/\/ Special handling for casting operation involving floating point types.\n-          \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n-          \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n-          \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n-          if (is_floating_point_type(elem_bt_from)) {\n-            const TypeVect* new_src_type = TypeVect::make(new_elem_bt_from, num_elem_to, is_mask);\n-            op = gvn().transform(new VectorMaskCastNode(op, new_src_type));\n-          }\n-          if (is_floating_point_type(elem_bt_to)) {\n-            new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n-          }\n-          op = gvn().transform(VectorCastNode::make(cast_vopc, op, new_elem_bt_to, num_elem_to));\n-          if (new_elem_bt_to != elem_bt_to) {\n-            op = gvn().transform(new VectorMaskCastNode(op, dst_type));\n-          }\n+          op = VectorMaskCastNode::makeCastNode(&gvn(), op, dst_type);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":62,"deletions":53,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -1450,0 +1450,76 @@\n+Node* VectorMaskToLongNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_VectorLongToMask) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+\n+Node* VectorMaskCastNode::makeCastNode(PhaseGVN* phase, Node* src, const TypeVect* dst_type) {\n+  const TypeVect* src_type = src->bottom_type()->is_vect();\n+  assert(src_type->length() == dst_type->length(), \"\");\n+\n+  int num_elem = src_type->length();\n+  BasicType elem_bt_from = src_type->element_basic_type();\n+  BasicType elem_bt_to = dst_type->element_basic_type();\n+\n+  if (dst_type->isa_vectmask() == NULL && src_type->isa_vectmask() == NULL &&\n+      type2aelembytes(elem_bt_from) != type2aelembytes(elem_bt_to)) {\n+\n+    Node* op = src;\n+    BasicType new_elem_bt_from = elem_bt_from;\n+    BasicType new_elem_bt_to = elem_bt_to;\n+    if (is_floating_point_type(elem_bt_from)) {\n+      new_elem_bt_from =  elem_bt_from == T_FLOAT ? T_INT : T_LONG;\n+    }\n+    if (is_floating_point_type(elem_bt_to)) {\n+      new_elem_bt_to = elem_bt_to == T_FLOAT ? T_INT : T_LONG;\n+    }\n+\n+    \/\/ Special handling for casting operation involving floating point types.\n+    \/\/ Case A) F -> X :=  F -> VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2X\n+    \/\/ Case B) X -> F :=  X -> VectorCastX2[I\/L] -> VectorMaskCast ([I\/L]->F [NOP])\n+    \/\/ Case C) F -> F :=  VectorMaskCast (F->I\/L [NOP]) -> VectorCast[I\/L]2[L\/I] -> VectotMaskCast (L\/I->F [NOP])\n+\n+    if (new_elem_bt_from != elem_bt_from) {\n+      const TypeVect* new_src_type = TypeVect::makemask(new_elem_bt_from, num_elem);\n+      op = phase->transform(new VectorMaskCastNode(op, new_src_type));\n+    }\n+\n+    op = phase->transform(VectorCastNode::make(VectorCastNode::opcode(new_elem_bt_from), op, new_elem_bt_to, num_elem));\n+\n+    if (new_elem_bt_to != elem_bt_to) {\n+      op = phase->transform(new VectorMaskCastNode(op, dst_type));\n+    }\n+    return op;\n+  } else {\n+    return new VectorMaskCastNode(src, dst_type);\n+  }\n+}\n+\n+Node* VectorLongToMaskNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  const TypeVect* dst_type = bottom_type()->is_vect();\n+  if (in(1)->Opcode() == Op_AndL &&\n+      in(1)->in(1)->Opcode() == Op_VectorMaskToLong &&\n+      in(1)->in(2)->bottom_type()->isa_long() &&\n+      in(1)->in(2)->bottom_type()->is_long()->is_con() &&\n+      in(1)->in(2)->bottom_type()->is_long()->get_con() == ((1L << dst_type->length()) - 1)) {\n+      \/\/ Different src\/dst mask length represents a re-interpretation operation,\n+      \/\/ we can however generate a mask casting operation if length matches.\n+     Node* src = in(1)->in(1)->in(1);\n+     if (dst_type->isa_vectmask() == NULL) {\n+       if (src->Opcode() != Op_VectorStoreMask) {\n+         return NULL;\n+       }\n+       src = src->in(1);\n+     }\n+     const TypeVect* src_type = src->bottom_type()->is_vect();\n+     if (src_type->length() == dst_type->length() &&\n+         ((src_type->isa_vectmask() == NULL && dst_type->isa_vectmask() == NULL) ||\n+          (src_type->isa_vectmask() && dst_type->isa_vectmask()))) {\n+       return VectorMaskCastNode::makeCastNode(phase, src, dst_type);\n+     }\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":76,"deletions":0,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"prims\/vectorSupport.hpp\"\n@@ -980,0 +981,10 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n+};\n+\n+class VectorLongToMaskNode : public VectorNode {\n+ public:\n+  VectorLongToMaskNode(Node* mask, const TypeVect* ty):\n+    VectorNode(mask, ty) {\n+  }\n+  virtual int Opcode() const;\n+  Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1404,1 +1415,1 @@\n-\n+  static Node* makeCastNode(PhaseGVN* phase, Node* in1, const TypeVect * vt);\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -3651,2 +3651,2 @@\n-    const char* release = Abstract_VM_Version::vm_release();\n-    const char* dbg_level = Abstract_VM_Version::jdk_debug_level();\n+    const char* release = VM_Version::vm_release();\n+    const char* dbg_level = VM_Version::jdk_debug_level();\n@@ -3657,4 +3657,4 @@\n-    seed += (jlong)Abstract_VM_Version::vm_major_version();\n-    seed += (jlong)Abstract_VM_Version::vm_minor_version();\n-    seed += (jlong)Abstract_VM_Version::vm_security_version();\n-    seed += (jlong)Abstract_VM_Version::vm_patch_version();\n+    seed += (jlong)VM_Version::vm_major_version();\n+    seed += (jlong)VM_Version::vm_minor_version();\n+    seed += (jlong)VM_Version::vm_security_version();\n+    seed += (jlong)VM_Version::vm_patch_version();\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-      if (major < 13 || major > Abstract_VM_Version::vm_major_version()) {\n+      if (major < 13 || major > VM_Version::vm_major_version()) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,0 +124,5 @@\n+  enum {\n+    MODE_BROADCAST = 0,\n+    MODE_BITS_COERCED_LONG_TO_MASK = 1\n+  };\n+\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -340,0 +340,43 @@\n+\n+\/\/ Abstract_VM_Version statics\n+int   Abstract_VM_Version::_no_of_threads = 0;\n+int   Abstract_VM_Version::_no_of_cores = 0;\n+int   Abstract_VM_Version::_no_of_sockets = 0;\n+bool  Abstract_VM_Version::_initialized = false;\n+char  Abstract_VM_Version::_cpu_name[CPU_TYPE_DESC_BUF_SIZE] = {0};\n+char  Abstract_VM_Version::_cpu_desc[CPU_DETAILED_DESC_BUF_SIZE] = {0};\n+\n+int Abstract_VM_Version::number_of_threads(void) {\n+  assert(_initialized, \"should be initialized\");\n+  return _no_of_threads;\n+}\n+\n+int Abstract_VM_Version::number_of_cores(void) {\n+  assert(_initialized, \"should be initialized\");\n+  return _no_of_cores;\n+}\n+\n+int Abstract_VM_Version::number_of_sockets(void) {\n+  assert(_initialized, \"should be initialized\");\n+  return _no_of_sockets;\n+}\n+\n+const char* Abstract_VM_Version::cpu_name(void) {\n+  assert(_initialized, \"should be initialized\");\n+  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_TYPE_DESC_BUF_SIZE, mtTracing);\n+  if (NULL == tmp) {\n+    return NULL;\n+  }\n+  strncpy(tmp, _cpu_name, CPU_TYPE_DESC_BUF_SIZE);\n+  return tmp;\n+}\n+\n+const char* Abstract_VM_Version::cpu_description(void) {\n+  assert(_initialized, \"should be initialized\");\n+  char* tmp = NEW_C_HEAP_ARRAY_RETURN_NULL(char, CPU_DETAILED_DESC_BUF_SIZE, mtTracing);\n+  if (NULL == tmp) {\n+    return NULL;\n+  }\n+  strncpy(tmp, _cpu_desc, CPU_DETAILED_DESC_BUF_SIZE);\n+  return tmp;\n+}\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -189,0 +189,20 @@\n+\n+ protected:\n+  \/\/ VM_Version statics\n+  static const size_t      CPU_TYPE_DESC_BUF_SIZE = 256;\n+  static const size_t      CPU_DETAILED_DESC_BUF_SIZE = 4096;\n+\n+  static int   _no_of_threads;\n+  static int   _no_of_cores;\n+  static int   _no_of_sockets;\n+  static bool  _initialized;\n+  static char  _cpu_name[CPU_TYPE_DESC_BUF_SIZE];\n+  static char  _cpu_desc[CPU_DETAILED_DESC_BUF_SIZE];\n+\n+ public:\n+  static int number_of_threads(void);\n+  static int number_of_cores(void);\n+  static int number_of_sockets(void);\n+\n+  static const char* cpu_name(void);\n+  static const char* cpu_description(void);\n","filename":"src\/hotspot\/share\/runtime\/abstract_vm_version.hpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -122,0 +122,3 @@\n+\/\/ True if -Xshare:auto option was specified.\n+static bool xshare_auto_cmd_line = false;\n+\n@@ -530,1 +533,0 @@\n-  { \"FilterSpuriousWakeups\",        JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::jdk(20) },\n@@ -546,13 +548,2 @@\n-  { \"CriticalJNINatives\",           JDK_Version::jdk(16), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"InlineFrequencyCount\",         JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"G1RSetRegionEntries\",          JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"G1RSetSparseRegionEntries\",    JDK_Version::undefined(), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"AlwaysLockClassLoader\",        JDK_Version::jdk(17), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n-  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(18), JDK_Version::jdk(19) },\n+\n+  { \"FilterSpuriousWakeups\",        JDK_Version::jdk(18), JDK_Version::jdk(19), JDK_Version::jdk(20) },\n@@ -1517,1 +1508,1 @@\n-    FLAG_SET_DEFAULT(UseSharedSpaces, false);\n+    UseSharedSpaces = false;\n@@ -2706,3 +2697,1 @@\n-      if (FLAG_SET_CMDLINE(DumpSharedSpaces, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n+      DumpSharedSpaces = true;\n@@ -2711,6 +2700,2 @@\n-      if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n+      UseSharedSpaces = true;\n+      RequireSharedSpaces = true;\n@@ -2719,6 +2704,3 @@\n-      if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n+      UseSharedSpaces = true;\n+      RequireSharedSpaces = false;\n+      xshare_auto_cmd_line = true;\n@@ -2727,6 +2709,2 @@\n-      if (FLAG_SET_CMDLINE(UseSharedSpaces, false) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n-      if (FLAG_SET_CMDLINE(RequireSharedSpaces, false) != JVMFlag::SUCCESS) {\n-        return JNI_EINVAL;\n-      }\n+      UseSharedSpaces = false;\n+      RequireSharedSpaces = false;\n@@ -2986,6 +2964,2 @@\n-    if (FLAG_SET_CMDLINE(UseSharedSpaces, true) != JVMFlag::SUCCESS) {\n-      return JNI_EINVAL;\n-    }\n-    if (FLAG_SET_CMDLINE(RequireSharedSpaces, true) != JVMFlag::SUCCESS) {\n-      return JNI_EINVAL;\n-    }\n+    UseSharedSpaces = true;\n+    RequireSharedSpaces = true;\n@@ -3147,1 +3121,1 @@\n-    \/\/ unsafe with DumpSharedSpaces (which modifies the class metadata in place). Let's disable\n+    \/\/ unsafe with -Xshare:dump (which modifies the class metadata in place). Let's disable\n@@ -3150,2 +3124,2 @@\n-    \/\/ Note: this is not a concern for DynamicDumpSharedSpaces, which makes a copy of the class metadata\n-    \/\/ instead of modifying them in place. The copy is inaccessible to the compiler.\n+    \/\/ Note: this is not a concern for dynamically dumping shared spaces, which makes a copy of the\n+    \/\/ class metadata instead of modifying them in place. The copy is inaccessible to the compiler.\n@@ -3164,1 +3138,1 @@\n-    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, false);\n+    DynamicDumpSharedSpaces = false;\n@@ -3166,1 +3140,1 @@\n-    FLAG_SET_DEFAULT(DynamicDumpSharedSpaces, true);\n+    DynamicDumpSharedSpaces = true;\n@@ -3173,1 +3147,1 @@\n-    FLAG_SET_DEFAULT(UseSharedSpaces, false);\n+    UseSharedSpaces = false;\n@@ -3543,0 +3517,5 @@\n+\n+    if (os::same_files((const char*)get_default_shared_archive_path(), ArchiveClassesAtExit)) {\n+      vm_exit_during_initialization(\n+        \"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit\", get_default_shared_archive_path());\n+    }\n@@ -4013,1 +3992,1 @@\n-  if ((UseSharedSpaces && FLAG_IS_CMDLINE(UseSharedSpaces)) ||\n+  if ((UseSharedSpaces && xshare_auto_cmd_line) ||\n@@ -4016,1 +3995,1 @@\n-    FLAG_SET_DEFAULT(UseSharedSpaces, false);\n+    UseSharedSpaces = false;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":29,"deletions":50,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -2282,1 +2282,2 @@\n-      idx += Reason_LIMIT;\n+      \/\/ Upper half of history array used for traps in OSR compilations\n+      idx += Reason_TRAP_HISTORY_LENGTH;\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  \/\/ Note: Keep this enum in sync. with Deoptimization::_trap_reason_name.\n@@ -101,0 +102,3 @@\n+    \/\/ Used to define MethodData::_trap_hist_limit where Reason_tenured isn't included\n+    Reason_TRAP_HISTORY_LENGTH,\n+\n@@ -102,2 +106,1 @@\n-    \/\/ Related to MethodData::_trap_hist_limit where Reason_tenured isn't included\n-    Reason_tenured,               \/\/ age of the code has reached the limit\n+    Reason_tenured = Reason_TRAP_HISTORY_LENGTH, \/\/ age of the code has reached the limit\n@@ -106,2 +109,0 @@\n-    \/\/ Note:  Keep this enum in sync. with _trap_reason_name.\n-    Reason_RECORDED_LIMIT = Reason_profile_predicate  \/\/ some are not recorded per bc\n@@ -112,0 +113,1 @@\n+    Reason_RECORDED_LIMIT = Reason_profile_predicate,  \/\/ some are not recorded per bc\n@@ -115,0 +117,1 @@\n+  \/\/ Note: Keep this enum in sync. with Deoptimization::_trap_action_name.\n@@ -122,1 +125,0 @@\n-    \/\/ Note:  Keep this enum in sync. with _trap_action_name.\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -722,4 +722,0 @@\n-  product(bool, FilterSpuriousWakeups, true,                                \\\n-          \"(Deprecated) When true prevents OS-level spurious, or premature,\"\\\n-          \" wakeups from Object.wait (Ignored for Windows)\")                \\\n-                                                                            \\\n@@ -1808,3 +1804,0 @@\n-  product(bool, UseSharedSpaces, true,                                      \\\n-          \"(Deprecated) Use shared spaces for metadata\")                    \\\n-                                                                            \\\n@@ -1814,11 +1807,0 @@\n-  product(bool, RequireSharedSpaces, false,                                 \\\n-          \"(Deprecated) Require shared spaces for metadata\")                \\\n-                                                                            \\\n-  product(bool, DumpSharedSpaces, false,                                    \\\n-          \"(Deprecated) Special mode: JVM reads a class list, loads \"       \\\n-          \"classes, builds shared spaces, and dumps the shared spaces to \"  \\\n-          \"a file to be used in future JVM runs\")                           \\\n-                                                                            \\\n-  product(bool, DynamicDumpSharedSpaces, false,                             \\\n-          \"(Deprecated) Dynamic archive\")                                   \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-OSThread::OSThread(OSThreadStartFunc start_proc, void* start_parm) {\n+OSThread::OSThread() {\n@@ -31,2 +31,0 @@\n-  set_start_proc(start_proc);\n-  set_start_parm(start_parm);\n","filename":"src\/hotspot\/share\/runtime\/osThread.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,2 +64,0 @@\n-  OSThreadStartFunc _start_proc;  \/\/ Thread start routine\n-  void* _start_parm;              \/\/ Thread start routine parameter\n@@ -73,1 +71,1 @@\n-  OSThread(OSThreadStartFunc start_proc, void* start_parm);\n+  OSThread();\n@@ -76,9 +74,0 @@\n-  \/\/ Accessors\n-  OSThreadStartFunc start_proc() const              { return _start_proc; }\n-  void set_start_proc(OSThreadStartFunc start_proc) { _start_proc = start_proc; }\n-  void* start_parm() const                          { return _start_parm; }\n-  void set_start_parm(void* start_parm)             { _start_parm = start_parm; }\n-  \/\/ This is specialized on Windows.\n-#ifndef _WINDOWS\n-  void set_interrupted(bool z)                      { \/* nothing to do *\/ }\n-#endif\n@@ -93,2 +82,0 @@\n-  static ByteSize thread_id_offset()              { return byte_offset_of(OSThread, _thread_id); }\n-  static size_t thread_id_size()                  { return sizeof(thread_id_t); }\n","filename":"src\/hotspot\/share\/runtime\/osThread.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1114,1 +1114,1 @@\n-  osthread()->set_interrupted(true);\n+  WINDOWS_ONLY(osthread()->set_interrupted(true);)\n@@ -1159,1 +1159,1 @@\n-    osthread()->set_interrupted(false);\n+    WINDOWS_ONLY(osthread()->set_interrupted(false);)\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -915,2 +915,3 @@\n-  _print_subclasses(\"-s\", \"If a classname is specified, print its subclasses. \"\n-                    \"Otherwise only its superclasses are printed.\", \"BOOLEAN\", false, \"false\"),\n+  _print_subclasses(\"-s\", \"If a classname is specified, print its subclasses \"\n+                    \"in addition to its superclasses. Without this option only the \"\n+                    \"superclasses will be printed.\", \"BOOLEAN\", false, \"false\"),\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  JVM_ACC_HAS_RESOLVED_METHODS    = 0x00200000,     \/\/ True if the klass has resolved methods\n@@ -75,1 +76,1 @@\n-  JVM_ACC_HAS_LOCAL_VARIABLE_TABLE= 0x00200000,\n+  JVM_ACC_HAS_LOCAL_VARIABLE_TABLE= 0x00400000,\n@@ -77,1 +78,1 @@\n-  JVM_ACC_PROMOTED_FLAGS          = 0x00200000,     \/\/ flags promoted from methods to the holding klass\n+  JVM_ACC_PROMOTED_FLAGS          = 0x00400000,     \/\/ flags promoted from methods to the holding klass\n@@ -167,0 +168,3 @@\n+  bool has_resolved_methods() const     { return (_flags & JVM_ACC_HAS_RESOLVED_METHODS) != 0; }\n+  void set_has_resolved_methods()       { atomic_set_bits(JVM_ACC_HAS_RESOLVED_METHODS); }\n+\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -42,0 +42,8 @@\n+\/\/ Old CDS options\n+bool DumpSharedSpaces;\n+bool DynamicDumpSharedSpaces;\n+bool RequireSharedSpaces;\n+extern \"C\" {\n+JNIEXPORT jboolean UseSharedSpaces = true;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -511,0 +511,10 @@\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ old CDS options\n+extern bool DumpSharedSpaces;\n+extern bool DynamicDumpSharedSpaces;\n+extern bool RequireSharedSpaces;\n+extern \"C\" {\n+\/\/ Make sure UseSharedSpaces is accessible to the serviceability agent.\n+extern JNIEXPORT jboolean UseSharedSpaces;\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1307,1 +1307,1 @@\n-                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                throw new ShortBufferException(\"Output buffer too small, must \" +\n@@ -1475,1 +1475,1 @@\n-                throw new ShortBufferException(\"Output buffer too small, must\" +\n+                throw new ShortBufferException(\"Output buffer too small, must \" +\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/GaloisCounterMode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-                            \"Internal Error:  TLS 1.1+ should not be negotiating\" +\n+                            \"Internal Error:  TLS 1.1+ should not be negotiating \" +\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/TlsKeyMaterialGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.io;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+\n+\/\/ Maps Class instances to values of type T. Under memory pressure, the\n+\/\/ mapping is released (under soft references GC policy) and would be\n+\/\/ recomputed the next time it is queried. The mapping is bound to the\n+\/\/ lifetime of the class: when the class is unloaded, the mapping is\n+\/\/ removed too.\n+abstract class ClassCache<T> {\n+\n+    private static class CacheRef<T> extends SoftReference<T> {\n+        private final Class<?> type;\n+\n+        CacheRef(T referent, ReferenceQueue<T> queue, Class<?> type) {\n+            super(referent, queue);\n+            this.type = type;\n+        }\n+\n+        Class<?> getType() {\n+            return type;\n+        }\n+    }\n+\n+    private final ReferenceQueue<T> queue;\n+    private final ClassValue<SoftReference<T>> map;\n+\n+    protected abstract T computeValue(Class<?> cl);\n+\n+    protected ClassCache() {\n+        queue = new ReferenceQueue<>();\n+        map = new ClassValue<>() {\n+            @Override\n+            protected SoftReference<T> computeValue(Class<?> type) {\n+                return new CacheRef<>(ClassCache.this.computeValue(type), queue, type);\n+            }\n+        };\n+    }\n+\n+    T get(Class<?> cl) {\n+        processQueue();\n+        T val;\n+        do {\n+            SoftReference<T> ref = map.get(cl);\n+            val = ref.get();\n+            if (val == null) {\n+                map.remove(cl);\n+            }\n+        } while (val == null);\n+        return val;\n+    }\n+\n+    private void processQueue() {\n+        Reference<? extends T> ref;\n+        while((ref = queue.poll()) != null) {\n+            CacheRef<? extends T> cacheRef = (CacheRef<? extends T>)ref;\n+            map.remove(cacheRef.getType());\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/io\/ClassCache.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.ref.SoftReference;\n@@ -111,2 +110,7 @@\n-        static final ConcurrentMap<WeakClassKey,Reference<?>> localDescs =\n-            new ConcurrentHashMap<>();\n+        static final ClassCache<ObjectStreamClass> localDescs =\n+            new ClassCache<>() {\n+                @Override\n+                protected ObjectStreamClass computeValue(Class<?> type) {\n+                    return new ObjectStreamClass(type);\n+                }\n+            };\n@@ -115,9 +119,7 @@\n-        static final ConcurrentMap<FieldReflectorKey,Reference<?>> reflectors =\n-            new ConcurrentHashMap<>();\n-\n-        \/** queue for WeakReferences to local classes *\/\n-        private static final ReferenceQueue<Class<?>> localDescsQueue =\n-            new ReferenceQueue<>();\n-        \/** queue for WeakReferences to field reflectors keys *\/\n-        private static final ReferenceQueue<Class<?>> reflectorsQueue =\n-            new ReferenceQueue<>();\n+        static final ClassCache<Map<FieldReflectorKey, FieldReflector>> reflectors =\n+            new ClassCache<>() {\n+                @Override\n+                protected Map<FieldReflectorKey, FieldReflector> computeValue(Class<?> type) {\n+                    return new ConcurrentHashMap<>();\n+                }\n+            };\n@@ -365,130 +367,1 @@\n-        processQueue(Caches.localDescsQueue, Caches.localDescs);\n-        WeakClassKey key = new WeakClassKey(cl, Caches.localDescsQueue);\n-        Reference<?> ref = Caches.localDescs.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.localDescs.remove(key, ref);\n-                }\n-                ref = Caches.localDescs.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {  \/\/ check common case first\n-            return (ObjectStreamClass) entry;\n-        }\n-        if (entry instanceof EntryFuture) {\n-            future = (EntryFuture) entry;\n-            if (future.getOwner() == Thread.currentThread()) {\n-                \/*\n-                 * Handle nested call situation described by 4803747: waiting\n-                 * for future value to be set by a lookup() call further up the\n-                 * stack will result in deadlock, so calculate and set the\n-                 * future value here instead.\n-                 *\/\n-                entry = null;\n-            } else {\n-                entry = future.get();\n-            }\n-        }\n-        if (entry == null) {\n-            try {\n-                entry = new ObjectStreamClass(cl);\n-            } catch (Throwable th) {\n-                entry = th;\n-            }\n-            if (future.set(entry)) {\n-                Caches.localDescs.put(key, new SoftReference<>(entry));\n-            } else {\n-                \/\/ nested lookup call already set future\n-                entry = future.get();\n-            }\n-        }\n-\n-        if (entry instanceof ObjectStreamClass) {\n-            return (ObjectStreamClass) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n-        }\n-    }\n-\n-    \/**\n-     * Placeholder used in class descriptor and field reflector lookup tables\n-     * for an entry in the process of being initialized.  (Internal) callers\n-     * which receive an EntryFuture belonging to another thread as the result\n-     * of a lookup should call the get() method of the EntryFuture; this will\n-     * return the actual entry once it is ready for use and has been set().  To\n-     * conserve objects, EntryFutures synchronize on themselves.\n-     *\/\n-    private static class EntryFuture {\n-\n-        private static final Object unset = new Object();\n-        private final Thread owner = Thread.currentThread();\n-        private Object entry = unset;\n-\n-        \/**\n-         * Attempts to set the value contained by this EntryFuture.  If the\n-         * EntryFuture's value has not been set already, then the value is\n-         * saved, any callers blocked in the get() method are notified, and\n-         * true is returned.  If the value has already been set, then no saving\n-         * or notification occurs, and false is returned.\n-         *\/\n-        synchronized boolean set(Object entry) {\n-            if (this.entry != unset) {\n-                return false;\n-            }\n-            this.entry = entry;\n-            notifyAll();\n-            return true;\n-        }\n-\n-        \/**\n-         * Returns the value contained by this EntryFuture, blocking if\n-         * necessary until a value is set.\n-         *\/\n-        @SuppressWarnings(\"removal\")\n-        synchronized Object get() {\n-            boolean interrupted = false;\n-            while (entry == unset) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    interrupted = true;\n-                }\n-            }\n-            if (interrupted) {\n-                AccessController.doPrivileged(\n-                    new PrivilegedAction<>() {\n-                        public Void run() {\n-                            Thread.currentThread().interrupt();\n-                            return null;\n-                        }\n-                    }\n-                );\n-            }\n-            return entry;\n-        }\n-\n-        \/**\n-         * Returns the thread that created this EntryFuture.\n-         *\/\n-        Thread getOwner() {\n-            return owner;\n-        }\n+        return Caches.localDescs.get(cl);\n@@ -2251,26 +2124,1 @@\n-            localDesc.cl : null;\n-        processQueue(Caches.reflectorsQueue, Caches.reflectors);\n-        FieldReflectorKey key = new FieldReflectorKey(cl, fields,\n-                                                      Caches.reflectorsQueue);\n-        Reference<?> ref = Caches.reflectors.get(key);\n-        Object entry = null;\n-        if (ref != null) {\n-            entry = ref.get();\n-        }\n-        EntryFuture future = null;\n-        if (entry == null) {\n-            EntryFuture newEntry = new EntryFuture();\n-            Reference<?> newRef = new SoftReference<>(newEntry);\n-            do {\n-                if (ref != null) {\n-                    Caches.reflectors.remove(key, ref);\n-                }\n-                ref = Caches.reflectors.putIfAbsent(key, newRef);\n-                if (ref != null) {\n-                    entry = ref.get();\n-                }\n-            } while (ref != null && entry == null);\n-            if (entry == null) {\n-                future = newEntry;\n-            }\n-        }\n+            localDesc.cl : Void.class;\n@@ -2278,9 +2126,8 @@\n-        if (entry instanceof FieldReflector) {  \/\/ check common case first\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof EntryFuture) {\n-            entry = ((EntryFuture) entry).get();\n-        } else if (entry == null) {\n-            try {\n-                entry = new FieldReflector(matchFields(fields, localDesc));\n-            } catch (Throwable th) {\n-                entry = th;\n+        var clReflectors = Caches.reflectors.get(cl);\n+        var key = new FieldReflectorKey(fields);\n+        var reflector = clReflectors.get(key);\n+        if (reflector == null) {\n+            reflector = new FieldReflector(matchFields(fields, localDesc));\n+            var oldReflector = clReflectors.putIfAbsent(key, reflector);\n+            if (oldReflector != null) {\n+                reflector = oldReflector;\n@@ -2288,14 +2135,0 @@\n-            future.set(entry);\n-            Caches.reflectors.put(key, new SoftReference<>(entry));\n-        }\n-\n-        if (entry instanceof FieldReflector) {\n-            return (FieldReflector) entry;\n-        } else if (entry instanceof InvalidClassException) {\n-            throw (InvalidClassException) entry;\n-        } else if (entry instanceof RuntimeException) {\n-            throw (RuntimeException) entry;\n-        } else if (entry instanceof Error) {\n-            throw (Error) entry;\n-        } else {\n-            throw new InternalError(\"unexpected entry: \" + entry);\n@@ -2303,0 +2136,1 @@\n+        return reflector;\n@@ -2307,1 +2141,1 @@\n-     * refer to the same class and equivalent field formats.\n+     * refer to equivalent field formats.\n@@ -2309,1 +2143,1 @@\n-    private static class FieldReflectorKey extends WeakReference<Class<?>> {\n+    private static class FieldReflectorKey {\n@@ -2313,1 +2147,0 @@\n-        private final boolean nullClass;\n@@ -2315,2 +2148,1 @@\n-        FieldReflectorKey(Class<?> cl, ObjectStreamField[] fields,\n-                          ReferenceQueue<Class<?>> queue)\n+        FieldReflectorKey(ObjectStreamField[] fields)\n@@ -2318,2 +2150,0 @@\n-            super(cl, queue);\n-            nullClass = (cl == null);\n@@ -2326,1 +2156,1 @@\n-            hash = System.identityHashCode(cl) + Arrays.hashCode(sigs);\n+            hash = Arrays.hashCode(sigs);\n@@ -2334,13 +2164,3 @@\n-            if (obj == this) {\n-                return true;\n-            }\n-\n-            if (obj instanceof FieldReflectorKey other) {\n-                Class<?> referent;\n-                return (nullClass ? other.nullClass\n-                                  : ((referent = get()) != null) &&\n-                                    (other.refersTo(referent))) &&\n-                        Arrays.equals(sigs, other.sigs);\n-            } else {\n-                return false;\n-            }\n+            return obj == this ||\n+                   obj instanceof FieldReflectorKey other &&\n+                   Arrays.equals(sigs, other.sigs);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":32,"deletions":212,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -2083,0 +2083,1 @@\n+     * @see #getDeclaredConstructors()\n@@ -2282,1 +2283,3 @@\n-     * @throws NoSuchMethodException if a matching method is not found.\n+     * @throws NoSuchMethodException if a matching constructor is not found,\n+     *         including when this {@code Class} object represents\n+     *         an interface, a primitive type, an array class, or void.\n@@ -2291,0 +2294,1 @@\n+     * @see #getDeclaredConstructor(Class<?>[])\n@@ -2539,1 +2543,0 @@\n-\n@@ -2542,1 +2545,1 @@\n-     * constructors declared by the class represented by this\n+     * constructors implicitly or explicitly declared by the class represented by this\n@@ -2546,1 +2549,4 @@\n-     * class has a default constructor, it is included in the returned array.\n+     * class has a default constructor (JLS {@jls 8.8.9}), it is included in the returned array.\n+     * If a record class has a canonical constructor (JLS {@jls\n+     * 8.10.4.1}, {@jls 8.10.4.2}), it is included in the returned array.\n+     *\n@@ -2551,3 +2557,0 @@\n-     * <p> See <cite>The Java Language Specification<\/cite>,\n-     * section {@jls 8.2}.\n-     *\n@@ -2578,0 +2581,1 @@\n+     * @see #getConstructors()\n@@ -2739,1 +2743,1 @@\n-     * constructor of the class or interface represented by this\n+     * constructor of the class represented by this\n@@ -2751,1 +2755,3 @@\n-     * @throws  NoSuchMethodException if a matching method is not found.\n+     * @throws  NoSuchMethodException if a matching constructor is not found,\n+     *          including when this {@code Class} object represents\n+     *          an interface, a primitive type, an array class, or void.\n@@ -2773,0 +2779,1 @@\n+     * @see #getConstructor(Class<?>[])\n@@ -3823,4 +3830,3 @@\n-        if (reflectionFactory == null) {\n-            reflectionFactory =\n-                java.security.AccessController.doPrivileged\n-                    (new ReflectionFactory.GetReflectionFactoryAction());\n+        var factory = reflectionFactory;\n+        if (factory != null) {\n+            return factory;\n@@ -3828,1 +3834,3 @@\n-        return reflectionFactory;\n+        return reflectionFactory =\n+                java.security.AccessController.doPrivileged\n+                        (new ReflectionFactory.GetReflectionFactoryAction());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4408,1 +4408,1 @@\n-        return (x < y) ? -1 : ((x == y) ? 0 : 1);\n+        return Long.compare(x, y);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigDecimal.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -450,7 +450,1 @@\n-            if (creation1 < creation2) {\n-                return -1;\n-            }\n-            if (creation1 > creation2) {\n-                return 1;\n-            }\n-            return 0;\n+            return Long.compare(creation1, creation2);\n","filename":"src\/java.base\/share\/classes\/java\/net\/CookieManager.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3419,2 +3419,1 @@\n-        long thisTime = getMillisOf(this);\n-        return (thisTime > t) ? 1 : (thisTime == t) ? 0 : -1;\n+        return Long.compare(getMillisOf(this), t);\n","filename":"src\/java.base\/share\/classes\/java\/util\/Calendar.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.time.LocalDate;\n@@ -33,1 +32,0 @@\n-import java.lang.ref.SoftReference;\n@@ -36,1 +34,0 @@\n-import sun.util.calendar.CalendarDate;\n@@ -39,2 +36,0 @@\n-import sun.util.calendar.Era;\n-import sun.util.calendar.Gregorian;\n@@ -978,0 +973,1 @@\n+    @Override\n@@ -979,3 +975,1 @@\n-        long thisTime = getMillisOf(this);\n-        long anotherTime = getMillisOf(anotherDate);\n-        return (thisTime<anotherTime ? -1 : (thisTime==anotherTime ? 0 : 1));\n+        return Long.compare(getMillisOf(this), getMillisOf(anotherDate));\n","filename":"src\/java.base\/share\/classes\/java\/util\/Date.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2037,1 +2037,1 @@\n-    private static final Appendable nonNullAppendable(Appendable a) {\n+    private static Appendable nonNullAppendable(Appendable a) {\n@@ -2758,1 +2758,1 @@\n-                        fs.print(null, l);\n+                        fs.print(this, null, l);\n@@ -2762,1 +2762,1 @@\n-                        fs.print((args == null ? null : args[last]), l);\n+                        fs.print(this, (args == null ? null : args[last]), l);\n@@ -2769,1 +2769,1 @@\n-                        fs.print((args == null ? null : args[lasto]), l);\n+                        fs.print(this, (args == null ? null : args[lasto]), l);\n@@ -2775,1 +2775,1 @@\n-                        fs.print((args == null ? null : args[last]), l);\n+                        fs.print(this, (args == null ? null : args[last]), l);\n@@ -2839,1 +2839,1 @@\n-        void print(Object arg, Locale l) throws IOException;\n+        void print(Formatter fmt, Object arg, Locale l) throws IOException;\n@@ -2843,1 +2843,1 @@\n-    private class FixedString implements FormatString {\n+    private static class FixedString implements FormatString {\n@@ -2853,2 +2853,2 @@\n-        public void print(Object arg, Locale l)\n-            throws IOException { a.append(s, start, end); }\n+        public void print(Formatter fmt, Object arg, Locale l)\n+            throws IOException { fmt.a.append(s, start, end); }\n@@ -2873,1 +2873,1 @@\n-    private class FormatSpecifier implements FormatString {\n+    private static class FormatSpecifier implements FormatString {\n@@ -2876,1 +2876,1 @@\n-        private Flags f = Flags.NONE;\n+        private int flags = Flags.NONE;\n@@ -2901,2 +2901,2 @@\n-            f = Flags.parse(s, start, end);\n-            if (f.contains(Flags.PREVIOUS))\n+            flags = Flags.parse(s, start, end);\n+            if (Flags.contains(flags, Flags.PREVIOUS))\n@@ -2938,1 +2938,1 @@\n-                    f.add(Flags.UPPERCASE);\n+                    flags = Flags.add(flags, Flags.UPPERCASE);\n@@ -2950,1 +2950,1 @@\n-                f = Flags.UPPERCASE;\n+                flags = Flags.UPPERCASE;\n@@ -2968,1 +2968,1 @@\n-                    f.add(Flags.UPPERCASE);\n+                    flags = Flags.add(flags, Flags.UPPERCASE);\n@@ -2989,1 +2989,1 @@\n-        public void print(Object arg, Locale l) throws IOException {\n+        public void print(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -2991,1 +2991,1 @@\n-                printDateTime(arg, l);\n+                printDateTime(fmt, arg, l);\n@@ -2998,1 +2998,1 @@\n-                printInteger(arg, l);\n+                printInteger(fmt, arg, l);\n@@ -3004,1 +3004,1 @@\n-                printFloat(arg, l);\n+                printFloat(fmt, arg, l);\n@@ -3007,1 +3007,1 @@\n-                printCharacter(arg, l);\n+                printCharacter(fmt, arg, l);\n@@ -3010,1 +3010,1 @@\n-                printBoolean(arg, l);\n+                printBoolean(fmt, arg, l);\n@@ -3013,1 +3013,1 @@\n-                printString(arg, l);\n+                printString(fmt, arg, l);\n@@ -3016,1 +3016,1 @@\n-                printHashCode(arg, l);\n+                printHashCode(fmt, arg, l);\n@@ -3019,1 +3019,1 @@\n-                a.append(System.lineSeparator());\n+                fmt.a.append(System.lineSeparator());\n@@ -3022,1 +3022,1 @@\n-                print(\"%\", l);\n+                print(fmt, \"%\", l);\n@@ -3029,1 +3029,1 @@\n-        private void printInteger(Object arg, Locale l) throws IOException {\n+        private void printInteger(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3031,1 +3031,1 @@\n-                print(\"null\", l);\n+                print(fmt, \"null\", l);\n@@ -3033,1 +3033,1 @@\n-                print(((Byte)arg).byteValue(), l);\n+                print(fmt, ((Byte)arg).byteValue(), l);\n@@ -3035,1 +3035,1 @@\n-                print(((Short)arg).shortValue(), l);\n+                print(fmt, ((Short)arg).shortValue(), l);\n@@ -3037,1 +3037,1 @@\n-                print(((Integer)arg).intValue(), l);\n+                print(fmt, ((Integer)arg).intValue(), l);\n@@ -3039,1 +3039,1 @@\n-                print(((Long)arg).longValue(), l);\n+                print(fmt, ((Long)arg).longValue(), l);\n@@ -3041,1 +3041,1 @@\n-                print(((BigInteger)arg), l);\n+                print(fmt, ((BigInteger)arg), l);\n@@ -3046,1 +3046,1 @@\n-        private void printFloat(Object arg, Locale l) throws IOException {\n+        private void printFloat(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3048,1 +3048,1 @@\n-                print(\"null\", l);\n+                print(fmt, \"null\", l);\n@@ -3050,1 +3050,1 @@\n-                print(((Float)arg).floatValue(), l);\n+                print(fmt, ((Float)arg).floatValue(), l);\n@@ -3052,1 +3052,1 @@\n-                print(((Double)arg).doubleValue(), l);\n+                print(fmt, ((Double)arg).doubleValue(), l);\n@@ -3054,1 +3054,1 @@\n-                print(((BigDecimal)arg), l);\n+                print(fmt, ((BigDecimal)arg), l);\n@@ -3059,1 +3059,1 @@\n-        private void printDateTime(Object arg, Locale l) throws IOException {\n+        private void printDateTime(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3061,1 +3061,1 @@\n-                print(\"null\", l);\n+                print(fmt, \"null\", l);\n@@ -3082,1 +3082,1 @@\n-                print((TemporalAccessor) arg, c, l);\n+                print(fmt, (TemporalAccessor) arg, c, l);\n@@ -3089,1 +3089,1 @@\n-            print(cal, c, l);\n+            print(fmt, cal, c, l);\n@@ -3092,1 +3092,1 @@\n-        private void printCharacter(Object arg, Locale l) throws IOException {\n+        private void printCharacter(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3094,1 +3094,1 @@\n-                print(\"null\", l);\n+                print(fmt, \"null\", l);\n@@ -3121,1 +3121,1 @@\n-            print(s, l);\n+            print(fmt, s, l);\n@@ -3124,1 +3124,1 @@\n-        private void printString(Object arg, Locale l) throws IOException {\n+        private void printString(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3126,1 +3126,0 @@\n-                Formatter fmt = Formatter.this;\n@@ -3129,1 +3128,1 @@\n-                ((Formattable)arg).formatTo(fmt, f.valueOf(), width, precision);\n+                ((Formattable)arg).formatTo(fmt, flags, width, precision);\n@@ -3131,1 +3130,1 @@\n-                if (f.contains(Flags.ALTERNATE))\n+                if (Flags.contains(flags, Flags.ALTERNATE))\n@@ -3134,1 +3133,1 @@\n-                    print(\"null\", l);\n+                    print(fmt, \"null\", l);\n@@ -3136,1 +3135,1 @@\n-                    print(arg.toString(), l);\n+                    print(fmt, arg.toString(), l);\n@@ -3140,1 +3139,1 @@\n-        private void printBoolean(Object arg, Locale l) throws IOException {\n+        private void printBoolean(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3148,1 +3147,1 @@\n-            print(s, l);\n+            print(fmt, s, l);\n@@ -3151,1 +3150,1 @@\n-        private void printHashCode(Object arg, Locale l) throws IOException {\n+        private void printHashCode(Formatter fmt, Object arg, Locale l) throws IOException {\n@@ -3155,1 +3154,1 @@\n-            print(s, l);\n+            print(fmt, s, l);\n@@ -3158,1 +3157,1 @@\n-        private void print(String s, Locale l) throws IOException {\n+        private void print(Formatter fmt, String s, Locale l) throws IOException {\n@@ -3161,1 +3160,1 @@\n-            if (f.contains(Flags.UPPERCASE))\n+            if (Flags.contains(flags, Flags.UPPERCASE))\n@@ -3163,1 +3162,1 @@\n-            appendJustified(a, s);\n+            appendJustified(fmt.a, s);\n@@ -3176,1 +3175,1 @@\n-             boolean padRight = f.contains(Flags.LEFT_JUSTIFY);\n+             boolean padRight = Flags.contains(flags, Flags.LEFT_JUSTIFY);\n@@ -3192,2 +3191,1 @@\n-            Flags dupf = f.dup().remove(Flags.UPPERCASE);\n-            sb.append(dupf.toString());\n+            sb.append(Flags.toString(Flags.remove(flags, Flags.UPPERCASE)));\n@@ -3201,2 +3199,2 @@\n-                sb.append(f.contains(Flags.UPPERCASE) ? 'T' : 't');\n-            sb.append(f.contains(Flags.UPPERCASE)\n+                sb.append(Flags.contains(flags, Flags.UPPERCASE) ? 'T' : 't');\n+            sb.append(Flags.contains(flags, Flags.UPPERCASE)\n@@ -3209,1 +3207,1 @@\n-                && f.contains(Flags.ALTERNATE))\n+                && Flags.contains(flags, Flags.ALTERNATE))\n@@ -3212,1 +3210,1 @@\n-            if (width == -1 && f.contains(Flags.LEFT_JUSTIFY))\n+            if (width == -1 && Flags.contains(flags, Flags.LEFT_JUSTIFY))\n@@ -3214,2 +3212,2 @@\n-            checkBadFlags(Flags.PLUS, Flags.LEADING_SPACE, Flags.ZERO_PAD,\n-                          Flags.GROUP, Flags.PARENTHESES);\n+            checkBadFlags(Flags.PLUS | Flags.LEADING_SPACE | Flags.ZERO_PAD |\n+                          Flags.GROUP | Flags.PARENTHESES);\n@@ -3223,2 +3221,2 @@\n-            checkBadFlags(Flags.ALTERNATE, Flags.PLUS, Flags.LEADING_SPACE,\n-                          Flags.ZERO_PAD, Flags.GROUP, Flags.PARENTHESES);\n+            checkBadFlags(Flags.ALTERNATE | Flags.PLUS | Flags.LEADING_SPACE |\n+                          Flags.ZERO_PAD | Flags.GROUP | Flags.PARENTHESES);\n@@ -3226,1 +3224,1 @@\n-            if (width == -1 && f.contains(Flags.LEFT_JUSTIFY))\n+            if (width == -1 && Flags.contains(flags, Flags.LEFT_JUSTIFY))\n@@ -3233,2 +3231,2 @@\n-            checkBadFlags(Flags.ALTERNATE, Flags.PLUS, Flags.LEADING_SPACE,\n-                          Flags.ZERO_PAD, Flags.GROUP, Flags.PARENTHESES);\n+            checkBadFlags(Flags.ALTERNATE | Flags.PLUS | Flags.LEADING_SPACE |\n+                          Flags.ZERO_PAD | Flags.GROUP | Flags.PARENTHESES);\n@@ -3236,1 +3234,1 @@\n-            if (width == -1 && f.contains(Flags.LEFT_JUSTIFY))\n+            if (width == -1 && Flags.contains(flags, Flags.LEFT_JUSTIFY))\n@@ -3253,4 +3251,4 @@\n-        private void checkBadFlags(Flags ... badFlags) {\n-            for (Flags badFlag : badFlags)\n-                if (f.contains(badFlag))\n-                    failMismatch(badFlag, c);\n+        private void checkBadFlags(int badFlags) {\n+            if ((flags & badFlags) != 0) {\n+                failMismatch(flags & badFlags, c);\n+            }\n@@ -3263,1 +3261,1 @@\n-                checkBadFlags(Flags.PARENTHESES, Flags.GROUP);\n+                checkBadFlags(Flags.PARENTHESES | Flags.GROUP);\n@@ -3280,1 +3278,1 @@\n-                && (f.contains(Flags.LEFT_JUSTIFY) || f.contains(Flags.ZERO_PAD)))\n+                && (Flags.containsAny(flags, Flags.LEFT_JUSTIFY | Flags.ZERO_PAD)))\n@@ -3284,3 +3282,3 @@\n-            if ((f.contains(Flags.PLUS) && f.contains(Flags.LEADING_SPACE))\n-                || (f.contains(Flags.LEFT_JUSTIFY) && f.contains(Flags.ZERO_PAD)))\n-                throw new IllegalFormatFlagsException(f.toString());\n+            if ((Flags.contains(flags, Flags.PLUS | Flags.LEADING_SPACE))\n+                || (Flags.contains(flags, Flags.LEFT_JUSTIFY | Flags.ZERO_PAD)))\n+                throw new IllegalFormatFlagsException(Flags.toString(flags));\n@@ -3294,3 +3292,3 @@\n-                if (f.valueOf() != Flags.LEFT_JUSTIFY.valueOf()\n-                    && f.valueOf() != Flags.NONE.valueOf())\n-                    throw new IllegalFormatFlagsException(f.toString());\n+                if (flags != Flags.LEFT_JUSTIFY\n+                    && flags != Flags.NONE)\n+                    throw new IllegalFormatFlagsException(Flags.toString(flags));\n@@ -3298,1 +3296,1 @@\n-                if (width == -1 && f.contains(Flags.LEFT_JUSTIFY))\n+                if (width == -1 && Flags.contains(flags, Flags.LEFT_JUSTIFY))\n@@ -3304,2 +3302,2 @@\n-                if (f.valueOf() != Flags.NONE.valueOf())\n-                    throw new IllegalFormatFlagsException(f.toString());\n+                if (flags != Flags.NONE)\n+                    throw new IllegalFormatFlagsException(Flags.toString(flags));\n@@ -3312,1 +3310,1 @@\n-        private void print(byte value, Locale l) throws IOException {\n+        private void print(Formatter fmt, byte value, Locale l) throws IOException {\n@@ -3319,1 +3317,1 @@\n-            print(v, l);\n+            print(fmt, v, l);\n@@ -3322,1 +3320,1 @@\n-        private void print(short value, Locale l) throws IOException {\n+        private void print(Formatter fmt, short value, Locale l) throws IOException {\n@@ -3330,1 +3328,1 @@\n-            print(v, l);\n+            print(fmt, v, l);\n@@ -3333,1 +3331,1 @@\n-        private void print(int value, Locale l) throws IOException {\n+        private void print(Formatter fmt, int value, Locale l) throws IOException {\n@@ -3341,1 +3339,1 @@\n-            print(v, l);\n+            print(fmt, v, l);\n@@ -3344,1 +3342,1 @@\n-        private void print(long value, Locale l) throws IOException {\n+        private void print(Formatter fmt, long value, Locale l) throws IOException {\n@@ -3356,1 +3354,1 @@\n-                localizedMagnitude(sb, valueStr, neg ? 1 : 0, f, adjustWidth(width, f, neg), l);\n+                localizedMagnitude(fmt, sb, valueStr, neg ? 1 : 0, flags, adjustWidth(width, flags, neg), l);\n@@ -3361,2 +3359,1 @@\n-                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,\n-                              Flags.PLUS);\n+                checkBadFlags(Flags.PARENTHESES | Flags.LEADING_SPACE | Flags.PLUS);\n@@ -3364,1 +3361,1 @@\n-                int len = (f.contains(Flags.ALTERNATE)\n+                int len = (Flags.contains(flags, Flags.ALTERNATE)\n@@ -3369,1 +3366,1 @@\n-                if (f.contains(Flags.ALTERNATE))\n+                if (Flags.contains(flags, Flags.ALTERNATE))\n@@ -3371,1 +3368,1 @@\n-                if (f.contains(Flags.ZERO_PAD)) {\n+                if (Flags.contains(flags, Flags.ZERO_PAD)) {\n@@ -3376,2 +3373,1 @@\n-                checkBadFlags(Flags.PARENTHESES, Flags.LEADING_SPACE,\n-                              Flags.PLUS);\n+                checkBadFlags(Flags.PARENTHESES | Flags.LEADING_SPACE | Flags.PLUS);\n@@ -3379,1 +3375,1 @@\n-                int len = (f.contains(Flags.ALTERNATE)\n+                int len = (Flags.contains(flags, Flags.ALTERNATE)\n@@ -3384,3 +3380,3 @@\n-                if (f.contains(Flags.ALTERNATE))\n-                    sb.append(f.contains(Flags.UPPERCASE) ? \"0X\" : \"0x\");\n-                if (f.contains(Flags.ZERO_PAD)) {\n+                if (Flags.contains(flags, Flags.ALTERNATE))\n+                    sb.append(Flags.contains(flags, Flags.UPPERCASE) ? \"0X\" : \"0x\");\n+                if (Flags.contains(flags, Flags.ZERO_PAD)) {\n@@ -3389,1 +3385,1 @@\n-                if (f.contains(Flags.UPPERCASE))\n+                if (Flags.contains(flags, Flags.UPPERCASE))\n@@ -3395,1 +3391,1 @@\n-            appendJustified(a, sb);\n+            appendJustified(fmt.a, sb);\n@@ -3401,1 +3397,1 @@\n-                if (f.contains(Flags.PLUS)) {\n+                if (Flags.contains(flags, Flags.PLUS)) {\n@@ -3403,1 +3399,1 @@\n-                } else if (f.contains(Flags.LEADING_SPACE)) {\n+                } else if (Flags.contains(flags, Flags.LEADING_SPACE)) {\n@@ -3407,1 +3403,1 @@\n-                if (f.contains(Flags.PARENTHESES))\n+                if (Flags.contains(flags, Flags.PARENTHESES))\n@@ -3417,1 +3413,1 @@\n-            if (neg && f.contains(Flags.PARENTHESES))\n+            if (neg && Flags.contains(flags, Flags.PARENTHESES))\n@@ -3422,1 +3418,1 @@\n-        private void print(BigInteger value, Locale l) throws IOException {\n+        private void print(Formatter fmt, BigInteger value, Locale l) throws IOException {\n@@ -3432,1 +3428,1 @@\n-                localizedMagnitude(sb, v.toString(), 0, f, adjustWidth(width, f, neg), l);\n+                localizedMagnitude(fmt, sb, v.toString(), 0, flags, adjustWidth(width, flags, neg), l);\n@@ -3437,1 +3433,1 @@\n-                if (neg && f.contains(Flags.PARENTHESES))\n+                if (neg && Flags.contains(flags, Flags.PARENTHESES))\n@@ -3441,1 +3437,1 @@\n-                if (f.contains(Flags.ALTERNATE)) {\n+                if (Flags.contains(flags, Flags.ALTERNATE)) {\n@@ -3445,1 +3441,1 @@\n-                if (f.contains(Flags.ZERO_PAD)) {\n+                if (Flags.contains(flags, Flags.ZERO_PAD)) {\n@@ -3453,1 +3449,1 @@\n-                if (neg && f.contains(Flags.PARENTHESES))\n+                if (neg && Flags.contains(flags, Flags.PARENTHESES))\n@@ -3457,1 +3453,1 @@\n-                if (f.contains(Flags.ALTERNATE)) {\n+                if (Flags.contains(flags, Flags.ALTERNATE)) {\n@@ -3459,1 +3455,1 @@\n-                    sb.append(f.contains(Flags.UPPERCASE) ? \"0X\" : \"0x\");\n+                    sb.append(Flags.contains(flags, Flags.UPPERCASE) ? \"0X\" : \"0x\");\n@@ -3461,1 +3457,1 @@\n-                if (f.contains(Flags.ZERO_PAD)) {\n+                if (Flags.contains(flags, Flags.ZERO_PAD)) {\n@@ -3464,1 +3460,1 @@\n-                if (f.contains(Flags.UPPERCASE))\n+                if (Flags.contains(flags, Flags.UPPERCASE))\n@@ -3473,1 +3469,1 @@\n-            appendJustified(a, sb);\n+            appendJustified(fmt.a, sb);\n@@ -3476,2 +3472,2 @@\n-        private void print(float value, Locale l) throws IOException {\n-            print((double) value, l);\n+        private void print(Formatter fmt, float value, Locale l) throws IOException {\n+            print(fmt, (double) value, l);\n@@ -3480,1 +3476,1 @@\n-        private void print(double value, Locale l) throws IOException {\n+        private void print(Formatter fmt, double value, Locale l) throws IOException {\n@@ -3492,1 +3488,1 @@\n-                    print(sb, v, l, f, c, precision, neg);\n+                    print(fmt, sb, v, l, flags, c, precision, neg);\n@@ -3494,1 +3490,1 @@\n-                    sb.append(f.contains(Flags.UPPERCASE)\n+                    sb.append(Flags.contains(flags, Flags.UPPERCASE)\n@@ -3500,1 +3496,1 @@\n-                sb.append(f.contains(Flags.UPPERCASE) ? \"NAN\" : \"NaN\");\n+                sb.append(Flags.contains(flags, Flags.UPPERCASE) ? \"NAN\" : \"NaN\");\n@@ -3504,1 +3500,1 @@\n-            appendJustified(a, sb);\n+            appendJustified(fmt.a, sb);\n@@ -3508,2 +3504,2 @@\n-        private void print(StringBuilder sb, double value, Locale l,\n-                           Flags f, char c, int precision, boolean neg)\n+        private void print(Formatter fmt, StringBuilder sb, double value, Locale l,\n+                           int flags, char c, int precision, boolean neg)\n@@ -3526,1 +3522,1 @@\n-                if (f.contains(Flags.ALTERNATE) && (prec == 0)) {\n+                if (Flags.contains(flags, Flags.ALTERNATE) && (prec == 0)) {\n@@ -3535,1 +3531,1 @@\n-                    newW = adjustWidth(width - exp.length - 1, f, neg);\n+                    newW = adjustWidth(width - exp.length - 1, flags, neg);\n@@ -3537,1 +3533,1 @@\n-                localizedMagnitude(sb, mant, 0, f, newW, l);\n+                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3539,1 +3535,1 @@\n-                sb.append(f.contains(Flags.UPPERCASE) ? 'E' : 'e');\n+                sb.append(Flags.contains(flags, Flags.UPPERCASE) ? 'E' : 'e');\n@@ -3545,1 +3541,1 @@\n-                localizedMagnitudeExp(sb, exp, 1, l);\n+                localizedMagnitudeExp(fmt, sb, exp, 1, l);\n@@ -3560,1 +3556,1 @@\n-                if (f.contains(Flags.ALTERNATE) && (prec == 0))\n+                if (Flags.contains(flags, Flags.ALTERNATE) && (prec == 0))\n@@ -3565,2 +3561,2 @@\n-                    newW = adjustWidth(width, f, neg);\n-                localizedMagnitude(sb, mant, 0, f, newW, l);\n+                    newW = adjustWidth(width, flags, neg);\n+                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3599,1 +3595,1 @@\n-                if (f.contains(Flags.ALTERNATE) && (prec == 0)) {\n+                if (Flags.contains(flags, Flags.ALTERNATE) && (prec == 0)) {\n@@ -3606,1 +3602,1 @@\n-                        newW = adjustWidth(width - exp.length - 1, f, neg);\n+                        newW = adjustWidth(width - exp.length - 1, flags, neg);\n@@ -3608,1 +3604,1 @@\n-                        newW = adjustWidth(width, f, neg);\n+                        newW = adjustWidth(width, flags, neg);\n@@ -3610,1 +3606,1 @@\n-                localizedMagnitude(sb, mant, 0, f, newW, l);\n+                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3613,1 +3609,1 @@\n-                    sb.append(f.contains(Flags.UPPERCASE) ? 'E' : 'e');\n+                    sb.append(Flags.contains(flags, Flags.UPPERCASE) ? 'E' : 'e');\n@@ -3619,1 +3615,1 @@\n-                    localizedMagnitudeExp(sb, exp, 1, l);\n+                    localizedMagnitudeExp(fmt, sb, exp, 1, l);\n@@ -3632,1 +3628,1 @@\n-                boolean upper = f.contains(Flags.UPPERCASE);\n+                boolean upper = Flags.contains(flags, Flags.UPPERCASE);\n@@ -3635,1 +3631,1 @@\n-                if (f.contains(Flags.ZERO_PAD)) {\n+                if (Flags.contains(flags, Flags.ZERO_PAD)) {\n@@ -3637,2 +3633,2 @@\n-                    if(f.contains(Flags.LEADING_SPACE) ||\n-                            f.contains(Flags.PLUS) || neg) {\n+                    if(Flags.contains(flags, Flags.LEADING_SPACE) ||\n+                            Flags.contains(flags, Flags.PLUS) || neg) {\n@@ -3777,1 +3773,1 @@\n-        private void print(BigDecimal value, Locale l) throws IOException {\n+        private void print(Formatter fmt, BigDecimal value, Locale l) throws IOException {\n@@ -3787,1 +3783,1 @@\n-            print(sb, v, l, f, c, precision, neg);\n+            print(fmt, sb, v, l, flags, c, precision, neg);\n@@ -3793,1 +3789,1 @@\n-            appendJustified(a, sb);\n+            appendJustified(fmt.a, sb);\n@@ -3797,2 +3793,2 @@\n-        private void print(StringBuilder sb, BigDecimal value, Locale l,\n-                           Flags f, char c, int precision, boolean neg)\n+        private void print(Formatter fmt, StringBuilder sb, BigDecimal value, Locale l,\n+                           int flags, char c, int precision, boolean neg)\n@@ -3832,1 +3828,1 @@\n-                        && (nzeros > 0 || (f.contains(Flags.ALTERNATE)))) {\n+                        && (nzeros > 0 || (Flags.contains(flags, Flags.ALTERNATE)))) {\n@@ -3843,1 +3839,1 @@\n-                    newW = adjustWidth(width - exp.length() - 1, f, neg);\n+                    newW = adjustWidth(width - exp.length() - 1, flags, neg);\n@@ -3845,1 +3841,1 @@\n-                localizedMagnitude(sb, mant, 0, f, newW, l);\n+                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3847,1 +3843,1 @@\n-                sb.append(f.contains(Flags.UPPERCASE) ? 'E' : 'e');\n+                sb.append(Flags.contains(flags, Flags.UPPERCASE) ? 'E' : 'e');\n@@ -3849,1 +3845,1 @@\n-                Flags flags = f.dup().remove(Flags.GROUP);\n+                int adaptedFlags = Flags.remove(flags, Flags.GROUP);\n@@ -3854,1 +3850,1 @@\n-                sb.append(localizedMagnitude(null, exp, 1, flags, -1, l));\n+                sb.append(localizedMagnitude(fmt, null, exp, 1, adaptedFlags, -1, l));\n@@ -3886,1 +3882,1 @@\n-                if (bdl.scale() == 0 && (f.contains(Flags.ALTERNATE)\n+                if (bdl.scale() == 0 && (Flags.contains(flags, Flags.ALTERNATE)\n@@ -3895,1 +3891,1 @@\n-                localizedMagnitude(sb, mant, 0, f, adjustWidth(width, f, neg), l);\n+                localizedMagnitude(fmt, sb, mant, 0, flags, adjustWidth(width, flags, neg), l);\n@@ -3923,1 +3919,1 @@\n-                    print(sb, value, l, f, Conversion.DECIMAL_FLOAT, prec,\n+                    print(fmt, sb, value, l, flags, Conversion.DECIMAL_FLOAT, prec,\n@@ -3926,1 +3922,1 @@\n-                    print(sb, value, l, f, Conversion.SCIENTIFIC, prec - 1, neg);\n+                    print(fmt, sb, value, l, flags, Conversion.SCIENTIFIC, prec - 1, neg);\n@@ -4048,1 +4044,1 @@\n-        private int adjustWidth(int width, Flags f, boolean neg) {\n+        private int adjustWidth(int width, int flags, boolean neg) {\n@@ -4050,1 +4046,1 @@\n-            if (newW != -1 && neg && f.contains(Flags.PARENTHESES))\n+            if (newW != -1 && neg && Flags.contains(flags, Flags.PARENTHESES))\n@@ -4062,1 +4058,1 @@\n-        private void print(Calendar t, char c, Locale l)  throws IOException {\n+        private void print(Formatter fmt, Calendar t, char c, Locale l)  throws IOException {\n@@ -4064,1 +4060,1 @@\n-            print(sb, t, c, l);\n+            print(fmt, sb, t, c, l);\n@@ -4067,2 +4063,2 @@\n-            if (f.contains(Flags.UPPERCASE)) {\n-                appendJustified(a, toUpperCaseWithLocale(sb.toString(), l));\n+            if (Flags.contains(flags, Flags.UPPERCASE)) {\n+                appendJustified(fmt.a, toUpperCaseWithLocale(sb.toString(), l));\n@@ -4070,1 +4066,1 @@\n-                appendJustified(a, sb);\n+                appendJustified(fmt.a, sb);\n@@ -4074,1 +4070,1 @@\n-        private Appendable print(StringBuilder sb, Calendar t, char c, Locale l)\n+        private Appendable print(Formatter fmt, StringBuilder sb, Calendar t, char c, Locale l)\n@@ -4086,1 +4082,1 @@\n-                Flags flags = (c == DateTime.HOUR_OF_DAY_0\n+                int flags = (c == DateTime.HOUR_OF_DAY_0\n@@ -4090,1 +4086,1 @@\n-                sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                sb.append(localizedMagnitude(fmt, null, i, flags, 2, l));\n@@ -4095,2 +4091,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4101,2 +4096,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, 9, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 9, l));\n@@ -4107,2 +4101,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, 3, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 3, l));\n@@ -4113,2 +4106,1 @@\n-                Flags flags = Flags.NONE;\n-                sb.append(localizedMagnitude(null, i, flags, width, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.NONE, width, l));\n@@ -4131,2 +4123,1 @@\n-                Flags flags = Flags.NONE;\n-                sb.append(localizedMagnitude(null, i, flags, width, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.NONE, width, l));\n@@ -4137,2 +4128,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4150,1 +4140,0 @@\n-                Flags flags = Flags.ZERO_PAD;\n@@ -4152,1 +4141,1 @@\n-                sb.append(localizedMagnitude(null, offset, flags, 4, l));\n+                sb.append(localizedMagnitude(fmt, null, offset, Flags.ZERO_PAD, 4, l));\n@@ -4197,2 +4186,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, size, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, size, l));\n@@ -4204,1 +4192,1 @@\n-                Flags flags = (c == DateTime.DAY_OF_MONTH_0\n+                int flags = (c == DateTime.DAY_OF_MONTH_0\n@@ -4207,1 +4195,1 @@\n-                sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                sb.append(localizedMagnitude(fmt, null, i, flags, 2, l));\n@@ -4212,2 +4200,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, 3, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 3, l));\n@@ -4218,2 +4205,1 @@\n-                Flags flags = Flags.ZERO_PAD;\n-                sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4227,2 +4213,2 @@\n-                print(sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);\n-                print(sb, t, DateTime.MINUTE, l);\n+                print(fmt, sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);\n+                print(fmt, sb, t, DateTime.MINUTE, l);\n@@ -4231,1 +4217,1 @@\n-                    print(sb, t, DateTime.SECOND, l);\n+                    print(fmt, sb, t, DateTime.SECOND, l);\n@@ -4237,3 +4223,3 @@\n-                print(sb, t, DateTime.HOUR_0, l).append(sep);\n-                print(sb, t, DateTime.MINUTE, l).append(sep);\n-                print(sb, t, DateTime.SECOND, l).append(' ');\n+                print(fmt, sb, t, DateTime.HOUR_0, l).append(sep);\n+                print(fmt, sb, t, DateTime.MINUTE, l).append(sep);\n+                print(fmt, sb, t, DateTime.SECOND, l).append(' ');\n@@ -4242,1 +4228,1 @@\n-                print(tsb, t, DateTime.AM_PM, l);\n+                print(fmt, tsb, t, DateTime.AM_PM, l);\n@@ -4249,6 +4235,6 @@\n-                print(sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);\n-                print(sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);\n-                print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n-                print(sb, t, DateTime.TIME, l).append(sep);\n-                print(sb, t, DateTime.ZONE, l).append(sep);\n-                print(sb, t, DateTime.YEAR_4, l);\n+                print(fmt, sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);\n+                print(fmt, sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);\n+                print(fmt, sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n+                print(fmt, sb, t, DateTime.TIME, l).append(sep);\n+                print(fmt, sb, t, DateTime.ZONE, l).append(sep);\n+                print(fmt, sb, t, DateTime.YEAR_4, l);\n@@ -4259,3 +4245,3 @@\n-                print(sb, t, DateTime.MONTH, l).append(sep);\n-                print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n-                print(sb, t, DateTime.YEAR_2, l);\n+                print(fmt, sb, t, DateTime.MONTH, l).append(sep);\n+                print(fmt, sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n+                print(fmt, sb, t, DateTime.YEAR_2, l);\n@@ -4266,3 +4252,3 @@\n-                print(sb, t, DateTime.YEAR_4, l).append(sep);\n-                print(sb, t, DateTime.MONTH, l).append(sep);\n-                print(sb, t, DateTime.DAY_OF_MONTH_0, l);\n+                print(fmt, sb, t, DateTime.YEAR_4, l).append(sep);\n+                print(fmt, sb, t, DateTime.MONTH, l).append(sep);\n+                print(fmt, sb, t, DateTime.DAY_OF_MONTH_0, l);\n@@ -4277,1 +4263,1 @@\n-        private void print(TemporalAccessor t, char c, Locale l)  throws IOException {\n+        private void print(Formatter fmt, TemporalAccessor t, char c, Locale l)  throws IOException {\n@@ -4279,1 +4265,1 @@\n-            print(sb, t, c, l);\n+            print(fmt, sb, t, c, l);\n@@ -4281,2 +4267,2 @@\n-            if (f.contains(Flags.UPPERCASE)) {\n-                appendJustified(a, toUpperCaseWithLocale(sb.toString(), l));\n+            if (Flags.contains(flags, Flags.UPPERCASE)) {\n+                appendJustified(fmt.a, toUpperCaseWithLocale(sb.toString(), l));\n@@ -4284,1 +4270,1 @@\n-                appendJustified(a, sb);\n+                appendJustified(fmt.a, sb);\n@@ -4288,1 +4274,1 @@\n-        private Appendable print(StringBuilder sb, TemporalAccessor t, char c,\n+        private Appendable print(Formatter fmt, StringBuilder sb, TemporalAccessor t, char c,\n@@ -4296,1 +4282,1 @@\n-                    sb.append(localizedMagnitude(null, i, Flags.ZERO_PAD, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4301,1 +4287,1 @@\n-                    sb.append(localizedMagnitude(null, i, Flags.NONE, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.NONE, 2, l));\n@@ -4306,1 +4292,1 @@\n-                    sb.append(localizedMagnitude(null, i, Flags.ZERO_PAD, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4311,1 +4297,1 @@\n-                    sb.append(localizedMagnitude(null, i, Flags.NONE, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.NONE, 2, l));\n@@ -4316,2 +4302,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4327,2 +4312,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, 9, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 9, l));\n@@ -4333,2 +4317,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, 3, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 3, l));\n@@ -4340,2 +4323,1 @@\n-                    Flags flags = Flags.NONE;\n-                    sb.append(localizedMagnitude(null, i, flags, width, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.NONE, width, l));\n@@ -4358,2 +4340,1 @@\n-                    Flags flags = Flags.NONE;\n-                    sb.append(localizedMagnitude(null, i, flags, width, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.NONE, width, l));\n@@ -4364,2 +4345,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4377,2 +4357,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, offset, flags, 4, l));\n+                    sb.append(localizedMagnitude(fmt, null, offset, Flags.ZERO_PAD, 4, l));\n@@ -4432,2 +4411,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, size, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, size, l));\n@@ -4439,1 +4417,1 @@\n-                    Flags flags = (c == DateTime.DAY_OF_MONTH_0\n+                    int flags = (c == DateTime.DAY_OF_MONTH_0\n@@ -4442,1 +4420,1 @@\n-                    sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, flags, 2, l));\n@@ -4447,2 +4425,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, 3, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 3, l));\n@@ -4453,2 +4430,1 @@\n-                    Flags flags = Flags.ZERO_PAD;\n-                    sb.append(localizedMagnitude(null, i, flags, 2, l));\n+                    sb.append(localizedMagnitude(fmt, null, i, Flags.ZERO_PAD, 2, l));\n@@ -4462,2 +4438,2 @@\n-                    print(sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);\n-                    print(sb, t, DateTime.MINUTE, l);\n+                    print(fmt, sb, t, DateTime.HOUR_OF_DAY_0, l).append(sep);\n+                    print(fmt, sb, t, DateTime.MINUTE, l);\n@@ -4466,1 +4442,1 @@\n-                        print(sb, t, DateTime.SECOND, l);\n+                        print(fmt, sb, t, DateTime.SECOND, l);\n@@ -4472,3 +4448,3 @@\n-                    print(sb, t, DateTime.HOUR_0, l).append(sep);\n-                    print(sb, t, DateTime.MINUTE, l).append(sep);\n-                    print(sb, t, DateTime.SECOND, l).append(' ');\n+                    print(fmt, sb, t, DateTime.HOUR_0, l).append(sep);\n+                    print(fmt, sb, t, DateTime.MINUTE, l).append(sep);\n+                    print(fmt, sb, t, DateTime.SECOND, l).append(' ');\n@@ -4477,1 +4453,1 @@\n-                    print(tsb, t, DateTime.AM_PM, l);\n+                    print(fmt, tsb, t, DateTime.AM_PM, l);\n@@ -4483,6 +4459,6 @@\n-                    print(sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);\n-                    print(sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);\n-                    print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n-                    print(sb, t, DateTime.TIME, l).append(sep);\n-                    print(sb, t, DateTime.ZONE, l).append(sep);\n-                    print(sb, t, DateTime.YEAR_4, l);\n+                    print(fmt, sb, t, DateTime.NAME_OF_DAY_ABBREV, l).append(sep);\n+                    print(fmt, sb, t, DateTime.NAME_OF_MONTH_ABBREV, l).append(sep);\n+                    print(fmt, sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n+                    print(fmt, sb, t, DateTime.TIME, l).append(sep);\n+                    print(fmt, sb, t, DateTime.ZONE, l).append(sep);\n+                    print(fmt, sb, t, DateTime.YEAR_4, l);\n@@ -4493,3 +4469,3 @@\n-                    print(sb, t, DateTime.MONTH, l).append(sep);\n-                    print(sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n-                    print(sb, t, DateTime.YEAR_2, l);\n+                    print(fmt, sb, t, DateTime.MONTH, l).append(sep);\n+                    print(fmt, sb, t, DateTime.DAY_OF_MONTH_0, l).append(sep);\n+                    print(fmt, sb, t, DateTime.YEAR_2, l);\n@@ -4500,3 +4476,3 @@\n-                    print(sb, t, DateTime.YEAR_4, l).append(sep);\n-                    print(sb, t, DateTime.MONTH, l).append(sep);\n-                    print(sb, t, DateTime.DAY_OF_MONTH_0, l);\n+                    print(fmt, sb, t, DateTime.YEAR_4, l).append(sep);\n+                    print(fmt, sb, t, DateTime.MONTH, l).append(sep);\n+                    print(fmt, sb, t, DateTime.DAY_OF_MONTH_0, l);\n@@ -4516,2 +4492,2 @@\n-        private void failMismatch(Flags f, char c) {\n-            String fs = f.toString();\n+        private void failMismatch(int f, char c) {\n+            String fs = Flags.toString(f);\n@@ -4525,2 +4501,2 @@\n-        private char getZero(Locale l) {\n-            if ((l != null) &&  !l.equals(locale())) {\n+        private char getZero(Formatter fmt, Locale l) {\n+            if ((l != null) &&  !l.equals(fmt.locale())) {\n@@ -4530,1 +4506,1 @@\n-            return zero();\n+            return fmt.zero();\n@@ -4533,3 +4509,3 @@\n-        private StringBuilder localizedMagnitude(StringBuilder sb,\n-                long value, Flags f, int width, Locale l) {\n-            return localizedMagnitude(sb, Long.toString(value, 10), 0, f, width, l);\n+        private StringBuilder localizedMagnitude(Formatter fmt, StringBuilder sb,\n+                long value, int flags, int width, Locale l) {\n+            return localizedMagnitude(fmt, sb, Long.toString(value, 10), 0, flags, width, l);\n@@ -4538,2 +4514,2 @@\n-        private StringBuilder localizedMagnitude(StringBuilder sb,\n-                CharSequence value, final int offset, Flags f, int width,\n+        private StringBuilder localizedMagnitude(Formatter fmt, StringBuilder sb,\n+                CharSequence value, final int offset, int f, int width,\n@@ -4546,1 +4522,1 @@\n-            char zero = getZero(l);\n+            char zero = getZero(fmt, l);\n@@ -4571,1 +4547,1 @@\n-            if (f.contains(Flags.GROUP)) {\n+            if (Flags.contains(f, Flags.GROUP)) {\n@@ -4625,1 +4601,1 @@\n-            if (width != -1 && f.contains(Flags.ZERO_PAD)) {\n+            if (width != -1 && Flags.contains(f, Flags.ZERO_PAD)) {\n@@ -4637,1 +4613,1 @@\n-        private void localizedMagnitudeExp(StringBuilder sb, char[] value,\n+        private void localizedMagnitudeExp(Formatter fmt, StringBuilder sb, char[] value,\n@@ -4639,1 +4615,1 @@\n-            char zero = getZero(l);\n+            char zero = getZero(fmt, l);\n@@ -4650,1 +4626,0 @@\n-        private int flags;\n@@ -4652,1 +4627,1 @@\n-        static final Flags NONE          = new Flags(0);      \/\/ ''\n+        static final int NONE          = 0;      \/\/ ''\n@@ -4655,3 +4630,3 @@\n-        static final Flags LEFT_JUSTIFY  = new Flags(1<<0);   \/\/ '-'\n-        static final Flags UPPERCASE     = new Flags(1<<1);   \/\/ '^'\n-        static final Flags ALTERNATE     = new Flags(1<<2);   \/\/ '#'\n+        static final int LEFT_JUSTIFY  = 1<<0;   \/\/ '-'\n+        static final int UPPERCASE     = 1<<1;   \/\/ '^'\n+        static final int ALTERNATE     = 1<<2;   \/\/ '#'\n@@ -4660,5 +4635,5 @@\n-        static final Flags PLUS          = new Flags(1<<3);   \/\/ '+'\n-        static final Flags LEADING_SPACE = new Flags(1<<4);   \/\/ ' '\n-        static final Flags ZERO_PAD      = new Flags(1<<5);   \/\/ '0'\n-        static final Flags GROUP         = new Flags(1<<6);   \/\/ ','\n-        static final Flags PARENTHESES   = new Flags(1<<7);   \/\/ '('\n+        static final int PLUS          = 1<<3;   \/\/ '+'\n+        static final int LEADING_SPACE = 1<<4;   \/\/ ' '\n+        static final int ZERO_PAD      = 1<<5;   \/\/ '0'\n+        static final int GROUP         = 1<<6;   \/\/ ','\n+        static final int PARENTHESES   = 1<<7;   \/\/ '('\n@@ -4667,9 +4642,1 @@\n-        static final Flags PREVIOUS      = new Flags(1<<8);   \/\/ '<'\n-\n-        private Flags(int f) {\n-            flags = f;\n-        }\n-\n-        public int valueOf() {\n-            return flags;\n-        }\n+        static final int PREVIOUS      = 1<<8;   \/\/ '<'\n@@ -4677,2 +4644,2 @@\n-        public boolean contains(Flags f) {\n-            return (flags & f.valueOf()) == f.valueOf();\n+        public static boolean contains(int flags, int f) {\n+            return (flags & f) == f;\n@@ -4681,2 +4648,2 @@\n-        public Flags dup() {\n-            return new Flags(flags);\n+        public static boolean containsAny(int flags, int f) {\n+            return (flags & f) != 0;\n@@ -4685,3 +4652,2 @@\n-        private Flags add(Flags f) {\n-            flags |= f.valueOf();\n-            return this;\n+        private static int add(int flags, int f) {\n+            return flags | f;\n@@ -4690,3 +4656,2 @@\n-        public Flags remove(Flags f) {\n-            flags &= ~f.valueOf();\n-            return this;\n+        public static int remove(int flags, int f) {\n+            return flags & ~f;\n@@ -4695,2 +4660,2 @@\n-        public static Flags parse(String s, int start, int end) {\n-            Flags f = new Flags(0);\n+        public static int parse(String s, int start, int end) {\n+            int f = 0;\n@@ -4699,4 +4664,4 @@\n-                Flags v = parse(c);\n-                if (f.contains(v))\n-                    throw new DuplicateFormatFlagsException(v.toString());\n-                f.add(v);\n+                int v = parse(c);\n+                if (contains(f, v))\n+                    throw new DuplicateFormatFlagsException(toString(v));\n+                f = add(f, v);\n@@ -4708,1 +4673,1 @@\n-        private static Flags parse(char c) {\n+        private static int parse(char c) {\n@@ -4723,5 +4688,1 @@\n-        public static String toString(Flags f) {\n-            return f.toString();\n-        }\n-\n-        public String toString() {\n+        public static String toString(int f) {\n@@ -4729,9 +4690,9 @@\n-            if (contains(LEFT_JUSTIFY))  sb.append('-');\n-            if (contains(UPPERCASE))     sb.append('^');\n-            if (contains(ALTERNATE))     sb.append('#');\n-            if (contains(PLUS))          sb.append('+');\n-            if (contains(LEADING_SPACE)) sb.append(' ');\n-            if (contains(ZERO_PAD))      sb.append('0');\n-            if (contains(GROUP))         sb.append(',');\n-            if (contains(PARENTHESES))   sb.append('(');\n-            if (contains(PREVIOUS))      sb.append('<');\n+            if (contains(f, LEFT_JUSTIFY))  sb.append('-');\n+            if (contains(f, UPPERCASE))     sb.append('^');\n+            if (contains(f, ALTERNATE))     sb.append('#');\n+            if (contains(f, PLUS))          sb.append('+');\n+            if (contains(f, LEADING_SPACE)) sb.append(' ');\n+            if (contains(f, ZERO_PAD))      sb.append('0');\n+            if (contains(f, GROUP))         sb.append(',');\n+            if (contains(f, PARENTHESES))   sb.append('(');\n+            if (contains(f, PREVIOUS))      sb.append('<');\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":294,"deletions":333,"binary":false,"changes":627,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -515,5 +515,2 @@\n-        return (this.mostSigBits < val.mostSigBits ? -1 :\n-                (this.mostSigBits > val.mostSigBits ? 1 :\n-                 (this.leastSigBits < val.leastSigBits ? -1 :\n-                  (this.leastSigBits > val.leastSigBits ? 1 :\n-                   0))));\n+        int mostSigBits = Long.compare(this.mostSigBits, val.mostSigBits);\n+        return mostSigBits != 0 ? mostSigBits : Long.compare(this.leastSigBits, val.leastSigBits);\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -343,1 +343,1 @@\n-            throw new NoSuchAlgorithmException(\"Invalid transformation:\" +\n+            throw new NoSuchAlgorithmException(\"Invalid transformation: \" +\n","filename":"src\/java.base\/share\/classes\/javax\/crypto\/Cipher.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-        return length;\n+        return current - offset + length;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/ImageStringsReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-      * Is sharing enabled via the UseSharedSpaces flag.\n+      * Is sharing enabled.\n@@ -235,2 +235,0 @@\n-         \"-XX:+DumpSharedSpaces\",\n-         \"-XX:+DynamicDumpSharedSpaces\",\n@@ -241,3 +239,1 @@\n-         \"-XX:ArchiveClassesAtExit=\",\n-         \"-XX:+UseSharedSpaces\",\n-         \"-XX:+RequireSharedSpaces\"};\n+         \"-XX:ArchiveClassesAtExit=\"};\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/CDS.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -225,1 +225,1 @@\n-        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V18) {\n+        if (checkClassVersion && readShort(classFileOffset + 6) > Opcodes.V19) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/ClassReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -317,0 +317,1 @@\n+    int V19 = 0 << 16 | 63;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/org\/objectweb\/asm\/Opcodes.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -117,0 +117,4 @@\n+    \/\/ Various broadcasting modes.\n+    public static final int MODE_BROADCAST = 0;\n+    public static final int MODE_BITS_COERCED_LONG_TO_MASK = 1;\n+\n@@ -160,3 +164,3 @@\n-    public interface BroadcastOperation<VM extends VectorPayload,\n-                                        S extends VectorSpecies<?>> {\n-        VM broadcast(long l, S s);\n+    public interface FromBitsCoercedOperation<VM extends VectorPayload,\n+                                              S extends VectorSpecies<?>> {\n+        VM fromBits(long l, S s);\n@@ -170,4 +174,4 @@\n-    VM broadcastCoerced(Class<? extends VM> vmClass, Class<E> eClass,\n-                        int length,\n-                        long bits, S s,\n-                        BroadcastOperation<VM, S> defaultImpl) {\n+    VM fromBitsCoerced(Class<? extends VM> vmClass, Class<E> eClass,\n+                       int length,\n+                       long bits, int mode, S s,\n+                       FromBitsCoercedOperation<VM, S> defaultImpl) {\n@@ -175,1 +179,1 @@\n-        return defaultImpl.broadcast(bits, s);\n+        return defaultImpl.fromBits(bits, s);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/vector\/VectorSupport.java","additions":12,"deletions":8,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -484,1 +484,1 @@\n-            throw new IOException(\"PKCS9 IssuerAndSerialNumber\" +\n+            throw new IOException(\"PKCS9 IssuerAndSerialNumber \" +\n@@ -489,1 +489,1 @@\n-            throw new IOException(\"PKCS9 RSA DSI attributes\" +\n+            throw new IOException(\"PKCS9 RSA DSI attributes \" +\n@@ -607,1 +607,1 @@\n-            throw new IOException(\"PKCS9 IssuerAndSerialNumber\" +\n+            throw new IOException(\"PKCS9 IssuerAndSerialNumber \" +\n@@ -612,1 +612,1 @@\n-            throw new IOException(\"PKCS9 RSA DSI attributes\" +\n+            throw new IOException(\"PKCS9 RSA DSI attributes \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs\/PKCS9Attribute.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -638,1 +638,1 @@\n-                    throw new KeyStoreException(\"Private key is not encoded\" +\n+                    throw new KeyStoreException(\"Private key is not encoded \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/pkcs12\/PKCS12KeyStore.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -273,1 +273,1 @@\n-            throw new BadPaddingException(\"Decryption error.\" +\n+            throw new BadPaddingException(\"Decryption error. \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/rsa\/RSAPadding.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-                            \"The number of CAs exceeds the maximum size\" +\n+                            \"The number of CAs exceeds the maximum size \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CertificateAuthoritiesExtension.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -385,7 +385,6 @@\n-                    \/\/ the results will either be a single perfect match\n-                    \/\/ or 1 or more imperfect matches\n-                    \/\/ if it's a perfect match, return immediately\n-                    EntryStatus status = results.get(0);\n-                    if (status.checkResult == CheckResult.OK) {\n-                        if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n-                            SSLLogger.fine(\"KeyMgr: choosing key: \" + status);\n+                    for (EntryStatus status : results) {\n+                        if (status.checkResult == CheckResult.OK) {\n+                            if (SSLLogger.isOn && SSLLogger.isOn(\"keymanager\")) {\n+                                SSLLogger.fine(\"KeyMgr: choosing key: \" + status);\n+                            }\n+                            return makeAlias(status);\n@@ -393,1 +392,0 @@\n-                        return makeAlias(status);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/X509KeyManagerImpl.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -454,1 +454,1 @@\n-                        debug.println(\"Constraints: failed key size\" +\n+                        debug.println(\"Constraints: failed key size \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/DisabledAlgorithmConstraints.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-                    throw new IOException(\"Duplicate requireExplicitPolicy\" +\n+                    throw new IOException(\"Duplicate requireExplicitPolicy \" +\n@@ -165,1 +165,1 @@\n-                    throw new IOException(\"Duplicate inhibitPolicyMapping\" +\n+                    throw new IOException(\"Duplicate inhibitPolicyMapping \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PolicyConstraintsExtension.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-                        throw new IOException(\"Attribute value must be a\" +\n+                        throw new IOException(\"Attribute value must be a \" +\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/PolicyInformation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JAVA\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JAVA\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n@@ -184,1 +184,1 @@\n-(\\f[CB]18\\f[R]) and a limited number of previous releases, detailed in the\n+(\\f[CB]19\\f[R]) and a limited number of previous releases, detailed in the\n@@ -4042,0 +4042,8 @@\n+.SH REMOVED JAVA OPTIONS\n+.PP\n+These \\f[CB]java\\f[R] options have been removed in JDK 19 and using them\n+results in an error of:\n+.RS\n+.PP\n+\\f[CB]Unrecognized\\ VM\\ option\\f[R] \\f[I]option\\-name\\f[R]\n+.RE\n@@ -4049,2 +4057,0 @@\n-.PP\n-By default, this option is disabled.\n@@ -4052,3 +4058,0 @@\n-.SH REMOVED JAVA OPTIONS\n-.PP\n-No documented \\f[CB]java\\f[R] options have been removed in JDK 18.\n@@ -4059,0 +4062,3 @@\n+\\f[B]The \\f[BC]java\\f[B] Command, Release 18\\f[R]\n+[https:\/\/docs.oracle.com\/en\/java\/javase\/18\/docs\/specs\/man\/java.html]\n+.IP \\[bu] 2\n","filename":"src\/java.base\/share\/man\/java.1","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"KEYTOOL\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"KEYTOOL\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/java.base\/share\/man\/keytool.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -255,1 +255,9 @@\n-    RELEASE_18;\n+    RELEASE_18,\n+\n+    \/**\n+     * The version recognized by the Java Platform, Standard Edition\n+     * 19.\n+     *\n+     * @since 19\n+     *\/\n+    RELEASE_19;\n@@ -264,1 +272,1 @@\n-        return RELEASE_18;\n+        return RELEASE_19;\n@@ -279,1 +287,1 @@\n-            valueOf(\"RELEASE_\" + Math.min(18, intVersion)):\n+            valueOf(\"RELEASE_\" + Math.min(19, intVersion)):\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-@SupportedSourceVersion(RELEASE_18)\n+@SupportedSourceVersion(RELEASE_19)\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitor14.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-        FontManager fm = FontManagerFactory.getInstance();\n+        CFontManager fm = (CFontManager) FontManagerFactory.getInstance();\n@@ -225,1 +225,1 @@\n-            Font2D f2d = fm.findFont2D(s, Font.PLAIN, FontManager.NO_FALLBACK);\n+            Font2D f2d = fm.getOrCreateFallbackFont(s);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFont.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.Map;\n@@ -38,0 +39,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -48,0 +50,1 @@\n+    private final Map<String, Font2D> fallbackFonts = new ConcurrentHashMap<>();\n@@ -324,0 +327,13 @@\n+\n+    Font2D getOrCreateFallbackFont(String fontName) {\n+        Font2D font2D = findFont2D(fontName, Font.PLAIN, FontManager.NO_FALLBACK);\n+        if (font2D != null || fontName.startsWith(\".\")) {\n+            return font2D;\n+        } else {\n+            \/\/ macOS doesn't list some system fonts in [NSFontManager availableFontFamilies] output,\n+            \/\/ so they are not registered in font manager as part of 'loadNativeFonts'.\n+            \/\/ These fonts are present in [NSFontManager availableFonts] output though,\n+            \/\/ and can be accessed in the same way as other system fonts.\n+            return fallbackFonts.computeIfAbsent(fontName, name -> new CFont(name, null));\n+        }\n+    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFontManager.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1536,6 +1536,1 @@\n-            Arrays.sort(rangeArray,\n-                        new Comparator<Range>() {\n-                            public int compare(Range s1, Range s2) {\n-                                return s1.base > s2.base ? 1 : s1.base == s2.base ? 0 : -1;\n-                            }\n-                        });\n+            Arrays.sort(rangeArray, Comparator.comparingInt(s -> s.base));\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.awt.dnd.*;\n@@ -33,3 +32,0 @@\n-import java.util.EventObject;\n-import java.util.Hashtable;\n-import java.util.TooManyListenersException;\n@@ -39,1 +35,0 @@\n-import javax.swing.text.*;\n@@ -224,2 +219,2 @@\n-                dx = sign(dx);\n-                dy = sign(dy);\n+                dx = Integer.signum(dx);\n+                dy = Integer.signum(dy);\n@@ -253,4 +248,0 @@\n-        private static int sign(int num) {\n-            return (num < 0) ? -1 : ((num == 0) ? 0 : 1);\n-        }\n-\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicTableUI.java","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,7 +507,1 @@\n-        if (o1.index < o2.index) {\n-            return -1;\n-        } else if (o1.index > o2.index) {\n-            return 1;\n-        } else {\n-            return 0;\n-        }\n+      return Integer.compare(o1.index, o2.index);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/GapContent.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,7 @@\n-import java.io.*;\n-import java.text.*;\n-import java.util.*;\n-import javax.swing.*;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.Serial;\n+import java.text.ParseException;\n+import java.util.ArrayList;\n+import javax.swing.JFormattedTextField;\n+import javax.swing.text.DefaultFormatter;\n@@ -103,1 +106,1 @@\n- *   formatter.getDisplayValue(tf, \"123\");\n+ *   System.out.println(formatter.valueToString(\"123\"));\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/MaskFormatter.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -734,6 +734,6 @@\n-            return -1;\n-        }\n-        if (x1 > x2) {\n-            return 1;\n-        }\n-        return 0;\n+             return -1;\n+         }\n+         if (x1 > x2) {\n+             return 1;\n+         }\n+         return 0;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/geom\/Curve.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2000, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,0 +318,1 @@\n+        @Override\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Spans.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-            return (id1 == id2 ? 0 : (id1 < id2 ? -1 : 1));\n+            return Integer.compare(id1, id2);\n@@ -91,1 +91,1 @@\n-            return (id1 == id2 ? 0 : (id1 < id2 ? -1 : 1));\n+            return Integer.compare(id1, id2);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/loops\/GraphicsPrimitiveMgr.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,3 +28,5 @@\n-import java.awt.*;\n-import java.awt.geom.*;\n-\n+import java.awt.AlphaComposite;\n+import java.awt.Composite;\n+import java.awt.Paint;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.NoninvertibleTransformException;\n@@ -34,3 +36,4 @@\n-import sun.font.*;\n-import sun.java2d.*;\n-import sun.java2d.loops.*;\n+import sun.awt.image.PixelConverter;\n+import sun.font.XRTextRenderer;\n+import sun.java2d.SunGraphics2D;\n+import sun.java2d.loops.XORComposite;\n@@ -71,0 +74,1 @@\n+    int eargb;\n@@ -173,2 +177,4 @@\n-        if (sg2d != null && (validatedPixel != sg2d.pixel  || updatePaint)) {\n-            validatedPixel = sg2d.pixel;\n+        if (sg2d != null && (eargb != sg2d.eargb || updatePaint)) {\n+            eargb = sg2d.eargb;\n+            validatedPixel = PixelConverter.ArgbPre.instance\n+                                           .rgbToPixel(eargb, null);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRCompositeManager.java","additions":14,"deletions":8,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import java.awt.Transparency;\n-import sun.awt.X11GraphicsConfig;\n@@ -31,0 +29,1 @@\n+import sun.awt.X11GraphicsConfig;\n@@ -35,1 +34,0 @@\n-import sun.java2d.loops.SurfaceType;\n@@ -61,10 +59,0 @@\n-\n-    public synchronized SurfaceType getSurfaceType() {\n-        if (surfaceType != null) {\n-            return surfaceType;\n-        }\n-\n-        surfaceType = XRSurfaceData.getSurfaceType(this, Transparency.OPAQUE);\n-        return surfaceType;\n-    }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRGraphicsConfig.java","additions":2,"deletions":14,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,1 @@\n+import sun.font.FontManagerNativeLibrary;\n@@ -58,1 +60,0 @@\n-import sun.font.FontManagerNativeLibrary;\n@@ -279,1 +280,1 @@\n-            (gc, width, height, image, getSurfaceType(gc, transparency),\n+            (gc, width, height, image, getPixmapSurfaceType(transparency),\n@@ -398,2 +399,1 @@\n-    public static SurfaceType getSurfaceType(XRGraphicsConfig gc,\n-                                             int transparency) {\n+    public static SurfaceType getPixmapSurfaceType(int transparency) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRSurfaceData.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"RMIREGISTRY\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"RMIREGISTRY\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/java.rmi\/share\/man\/rmiregistry.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JRUNSCRIPT\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JRUNSCRIPT\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/java.scripting\/share\/man\/jrunscript.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-                    System.out.println(\"Permission to initiate\" +\n+                    System.out.println(\"Permission to initiate \" +\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/krb5\/Krb5MechFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,3 @@\n-                id = id.substring(i1+1, i2);\n+                if (i1 >= 0 && i2 >= 0) {\n+                    id = id.substring(i1 + 1, i2);\n+                }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/DOMURIDereferencer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -97,1 +97,3 @@\n-            id = id.substring(i1+1, i2);\n+            if (i1 >= 0 && i2 >= 0) {\n+                id = id.substring(i1 + 1, i2);\n+            }\n","filename":"src\/java.xml.crypto\/share\/classes\/org\/jcp\/xml\/dsig\/internal\/dom\/Utils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -983,1 +983,1 @@\n-            toClear.stream().forEach(c -> {\n+            toClear.forEach(c -> {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -120,1 +120,6 @@\n-    JDK18(\"18\");\n+    JDK18(\"18\"),\n+\n+    \/**\n+      * 19, tbd\n+      *\/\n+    JDK19(\"19\");\n@@ -172,0 +177,1 @@\n+        case JDK19  -> Target.JDK1_19;\n@@ -316,0 +322,1 @@\n+        case JDK19  -> RELEASE_19;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2281,0 +2281,5 @@\n+        @Override\n+        public Name name() {\n+            return name;\n+        }\n+\n@@ -2319,0 +2324,5 @@\n+        @Override\n+        public Name name() {\n+            return name;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,3 @@\n-import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.JCTree.JCAnnotatedType;\n+import com.sun.tools.javac.tree.JCTree.JCAnnotation;\n+import com.sun.tools.javac.tree.JCTree.JCArrayTypeTree;\n@@ -63,0 +65,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n@@ -64,0 +67,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCMemberReference;\n@@ -66,0 +70,1 @@\n+import com.sun.tools.javac.tree.JCTree.JCNewArray;\n@@ -68,0 +73,3 @@\n+import com.sun.tools.javac.tree.JCTree.JCTypeIntersection;\n+import com.sun.tools.javac.tree.JCTree.JCTypeParameter;\n+import com.sun.tools.javac.tree.JCTree.JCTypeUnion;\n@@ -69,0 +77,2 @@\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeInfo;\n@@ -70,1 +80,0 @@\n-import com.sun.tools.javac.tree.JCTree.*;\n@@ -1135,1 +1144,1 @@\n-                tree.sym.getRecordComponents().stream().forEach(rc -> scan(rc.accessorMeth));\n+                tree.sym.getRecordComponents().forEach(rc -> scan(rc.accessorMeth));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/TypeAnnotations.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -196,1 +196,1 @@\n-                rollback.stream().forEach(Runnable::run);\n+                rollback.forEach(Runnable::run);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrRecover.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.HashSet;\n@@ -396,1 +395,1 @@\n-            roots.stream().forEach(this::visit);\n+            roots.forEach(this::visit);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/InferenceContext.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2945,3 +2945,0 @@\n-                                final JCDiagnostic details = sym.kind == WRONG_MTH ?\n-                                                ((InapplicableSymbolError)sym.baseSymbol()).errCandidate().snd :\n-                                                null;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -181,7 +181,0 @@\n-        @Override @DefinedBy(Api.COMPILER)\n-        public URI toUri() {\n-            \/\/ Work around bug JDK-8134451:\n-            \/\/ path.toUri() returns double-encoded URIs, that cannot be opened by URLConnection\n-            return createJarUri(userJarPath, path.toString());\n-        }\n-\n@@ -200,11 +193,0 @@\n-\n-        private static URI createJarUri(Path jarFile, String entryName) {\n-            URI jarURI = jarFile.toUri().normalize();\n-            String separator = entryName.startsWith(\"\/\") ? \"!\" : \"!\/\";\n-            try {\n-                \/\/ The jar URI convention appears to be not to re-encode the jarURI\n-                return new URI(\"jar:\" + jarURI + separator + entryName);\n-            } catch (URISyntaxException e) {\n-                throw new CannotCreateUriError(jarURI + separator + entryName, e);\n-            }\n-        }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/file\/PathFileObject.java","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -122,1 +122,2 @@\n-        V62(62, 0);   \/\/ JDK 18\n+        V62(62, 0),   \/\/ JDK 18\n+        V63(63, 0);   \/\/ JDK 19\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassFile.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -137,0 +137,5 @@\n+        \/**\n+         * The dynamic constant's name.\n+         *\/\n+        Name name();\n+\n@@ -153,1 +158,1 @@\n-            return new Pair<>(bsmKey(types), dynamicType().poolKey(types));\n+            return new PoolKey(name(), bsmKey(types), dynamicType().poolKey(types));\n@@ -195,0 +200,2 @@\n+\n+        record PoolKey(Name name, BsmKey bsmKey, Object dynamicType) {}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/PoolConstant.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -91,1 +91,4 @@\n-    JDK1_18(\"18\", 62, 0);\n+    JDK1_18(\"18\", 62, 0),\n+\n+    \/** JDK 19. *\/\n+    JDK1_19(\"19\", 63, 0);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Target.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import java.util.stream.Collectors;\n@@ -49,1 +48,0 @@\n-import javax.tools.StandardJavaFileManager;\n@@ -1645,1 +1643,1 @@\n-                        originalAnnos.stream().forEach(a -> visitAnnotation(a));\n+                        originalAnnos.forEach(a -> visitAnnotation(a));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/JavacProcessingEnvironment.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-@SupportedSourceVersion(SourceVersion.RELEASE_18)\n+@SupportedSourceVersion(SourceVersion.RELEASE_19)\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAVAC\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JAVAC\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.compiler\/share\/man\/javac.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"SERIALVER\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"SERIALVER\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.compiler\/share\/man\/serialver.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -946,3 +946,7 @@\n-      Flag flag = getCommandLineFlag(\"UseSharedSpaces\");\n-      sharingEnabled = (flag == null)? Boolean.FALSE :\n-          (flag.getBool()? Boolean.TRUE: Boolean.FALSE);\n+        Address address = VM.getVM().getDebugger().lookup(null, \"UseSharedSpaces\");\n+        if (address == null && getOS().equals(\"win32\")) {\n+            \/\/ On Win32 symbols are prefixed with the dll name. So look for\n+            \/\/ UseSharedSpaces as a symbol in jvm.dll.\n+            address = VM.getVM().getDebugger().lookup(null, \"jvm!UseSharedSpaces\");\n+        }\n+        sharingEnabled = address.getJBooleanAt(0);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/VM.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    \/\/ search nearby memory for the vtbl value of the given type.\n+    \/\/ search the first word for the vtbl value of the given type.\n@@ -234,6 +234,3 @@\n-    \/\/ Assuming that the base type is truly the first polymorphic type\n-    \/\/ then the vtbl for all subclasss should be at several defined\n-    \/\/ locations so only those locations will be checked.  It's also\n-    \/\/ required that the caller knows that the static type is at least\n-    \/\/ baseType.  See the notes in guessTypeForAddress for the logic of\n-    \/\/ the locations searched.\n+    \/\/ Assuming that the base type is truly the first polymorphic type,\n+    \/\/ then the vtbl for all subclassses should be in the first word of\n+    \/\/ the object.\n@@ -251,17 +248,0 @@\n-    Address loc2 = null;\n-    Address loc3 = null;\n-    long offset2 = baseType.getSize();\n-    \/\/ I don't think this should be misaligned under any\n-    \/\/ circumstances, but I'm not sure (FIXME: also not sure which\n-    \/\/ way to go here, up or down -- assuming down)\n-    offset2 = offset2 - (offset2 % getAddressSize()) - getAddressSize();\n-    if (offset2 > 0) {\n-      loc2 = addr.getAddressAt(offset2);\n-    }\n-    long offset3 = offset2 - getAddressSize();\n-    if (offset3 > 0) {\n-      loc3 = addr.getAddressAt(offset3);\n-    }\n-\n-    Type loc2Match = null;\n-    Type loc3Match = null;\n@@ -274,1 +254,1 @@\n-      if (superClass == null) continue;\n+      if (superClass == null) continue;  \/\/ type is not a subclass of baseType\n@@ -277,2 +257,1 @@\n-        \/\/ This occurs sometimes for intermediate types that are never\n-        \/\/ instantiated.\n+        \/\/ This occurs sometimes for intermediate types that are never instantiated.\n@@ -284,7 +263,2 @@\n-      \/\/ Prefer loc1 match\n-      if (vtblAddr.equals(loc1)) return type;\n-      if (loc2 != null && loc2Match == null && vtblAddr.equals(loc2)) {\n-          loc2Match = type;\n-      }\n-      if (loc3 != null && loc3Match == null && vtblAddr.equals(loc3)) {\n-          loc3Match = type;\n+      if (vtblAddr.equals(loc1)) {\n+        return type;\n@@ -293,2 +267,0 @@\n-    if (loc2Match != null) return loc2Match;\n-    if (loc3Match != null) return loc3Match;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/types\/basic\/BasicTypeDataBase.java","additions":8,"deletions":36,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JHSDB\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JHSDB\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.hotspot.agent\/share\/man\/jhsdb.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -303,1 +303,1 @@\n-        print_debug(\"can't lookup 'UseSharedSpaces' flag\\n\");\n+        print_debug(\"can't lookup 'UseSharedSpaces' symbol\\n\");\n@@ -311,1 +311,1 @@\n-        print_debug(\"can't read the value of 'UseSharedSpaces' flag\\n\");\n+        print_debug(\"can't read the value of 'UseSharedSpaces' symbol\\n\");\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/ps_core_common.c","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JWEBSERVER\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JWEBSERVER\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.httpserver\/share\/man\/jwebserver.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -760,3 +760,3 @@\n-            return VectorSupport.broadcastCoerced(Byte128Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte128Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -792,3 +792,3 @@\n-            return VectorSupport.broadcastCoerced(Byte256Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte256Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -856,3 +856,3 @@\n-            return VectorSupport.broadcastCoerced(Byte512Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte512Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -744,3 +744,3 @@\n-            return VectorSupport.broadcastCoerced(Byte64Mask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Byte64Mask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Byte64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -730,3 +730,3 @@\n-            return VectorSupport.broadcastCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(ByteMaxMask.class, byte.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -458,2 +458,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), byte.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), byte.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -4152,1 +4152,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -4154,1 +4154,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ByteVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -721,3 +721,3 @@\n-            return VectorSupport.broadcastCoerced(Double128Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double128Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -725,3 +725,3 @@\n-            return VectorSupport.broadcastCoerced(Double256Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double256Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -733,3 +733,3 @@\n-            return VectorSupport.broadcastCoerced(Double512Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double512Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -719,3 +719,3 @@\n-            return VectorSupport.broadcastCoerced(Double64Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Double64Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Double64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -718,3 +718,3 @@\n-            return VectorSupport.broadcastCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(DoubleMaxMask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -447,2 +447,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), double.class, species.length(),\n-                        toBits(0.0f), vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), double.class, species.length(),\n+                        toBits(0.0f), MODE_BROADCAST, vsp,\n@@ -3757,1 +3757,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3759,1 +3759,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/DoubleVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -725,3 +725,3 @@\n-            return VectorSupport.broadcastCoerced(Float128Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float128Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -733,3 +733,3 @@\n-            return VectorSupport.broadcastCoerced(Float256Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float256Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -749,3 +749,3 @@\n-            return VectorSupport.broadcastCoerced(Float512Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float512Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -721,3 +721,3 @@\n-            return VectorSupport.broadcastCoerced(Float64Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Float64Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Float64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -718,3 +718,3 @@\n-            return VectorSupport.broadcastCoerced(FloatMaxMask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(FloatMaxMask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -447,2 +447,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), float.class, species.length(),\n-                        toBits(0.0f), vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), float.class, species.length(),\n+                        toBits(0.0f), MODE_BROADCAST, vsp,\n@@ -3707,1 +3707,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3709,1 +3709,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/FloatVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -736,3 +736,3 @@\n-            return VectorSupport.broadcastCoerced(Int128Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int128Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -744,3 +744,3 @@\n-            return VectorSupport.broadcastCoerced(Int256Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int256Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -760,3 +760,3 @@\n-            return VectorSupport.broadcastCoerced(Int512Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int512Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -732,3 +732,3 @@\n-            return VectorSupport.broadcastCoerced(Int64Mask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Int64Mask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Int64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -730,3 +730,3 @@\n-            return VectorSupport.broadcastCoerced(IntMaxMask.class, int.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(IntMaxMask.class, int.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -458,2 +458,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), int.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), int.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -3877,1 +3877,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3879,1 +3879,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/IntVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -722,3 +722,3 @@\n-            return VectorSupport.broadcastCoerced(Long128Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long128Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -726,3 +726,3 @@\n-            return VectorSupport.broadcastCoerced(Long256Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long256Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -734,3 +734,3 @@\n-            return VectorSupport.broadcastCoerced(Long512Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long512Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -720,3 +720,3 @@\n-            return VectorSupport.broadcastCoerced(Long64Mask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Long64Mask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Long64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -720,3 +720,3 @@\n-            return VectorSupport.broadcastCoerced(LongMaxMask.class, long.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(LongMaxMask.class, long.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -458,2 +458,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), long.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), long.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -3812,1 +3812,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -3814,1 +3814,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/LongVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -744,3 +744,3 @@\n-            return VectorSupport.broadcastCoerced(Short128Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short128Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short128Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -760,3 +760,3 @@\n-            return VectorSupport.broadcastCoerced(Short256Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short256Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short256Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -792,3 +792,3 @@\n-            return VectorSupport.broadcastCoerced(Short512Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short512Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short512Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -736,3 +736,3 @@\n-            return VectorSupport.broadcastCoerced(Short64Mask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(Short64Mask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/Short64Vector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -730,3 +730,3 @@\n-            return VectorSupport.broadcastCoerced(ShortMaxMask.class, short.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced(ShortMaxMask.class, short.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortMaxVector.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -458,2 +458,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), short.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), short.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -4146,1 +4146,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -4148,1 +4148,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/ShortVector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -240,20 +240,19 @@\n-        AbstractSpecies<E> vspecies = (AbstractSpecies<E>) species;\n-        int laneCount = vspecies.laneCount();\n-        if (laneCount < Long.SIZE) {\n-            int extraSignBits = Long.SIZE - laneCount;\n-            bits <<= extraSignBits;\n-            bits >>= extraSignBits;\n-        }\n-        if (bits == (bits >> 1)) {\n-            \/\/ Special case.\n-            assert(bits == 0 || bits == -1);\n-            return vspecies.maskAll(bits != 0);\n-        }\n-        \/\/ FIXME: Intrinsify this.\n-        long shifted = bits;\n-        boolean[] a = new boolean[laneCount];\n-        for (int i = 0; i < a.length; i++) {\n-            a[i] = ((shifted & 1) != 0);\n-            shifted >>= 1;  \/\/ replicate sign bit\n-        }\n-        return fromValues(vspecies, a);\n+        AbstractSpecies<E> vsp = (AbstractSpecies<E>) species;\n+        bits = bits & (0xFFFFFFFFFFFFFFFFL >>> (64 - vsp.laneCount()));\n+        return VectorSupport.fromBitsCoerced(vsp.maskType(), vsp.elementType(), vsp.laneCount(), bits,\n+                                             VectorSupport.MODE_BITS_COERCED_LONG_TO_MASK, vsp,\n+                                             (m, s) -> {\n+                                                 if (m == (m >> 1)) {\n+                                                     \/\/ Special case.\n+                                                     assert(m == 0 || m == -1);\n+                                                     return s.maskAll(m != 0);\n+                                                 }\n+\n+                                                 long shifted = m;\n+                                                 boolean[] a = new boolean[s.laneCount()];\n+                                                 for (int i = 0; i < a.length; i++) {\n+                                                     a[i] = ((shifted & 1) != 0);\n+                                                     shifted >>= 1;  \/\/ replicate sign bit\n+                                                 }\n+                                                 return fromValues(s, a);\n+                                              });\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/VectorMask.java","additions":19,"deletions":20,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -473,2 +473,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                        toBits(0.0f), vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+                        toBits(0.0f), MODE_BROADCAST, vsp,\n@@ -477,2 +477,2 @@\n-        return VectorSupport.broadcastCoerced(vsp.vectorType(), $type$.class, species.length(),\n-                                0, vsp,\n+        return VectorSupport.fromBitsCoerced(vsp.vectorType(), $type$.class, species.length(),\n+                                0, MODE_BROADCAST, vsp,\n@@ -5330,1 +5330,1 @@\n-                VectorSupport.broadcastCoerced(\n+                VectorSupport.fromBitsCoerced(\n@@ -5332,1 +5332,1 @@\n-                    bits, this,\n+                    bits, MODE_BROADCAST, this,\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-Vector.java.template","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1003,3 +1003,3 @@\n-            return VectorSupport.broadcastCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n-                                                  (bit ? -1 : 0), null,\n-                                                  (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n+            return VectorSupport.fromBitsCoerced($masktype$.class, $bitstype$.class, VLENGTH,\n+                                                 (bit ? -1 : 0), MODE_BROADCAST, null,\n+                                                 (v, __) -> (v != 0 ? TRUE_MASK : FALSE_MASK));\n","filename":"src\/jdk.incubator.vector\/share\/classes\/jdk\/incubator\/vector\/X-VectorBits.java.template","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-    final int deoptReasonOSROffset = getConstant(\"Deoptimization::Reason_LIMIT\", Integer.class);\n+    final int deoptReasonOSROffset = getConstant(\"Deoptimization::Reason_TRAP_HISTORY_LENGTH\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-                    StringBuffer sb = null;\n+                    StringBuilder sb = null;\n@@ -839,1 +839,1 @@\n-                        sb = new StringBuffer();\n+                        sb = new StringBuilder();\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/security\/tools\/jarsigner\/Main.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -43,0 +48,4 @@\n+    \/\/ Valid --date range\n+    static final ZonedDateTime DATE_MIN = ZonedDateTime.parse(\"1980-01-01T00:00:02Z\");\n+    static final ZonedDateTime DATE_MAX = ZonedDateTime.parse(\"2099-12-31T23:59:59Z\");\n+\n@@ -191,0 +200,14 @@\n+            new Option(true, OptionType.CREATE_UPDATE_INDEX, \"--date\") {\n+                void process(Main jartool, String opt, String arg) throws BadArgs {\n+                    try {\n+                        ZonedDateTime date = ZonedDateTime.parse(arg, DateTimeFormatter.ISO_ZONED_DATE_TIME)\n+                                                             .withZoneSameInstant(ZoneOffset.UTC);\n+                        if (date.isBefore(DATE_MIN) || date.isAfter(DATE_MAX)) {\n+                            throw new BadArgs(\"error.date.out.of.range\", arg);\n+                        }\n+                        jartool.date = date.toLocalDateTime();\n+                    } catch (DateTimeParseException x) {\n+                        throw new BadArgs(\"error.date.notvalid\", arg);\n+                    }\n+                }\n+            },\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/GNUStyleOptions.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -71,0 +72,2 @@\n+import java.time.LocalDateTime;\n+import java.time.ZoneOffset;\n@@ -177,0 +180,3 @@\n+    \/* Date option for entry timestamps resolved to UTC Local time *\/\n+    LocalDateTime date;\n+\n@@ -865,1 +871,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                setZipEntryTime(e);\n@@ -870,1 +876,1 @@\n-                e.setTime(System.currentTimeMillis());\n+                setZipEntryTime(e);\n@@ -970,1 +976,1 @@\n-                    e2.setTime(e.getTime());\n+                    setZipEntryTime(e2, e.getTime());\n@@ -1036,1 +1042,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        setZipEntryTime(e);\n@@ -1058,1 +1064,1 @@\n-                e.setLastModifiedTime(lastModified);\n+                setZipEntryTime(e, lastModified.toMillis());\n@@ -1060,1 +1066,1 @@\n-                e.setLastModifiedTime(FileTime.fromMillis(System.currentTimeMillis()));\n+                setZipEntryTime(e);\n@@ -1086,1 +1092,1 @@\n-        e.setTime(System.currentTimeMillis());\n+        setZipEntryTime(e);\n@@ -1207,1 +1213,1 @@\n-        e.setTime(file.lastModified());\n+        setZipEntryTime(e, file.lastModified());\n@@ -2321,0 +2327,14 @@\n+    \/\/ Set the ZipEntry dostime using date if specified otherwise the current time\n+    private void setZipEntryTime(ZipEntry e) {\n+        setZipEntryTime(e, System.currentTimeMillis());\n+    }\n+\n+    \/\/ Set the ZipEntry dostime using the date if specified\n+    \/\/ otherwise the original time\n+    private void setZipEntryTime(ZipEntry e, long origTime) {\n+        if (date != null) {\n+            e.setTimeLocal(date);\n+        } else {\n+            e.setTime(origTime);\n+        }\n+    }\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/Main.java","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,4 @@\n+error.date.notvalid=\\\n+        date {0} is not a valid ISO-8601 extended offset date-time with optional time-zone\n+error.date.out.of.range=\\\n+        date {0} is not within the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z\n@@ -293,0 +297,4 @@\n+main.help.opt.create.update.index.date=\\\n+\\      --date=TIMESTAMP       The timestamp in ISO-8601 extended offset date-time with\\n\\\n+\\                             optional time-zone format, to use for the timestamps of\\n\\\n+\\                             entries, e.g. \"2022-02-12T12:30:00-05:00\"\n","filename":"src\/jdk.jartool\/share\/classes\/sun\/tools\/jar\/resources\/jar.properties","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAR\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JAR\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jartool\/share\/man\/jar.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JARSIGNER\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JARSIGNER\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jartool\/share\/man\/jarsigner.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAVADOC\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JAVADOC\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.javadoc\/share\/man\/javadoc.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JCMD\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JCMD\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n@@ -876,3 +876,3 @@\n-\\f[CB]\\-s\\f[R]: (Optional) If a class name is specified, it prints the\n-subclasses.\n-If the class name is not specified, only the superclasses are printed.\n+\\f[CB]\\-s\\f[R]: (Optional) If a classname is specified, print its\n+subclasses in addition to its superclasses.\n+Without this option only the superclasses will be printed.\n","filename":"src\/jdk.jcmd\/share\/man\/jcmd.1","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JINFO\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JINFO\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jinfo.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JMAP\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JMAP\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jmap.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JPS\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JPS\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jps.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JSTACK\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JSTACK\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jstack.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JSTAT\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JSTAT\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jcmd\/share\/man\/jstat.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JCONSOLE\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JCONSOLE\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jconsole\/share\/man\/jconsole.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JAVAP\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JAVAP\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/javap.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JDEPRSCAN\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JDEPRSCAN\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/jdeprscan.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JDEPS\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JDEPS\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jdeps\/share\/man\/jdeps.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JDB\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JDB\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jdi\/share\/man\/jdb.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -230,1 +230,1 @@\n-        return JNI_FALSE;\n+        return JNI_TRUE;\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/ArrayTypeImpl.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JFR\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JFR\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jfr\/share\/man\/jfr.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import java.time.LocalDateTime;\n@@ -57,1 +58,1 @@\n-    static JmodOutputStream newOutputStream(Path file) throws IOException {\n+    static JmodOutputStream newOutputStream(Path file, LocalDateTime date) throws IOException {\n@@ -60,1 +61,1 @@\n-        return new JmodOutputStream(bos);\n+        return new JmodOutputStream(bos, date);\n@@ -64,1 +65,2 @@\n-    private JmodOutputStream(OutputStream out) {\n+    private final LocalDateTime date;\n+    private JmodOutputStream(OutputStream out, LocalDateTime date) {\n@@ -66,0 +68,1 @@\n+        this.date = date;\n@@ -107,1 +110,5 @@\n-        e2.setTime(e1.getTime());\n+        if (date != null) {\n+            e2.setTimeLocal(date);\n+        } else {\n+            e2.setTime(e1.getTime());\n+        }\n@@ -127,1 +134,5 @@\n-        return new ZipEntry(name);\n+        ZipEntry zipEntry = new ZipEntry(name);\n+        if (date != null) {\n+            zipEntry.setTimeLocal(date);\n+        }\n+        return zipEntry;\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodOutputStream.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -65,0 +65,5 @@\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n@@ -163,0 +168,1 @@\n+        LocalDateTime date;\n@@ -165,0 +171,4 @@\n+    \/\/ Valid --date range\n+    static final ZonedDateTime DATE_MIN = ZonedDateTime.parse(\"1980-01-01T00:00:02Z\");\n+    static final ZonedDateTime DATE_MAX = ZonedDateTime.parse(\"2099-12-31T23:59:59Z\");\n+\n@@ -430,1 +440,1 @@\n-            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget)) {\n+            try (JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date)) {\n@@ -987,1 +997,5 @@\n-                            ze.setTime(System.currentTimeMillis());\n+                            if (options.date != null) {\n+                                ze.setTimeLocal(options.date);\n+                            } else {\n+                                ze.setTime(System.currentTimeMillis());\n+                            }\n@@ -1015,1 +1029,1 @@\n-                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget))\n+                 JmodOutputStream jos = JmodOutputStream.newOutputStream(tempTarget, options.date))\n@@ -1150,0 +1164,20 @@\n+    static class DateConverter implements ValueConverter<LocalDateTime> {\n+        @Override\n+        public LocalDateTime convert(String value) {\n+            try {\n+                ZonedDateTime date = ZonedDateTime.parse(value, DateTimeFormatter.ISO_ZONED_DATE_TIME)\n+                                                          .withZoneSameInstant(ZoneOffset.UTC);\n+                if (date.isBefore(DATE_MIN) || date.isAfter(DATE_MAX)) {\n+                    throw new CommandException(\"err.date.out.of.range\", value);\n+                }\n+                return date.toLocalDateTime();\n+            } catch (DateTimeParseException x) {\n+                throw new CommandException(\"err.invalid.date\", value, x.getMessage());\n+            }\n+        }\n+\n+        @Override public Class<LocalDateTime> valueType() { return LocalDateTime.class; }\n+\n+        @Override public String valuePattern() { return \"date\"; }\n+    }\n+\n@@ -1385,0 +1419,5 @@\n+        OptionSpec<LocalDateTime> date\n+                = parser.accepts(\"date\", getMessage(\"main.opt.date\"))\n+                        .withRequiredArg()\n+                        .withValuesConvertedBy(new DateConverter());\n+\n@@ -1428,0 +1467,2 @@\n+            if (opts.has(date))\n+                options.date = opts.valueOf(date);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/JmodTask.java","additions":44,"deletions":3,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,3 @@\n+main.opt.date=Date and time for the timestamps of entries, specified in ISO-8601\\\n+\\ extended offset date-time with optional time-zone format, e.g.\\\n+\\ \"2022-02-12T12:30:00-05:00\"\n@@ -109,0 +112,2 @@\n+err.invalid.date=--date {0} is not a valid ISO-8601 extended offset date-time with optional time-zone format: {1}\n+err.date.out.of.range=--date {0} is out of the valid range 1980-01-01T00:00:02Z to 2099-12-31T23:59:59Z\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jmod\/resources\/jmod.properties","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JLINK\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JLINK\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jlink\/share\/man\/jlink.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JMOD\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JMOD\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jlink\/share\/man\/jmod.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-                StringBuffer sb = new StringBuffer();\n+                StringBuilder sb = new StringBuilder();\n@@ -119,1 +119,1 @@\n-                verbose(new String(sb));\n+                verbose(sb.toString());\n@@ -121,1 +121,1 @@\n-                    sb = new StringBuffer(\"Output:\");\n+                    sb = new StringBuilder(\"Output:\");\n@@ -125,1 +125,1 @@\n-                    verbose(new String(sb));\n+                    verbose(sb.toString());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Log.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JPACKAGE\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JPACKAGE\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jpackage\/share\/man\/jpackage.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -375,1 +375,1 @@\n-            StringBuffer sb = new StringBuffer(format.length());\n+            StringBuilder sb = new StringBuilder(format.length());\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/Feedback.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-.TH \"JSHELL\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JSHELL\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jshell\/share\/man\/jshell.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-.TH \"JSTATD\" \"1\" \"2022\" \"JDK 18\" \"JDK Commands\"\n+.TH \"JSTATD\" \"1\" \"2022\" \"JDK 19\\-ea\" \"JDK Commands\"\n","filename":"src\/jdk.jstatd\/share\/man\/jstatd.1","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1474,0 +1474,7 @@\n+    \/**\n+     * Package-private accessor to entry alias map used by ZipPath.\n+     *\/\n+    byte[] lookupPath(byte[] resolvedPath) {\n+        return entryLookup.apply(resolvedPath);\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -203,1 +203,1 @@\n-                           zfs.getString(toAbsolutePath().path),\n+                           getRealPath(),\n@@ -210,0 +210,6 @@\n+    private String getRealPath() {\n+        byte[] resolvedPath = getResolvedPath();\n+        byte[] realPath = zfs.lookupPath(resolvedPath);\n+        return zfs.getString(realPath != null ? realPath : resolvedPath);\n+    }\n+\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1574,4 +1574,4 @@\n-                        [\"mov\",    \"__ mov(v1, __ T1D, 0, zr);\",                         \"mov\\tv1.d[0], xzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T2S, 1, zr);\",                         \"mov\\tv1.s[1], wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T4H, 2, zr);\",                         \"mov\\tv1.h[2], wzr\"],\n-                        [\"mov\",    \"__ mov(v1, __ T8B, 3, zr);\",                         \"mov\\tv1.b[3], wzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ D, 0, zr);\",                           \"mov\\tv1.d[0], xzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ S, 1, zr);\",                           \"mov\\tv1.s[1], wzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ H, 2, zr);\",                           \"mov\\tv1.h[2], wzr\"],\n+                        [\"mov\",    \"__ mov(v1, __ B, 3, zr);\",                           \"mov\\tv1.b[3], wzr\"],\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -716,4 +716,4 @@\n-    __ mov(v1, __ T1D, 0, zr);                         \/\/       mov     v1.d[0], xzr\n-    __ mov(v1, __ T2S, 1, zr);                         \/\/       mov     v1.s[1], wzr\n-    __ mov(v1, __ T4H, 2, zr);                         \/\/       mov     v1.h[2], wzr\n-    __ mov(v1, __ T8B, 3, zr);                         \/\/       mov     v1.b[3], wzr\n+    __ mov(v1, __ D, 0, zr);                           \/\/       mov     v1.d[0], xzr\n+    __ mov(v1, __ S, 1, zr);                           \/\/       mov     v1.s[1], wzr\n+    __ mov(v1, __ H, 2, zr);                           \/\/       mov     v1.h[2], wzr\n+    __ mov(v1, __ B, 3, zr);                           \/\/       mov     v1.b[3], wzr\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-vmTestbase\/jit\/escape\/AdaptiveBlocking\/AdaptiveBlocking001\/AdaptiveBlocking001.java 8260303 windows-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-zgc.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,0 +104,3 @@\n+hotspot_compiler_arraycopy = \\\n+  compiler\/arraycopy\/stress\n+\n@@ -125,1 +128,2 @@\n-  compiler\/gcbarriers\/PreserveFPRegistersTest.java\n+  compiler\/gcbarriers\/PreserveFPRegistersTest.java \\\n+  :hotspot_compiler_arraycopy\n@@ -142,0 +146,1 @@\n+  -:hotspot_slow_compiler\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Random;\n+\n+public abstract class AbstractStressArrayCopy {\n+    \/**\n+     * Max array size to test. This should be reasonably high to test\n+     * massive vectorized copies, plus cases that cross the cache lines and\n+     * (small) page boundaries. But it should also be reasonably low to\n+     * keep the test costs down.\n+     *\n+     * A rough guideline:\n+     *   - AVX-512: 64-byte copies over 32 registers copies roughly 2K per step.\n+     *   - AArch64: small pages can be about 64K large\n+     *\/\n+    static final int MAX_SIZE = 128*1024 + 1;\n+\n+    \/**\n+     * Arrays up to this size would be tested exhaustively: with all combinations\n+     * of source\/destination starts and copy lengths. Exercise restraint when bumping\n+     * this value, as the test costs are proportional to N^3 of this setting.\n+     *\/\n+    static final int EXHAUSTIVE_SIZES = Integer.getInteger(\"exhaustiveSizes\", 192);\n+\n+    \/*\n+     * Larger arrays would fuzzed with this many attempts.\n+     *\/\n+    static final int FUZZ_COUNT = Integer.getInteger(\"fuzzCount\", 300);\n+\n+    public static void throwSeedError(int len, int pos) {\n+        throw new RuntimeException(\"Error after seed: \" +\n+            len + \" elements, at pos \" + pos);\n+    }\n+\n+    public static void throwContentsError(int l, int r, int len, int pos) {\n+        throwError(\"in contents\", l, r, len, pos);\n+    }\n+\n+    public static void throwHeadError(int l, int r, int len, int pos) {\n+        throwError(\"in head\", l, r, len, pos);\n+    }\n+\n+    public static void throwTailError(int l, int r, int len, int pos) {\n+        throwError(\"in tail\", l, r, len, pos);\n+    }\n+\n+    private static void throwError(String phase, int l, int r, int len, int pos) {\n+        throw new RuntimeException(\"Error \" + phase + \": \" +\n+            len + \" elements, \" +\n+            \"[\" + l + \", \" + (l+len) + \") -> \" +\n+            \"[\" + r + \", \" + (r+len) + \"), \" +\n+            \"at pos \" + pos);\n+    }\n+\n+    protected abstract void testWith(int size, int l, int r, int len);\n+\n+    private void checkBounds(int size, int l, int r, int len) {\n+        if (l >= size)      throw new IllegalStateException(\"l is out of bounds\");\n+        if (l + len > size) throw new IllegalStateException(\"l+len is out of bounds\");\n+        if (r >= size)      throw new IllegalStateException(\"r is out of bounds\");\n+        if (r + len > size) throw new IllegalStateException(\"r+len is out of bounds: \" + l + \" \" + r + \" \" + len + \" \" + size);\n+    }\n+\n+    private void checkDisjoint(int size, int l, int r, int len) {\n+        if (l == r)               throw new IllegalStateException(\"Not disjoint: l == r\");\n+        if (l < r && l + len > r) throw new IllegalStateException(\"Not disjoint\");\n+        if (l > r && r + len > l) throw new IllegalStateException(\"Not disjoint\");\n+    }\n+\n+    private void checkConjoint(int size, int l, int r, int len) {\n+        if (l == r) return; \/\/ Definitely conjoint, even with zero len\n+        if (l < r && l + len < r) throw new IllegalStateException(\"Not conjoint\");\n+        if (l > r && r + len < l) throw new IllegalStateException(\"Not conjoint\");\n+    }\n+\n+    public void exhaustiveWith(int size) {\n+        for (int l = 0; l < size; l++) {\n+            for (int r = 0; r < size; r++) {\n+                int maxLen = Math.min(size - l, size - r);\n+                for (int len = 0; len <= maxLen; len++) {\n+                    checkBounds(size, l, r, len);\n+                    testWith(size, l, r, len);\n+                }\n+            }\n+        }\n+    }\n+\n+    public void fuzzWith(Random rand, int size) {\n+        \/\/ Some basic checks first\n+        testWith(size, 0, 1, 1);\n+        testWith(size, 0, 1, size-1);\n+\n+        \/\/ Test disjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size \/ 2);\n+            int len = rand.nextInt((size - l) \/ 2);\n+            int r = (l + len + 1) + rand.nextInt(size - 2*len - l - 1);\n+\n+            checkBounds(size, l, r, len);\n+            checkDisjoint(size, l, r, len);\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+\n+        \/\/ Test conjoint:\n+        for (int c = 0; c < FUZZ_COUNT; c++) {\n+            int l = rand.nextInt(size);\n+            int len = rand.nextInt(size - l);\n+            int r = Math.min(l + (len > 0 ? rand.nextInt(len) : 0), size - len);\n+\n+            checkBounds(size, l, r, len);\n+            checkConjoint(size, l, r, len);\n+\n+            testWith(size, l, r, len);\n+            testWith(size, r, l, len);\n+        }\n+    }\n+\n+    public void run(Random rand) {\n+        \/\/ Exhaustive on all small arrays\n+        for (int size = 1; size <= EXHAUSTIVE_SIZES; size++) {\n+            exhaustiveWith(size);\n+        }\n+\n+        \/\/ Fuzz powers of ten\n+        for (int size = 10; size < MAX_SIZE; size *= 10) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+\n+        \/\/ Fuzz powers of two\n+        for (int size = 2; size < MAX_SIZE; size *= 2) {\n+            if (size <= EXHAUSTIVE_SIZES) continue;\n+            fuzzWith(rand, size - 1);\n+            fuzzWith(rand, size);\n+            fuzzWith(rand, size + 1);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/AbstractStressArrayCopy.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressBooleanArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final boolean[] orig = new boolean[MAX_SIZE];\n+    private static final boolean[] test = new boolean[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextBoolean();\n+        }\n+        new StressBooleanArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressBooleanArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressByteArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final byte[] orig = new byte[MAX_SIZE];\n+    private static final byte[] test = new byte[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (byte)rand.nextInt();\n+        }\n+        new StressByteArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressByteArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressCharArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final char[] orig = new char[MAX_SIZE];\n+    private static final char[] test = new char[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (char)rand.nextInt();\n+        }\n+        new StressCharArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressCharArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressDoubleArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final double[] orig = new double[MAX_SIZE];\n+    private static final double[] test = new double[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextDouble();\n+        }\n+        new StressDoubleArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressDoubleArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressFloatArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final float[] orig = new float[MAX_SIZE];\n+    private static final float[] test = new float[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextFloat();\n+        }\n+        new StressFloatArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressFloatArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressIntArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final int[] orig = new int[MAX_SIZE];\n+    private static final int[] test = new int[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextInt();\n+        }\n+        new StressIntArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressIntArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressLongArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final long[] orig = new long[MAX_SIZE];\n+    private static final long[] test = new long[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = rand.nextLong();\n+        }\n+        new StressLongArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressLongArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressObjectArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final Object[] orig = new Object[MAX_SIZE];\n+    private static final Object[] test = new Object[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = new Object();\n+        }\n+        new StressObjectArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressObjectArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+public class StressShortArrayCopy extends AbstractStressArrayCopy {\n+\n+    private static final short[] orig = new short[MAX_SIZE];\n+    private static final short[] test = new short[MAX_SIZE];\n+\n+    protected void testWith(int size, int l, int r, int len) {\n+        \/\/ Seed the test from the original\n+        System.arraycopy(orig, 0, test, 0, size);\n+\n+        \/\/ Check the seed is correct\n+        {\n+            int m = Arrays.mismatch(test, 0, size,\n+                                    orig, 0, size);\n+            if (m != -1) {\n+                throwSeedError(size, m);\n+            }\n+        }\n+\n+        \/\/ Perform the tested copy\n+        System.arraycopy(test, l, test, r, len);\n+\n+        \/\/ Check the copy has proper contents\n+        {\n+            int m = Arrays.mismatch(test, r, r+len,\n+                                    orig, l, l+len);\n+            if (m != -1) {\n+                throwContentsError(l, r, len, r+m);\n+            }\n+        }\n+\n+        \/\/ Check anything else was not affected: head and tail\n+        {\n+            int m = Arrays.mismatch(test, 0, r,\n+                                    orig, 0, r);\n+            if (m != -1) {\n+                throwHeadError(l, r, len, m);\n+            }\n+        }\n+        {\n+            int m = Arrays.mismatch(test, r + len, size,\n+                                    orig, r + len, size);\n+            if (m != -1) {\n+                throwTailError(l, r, len, m);\n+            }\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        Random rand = Utils.getRandomInstance();\n+        for (int c = 0; c < orig.length; c++) {\n+            orig[c] = (short)rand.nextInt();\n+        }\n+        new StressShortArrayCopy().run(rand);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/StressShortArrayCopy.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.arraycopy.stress;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import jdk.test.whitebox.cpuinfo.CPUInfo;\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @library \/test\/lib\n+ * @build compiler.arraycopy.stress.AbstractStressArrayCopy\n+ *        compiler.arraycopy.stress.StressBooleanArrayCopy\n+ *        compiler.arraycopy.stress.StressByteArrayCopy\n+ *        compiler.arraycopy.stress.StressCharArrayCopy\n+ *        compiler.arraycopy.stress.StressShortArrayCopy\n+ *        compiler.arraycopy.stress.StressIntArrayCopy\n+ *        compiler.arraycopy.stress.StressFloatArrayCopy\n+ *        compiler.arraycopy.stress.StressLongArrayCopy\n+ *        compiler.arraycopy.stress.StressDoubleArrayCopy\n+ *        compiler.arraycopy.stress.StressObjectArrayCopy\n+ *        jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ *\n+ * @run main\/othervm\/timeout=7200\n+ *      -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *      compiler.arraycopy.stress.TestStressArrayCopy\n+ *\/\n+public class TestStressArrayCopy {\n+\n+    \/\/ These tests are remarkably memory bandwidth hungry. Running multiple\n+    \/\/ configs in parallel makes sense only when running a single test in\n+    \/\/ isolation, and only on machines with many memory channels. In common\n+    \/\/ testing, or even running all arraycopy stress tests at once, overloading\n+    \/\/ the system with many configs become counter-productive very quickly.\n+    \/\/\n+    \/\/ Default to 1\/4 of the CPUs, and allow users to override.\n+    static final int MAX_PARALLELISM = Integer.getInteger(\"maxParallelism\",\n+        Math.max(1, Runtime.getRuntime().availableProcessors() \/ 4));\n+\n+    private static List<String> mix(List<String> o, String... mix) {\n+        List<String> n = new ArrayList<>(o);\n+        for (String m : mix) {\n+            n.add(m);\n+        }\n+        return n;\n+    }\n+\n+    private static List<List<String>> product(List<List<String>> list, String... mix) {\n+        List<List<String>> newList = new ArrayList<>();\n+        for (List<String> c : list) {\n+            for (String m : mix) {\n+                newList.add(mix(c, m));\n+            }\n+        }\n+        return newList;\n+    }\n+\n+    private static List<List<String>> alternate(List<List<String>> list, String opt) {\n+        return product(list, \"-XX:+\" + opt, \"-XX:-\" + opt);\n+    }\n+\n+    private static boolean containsFuzzy(List<String> list, String sub) {\n+        for (String s : list) {\n+            if (s.contains(sub)) return true;\n+        }\n+        return false;\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        List<List<String>> configs = new ArrayList<>();\n+        List<String> cpuFeatures = CPUInfo.getFeatures();\n+\n+        if (Platform.isX64() || Platform.isX86()) {\n+            \/\/ If CPU features were not found, provide a default config.\n+            if (cpuFeatures.isEmpty()) {\n+                configs.add(new ArrayList());\n+            }\n+\n+            \/\/ Otherwise, select the tests that make sense on current platform.\n+            if (containsFuzzy(cpuFeatures, \"avx512\")) {\n+                configs.add(List.of(\"-XX:UseAVX=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=2\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"avx\")) {\n+                configs.add(List.of(\"-XX:UseAVX=1\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse4\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=4\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse3\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=3\"));\n+            }\n+            if (containsFuzzy(cpuFeatures, \"sse2\")) {\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=2\"));\n+            }\n+\n+            \/\/ x86_64 always has UseSSE >= 2. These lower configurations only\n+            \/\/ make sense for x86_32.\n+            if (Platform.isX86()) {\n+                if (containsFuzzy(cpuFeatures, \"sse\")) {\n+                    configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=1\"));\n+                }\n+\n+                configs.add(List.of(\"-XX:UseAVX=0\", \"-XX:UseSSE=0\"));\n+            }\n+\n+            \/\/ Alternate configs with other flags\n+            if (Platform.isX64()) {\n+                configs = alternate(configs, \"UseCompressedOops\");\n+            }\n+            configs = alternate(configs, \"UseUnalignedLoadStores\");\n+\n+        } else if (Platform.isAArch64()) {\n+            \/\/ AArch64.\n+            configs.add(new ArrayList());\n+\n+            \/\/ Alternate configs with other flags\n+            configs = alternate(configs, \"UseCompressedOops\");\n+            configs = alternate(configs, \"UseSIMDForMemoryOps\");\n+        } else {\n+            \/\/ Generic config.\n+            configs.add(new ArrayList());\n+        }\n+\n+        String[] classNames = {\n+            \"compiler.arraycopy.stress.StressBooleanArrayCopy\",\n+            \"compiler.arraycopy.stress.StressByteArrayCopy\",\n+            \"compiler.arraycopy.stress.StressCharArrayCopy\",\n+            \"compiler.arraycopy.stress.StressShortArrayCopy\",\n+            \"compiler.arraycopy.stress.StressIntArrayCopy\",\n+            \"compiler.arraycopy.stress.StressFloatArrayCopy\",\n+            \"compiler.arraycopy.stress.StressLongArrayCopy\",\n+            \"compiler.arraycopy.stress.StressDoubleArrayCopy\",\n+            \"compiler.arraycopy.stress.StressObjectArrayCopy\",\n+        };\n+\n+        ArrayList<Fork> forks = new ArrayList<>();\n+        int jobs = 0;\n+\n+        for (List<String> c : configs) {\n+            for (String className : classNames) {\n+                \/\/ Start a new job\n+                {\n+                    ProcessBuilder pb = ProcessTools.createTestJvm(mix(c, \"-Xmx256m\", className));\n+                    Process p = pb.start();\n+                    OutputAnalyzer oa = new OutputAnalyzer(p);\n+                    forks.add(new Fork(p, oa));\n+                    jobs++;\n+                }\n+\n+                \/\/ Wait for the completion of other jobs\n+                while (jobs >= MAX_PARALLELISM) {\n+                    Fork f = findDone(forks);\n+                    if (f != null) {\n+                        OutputAnalyzer oa = f.oa();\n+                        oa.shouldHaveExitValue(0);\n+                        forks.remove(f);\n+                        jobs--;\n+                    } else {\n+                        \/\/ Nothing is done, wait a little.\n+                        Thread.sleep(200);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Drain the rest\n+        for (Fork f : forks) {\n+            OutputAnalyzer oa = f.oa();\n+            oa.shouldHaveExitValue(0);\n+        }\n+    }\n+\n+    private static Fork findDone(List<Fork> forks) {\n+        for (Fork f : forks) {\n+            if (!f.p().isAlive()) {\n+                return f;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static record Fork(Process p, OutputAnalyzer oa) {};\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/stress\/TestStressArrayCopy.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,128 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8276455\n+ * @summary Test C2 iterative Escape Analysis to remove all allocations in test\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestIterativeEA\n+ *\/\n+public class TestIterativeEA {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    static class MyClass {\n+        int val;\n+        public MyClass(int val) {\n+            this.val = val;\n+        }\n+    }\n+\n+    static class AbstractClass {\n+        final int unused;\n+        public AbstractClass() {\n+            unused = 42;\n+        }\n+    }\n+\n+    static class HolderWithSuper extends AbstractClass {\n+        final MyClass obj;\n+        public HolderWithSuper(MyClass obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    static class Holder {\n+        final MyClass obj;\n+        public Holder(MyClass obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    static class GenericHolder {\n+        final Object obj;\n+        public GenericHolder(Object obj) {\n+            this.obj = obj;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH })\n+    @IR(failOn = { IRNode.ALLOC })\n+    public static int testSlow(int val) {\n+        MyClass obj = new MyClass(val);\n+        HolderWithSuper h1 = new HolderWithSuper(obj);\n+        GenericHolder h2 = new GenericHolder(h1);\n+        return ((HolderWithSuper)h2.obj).obj.val;\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH })\n+    @IR(failOn = { IRNode.ALLOC })\n+    public static int testFast(int val) {\n+        MyClass obj = new MyClass(val);\n+        Holder h1 = new Holder(obj);\n+        GenericHolder h2 = new GenericHolder(h1);\n+        return ((Holder)h2.obj).obj.val;\n+    }\n+\n+    static class A {\n+        int i;\n+        public A(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    static class B {\n+        A a;\n+        public B(A a) {\n+            this.a = a;\n+        }\n+    }\n+\n+    static class C {\n+        B b;\n+        public C(B b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({ Argument.RANDOM_EACH })\n+    @IR(failOn = { IRNode.ALLOC })\n+    static int testNested(int i) {\n+        C c = new C(new B(new A(i)));\n+        return c.b.a.i;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestIterativeEA.java","additions":128,"deletions":0,"binary":false,"changes":128,"status":"added"},{"patch":"@@ -27,0 +27,2 @@\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n@@ -30,1 +32,1 @@\n- * @bug 8277850\n+ * @bug 8277850 8278949\n@@ -37,0 +39,2 @@\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n@@ -48,0 +52,7 @@\n+    @Check(test = \"shiftMaskInt\")\n+    public static void checkShiftMaskInt(int res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -55,0 +66,52 @@\n+\n+    @Check(test = \"shiftMaskLong\")\n+    public static void checkShiftMaskLong(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    static volatile int barrier;\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @IR(failOn = { IRNode.AND_I, IRNode.LSHIFT_I })\n+    public static int shiftNonConstMaskInt(int i, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (i << 2); \/\/ transformed to: return 0;\n+    }\n+\n+    @Check(test = \"shiftNonConstMaskInt\")\n+    public static void checkShiftNonConstMaskInt(int res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @IR(failOn = { IRNode.AND_L, IRNode.LSHIFT_L })\n+    public static long shiftNonConstMaskLong(long i, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (i << 2); \/\/ transformed to: return 0;\n+    }\n+\n+    @Check(test = \"shiftNonConstMaskLong\")\n+    public static void checkShiftNonConstMaskLong(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -56,1 +119,0 @@\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -63,0 +125,38 @@\n+    @Run(test = \"addShiftMaskInt\")\n+    public static void addShiftMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftMaskInt(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addSshiftNonConstMaskInt(int i, int j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addSshiftNonConstMaskInt\")\n+    public static void addSshiftNonConstMaskInt_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addSshiftNonConstMaskInt(i, j, true);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addSshiftNonConstMaskInt(i, j, false);\n+        if (res != (j & 1)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -64,1 +164,0 @@\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -71,0 +170,38 @@\n+    @Run(test = \"addShiftMaskLong\")\n+    public static void addShiftMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftMaskLong(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addSshiftNonConstMaskLong(long i, long j, boolean flag) {\n+        int mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & (j + (i << 2)); \/\/ transformed to: return j & mask;\n+    }\n+\n+    @Run(test = \"addSshiftNonConstMaskLong\")\n+    public static void addSshiftNonConstMaskLong_runner() {\n+        long i = RANDOM.nextLong();\n+        long j = RANDOM.nextLong();\n+        long res = addSshiftNonConstMaskLong(i, j, true);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+        res = addSshiftNonConstMaskLong(i, j, false);\n+        if (res != (j & 1)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -78,0 +215,7 @@\n+    @Check(test = \"addShiftMaskInt2\")\n+    public static void checkAddShiftMaskInt2(int res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -85,0 +229,8 @@\n+    @Check(test = \"addShiftMaskLong2\")\n+    public static void checkAddShiftMaskLong2(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    \/\/ Try to get add inputs swapped compared to other tests\n@@ -86,1 +238,39 @@\n-    @Arguments(Argument.RANDOM_EACH)\n+    @IR(counts = { IRNode.AND_I, \"1\" })\n+    @IR(failOn = { IRNode.ADD_I, IRNode.LSHIFT_I })\n+    public static int addShiftMaskInt3(int i, long j) {\n+        int add1 = (i << 2);\n+        int add2 = (int)j;\n+        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Run(test = \"addShiftMaskInt3\")\n+    public static void addShiftMaskInt3_runner() {\n+        int i = RANDOM.nextInt();\n+        int j = RANDOM.nextInt();\n+        int res = addShiftMaskInt3(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_L, \"1\" })\n+    @IR(failOn = { IRNode.ADD_L, IRNode.LSHIFT_L })\n+    public static long addShiftMaskLong3(long i, float j) {\n+        long add1 = (i << 2);\n+        long add2 = (long)j;\n+        return (add1 + add2) & 3; \/\/ transformed to: return j & 3;\n+    }\n+\n+    @Run(test = \"addShiftMaskLong3\")\n+    public static void addShiftMaskLong3_runner() {\n+        long i = RANDOM.nextLong();\n+        float j = RANDOM.nextFloat();\n+        long res = addShiftMaskLong3(i, j);\n+        if (res != (((long)j) & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH})\n@@ -92,0 +282,28 @@\n+    @Check(test = \"shiftConvMask\")\n+    public static void checkShiftConvMask(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_EACH, Argument.BOOLEAN_TOGGLE_FIRST_TRUE})\n+    @IR(failOn = { IRNode.AND_L, IRNode.LSHIFT_L })\n+    public static long shiftNotConstConvMask(int i, boolean flag) {\n+        long mask;\n+        if (flag) {\n+            barrier = 42;\n+            mask = 3;\n+        } else {\n+            mask = 1;\n+        }\n+        return mask & ((long)(i << 2)); \/\/ transformed to: return 0;\n+    }\n+\n+    @Check(test = \"shiftNotConstConvMask\")\n+    public static void checkShiftNotConstConvMask(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -93,1 +311,0 @@\n-    @Arguments({Argument.RANDOM_EACH, Argument.RANDOM_EACH})\n@@ -100,0 +317,10 @@\n+    @Run(test = \"addShiftConvMask\")\n+    public static void addShiftConvMask_runner() {\n+        int i = RANDOM.nextInt();\n+        long j = RANDOM.nextLong();\n+        long res = addShiftConvMask(i, j);\n+        if (res != (j & 3)) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+\n@@ -107,0 +334,6 @@\n+    @Check(test = \"addShiftConvMask2\")\n+    public static void checkAddShiftConvMask2(long res) {\n+        if (res != 0) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n@@ -108,1 +341,0 @@\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestShiftAndMask.java","additions":238,"deletions":6,"binary":false,"changes":244,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8278471\n+ * @summary Remove unreached rules in AddNode::IdealIL\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestSpecialCasesOf_AMinusB_Plus_CMinusD_InAddIdeal\n+ *\/\n+\/* Test conversion from (a - b) + (b - c) to (a - c) and conversion\n+ * from (a - b) + (c - a) to (c - b) have really happened so we can\n+ * safely remove both. *\/\n+public class TestSpecialCasesOf_AMinusB_Plus_CMinusD_InAddIdeal {\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int test1Int(int a, int b, int c) {\n+        return (a - b) + (b - c); \/\/ transformed to a - c rather than (a + b) - (b + c)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    @IR(failOn = {IRNode.ADD_L})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public long test1Long(long a, long b, long c) {\n+        return (a - b) + (b - c); \/\/ transformed to a - c rather than (a + b) - (b + c)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    @IR(failOn = {IRNode.ADD_I})\n+    @IR(counts = {IRNode.SUB_I, \"1\"})\n+    public int test2Int(int b, int a, int c) { \/\/ make sure inputs sorted\n+        return (a - b) + (c - a); \/\/ transformed to c - b rather than (a + c) - (b + a)\n+    }\n+\n+    @Test\n+    @Arguments({Argument.RANDOM_ONCE, Argument.RANDOM_ONCE, Argument.RANDOM_ONCE})\n+    @IR(failOn = {IRNode.ADD_L})\n+    @IR(counts = {IRNode.SUB_L, \"1\"})\n+    public long test2Long(long b, long a, long c) { \/\/ make sure inputs sorted\n+        return (a - b) + (c - a); \/\/ transformed to return c - b rather than (a + c) - (b + a)\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestSpecialCasesOf_AMinusB_Plus_CMinusD_InAddIdeal.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8276455\n+ * @summary Test C2 iterative Escape Analysis\n+ * @library \/test\/lib \/\n+ *\n+ * @requires vm.flagless\n+ * @requires vm.compiler2.enabled & vm.debug == true\n+ *\n+ * @run driver TestIterativeEA\n+ *\/\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestIterativeEA {\n+\n+  public static void main(String[] args) throws Exception {\n+    ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                \"-server\", \"-XX:-TieredCompilation\", \"-Xbatch\", \"-XX:+PrintEliminateAllocations\",\n+                 Launcher.class.getName());\n+\n+    OutputAnalyzer analyzer = new OutputAnalyzer(pb.start());\n+\n+    System.out.println(analyzer.getOutput());\n+\n+    analyzer.shouldHaveExitValue(0);\n+    analyzer.shouldContain(\"++++ Eliminated: 26 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 48 Allocate\");\n+    analyzer.shouldContain(\"++++ Eliminated: 78 Allocate\");\n+  }\n+\n+  static class A {\n+    int i;\n+\n+    public A(int i) {\n+      this.i = i;\n+    }\n+  }\n+\n+  static class B {\n+    A a;\n+\n+    public B(A a) {\n+      this.a = a;\n+    }\n+  }\n+\n+  static class C {\n+    B b;\n+\n+    public C(B b) {\n+      this.b = b;\n+    }\n+  }\n+\n+  static int test(int i) {\n+    C c = new C(new B(new A(i)));\n+    return c.b.a.i;\n+  }\n+\n+  static class Launcher {\n+    public static void main(String[] args) {\n+      for (int i = 0; i < 12000; ++i) {\n+        int j = test(i);\n+      }\n+    }\n+  }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/escapeAnalysis\/TestIterativeEA.java","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -142,0 +142,2 @@\n+    public static final String SUB_I = START + \"SubI\" + MID + END;\n+    public static final String SUB_L = START + \"SubL\" + MID + END;\n@@ -144,0 +146,8 @@\n+    public static final String VECTOR_CAST_B2X = START + \"VectorCastB2X\" + MID + END;\n+    public static final String VECTOR_CAST_S2X = START + \"VectorCastS2X\" + MID + END;\n+    public static final String VECTOR_CAST_I2X = START + \"VectorCastI2X\" + MID + END;\n+    public static final String VECTOR_CAST_L2X = START + \"VectorCastL2X\" + MID + END;\n+    public static final String VECTOR_CAST_F2X = START + \"VectorCastF2X\" + MID + END;\n+    public static final String VECTOR_CAST_D2X = START + \"VectorCastD2X\" + MID + END;\n+    public static final String VECTOR_REINTERPRET = START + \"VectorReinterpret\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -52,0 +52,12 @@\n+\/**\n+ * @test\n+ * @bug 8278584\n+ * @library \/test\/lib\n+ * @summary Test the codegen for C2's VectorLongToMaskNode\n+ *          \"-XX:DisableIntrinsic=_VectorMaskOp\" is required to break \"VectorMaskToLong (VectorLongToMask l) ==> l\" opt.\n+ *          This is because when _VectorMaskOp is disabled, VectorMaskToLong won't be generated.\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run testng\/othervm -XX:-TieredCompilation -XX:CompileThreshold=100 -XX:+UnlockDiagnosticVMOptions\n+ *                     -XX:DisableIntrinsic=_VectorMaskOp compiler.vectorapi.VectorMaskLoadStoreTest\n+ *\/\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorMaskLoadStoreTest.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx1.\n+ * @requires vm.cpu.features ~= \".*avx.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX1\n+ *\/\n+public class TestVectorCastAVX1 {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX1_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=1\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX1.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx2.\n+ * @requires vm.cpu.features ~= \".*avx2.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX2\n+ *\/\n+public class TestVectorCastAVX2 {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX2_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=2\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX2.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx512.\n+ * @requires vm.cpu.features ~= \".*avx512.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX512\n+ *\/\n+public class TestVectorCastAVX512 {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX512_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=3\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8278623\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx512bw.\n+ * @requires vm.cpu.features ~= \".*avx512bw.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX512BW\n+ *\/\n+public class TestVectorCastAVX512BW {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX512BW_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=3\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512BW.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on avx512dq.\n+ * @requires vm.cpu.features ~= \".*avx512dq.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastAVX512DQ\n+ *\/\n+public class TestVectorCastAVX512DQ {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.AVX512DQ_CAST_TESTS.stream(),\n+                \"-XX:UseAVX=3\");\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastAVX512DQ.java","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on neon.\n+ * @requires vm.cpu.features ~= \".*simd.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastNeon\n+ *\/\n+public class TestVectorCastNeon {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.NEON_CAST_TESTS.stream(),\n+                \"-XX:+UseNeon\");\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastNeon.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorCast;\n+import compiler.vectorapi.reshape.utils.TestCastMethods;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector cast intrinsics work as intended on sve.\n+ * @requires vm.cpu.features ~= \".*sve.*\"\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorCastSVE\n+ *\/\n+public class TestVectorCastSVE {\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorCast.class,\n+                TestCastMethods.SVE_CAST_TESTS.stream(),\n+                \"-XX:UseSVE=1\");\n+    }\n+}\n+\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorCastSVE.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape;\n+\n+import compiler.vectorapi.reshape.tests.TestVectorDoubleExpandShrink;\n+import compiler.vectorapi.reshape.tests.TestVectorExpandShrink;\n+import compiler.vectorapi.reshape.tests.TestVectorRebracket;\n+import compiler.vectorapi.reshape.utils.VectorReshapeHelper;\n+import compiler.vectorapi.reshape.utils.VectorSpeciesPair;\n+import java.util.List;\n+import jdk.incubator.vector.VectorShape;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+\/*\n+ * @test\n+ * @bug 8259610\n+ * @modules jdk.incubator.vector\n+ * @modules java.base\/jdk.internal.misc\n+ * @summary Test that vector reinterpret intrinsics work as intended.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.vectorapi.reshape.TestVectorReinterpret\n+ *\/\n+public class TestVectorReinterpret {\n+    private static final List<VectorShape> SHAPE_LIST = List.of(VectorShape.values());\n+    private static final List<Class<?>> ETYPE_LIST = List.of(\n+            byte.class, short.class, int.class, long.class, float.class, double.class\n+    );\n+\n+    public static void main(String[] args) {\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorExpandShrink.class,\n+                SHAPE_LIST.stream()\n+                        .flatMap(s -> SHAPE_LIST.stream()\n+                                .filter(t -> t.vectorBitSize() != s.vectorBitSize())\n+                                .map(t -> VectorSpeciesPair.makePair(VectorSpecies.of(byte.class, s),\n+                                        VectorSpecies.of(byte.class, t))))\n+        );\n+\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorDoubleExpandShrink.class,\n+                SHAPE_LIST.stream()\n+                        .flatMap(s -> SHAPE_LIST.stream()\n+                                .filter(t -> t.vectorBitSize() != s.vectorBitSize())\n+                                .map(t -> VectorSpeciesPair.makePair(VectorSpecies.of(byte.class, s),\n+                                        VectorSpecies.of(byte.class, t))))\n+        );\n+\n+        VectorReshapeHelper.runMainHelper(\n+                TestVectorRebracket.class,\n+                SHAPE_LIST.stream()\n+                        .flatMap(shape -> ETYPE_LIST.stream()\n+                                .flatMap(etype -> ETYPE_LIST.stream()\n+                                        .filter(ftype -> ftype != etype)\n+                                        .map(ftype -> VectorSpeciesPair.makePair(VectorSpecies.of(etype, shape),\n+                                                VectorSpecies.of(ftype, shape)))))\n+                        .filter(p -> p.isp().length() > 1 && p.osp().length() > 1)\n+        );\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/TestVectorReinterpret.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,1365 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+import static jdk.incubator.vector.VectorOperators.*;\n+\n+\/**\n+ * This class contains all possible cast operations between different vector species.\n+ * The methods only take into consideration the actual cast in C2, as the vectors are\n+ * ofter shrunk or expanded before\/after casting if the element numbers mismatch.\n+ *\n+ * We must load from\/store to the exact type array since vector support for byte may be\n+ * smaller than that for other types. Failing to intrinsify LoadVectorNode causes C2\n+ * compilation to stop, which results in non-compilable failure since we only have one\n+ * chance of compilation before IR verification.\n+ *\n+ * In each cast, the VectorCastNode is expected to appear exactly once.\n+ *\/\n+public class TestVectorCast {\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toS64(byte[] input, short[] output) {\n+        vectorCast(B2S, BSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toS64\")\n+    public static void runB64toS64() throws Throwable {\n+        runCastHelper(B2S, BSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toS128(byte[] input, short[] output) {\n+        vectorCast(B2S, BSPEC64, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toS128\")\n+    public static void runB64toS128() throws Throwable {\n+        runCastHelper(B2S, BSPEC64, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB128toS256(byte[] input, short[] output) {\n+        vectorCast(B2S, BSPEC128, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB128toS256\")\n+    public static void runB128toS256() throws Throwable {\n+        runCastHelper(B2S, BSPEC128, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB256toS512(byte[] input, short[] output) {\n+        vectorCast(B2S, BSPEC256, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB256toS512\")\n+    public static void runB256toS512() throws Throwable {\n+        runCastHelper(B2S, BSPEC256, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toI64(byte[] input, int[] output) {\n+        vectorCast(B2I, BSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI64\")\n+    public static void runB64toI64() throws Throwable {\n+        runCastHelper(B2I, BSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toI128(byte[] input, int[] output) {\n+        vectorCast(B2I, BSPEC64, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI128\")\n+    public static void runB64toI128() throws Throwable {\n+        runCastHelper(B2I, BSPEC64, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toI256(byte[] input, int[] output) {\n+        vectorCast(B2I, BSPEC64, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI256\")\n+    public static void runB64toI256() throws Throwable {\n+        runCastHelper(B2I, BSPEC64, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB128toI512(byte[] input, int[] output) {\n+        vectorCast(B2I, BSPEC128, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toI512\")\n+    public static void runB128toI512() throws Throwable {\n+        runCastHelper(B2I, BSPEC128, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL64(byte[] input, long[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL64\")\n+    public static void runB64toL64() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL128(byte[] input, long[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL128\")\n+    public static void runB64toL128() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL256(byte[] input, long[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL256\")\n+    public static void runB64toL256() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toL512(byte[] input, long[] output) {\n+        vectorCast(B2L, BSPEC64, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL512\")\n+    public static void runB64toL512() throws Throwable {\n+        runCastHelper(B2L, BSPEC64, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toF64(byte[] input, float[] output) {\n+        vectorCast(B2F, BSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF64\")\n+    public static void runB64toF64() throws Throwable {\n+        runCastHelper(B2F, BSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toF128(byte[] input, float[] output) {\n+        vectorCast(B2F, BSPEC64, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF128\")\n+    public static void runB64toF128() throws Throwable {\n+        runCastHelper(B2F, BSPEC64, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toF256(byte[] input, float[] output) {\n+        vectorCast(B2F, BSPEC64, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF256\")\n+    public static void runB64toF256() throws Throwable {\n+        runCastHelper(B2F, BSPEC64, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB128toF512(byte[] input, float[] output) {\n+        vectorCast(B2F, BSPEC128, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toF512\")\n+    public static void runB128toF512() throws Throwable {\n+        runCastHelper(B2F, BSPEC128, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD64(byte[] input, double[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD64\")\n+    public static void runB64toD64() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD128(byte[] input, double[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD128\")\n+    public static void runB64toD128() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD256(byte[] input, double[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD256\")\n+    public static void runB64toD256() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {B2X_NODE, \"1\"})\n+    public static void testB64toD512(byte[] input, double[] output) {\n+        vectorCast(B2D, BSPEC64, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD512\")\n+    public static void runB64toD512() throws Throwable {\n+        runCastHelper(B2D, BSPEC64, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toB64(short[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toB64\")\n+    public static void runS64toB64() throws Throwable {\n+        runCastHelper(S2B, SSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toB64(short[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS128toB64\")\n+    public static void runS128toB64() throws Throwable {\n+        runCastHelper(S2B, SSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS256toB128(short[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC256, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS256toB128\")\n+    public static void runS256toB128() throws Throwable {\n+        runCastHelper(S2B, SSPEC256, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS512toB256(short[] input, byte[] output) {\n+        vectorCast(S2B, SSPEC512, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS512toB256\")\n+    public static void runS512toB256() throws Throwable {\n+        runCastHelper(S2B, SSPEC512, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toI64(short[] input, int[] output) {\n+        vectorCast(S2I, SSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toI64\")\n+    public static void runS64toI64() throws Throwable {\n+        runCastHelper(S2I, SSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toI128(short[] input, int[] output) {\n+        vectorCast(S2I, SSPEC64, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toI128\")\n+    public static void runS64toI128() throws Throwable {\n+        runCastHelper(S2I, SSPEC64, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toI256(short[] input, int[] output) {\n+        vectorCast(S2I, SSPEC128, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS128toI256\")\n+    public static void runS128toI256() throws Throwable {\n+        runCastHelper(S2I, SSPEC128, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS256toI512(short[] input, int[] output) {\n+        vectorCast(S2I, SSPEC256, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS256toI512\")\n+    public static void runS256toI512() throws Throwable {\n+        runCastHelper(S2I, SSPEC256, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toL64(short[] input, long[] output) {\n+        vectorCast(S2L, SSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL64\")\n+    public static void runS64toL64() throws Throwable {\n+        runCastHelper(S2L, SSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toL128(short[] input, long[] output) {\n+        vectorCast(S2L, SSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL128\")\n+    public static void runS64toL128() throws Throwable {\n+        runCastHelper(S2L, SSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toL256(short[] input, long[] output) {\n+        vectorCast(S2L, SSPEC64, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL256\")\n+    public static void runS64toL256() throws Throwable {\n+        runCastHelper(S2L, SSPEC64, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toL512(short[] input, long[] output) {\n+        vectorCast(S2L, SSPEC128, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS128toL512\")\n+    public static void runS128toL512() throws Throwable {\n+        runCastHelper(S2L, SSPEC128, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toF64(short[] input, float[] output) {\n+        vectorCast(S2F, SSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toF64\")\n+    public static void runS64toF64() throws Throwable {\n+        runCastHelper(S2F, SSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toF128(short[] input, float[] output) {\n+        vectorCast(S2F, SSPEC64, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toF128\")\n+    public static void runS64toF128() throws Throwable {\n+        runCastHelper(S2F, SSPEC64, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toF256(short[] input, float[] output) {\n+        vectorCast(S2F, SSPEC128, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS128toF256\")\n+    public static void runS128toF256() throws Throwable {\n+        runCastHelper(S2F, SSPEC128, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS256toF512(short[] input, float[] output) {\n+        vectorCast(S2F, SSPEC256, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS256toF512\")\n+    public static void runS256toF512() throws Throwable {\n+        runCastHelper(S2F, SSPEC256, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toD64(short[] input, double[] output) {\n+        vectorCast(S2D, SSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD64\")\n+    public static void runS64toD64() throws Throwable {\n+        runCastHelper(S2D, SSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toD128(short[] input, double[] output) {\n+        vectorCast(S2D, SSPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD128\")\n+    public static void runS64toD128() throws Throwable {\n+        runCastHelper(S2D, SSPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS64toD256(short[] input, double[] output) {\n+        vectorCast(S2D, SSPEC64, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD256\")\n+    public static void runS64toD256() throws Throwable {\n+        runCastHelper(S2D, SSPEC64, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {S2X_NODE, \"1\"})\n+    public static void testS128toD512(short[] input, double[] output) {\n+        vectorCast(S2D, SSPEC128, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS128toD512\")\n+    public static void runS128toD512() throws Throwable {\n+        runCastHelper(S2D, SSPEC128, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toB64(int[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toB64\")\n+    public static void runI64toB64() throws Throwable {\n+        runCastHelper(I2B, ISPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toB64(int[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI128toB64\")\n+    public static void runI128toB64() throws Throwable {\n+        runCastHelper(I2B, ISPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toB64(int[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI256toB64\")\n+    public static void runI256toB64() throws Throwable {\n+        runCastHelper(I2B, ISPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI512toB128(int[] input, byte[] output) {\n+        vectorCast(I2B, ISPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI512toB128\")\n+    public static void runI512toB128() throws Throwable {\n+        runCastHelper(I2B, ISPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toS64(int[] input, short[] output) {\n+        vectorCast(I2S, ISPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toS64\")\n+    public static void runI64toS64() throws Throwable {\n+        runCastHelper(I2S, ISPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toS64(int[] input, short[] output) {\n+        vectorCast(I2S, ISPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI128toS64\")\n+    public static void runI128toS64() throws Throwable {\n+        runCastHelper(I2S, ISPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toS128(int[] input, short[] output) {\n+        vectorCast(I2S, ISPEC256, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI256toS128\")\n+    public static void runI256toS128() throws Throwable {\n+        runCastHelper(I2S, ISPEC256, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI512toS256(int[] input, short[] output) {\n+        vectorCast(I2S, ISPEC512, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI512toS256\")\n+    public static void runI512toS256() throws Throwable {\n+        runCastHelper(I2S, ISPEC512, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toL64(int[] input, long[] output) {\n+        vectorCast(I2L, ISPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toL64\")\n+    public static void runI64toL64() throws Throwable {\n+        runCastHelper(I2L, ISPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toL128(int[] input, long[] output) {\n+        vectorCast(I2L, ISPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI64toL128\")\n+    public static void runI64toL128() throws Throwable {\n+        runCastHelper(I2L, ISPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toL256(int[] input, long[] output) {\n+        vectorCast(I2L, ISPEC128, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI128toL256\")\n+    public static void runI128toL256() throws Throwable {\n+        runCastHelper(I2L, ISPEC128, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toL512(int[] input, long[] output) {\n+        vectorCast(I2L, ISPEC256, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI256toL512\")\n+    public static void runI256toL512() throws Throwable {\n+        runCastHelper(I2L, ISPEC256, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toF64(int[] input, float[] output) {\n+        vectorCast(I2F, ISPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toF64\")\n+    public static void runI64toF64() throws Throwable {\n+        runCastHelper(I2F, ISPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toF128(int[] input, float[] output) {\n+        vectorCast(I2F, ISPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toF128\")\n+    public static void runI128toF128() throws Throwable {\n+        runCastHelper(I2F, ISPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toF256(int[] input, float[] output) {\n+        vectorCast(I2F, ISPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toF256\")\n+    public static void runI256toF256() throws Throwable {\n+        runCastHelper(I2F, ISPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI512toF512(int[] input, float[] output) {\n+        vectorCast(I2F, ISPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toF512\")\n+    public static void runI512toF512() throws Throwable {\n+        runCastHelper(I2F, ISPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toD64(int[] input, double[] output) {\n+        vectorCast(I2D, ISPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toD64\")\n+    public static void runI64toD64() throws Throwable {\n+        runCastHelper(I2D, ISPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI64toD128(int[] input, double[] output) {\n+        vectorCast(I2D, ISPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI64toD128\")\n+    public static void runI64toD128() throws Throwable {\n+        runCastHelper(I2D, ISPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI128toD256(int[] input, double[] output) {\n+        vectorCast(I2D, ISPEC128, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI128toD256\")\n+    public static void runI128toD256() throws Throwable {\n+        runCastHelper(I2D, ISPEC128, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {I2X_NODE, \"1\"})\n+    public static void testI256toD512(int[] input, double[] output) {\n+        vectorCast(I2D, ISPEC256, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI256toD512\")\n+    public static void runI256toD512() throws Throwable {\n+        runCastHelper(I2D, ISPEC256, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toB64(long[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toB64\")\n+    public static void runL64toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toB64(long[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toB64\")\n+    public static void runL128toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toB64(long[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL256toB64\")\n+    public static void runL256toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toB64(long[] input, byte[] output) {\n+        vectorCast(L2B, LSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL512toB64\")\n+    public static void runL512toB64() throws Throwable {\n+        runCastHelper(L2B, LSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toS64(long[] input, short[] output) {\n+        vectorCast(L2S, LSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toS64\")\n+    public static void runL64toS64() throws Throwable {\n+        runCastHelper(L2S, LSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toS64(long[] input, short[] output) {\n+        vectorCast(L2S, LSPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toS64\")\n+    public static void runL128toS64() throws Throwable {\n+        runCastHelper(L2S, LSPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toS64(long[] input, short[] output) {\n+        vectorCast(L2S, LSPEC256, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL256toS64\")\n+    public static void runL256toS64() throws Throwable {\n+        runCastHelper(L2S, LSPEC256, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toS128(long[] input, short[] output) {\n+        vectorCast(L2S, LSPEC512, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL512toS128\")\n+    public static void runL512toS128() throws Throwable {\n+        runCastHelper(L2S, LSPEC512, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toI64(long[] input, int[] output) {\n+        vectorCast(L2I, LSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toI64\")\n+    public static void runL64toI64() throws Throwable {\n+        runCastHelper(L2I, LSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toI64(long[] input, int[] output) {\n+        vectorCast(L2I, LSPEC128, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toI64\")\n+    public static void runL128toI64() throws Throwable {\n+        runCastHelper(L2I, LSPEC128, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toI128(long[] input, int[] output) {\n+        vectorCast(L2I, LSPEC256, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL256toI128\")\n+    public static void runL256toI128() throws Throwable {\n+        runCastHelper(L2I, LSPEC256, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toI256(long[] input, int[] output) {\n+        vectorCast(L2I, LSPEC512, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL512toI256\")\n+    public static void runL512toI256() throws Throwable {\n+        runCastHelper(L2I, LSPEC512, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toF64(long[] input, float[] output) {\n+        vectorCast(L2F, LSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toF64\")\n+    public static void runL64toF64() throws Throwable {\n+        runCastHelper(L2F, LSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toF64(long[] input, float[] output) {\n+        vectorCast(L2F, LSPEC128, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL128toF64\")\n+    public static void runL128toF64() throws Throwable {\n+        runCastHelper(L2F, LSPEC128, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toF128(long[] input, float[] output) {\n+        vectorCast(L2F, LSPEC256, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL256toF128\")\n+    public static void runL256toF128() throws Throwable {\n+        runCastHelper(L2F, LSPEC256, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toF256(long[] input, float[] output) {\n+        vectorCast(L2F, LSPEC512, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL512toF256\")\n+    public static void runL512toF256() throws Throwable {\n+        runCastHelper(L2F, LSPEC512, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL64toD64(long[] input, double[] output) {\n+        vectorCast(L2D, LSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toD64\")\n+    public static void runL64toD64() throws Throwable {\n+        runCastHelper(L2D, LSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL128toD128(long[] input, double[] output) {\n+        vectorCast(L2D, LSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toD128\")\n+    public static void runL128toD128() throws Throwable {\n+        runCastHelper(L2D, LSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL256toD256(long[] input, double[] output) {\n+        vectorCast(L2D, LSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toD256\")\n+    public static void runL256toD256() throws Throwable {\n+        runCastHelper(L2D, LSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {L2X_NODE, \"1\"})\n+    public static void testL512toD512(long[] input, double[] output) {\n+        vectorCast(L2D, LSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toD512\")\n+    public static void runL512toD512() throws Throwable {\n+        runCastHelper(L2D, LSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toB64(float[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toB64\")\n+    public static void runF64toB64() throws Throwable {\n+        runCastHelper(F2B, FSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toB64(float[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF128toB64\")\n+    public static void runF128toB64() throws Throwable {\n+        runCastHelper(F2B, FSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toB64(float[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF256toB64\")\n+    public static void runF256toB64() throws Throwable {\n+        runCastHelper(F2B, FSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF512toB128(float[] input, byte[] output) {\n+        vectorCast(F2B, FSPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF512toB128\")\n+    public static void runF512toB128() throws Throwable {\n+        runCastHelper(F2B, FSPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toS64(float[] input, short[] output) {\n+        vectorCast(F2S, FSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toS64\")\n+    public static void runF64toS64() throws Throwable {\n+        runCastHelper(F2S, FSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toS64(float[] input, short[] output) {\n+        vectorCast(F2S, FSPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF128toS64\")\n+    public static void runF128toS64() throws Throwable {\n+        runCastHelper(F2S, FSPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toS128(float[] input, short[] output) {\n+        vectorCast(F2S, FSPEC256, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF256toS128\")\n+    public static void runF256toS128() throws Throwable {\n+        runCastHelper(F2S, FSPEC256, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF512toS256(float[] input, short[] output) {\n+        vectorCast(F2S, FSPEC512, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF512toS256\")\n+    public static void runF512toS256() throws Throwable {\n+        runCastHelper(F2S, FSPEC512, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toI64(float[] input, int[] output) {\n+        vectorCast(F2I, FSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toI64\")\n+    public static void runF64toI64() throws Throwable {\n+        runCastHelper(F2I, FSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toI128(float[] input, int[] output) {\n+        vectorCast(F2I, FSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toI128\")\n+    public static void runF128toI128() throws Throwable {\n+        runCastHelper(F2I, FSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toI256(float[] input, int[] output) {\n+        vectorCast(F2I, FSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toI256\")\n+    public static void runF256toI256() throws Throwable {\n+        runCastHelper(F2I, FSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF512toI512(float[] input, int[] output) {\n+        vectorCast(F2I, FSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toI512\")\n+    public static void runF512toI512() throws Throwable {\n+        runCastHelper(F2I, FSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toL64(float[] input, long[] output) {\n+        vectorCast(F2L, FSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toL64\")\n+    public static void runF64toL64() throws Throwable {\n+        runCastHelper(F2L, FSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toL128(float[] input, long[] output) {\n+        vectorCast(F2L, FSPEC64, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF64toL128\")\n+    public static void runF64toL128() throws Throwable {\n+        runCastHelper(F2L, FSPEC64, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toL256(float[] input, long[] output) {\n+        vectorCast(F2L, FSPEC128, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF128toL256\")\n+    public static void runF128toL256() throws Throwable {\n+        runCastHelper(F2L, FSPEC128, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toL512(float[] input, long[] output) {\n+        vectorCast(F2L, FSPEC256, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF256toL512\")\n+    public static void runF256toL512() throws Throwable {\n+        runCastHelper(F2L, FSPEC256, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toD64(float[] input, double[] output) {\n+        vectorCast(F2D, FSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toD64\")\n+    public static void runF64toD64() throws Throwable {\n+        runCastHelper(F2D, FSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF64toD128(float[] input, double[] output) {\n+        vectorCast(F2D, FSPEC64, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF64toD128\")\n+    public static void runF64toD128() throws Throwable {\n+        runCastHelper(F2D, FSPEC64, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF128toD256(float[] input, double[] output) {\n+        vectorCast(F2D, FSPEC128, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF128toD256\")\n+    public static void runF128toD256() throws Throwable {\n+        runCastHelper(F2D, FSPEC128, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {F2X_NODE, \"1\"})\n+    public static void testF256toD512(float[] input, double[] output) {\n+        vectorCast(F2D, FSPEC256, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF256toD512\")\n+    public static void runF256toD512() throws Throwable {\n+        runCastHelper(F2D, FSPEC256, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toB64(double[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toB64\")\n+    public static void runD64toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toB64(double[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toB64\")\n+    public static void runD128toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toB64(double[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD256toB64\")\n+    public static void runD256toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toB64(double[] input, byte[] output) {\n+        vectorCast(D2B, DSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD512toB64\")\n+    public static void runD512toB64() throws Throwable {\n+        runCastHelper(D2B, DSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toS64(double[] input, short[] output) {\n+        vectorCast(D2S, DSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toS64\")\n+    public static void runD64toS64() throws Throwable {\n+        runCastHelper(D2S, DSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toS64(double[] input, short[] output) {\n+        vectorCast(D2S, DSPEC128, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toS64\")\n+    public static void runD128toS64() throws Throwable {\n+        runCastHelper(D2S, DSPEC128, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toS64(double[] input, short[] output) {\n+        vectorCast(D2S, DSPEC256, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD256toS64\")\n+    public static void runD256toS64() throws Throwable {\n+        runCastHelper(D2S, DSPEC256, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toS128(double[] input, short[] output) {\n+        vectorCast(D2S, DSPEC512, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD512toS128\")\n+    public static void runD512toS128() throws Throwable {\n+        runCastHelper(D2S, DSPEC512, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toI64(double[] input, int[] output) {\n+        vectorCast(D2I, DSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toI64\")\n+    public static void runD64toI64() throws Throwable {\n+        runCastHelper(D2I, DSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toI64(double[] input, int[] output) {\n+        vectorCast(D2I, DSPEC128, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toI64\")\n+    public static void runD128toI64() throws Throwable {\n+        runCastHelper(D2I, DSPEC128, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toI128(double[] input, int[] output) {\n+        vectorCast(D2I, DSPEC256, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD256toI128\")\n+    public static void runD256toI128() throws Throwable {\n+        runCastHelper(D2I, DSPEC256, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toI256(double[] input, int[] output) {\n+        vectorCast(D2I, DSPEC512, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD512toI256\")\n+    public static void runD512toI256() throws Throwable {\n+        runCastHelper(D2I, DSPEC512, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toL64(double[] input, long[] output) {\n+        vectorCast(D2L, DSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toL64\")\n+    public static void runD64toL64() throws Throwable {\n+        runCastHelper(D2L, DSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toL128(double[] input, long[] output) {\n+        vectorCast(D2L, DSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toL128\")\n+    public static void runD128toL128() throws Throwable {\n+        runCastHelper(D2L, DSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toL256(double[] input, long[] output) {\n+        vectorCast(D2L, DSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toL256\")\n+    public static void runD256toL256() throws Throwable {\n+        runCastHelper(D2L, DSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toL512(double[] input, long[] output) {\n+        vectorCast(D2L, DSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toL512\")\n+    public static void runD512toL512() throws Throwable {\n+        runCastHelper(D2L, DSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD64toF64(double[] input, float[] output) {\n+        vectorCast(D2F, DSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toF64\")\n+    public static void runD64toF64() throws Throwable {\n+        runCastHelper(D2F, DSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD128toF64(double[] input, float[] output) {\n+        vectorCast(D2F, DSPEC128, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD128toF64\")\n+    public static void runD128toF64() throws Throwable {\n+        runCastHelper(D2F, DSPEC128, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD256toF128(double[] input, float[] output) {\n+        vectorCast(D2F, DSPEC256, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD256toF128\")\n+    public static void runD256toF128() throws Throwable {\n+        runCastHelper(D2F, DSPEC256, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {D2X_NODE, \"1\"})\n+    public static void testD512toF256(double[] input, float[] output) {\n+        vectorCast(D2F, DSPEC512, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD512toF256\")\n+    public static void runD512toF256() throws Throwable {\n+        runCastHelper(D2F, DSPEC512, FSPEC256);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorCast.java","additions":1365,"deletions":0,"binary":false,"changes":1365,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+\n+\/**\n+ * As spot in 8259353. We need to do a shrink and an expand together to not accidentally\n+ * zero out elements in the physical registers that may not be zero in general cases.\n+ *\n+ * In some methods, 2 consecutive ReinterpretNodes may be optimized out.\n+ *\/\n+public class TestVectorDoubleExpandShrink {\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB64toB128(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC64, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB128\")\n+    public static void runB64toB128() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC64, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB64toB256(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC64, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB256\")\n+    public static void runB64toB256() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC64, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB64toB512(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC64, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB512\")\n+    public static void runB64toB512() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC64, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB128toB64(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB64\")\n+    public static void runB128toB64() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB128toB256(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC128, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB256\")\n+    public static void runB128toB256() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC128, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB128toB512(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC128, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB512\")\n+    public static void runB128toB512() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC128, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB256toB64(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB64\")\n+    public static void runB256toB64() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB256toB128(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC256, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB128\")\n+    public static void runB256toB128() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC256, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(failOn = REINTERPRET_NODE)\n+    public static void testB256toB512(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC256, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB512\")\n+    public static void runB256toB512() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC256, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB512toB64(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB64\")\n+    public static void runB512toB64() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB512toB128(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB128\")\n+    public static void runB512toB128() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"2\"})\n+    public static void testB512toB256(byte[] input, byte[] output) {\n+        vectorDoubleExpandShrink(BSPEC512, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB256\")\n+    public static void runB512toB256() throws Throwable {\n+        runDoubleExpandShrinkHelper(BSPEC512, BSPEC256);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorDoubleExpandShrink.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+\n+\/**\n+ *  This class contains method to ensure a resizing reinterpretation operations work as\n+ *  intended.\n+ *\n+ *  In each test, the ReinterpretNode is expected to appear exactly once.\n+ *\/\n+public class TestVectorExpandShrink {\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toB128(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC64, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB128\")\n+    public static void runB64toB128() throws Throwable {\n+        runExpandShrinkHelper(BSPEC64, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toB256(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC64, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB256\")\n+    public static void runB64toB256() throws Throwable {\n+        runExpandShrinkHelper(BSPEC64, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toB512(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC64, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB64toB512\")\n+    public static void runB64toB512() throws Throwable {\n+        runExpandShrinkHelper(BSPEC64, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toB64(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC128, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB64\")\n+    public static void runB128toB64() throws Throwable {\n+        runExpandShrinkHelper(BSPEC128, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toB256(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC128, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB256\")\n+    public static void runB128toB256() throws Throwable {\n+        runExpandShrinkHelper(BSPEC128, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toB512(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC128, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB128toB512\")\n+    public static void runB128toB512() throws Throwable {\n+        runExpandShrinkHelper(BSPEC128, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toB64(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC256, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB64\")\n+    public static void runB256toB64() throws Throwable {\n+        runExpandShrinkHelper(BSPEC256, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toB128(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC256, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB128\")\n+    public static void runB256toB128() throws Throwable {\n+        runExpandShrinkHelper(BSPEC256, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toB512(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC256, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB256toB512\")\n+    public static void runB256toB512() throws Throwable {\n+        runExpandShrinkHelper(BSPEC256, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toB64(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC512, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB64\")\n+    public static void runB512toB64() throws Throwable {\n+        runExpandShrinkHelper(BSPEC512, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toB128(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC512, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB128\")\n+    public static void runB512toB128() throws Throwable {\n+        runExpandShrinkHelper(BSPEC512, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toB256(byte[] input, byte[] output) {\n+        vectorExpandShrink(BSPEC512, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB512toB256\")\n+    public static void runB512toB256() throws Throwable {\n+        runExpandShrinkHelper(BSPEC512, BSPEC256);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorExpandShrink.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,1362 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.tests;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.Run;\n+import compiler.lib.ir_framework.Test;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+\n+\/**\n+ * This class contains methods to test for reinterpretation operations that reinterpret\n+ * a vector as a similar vector with another element type.\n+ *\n+ * It is complicated to verify the IR in this case since a load\/store with respect to\n+ * byte array will result in additional ReinterpretNodes if the vector element type is\n+ * not byte. As a result, arguments need to be arrays of the correct type.\n+ *\n+ * In each test, the ReinterpretNode is expected to appear exactly once.\n+ *\/\n+public class TestVectorRebracket {\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toS64(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toS64\")\n+    public static void runB64toS64() throws Throwable {\n+        runRebracketHelper(BSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toI64(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toI64\")\n+    public static void runB64toI64() throws Throwable {\n+        runRebracketHelper(BSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toL64(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toL64\")\n+    public static void runB64toL64() throws Throwable {\n+        runRebracketHelper(BSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toF64(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toF64\")\n+    public static void runB64toF64() throws Throwable {\n+        runRebracketHelper(BSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB64toD64(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testB64toD64\")\n+    public static void runB64toD64() throws Throwable {\n+        runRebracketHelper(BSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toB64(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toB64\")\n+    public static void runS64toB64() throws Throwable {\n+        runRebracketHelper(SSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toI64(short[] input, int[] output) {\n+        vectorRebracket(SSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toI64\")\n+    public static void runS64toI64() throws Throwable {\n+        runRebracketHelper(SSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toL64(short[] input, long[] output) {\n+        vectorRebracket(SSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toL64\")\n+    public static void runS64toL64() throws Throwable {\n+        runRebracketHelper(SSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toF64(short[] input, float[] output) {\n+        vectorRebracket(SSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toF64\")\n+    public static void runS64toF64() throws Throwable {\n+        runRebracketHelper(SSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS64toD64(short[] input, double[] output) {\n+        vectorRebracket(SSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testS64toD64\")\n+    public static void runS64toD64() throws Throwable {\n+        runRebracketHelper(SSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toB64(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toB64\")\n+    public static void runI64toB64() throws Throwable {\n+        runRebracketHelper(ISPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toS64(int[] input, short[] output) {\n+        vectorRebracket(ISPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toS64\")\n+    public static void runI64toS64() throws Throwable {\n+        runRebracketHelper(ISPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toL64(int[] input, long[] output) {\n+        vectorRebracket(ISPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toL64\")\n+    public static void runI64toL64() throws Throwable {\n+        runRebracketHelper(ISPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toF64(int[] input, float[] output) {\n+        vectorRebracket(ISPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toF64\")\n+    public static void runI64toF64() throws Throwable {\n+        runRebracketHelper(ISPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI64toD64(int[] input, double[] output) {\n+        vectorRebracket(ISPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testI64toD64\")\n+    public static void runI64toD64() throws Throwable {\n+        runRebracketHelper(ISPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toB64(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toB64\")\n+    public static void runL64toB64() throws Throwable {\n+        runRebracketHelper(LSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toS64(long[] input, short[] output) {\n+        vectorRebracket(LSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toS64\")\n+    public static void runL64toS64() throws Throwable {\n+        runRebracketHelper(LSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toI64(long[] input, int[] output) {\n+        vectorRebracket(LSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toI64\")\n+    public static void runL64toI64() throws Throwable {\n+        runRebracketHelper(LSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toF64(long[] input, float[] output) {\n+        vectorRebracket(LSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toF64\")\n+    public static void runL64toF64() throws Throwable {\n+        runRebracketHelper(LSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL64toD64(long[] input, double[] output) {\n+        vectorRebracket(LSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testL64toD64\")\n+    public static void runL64toD64() throws Throwable {\n+        runRebracketHelper(LSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toB64(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toB64\")\n+    public static void runF64toB64() throws Throwable {\n+        runRebracketHelper(FSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toS64(float[] input, short[] output) {\n+        vectorRebracket(FSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toS64\")\n+    public static void runF64toS64() throws Throwable {\n+        runRebracketHelper(FSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toI64(float[] input, int[] output) {\n+        vectorRebracket(FSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toI64\")\n+    public static void runF64toI64() throws Throwable {\n+        runRebracketHelper(FSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toL64(float[] input, long[] output) {\n+        vectorRebracket(FSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toL64\")\n+    public static void runF64toL64() throws Throwable {\n+        runRebracketHelper(FSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF64toD64(float[] input, double[] output) {\n+        vectorRebracket(FSPEC64, DSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testF64toD64\")\n+    public static void runF64toD64() throws Throwable {\n+        runRebracketHelper(FSPEC64, DSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toB64(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC64, BSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toB64\")\n+    public static void runD64toB64() throws Throwable {\n+        runRebracketHelper(DSPEC64, BSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toS64(double[] input, short[] output) {\n+        vectorRebracket(DSPEC64, SSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toS64\")\n+    public static void runD64toS64() throws Throwable {\n+        runRebracketHelper(DSPEC64, SSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toI64(double[] input, int[] output) {\n+        vectorRebracket(DSPEC64, ISPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toI64\")\n+    public static void runD64toI64() throws Throwable {\n+        runRebracketHelper(DSPEC64, ISPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toL64(double[] input, long[] output) {\n+        vectorRebracket(DSPEC64, LSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toL64\")\n+    public static void runD64toL64() throws Throwable {\n+        runRebracketHelper(DSPEC64, LSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD64toF64(double[] input, float[] output) {\n+        vectorRebracket(DSPEC64, FSPEC64, input, output);\n+    }\n+\n+    @Run(test = \"testD64toF64\")\n+    public static void runD64toF64() throws Throwable {\n+        runRebracketHelper(DSPEC64, FSPEC64);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toS128(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toS128\")\n+    public static void runB128toS128() throws Throwable {\n+        runRebracketHelper(BSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toI128(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toI128\")\n+    public static void runB128toI128() throws Throwable {\n+        runRebracketHelper(BSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toL128(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toL128\")\n+    public static void runB128toL128() throws Throwable {\n+        runRebracketHelper(BSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toF128(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toF128\")\n+    public static void runB128toF128() throws Throwable {\n+        runRebracketHelper(BSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB128toD128(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testB128toD128\")\n+    public static void runB128toD128() throws Throwable {\n+        runRebracketHelper(BSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toB128(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toB128\")\n+    public static void runS128toB128() throws Throwable {\n+        runRebracketHelper(SSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toI128(short[] input, int[] output) {\n+        vectorRebracket(SSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toI128\")\n+    public static void runS128toI128() throws Throwable {\n+        runRebracketHelper(SSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toL128(short[] input, long[] output) {\n+        vectorRebracket(SSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toL128\")\n+    public static void runS128toL128() throws Throwable {\n+        runRebracketHelper(SSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toF128(short[] input, float[] output) {\n+        vectorRebracket(SSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toF128\")\n+    public static void runS128toF128() throws Throwable {\n+        runRebracketHelper(SSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS128toD128(short[] input, double[] output) {\n+        vectorRebracket(SSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testS128toD128\")\n+    public static void runS128toD128() throws Throwable {\n+        runRebracketHelper(SSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toB128(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toB128\")\n+    public static void runI128toB128() throws Throwable {\n+        runRebracketHelper(ISPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toS128(int[] input, short[] output) {\n+        vectorRebracket(ISPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toS128\")\n+    public static void runI128toS128() throws Throwable {\n+        runRebracketHelper(ISPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toL128(int[] input, long[] output) {\n+        vectorRebracket(ISPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toL128\")\n+    public static void runI128toL128() throws Throwable {\n+        runRebracketHelper(ISPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toF128(int[] input, float[] output) {\n+        vectorRebracket(ISPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toF128\")\n+    public static void runI128toF128() throws Throwable {\n+        runRebracketHelper(ISPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI128toD128(int[] input, double[] output) {\n+        vectorRebracket(ISPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testI128toD128\")\n+    public static void runI128toD128() throws Throwable {\n+        runRebracketHelper(ISPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toB128(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toB128\")\n+    public static void runL128toB128() throws Throwable {\n+        runRebracketHelper(LSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toS128(long[] input, short[] output) {\n+        vectorRebracket(LSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toS128\")\n+    public static void runL128toS128() throws Throwable {\n+        runRebracketHelper(LSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toI128(long[] input, int[] output) {\n+        vectorRebracket(LSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toI128\")\n+    public static void runL128toI128() throws Throwable {\n+        runRebracketHelper(LSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toF128(long[] input, float[] output) {\n+        vectorRebracket(LSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toF128\")\n+    public static void runL128toF128() throws Throwable {\n+        runRebracketHelper(LSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL128toD128(long[] input, double[] output) {\n+        vectorRebracket(LSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testL128toD128\")\n+    public static void runL128toD128() throws Throwable {\n+        runRebracketHelper(LSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toB128(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toB128\")\n+    public static void runF128toB128() throws Throwable {\n+        runRebracketHelper(FSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toS128(float[] input, short[] output) {\n+        vectorRebracket(FSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toS128\")\n+    public static void runF128toS128() throws Throwable {\n+        runRebracketHelper(FSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toI128(float[] input, int[] output) {\n+        vectorRebracket(FSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toI128\")\n+    public static void runF128toI128() throws Throwable {\n+        runRebracketHelper(FSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toL128(float[] input, long[] output) {\n+        vectorRebracket(FSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toL128\")\n+    public static void runF128toL128() throws Throwable {\n+        runRebracketHelper(FSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF128toD128(float[] input, double[] output) {\n+        vectorRebracket(FSPEC128, DSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testF128toD128\")\n+    public static void runF128toD128() throws Throwable {\n+        runRebracketHelper(FSPEC128, DSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toB128(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC128, BSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toB128\")\n+    public static void runD128toB128() throws Throwable {\n+        runRebracketHelper(DSPEC128, BSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toS128(double[] input, short[] output) {\n+        vectorRebracket(DSPEC128, SSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toS128\")\n+    public static void runD128toS128() throws Throwable {\n+        runRebracketHelper(DSPEC128, SSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toI128(double[] input, int[] output) {\n+        vectorRebracket(DSPEC128, ISPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toI128\")\n+    public static void runD128toI128() throws Throwable {\n+        runRebracketHelper(DSPEC128, ISPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toL128(double[] input, long[] output) {\n+        vectorRebracket(DSPEC128, LSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toL128\")\n+    public static void runD128toL128() throws Throwable {\n+        runRebracketHelper(DSPEC128, LSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD128toF128(double[] input, float[] output) {\n+        vectorRebracket(DSPEC128, FSPEC128, input, output);\n+    }\n+\n+    @Run(test = \"testD128toF128\")\n+    public static void runD128toF128() throws Throwable {\n+        runRebracketHelper(DSPEC128, FSPEC128);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toS256(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toS256\")\n+    public static void runB256toS256() throws Throwable {\n+        runRebracketHelper(BSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toI256(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toI256\")\n+    public static void runB256toI256() throws Throwable {\n+        runRebracketHelper(BSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toL256(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toL256\")\n+    public static void runB256toL256() throws Throwable {\n+        runRebracketHelper(BSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toF256(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toF256\")\n+    public static void runB256toF256() throws Throwable {\n+        runRebracketHelper(BSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB256toD256(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testB256toD256\")\n+    public static void runB256toD256() throws Throwable {\n+        runRebracketHelper(BSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toB256(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toB256\")\n+    public static void runS256toB256() throws Throwable {\n+        runRebracketHelper(SSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toI256(short[] input, int[] output) {\n+        vectorRebracket(SSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toI256\")\n+    public static void runS256toI256() throws Throwable {\n+        runRebracketHelper(SSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toL256(short[] input, long[] output) {\n+        vectorRebracket(SSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toL256\")\n+    public static void runS256toL256() throws Throwable {\n+        runRebracketHelper(SSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toF256(short[] input, float[] output) {\n+        vectorRebracket(SSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toF256\")\n+    public static void runS256toF256() throws Throwable {\n+        runRebracketHelper(SSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS256toD256(short[] input, double[] output) {\n+        vectorRebracket(SSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testS256toD256\")\n+    public static void runS256toD256() throws Throwable {\n+        runRebracketHelper(SSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toB256(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toB256\")\n+    public static void runI256toB256() throws Throwable {\n+        runRebracketHelper(ISPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toS256(int[] input, short[] output) {\n+        vectorRebracket(ISPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toS256\")\n+    public static void runI256toS256() throws Throwable {\n+        runRebracketHelper(ISPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toL256(int[] input, long[] output) {\n+        vectorRebracket(ISPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toL256\")\n+    public static void runI256toL256() throws Throwable {\n+        runRebracketHelper(ISPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toF256(int[] input, float[] output) {\n+        vectorRebracket(ISPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toF256\")\n+    public static void runI256toF256() throws Throwable {\n+        runRebracketHelper(ISPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI256toD256(int[] input, double[] output) {\n+        vectorRebracket(ISPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testI256toD256\")\n+    public static void runI256toD256() throws Throwable {\n+        runRebracketHelper(ISPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toB256(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toB256\")\n+    public static void runL256toB256() throws Throwable {\n+        runRebracketHelper(LSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toS256(long[] input, short[] output) {\n+        vectorRebracket(LSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toS256\")\n+    public static void runL256toS256() throws Throwable {\n+        runRebracketHelper(LSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toI256(long[] input, int[] output) {\n+        vectorRebracket(LSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toI256\")\n+    public static void runL256toI256() throws Throwable {\n+        runRebracketHelper(LSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toF256(long[] input, float[] output) {\n+        vectorRebracket(LSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toF256\")\n+    public static void runL256toF256() throws Throwable {\n+        runRebracketHelper(LSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL256toD256(long[] input, double[] output) {\n+        vectorRebracket(LSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testL256toD256\")\n+    public static void runL256toD256() throws Throwable {\n+        runRebracketHelper(LSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toB256(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toB256\")\n+    public static void runF256toB256() throws Throwable {\n+        runRebracketHelper(FSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toS256(float[] input, short[] output) {\n+        vectorRebracket(FSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toS256\")\n+    public static void runF256toS256() throws Throwable {\n+        runRebracketHelper(FSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toI256(float[] input, int[] output) {\n+        vectorRebracket(FSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toI256\")\n+    public static void runF256toI256() throws Throwable {\n+        runRebracketHelper(FSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toL256(float[] input, long[] output) {\n+        vectorRebracket(FSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toL256\")\n+    public static void runF256toL256() throws Throwable {\n+        runRebracketHelper(FSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF256toD256(float[] input, double[] output) {\n+        vectorRebracket(FSPEC256, DSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testF256toD256\")\n+    public static void runF256toD256() throws Throwable {\n+        runRebracketHelper(FSPEC256, DSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toB256(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC256, BSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toB256\")\n+    public static void runD256toB256() throws Throwable {\n+        runRebracketHelper(DSPEC256, BSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toS256(double[] input, short[] output) {\n+        vectorRebracket(DSPEC256, SSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toS256\")\n+    public static void runD256toS256() throws Throwable {\n+        runRebracketHelper(DSPEC256, SSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toI256(double[] input, int[] output) {\n+        vectorRebracket(DSPEC256, ISPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toI256\")\n+    public static void runD256toI256() throws Throwable {\n+        runRebracketHelper(DSPEC256, ISPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toL256(double[] input, long[] output) {\n+        vectorRebracket(DSPEC256, LSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toL256\")\n+    public static void runD256toL256() throws Throwable {\n+        runRebracketHelper(DSPEC256, LSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD256toF256(double[] input, float[] output) {\n+        vectorRebracket(DSPEC256, FSPEC256, input, output);\n+    }\n+\n+    @Run(test = \"testD256toF256\")\n+    public static void runD256toF256() throws Throwable {\n+        runRebracketHelper(DSPEC256, FSPEC256);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toS512(byte[] input, short[] output) {\n+        vectorRebracket(BSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toS512\")\n+    public static void runB512toS512() throws Throwable {\n+        runRebracketHelper(BSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toI512(byte[] input, int[] output) {\n+        vectorRebracket(BSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toI512\")\n+    public static void runB512toI512() throws Throwable {\n+        runRebracketHelper(BSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toL512(byte[] input, long[] output) {\n+        vectorRebracket(BSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toL512\")\n+    public static void runB512toL512() throws Throwable {\n+        runRebracketHelper(BSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toF512(byte[] input, float[] output) {\n+        vectorRebracket(BSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toF512\")\n+    public static void runB512toF512() throws Throwable {\n+        runRebracketHelper(BSPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testB512toD512(byte[] input, double[] output) {\n+        vectorRebracket(BSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testB512toD512\")\n+    public static void runB512toD512() throws Throwable {\n+        runRebracketHelper(BSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toB512(short[] input, byte[] output) {\n+        vectorRebracket(SSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toB512\")\n+    public static void runS512toB512() throws Throwable {\n+        runRebracketHelper(SSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toI512(short[] input, int[] output) {\n+        vectorRebracket(SSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toI512\")\n+    public static void runS512toI512() throws Throwable {\n+        runRebracketHelper(SSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toL512(short[] input, long[] output) {\n+        vectorRebracket(SSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toL512\")\n+    public static void runS512toL512() throws Throwable {\n+        runRebracketHelper(SSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toF512(short[] input, float[] output) {\n+        vectorRebracket(SSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toF512\")\n+    public static void runS512toF512() throws Throwable {\n+        runRebracketHelper(SSPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testS512toD512(short[] input, double[] output) {\n+        vectorRebracket(SSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testS512toD512\")\n+    public static void runS512toD512() throws Throwable {\n+        runRebracketHelper(SSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toB512(int[] input, byte[] output) {\n+        vectorRebracket(ISPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toB512\")\n+    public static void runI512toB512() throws Throwable {\n+        runRebracketHelper(ISPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toS512(int[] input, short[] output) {\n+        vectorRebracket(ISPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toS512\")\n+    public static void runI512toS512() throws Throwable {\n+        runRebracketHelper(ISPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toL512(int[] input, long[] output) {\n+        vectorRebracket(ISPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toL512\")\n+    public static void runI512toL512() throws Throwable {\n+        runRebracketHelper(ISPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toF512(int[] input, float[] output) {\n+        vectorRebracket(ISPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toF512\")\n+    public static void runI512toF512() throws Throwable {\n+        runRebracketHelper(ISPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testI512toD512(int[] input, double[] output) {\n+        vectorRebracket(ISPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testI512toD512\")\n+    public static void runI512toD512() throws Throwable {\n+        runRebracketHelper(ISPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toB512(long[] input, byte[] output) {\n+        vectorRebracket(LSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toB512\")\n+    public static void runL512toB512() throws Throwable {\n+        runRebracketHelper(LSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toS512(long[] input, short[] output) {\n+        vectorRebracket(LSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toS512\")\n+    public static void runL512toS512() throws Throwable {\n+        runRebracketHelper(LSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toI512(long[] input, int[] output) {\n+        vectorRebracket(LSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toI512\")\n+    public static void runL512toI512() throws Throwable {\n+        runRebracketHelper(LSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toF512(long[] input, float[] output) {\n+        vectorRebracket(LSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toF512\")\n+    public static void runL512toF512() throws Throwable {\n+        runRebracketHelper(LSPEC512, FSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testL512toD512(long[] input, double[] output) {\n+        vectorRebracket(LSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testL512toD512\")\n+    public static void runL512toD512() throws Throwable {\n+        runRebracketHelper(LSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toB512(float[] input, byte[] output) {\n+        vectorRebracket(FSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toB512\")\n+    public static void runF512toB512() throws Throwable {\n+        runRebracketHelper(FSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toS512(float[] input, short[] output) {\n+        vectorRebracket(FSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toS512\")\n+    public static void runF512toS512() throws Throwable {\n+        runRebracketHelper(FSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toI512(float[] input, int[] output) {\n+        vectorRebracket(FSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toI512\")\n+    public static void runF512toI512() throws Throwable {\n+        runRebracketHelper(FSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toL512(float[] input, long[] output) {\n+        vectorRebracket(FSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toL512\")\n+    public static void runF512toL512() throws Throwable {\n+        runRebracketHelper(FSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testF512toD512(float[] input, double[] output) {\n+        vectorRebracket(FSPEC512, DSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testF512toD512\")\n+    public static void runF512toD512() throws Throwable {\n+        runRebracketHelper(FSPEC512, DSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toB512(double[] input, byte[] output) {\n+        vectorRebracket(DSPEC512, BSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toB512\")\n+    public static void runD512toB512() throws Throwable {\n+        runRebracketHelper(DSPEC512, BSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toS512(double[] input, short[] output) {\n+        vectorRebracket(DSPEC512, SSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toS512\")\n+    public static void runD512toS512() throws Throwable {\n+        runRebracketHelper(DSPEC512, SSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toI512(double[] input, int[] output) {\n+        vectorRebracket(DSPEC512, ISPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toI512\")\n+    public static void runD512toI512() throws Throwable {\n+        runRebracketHelper(DSPEC512, ISPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toL512(double[] input, long[] output) {\n+        vectorRebracket(DSPEC512, LSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toL512\")\n+    public static void runD512toL512() throws Throwable {\n+        runRebracketHelper(DSPEC512, LSPEC512);\n+    }\n+\n+    @Test\n+    @IR(counts = {REINTERPRET_NODE, \"1\"})\n+    public static void testD512toF512(double[] input, float[] output) {\n+        vectorRebracket(DSPEC512, FSPEC512, input, output);\n+    }\n+\n+    @Run(test = \"testD512toF512\")\n+    public static void runD512toF512() throws Throwable {\n+        runRebracketHelper(DSPEC512, FSPEC512);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/tests\/TestVectorRebracket.java","additions":1362,"deletions":0,"binary":false,"changes":1362,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static compiler.vectorapi.reshape.utils.VectorReshapeHelper.*;\n+import static compiler.vectorapi.reshape.utils.VectorSpeciesPair.makePair;\n+\n+\/**\n+ * The cast intrinsics implemented on each platform, commented out tests are the ones that are\n+ * supposed to work but currently don't.\n+ *\/\n+public class TestCastMethods {\n+    public static final List<VectorSpeciesPair> AVX1_CAST_TESTS = List.of(\n+            makePair(BSPEC64, SSPEC64),\n+            makePair(BSPEC64, SSPEC128),\n+            makePair(BSPEC64, ISPEC128),\n+            makePair(BSPEC64, FSPEC128),\n+\/\/            makePair(BSPEC64, DSPEC256),\n+            makePair(SSPEC64, BSPEC64),\n+            makePair(SSPEC128, BSPEC64),\n+            makePair(SSPEC64, ISPEC64),\n+            makePair(SSPEC64, ISPEC128),\n+            makePair(SSPEC64, LSPEC128),\n+            makePair(SSPEC64, FSPEC64),\n+            makePair(SSPEC64, FSPEC128),\n+            makePair(SSPEC64, DSPEC128),\n+\/\/            makePair(SSPEC64, DSPEC256),\n+            makePair(ISPEC128, BSPEC64),\n+            makePair(ISPEC64, SSPEC64),\n+            makePair(ISPEC128, SSPEC64),\n+            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC64, FSPEC64),\n+            makePair(ISPEC128, FSPEC128),\n+            makePair(ISPEC64, DSPEC128),\n+            makePair(ISPEC128, DSPEC256),\n+            makePair(LSPEC128, SSPEC64),\n+            makePair(LSPEC128, ISPEC64),\n+            makePair(FSPEC64, ISPEC64),\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC64, DSPEC128),\n+            makePair(FSPEC128, DSPEC256),\n+            makePair(DSPEC128, FSPEC64),\n+            makePair(DSPEC256, FSPEC128)\n+    );\n+\n+    public static final List<VectorSpeciesPair> AVX2_CAST_TESTS = Stream.concat(AVX1_CAST_TESTS.stream(), Stream.of(\n+            makePair(BSPEC128, SSPEC256),\n+            makePair(BSPEC64, ISPEC256),\n+            makePair(BSPEC64, LSPEC256),\n+            makePair(BSPEC64, FSPEC256),\n+            makePair(SSPEC256, BSPEC128),\n+            makePair(SSPEC128, ISPEC256),\n+            makePair(SSPEC64, LSPEC256),\n+            makePair(SSPEC128, FSPEC256),\n+            makePair(ISPEC256, BSPEC64),\n+            makePair(ISPEC256, SSPEC128),\n+            makePair(ISPEC128, LSPEC256),\n+            makePair(ISPEC256, FSPEC256),\n+            makePair(LSPEC256, BSPEC64),\n+            makePair(LSPEC256, SSPEC64),\n+            makePair(LSPEC256, ISPEC128),\n+            makePair(FSPEC256, ISPEC256)\n+    )).toList();\n+\n+    public static final List<VectorSpeciesPair> AVX512_CAST_TESTS = Stream.concat(AVX2_CAST_TESTS.stream(), Stream.of(\n+            makePair(BSPEC128, ISPEC512),\n+            makePair(BSPEC64, LSPEC512),\n+            makePair(BSPEC128, FSPEC512),\n+            makePair(BSPEC64, DSPEC512),\n+            makePair(SSPEC256, ISPEC512),\n+            makePair(SSPEC128, LSPEC512),\n+            makePair(SSPEC256, FSPEC512),\n+            makePair(SSPEC128, DSPEC512),\n+            makePair(ISPEC512, BSPEC128),\n+            makePair(ISPEC512, SSPEC256),\n+            makePair(ISPEC256, LSPEC512),\n+            makePair(ISPEC512, FSPEC512),\n+            makePair(ISPEC256, DSPEC512),\n+            makePair(LSPEC512, BSPEC64),\n+            makePair(LSPEC512, SSPEC128),\n+            makePair(LSPEC512, ISPEC256),\n+            makePair(FSPEC512, ISPEC512),\n+            makePair(FSPEC256, DSPEC512),\n+            makePair(DSPEC512, FSPEC256)\n+    )).toList();\n+\n+    public static final List<VectorSpeciesPair> AVX512BW_CAST_TESTS = Stream.concat(AVX512_CAST_TESTS.stream(), Stream.of(\n+            makePair(BSPEC256, SSPEC512),\n+            makePair(SSPEC512, BSPEC256)\n+    )).toList();\n+\n+    public static final List<VectorSpeciesPair> AVX512DQ_CAST_TESTS = Stream.concat(AVX512_CAST_TESTS.stream(), Stream.of(\n+            makePair(LSPEC128, DSPEC128),\n+            makePair(LSPEC256, DSPEC256),\n+            makePair(LSPEC512, DSPEC512),\n+            makePair(DSPEC128, LSPEC128),\n+            makePair(DSPEC256, LSPEC256),\n+            makePair(DSPEC512, LSPEC512)\n+    )).toList();\n+\n+    public static final List<VectorSpeciesPair> SVE_CAST_TESTS = List.of(\n+            makePair(BSPEC64, SSPEC128),\n+            makePair(BSPEC128, SSPEC256),\n+            makePair(BSPEC256, SSPEC512),\n+            makePair(BSPEC64, ISPEC256),\n+            makePair(BSPEC128, ISPEC512),\n+            makePair(BSPEC64, LSPEC512),\n+            makePair(BSPEC64, FSPEC256),\n+            makePair(BSPEC128, FSPEC512),\n+            makePair(BSPEC64, DSPEC512),\n+            makePair(SSPEC128, BSPEC64),\n+            makePair(SSPEC256, BSPEC128),\n+            makePair(SSPEC512, BSPEC256),\n+            makePair(SSPEC64, ISPEC128),\n+            makePair(SSPEC128, ISPEC256),\n+            makePair(SSPEC256, ISPEC512),\n+            makePair(SSPEC64, LSPEC256),\n+            makePair(SSPEC128, LSPEC512),\n+            makePair(SSPEC64, FSPEC128),\n+            makePair(SSPEC128, FSPEC256),\n+            makePair(SSPEC256, FSPEC512),\n+            makePair(SSPEC64, DSPEC256),\n+            makePair(SSPEC128, DSPEC512),\n+            makePair(ISPEC256, BSPEC64),\n+            makePair(ISPEC512, BSPEC128),\n+            makePair(ISPEC128, SSPEC64),\n+            makePair(ISPEC256, SSPEC128),\n+            makePair(ISPEC512, SSPEC256),\n+            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC128, LSPEC256),\n+            makePair(ISPEC256, LSPEC512),\n+            makePair(ISPEC64, FSPEC64),\n+            makePair(ISPEC128, FSPEC128),\n+            makePair(ISPEC256, FSPEC256),\n+            makePair(ISPEC512, FSPEC512),\n+            makePair(ISPEC64, DSPEC128),\n+            makePair(ISPEC128, DSPEC256),\n+            makePair(ISPEC256, DSPEC512),\n+            makePair(LSPEC512, BSPEC64),\n+            makePair(LSPEC256, SSPEC64),\n+            makePair(LSPEC512, SSPEC128),\n+            makePair(LSPEC128, ISPEC64),\n+            makePair(LSPEC256, ISPEC128),\n+            makePair(LSPEC512, ISPEC256),\n+            makePair(LSPEC128, FSPEC64),\n+            makePair(LSPEC256, FSPEC128),\n+            makePair(LSPEC512, FSPEC256),\n+            makePair(LSPEC128, DSPEC128),\n+            makePair(LSPEC256, DSPEC256),\n+            makePair(LSPEC512, DSPEC512),\n+            makePair(FSPEC256, BSPEC64),\n+            makePair(FSPEC512, BSPEC128),\n+            makePair(FSPEC128, SSPEC64),\n+            makePair(FSPEC256, SSPEC128),\n+            makePair(FSPEC512, SSPEC256),\n+            makePair(FSPEC64, ISPEC64),\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC256, ISPEC256),\n+            makePair(FSPEC512, ISPEC512),\n+            makePair(FSPEC64, LSPEC128),\n+            makePair(FSPEC128, LSPEC256),\n+            makePair(FSPEC256, LSPEC512),\n+            makePair(FSPEC64, DSPEC128),\n+            makePair(FSPEC128, DSPEC256),\n+            makePair(FSPEC256, DSPEC512),\n+            makePair(DSPEC512, BSPEC64),\n+            makePair(DSPEC256, SSPEC64),\n+            makePair(DSPEC512, SSPEC128),\n+            makePair(DSPEC128, ISPEC64),\n+            makePair(DSPEC256, ISPEC128),\n+            makePair(DSPEC512, ISPEC256),\n+            makePair(DSPEC128, LSPEC128),\n+            makePair(DSPEC256, LSPEC256),\n+            makePair(DSPEC512, LSPEC512),\n+            makePair(DSPEC128, FSPEC64),\n+            makePair(DSPEC256, FSPEC128),\n+            makePair(DSPEC512, FSPEC256)\n+    );\n+\n+    public static final List<VectorSpeciesPair> NEON_CAST_TESTS = List.of(\n+            makePair(BSPEC64, SSPEC64),\n+            makePair(BSPEC64, SSPEC128),\n+            makePair(BSPEC64, ISPEC128),\n+            makePair(BSPEC64, FSPEC128),\n+            makePair(SSPEC64, BSPEC64),\n+            makePair(SSPEC128, BSPEC64),\n+            makePair(SSPEC64, ISPEC128),\n+            makePair(SSPEC64, FSPEC128),\n+            makePair(ISPEC128, BSPEC64),\n+            makePair(ISPEC128, SSPEC64),\n+            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC64, FSPEC64),\n+            makePair(ISPEC128, FSPEC128),\n+            makePair(ISPEC64, DSPEC128),\n+            makePair(LSPEC128, ISPEC64),\n+            makePair(LSPEC128, FSPEC64),\n+            makePair(LSPEC128, DSPEC128),\n+            makePair(FSPEC128, BSPEC64),\n+            makePair(FSPEC128, SSPEC64),\n+            makePair(FSPEC64, ISPEC64),\n+            makePair(FSPEC128, ISPEC128),\n+            makePair(FSPEC64, LSPEC128),\n+            makePair(FSPEC64, DSPEC128),\n+            makePair(DSPEC128, ISPEC64),\n+            makePair(DSPEC128, LSPEC128),\n+            makePair(DSPEC128, FSPEC64)\n+    );\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+\/**\n+ * Unsafe to check for correctness of reinterpret operations. May be replaced with foreign API later.\n+ *\/\n+public class UnsafeUtils {\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+    public static long arrayBase(Class<?> etype) {\n+        return UNSAFE.arrayBaseOffset(etype.arrayType());\n+    }\n+\n+    public static byte getByte(Object o, long base, int i) {\n+        \/\/ This technically leads to UB, what we need is UNSAFE.getByteUnaligned but they seem to be equivalent\n+        return UNSAFE.getByte(o, base + (long)i * Unsafe.ARRAY_BYTE_INDEX_SCALE);\n+    }\n+\n+    public static void putByte(Object o, long base, int i, byte value) {\n+        \/\/ This technically leads to UB, what we need is UNSAFE.putByteUnaligned but they seem to be equivalent\n+        UNSAFE.putByte(o, base + (long)i * Unsafe.ARRAY_BYTE_INDEX_SCALE, value);\n+    }\n+\n+    public static short getShort(Object o, long base, int i) {\n+        return UNSAFE.getShort(o, base + (long)i * Unsafe.ARRAY_SHORT_INDEX_SCALE);\n+    }\n+\n+    public static void putShort(Object o, long base, int i, short value) {\n+        UNSAFE.putShort(o, base + (long)i * Unsafe.ARRAY_SHORT_INDEX_SCALE, value);\n+    }\n+\n+    public static int getInt(Object o, long base, int i) {\n+        return UNSAFE.getInt(o, base + (long)i * Unsafe.ARRAY_INT_INDEX_SCALE);\n+    }\n+\n+    public static void putInt(Object o, long base, int i, int value) {\n+        UNSAFE.putInt(o, base + (long)i * Unsafe.ARRAY_INT_INDEX_SCALE, value);\n+    }\n+\n+    public static long getLong(Object o, long base, int i) {\n+        return UNSAFE.getLong(o, base + (long)i * Unsafe.ARRAY_LONG_INDEX_SCALE);\n+    }\n+\n+    public static void putLong(Object o, long base, int i, long value) {\n+        UNSAFE.putLong(o, base + (long)i * Unsafe.ARRAY_LONG_INDEX_SCALE, value);\n+    }\n+\n+    public static float getFloat(Object o, long base, int i) {\n+        return UNSAFE.getFloat(o, base + (long)i * Unsafe.ARRAY_FLOAT_INDEX_SCALE);\n+    }\n+\n+    public static void putFloat(Object o, long base, int i, float value) {\n+        UNSAFE.putFloat(o, base + (long)i * Unsafe.ARRAY_FLOAT_INDEX_SCALE, value);\n+    }\n+\n+    public static double getDouble(Object o, long base, int i) {\n+        return UNSAFE.getDouble(o, base + (long)i * Unsafe.ARRAY_DOUBLE_INDEX_SCALE);\n+    }\n+\n+    public static void putDouble(Object o, long base, int i, double value) {\n+        UNSAFE.putDouble(o, base + (long)i * Unsafe.ARRAY_DOUBLE_INDEX_SCALE, value);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/UnsafeUtils.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,328 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import compiler.lib.ir_framework.ForceInline;\n+import compiler.lib.ir_framework.IRNode;\n+import compiler.lib.ir_framework.TestFramework;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Array;\n+import java.nio.ByteOrder;\n+import java.util.List;\n+import java.util.random.RandomGenerator;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+\n+public class VectorReshapeHelper {\n+    public static final int INVOCATIONS = 10_000;\n+\n+    public static final VectorSpecies<Byte>    BSPEC64  =   ByteVector.SPECIES_64;\n+    public static final VectorSpecies<Short>   SSPEC64  =  ShortVector.SPECIES_64;\n+    public static final VectorSpecies<Integer> ISPEC64  =    IntVector.SPECIES_64;\n+    public static final VectorSpecies<Long>    LSPEC64  =   LongVector.SPECIES_64;\n+    public static final VectorSpecies<Float>   FSPEC64  =  FloatVector.SPECIES_64;\n+    public static final VectorSpecies<Double>  DSPEC64  = DoubleVector.SPECIES_64;\n+\n+    public static final VectorSpecies<Byte>    BSPEC128 =   ByteVector.SPECIES_128;\n+    public static final VectorSpecies<Short>   SSPEC128 =  ShortVector.SPECIES_128;\n+    public static final VectorSpecies<Integer> ISPEC128 =    IntVector.SPECIES_128;\n+    public static final VectorSpecies<Long>    LSPEC128 =   LongVector.SPECIES_128;\n+    public static final VectorSpecies<Float>   FSPEC128 =  FloatVector.SPECIES_128;\n+    public static final VectorSpecies<Double>  DSPEC128 = DoubleVector.SPECIES_128;\n+\n+    public static final VectorSpecies<Byte>    BSPEC256 =   ByteVector.SPECIES_256;\n+    public static final VectorSpecies<Short>   SSPEC256 =  ShortVector.SPECIES_256;\n+    public static final VectorSpecies<Integer> ISPEC256 =    IntVector.SPECIES_256;\n+    public static final VectorSpecies<Long>    LSPEC256 =   LongVector.SPECIES_256;\n+    public static final VectorSpecies<Float>   FSPEC256 =  FloatVector.SPECIES_256;\n+    public static final VectorSpecies<Double>  DSPEC256 = DoubleVector.SPECIES_256;\n+\n+    public static final VectorSpecies<Byte>    BSPEC512 =   ByteVector.SPECIES_512;\n+    public static final VectorSpecies<Short>   SSPEC512 =  ShortVector.SPECIES_512;\n+    public static final VectorSpecies<Integer> ISPEC512 =    IntVector.SPECIES_512;\n+    public static final VectorSpecies<Long>    LSPEC512 =   LongVector.SPECIES_512;\n+    public static final VectorSpecies<Float>   FSPEC512 =  FloatVector.SPECIES_512;\n+    public static final VectorSpecies<Double>  DSPEC512 = DoubleVector.SPECIES_512;\n+\n+    public static final String B2X_NODE  = IRNode.VECTOR_CAST_B2X;\n+    public static final String S2X_NODE  = IRNode.VECTOR_CAST_S2X;\n+    public static final String I2X_NODE  = IRNode.VECTOR_CAST_I2X;\n+    public static final String L2X_NODE  = IRNode.VECTOR_CAST_L2X;\n+    public static final String F2X_NODE  = IRNode.VECTOR_CAST_F2X;\n+    public static final String D2X_NODE  = IRNode.VECTOR_CAST_D2X;\n+    public static final String REINTERPRET_NODE = IRNode.VECTOR_REINTERPRET;\n+\n+    public static void runMainHelper(Class<?> testClass, Stream<VectorSpeciesPair> testMethods, String... flags) {\n+        var test = new TestFramework(testClass);\n+        test.setDefaultWarmup(1);\n+        test.addHelperClasses(VectorReshapeHelper.class);\n+        test.addFlags(\"--add-modules=jdk.incubator.vector\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+        test.addFlags(flags);\n+        String testMethodNames = testMethods\n+                .filter(p -> p.isp().length() <= VectorSpecies.ofLargestShape(p.isp().elementType()).length())\n+                .filter(p -> p.osp().length() <= VectorSpecies.ofLargestShape(p.osp().elementType()).length())\n+                .map(VectorSpeciesPair::format)\n+                .collect(Collectors.joining(\",\"));\n+        test.addFlags(\"-DTest=\" + testMethodNames);\n+        test.start();\n+    }\n+\n+    @ForceInline\n+    public static <T, U> void vectorCast(VectorOperators.Conversion<T, U> cop,\n+                                         VectorSpecies<T> isp, VectorSpecies<U> osp, Object input, Object output) {\n+        var outputVector = readVector(isp, input)\n+                .convertShape(cop, osp, 0);\n+        writeVector(osp, outputVector, output);\n+    }\n+\n+    public static <T, U> void runCastHelper(VectorOperators.Conversion<T, U> castOp,\n+                                            VectorSpecies<T> isp, VectorSpecies<U> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        boolean isUnsignedCast = castOp.name().startsWith(\"ZERO\");\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                    testMethodName,\n+                    MethodType.methodType(void.class, isp.elementType().arrayType(), osp.elementType().arrayType()))\n+                .asType(MethodType.methodType(void.class, Object.class, Object.class));\n+        Object input = Array.newInstance(isp.elementType(), isp.length());\n+        Object output = Array.newInstance(osp.elementType(), osp.length());\n+        long ibase = UnsafeUtils.arrayBase(isp.elementType());\n+        long obase = UnsafeUtils.arrayBase(osp.elementType());\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            \/\/ We need to generate arrays with NaN or very large values occasionally\n+            boolean normalArray = random.nextBoolean();\n+            var abnormalValue = List.of(Double.NaN, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY, -1e30, 1e30);\n+            for (int i = 0; i < isp.length(); i++) {\n+                switch (isp.elementType().getName()) {\n+                    case \"byte\"   -> UnsafeUtils.putByte(input, ibase, i, (byte)random.nextInt());\n+                    case \"short\"  -> UnsafeUtils.putShort(input, ibase, i, (short)random.nextInt());\n+                    case \"int\"    -> UnsafeUtils.putInt(input, ibase, i, random.nextInt());\n+                    case \"long\"   -> UnsafeUtils.putLong(input, ibase, i, random.nextLong());\n+                    case \"float\"  -> {\n+                        if (normalArray || random.nextBoolean()) {\n+                            UnsafeUtils.putFloat(input, ibase, i, random.nextFloat(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+                        } else {\n+                            UnsafeUtils.putFloat(input, ibase, i, abnormalValue.get(random.nextInt(abnormalValue.size())).floatValue());\n+                        }\n+                    }\n+                    case \"double\" -> {\n+                        if (normalArray || random.nextBoolean()) {\n+                            UnsafeUtils.putDouble(input, ibase, i, random.nextDouble(Byte.MIN_VALUE, Byte.MAX_VALUE));\n+                        } else {\n+                            UnsafeUtils.putDouble(input, ibase, i, abnormalValue.get(random.nextInt(abnormalValue.size())));\n+                        }\n+                    }\n+                    default -> throw new AssertionError();\n+                }\n+            }\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < osp.length(); i++) {\n+                Number expected, actual;\n+                if (i < isp.length()) {\n+                    Number initial = switch (isp.elementType().getName()) {\n+                        case \"byte\"   -> UnsafeUtils.getByte(input, ibase, i);\n+                        case \"short\"  -> UnsafeUtils.getShort(input, ibase, i);\n+                        case \"int\"    -> UnsafeUtils.getInt(input, ibase, i);\n+                        case \"long\"   -> UnsafeUtils.getLong(input, ibase, i);\n+                        case \"float\"  -> UnsafeUtils.getFloat(input, ibase, i);\n+                        case \"double\" -> UnsafeUtils.getDouble(input, ibase, i);\n+                        default -> throw new AssertionError();\n+                    };\n+                    expected = switch (osp.elementType().getName()) {\n+                        case \"byte\" -> initial.byteValue();\n+                        case \"short\" -> {\n+                            if (isUnsignedCast) {\n+                                yield (short) (initial.longValue() & ((1L << isp.elementSize()) - 1));\n+                            } else {\n+                                yield initial.shortValue();\n+                            }\n+                        }\n+                        case \"int\" -> {\n+                            if (isUnsignedCast) {\n+                                yield (int) (initial.longValue() & ((1L << isp.elementSize()) - 1));\n+                            } else {\n+                                yield initial.intValue();\n+                            }\n+                        }\n+                        case \"long\" -> {\n+                            if (isUnsignedCast) {\n+                                yield (long) (initial.longValue() & ((1L << isp.elementSize()) - 1));\n+                            } else {\n+                                yield initial.longValue();\n+                            }\n+                        }\n+                        case \"float\" -> initial.floatValue();\n+                        case \"double\" -> initial.doubleValue();\n+                        default -> throw new AssertionError();\n+                    };\n+                } else {\n+                    expected = switch (osp.elementType().getName()) {\n+                        case \"byte\"   -> (byte)0;\n+                        case \"short\"  -> (short)0;\n+                        case \"int\"    -> (int)0;\n+                        case \"long\"   -> (long)0;\n+                        case \"float\"  -> (float)0;\n+                        case \"double\" -> (double)0;\n+                        default -> throw new AssertionError();\n+                    };\n+                }\n+                actual = switch (osp.elementType().getName()) {\n+                    case \"byte\"   -> UnsafeUtils.getByte(output, obase, i);\n+                    case \"short\"  -> UnsafeUtils.getShort(output, obase, i);\n+                    case \"int\"    -> UnsafeUtils.getInt(output, obase, i);\n+                    case \"long\"   -> UnsafeUtils.getLong(output, obase, i);\n+                    case \"float\"  -> UnsafeUtils.getFloat(output, obase, i);\n+                    case \"double\" -> UnsafeUtils.getDouble(output, obase, i);\n+                    default -> throw new AssertionError();\n+                };\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void vectorExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp, byte[] input, byte[] output) {\n+        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+                .reinterpretShape(osp, 0)\n+                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+    }\n+\n+    public static void runExpandShrinkHelper(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                testMethodName,\n+                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+        byte[] input = new byte[isp.vectorByteSize()];\n+        byte[] output = new byte[osp.vectorByteSize()];\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            random.nextBytes(input);\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < osp.vectorByteSize(); i++) {\n+                int expected = i < isp.vectorByteSize() ? input[i] : 0;\n+                int actual = output[i];\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static void vectorDoubleExpandShrink(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp, byte[] input, byte[] output) {\n+        isp.fromByteArray(input, 0, ByteOrder.nativeOrder())\n+                .reinterpretShape(osp, 0)\n+                .reinterpretShape(isp, 0)\n+                .intoByteArray(output, 0, ByteOrder.nativeOrder());\n+    }\n+\n+    public static void runDoubleExpandShrinkHelper(VectorSpecies<Byte> isp, VectorSpecies<Byte> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                testMethodName,\n+                MethodType.methodType(void.class, byte.class.arrayType(), byte.class.arrayType()));\n+        byte[] input = new byte[isp.vectorByteSize()];\n+        byte[] output = new byte[isp.vectorByteSize()];\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            random.nextBytes(input);\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < isp.vectorByteSize(); i++) {\n+                int expected = i < osp.vectorByteSize() ? input[i] : 0;\n+                int actual = output[i];\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    public static <T, U> void vectorRebracket(VectorSpecies<T> isp, VectorSpecies<U> osp, Object input, Object output) {\n+        var outputVector = readVector(isp, input)\n+                .reinterpretShape(osp, 0);\n+        writeVector(osp, outputVector, output);\n+    }\n+\n+    public static <T, U> void runRebracketHelper(VectorSpecies<T> isp, VectorSpecies<U> osp) throws Throwable {\n+        var random = RandomGenerator.getDefault();\n+        String testMethodName = VectorSpeciesPair.makePair(isp, osp).format();\n+        var caller = StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).getCallerClass();\n+        var testMethod = MethodHandles.lookup().findStatic(caller,\n+                    testMethodName,\n+                    MethodType.methodType(void.class, isp.elementType().arrayType(), osp.elementType().arrayType()))\n+                .asType(MethodType.methodType(void.class, Object.class, Object.class));\n+        Object input = Array.newInstance(isp.elementType(), isp.length());\n+        Object output = Array.newInstance(osp.elementType(), osp.length());\n+        long ibase = UnsafeUtils.arrayBase(isp.elementType());\n+        long obase = UnsafeUtils.arrayBase(osp.elementType());\n+        for (int iter = 0; iter < INVOCATIONS; iter++) {\n+            for (int i = 0; i < isp.vectorByteSize(); i++) {\n+                UnsafeUtils.putByte(input, ibase, i, (byte)random.nextInt());\n+            }\n+\n+            testMethod.invokeExact(input, output);\n+\n+            for (int i = 0; i < osp.vectorByteSize(); i++) {\n+                int expected = i < isp.vectorByteSize() ? UnsafeUtils.getByte(input, ibase, i) : 0;\n+                int actual = UnsafeUtils.getByte(output, obase, i);\n+                Asserts.assertEquals(expected, actual);\n+            }\n+        }\n+    }\n+\n+    @ForceInline\n+    private static <T> Vector<T> readVector(VectorSpecies<T> isp, Object input) {\n+        return isp.fromArray(input, 0);\n+    }\n+\n+    @ForceInline\n+    private static <U> void writeVector(VectorSpecies<U> osp, Vector<U> vector, Object output) {\n+        var otype = osp.elementType();\n+        if (otype == byte.class) {\n+            ((ByteVector)vector).intoArray((byte[])output, 0);\n+        } else if (otype == short.class) {\n+            ((ShortVector)vector).intoArray((short[])output, 0);\n+        } else if (otype == int.class) {\n+            ((IntVector)vector).intoArray((int[])output, 0);\n+        } else if (otype == long.class) {\n+            ((LongVector)vector).intoArray((long[])output, 0);\n+        } else if (otype == float.class) {\n+            ((FloatVector)vector).intoArray((float[])output, 0);\n+        } else if (otype == double.class) {\n+            ((DoubleVector)vector).intoArray((double[])output, 0);\n+        } else {\n+            throw new AssertionError();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorReshapeHelper.java","additions":328,"deletions":0,"binary":false,"changes":328,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi.reshape.utils;\n+\n+import jdk.incubator.vector.VectorSpecies;\n+\n+public record VectorSpeciesPair(VectorSpecies<?> isp, VectorSpecies<?> osp, boolean unsignedCast) {\n+    public static VectorSpeciesPair makePair(VectorSpecies<?> isp, VectorSpecies<?> osp, boolean unsignedCast) {\n+        return new VectorSpeciesPair(isp, osp, unsignedCast);\n+    }\n+\n+    public static VectorSpeciesPair makePair(VectorSpecies<?> isp, VectorSpecies<?> osp) {\n+        return new VectorSpeciesPair(isp, osp, false);\n+    }\n+\n+    public String format() {\n+        return String.format(\"test%s%c%dto%c%d\",\n+                unsignedCast() ? \"U\" : \"\",\n+                Character.toUpperCase(isp().elementType().getName().charAt(0)),\n+                isp().vectorBitSize(),\n+                Character.toUpperCase(osp().elementType().getName().charAt(0)),\n+                osp().vectorBitSize());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/VectorSpeciesPair.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -57,4 +57,0 @@\n-            {\"UseSharedSpaces\",           \"false\"},\n-            {\"RequireSharedSpaces\",       \"false\"},\n-            {\"DumpSharedSpaces\",          \"false\"},\n-            {\"DynamicDumpSharedSpaces\",   \"false\"},\n@@ -67,3 +63,0 @@\n-        if (!Platform.isDebugBuild()) {\n-            deprecated.add(new String[]{\"UseHeavyMonitors\", \"false\"});\n-        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.invoke.MethodHandles.Lookup.ClassOption;\n@@ -47,0 +48,7 @@\n+        \/\/ This class is also used by the appcds\/dynamicArchive\/RegularHiddenClass.java\n+        \/\/ test which will pass the \"keep-alive\" argument during dynamic CDS dump\n+        \/\/ for preventing from being GC'ed prior to the dumping operation.\n+        boolean keepAlive = false;\n+        if (args.length == 1 && args[0].equals(\"keep-alive\")) {\n+            keepAlive = true;\n+        }\n@@ -51,2 +59,2 @@\n-            Class<?> cl = lookup.defineHiddenClass(klassbuf, false, NESTMATE).lookupClass();\n-            Class.forName(cl.getName()).newInstance();\n+            Class<?> c0 = lookup.defineHiddenClass(klassbuf, false, NESTMATE).lookupClass();\n+            Class.forName(c0.getName()).newInstance();\n@@ -63,2 +71,3 @@\n-        Class<?> c1 = lookup.defineHiddenClass(klassbuf, false, NESTMATE).lookupClass();\n-        Class<?> c2 = lookup.defineHiddenClass(klassbuf, false, NESTMATE).lookupClass();\n+        ClassOption classOption = keepAlive ? STRONG : NESTMATE;\n+        Class<?> c1 = lookup.defineHiddenClass(klassbuf, false, classOption).lookupClass();\n+        Class<?> c2 = lookup.defineHiddenClass(klassbuf, false, classOption).lookupClass();\n","filename":"test\/hotspot\/jtreg\/runtime\/HiddenClasses\/InstantiateHiddenClass.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestSpinPause\n+ * @summary JVM runtime can use SpinPause function for synchronized statements.\n+ *          Check different implementations of JVM SpinPause don't crash JVM.\n+ * @bug 8278241\n+ * @library \/test\/lib\n+ *\n+ * @requires os.arch==\"aarch64\"\n+ *\n+ * @run main\/othervm TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=none TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop -XX:OnSpinWaitInstCount=10 TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb -XX:OnSpinWaitInstCount=3 TestSpinPause\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield -XX:OnSpinWaitInstCount=3 TestSpinPause\n+ * @run main\/othervm -Xint TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=none TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop -XX:OnSpinWaitInstCount=10 TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb -XX:OnSpinWaitInstCount=3 TestSpinPause\n+ * @run main\/othervm -Xint -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield -XX:OnSpinWaitInstCount=3 TestSpinPause\n+ * @run main\/othervm -Xcomp TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=none TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=nop -XX:OnSpinWaitInstCount=10 TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=isb -XX:OnSpinWaitInstCount=3 TestSpinPause\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:OnSpinWaitInst=yield -XX:OnSpinWaitInstCount=3 TestSpinPause\n+ *\/\n+\n+public class TestSpinPause {\n+    private Integer[] valueHolder;\n+\n+    private TestSpinPause () {\n+        valueHolder = new Integer[] {Integer.valueOf(101)};\n+    }\n+\n+    private void getSet() {\n+        final int iterCount = 100;\n+        for (int i = 0; i < iterCount; ++i) {\n+           synchronized (valueHolder) {\n+               Integer v = valueHolder[0];\n+               valueHolder[0] = Integer.reverse(v);\n+           }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        TestSpinPause test = new TestSpinPause();\n+        Thread t1 = new Thread(test::getSet);\n+        Thread t2 = new Thread(test::getSet);\n+        t1.start();\n+        t2.start();\n+        t1.join();\n+        t2.join();\n+        System.out.println(\"Done: \" + test.valueHolder[0]);\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/Thread\/TestSpinPause.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -48,6 +48,0 @@\n-        \/\/ -XX:+DumpSharedSpaces should behave the same as -Xshare:dump\n-        opts = (new CDSOptions())\n-            .addPrefix(\"-XX:+DumpSharedSpaces\", \"-Xlog:cds\")\n-            .setArchiveName(\".\/SharedArchiveFile.jsa\");\n-        CDSTestUtils.createArchiveAndCheck(opts);\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/SharedArchiveFile.java","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+    \/\/ Prevent the following class from being GC'ed too soon.\n+    private static Class keptC = null;\n@@ -35,2 +37,2 @@\n-        if (args.length != 3) {\n-            throw new RuntimeException(\"Unexpected number of arguments: expected 3, actual \" + args.length);\n+        if (args.length < 3) {\n+            throw new RuntimeException(\"Unexpected number of arguments: expected at least 3, actual \" + args.length);\n@@ -65,0 +67,8 @@\n+        \/\/ The HelloDynamicCustom.java and PrintSharedArchiveAndExit.java tests\n+        \/\/ under appcds\/dynamicArchive pass the keep-alive argument for preventing\n+        \/\/ the class from being GC'ed prior to dumping of the dynamic CDS archive.\n+        boolean keepAlive = false;\n+        if (args[args.length - 1].equals(\"keep-alive\")) {\n+            keepAlive = true;\n+        }\n+\n@@ -68,0 +78,3 @@\n+        if (keepAlive) {\n+            keptC = c;\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/HelloUnload.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.HashMap;\n@@ -31,0 +32,2 @@\n+    \/\/ Prevent the classes from being GC'ed too soon.\n+    static HashMap<String, Class> clsMap = new HashMap<>();\n@@ -47,0 +50,10 @@\n+        \/\/ The OldClassAndInf.java test under appcds\/dynamicArchive passes the keep-alive\n+        \/\/ argument for preventing the classes from being GC'ed prior to dumping of\n+        \/\/ the dynamic CDS archive.\n+        int startIdx = 2;\n+        boolean keepAlive = false;\n+        if (args[2].equals(\"keep-alive\")) {\n+            keepAlive = true;\n+            startIdx = 3;\n+        }\n+\n@@ -50,1 +63,1 @@\n-        for (int i = 2; i < args.length; i++) {\n+        for (int i = startIdx; i < args.length; i++) {\n@@ -54,0 +67,3 @@\n+            if (keepAlive) {\n+                clsMap.put(args[i], c);\n+            }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/customLoader\/test-classes\/OldClassApp.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277100\n+ * @summary VM should exit with an error message if the specified dynamic archive\n+ *          is the same as the default CDS archive.\n+ * @requires vm.cds\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. DumpToDefaultArchive\n+ *\/\n+\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import sun.hotspot.WhiteBox;\n+\n+public class DumpToDefaultArchive extends DynamicArchiveTestBase {\n+\n+    public static void main(String[] args) throws Exception {\n+        runTest(DumpToDefaultArchive::doTest);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        WhiteBox wb = WhiteBox.getWhiteBox();\n+        String topArchiveName = wb.getDefaultArchivePath();\n+\n+        dump(topArchiveName,\n+             \"-Xlog:cds\",\n+             \"-version\")\n+            .assertAbnormalExit(output -> {\n+                    output.shouldContain(\"Cannot specify the default CDS archive for -XX:ArchiveClassesAtExit: \"\n+                        + topArchiveName);\n+                });\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DumpToDefaultArchive.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -283,1 +283,1 @@\n-     * Return true if the UseSharedSpaces flag has been disabled.\n+     * Return true if sharing has been disabled.\n@@ -285,2 +285,2 @@\n-     * The UseSharedSpaces flag will be disabled by the VM if there's some\n-     * problem in using the default CDS archive. It could happen under some\n+     * Sharing will be disabled by the VM if there's some problem\n+     * in using the default CDS archive. It could happen under some\n@@ -297,1 +297,1 @@\n-        return (WB.getBooleanVMFlag(\"UseSharedSpaces\") == false);\n+        return !WB.isSharingEnabled();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicArchiveTestBase.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary The DynamicDumpShareSpaces flag is internal, setting it at the command line should have no effect.\n- * @requires vm.cds\n- * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- * @compile ..\/test-classes\/Hello.java\n- * @run driver DynamicFlag\n- *\/\n-\n-public class DynamicFlag {\n-  public static void main(String[] args) throws Exception {\n-      TestCommon.test(JarBuilder.getOrCreateHelloJar(),\n-          TestCommon.list(\"Hello\"), \"-XX:+DynamicDumpSharedSpaces\", \"Hello\");\n-  }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/DynamicFlag.java","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -67,1 +67,1 @@\n-            mainAppClass, customJarPath, \"false\", \"false\")\n+            mainAppClass, customJarPath, \"false\", \"false\", \"keep-alive\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/HelloDynamicCustom.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-            \"-cp\", appJar, mainClass, appJar, \"init\")\n+            \"-cp\", appJar, mainClass, appJar, \"init\", \"keep-alive\")\n@@ -70,1 +70,1 @@\n-            \"-cp\", appJar, mainClass, appJar)\n+            \"-cp\", appJar, mainClass, appJar, \"keep-alive\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/LambdaCustomLoader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-                     mainAppClass, loadeesJar, inArchive),\n+                     mainAppClass, loadeesJar, inArchive, \"keep-alive\"),\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/OldClassAndInf.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-            mainAppClass, customJarPath, \"false\", \"false\")\n+            mainAppClass, customJarPath, \"false\", \"false\", \"keep-alive\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/PrintSharedArchiveAndExit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-            \"-cp\", appJar, mainClass)\n+            \"-cp\", appJar, mainClass, \"keep-alive\")\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/RegularHiddenClass.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+    \/\/ Prevent the class from being GC'ed too soon.\n+    private static Class keptC = null;\n@@ -40,1 +42,1 @@\n-        if (args.length ==2 && args[1].equals(\"init\")) {\n+        if (args.length >= 2 && args[1].equals(\"init\")) {\n@@ -44,0 +46,8 @@\n+        \/\/ The dynamicArchive\/LambdaCustomLoader.java test passes the keep-alive\n+        \/\/ argument for preventing the class from being GC'ed prior to dumping of\n+        \/\/ the dynamic CDS archive.\n+        boolean keepAlive = false;\n+        if (args[args.length - 1].equals(\"keep-alive\")) {\n+            keepAlive = true;\n+        }\n+\n@@ -47,0 +57,4 @@\n+        if (keepAlive) {\n+            keptC = c;\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/test-classes\/CustomLoaderApp.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -99,1 +99,1 @@\n-        boolean cdsEnabled = WhiteBox.getWhiteBox().getBooleanVMFlag(\"UseSharedSpaces\");\n+        boolean cdsEnabled = WhiteBox.getWhiteBox().isSharingEnabled();\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDumpBase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -84,3 +84,3 @@\n-        \/\/ Test dynamic dump with flags -XX:+RecordDynamicDumpInfo -XX:-DynamicDumpSharedSpaces.\n-        print2ln(test_count++ + \" Test dynamic dump with flags -XX:+RecordDynamicDumpInfo -XX:-DynamicDumpSharedSpaces.\");\n-        app = createLingeredApp(\"-cp\", allJars, \"-XX:+RecordDynamicDumpInfo\", \"-XX:-DynamicDumpSharedSpaces\");\n+        \/\/ Test dynamic dump with flag -XX:+RecordDynamicDumpInfo\n+        print2ln(test_count++ + \" Test dynamic dump with flag -XX:+RecordDynamicDumpInfo.\");\n+        app = createLingeredApp(\"-cp\", allJars, \"-XX:+RecordDynamicDumpInfo\");\n@@ -91,7 +91,0 @@\n-        \/\/ Test dynamic dump with flags -XX:-DynamicDumpSharedSpaces -XX:+RecordDynamicDumpInfo.\n-        print2ln(test_count++ + \" Test dynamic dump with flags -XX:-DynamicDumpSharedSpaces -XX:+RecordDynamicDumpInfo.\");\n-        app = createLingeredApp(\"-cp\", allJars, \"-XX:-DynamicDumpSharedSpaces\", \"-XX:+RecordDynamicDumpInfo\");\n-        pid = app.getPid();\n-        test(null, pid, noBoot,  EXPECT_PASS, DYNAMIC_MESSAGES);\n-        app.stopApp();\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestDynamicDump.java","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    \/\/ Those two flags will not create a successful LingeredApp.\n+    \/\/ This flag will not create a successful LingeredApp.\n@@ -50,2 +50,1 @@\n-        {\"-XX:+DumpSharedSpaces\",\n-         \"-Xshare:dump\"};\n+        {\"-Xshare:dump\"};\n@@ -56,3 +55,0 @@\n-         \/\/ this flag just dump archive, won't run app normally.\n-         \/\/ \"-XX:+DumpSharedSpaces\",\n-         \"-XX:+DynamicDumpSharedSpaces\",\n@@ -64,3 +60,1 @@\n-         \"-XX:ArchiveClassesAtExit=tmp.jsa\",\n-         \"-XX:+UseSharedSpaces\",\n-         \"-XX:+RequireSharedSpaces\"};\n+         \"-XX:ArchiveClassesAtExit=tmp.jsa\"};\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jcmd\/JCmdTestStaticDump.java","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276241\n+ * @summary Throw ClassFormatError exception for an old class file whose name ends in a '\/'.\n+ * @run main\/othervm -Xverify:remote TrailingSlashTest\n+ *\/\n+\n+public class TrailingSlashTest extends ClassLoader {\n+\n+    @Override\n+    public Class findClass(String fileName) throws ClassNotFoundException {\n+        return defineClass(null, oldSlashClass, 0, oldSlashClass.length);\n+    }\n+\n+    public static void main(String args[]) throws Throwable {\n+        try {\n+            TrailingSlashTest cl = new TrailingSlashTest();\n+            cl.findClass(\"oldSlashClass\");\n+            throw new RuntimeException(\"Expected exception not thrown\");\n+        } catch (ClassFormatError e) {\n+            if (!e.getMessage().contains(\"Illegal class name\")) {\n+               throw new RuntimeException(\"Wrong ClassFormatError exception: \" + e.getMessage());\n+            }\n+        }\n+    }\n+\n+\n+    \/\/ This byte array comprises the compiled bytes of the following class.  Note that the class's\n+    \/\/ name ends in a '\/' and has a class file version of 45.3.\n+    \/*\n+        package has;\n+        public class slashe\/ { }\n+    *\/\n+    public static byte[] oldSlashClass = {\n+        (byte) 0xca, (byte) 0xfe, (byte) 0xba, (byte) 0xbe, (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0x2d,\n+        (byte) 0x0, (byte) 0xd, (byte) 0xa, (byte) 0x0, (byte) 0x2, (byte) 0x0, (byte) 0x3, (byte) 0x7,\n+        (byte) 0x0, (byte) 0x4, (byte) 0xc, (byte) 0x0, (byte) 0x5, (byte) 0x0, (byte) 0x6, (byte) 0x1,\n+        (byte) 0x0, (byte) 0x10, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x2f, (byte) 0x6c,\n+        (byte) 0x61, (byte) 0x6e, (byte) 0x67, (byte) 0x2f, (byte) 0x4f, (byte) 0x62, (byte) 0x6a, (byte) 0x65,\n+        (byte) 0x63, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x6, (byte) 0x3c, (byte) 0x69, (byte) 0x6e,\n+        (byte) 0x69, (byte) 0x74, (byte) 0x3e, (byte) 0x1, (byte) 0x0, (byte) 0x3, (byte) 0x28, (byte) 0x29,\n+        (byte) 0x56, (byte) 0x7, (byte) 0x0, (byte) 0x8, (byte) 0x1, (byte) 0x0, (byte) 0xb, (byte) 0x68,\n+        (byte) 0x61, (byte) 0x73, (byte) 0x2f, (byte) 0x73, (byte) 0x6c, (byte) 0x61, (byte) 0x73, (byte) 0x68,\n+        (byte) 0x65, (byte) 0x2f, (byte) 0x1, (byte) 0x0, (byte) 0x4, (byte) 0x43, (byte) 0x6f, (byte) 0x64,\n+        (byte) 0x65, (byte) 0x1, (byte) 0x0, (byte) 0xf, (byte) 0x4c, (byte) 0x69, (byte) 0x6e, (byte) 0x65,\n+        (byte) 0x4e, (byte) 0x75, (byte) 0x6d, (byte) 0x62, (byte) 0x65, (byte) 0x72, (byte) 0x54, (byte) 0x61,\n+        (byte) 0x62, (byte) 0x6c, (byte) 0x65, (byte) 0x1, (byte) 0x0, (byte) 0xa, (byte) 0x53, (byte) 0x6f,\n+        (byte) 0x75, (byte) 0x72, (byte) 0x63, (byte) 0x65, (byte) 0x46, (byte) 0x69, (byte) 0x6c, (byte) 0x65,\n+        (byte) 0x1, (byte) 0x0, (byte) 0xc, (byte) 0x73, (byte) 0x6c, (byte) 0x61, (byte) 0x73, (byte) 0x68,\n+        (byte) 0x65, (byte) 0x73, (byte) 0x2e, (byte) 0x6a, (byte) 0x61, (byte) 0x76, (byte) 0x61, (byte) 0x0,\n+        (byte) 0x21, (byte) 0x0, (byte) 0x7, (byte) 0x0, (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+        (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x5, (byte) 0x0,\n+        (byte) 0x6, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x9, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+        (byte) 0x1d, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+        (byte) 0x5, (byte) 0x2a, (byte) 0xb7, (byte) 0x0, (byte) 0x1, (byte) 0xb1, (byte) 0x0, (byte) 0x0,\n+        (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0xa, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6,\n+        (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0x1,\n+        (byte) 0x0, (byte) 0xb, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2, (byte) 0x0, (byte) 0xc,\n+    };\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/classFileParserBug\/TrailingSlashTest.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,1 @@\n-        if (!initWatchers(MyList.class, MyList.class.getDeclaredField(\"items\"))) {\n+        if (!initWatchers(MyList.class, MyList.class.getDeclaredField(\"items\"), Thread.currentThread())) {\n@@ -134,1 +134,1 @@\n-    private static native boolean initWatchers(Class cls, Field field);\n+    private static native boolean initWatchers(Class cls, Field field, Thread testThread);\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/FieldAccessWatch\/FieldAccessWatch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+static jthread testThread = NULL;\n@@ -49,0 +50,1 @@\n+    jthread thread,\n@@ -67,0 +69,4 @@\n+    if (!(*jni_env)->IsSameObject(jni_env, thread, testThread)) {\n+        return; \/\/ skip events from unexpected threads\n+    }\n+\n@@ -182,1 +188,1 @@\n-    handleNotification(jni_env, method, field, field_klass, 0, location);\n+    handleNotification(jni_env, thread, method, field, field_klass, 0, location);\n@@ -198,1 +204,1 @@\n-    handleNotification(jni_env, method, field, field_klass, 1, location);\n+    handleNotification(jni_env, thread, method, field, field_klass, 1, location);\n@@ -254,1 +260,1 @@\n-Java_FieldAccessWatch_initWatchers(JNIEnv *env, jclass thisClass, jclass cls, jobject field)\n+Java_FieldAccessWatch_initWatchers(JNIEnv *env, jclass thisClass, jclass cls, jobject field, jthread thread)\n@@ -278,0 +284,2 @@\n+    testThread = (jthread)(*env)->NewGlobalRef(env, thread);\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/FieldAccessWatch\/libFieldAccessWatch.c","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- *     of invocations (which is 10 times that crucial depth just measured).\n+ *     of invocations (which is 100 times that crucial depth just measured).\n@@ -106,1 +106,1 @@\n-        for (depthToTry = 0; ; depthToTry += STEP)\n+        for (depthToTry = 0; ; depthToTry += STEP) {\n@@ -120,0 +120,6 @@\n+        }\n+\n+        if (maxDepth == 0) {\n+            \/\/ The depth STEP was enough to cause StackOverflowError or OutOfMemoryError.\n+            maxDepth = STEP;\n+        }\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/stack\/stack018.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-sun\/tools\/jstatd sun\/tools\/jcmd \\\n-sun\/tools\/jinfo sun\/tools\/jmap sun\/tools\/jps sun\/tools\/jstack sun\/tools\/jstat \\\n-com\/sun\/tools\/attach sun\/security\/mscapi java\/util\/Arrays\/largeMemory \\\n+sun\/tools\/jstatd sun\/security\/mscapi java\/util\/Arrays\/largeMemory \\\n","filename":"test\/jdk\/TEST.ROOT","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -388,3 +388,6 @@\n-    :jdk_awt \\\n-    :jdk_2d \\\n-    :jdk_beans \\\n+    :jdk_desktop_part1 \\\n+    :jdk_desktop_part2 \\\n+    :jdk_desktop_part3\n+\n+jdk_desktop_part1 = \\\n+    :jdk_client_sanity \\\n@@ -392,0 +395,1 @@\n+    :jdk_2d \\\n@@ -394,1 +398,1 @@\n-    :jdk_accessibility \\\n+    :jdk_editpad \\\n@@ -396,2 +400,15 @@\n-    :jdk_client_sanity \\\n-    :jdk_editpad\n+    :jdk_accessibility \\\n+    :jdk_beans\n+\n+jdk_desktop_part2 = \\\n+    :jdk_awt \\\n+    -java\/awt\/Component \\\n+    -java\/awt\/Modal \\\n+    -java\/awt\/datatransfer \\\n+    -java\/awt\/Window\n+\n+jdk_desktop_part3 = \\\n+    java\/awt\/Component \\\n+    java\/awt\/Modal \\\n+    java\/awt\/datatransfer \\\n+    java\/awt\/Window\n","filename":"test\/jdk\/TEST.groups","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -261,1 +261,1 @@\n-                    throw new Exception(\"To do incrementalSegments you must\" +\n+                    throw new Exception(\"To do incrementalSegments you must \" +\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMBufferTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-                \"doFinal() return ( \" + r + \") is not the same\" +\n+                \"doFinal() return ( \" + r + \") is not the same \" +\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/AEAD\/GCMShortBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8278312\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient \/test\/jdk\/java\/net\/httpclient\/http2\/server\n+ * @build jdk.test.lib.net.SimpleSSLContext HttpServerAdapters Http2Handler\n+ *          jdk.test.lib.net.IPSupport\n+ *          Http2TestExchange\n+ *\n+ * @modules java.net.http\/jdk.internal.net.http.common\n+ *          java.net.http\/jdk.internal.net.http.frame\n+ *          java.net.http\/jdk.internal.net.http.hpack\n+ *          java.logging\n+ *          java.base\/sun.net.www.http\n+ *          java.base\/sun.net.www\n+ *          java.base\/sun.net\n+ *\n+ * @run main\/othervm SANTest\n+ * @summary Update SimpleSSLContext keystore to use SANs for localhost IP addresses\n+ *\/\n+\n+import com.sun.net.httpserver.*;\n+\n+import java.util.concurrent.*;\n+import java.io.*;\n+import java.net.*;\n+import java.net.http.*;\n+import java.nio.charset.StandardCharsets;\n+import javax.net.ssl.*;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import jdk.test.lib.net.IPSupport;\n+\n+\/*\n+ * Will fail if the testkeys file belonging to SimpleSSLContext\n+ * does not have SAN entries for 127.0.0.1 or ::1\n+ *\/\n+public class SANTest implements HttpServerAdapters {\n+\n+    static SSLContext ctx;\n+\n+    static HttpServer getHttpsServer(InetSocketAddress addr, Executor exec, SSLContext ctx) throws Exception {\n+        HttpsServer server = HttpsServer.create(addr, 0);\n+        server.setExecutor(exec);\n+        server.setHttpsConfigurator(new HttpsConfigurator (ctx));\n+        return server;\n+    }\n+\n+    static final boolean hasIPv4 = IPSupport.hasIPv4();\n+    static final boolean hasIPv6 = IPSupport.hasIPv6();\n+\n+    static HttpTestServer initServer(boolean h2, InetAddress addr, SSLContext ctx,\n+                String sni, ExecutorService e) throws Exception {\n+        HttpTestServer s = null;\n+        InetSocketAddress ia = new InetSocketAddress (addr, 0);\n+        if ((addr instanceof Inet4Address) && !hasIPv4)\n+                return null;\n+        if ((addr instanceof Inet6Address) && !hasIPv6)\n+                return null;\n+\n+        if (!h2) {\n+            s = HttpTestServer.of(getHttpsServer(ia, e, ctx));\n+            HttpTestHandler h = new HttpTestEchoHandler();\n+            s.addHandler(h, \"\/test1\");\n+            s.start();\n+            return s;\n+        } else {\n+            s = HttpTestServer.of(new Http2TestServer(addr, sni, true, 0, e,\n+                        10, null, ctx, false));\n+            HttpTestHandler h = new HttpTestEchoHandler();\n+            s.addHandler(h, \"\/test1\");\n+            s.start();\n+            return s;\n+        }\n+    }\n+\n+    public static void main (String[] args) throws Exception {\n+        \/\/ Http\/1.1 servers\n+        HttpTestServer h1s1 = null;\n+        HttpTestServer h1s2 = null;\n+\n+        \/\/ Http\/2 servers\n+        HttpTestServer h2s1 = null;\n+        HttpTestServer h2s2 = null;\n+\n+        ExecutorService executor=null;\n+        try {\n+            System.out.print (\"SANTest: \");\n+            ctx = new SimpleSSLContext().get();\n+            executor = Executors.newCachedThreadPool();\n+\n+            InetAddress l1 = InetAddress.getByName(\"::1\");\n+            InetAddress l2 = InetAddress.getByName(\"127.0.0.1\");\n+\n+            h1s1 = initServer(false, l1, ctx, \"::1\", executor);\n+            h1s2 = initServer(false, l2, ctx, \"127.0.0.1\", executor);\n+\n+            h2s1 = initServer(true, l1, ctx, \"::1\", executor);\n+            h2s2 = initServer(true, l2, ctx, \"127.0.0.1\", executor);\n+\n+            test(\"127.0.0.1\", h1s2);\n+            test(\"::1\", h1s1);\n+            testNew(\"127.0.0.1\", h2s2, executor);\n+            testNew(\"::1\", h2s1, executor);\n+            System.out.println (\"OK\");\n+        } finally {\n+            if (h1s1 != null)\n+                h1s1.stop();\n+            if (h1s2 != null)\n+                h1s2.stop();\n+            if (h2s1 != null)\n+                h2s1.stop();\n+            if (h2s2 != null)\n+                h2s2.stop();\n+            if (executor != null)\n+                executor.shutdown ();\n+        }\n+    }\n+\n+    static void test (String host, HttpTestServer server) throws Exception {\n+        if (server == null)\n+            return;\n+        int port = server.getAddress().getPort();\n+        String body = \"Yellow world\";\n+        URL url = URIBuilder.newBuilder()\n+                 .scheme(\"https\")\n+                 .host(host)\n+                 .port(port)\n+                 .path(\"\/test1\/foo.txt\")\n+                 .toURL();\n+        System.out.println(\"URL = \" + url);\n+        HttpURLConnection urlc = (HttpURLConnection) url.openConnection(Proxy.NO_PROXY);\n+        System.out.println(\"urlc = \" + urlc);\n+        if (urlc instanceof HttpsURLConnection) {\n+            HttpsURLConnection urlcs = (HttpsURLConnection) urlc;\n+            urlcs.setSSLSocketFactory (ctx.getSocketFactory());\n+        }\n+\n+        urlc.setRequestMethod(\"POST\");\n+        urlc.setDoOutput(true);\n+\n+        OutputStream os = urlc.getOutputStream();\n+        os.write(body.getBytes(StandardCharsets.ISO_8859_1));\n+        os.close();\n+        InputStream is = urlc.getInputStream();\n+        byte[] vv = is.readAllBytes();\n+        String ff = new String(vv, StandardCharsets.ISO_8859_1);\n+        System.out.println(\"resp = \" + ff);\n+        if (!ff.equals(body))\n+            throw new RuntimeException();\n+        is.close();\n+    }\n+\n+    static void testNew (String host, HttpTestServer server, Executor exec) throws Exception {\n+        if (server == null)\n+            return;\n+        int port = server.getAddress().getPort();\n+        String body = \"Red and Yellow world\";\n+        URI uri = URIBuilder.newBuilder()\n+                 .scheme(\"https\")\n+                 .host(host)\n+                 .port(port)\n+                 .path(\"\/test1\/foo.txt\")\n+                 .build();\n+\n+        HttpClient client = HttpClient.newBuilder()\n+                .sslContext(ctx)\n+                .executor(exec)\n+                .build();\n+        HttpRequest req = HttpRequest.newBuilder(uri)\n+                .version(HttpClient.Version.HTTP_2)\n+                .POST(HttpRequest.BodyPublishers.ofString(body))\n+                .build();\n+\n+        HttpResponse<String> resp = client.send(req, HttpResponse.BodyHandlers.ofString());\n+        System.out.println(\"resp = \" + resp.body());\n+        if (!resp.body().equals(body))\n+            throw new RuntimeException();\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/net\/httpserver\/SANTest.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8204931 8227392 8224825 8233910\n+ * @bug 8204931 8227392 8224825 8233910 8275843\n","filename":"test\/jdk\/java\/awt\/ColorClass\/AlphaColorTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,1 @@\n+\n@@ -27,1 +28,1 @@\n- * @bug      8176795\n+ * @bug      8176795 8275843\n@@ -30,2 +31,2 @@\n- * @requires (os.family == \"linux\")\n- * @run      main XRenderTranslucentColorDrawTest -Dsun.java2d.xrender=true\n+ * @run      main\/othervm XRenderTranslucentColorDrawTest\n+ * @run      main\/othervm -Dsun.java2d.xrender=true XRenderTranslucentColorDrawTest\n@@ -39,0 +40,1 @@\n+import java.awt.Transparency;\n@@ -44,5 +46,3 @@\n-    public static void main(String[] args) throws Exception {\n-        GraphicsEnvironment env = GraphicsEnvironment.\n-                getLocalGraphicsEnvironment();\n-        GraphicsConfiguration translucentGC = null;\n-        SCREENS: for (GraphicsDevice screen : env.getScreenDevices()) {\n+    public static void main(String[] args) {\n+        var env = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        for (GraphicsDevice screen : env.getScreenDevices()) {\n@@ -50,4 +50,3 @@\n-                if (gc.isTranslucencyCapable()) {\n-                    translucentGC = gc;\n-                    break SCREENS;\n-                }\n+                test(gc, Transparency.OPAQUE);\n+                test(gc, Transparency.BITMASK);\n+                test(gc, Transparency.TRANSLUCENT);\n@@ -56,3 +55,3 @@\n-        if (translucentGC == null) {\n-            throw new RuntimeException(\"No suitable gc found.\");\n-        }\n+    }\n+\n+    private static void test(GraphicsConfiguration gc, int transparency) {\n@@ -61,2 +60,2 @@\n-        VolatileImage image = translucentGC.\n-                createCompatibleVolatileImage(width, height);\n+        VolatileImage image = gc.createCompatibleVolatileImage(width, height,\n+                                                               transparency);\n@@ -75,3 +74,4 @@\n-        if (!(Integer.toHexString(argb).equals(\"ff808080\"))) {\n-            throw new RuntimeException(\"Using X Render extension for drawing\"\n-                    + \" translucent color is not giving expected results.\");\n+        String actual = Integer.toHexString(argb);\n+        if (!(actual.equals(\"ff808080\"))) {\n+            throw new RuntimeException(\"Drawing translucent color is not \" +\n+                                       \"giving expected results: \" + actual);\n@@ -80,2 +80,1 @@\n-}\n-\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/ColorClass\/XRenderTranslucentColorDrawTest.java","additions":22,"deletions":23,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Frame;\n+import java.awt.Graphics2D;\n+import java.awt.GraphicsConfiguration;\n+import java.awt.GraphicsDevice;\n+import java.awt.GraphicsEnvironment;\n+import java.awt.Image;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DataBufferInt;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.WritableRaster;\n+import java.util.Arrays;\n+\n+\/**\n+ * @test\n+ * @bug 8275843\n+ * @key headful\n+ * @summary No exception or errors should occur.\n+ *\/\n+public final class DrawCustomColorModel {\n+\n+    public static void main(String[] args) {\n+        var ge = GraphicsEnvironment.getLocalGraphicsEnvironment();\n+        for (GraphicsDevice gd : ge.getScreenDevices()) {\n+            GraphicsConfiguration[] gcs = gd.getConfigurations();\n+            for (GraphicsConfiguration gc : gcs) {\n+                test(gc);\n+            }\n+        }\n+    }\n+\n+    private static void test(GraphicsConfiguration gc) {\n+        Frame frame = new Frame(gc);\n+        frame.setUndecorated(true);\n+        frame.pack();\n+        frame.setSize(15, 15);\n+        ColorModel cm = new DirectColorModel(32,\n+                                             0xff000000, \/\/ Red\n+                                             0x00ff0000, \/\/ Green\n+                                             0x0000ff00, \/\/ Blue\n+                                             0x000000FF  \/\/ Alpha\n+        );\n+        WritableRaster wr = cm.createCompatibleWritableRaster(16, 16);\n+        DataBufferInt buff = (DataBufferInt) wr.getDataBuffer();\n+        int[] data = buff.getData();\n+        Arrays.fill(data, -1); \/\/ more chance to reproduce\n+        Image image =  new BufferedImage(cm, wr, false, null);\n+\n+        Graphics2D graphics = (Graphics2D) frame.getGraphics();\n+        graphics.setComposite(AlphaComposite.Src);\n+        graphics.drawImage(image, 0, 0, null);\n+        graphics.dispose();\n+        frame.dispose();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/image\/ColorModel\/DrawCustomColorModel.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.WeakReference;\n+import java.io.ObjectStreamClass;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng\/othervm -Xmx10m -XX:SoftRefLRUPolicyMSPerMB=1 ObjectStreamClassCaching\n+ *\/\n+public class ObjectStreamClassCaching {\n+\n+    @Test\n+    public void testCachingEffectiveness() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        System.gc();\n+        Thread.sleep(100L);\n+        \/\/ to trigger any ReferenceQueue processing...\n+        lookupObjectStreamClass(AnotherTestClass.class);\n+        assertFalse(ref.refersTo(null),\n+                    \"Cache lost entry although memory was not under pressure\");\n+    }\n+\n+    @Test\n+    public void testCacheReleaseUnderMemoryPressure() throws Exception {\n+        var ref = lookupObjectStreamClass(TestClass.class);\n+        pressMemoryHard(ref);\n+        System.gc();\n+        Thread.sleep(100L);\n+        assertTrue(ref.refersTo(null),\n+                   \"Cache still has entry although memory was pressed hard\");\n+    }\n+\n+    \/\/ separate method so that the looked-up ObjectStreamClass is not kept on stack\n+    private static WeakReference<?> lookupObjectStreamClass(Class<?> cl) {\n+        return new WeakReference<>(ObjectStreamClass.lookup(cl));\n+    }\n+\n+    private static void pressMemoryHard(Reference<?> ref) {\n+        try {\n+            var list = new ArrayList<>();\n+            while (!ref.refersTo(null)) {\n+                list.add(new byte[1024 * 1024 * 64]); \/\/ 64 MiB chunks\n+            }\n+        } catch (OutOfMemoryError e) {\n+            \/\/ release\n+        }\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+}\n+\n+class AnotherTestClass implements Serializable {\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/ObjectStreamClassCaching.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.ref.WeakReference;\n+import java.lang.reflect.Constructor;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.ObjectStreamClass;\n+import java.io.ObjectStreamField;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertNotNull;\n+import static org.testng.Assert.assertTrue;\n+\n+import jdk.test.lib.util.ForceGC;\n+\n+\/* @test\n+ * @bug 8277072\n+ * @library \/test\/lib\/\n+ * @build jdk.test.lib.util.ForceGC\n+ * @summary ObjectStreamClass caches keep ClassLoaders alive\n+ * @run testng TestOSCClassLoaderLeak\n+ *\/\n+public class TestOSCClassLoaderLeak {\n+\n+    @Test\n+    public void testClassLoaderLeak() throws Exception {\n+        TestClassLoader myOwnClassLoader = new TestClassLoader();\n+        Class<?> loadClass = myOwnClassLoader.loadClass(\"ObjectStreamClass_MemoryLeakExample\");\n+        Constructor con = loadClass.getConstructor();\n+        con.setAccessible(true);\n+        Object objectStreamClass_MemoryLeakExample = con.newInstance();\n+        objectStreamClass_MemoryLeakExample.toString();\n+\n+        WeakReference<Object> myOwnClassLoaderWeakReference = new WeakReference<>(myOwnClassLoader);\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+        objectStreamClass_MemoryLeakExample = null;\n+        myOwnClassLoader = null;\n+        loadClass = null;\n+        con = null;\n+        assertNotNull(myOwnClassLoaderWeakReference.get());\n+\n+        ForceGC gc = new ForceGC();\n+        assertTrue(gc.await(() -> myOwnClassLoaderWeakReference.get() == null));\n+    }\n+}\n+\n+class ObjectStreamClass_MemoryLeakExample {\n+    private static final ObjectStreamField[] fields = ObjectStreamClass.lookup(TestClass.class).getFields();\n+    public ObjectStreamClass_MemoryLeakExample() {\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return Arrays.toString(fields);\n+    }\n+}\n+\n+class TestClassLoader extends ClassLoader {\n+\n+    @Override\n+    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+        if (name.equals(\"TestClass\") || name.equals(\"ObjectStreamClass_MemoryLeakExample\")) {\n+            byte[] bt = loadClassData(name);\n+            return defineClass(name, bt, 0, bt.length);\n+        } else {\n+            return super.loadClass(name);\n+        }\n+    }\n+\n+    private static byte[] loadClassData(String className) {\n+        ByteArrayOutputStream byteSt = new ByteArrayOutputStream();\n+        try (InputStream is = TestClassLoader.class.getClassLoader().getResourceAsStream(className.replace(\".\", \"\/\") + \".class\")) {\n+            int len = 0;\n+            while ((len = is.read()) != -1) {\n+                byteSt.write(len);\n+            }\n+        } catch (java.io.IOException e) {\n+            e.printStackTrace();\n+        }\n+        return byteSt.toByteArray();\n+    }\n+}\n+\n+class TestClass implements Serializable {\n+    public String x;\n+}\n","filename":"test\/jdk\/java\/io\/ObjectStreamClass\/TestOSCClassLoaderLeak.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -127,0 +127,14 @@\n+    public Http2TestServer(String serverName,\n+                           boolean secure,\n+                           int port,\n+                           ExecutorService exec,\n+                           int backlog,\n+                           Properties properties,\n+                           SSLContext context,\n+                           boolean supportsHTTP11)\n+        throws Exception\n+    {\n+        this(InetAddress.getLoopbackAddress(), serverName, secure, port, exec,\n+                backlog, properties, context, supportsHTTP11);\n+    }\n+\n@@ -137,0 +151,1 @@\n+     * @param localAddr local address to bind to\n@@ -149,1 +164,2 @@\n-    public Http2TestServer(String serverName,\n+    public Http2TestServer(InetAddress localAddr,\n+                           String serverName,\n@@ -166,1 +182,1 @@\n-            server = initSecure(port, backlog);\n+            server = initSecure(localAddr, port, backlog);\n@@ -239,1 +255,1 @@\n-    final ServerSocket initSecure(int port, int backlog) throws Exception {\n+    final ServerSocket initSecure(InetAddress localAddr, int port, int backlog) throws Exception {\n@@ -246,1 +262,1 @@\n-        se.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), backlog);\n+        se.bind(new InetSocketAddress(localAddr, 0), backlog);\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/server\/Http2TestServer.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -37,0 +37,3 @@\n+ * @library \/javax\/swing\/regtesthelpers\n+ * @build Util\n+ * @run main\/timeout=60\/othervm -mx32m FlushCustomClassLoader\n@@ -45,6 +48,2 @@\n-            if (++attempt > 10) {\n-                throw new RuntimeException(\"Too many attempts: \" + attempt);\n-            }\n-            System.gc();\n-            Thread.sleep(1000);\n-            System.out.println(\"Not freed, attempt: \" + attempt);\n+            Util.generateOOME();\n+            System.out.println(\"Not freed, attempt: \" + attempt++);\n","filename":"test\/jdk\/javax\/print\/PrintServiceLookup\/FlushCustomClassLoader.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.security.XMLUtils;\n+\n+import javax.xml.crypto.URIReferenceException;\n+import javax.xml.crypto.dsig.XMLSignatureException;\n+import java.security.KeyPair;\n+import java.security.KeyPairGenerator;\n+import java.security.spec.ECGenParameterSpec;\n+\n+\/**\n+ * @test\n+ * @bug 8278186\n+ * @summary reject malformed xpointer(id('a')) gracefully\n+ * @library \/test\/lib\n+ * @modules java.xml.crypto\n+ *\/\n+public class BadXPointer {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        KeyPairGenerator kpg = KeyPairGenerator.getInstance(\"EC\");\n+        kpg.initialize(new ECGenParameterSpec(\"secp256r1\"));\n+        KeyPair kp = kpg.generateKeyPair();\n+\n+        var signer = XMLUtils.signer(kp.getPrivate(), kp.getPublic());\n+        var doc = XMLUtils.string2doc(\"<root\/>\");\n+\n+        \/\/ No enclosing ' for id\n+        Utils.runAndCheckException(\n+                () -> signer.signEnveloping(doc, \"a\", \"#xpointer(id('a))\"),\n+                ex -> Asserts.assertTrue(ex instanceof XMLSignatureException\n+                        && ex.getCause() instanceof URIReferenceException\n+                        && ex.getMessage().contains(\"Could not find a resolver\"),\n+                    ex.toString()));\n+    }\n+}\n","filename":"test\/jdk\/javax\/xml\/crypto\/dsig\/BadXPointer.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -5518,1 +5518,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5518,1 +5518,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5518,1 +5518,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5518,1 +5518,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Byte64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4897,1 +4897,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4897,1 +4897,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4897,1 +4897,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4897,1 +4897,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Double64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4875,1 +4875,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4875,1 +4875,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4875,1 +4875,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4875,1 +4875,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Float64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5472,1 +5472,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5472,1 +5472,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5472,1 +5472,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5472,1 +5472,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Int64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5356,1 +5356,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5356,1 +5356,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5356,1 +5356,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5356,1 +5356,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Long64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5497,1 +5497,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short128VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5497,1 +5497,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short256VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5497,1 +5497,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short512VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5497,1 +5497,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/Short64VectorTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -502,1 +502,1 @@\n-        Assert.assertEquals(outputLong, inputLong & (((1L << (SPECIES.length() - 1)) << 1) - 1));\n+        Assert.assertEquals(outputLong, (inputLong & (((0xFFFFFFFFFFFFFFFFL >>> (64 - SPECIES.length()))))));\n","filename":"test\/jdk\/jdk\/incubator\/vector\/templates\/Unit-Miscellaneous.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n- *      8131067 8034802 8210899 8273961\n+ *      8131067 8034802 8210899 8273961 8271079\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/ZipFSTester.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8164389 8222440\n+ * @bug 8164389 8222440 8271079\n@@ -149,0 +149,54 @@\n+\n+    @Test\n+    public void testToUri() throws IOException {\n+        \/\/ treat multi-release jar as unversioned\n+        Map<String, String> env = new HashMap<>();\n+        Set<String> contents = doTestUri(env);\n+        Set<String> expectedContents = Set.of(\n+            \"!\/root\/dir1\/leaf1.txt\",\n+            \"!\/root\/dir1\/leaf2.txt\",\n+            \"!\/root\/dir2\/leaf3.txt\",\n+            \"!\/root\/dir2\/leaf4.txt\"\n+        );\n+        Assert.assertEquals(contents, expectedContents);\n+\n+        \/\/ open file as multi-release for version 9\n+        env.put(\"multi-release\", \"9\");\n+        contents = doTestUri(env);\n+        expectedContents = Set.of(\n+            \"!\/root\/dir1\/leaf1.txt\",\n+            \"!\/root\/dir1\/leaf2.txt\",\n+            \"!\/META-INF\/versions\/9\/root\/dir2\/leaf3.txt\",\n+            \"!\/META-INF\/versions\/9\/root\/dir2\/leaf4.txt\",\n+            \"!\/META-INF\/versions\/9\/root\/dir3\/leaf5.txt\",\n+            \"!\/META-INF\/versions\/9\/root\/dir3\/leaf6.txt\"\n+        );\n+        Assert.assertEquals(contents, expectedContents);\n+\n+        \/\/ open file as multi-release for version 10\n+        env.put(\"multi-release\", \"10\");\n+        contents = doTestUri(env);\n+        expectedContents = Set.of(\n+            \"!\/root\/dir1\/leaf1.txt\",\n+            \"!\/root\/dir1\/leaf2.txt\",\n+            \"!\/META-INF\/versions\/9\/root\/dir2\/leaf3.txt\",\n+            \"!\/META-INF\/versions\/9\/root\/dir2\/leaf4.txt\",\n+            \"!\/META-INF\/versions\/10\/root\/dir3\/leaf5.txt\",\n+            \"!\/META-INF\/versions\/10\/root\/dir3\/leaf6.txt\"\n+        );\n+        Assert.assertEquals(contents, expectedContents);\n+    }\n+\n+    private Set<String> doTestUri(Map<String,String> env) throws IOException {\n+        Set<String> contents;\n+        try (FileSystem fs = FileSystems.newFileSystem(jarURI, env)) {\n+            Path root = fs.getPath(\"root\");\n+            int prefix = root.toUri().toString().indexOf('!');\n+            contents = Files.walk(root)\n+                .filter(p -> !Files.isDirectory(p))\n+                .map(p ->  p.toUri().toString().substring(prefix))\n+                .sorted()\n+                .collect(Collectors.toSet());\n+        }\n+        return contents;\n+    }\n","filename":"test\/jdk\/jdk\/nio\/zipfs\/jarfs\/JFSTester.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -465,1 +465,1 @@\n-            .shouldContain(\"MAC: sha256, Iteration 10000\")\n+            .shouldContain(\"MAC:\").shouldContain(\"sha256\").shouldContain(\"Iteration 10000\")\n@@ -508,1 +508,1 @@\n-            .shouldContain(\"MAC: sha256, Iteration 5555\")\n+            .shouldContain(\"MAC:\").shouldContain(\"sha256\").shouldContain(\"Iteration 5555\")\n","filename":"test\/jdk\/sun\/security\/pkcs12\/KeytoolOpensslInteropTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-                throw new SecurityException(\"PrincipalExpansionError\" +\n+                throw new SecurityException(\"PrincipalExpansionError \" +\n","filename":"test\/jdk\/sun\/security\/provider\/PolicyParser\/PrincipalExpansionError.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8278560\n+ * @summary X509KeyManagerImpl::getAliases might return a good key with others\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.tools.keytool\n+ *          java.base\/sun.security.util\n+ *          java.base\/sun.security.x509\n+ *\/\n+import jdk.test.lib.Asserts;\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.util.KnownOIDs;\n+import sun.security.util.ObjectIdentifier;\n+import sun.security.x509.CertificateExtensions;\n+import sun.security.x509.ExtendedKeyUsageExtension;\n+import sun.security.x509.X500Name;\n+\n+import java.io.*;\n+import java.security.*;\n+import java.security.cert.Certificate;\n+import java.util.Date;\n+import java.util.Vector;\n+import javax.net.ssl.*;\n+\n+public class NoGoodKey {\n+    public static void main(String[] args) throws Exception {\n+\n+        PrintStream oldErr = System.err;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+\n+        CertificateExtensions exts = new CertificateExtensions();\n+        Vector<ObjectIdentifier> xku = new Vector<>(1);\n+        xku.add(ObjectIdentifier.of(KnownOIDs.KP_TimeStamping));\n+        var ext = new ExtendedKeyUsageExtension(xku);\n+        exts.set(ext.getId(), ext);\n+\n+        KeyStore ks = KeyStore.getInstance(\"pkcs12\");\n+        char[] pass = \"password\".toCharArray();\n+        ks.load(null, null);\n+\n+        CertAndKeyGen ckg;\n+\n+        \/\/ This is for the first keyType but wrong extendedKeyUsage\n+        ckg = new CertAndKeyGen(\"EC\", \"SHA256withECDSA\");\n+        ckg.generate(\"secp256r1\");\n+        ks.setKeyEntry(\"a\", ckg.getPrivateKey(), pass, new java.security.cert.Certificate[]\n+                { ckg.getSelfCertificate(new X500Name(\"CN=user\"), new Date(), 10000, exts) });\n+\n+        \/\/ This is for the 2nd keyType and is perfect\n+        ckg = new CertAndKeyGen(\"RSA\", \"SHA256withRSA\");\n+        ckg.generate(2048);\n+        ks.setKeyEntry(\"b\", ckg.getPrivateKey(), pass, new Certificate[]\n+                { ckg.getSelfCertificate(new X500Name(\"CN=user\"), 10000) });\n+\n+        try {\n+            System.setProperty(\"javax.net.debug\", \"keymanager\");\n+            System.setErr(new PrintStream(bout));\n+            var kmf = KeyManagerFactory.getInstance(\"NewSunX509\");\n+            kmf.init(ks, pass);\n+            var km = (X509ExtendedKeyManager) kmf.getKeyManagers()[0];\n+\n+            \/\/ b will be chosen anyway\n+            Asserts.assertEQ(km.chooseClientAlias(new String[]{\"EC\", \"RSA\"}, null, null), \"1.0.b\");\n+        } finally {\n+            System.setErr(oldErr);\n+        }\n+\n+        \/\/ make sure it's chosen as good matching key\n+        String log = bout.toString();\n+        Asserts.assertFalse(log.contains(\"no good matching key found\"), log);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509KeyManager\/NoGoodKey.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-                        \"for TLS connections.  Please rethink about the size\" +\n+                        \"for TLS connections.  Please rethink about the size \" +\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/CacertsLimit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-                    \"has been patched. Key size \" + keySize +\n+                    \" has been patched. Key size \" + keySize +\n","filename":"test\/jdk\/sun\/security\/tools\/keytool\/fakegen\/jdk.crypto.ec\/sun\/security\/ec\/ECKeyPairGenerator.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,2 @@\n-    public static void printStackTraces(String file) throws IOException {\n+    \/* Returns false if the attempt should be retried. *\/\n+    public static boolean printStackTraces(String file, boolean allowRetry) throws IOException {\n@@ -107,1 +108,10 @@\n-                throw new RuntimeException(\"'JShellToolProvider' missing from stdout\/stderr\");\n+                \/\/ This check will very rarely fail due to not be able to get the stack trace\n+                \/\/ of the main thread do to it actively executing. See JDK-8269556. We retry once\n+                \/\/ if that happens. This failure is so rare that this should be enough to make it\n+                \/\/ extremely unlikely that we ever see this test fail again for this reason.\n+                if (!allowRetry) {\n+                    throw new RuntimeException(\"'JShellToolProvider' missing from stdout\/stderr\");\n+                } else {\n+                    System.out.println(\"'JShellToolProvider' missing. Allow one retry.\");\n+                    return true; \/\/ Allow one retry\n+                }\n@@ -112,0 +122,1 @@\n+        return false;\n@@ -114,1 +125,2 @@\n-    public static void testHeapDump() throws IOException {\n+    \/* Returns false if the attempt should be retried. *\/\n+    public static boolean testHeapDump(boolean allowRetry) throws IOException {\n@@ -127,1 +139,1 @@\n-        printStackTraces(hprofFile.getAbsolutePath());\n+        boolean retry = printStackTraces(hprofFile.getAbsolutePath(), allowRetry);\n@@ -131,0 +143,2 @@\n+\n+        return retry;\n@@ -152,1 +166,1 @@\n-                Thread.sleep(2000);\n+                Thread.sleep(4000);\n@@ -169,1 +183,6 @@\n-        testHeapDump();\n+\n+        boolean retry = testHeapDump(true);\n+        \/\/ In case of rare failure to find 'JShellToolProvider' in the output, allow one retry.\n+        if (retry) {\n+            testHeapDump(false);\n+        }\n","filename":"test\/jdk\/sun\/tools\/jhsdb\/JShellHeapDumpTest.java","additions":26,"deletions":7,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,290 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8276766\n+ * @summary Test jar --date source date of entries and that jars are\n+ *          reproducible\n+ * @modules jdk.jartool\n+ * @run testng\/othervm ReproducibleJar\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.nio.file.Files;\n+import java.nio.file.attribute.FileTime;\n+import java.util.Date;\n+import java.util.TimeZone;\n+import java.util.spi.ToolProvider;\n+import java.time.LocalDateTime;\n+import java.time.ZonedDateTime;\n+import java.time.ZoneId;\n+import java.time.ZoneOffset;\n+import java.time.format.DateTimeFormatter;\n+import java.time.Instant;\n+import java.util.concurrent.TimeUnit;\n+\n+public class ReproducibleJar {\n+    private static final ToolProvider JAR_TOOL = ToolProvider.findFirst(\"jar\")\n+            .orElseThrow(() ->\n+                    new RuntimeException(\"jar tool not found\")\n+            );\n+\n+    \/\/ ZipEntry's mod date has 2 seconds precision: give extra time to\n+    \/\/ allow for e.g. rounding\/truncation and networked\/samba drives.\n+    private static final long PRECISION = 10000L;\n+\n+    private static final TimeZone TZ = TimeZone.getDefault();\n+    private static final boolean DST = TZ.inDaylightTime(new Date());\n+    private static final String UNIX_2038_ROLLOVER_TIME = \"2038-01-19T03:14:07Z\";\n+    private static final Instant UNIX_2038_ROLLOVER = Instant.parse(UNIX_2038_ROLLOVER_TIME);\n+    private static final File DIR_OUTER = new File(\"outer\");\n+    private static final File DIR_INNER = new File(DIR_OUTER, \"inner\");\n+    private static final File FILE_INNER = new File(DIR_INNER, \"foo.txt\");\n+    private static final File JAR_FILE_SOURCE_DATE1 = new File(\"JarEntryTimeSourceDate1.jar\");\n+    private static final File JAR_FILE_SOURCE_DATE2 = new File(\"JarEntryTimeSourceDate2.jar\");\n+\n+    \/\/ Valid --date values for jar\n+    @DataProvider\n+    private Object[][] validSourceDates() {\n+        return new Object[][]{\n+                {\"1980-01-01T00:00:02+00:00\"},\n+                {\"1986-06-24T01:02:03+00:00\"},\n+                {\"2022-03-15T00:00:00+00:00\"},\n+                {\"2022-03-15T00:00:00+06:00\"},\n+                {\"2021-12-25T09:30:00-08:00[America\/Los_Angeles]\"},\n+                {\"2021-12-31T23:59:59Z\"},\n+                {\"2024-06-08T14:24Z\"},\n+                {\"2026-09-24T16:26-05:00\"},\n+                {\"2038-11-26T06:06:06+00:00\"},\n+                {\"2098-02-18T00:00:00-08:00\"},\n+                {\"2099-12-31T23:59:59+00:00\"}\n+        };\n+    }\n+\n+    \/\/ Invalid --date values for jar\n+    @DataProvider\n+    private Object[][] invalidSourceDates() {\n+        return new Object[][]{\n+                {\"1976-06-24T01:02:03+00:00\"},\n+                {\"1980-01-01T00:00:01+00:00\"},\n+                {\"2100-01-01T00:00:00+00:00\"},\n+                {\"2138-02-18T00:00:00-11:00\"},\n+                {\"2006-04-06T12:38:00\"},\n+                {\"2012-08-24T16\"}\n+        };\n+    }\n+\n+    @BeforeMethod\n+    public void runBefore() throws IOException {\n+        runAfter();\n+        createOuterInnerDirs();\n+    }\n+\n+    @AfterMethod\n+    public void runAfter() {\n+        cleanup(DIR_INNER);\n+        cleanup(DIR_OUTER);\n+        JAR_FILE_SOURCE_DATE1.delete();\n+        JAR_FILE_SOURCE_DATE2.delete();\n+        TimeZone.setDefault(TZ);\n+    }\n+\n+    \/**\n+     * Test jar tool with various valid --date <timestamps>\n+     *\/\n+    @Test(dataProvider = \"validSourceDates\")\n+    public void testValidSourceDate(String sourceDate) {\n+        if (isInTransition()) return;\n+\n+        \/\/ Test --date source date\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+        Assert.assertTrue(JAR_FILE_SOURCE_DATE1.exists());\n+\n+        \/\/ Extract JAR_FILE_SOURCE_DATE1 and check last modified values\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--extract\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName()), 0);\n+        Assert.assertTrue(DIR_OUTER.exists());\n+        Assert.assertTrue(DIR_INNER.exists());\n+        Assert.assertTrue(FILE_INNER.exists());\n+        LocalDateTime expectedLdt = ZonedDateTime.parse(sourceDate,\n+                        DateTimeFormatter.ISO_DATE_TIME)\n+                .withZoneSameInstant(ZoneOffset.UTC)\n+                .toLocalDateTime();\n+        System.out.format(\"Checking jar entries local date time for --date %s, is %s%n\",\n+                sourceDate, expectedLdt);\n+        long sourceDateEpochMillis = TimeUnit.MILLISECONDS.convert(\n+                expectedLdt.toEpochSecond(ZoneId.systemDefault().getRules()\n+                        .getOffset(expectedLdt)), TimeUnit.SECONDS);\n+        checkFileTime(DIR_OUTER.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(DIR_INNER.lastModified(), sourceDateEpochMillis);\n+        checkFileTime(FILE_INNER.lastModified(), sourceDateEpochMillis);\n+    }\n+\n+    \/**\n+     * Test jar tool with various invalid --date <timestamps>\n+     *\/\n+    @Test(dataProvider = \"invalidSourceDates\")\n+    public void testInvalidSourceDate(String sourceDate) {\n+        \/\/ Negative Tests --date out of range or wrong format source date\n+        Assert.assertNotEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+    }\n+\n+    \/**\n+     * Test jar produces deterministic reproducible output\n+     *\/\n+    @Test(dataProvider = \"validSourceDates\")\n+    public void testJarsReproducible(String sourceDate) throws IOException {\n+        \/\/ Test jars are reproducible across timezones\n+        TimeZone tzAsia = TimeZone.getTimeZone(\"Asia\/Shanghai\");\n+        TimeZone tzLA = TimeZone.getTimeZone(\"America\/Los_Angeles\");\n+        TimeZone.setDefault(tzAsia);\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE1.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+        Assert.assertTrue(JAR_FILE_SOURCE_DATE1.exists());\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure jar timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch (InterruptedException ex) {\n+        }\n+\n+        TimeZone.setDefault(tzLA);\n+        Assert.assertEquals(JAR_TOOL.run(System.out, System.err,\n+                \"--create\",\n+                \"--file\", JAR_FILE_SOURCE_DATE2.getName(),\n+                \"--date\", sourceDate,\n+                DIR_OUTER.getName()), 0);\n+        Assert.assertTrue(JAR_FILE_SOURCE_DATE2.exists());\n+\n+        \/\/ Check jars are identical\n+        Assert.assertEquals(Files.readAllBytes(JAR_FILE_SOURCE_DATE1.toPath()),\n+                Files.readAllBytes(JAR_FILE_SOURCE_DATE2.toPath()));\n+    }\n+\n+    \/**\n+     * Create the standard directory structure used by the test:\n+     * outer\/\n+     * inner\/\n+     * foo.txt\n+     *\/\n+    static void createOuterInnerDirs() throws IOException {\n+        Assert.assertTrue(DIR_OUTER.mkdir());\n+        Assert.assertTrue(DIR_INNER.mkdir());\n+        try (PrintWriter pw = new PrintWriter(FILE_INNER)) {\n+            pw.println(\"hello, world\");\n+        }\n+        Assert.assertTrue(DIR_OUTER.exists());\n+        Assert.assertTrue(DIR_INNER.exists());\n+        Assert.assertTrue(FILE_INNER.exists());\n+    }\n+\n+    \/**\n+     * Check the extracted and original millis since Epoch file times are\n+     * within the zip precision time period.\n+     *\/\n+    static void checkFileTime(long now, long original) {\n+        if (isTimeSettingChanged()) {\n+            return;\n+        }\n+\n+        if (Math.abs(now - original) > PRECISION) {\n+            \/\/ If original time is after UNIX 2038 32bit rollover\n+            \/\/ and the now time is exactly the rollover time, then assume\n+            \/\/ running on a file system that only supports to 2038 (e.g.XFS) and pass test\n+            if (FileTime.fromMillis(original).toInstant().isAfter(UNIX_2038_ROLLOVER) &&\n+                    FileTime.fromMillis(now).toInstant().equals(UNIX_2038_ROLLOVER)) {\n+                System.out.println(\"Checking file time after Unix 2038 rollover,\" +\n+                        \" and extracted file time is \" + UNIX_2038_ROLLOVER_TIME + \", \" +\n+                        \" Assuming restricted file system, pass file time check.\");\n+            } else {\n+                throw new AssertionError(\"checkFileTime failed,\" +\n+                        \" extracted to \" + FileTime.fromMillis(now) +\n+                        \", expected to be close to \" + FileTime.fromMillis(original));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Has the timezone or DST changed during the test?\n+     *\/\n+    private static boolean isTimeSettingChanged() {\n+        TimeZone currentTZ = TimeZone.getDefault();\n+        boolean currentDST = currentTZ.inDaylightTime(new Date());\n+        if (!currentTZ.equals(TZ) || currentDST != DST) {\n+            System.out.println(\"Timezone or DST has changed during \" +\n+                    \"ReproducibleJar testcase execution. Test skipped\");\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    \/**\n+     * Is the Zone currently within the transition change period?\n+     *\/\n+    private static boolean isInTransition() {\n+        var inTransition = false;\n+        var date = new Date();\n+        var defZone = ZoneId.systemDefault();\n+        if (defZone.getRules().getTransition(\n+                date.toInstant().atZone(defZone).toLocalDateTime()) != null) {\n+            System.out.println(\"ReproducibleJar testcase being run during Zone offset transition.  Test skipped.\");\n+            inTransition = true;\n+        }\n+        return inTransition;\n+    }\n+\n+    \/**\n+     * Remove the directory and its contents\n+     *\/\n+    static void cleanup(File dir) {\n+        File[] x = dir.listFiles();\n+        if (x != null) {\n+            for (File f : x) {\n+                f.delete();\n+            }\n+        }\n+        dir.delete();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jar\/ReproducibleJar.java","additions":290,"deletions":0,"binary":false,"changes":290,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import jdk.internal.jimage.BasicImageReader;\n+import jdk.internal.jimage.ImageLocation;\n+import jdk.test.lib.compiler.InMemoryJavaCompiler;\n+import jdk.test.lib.util.JarBuilder;\n+\n+import tests.Helper;\n+import tests.JImageGenerator;\n+import tests.Result;\n+\n+\/*\n+ * @test\n+ * @bug 8278185\n+ * @summary Test non-ASCII path in custom JRE\n+ * @library ..\/lib\n+ *          \/test\/lib\n+ * @modules java.base\/jdk.internal.jimage\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.jlink\/jdk.tools.jimage\n+ * @build tests.*\n+ * @run main\/othervm JImageNonAsciiNameTest\n+ *\/\n+\n+public class JImageNonAsciiNameTest {\n+    private final static String moduleName = \"A_module\";\n+    private final static String packageName = \"test.\\u3042\"; \/\/non-ASCII\n+    private final static String className = \"A\";\n+    private final static String fullName = packageName + \".\" + className;\n+    private static Helper helper;\n+\n+    public static void main(String[] args) throws Exception {\n+        helper = Helper.newHelper();\n+        if (helper == null) {\n+            System.err.println(\"Test not run\");\n+            return;\n+        }\n+\n+        String source =\n+            \"package \"+packageName+\";\" +\n+            \"public class \"+className+\" {\" +\n+            \"    public static void main(String[] args) {}\" +\n+            \"}\";\n+        String moduleInfo = \"module \" + moduleName + \" {}\";\n+\n+        \/\/ Using InMemory features to avoid generating non-ASCII name file\n+        byte[] byteA = InMemoryJavaCompiler.compile(fullName, source);\n+        byte[] byteModule = InMemoryJavaCompiler.compile(\n+                \"module-info\", moduleInfo);\n+\n+        Path jarDir = helper.getJarDir();\n+        JarBuilder jb = new JarBuilder(\n+                jarDir.resolve(moduleName + \".jar\").toString());\n+        jb.addEntry(fullName.replace(\".\",\"\/\") + \".class\", byteA);\n+        jb.addEntry(\"module-info.class\", byteModule);\n+        jb.build();\n+\n+        Path outDir = helper.createNewImageDir(moduleName);\n+\n+        Result result = JImageGenerator.getJLinkTask()\n+                .modulePath(helper.defaultModulePath())\n+                .output(outDir)\n+                .addMods(moduleName)\n+                .call();\n+        Path testImage = result.assertSuccess();\n+\n+        BasicImageReader bir = BasicImageReader.open(\n+                testImage.resolve(\"lib\").resolve(\"modules\"));\n+        ImageLocation loc = bir.findLocation(moduleName,\n+                fullName.replace(\".\",\"\/\") + \".class\");\n+        if (loc == null) {\n+            throw new RuntimeException(\"Failed to find \" +\n+                    fullName + \" in module \" +moduleName);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jimage\/JImageNonAsciiNameTest.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764\n+ * @bug 8142968 8166568 8166286 8170618 8168149 8240910 8276764 8276766\n@@ -186,0 +186,2 @@\n+        Path jmod = MODS_DIR.resolve(\"foo.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod);\n@@ -188,1 +190,1 @@\n-             MODS_DIR.resolve(\"foo.jmod\").toString())\n+             jmod.toString())\n@@ -192,1 +194,1 @@\n-             MODS_DIR.resolve(\"foo.jmod\").toString())\n+             jmod.toString())\n@@ -214,0 +216,58 @@\n+    @Test\n+    public void testSourceDateReproducible() throws IOException {\n+        String cp = EXPLODED_DIR.resolve(\"foo\").resolve(\"classes\").toString();\n+        Path jmod1 = MODS_DIR.resolve(\"foo1.jmod\");\n+        Path jmod2 = MODS_DIR.resolve(\"foo2.jmod\");\n+        Path jmod3 = MODS_DIR.resolve(\"foo3.jmod\");\n+        FileUtils.deleteFileIfExistsWithRetry(jmod1);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod2);\n+        FileUtils.deleteFileIfExistsWithRetry(jmod3);\n+\n+        \/\/ Use source date of 15\/03\/2022\n+        String sourceDate = \"2022-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod1.toString())\n+            .assertSuccess();\n+\n+        try {\n+            \/\/ Sleep 5 seconds to ensure zip timestamps might be different if they could be\n+            Thread.sleep(5000);\n+        } catch(InterruptedException ex) {}\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod2.toString())\n+            .assertSuccess();\n+\n+        \/\/ Compare file byte content to see if they are identical\n+        assertSameContent(jmod1, jmod2);\n+\n+        \/\/ Use a date before 1980 and assert failure error\n+        sourceDate = \"1976-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertFailure()\n+            .resultChecker(r -> {\n+                assertContains(r.output, \"is out of the valid range\");\n+            });\n+\n+        \/\/ Use a date after 2099 and assert failure error\n+        sourceDate = \"2100-03-15T00:00:00+00:00\";\n+\n+        jmod(\"create\",\n+             \"--class-path\", cp,\n+             \"--date\", sourceDate,\n+             jmod3.toString())\n+            .assertFailure()\n+            .resultChecker(r -> {\n+                assertContains(r.output, \"is out of the valid range\");\n+            });\n+    }\n+\n","filename":"test\/jdk\/tools\/jmod\/JmodTest.java","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8271079\n+ * @summary JavaFileObject#toUri in MR-JAR returns real path\n+ * @modules java.compiler\n+ *          jdk.compiler\n+ * @run main T8271079\n+ *\/\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.*;\n+import java.util.*;\n+import java.util.jar.JarEntry;\n+import javax.tools.*;\n+\n+public class T8271079 {\n+\n+    public static void main(String[] args) throws Exception {\n+        new T8271079().run();\n+    }\n+\n+    final PrintStream out;\n+\n+    T8271079() {\n+        this.out = System.out;\n+    }\n+\n+    void run() throws Exception {\n+        Path mr = generateMultiReleaseJar();\n+        try {\n+            testT8271079(mr);\n+        } finally {\n+            Files.deleteIfExists(mr);\n+        }\n+    }\n+\n+    \/\/ $ echo 'module hello {}' > module-info.java\n+    \/\/ $ javac -d classes --release 9 module-info.java\n+    \/\/ $ jar --create --file mr.jar --release 9 -C classes .\n+    Path generateMultiReleaseJar() throws Exception {\n+        Files.writeString(Path.of(\"module-info.java\"), \"module hello {}\");\n+        java.util.spi.ToolProvider.findFirst(\"javac\").orElseThrow()\n+            .run(out, System.err, \"-d\", \"classes\", \"--release\", \"9\", \"module-info.java\");\n+        Path mr = Path.of(\"mr.jar\");\n+        java.util.spi.ToolProvider.findFirst(\"jar\").orElseThrow()\n+            .run(out, System.err, \"--create\", \"--file\", mr.toString(), \"--release\", \"9\", \"-C\", \"classes\", \".\");\n+        out.println(\"Created: \" + mr.toUri());\n+        out.println(\" Exists: \" + Files.exists(mr));\n+        return mr;\n+    }\n+\n+    void testT8271079(Path path) throws Exception {\n+        StandardJavaFileManager fileManager =\n+            ToolProvider.getSystemJavaCompiler()\n+                .getStandardFileManager(null, Locale.ENGLISH, StandardCharsets.UTF_8);\n+        fileManager.setLocationFromPaths(StandardLocation.CLASS_PATH, List.of(path));\n+        Iterator<String> options = Arrays.asList(\"--multi-release\", \"9\").iterator();\n+        fileManager.handleOption(options.next(), options);\n+\n+        Iterable<JavaFileObject> list =\n+            fileManager.list(\n+                StandardLocation.CLASS_PATH, \"\", EnumSet.allOf(JavaFileObject.Kind.class), false);\n+\n+        for (JavaFileObject f : list) {\n+            out.println(\"JavaFileObject#getName: \" + f.getName());\n+            out.println(\"JavaFileObject#toUri: \" + f.toUri());\n+            openUsingUri(f.toUri());\n+        }\n+        System.gc(); \/\/ JDK-8224794\n+    }\n+\n+    void openUsingUri(URI uri) throws IOException {\n+        URLConnection connection = uri.toURL().openConnection();\n+        connection.setUseCaches(false); \/\/ JDK-8224794\n+        if (connection instanceof JarURLConnection jar) {\n+            try {\n+                JarEntry entry = jar.getJarEntry();\n+                out.println(\"JarEntry#getName: \" + entry.getName());\n+                connection.getInputStream().close(); \/\/ JDK-8224794\n+            } catch (FileNotFoundException e) {\n+                throw e;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/T8271079.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -38,1 +38,1 @@\n- *                                      RELEASE_18\n+ *                                      RELEASE_18 RELEASE_19\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetSourceVersions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-        EIGHTEEN(\"18\", 62);\n+        EIGHTEEN(\"18\", 62),\n+        NINETEEN(\"19\", 63);\n","filename":"test\/langtools\/tools\/javac\/classfiles\/ClassVersionChecker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8277634\n+ * @summary Verify the correct constantpool entries are created for invokedynamic instructions using\n+ *          the same bootstrap and type, but different name.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.code\n+ *          jdk.compiler\/com.sun.tools.javac.comp\n+ *          jdk.compiler\/com.sun.tools.javac.jvm\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.tree\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ *          jdk.jdeps\/com.sun.tools.classfile\n+ *          jdk.jdeps\/com.sun.tools.javap\n+ * @build toolbox.JarTask toolbox.JavacTask toolbox.JavapTask toolbox.ToolBox\n+ * @run main IndyCorrectInvocationName\n+ *\/\n+\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.HashSet;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import com.sun.source.util.JavacTask;\n+import com.sun.source.util.Plugin;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+\n+import com.sun.tools.classfile.Attribute;\n+import com.sun.tools.classfile.BootstrapMethods_attribute;\n+import com.sun.tools.classfile.ClassFile;\n+import com.sun.tools.classfile.Code_attribute;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_InvokeDynamic_info;\n+import com.sun.tools.classfile.ConstantPool.CONSTANT_NameAndType_info;\n+import com.sun.tools.classfile.Instruction;\n+\n+import com.sun.tools.javac.api.BasicJavacTask;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.jvm.PoolConstant;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n+import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n+import com.sun.tools.javac.tree.JCTree.JCLiteral;\n+import com.sun.tools.javac.tree.JCTree.JCMethodInvocation;\n+import com.sun.tools.javac.tree.JCTree.Tag;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeScanner;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Names;\n+\n+import toolbox.JarTask;\n+import toolbox.ToolBox;\n+\n+\n+public class IndyCorrectInvocationName implements Plugin {\n+    private static final String NL = System.lineSeparator();\n+\n+    public static void main(String... args) throws Exception {\n+        new IndyCorrectInvocationName().run();\n+    }\n+\n+    void run() throws Exception {\n+        ToolBox tb = new ToolBox();\n+        Path pluginClasses = Path.of(\"plugin-classes\");\n+        tb.writeFile(pluginClasses.resolve(\"META-INF\").resolve(\"services\").resolve(Plugin.class.getName()),\n+                IndyCorrectInvocationName.class.getName() + System.lineSeparator());\n+        try (DirectoryStream<Path> ds = Files.newDirectoryStream(Path.of(ToolBox.testClasses))) {\n+            for (Path p : ds) {\n+                if (p.getFileName().toString().startsWith(\"IndyCorrectInvocationName\") ||\n+                    p.getFileName().toString().endsWith(\".class\")) {\n+                    Files.copy(p, pluginClasses.resolve(p.getFileName()));\n+                }\n+            }\n+        }\n+\n+        Path pluginJar = Path.of(\"plugin.jar\");\n+        new JarTask(tb, pluginJar)\n+                .baseDir(pluginClasses)\n+                .files(\".\")\n+                .run();\n+\n+        Path src = Path.of(\"src\");\n+            tb.writeJavaFiles(src,\n+                    \"\"\"\n+                    import java.lang.invoke.CallSite;\n+                    import java.lang.invoke.ConstantCallSite;\n+                    import java.lang.invoke.MethodHandles;\n+                    import java.lang.invoke.MethodHandles.Lookup;\n+                    import java.lang.invoke.MethodType;\n+                    public class Test{\n+                        private static final String NL = System.lineSeparator();\n+                        private static StringBuilder output = new StringBuilder();\n+                        public static void doRun() {\n+                            method(\"a\");\n+                            method(\"b\");\n+                            method(\"a\");\n+                            method(\"b\");\n+                        }\n+                        public static String run() {\n+                            doRun();\n+                            return output.toString();\n+                        }\n+                        public static void method(String name) {}\n+                        public static void actualMethod(String name) {\n+                            output.append(name).append(NL);\n+                        }\n+                        public static CallSite bootstrap(Lookup lookup, String name, MethodType type) throws Exception {\n+                            return new ConstantCallSite(MethodHandles.lookup()\n+                                                                     .findStatic(Test.class,\n+                                                                                 \"actualMethod\",\n+                                                                                 MethodType.methodType(void.class,\n+                                                                                                       String.class))\n+                                                                     .bindTo(name));\n+                        }\n+                    }\n+                    \"\"\");\n+        Path classes = Files.createDirectories(Path.of(\"classes\"));\n+\n+        new toolbox.JavacTask(tb)\n+                .classpath(pluginJar)\n+                .options(\"-XDaccessInternalAPI\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run()\n+                .writeAll();\n+\n+        URLClassLoader cl = new URLClassLoader(new URL[] {classes.toUri().toURL()});\n+\n+        String actual = (String) cl.loadClass(\"Test\")\n+                                   .getMethod(\"run\")\n+                                   .invoke(null);\n+        String expected = \"a\" + NL + \"b\" + NL + \"a\" + NL +\"b\" + NL;\n+        if (!Objects.equals(actual, expected)) {\n+            throw new AssertionError(\"expected: \" + expected + \"; but got: \" + actual);\n+        }\n+\n+        Path testClass = classes.resolve(\"Test.class\");\n+        ClassFile cf = ClassFile.read(testClass);\n+        BootstrapMethods_attribute bootAttr =\n+                (BootstrapMethods_attribute) cf.attributes.get(Attribute.BootstrapMethods);\n+        if (bootAttr.bootstrap_method_specifiers.length != 1) {\n+            throw new AssertionError(\"Incorrect number of bootstrap methods: \" +\n+                                     bootAttr.bootstrap_method_specifiers.length);\n+        }\n+        Code_attribute codeAttr =\n+                (Code_attribute) cf.methods[1].attributes.get(Attribute.Code);\n+        Set<Integer> seenBootstraps = new HashSet<>();\n+        Set<Integer> seenNameAndTypes = new HashSet<>();\n+        Set<String> seenNames = new HashSet<>();\n+        for (Instruction i : codeAttr.getInstructions()) {\n+            switch (i.getOpcode()) {\n+                case INVOKEDYNAMIC -> {\n+                    int idx = i.getUnsignedShort(1);\n+                    CONSTANT_InvokeDynamic_info dynamicInfo =\n+                            (CONSTANT_InvokeDynamic_info) cf.constant_pool.get(idx);\n+                    seenBootstraps.add(dynamicInfo.bootstrap_method_attr_index);\n+                    seenNameAndTypes.add(dynamicInfo.name_and_type_index);\n+                    CONSTANT_NameAndType_info nameAndTypeInfo =\n+                            cf.constant_pool.getNameAndTypeInfo(dynamicInfo.name_and_type_index);\n+                    seenNames.add(nameAndTypeInfo.getName());\n+                }\n+                case RETURN -> {}\n+                default -> throw new AssertionError(\"Unexpected instruction: \" + i.getOpcode());\n+            }\n+            }\n+        if (seenBootstraps.size() != 1) {\n+            throw new AssertionError(\"Unexpected bootstraps: \" + seenBootstraps);\n+        }\n+        if (seenNameAndTypes.size() != 2) {\n+            throw new AssertionError(\"Unexpected names and types: \" + seenNameAndTypes);\n+        }\n+        if (!seenNames.equals(Set.of(\"a\", \"b\"))) {\n+            throw new AssertionError(\"Unexpected names and types: \" + seenNames);\n+        }\n+    }\n+\n+    \/\/ Plugin impl...\n+\n+    @Override\n+    public String getName() { return \"IndyCorrectInvocationName\"; }\n+\n+    @Override\n+    public void init(JavacTask task, String... args) {\n+        Context c = ((BasicJavacTask) task).getContext();\n+        task.addTaskListener(new TaskListener() {\n+            @Override\n+            public void started(TaskEvent e) {\n+                if (e.getKind() == TaskEvent.Kind.GENERATE) {\n+                    convert(c, (JCCompilationUnit) e.getCompilationUnit());\n+                }\n+            }\n+        });\n+    }\n+\n+    @Override\n+    public boolean autoStart() {\n+        return true;\n+    }\n+\n+    private void convert(Context context, JCCompilationUnit toplevel) {\n+        TreeMaker make = TreeMaker.instance(context);\n+        Names names = Names.instance(context);\n+        Symtab syms = Symtab.instance(context);\n+        new TreeScanner() {\n+            MethodSymbol bootstrap;\n+            @Override\n+            public void visitClassDef(JCClassDecl tree) {\n+                bootstrap = (MethodSymbol) tree.sym.members().getSymbolsByName(names.fromString(\"bootstrap\")).iterator().next();\n+                super.visitClassDef(tree);\n+            }\n+            @Override\n+            public void visitApply(JCMethodInvocation tree) {\n+                if (tree.args.size() == 1 && tree.args.head.hasTag(Tag.LITERAL)) {\n+                    String name = (String) ((JCLiteral) tree.args.head).value;\n+                    Type.MethodType indyType = new Type.MethodType(\n+                            com.sun.tools.javac.util.List.nil(),\n+                            syms.voidType,\n+                            com.sun.tools.javac.util.List.nil(),\n+                            syms.methodClass\n+                    );\n+                    Symbol.DynamicMethodSymbol dynSym = new Symbol.DynamicMethodSymbol(names.fromString(name),\n+                            syms.noSymbol,\n+                            bootstrap.asHandle(),\n+                            indyType,\n+                            new PoolConstant.LoadableConstant[0]);\n+\n+                    JCTree.JCFieldAccess qualifier = make.Select(make.QualIdent(bootstrap.owner), dynSym.name);\n+                    qualifier.sym = dynSym;\n+                    qualifier.type = syms.voidType;\n+                    tree.meth = qualifier;\n+                    tree.args = com.sun.tools.javac.util.List.nil();\n+                    tree.type = syms.voidType;\n+                }\n+                super.visitApply(tree);\n+            }\n+\n+        }.scan(toplevel);\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/classwriter\/IndyCorrectInvocationName.java","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -115,1 +115,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -126,1 +126,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -136,1 +136,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -146,1 +146,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -167,1 +167,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -186,1 +186,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -207,1 +207,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -228,1 +228,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n@@ -249,1 +249,1 @@\n-    @SupportedSourceVersion(RELEASE_18)\n+    @SupportedSourceVersion(RELEASE_19)\n","filename":"test\/langtools\/tools\/javac\/lib\/JavacTestingAbstractProcessor.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.err.preview.feature.disabled.classfile: Bar.class, 18\n+- compiler.err.preview.feature.disabled.classfile: Bar.class, 19\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.nopreview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-- compiler.warn.preview.feature.use.classfile: Bar.class, 18\n+- compiler.warn.preview.feature.use.classfile: Bar.class, 19\n","filename":"test\/langtools\/tools\/javac\/preview\/classReaderTest\/Client.preview.out","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-               \"15\", \"16\", \"17\", \"18\");\n+               \"15\", \"16\", \"17\", \"18\", \"19\");\n@@ -76,1 +76,1 @@\n-    public static final String LATEST_MAJOR_VERSION = \"62.0\";\n+    public static final String LATEST_MAJOR_VERSION = \"63.0\";\n@@ -90,1 +90,2 @@\n-        EIGHTEEN(false,  \"62.0\", \"18\", Versions::checksrc18);\n+        EIGHTEEN(false,  \"62.0\", \"18\", Versions::checksrc18),\n+        NINETEEN(false,  \"63.0\", \"19\", Versions::checksrc19);\n@@ -323,0 +324,7 @@\n+   protected void checksrc19(List<String> args) {\n+       printargs(\"checksrc19\", args);\n+       expectedPass(args, List.of(\"New7.java\", \"New8.java\", \"New10.java\", \"New11.java\",\n+                                  \"New14.java\", \"New15.java\", \"New16.java\", \"New17.java\"));\n+       \/\/ Add expectedFail after new language features added in a later release.\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/versions\/Versions.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-            return new Integer(id).compareTo(new Integer(f.id));\n+            return Integer.valueOf(id).compareTo(Integer.valueOf(f.id));\n","filename":"test\/lib-test\/jdk\/test\/lib\/AssertsTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+        @SuppressWarnings(\"deprecation\")\n","filename":"test\/lib-test\/jdk\/test\/lib\/TestPlatformIsTieredSupported.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,0 +277,1 @@\n+            public int hashCode() { return value.hashCode(); }\n@@ -366,1 +367,1 @@\n-            ArrayDiff diff;\n+            ArrayDiff<?> diff;\n","filename":"test\/lib-test\/jdk\/test\/lib\/format\/ArrayDiffTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+        @SuppressWarnings(\"deprecation\")\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/OldWhiteBox.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-            new VmFlagTest(existentFlag, set, get, true).test(tests, results);\n+            new VmFlagTest<T>(existentFlag, set, get, true).test(tests, results);\n@@ -77,1 +77,1 @@\n-        new VmFlagTest(NONEXISTENT_FLAG, set, get, false).test(tests, results);\n+        new VmFlagTest<T>(NONEXISTENT_FLAG, set, get, false).test(tests, results);\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/VmFlagTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-    public static void redefineClass(Class clazz, String javacode) throws Exception {\n+    public static void redefineClass(Class<?> clazz, String javacode) throws Exception {\n@@ -61,1 +61,1 @@\n-    public static void redefineClass(Class clazz, byte[] bytecode) throws Exception {\n+    public static void redefineClass(Class<?> clazz, byte[] bytecode) throws Exception {\n","filename":"test\/lib\/RedefineClassHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -454,0 +454,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import javax.tools.JavaFileManager;\n@@ -109,1 +110,1 @@\n-    private static class FileManagerWrapper extends ForwardingJavaFileManager {\n+    private static class FileManagerWrapper extends ForwardingJavaFileManager<JavaFileManager> {\n","filename":"test\/lib\/jdk\/test\/lib\/compiler\/InMemoryJavaCompiler.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,1 +144,1 @@\n-    public static ArrayCodec of(Object array) {\n+    public static ArrayCodec<?> of(Object array) {\n","filename":"test\/lib\/jdk\/test\/lib\/format\/ArrayCodec.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-    public static ArrayDiff of(Object first, Object second) {\n+    public static ArrayDiff<?> of(Object first, Object second) {\n@@ -112,1 +112,2 @@\n-    public static ArrayDiff of(Object first, Object second, int width, int contextBefore) {\n+    @SuppressWarnings(\"rawtypes\")\n+    public static ArrayDiff<?> of(Object first, Object second, int width, int contextBefore) {\n@@ -207,1 +208,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/format\/ArrayDiff.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -629,0 +629,1 @@\n+    @SuppressWarnings(\"deprecation\")\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/ASN1Formatter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -168,0 +168,1 @@\n+    @SuppressWarnings(\"deprecation\")\n","filename":"test\/lib\/jdk\/test\/lib\/hexdump\/StreamDump.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"filename":"test\/lib\/jdk\/test\/lib\/net\/testkeys","binary":true,"status":"modified"},{"patch":"@@ -116,2 +116,2 @@\n-    private Map<String,String> prop = new HashMap();\n-    private Map<String,String> secprop = new HashMap();\n+    private Map<String,String> prop = new HashMap<>();\n+    private Map<String,String> secprop = new HashMap<>();\n","filename":"test\/lib\/jdk\/test\/lib\/process\/Proc.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -435,0 +435,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -607,0 +608,1 @@\n+    @SuppressWarnings(\"removal\")\n","filename":"test\/lib\/jdk\/test\/lib\/process\/ProcessTools.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-                s3.sign(p.getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n+                s3.sign(p.toAbsolutePath().getParent().toUri(), p.getFileName().toUri()))); \/\/ can read KeyInfo\n@@ -98,0 +98,2 @@\n+        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#x\")));\n+        Asserts.assertTrue(v1.validate(s1.signEnveloping(d, \"x\", \"#xpointer(id('x'))\")));\n@@ -350,1 +352,1 @@\n-        public Document signEnveloping(Document document) throws Exception {\n+        public Document signEnveloping(Document document, String id, String ref) throws Exception {\n@@ -354,1 +356,1 @@\n-                    buildSignedInfo(FAC.newReference(\"#object\", dm)),\n+                    buildSignedInfo(FAC.newReference(ref, dm)),\n@@ -357,1 +359,1 @@\n-                            \"object\", null, null)),\n+                            id, null, null)),\n@@ -477,1 +479,1 @@\n-            NodeList nodeList = document.getElementsByTagName(\"Signature\");\n+            NodeList nodeList = document.getElementsByTagNameNS(XMLSignature.XMLNS, \"Signature\");\n","filename":"test\/lib\/jdk\/test\/lib\/security\/XMLUtils.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -110,2 +110,4 @@\n-            System.out.println(\"Found core file: \" + coreFileLocation);\n-            Asserts.assertGT(new File(coreFileLocation).length(), 0L, \"Unexpected core size\");\n+            long coreFileSize = new File(coreFileLocation).length();\n+            System.out.println(\"Found core file \" + coreFileLocation +\n+                               \", size = \" + coreFileSize \/ 1024 \/ 1024 + \"mb\");\n+            Asserts.assertGT(coreFileSize, 0L, \"Unexpected core size\");\n","filename":"test\/lib\/jdk\/test\/lib\/util\/CoreUtils.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/\/\n+\/\/ Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import jdk.incubator.vector.*;\n+import java.util.concurrent.TimeUnit;\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class MaskFromLongBenchmark {\n+    static long val = 0;\n+\n+    @Setup(Level.Invocation)\n+    public void BmSetup() {\n+        val++;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Byte64() {\n+        VectorMask mask = VectorMask.fromLong(ByteVector.SPECIES_64, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Byte128() {\n+        VectorMask mask = VectorMask.fromLong(ByteVector.SPECIES_128, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Byte256() {\n+        VectorMask mask = VectorMask.fromLong(ByteVector.SPECIES_256, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Byte512() {\n+        VectorMask mask = VectorMask.fromLong(ByteVector.SPECIES_512, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Short64() {\n+        VectorMask mask = VectorMask.fromLong(ShortVector.SPECIES_64, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Short128() {\n+        VectorMask mask = VectorMask.fromLong(ShortVector.SPECIES_128, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Short256() {\n+        VectorMask mask = VectorMask.fromLong(ShortVector.SPECIES_256, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Short512() {\n+        VectorMask mask = VectorMask.fromLong(ShortVector.SPECIES_512, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Integer64() {\n+        VectorMask mask = VectorMask.fromLong(IntVector.SPECIES_64, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Integer128() {\n+        VectorMask mask = VectorMask.fromLong(IntVector.SPECIES_128, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Integer256() {\n+        VectorMask mask = VectorMask.fromLong(IntVector.SPECIES_256, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Integer512() {\n+        VectorMask mask = VectorMask.fromLong(IntVector.SPECIES_512, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Long64() {\n+        VectorMask mask = VectorMask.fromLong(LongVector.SPECIES_64, val);\n+        return mask.laneIsSet(0) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Long128() {\n+        VectorMask mask = VectorMask.fromLong(LongVector.SPECIES_128, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Long256() {\n+        VectorMask mask = VectorMask.fromLong(LongVector.SPECIES_256, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+    @Benchmark\n+    public int microMaskFromLong_Long512() {\n+        VectorMask mask = VectorMask.fromLong(LongVector.SPECIES_512, val);\n+        return mask.laneIsSet(1) ? 1 : 0;\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/MaskFromLongBenchmark.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Fork(1)\n+\n+public class IterativeEA {\n+\n+    public static int ii = 1;\n+\n+    static class A {\n+        int i;\n+\n+        public A(int i) {\n+            this.i = i;\n+        }\n+    }\n+\n+    static class B {\n+        A a;\n+\n+        public B(A a) {\n+            this.a = a;\n+        }\n+    }\n+\n+    static class C {\n+        B b;\n+\n+        public C(B b) {\n+            this.b = b;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int test1() {\n+        C c = new C(new B(new A(ii)));\n+        return c.b.a.i;\n+    }\n+\n+    static class Point {\n+        int x;\n+        int y;\n+        int ax[];\n+        int ay[];\n+    }\n+\n+    @Benchmark\n+    public int test2() {\n+        Point p = new Point();\n+        p.ax = new int[2];\n+        p.ay = new int[2];\n+        int x = 3;\n+        p.ax[0] = x;\n+        p.ay[1] = 3 * x + ii;\n+        return p.ax[0] * p.ay[1];\n+    }\n+\n+    public static final Double dbc = Double.valueOf(1.);\n+\n+    @Benchmark\n+    public double test3() {\n+        Double j1 = Double.valueOf(1.);\n+        Double j2 = Double.valueOf(1.);\n+        for (int i = 0; i< 1000; i++) {\n+            j1 = j1 + 1.;\n+            j2 = j2 + 2.;\n+        }\n+        return j1 + j2;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/IterativeEA.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+  * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+  *\n+  * This code is free software; you can redistribute it and\/or modify it\n+  * under the terms of the GNU General Public License version 2 only, as\n+  * published by the Free Software Foundation.\n+  *\n+  * This code is distributed in the hope that it will be useful, but WITHOUT\n+  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+  * version 2 for more details (a copy is included in the LICENSE file that\n+  * accompanied this code).\n+  *\n+  * You should have received a copy of the GNU General Public License version\n+  * 2 along with this work; if not, write to the Free Software Foundation,\n+  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+  *\n+  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+  * or visit www.oracle.com if you need additional information or have any\n+  * questions.\n+  *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Fork(value = 3)\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 3, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+public class PointerBenchmarkFlat {\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+\n+    PointerImpl ptr_ptr;\n+    PointerImplFlat ptr_ptr_flat;\n+\n+    @Setup\n+    public void setup() {\n+        ptr_ptr = new PointerImpl(new FakeSegment(MemoryAddress.NULL, Long.MAX_VALUE));\n+        ptr_ptr_flat = new PointerImplFlat(new FakeSegmentFlat(MemoryAddress.NULL, Long.MAX_VALUE));\n+    }\n+\n+    static class MemoryAddress {\n+        private long addr;\n+\n+        public MemoryAddress(long addr) {\n+            this.addr = addr;\n+        }\n+\n+        long toRawLongValue() {\n+            return addr;\n+        }\n+\n+        private static final MemoryAddress NULL = new MemoryAddress(0);\n+\n+        static MemoryAddress ofLong(long val) {\n+            return new MemoryAddress(val);\n+        }\n+    }\n+\n+    static class PointerImpl {\n+        final FakeSegment segment;\n+\n+        public PointerImpl(FakeSegment segment) {\n+            this.segment = segment;\n+        }\n+\n+        MemoryAddress address() {\n+            return segment.address();\n+        }\n+\n+        PointerImpl get(long index) {\n+            MemoryAddress address = MemoryAddress.ofLong(index);\n+            FakeSegment holder = new FakeSegment(address, Long.MAX_VALUE);\n+            return new PointerImpl(holder);\n+        }\n+    }\n+\n+    static class PointerImplFlat {\n+        final FakeSegmentFlat segment;\n+\n+        public PointerImplFlat(FakeSegmentFlat segment) {\n+            this.segment = segment;\n+        }\n+\n+        MemoryAddress address() {\n+            return segment.address();\n+        }\n+\n+        PointerImplFlat get(long index) {\n+            MemoryAddress address = MemoryAddress.ofLong(index);\n+            FakeSegmentFlat holder = new FakeSegmentFlat(address, Long.MAX_VALUE);\n+            return new PointerImplFlat(holder);\n+        }\n+    }\n+\n+    static class AbstractFakeSegment {\n+        final long size;\n+\n+        public AbstractFakeSegment(long size) {\n+            this.size = size;\n+        }\n+    }\n+\n+    static class FakeSegment extends AbstractFakeSegment {\n+        final MemoryAddress address;\n+\n+        public FakeSegment(MemoryAddress address, long size) {\n+            super(size);\n+            this.address = address;\n+        }\n+\n+        MemoryAddress address() {\n+            return address;\n+        }\n+    }\n+\n+    static class FakeSegmentFlat {\n+        final MemoryAddress address;\n+        final long size;\n+\n+        public FakeSegmentFlat(MemoryAddress address, long size) {\n+            this.size = size;\n+            this.address = address;\n+        }\n+\n+        MemoryAddress address() {\n+            return address;\n+        }\n+    }\n+\n+    @Benchmark\n+    public int test() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += ptr_ptr.get(i).address().toRawLongValue();\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int testFlat() {\n+        int sum = 0;\n+        for (int i = 0 ; i < ELEM_SIZE ; i++) {\n+            sum += ptr_ptr_flat.get(i).address().toRawLongValue();\n+        }\n+        return sum;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/PointerBenchmarkFlat.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"}]}