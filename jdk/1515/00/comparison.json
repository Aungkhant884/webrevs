{"files":[{"patch":"@@ -147,1 +147,21 @@\n-  return Size() == 1;\n+\n+  for (unsigned i = _lwm; i <= _hwm; i++) {\n+    uintptr_t v = _RM_UP[i];\n+    if (v != 0) {\n+      \/\/ Only one bit allowed -> v must be a power of two\n+      if (!is_power_of_2(v)) {\n+        return false;\n+      }\n+\n+      \/\/ A single bit was found - check there are no bits in the rest of the mask\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n+      }\n+      \/\/ Done; found a single bit\n+      return true;\n+    }\n+  }\n+  \/\/ No bit found\n+  return false;\n@@ -153,1 +173,1 @@\n-  uintptr_t bit = all;               \/\/ Set to hold the one bit allowed\n+\n@@ -156,5 +176,5 @@\n-    if (_RM_UP[i]) {               \/\/ Found some bits\n-      if (bit != all) return false; \/\/ Already had bits, so fail\n-      bit = uintptr_t(1) << find_lowest_bit(_RM_UP[i]); \/\/ Extract lowest bit from mask\n-      if ((bit << 1U) != 0) {      \/\/ Bit pair stays in same word?\n-        if ((bit | (bit << 1U)) != _RM_UP[i])\n+    if (_RM_UP[i] != 0) {               \/\/ Found some bits\n+      unsigned int bit_index = find_lowest_bit(_RM_UP[i]);\n+      if (bit_index != _WordBitMask) {   \/\/ Bit pair stays in same word?\n+        uintptr_t bit = uintptr_t(1) << bit_index; \/\/ Extract lowest bit from mask\n+        if ((bit | (bit << 1U)) != _RM_UP[i]) {\n@@ -162,0 +182,1 @@\n+        }\n@@ -163,1 +184,1 @@\n-        if (bit != _RM_UP[i]) return false; \/\/ Found many bits, so fail\n+        assert(is_power_of_2(_RM_UP[i]), \"invariant\");\n@@ -165,1 +186,1 @@\n-        if (i > _hwm || _RM_UP[i] != 1)\n+        if (i > _hwm || _RM_UP[i] != 1) {\n@@ -167,0 +188,8 @@\n+        }\n+      }\n+\n+      \/\/ A matching pair was found - check there are no bits in the rest of the mask\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n@@ -168,0 +197,2 @@\n+      \/\/ Found a bit pair\n+      return true;\n@@ -170,1 +201,1 @@\n-  \/\/ True for both the empty mask and for a bit pair\n+  \/\/ True for the empty mask, too\n@@ -184,0 +215,1 @@\n+\n@@ -306,1 +338,0 @@\n-  uintptr_t bit = all;         \/\/ Set to hold the one bit allowed\n@@ -308,3 +339,1 @@\n-    if (_RM_UP[i] ) {           \/\/ Found some bits\n-      if (bit != all)\n-        return false;           \/\/ Already had bits, so fail\n+    if (_RM_UP[i] != 0) {       \/\/ Found some bits\n@@ -312,3 +341,3 @@\n-      bit = uintptr_t(1) << bit_index;\n-      uintptr_t hi_bit = bit << (size - 1); \/\/ high bit\n-      if (hi_bit != 0) {        \/\/ Bit set stays in same word?\n+      uintptr_t bit = uintptr_t(1) << bit_index;\n+      if (bit_index + size <= BitsPerWord) { \/\/ Bit set stays in same word?\n+        uintptr_t hi_bit = bit << (size - 1);\n@@ -316,1 +345,1 @@\n-        if (set != _RM_UP[i])\n+        if (set != _RM_UP[i]) {\n@@ -318,0 +347,1 @@\n+        }\n@@ -319,2 +349,4 @@\n-        if ((all & ~(bit-1)) != _RM_UP[i])\n-          return false;         \/\/ Found many bits, so fail\n+        \/\/ All bits from bit to highest bit in the word must be set\n+        if ((all & ~(bit-1)) != _RM_UP[i]) {\n+          return false;\n+        }\n@@ -324,1 +356,1 @@\n-        if (i > _hwm || _RM_UP[i] != set)\n+        if (i > _hwm || _RM_UP[i] != set) {\n@@ -326,0 +358,8 @@\n+        }\n+      }\n+\n+      \/\/ A matching set found - check there are no bits in the rest of the mask\n+      for (i++; i <= _hwm; i++) {\n+        if (_RM_UP[i] != 0) {\n+          return false;\n+        }\n@@ -327,0 +367,2 @@\n+      \/\/ Done - found a bit set\n+      return true;\n@@ -329,1 +371,1 @@\n-  \/\/ True for both the empty mask and for a bit set\n+  \/\/ True for the empty mask, too\n","filename":"src\/hotspot\/share\/opto\/regmask.cpp","additions":64,"deletions":22,"binary":false,"changes":86,"status":"modified"}]}