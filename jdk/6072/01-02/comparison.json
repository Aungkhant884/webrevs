{"files":[{"patch":"@@ -16515,1 +16515,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UU));\n@@ -16533,1 +16533,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LL));\n@@ -16551,1 +16551,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::UL));\n@@ -16571,1 +16571,1 @@\n-  predicate(((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU);\n+  predicate((UseSVE == 0) && (((StrCompNode*)n)->encoding() == StrIntrinsicNode::LU));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -5247,0 +5247,1 @@\n+    if (UseSVE == 0) {\n@@ -5255,0 +5256,10 @@\n+    } else {\n+      StubRoutines::aarch64::_compare_long_string_LL\n+          = generate_compare_long_string_sve(LL);\n+      StubRoutines::aarch64::_compare_long_string_UU\n+          = generate_compare_long_string_sve(UU);\n+      StubRoutines::aarch64::_compare_long_string_LU\n+          = generate_compare_long_string_sve(LU);\n+      StubRoutines::aarch64::_compare_long_string_UL\n+          = generate_compare_long_string_sve(UL);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.arm.benchmarks.intrinsics;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+\/**\n+ * This benchmark modified from test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringCompareToDifferentLength.java\n+ * This benchmark can be used to measure performance of compareTo() in\n+ * (Latin1, Latin1), (Latin1, UTF16), (UTF16, Latin1), and (UTF16, UTF16)\n+ * comparisons.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Measurement(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@Warmup(iterations = 3, time = 1000, timeUnit = TimeUnit.MILLISECONDS)\n+@CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+public class StringCompareToDifferentLength {\n+\n+    @State(Scope.Benchmark)\n+    public static class Input {\n+        @Param({\"24\", \"36\", \"72\", \"128\", \"256\", \"512\"})\n+        public int size;\n+\n+        @Param({\"2\"})\n+        public int delta;\n+\n+        int count = 100000;\n+        String longLatin1;\n+        String shortLatin1;\n+        String longUTF16FirstChar;\n+        String shortUTF16FirstChar;\n+        String longUTF16LastChar;\n+        String shortUTF16LastChar;\n+\n+        \/**\n+         * Initialize. New array objects and set initial values.\n+         *\/\n+        @Setup(Level.Trial)\n+        public void setup() throws Exception {\n+            char[] strsrc = new char[size + delta];\n+            \/\/ generate ASCII string\n+            for (int i = 0; i < size + delta; i++) {\n+                strsrc[i] = (char) ('a' + (i % 26));\n+            }\n+\n+            longLatin1 = new String(strsrc);\n+            shortLatin1 = longLatin1.substring(0, size);\n+            longUTF16LastChar = longLatin1.substring(0, longLatin1.length() - 1) + '\\ubeef';\n+            longUTF16FirstChar = '\\ubeef' + longLatin1.substring(1, longLatin1.length());\n+            shortUTF16LastChar = shortLatin1.substring(0, shortLatin1.length() - 1) + '\\ubeef';\n+            shortUTF16FirstChar = longUTF16FirstChar.substring(0, size);\n+        }\n+    }\n+\n+    private int runCompareTo(String str2, String str1) {\n+        return str1.compareTo(str2);\n+    }\n+\n+    \/**\n+     * latin1-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToLL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToUU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16FirstChar, in.shortUTF16FirstChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * latin1-UTF16\n+     *\/\n+    @Benchmark\n+    public void compareToLU(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longUTF16LastChar, in.shortLatin1);\n+        }\n+        blackhole.consume(res);\n+    }\n+\n+    \/**\n+     * UTF16-latin1\n+     *\/\n+    @Benchmark\n+    public void compareToUL(Input in, Blackhole blackhole) {\n+        int res = 0;\n+        for (int i = 0; i < in.count; ++i) {\n+            res += runCompareTo(in.longLatin1, in.shortUTF16LastChar);\n+        }\n+        blackhole.consume(res);\n+    }\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringCompareToDifferentLength.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"}]}