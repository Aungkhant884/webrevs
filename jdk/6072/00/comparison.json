{"files":[{"patch":"@@ -16504,1 +16504,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::UU);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::UU);\n@@ -16521,1 +16521,1 @@\n-                      fnoreg, fnoreg, fnoreg, StrIntrinsicNode::LL);\n+                      fnoreg, fnoreg, fnoreg, pnoreg, pnoreg, StrIntrinsicNode::LL);\n@@ -16541,1 +16541,1 @@\n-                      $vtmp3$$FloatRegister, StrIntrinsicNode::UL);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::UL);\n@@ -16561,1 +16561,1 @@\n-                      $vtmp3$$FloatRegister,StrIntrinsicNode::LU);\n+                      $vtmp3$$FloatRegister, pnoreg, pnoreg, StrIntrinsicNode::LU);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -679,1 +679,2 @@\n-    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {\n+    FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3,\n+    PRegister pgtmp1, PRegister pgtmp2, int ae) {\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-                      FloatRegister vtmp2, FloatRegister vtmp3, int ae);\n+                      FloatRegister vtmp2, FloatRegister vtmp3,\n+                      PRegister pgtmp1, PRegister pgtmp2, int ae);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -266,0 +266,2 @@\n+CONSTANT_REGISTER_DECLARATION(PRegister, pnoreg, (-1));\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,0 +191,2 @@\n+REGISTER_DEFINITION(PRegister, pnoreg);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/register_definitions_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5034,0 +5034,91 @@\n+  enum string_compare_mode {\n+    LL,\n+    LU,\n+    UL,\n+    UU,\n+  };\n+\n+  \/\/ The following registers are declared in aarch64.ad\n+  \/\/ r0  = result\n+  \/\/ r1  = str1\n+  \/\/ r2  = cnt1\n+  \/\/ r3  = str2\n+  \/\/ r4  = cnt2\n+  \/\/ r10 = tmp1\n+  \/\/ r11 = tmp2\n+  \/\/ z0  = ztmp1\n+  \/\/ z1  = ztmp2\n+  \/\/ p0  = pgtmp1\n+  \/\/ p1  = pgtmp2\n+  address generate_compare_long_string_sve(string_compare_mode mode) {\n+    __ align(CodeEntryAlignment);\n+    address entry = __ pc();\n+    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, cnt2 = r4,\n+             tmp1 = r10, tmp2 = r11;\n+\n+    Label LOOP, MATCH, DONE, NOMATCH;\n+    Register vec_len = tmp1;\n+    Register idx = tmp2;\n+    \/\/ The minimum of the string lengths has been stored in cnt2.\n+    Register cnt = cnt2;\n+    FloatRegister ztmp1 = z0, ztmp2 = z1;\n+    PRegister pgtmp1 = p0, pgtmp2 = p1;\n+\n+    if (mode == LL) {\n+      __ sve_cntb(vec_len);\n+    } else {\n+      __ sve_cnth(vec_len);\n+    }\n+\n+    __ mov(idx, 0);\n+    __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+\n+    __ bind(LOOP);\n+      switch (mode) {\n+        case LL:\n+          __ sve_ld1b(ztmp1, __ B, pgtmp1, Address(str1, idx));\n+          __ sve_ld1b(ztmp2, __ B, pgtmp1, Address(str2, idx));\n+          break;\n+        case LU:\n+          __ sve_ld1b(ztmp1, __ H, pgtmp1, Address(str1, idx));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        case UL:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1b(ztmp2, __ H, pgtmp1, Address(str2, idx));\n+          break;\n+        case UU:\n+          __ sve_ld1h(ztmp1, __ H, pgtmp1, Address(str1, idx, Address::lsl(1)));\n+          __ sve_ld1h(ztmp2, __ H, pgtmp1, Address(str2, idx, Address::lsl(1)));\n+          break;\n+        default: ShouldNotReachHere();\n+      }\n+      __ add(idx, idx, vec_len);\n+\n+      \/\/ Compare strings.\n+      __ sve_cmp(Assembler::NE, pgtmp2, mode == LL ? __ B : __ H, pgtmp1, ztmp1, ztmp2);\n+      __ br(__ NE, MATCH);\n+      __ sve_whilelt(pgtmp1, mode == LL ? __ B : __ H, idx, cnt);\n+      __ br(__ LT, LOOP);\n+\n+      \/\/ The result has been computed in the caller prior to entering this stub.\n+      __ b(DONE);\n+\n+    __ bind(MATCH);\n+\n+      \/\/ Crop the vector to find its location.\n+      __ sve_brkb(pgtmp2, pgtmp1, pgtmp2, false \/* isMerge *\/);\n+\n+      \/\/ Extract the first different characters of each string.\n+      __ sve_lasta(rscratch1, mode == LL ? __ B : __ H, pgtmp2, ztmp1);\n+      __ sve_lasta(rscratch2, mode == LL ? __ B : __ H, pgtmp2, ztmp2);\n+\n+      \/\/ Compute the difference of the first different characters.\n+      __ sub(result, rscratch1, rscratch2);\n+\n+    __ bind(DONE);\n+      __ ret(lr);\n+\n+    return entry;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"}]}