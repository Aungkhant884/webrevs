{"files":[{"patch":"@@ -139,1 +139,0 @@\n-           callerSP = Z_tmp_1,\n@@ -159,1 +158,1 @@\n-  allocated_frame_size = frame::z_abi_160_size;\n+  allocated_frame_size = _abi._shadow_space_bytes;\n@@ -162,1 +161,2 @@\n-  bool should_save_return_value = !_needs_return_buffer && _needs_transition;;\n+  assert(!_needs_return_buffer, \"unexpected needs_return_buffer\");\n+  bool should_save_return_value = _needs_transition;;\n@@ -188,1 +188,1 @@\n-  __ push_frame(allocated_frame_size); \/\/ Create a new frame for the wrapper.\n+  __ push_frame(allocated_frame_size, Z_R11); \/\/ Create a new frame for the wrapper.\n@@ -205,1 +205,0 @@\n-  __ z_lg(callerSP, _z_abi(callers_sp), Z_SP); \/\/ preset (used to access caller frame argument slots)\n@@ -207,1 +206,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(callerSP), frame::z_jit_out_preserve_size, _abi._shadow_space_bytes, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, frame::z_jit_out_preserve_size, _abi._shadow_space_bytes, locs);\n","filename":"src\/hotspot\/cpu\/s390\/downcallLinker_s390.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-static void move_reg64(MacroAssembler* masm, int out_stk_bias,\n+static void move_reg(MacroAssembler* masm, int out_stk_bias,\n@@ -163,1 +163,1 @@\n-static void move_stack(MacroAssembler* masm, Register callerSP, int in_stk_bias, int out_stk_bias,\n+static void move_stack(MacroAssembler* masm, Register tmp_reg, int in_stk_bias, int out_stk_bias,\n@@ -166,1 +166,1 @@\n-  Address from_addr(callerSP, reg2offset(from_reg, in_stk_bias));\n+  Address from_addr(Z_R11, reg2offset(from_reg, in_stk_bias));\n@@ -186,1 +186,1 @@\n-        case 8: __ mem2reg_opt(Z_R0_scratch, Address (callerSP, reg2offset(from_reg, in_stk_bias)), true); break;\n+        case 8: __ mem2reg_opt(tmp_reg, from_addr, true); break;\n@@ -188,1 +188,1 @@\n-                  __ mem2reg_signed_opt(Z_R0_scratch, Address (callerSP, reg2offset(from_reg, in_stk_bias)));\n+                  __ mem2reg_signed_opt(tmp_reg, from_addr);\n@@ -190,1 +190,1 @@\n-                  __ mem2reg_opt(Z_R0_scratch, Address (callerSP, reg2offset(from_reg, in_stk_bias)), false);\n+                  __ mem2reg_opt(tmp_reg, from_addr, false);\n@@ -196,2 +196,2 @@\n-        case 8: __ reg2mem_opt(Z_R0_scratch, Address (Z_SP, reg2offset(to_reg, out_bias)), true); break;\n-        case 4: __ reg2mem_opt(Z_R0_scratch, Address (Z_SP, reg2offset(to_reg, out_bias)), false); break;\n+        case 8: __ reg2mem_opt(tmp_reg, Address (Z_SP, reg2offset(to_reg, out_bias)), true); break;\n+        case 4: __ reg2mem_opt(tmp_reg, Address (Z_SP, reg2offset(to_reg, out_bias)), false); break;\n@@ -206,1 +206,1 @@\n-  Register callerSP = as_Register(tmp); \/\/ preset\n+  Register tmp_reg = as_Register(tmp);\n@@ -222,1 +222,1 @@\n-        move_reg64(masm, out_stk_bias, from_reg, to_reg);\n+        move_reg(masm, out_stk_bias, from_reg, to_reg);\n@@ -228,1 +228,1 @@\n-        move_stack(masm, callerSP, in_stk_bias, out_stk_bias, from_reg, to_reg);\n+        move_stack(masm, tmp_reg, in_stk_bias, out_stk_bias, from_reg, to_reg);\n","filename":"src\/hotspot\/cpu\/s390\/foreignGlobals_s390.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -131,3 +131,1 @@\n-  Register call_target_address = Z_R1_scratch,\n-           callerSP = Z_tmp_1,\n-           tmp = Z_R0_scratch;\n+  Register call_target_address = Z_R1_scratch;\n@@ -171,3 +169,0 @@\n-  \/\/      | (optional)          |\n-  \/\/      | ret_buf             |\n-  \/\/      |---------------------| = ret_buf_offset\n@@ -215,1 +210,0 @@\n-  __ z_lg(callerSP, _z_abi(callers_sp), Z_SP); \/\/ preset (used to access caller frame argument slots)\n@@ -217,1 +211,1 @@\n-  arg_shuffle.generate(_masm, as_VMStorage(callerSP), abi._shadow_space_bytes, frame::z_jit_out_preserve_size, locs);\n+  arg_shuffle.generate(_masm, shuffle_reg, abi._shadow_space_bytes, frame::z_jit_out_preserve_size, locs);\n@@ -232,23 +226,22 @@\n-  if (!needs_return_buffer) {\n-    \/\/ CallArranger can pick a return type that goes in the same reg for both CCs.\n-    if (call_regs._ret_regs.length() > 0) { \/\/ 0 or 1\n-      VMStorage ret_reg = call_regs._ret_regs.at(0);\n-      \/\/ Check if the return reg is as expected.\n-      switch (ret_type) {\n-        case T_BOOLEAN:\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_CHAR:\n-        case T_INT:\n-          __ z_lgfr(Z_RET, Z_RET); \/\/ Clear garbage in high half.\n-          \/\/ fallthrough\n-        case T_LONG:\n-          assert(as_Register(ret_reg) == Z_RET, \"unexpected result register\");\n-          break;\n-        case T_FLOAT:\n-        case T_DOUBLE:\n-          assert(as_FloatRegister(ret_reg) == Z_FRET, \"unexpected result register\");\n-          break;\n-        default:\n-          fatal(\"unexpected return type: %s\", type2name(ret_type));\n-      }\n+  assert(!needs_return_buffer, \"unexpected needs_return_buffer\");\n+  \/\/ CallArranger can pick a return type that goes in the same reg for both CCs.\n+  if (call_regs._ret_regs.length() > 0) { \/\/ 0 or 1\n+    VMStorage ret_reg = call_regs._ret_regs.at(0);\n+    \/\/ Check if the return reg is as expected.\n+    switch (ret_type) {\n+      case T_BOOLEAN:\n+      case T_BYTE:\n+      case T_SHORT:\n+      case T_CHAR:\n+      case T_INT:\n+        __ z_lgfr(Z_RET, Z_RET); \/\/ Clear garbage in high half.\n+                                 \/\/ fallthrough\n+      case T_LONG:\n+        assert(as_Register(ret_reg) == Z_RET, \"unexpected result register\");\n+        break;\n+      case T_FLOAT:\n+      case T_DOUBLE:\n+        assert(as_FloatRegister(ret_reg) == Z_FRET, \"unexpected result register\");\n+        break;\n+      default:\n+        fatal(\"unexpected return type: %s\", type2name(ret_type));\n","filename":"src\/hotspot\/cpu\/s390\/upcallLinker_s390.cpp","additions":24,"deletions":31,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-    Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3,1 +3,0 @@\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n@@ -115,1 +114,1 @@\n-        return new VMStorage(StorageType.FLOAT, REG64_MASK, index, \"v\" + index);\n+        return new VMStorage(StorageType.FLOAT, REG64_MASK, index, \"f\" + index);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/S390Architecture.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -135,1 +135,0 @@\n-            .filter(GroupLayout.class::isInstance)\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/LinuxS390CallArranger.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -104,11 +104,0 @@\n-        for (MemoryLayout elem : scalarLayouts) {\n-            if (!(elem instanceof ValueLayout))\n-                return false;\n-\n-            TypeClass argClass = classifyValueType((ValueLayout) elem);\n-            if (elem.byteSize() != baseType.byteSize() ||\n-                    elem.byteAlignment() != baseType.byteAlignment() ||\n-                    baseArgClass != argClass) {\n-                return false;\n-                    }\n-        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/s390\/linux\/TypeClass.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n+import static java.lang.foreign.ValueLayout.JAVA_INT;\n@@ -62,2 +62,2 @@\n-        MemorySegment segment = SymbolLookup.loaderLookup().find(\"c\").get().reinterpret(ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN ? 1 : 4);\n-        assertEquals(segment.get(JAVA_BYTE, ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN ? 0 : 3), 42);\n+        MemorySegment segment = SymbolLookup.loaderLookup().find(\"c\").get().reinterpret(4);\n+        assertEquals(segment.get(JAVA_INT, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestClassLoaderFindNative.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    private static final boolean byteorder = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;\n+    private static final boolean IS_LE = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;\n@@ -117,1 +117,1 @@\n-                    byteorder ? \"Unsupported layout: [2:i4]\" : \"Unsupported layout: [2:I4]\"\n+                    IS_LE ? \"Unsupported layout: [2:i4]\" : \"Unsupported layout: [2:I4]\"\n@@ -122,1 +122,1 @@\n-                    byteorder ? \"Unsupported layout: [2:i4]\" : \"Unsupported layout: [2:I4]\"\n+                    IS_LE ? \"Unsupported layout: [2:i4]\" : \"Unsupported layout: [2:I4]\"\n@@ -127,1 +127,1 @@\n-                    byteorder ? \"Unsupported layout: 2%i4\" : \"Unsupported layout: 2%I4\"\n+                    IS_LE ? \"Unsupported layout: 2%i4\" : \"Unsupported layout: 2%I4\"\n@@ -132,1 +132,1 @@\n-                    byteorder ? \"Unsupported layout: 2%a8\" : \"Unsupported layout: 2%A8\"\n+                    IS_LE ? \"Unsupported layout: 2%a8\" : \"Unsupported layout: 2%A8\"\n@@ -137,1 +137,1 @@\n-                    byteorder ? \"Unsupported layout: 4%c2\" : \"Unsupported layout: 4%C2\"\n+                    IS_LE ? \"Unsupported layout: 4%c2\" : \"Unsupported layout: 4%C2\"\n@@ -146,1 +146,1 @@\n-                    byteorder ? \"Unsupported layout: 1%s2\" : \"Unsupported layout: 1%S2\"\n+                    IS_LE ? \"Unsupported layout: 1%s2\" : \"Unsupported layout: 1%S2\"\n@@ -156,1 +156,1 @@\n-                    byteorder ? \"Unsupported layout: 1%s2\" : \"Unsupported layout: 1%S2\"\n+                    IS_LE ? \"Unsupported layout: 1%s2\" : \"Unsupported layout: 1%S2\"\n@@ -164,1 +164,1 @@\n-                    byteorder ? \"Unsupported layout: 1%i4\" : \"Unsupported layout: 1%I4\"\n+                    IS_LE ? \"Unsupported layout: 1%i4\" : \"Unsupported layout: 1%I4\"\n@@ -177,1 +177,1 @@\n-                    byteorder ? \"Unsupported layout: I4\" : \"Unsupported layout: i4\"\n+                    IS_LE ? \"Unsupported layout: I4\" : \"Unsupported layout: i4\"\n@@ -182,1 +182,1 @@\n-                    byteorder ? \"Unsupported layout: I4\" : \"Unsupported layout: i4\"\n+                    IS_LE ? \"Unsupported layout: I4\" : \"Unsupported layout: i4\"\n@@ -187,1 +187,1 @@\n-                    byteorder ? \"Unsupported layout: I4\" : \"Unsupported layout: i4\"\n+                    IS_LE ? \"Unsupported layout: I4\" : \"Unsupported layout: i4\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    boolean byteorder = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;\n+    boolean IS_LE = ByteOrder.nativeOrder() == ByteOrder.LITTLE_ENDIAN;\n@@ -265,1 +265,1 @@\n-        assertEquals(padding.toString(), byteorder ? \"[i4](struct)\" : \"[I4](struct)\");\n+        assertEquals(padding.toString(), IS_LE ? \"[i4](struct)\" : \"[I4](struct)\");\n@@ -267,1 +267,1 @@\n-        assertEquals(toStringUnaligned, byteorder ? \"8%[i4](struct)\" : \"8%[I4](struct)\");\n+        assertEquals(toStringUnaligned, IS_LE ? \"8%[i4](struct)\" : \"8%[I4](struct)\");\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -308,55 +308,0 @@\n-\n-    \/**\n-     * This class defines layout constants modelling standard primitive types supported by the S390 ABI.\n-     *\/\n-    public static final class S390 {\n-\n-        private S390() {\n-            \/\/just the one\n-        }\n-\n-        \/**\n-         * The {@code bool} native type.\n-         *\/\n-        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n-\n-        \/**\n-         * The {@code char} native type.\n-         *\/\n-        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n-\n-        \/**\n-         * The {@code short} native type.\n-         *\/\n-        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n-\n-        \/**\n-         * The {@code int} native type.\n-         *\/\n-        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n-\n-        \/**\n-         * The {@code long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG;\n-\n-        \/**\n-         * The {@code long long} native type.\n-         *\/\n-        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n-\n-        \/**\n-         * The {@code float} native type.\n-         *\/\n-        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n-\n-        \/**\n-         * The {@code double} native type.\n-         *\/\n-        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n-\n-        \/**\n-         * The {@code T*} native type.\n-         *\/\n-        public static final AddressLayout C_POINTER = SharedUtils.C_POINTER;\n-    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/platform\/PlatformLayouts.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"modified"}]}