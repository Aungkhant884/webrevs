{"files":[{"patch":"@@ -816,2 +816,2 @@\n-    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ] to \"\n-                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \" ]\",\n+    log_debug(cds)(\"Relocating archive from [\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"] to \"\n+                   \"[\" INTPTR_FORMAT \" - \" INTPTR_FORMAT \"]\",\n","filename":"src\/hotspot\/share\/memory\/archiveBuilder.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,0 +218,1 @@\n+    _heap_begin = CompressedOops::begin();\n@@ -1814,0 +1815,2 @@\n+  log_info(cds)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                p2i(header()->heap_begin()), p2i(header()->heap_end()));\n@@ -1821,0 +1824,2 @@\n+  log_info(cds)(\"    heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                p2i(CompressedOops::begin()), p2i(CompressedOops::end()));\n@@ -1840,0 +1845,3 @@\n+    } else if (header()->heap_end() != CompressedOops::end()) {\n+      log_info(cds)(\"CDS heap data need to be relocated to the end of the runtime heap to reduce fragmentation\");\n+      _heap_pointers_need_patching = true;\n@@ -1855,1 +1863,1 @@\n-    address runtime_heap_end = (address)CompressedOops::end();\n+    address runtime_heap_end = CompressedOops::end();\n@@ -1999,0 +2007,1 @@\n+  log_info(cds)(\"patching heap embedded pointers\");\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -202,0 +202,1 @@\n+  address _heap_begin;              \/\/ heap begin at dump time.\n@@ -265,0 +266,1 @@\n+  address heap_begin()                     const { return _heap_begin; }\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -348,0 +348,2 @@\n+    log_info(cds)(\"Heap range = [\" PTR_FORMAT \" - \"  PTR_FORMAT \"]\",\n+                  p2i(CompressedOops::begin()), p2i(CompressedOops::end()));\n","filename":"src\/hotspot\/share\/memory\/heapShared.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -455,0 +455,6 @@\n+    public static Result runWithoutCDS(String... suffix) throws Exception {\n+        AppCDSOptions opts = (new AppCDSOptions());\n+        opts.addSuffix(suffix).setXShareMode(\"off\");;\n+        return new Result(opts, runWithArchive(opts));\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestCommon.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+public class HeapFragmentationApp {\n+    public static void main(String args[]) throws Exception {\n+        int BUF_SIZE = Integer.parseInt(args[0]);\n+        System.out.println(\"allocating byte[\" + BUF_SIZE + \"]\");\n+        byte[] array = new byte[BUF_SIZE];\n+        System.out.println(\"array = \" + array);\n+        System.out.println(\"array.length = \" + array.length);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/HeapFragmentationApp.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Relocate CDS archived regions to the top of the G1 heap\n+ * @bug 8214455\n+ * @requires vm.cds.archived.java.heap\n+ * @requires (sun.arch.data.model == \"64\"  & os.maxMemory > 4g)\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @build HeapFragmentationApp\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar HeapFragmentationApp.jar HeapFragmentationApp\n+ * @run driver HeapFragmentationTest\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+\n+public class HeapFragmentationTest {\n+    public static void main(String[] args) throws Exception {\n+        String mainClass = \"HeapFragmentationApp\";\n+        String appJar = ClassFileInstaller.getJarPath(mainClass + \".jar\");\n+        String appClasses[] = TestCommon.list(mainClass);\n+\n+        \/\/ We run with a 1400m heap, so we should be able to allocate a 1000m buffer, regardless\n+        \/\/ of the heap size chosen at dump time.\n+        String dumpTimeHeapSize = \"-Xmx800m\";\n+        String runTimeHeapSize = \"-Xmx1400m\";\n+        String BUFF_SIZE = Integer.toString(1000 * 1024 * 1024);\n+        String successOutput = \"array.length = \" + BUFF_SIZE;\n+\n+        \/\/ On Linux\/x64, this would (usually, if not affected by ASLR) force the low end of\n+        \/\/ the heap to be at 0x600000000. Thus, the heap ranges would be\n+        \/\/\n+        \/\/ dump time:  [0x600000000 ... 0x600000000 + 800m]\n+        \/\/                                            [AHR] <- archived heap regions are dumped at here\n+        \/\/\n+        \/\/ run  time:  [0x600000000 ...............  0x600000000 + 1400m]\n+        \/\/                                                          [AHR] <- archived heap regions are moved to here\n+        \/\/             |<----      max allocatable size      ----->|\n+        String heapBase = \"-XX:HeapBaseMinAddress=0x600000000\";\n+\n+        TestCommon.dump(appJar, appClasses,\n+                        heapBase,\n+                        dumpTimeHeapSize, \"-Xlog:cds=debug\");\n+\n+        String execArgs[] = TestCommon.concat(\"-cp\", appJar,\n+                                              \"-showversion\",\n+                                              heapBase,\n+                                              \"-Xlog:cds=debug\",\n+                                              \"-Xlog:gc+heap+exit\",\n+                                              \"-Xlog:gc,gc+heap,gc+ergo+heap\",\n+                                              \"-XX:+CrashOnOutOfMemoryError\",\n+                                              \"-XX:+IgnoreUnrecognizedVMOptions\",\n+                                              \"-XX:+G1ExitOnExpansionFailure\");\n+\n+        \/\/ First, make sure the test runs without CDS\n+        TestCommon.runWithoutCDS(TestCommon.concat(execArgs, runTimeHeapSize, mainClass, BUFF_SIZE))\n+          .assertNormalExit(successOutput);\n+\n+        \/\/ Run with CDS. The archived heap regions should be relocated to avoid fragmentation.\n+        TestCommon.run(TestCommon.concat(execArgs, runTimeHeapSize, mainClass,  BUFF_SIZE))\n+          .assertNormalExit(successOutput);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/cacheObject\/HeapFragmentationTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+                     -Xlog:cds=debug\n","filename":"test\/jdk\/java\/io\/BufferedInputStream\/LargeCopyWithMark.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}