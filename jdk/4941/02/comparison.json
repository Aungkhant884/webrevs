{"files":[{"patch":"@@ -1015,0 +1015,3 @@\n+     * <p>\n+     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n+     * both for this method and for the built-in division operator \"{@code \/}\".\n@@ -1042,0 +1045,3 @@\n+     * <p>\n+     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n+     * both for this method and for the built-in division operator \"{@code \/}\".\n@@ -1059,0 +1065,74 @@\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * This method is identical to {@link #floorDiv(int,int)} except that it\n+     * throws an {@code ArithmeticException} when the dividend is\n+     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is\n+     * {@code -1} instead of ignoring the integer overflow and returning\n+     * {@code Integer.MIN_VALUE}.\n+     * <p>\n+     * The floor modulus method {@link #floorMod(int,int)} is a suitable\n+     * counterpart both for this method and for the {@link #floorDiv(int,int)}\n+     * method.\n+     * <p>\n+     * For examples, see {@link #floorDiv(int, int)}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see #floorDiv(int, int)\n+     * @since 18\n+     *\/\n+    public static int floorDivExact(int x, int y) {\n+        int r = x \/ y;\n+        if ((x & y & r) >= 0) {\n+            \/\/ if the signs are different and modulo not zero, round down\n+            if ((x ^ y) < 0 && (r * y != x)) {\n+                r--;\n+            }\n+            return r;\n+        }\n+        throw new ArithmeticException(\"integer overflow\");\n+    }\n+\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * This method is identical to {@link #floorDiv(long,long)} except that it\n+     * throws an {@code ArithmeticException} when the dividend is\n+     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is\n+     * {@code -1} instead of ignoring the integer overflow and returning\n+     * {@code Long.MIN_VALUE}.\n+     * <p>\n+     * The floor modulus method {@link #floorMod(long,long)} is a suitable\n+     * counterpart both for this method and for the {@link #floorDiv(long,long)}\n+     * method.\n+     * <p>\n+     * For examples, see {@link #floorDiv(int, int)}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see #floorDiv(long,long)\n+     * @since 18\n+     *\/\n+    public static long floorDivExact(long x, long y) {\n+        long r = x \/ y;\n+        if ((x & y & r) >= 0) {\n+            \/\/ if the signs are different and modulo not zero, round down\n+            if ((x ^ y) < 0 && (r * y != x)) {\n+                r--;\n+            }\n+            return r;\n+        }\n+        throw new ArithmeticException(\"long overflow\");\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -866,0 +866,3 @@\n+     * <p>\n+     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n+     * both for this method and for the built-in division operator \"{@code \/}\".\n@@ -890,0 +893,3 @@\n+     * <p>\n+     * The built-in remainder operator \"{@code %}\" is a suitable counterpart\n+     * both for this method and for the built-in division operator \"{@code \/}\".\n@@ -904,0 +910,60 @@\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * This method is identical to {@link #floorDiv(int,int)} except that it\n+     * throws an {@code ArithmeticException} when the dividend is\n+     * {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and the divisor is\n+     * {@code -1} instead of ignoring the integer overflow and returning\n+     * {@code Integer.MIN_VALUE}.\n+     * <p>\n+     * The floor modulus method {@link #floorMod(int,int)} is a suitable\n+     * counterpart both for this method and for the {@link #floorDiv(int,int)}\n+     * method.\n+     * <p>\n+     * See {@link Math#floorDiv(int, int) Math.floorDiv} for examples and\n+     * a comparison to the integer division {@code \/} operator.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see Math#floorDiv(int, int)\n+     * @since 18\n+     *\/\n+    public static int floorDivExact(int x, int y) {\n+        return Math.floorDivExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * This method is identical to {@link #floorDiv(long,long)} except that it\n+     * throws an {@code ArithmeticException} when the dividend is\n+     * {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the divisor is\n+     * {@code -1} instead of ignoring the integer overflow and returning\n+     * {@code Long.MIN_VALUE}.\n+     * <p>\n+     * The floor modulus method {@link #floorMod(long,long)} is a suitable\n+     * counterpart both for this method and for the {@link #floorDiv(long,long)}\n+     * method.\n+     * <p>\n+     * For examples, see {@link Math#floorDiv(int, int) Math.floorDiv}.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see Math#floorDiv(int, int)\n+     * @see Math#floorDiv(long,long)\n+     * @since 18\n+     *\/\n+    public static long floorDivExact(long x, long y) {\n+        return Math.floorDivExact(x, y);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-     * incrementExact, decrementExact, negateExact methods with\n+     * floorDivExact, incrementExact, decrementExact, negateExact methods with\n@@ -169,0 +169,28 @@\n+        exceptionExpected = false;\n+        try {\n+            \/\/ Test floorDivExact\n+            int q = 0;\n+            try {\n+                q = Math.floorDiv(x, y);\n+            } catch (ArithmeticException e) {\n+                exceptionExpected = true;\n+            }\n+            if (!exceptionExpected && x == Integer.MIN_VALUE && y == -1) {\n+                exceptionExpected = true;\n+            }\n+            int z = Math.floorDivExact(x, y);\n+            if (exceptionExpected) {\n+                fail(\"FAIL: int Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            if (z != q) {\n+                fail(\"FAIL: int Math.floorDivExact(\" + x + \" \/ \" + y + \") = \" +\n+                    z + \"; expected: \" + q);\n+            }\n+        } catch (ArithmeticException ex) {\n+            if (!exceptionExpected) {\n+                fail(\"FAIL: int Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n@@ -220,2 +248,2 @@\n-     * incrementExact, decrementExact, negateExact, toIntExact methods\n-     * with {@code long} arguments.\n+     * floorDivExact, incrementExact, decrementExact, negateExact, toIntExact\n+     * methods with {@code long} arguments.\n@@ -323,0 +351,28 @@\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n+        boolean exceptionExpected = false;\n+        try {\n+            \/\/ Test floorDivExact\n+            long q = 0;\n+            try {\n+                q = Math.floorDiv(x, y);\n+            } catch (ArithmeticException e) {\n+                exceptionExpected = true;\n+            }\n+            if (!exceptionExpected && x == Long.MIN_VALUE && y == -1) {\n+                exceptionExpected = true;\n+            }\n+            long z = Math.floorDivExact(x, y);\n+            if (exceptionExpected) {\n+                fail(\"FAIL: long Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            if (z != q) {\n+                fail(\"FAIL: long Math.floorDivExact(\" + x + \" \/ \" + y + \") = \" +\n+                    z + \"; expected: \" + q);\n+            }\n+        } catch (ArithmeticException ex) {\n+            if (!exceptionExpected) {\n+                fail(\"FAIL: long Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n","filename":"test\/jdk\/java\/lang\/Math\/ExactArithTests.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"}]}