{"files":[{"patch":"@@ -1015,0 +1015,3 @@\n+     * <p>\n+     * It should be noted that the operator \"{@code %}\" is a suitable remainder\n+     * couterpart of this method as it is of the division operator \"{@code \/}\".\n@@ -1042,0 +1045,3 @@\n+     * <p>\n+     * It should be noted that the operator \"{@code %}\" is a suitable remainder\n+     * couterpart of this method as it is of the division operator \"{@code \/}\".\n@@ -1059,0 +1065,91 @@\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * If the dividend is {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and\n+     * the divisor is {@code -1}, then integer overflow occurs and an\n+     * {@code ArithmeticException} is thrown.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * negative infinity (floor) rounding mode.\n+     * The floor rounding mode gives different results from truncation\n+     * when the exact result is negative.\n+     * <ul>\n+     *   <li>If the signs of the arguments are the same, the results of\n+     *       {@code floorDiv} and the {@code \/} operator are the same.  <br>\n+     *       For example, {@code floorDiv(4, 3) == 1} and {@code (4 \/ 3) == 1}.<\/li>\n+     *   <li>If the signs of the arguments are different,  the quotient is negative and\n+     *       {@code floorDiv} returns the integer less than or equal to the quotient\n+     *       and the {@code \/} operator returns the integer closest to zero.<br>\n+     *       For example, {@code floorDiv(-4, 3) == -2},\n+     *       whereas {@code (-4 \/ 3) == -1}.\n+     *   <\/li>\n+     * <\/ul>\n+     * <p>\n+     * It should be noted that the method {@link #floorMod(int,int)} is a\n+     * suitable modulus couterpart of this method as it is of the\n+     * {@link #floorDiv(int,int)} method.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see #floorDiv(int, int)\n+     * @since 18\n+     *\/\n+    public static int floorDivExact(int x, int y) {\n+        int r = x \/ y;\n+        if ((x & y & r) >= 0) {\n+            \/\/ if the signs are different and modulo not zero, round down\n+            if ((x ^ y) < 0 && (r * y != x)) {\n+                r--;\n+            }\n+            return r;\n+        }\n+        throw new ArithmeticException(\"integer overflow\");\n+    }\n+\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * If the dividend is {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the\n+     * divisor is {@code -1}, then integer overflow occurs and an\n+     * {@code ArithmeticException} is thrown.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * negative infinity (floor) rounding mode.\n+     * The floor rounding mode gives different results from truncation\n+     * when the exact result is negative.\n+     * <p>\n+     * For examples, see {@link #floorDiv(int, int)}.\n+     * <p>\n+     * It should be noted that the method {@link #floorMod(long,long)} is a\n+     * suitable modulus couterpart of this method as it is of the\n+     * {@link #floorDiv(long,long)} method.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see #floorDiv(long, long)\n+     * @since 18\n+     *\/\n+    public static long floorDivExact(long x, long y) {\n+        long r = x \/ y;\n+        if ((x & y & r) >= 0) {\n+            \/\/ if the signs are different and modulo not zero, round down\n+            if ((x ^ y) < 0 && (r * y != x)) {\n+                r--;\n+            }\n+            return r;\n+        }\n+        throw new ArithmeticException(\"long overflow\");\n+    }\n+\n@@ -1250,1 +1347,1 @@\n-     * There is one special case, if the dividend is the\n+     * There is one special case, if the dividend is\n@@ -1293,1 +1390,1 @@\n-     * There is one special case, if the dividend is the\n+     * There is one special case, if the dividend is\n@@ -1322,1 +1419,1 @@\n-     * There is one special case, if the dividend is the\n+     * There is one special case, if the dividend is\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Math.java","additions":100,"deletions":3,"binary":false,"changes":103,"status":"modified"},{"patch":"@@ -866,0 +866,3 @@\n+     * <p>\n+     * It should be noted that the operator \"{@code %}\" is a suitable remainder\n+     * couterpart of this method as it is of the division operator \"{@code \/}\".\n@@ -890,0 +893,3 @@\n+     * <p>\n+     * It should be noted that the operator \"{@code %}\" is a suitable remainder\n+     * couterpart of this method as it is of the division operator \"{@code \/}\".\n@@ -904,0 +910,77 @@\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * If the dividend is {@linkplain Integer#MIN_VALUE Integer.MIN_VALUE} and\n+     * the divisor is {@code -1}, then integer overflow occurs and an\n+     * {@code ArithmeticException} is thrown.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * negative infinity (floor) rounding mode.\n+     * The floor rounding mode gives different results from truncation\n+     * when the exact result is negative.\n+     * <ul>\n+     *   <li>If the signs of the arguments are the same, the results of\n+     *       {@code floorDiv} and the {@code \/} operator are the same.  <br>\n+     *       For example, {@code floorDiv(4, 3) == 1} and {@code (4 \/ 3) == 1}.<\/li>\n+     *   <li>If the signs of the arguments are different,  the quotient is negative and\n+     *       {@code floorDiv} returns the integer less than or equal to the quotient\n+     *       and the {@code \/} operator returns the integer closest to zero.<br>\n+     *       For example, {@code floorDiv(-4, 3) == -2},\n+     *       whereas {@code (-4 \/ 3) == -1}.\n+     *   <\/li>\n+     * <\/ul>\n+     * <p>\n+     * It should be noted that the method {@link #floorMod(int,int)} is a\n+     * suitable modulus couterpart of this method as it is of the\n+     * {@link #floorDiv(int,int)} method.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code int} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Integer.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see #floorDiv(int, int)\n+     * @see Math#floorDiv(int, int)\n+     * @since 18\n+     *\/\n+    public static int floorDivExact(int x, int y) {\n+        return Math.floorDivExact(x, y);\n+    }\n+\n+    \/**\n+     * Returns the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * If the dividend is {@linkplain Long#MIN_VALUE Long.MIN_VALUE} and the\n+     * divisor is {@code -1}, then integer overflow occurs and an\n+     * {@code ArithmeticException} is thrown.\n+     * <p>\n+     * Normal integer division operates under the round to zero rounding mode\n+     * (truncation).  This operation instead acts under the round toward\n+     * negative infinity (floor) rounding mode.\n+     * The floor rounding mode gives different results from truncation\n+     * when the exact result is negative.\n+     * <p>\n+     * For examples, see {@link #floorDiv(int, int)}.\n+     * <p>\n+     * It should be noted that the method {@link #floorMod(long,long)} is a\n+     * suitable modulus couterpart of this method as it is of the\n+     * {@link #floorDiv(long,long)} method.\n+     *\n+     * @param x the dividend\n+     * @param y the divisor\n+     * @return the largest (closest to positive infinity)\n+     * {@code long} value that is less than or equal to the algebraic quotient.\n+     * @throws ArithmeticException if the divisor {@code y} is zero, or the\n+     * dividend {@code x} is {@code Long.MIN_VALUE} and the divisor {@code y}\n+     * is {@code -1}.\n+     * @see #floorDiv(long, long)\n+     * @see Math#floorDiv(long, long)\n+     * @since 18\n+     *\/\n+    public static long floorDivExact(long x, long y) {\n+        return Math.floorDivExact(x, y);\n+    }\n+\n@@ -1054,1 +1137,1 @@\n-     * There is one special case, if the dividend is the\n+     * There is one special case, if the dividend is\n@@ -1078,1 +1161,1 @@\n-     * There is one special case, if the dividend is the\n+     * There is one special case, if the dividend is\n@@ -1102,1 +1185,1 @@\n-     * There is one special case, if the dividend is the\n+     * There is one special case, if the dividend is\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":86,"deletions":3,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-     * incrementExact, decrementExact, negateExact methods with\n+     * floorDivExact, incrementExact, decrementExact, negateExact methods with\n@@ -169,0 +169,28 @@\n+        exceptionExpected = false;\n+        try {\n+            \/\/ Test floorDivExact\n+            int q = 0;\n+            try {\n+                q = Math.floorDiv(x, y);\n+            } catch (ArithmeticException e) {\n+                exceptionExpected = true;\n+            }\n+            if (!exceptionExpected && x == Integer.MIN_VALUE && y == -1) {\n+                exceptionExpected = true;\n+            }\n+            int z = Math.floorDivExact(x, y);\n+            if (exceptionExpected) {\n+                fail(\"FAIL: int Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            if (z != q) {\n+                fail(\"FAIL: int Math.floorDivExact(\" + x + \" \/ \" + y + \") = \" +\n+                    z + \"; expected: \" + q);\n+            }\n+        } catch (ArithmeticException ex) {\n+            if (!exceptionExpected) {\n+                fail(\"FAIL: int Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n@@ -220,2 +248,2 @@\n-     * incrementExact, decrementExact, negateExact, toIntExact methods\n-     * with {@code long} arguments.\n+     * floorDivExact, incrementExact, decrementExact, negateExact, toIntExact\n+     * methods with {@code long} arguments.\n@@ -323,0 +351,28 @@\n+                    \"; Unexpected exception: \" + ex);\n+            }\n+        }\n+\n+        boolean exceptionExpected = false;\n+        try {\n+            \/\/ Test floorDivExact\n+            long q = 0;\n+            try {\n+                q = Math.floorDiv(x, y);\n+            } catch (ArithmeticException e) {\n+                exceptionExpected = true;\n+            }\n+            if (!exceptionExpected && x == Long.MIN_VALUE && y == -1) {\n+                exceptionExpected = true;\n+            }\n+            long z = Math.floorDivExact(x, y);\n+            if (exceptionExpected) {\n+                fail(\"FAIL: long Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n+                    \"; expected ArithmeticException not thrown\");\n+            }\n+            if (z != q) {\n+                fail(\"FAIL: long Math.floorDivExact(\" + x + \" \/ \" + y + \") = \" +\n+                    z + \"; expected: \" + q);\n+            }\n+        } catch (ArithmeticException ex) {\n+            if (!exceptionExpected) {\n+                fail(\"FAIL: long Math.floorDivExact(\" + x + \" \/ \" + y + \")\" +\n","filename":"test\/jdk\/java\/lang\/Math\/ExactArithTests.java","additions":59,"deletions":3,"binary":false,"changes":62,"status":"modified"}]}