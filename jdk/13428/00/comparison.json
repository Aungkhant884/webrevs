{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,1 @@\n+    private long initCounterValue;\n@@ -339,1 +340,3 @@\n-                counter = ((long)chaParams.getCounter()) & 0x00000000FFFFFFFFL;\n+                initCounterValue = ((long)chaParams.getCounter()) &\n+                        0x00000000FFFFFFFFL;\n+                counter = initCounterValue;\n@@ -548,1 +551,2 @@\n-        \/\/ assigning them to the object.\n+        \/\/ assigning them to the object.  Key and nonce uniqueness\n+        \/\/ protection is for encryption operations only.\n@@ -550,1 +554,3 @@\n-        checkKeyAndNonce(newKeyBytes, newNonce);\n+        if (opmode == Cipher.ENCRYPT_MODE) {\n+            checkKeyAndNonce(newKeyBytes, newNonce);\n+        }\n@@ -707,3 +713,2 @@\n-            \/\/ Regardless of what happens, the cipher cannot be used for\n-            \/\/ further processing until it has been freshly initialized.\n-            initialized = false;\n+            \/\/ Reset the cipher's state to post-init values.\n+            resetStartState();\n@@ -745,3 +750,2 @@\n-            \/\/ Regardless of what happens, the cipher cannot be used for\n-            \/\/ further processing until it has been freshly initialized.\n-            initialized = false;\n+            \/\/ Reset the cipher's state to post-init values.\n+            resetStartState();\n@@ -1173,0 +1177,17 @@\n+    \/**\n+     * reset the Cipher's state to the values it had after\n+     * the initial init() call.\n+     *\n+     * Note: The cipher's internal \"initialized\" field is set differently\n+     * for ENCRYPT_MODE and DECRYPT_MODE in order to allow DECRYPT_MODE\n+     * ciphers to reuse the key\/nonce\/counter values.  This kind of reuse\n+     * is disallowed in ENCRYPT_MODE.\n+     *\/\n+    private void resetStartState() {\n+        keyStrLimit = 0;\n+        keyStrOffset = 0;\n+        counter = initCounterValue;\n+        aadDone = false;\n+        initialized = (direction == Cipher.DECRYPT_MODE);\n+    }\n+\n@@ -1278,1 +1299,2 @@\n-            counter = 1;\n+            initCounterValue = 1;\n+            counter = initCounterValue;\n@@ -1350,1 +1372,2 @@\n-            counter = 1;\n+            initCounterValue = 1;\n+            counter = initCounterValue;\n","filename":"src\/java.base\/share\/classes\/com\/sun\/crypto\/provider\/ChaCha20Cipher.java","additions":35,"deletions":12,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8153029\n+ * @bug 8153029 8305091\n@@ -379,1 +379,1 @@\n-                \/\/ Initialize and encrypt\n+                \/\/ Initialize and decrypt\n@@ -387,11 +387,4 @@\n-                \/\/ Now attempt to encrypt again without changing the key\/IV\n-                \/\/ This should fail.\n-                try {\n-                    if (algorithm.equals(ALG_CC20_P1305)) {\n-                        cipher.updateAAD(testData.aad);\n-                    }\n-                    cipher.doFinal(testData.input);\n-                    throw new RuntimeException(\n-                            \"Expected IllegalStateException not thrown\");\n-                } catch (IllegalStateException ise) {\n-                    \/\/ Do nothing, this is what we expected to happen\n+                \/\/ Now attempt to decrypt again without changing the key\/IV\n+                \/\/ We allow this scenario.\n+                if (algorithm.equals(ALG_CC20_P1305)) {\n+                    cipher.updateAAD(testData.aad);\n@@ -399,0 +392,1 @@\n+                cipher.doFinal(testData.input);\n@@ -411,1 +405,2 @@\n-     * match.  Then attempt to reuse the cipher without initialization.\n+     * match.  Then use the uncorrupted test vector input and attempt to\n+     * reuse the cipher without initialization.\n@@ -444,10 +439,10 @@\n-                \/\/ Make sure that despite the exception, the Cipher object is\n-                \/\/ not in a state that would leave it initialized and able\n-                \/\/ to process future decryption operations without init.\n-                try {\n-                    cipher.updateAAD(testData.aad);\n-                    cipher.doFinal(testData.input);\n-                    throw new RuntimeException(\n-                            \"Expected IllegalStateException not thrown\");\n-                } catch (IllegalStateException ise) {\n-                    \/\/ Do nothing, this is what we expected to happen\n+                \/\/ Even though an exception occurred during decryption, the\n+                \/\/ Cipher object should be returned to its post-init state.\n+                \/\/ Since this is a decryption operation, we should allow\n+                \/\/ key\/nonce reuse.  It should properly decrypt the uncorrupted\n+                \/\/ input.\n+                cipher.updateAAD(testData.aad);\n+                byte[] pText = cipher.doFinal(testData.input);\n+                if (!Arrays.equals(pText, testData.expOutput)) {\n+                    throw new RuntimeException(\"FAIL: Attempted decryption \" +\n+                            \"did not match expected plaintext\");\n@@ -565,1 +560,5 @@\n-                cipher.doFinal(testData.input);\n+                byte[] pText = cipher.doFinal(testData.input);\n+                if (!Arrays.equals(pText, testData.expOutput)) {\n+                    throw new RuntimeException(\"FAIL: Attempted decryption \" +\n+                            \"did not match expected plaintext\");\n+                }\n@@ -569,8 +568,3 @@\n-                \/\/ the same key and nonce should fail.\n-                try {\n-                    cipher.init(testData.direction, key, spec);\n-                    throw new RuntimeException(\n-                            \"Expected InvalidKeyException not thrown\");\n-                } catch (InvalidKeyException ike) {\n-                    \/\/ Do nothing, this is what we expected to happen\n-                }\n+                \/\/ the same key and nonce is allowed.\n+                cipher.init(testData.direction, key, spec);\n+                System.out.println(\"Successful reinit in DECRYPT_MODE\");\n","filename":"test\/jdk\/com\/sun\/crypto\/provider\/Cipher\/ChaCha20\/ChaCha20NoReuse.java","additions":28,"deletions":34,"binary":false,"changes":62,"status":"modified"}]}