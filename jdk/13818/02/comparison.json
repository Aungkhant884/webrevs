{"files":[{"patch":"@@ -634,2 +634,1 @@\n-  ResizeableResourceHashtable<oop, bool,\n-                              AnyObj::C_HEAP, mtInternal,\n+  ResizeableResourceHashtable<oop, bool, AnyObj::C_HEAP, mtInternal,\n@@ -639,1 +638,1 @@\n-  VerifyCompStrings() : _table(unsigned(_items_count \/ 8) + 1), _errors(0) {}\n+  VerifyCompStrings() : _table(unsigned(_items_count \/ 8) + 1, 0 \/* do not resize *\/), _errors(0) {}\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -244,7 +244,3 @@\n-  jlong current_tag = hashmap->find(o);\n-  if (current_tag == 0) {\n-    if (obj_tag != 0) {\n-      \/\/ callback has tagged the object\n-      assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n-      hashmap->add(o, obj_tag);\n-    }\n+  if (obj_tag == 0) {\n+    \/\/ callback has untagged the object, remove the entry if present\n+    hashmap->remove(o);\n@@ -252,9 +248,4 @@\n-    \/\/ object was previously tagged - the callback may have untagged\n-    \/\/ the object or changed the tag value\n-    if (obj_tag == 0) {\n-      hashmap->remove(o);\n-    } else {\n-      if (obj_tag != current_tag) {\n-        hashmap->update(o, obj_tag);\n-      }\n-    }\n+    \/\/ object was previously tagged or not present - the callback may have\n+    \/\/ changed the tag value\n+    assert(Thread::current()->is_VM_thread(), \"must be VMThread\");\n+    hashmap->add(o, obj_tag);\n@@ -350,1 +341,0 @@\n-  jlong found_tag = hashmap->find(o);\n@@ -352,7 +342,3 @@\n-  \/\/ if the object is not already tagged then we tag it\n-  if (found_tag == 0) {\n-    if (tag != 0) {\n-      hashmap->add(o, tag);\n-    } else {\n-      \/\/ no-op\n-    }\n+  if (tag == 0) {\n+    \/\/ remove the entry if present\n+    hashmap->remove(o);\n@@ -360,8 +346,3 @@\n-    \/\/ if the object is already tagged then we either update\n-    \/\/ the tag (if a new tag value has been provided)\n-    \/\/ or remove the object if the new tag value is 0.\n-    if (tag == 0) {\n-      hashmap->remove(o);\n-    } else {\n-      hashmap->update(o, tag);\n-    }\n+    \/\/ if the object is already tagged or not present then we add\/update\n+    \/\/ the tag\n+    hashmap->add(o, tag);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":13,"deletions":32,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  assert(src._obj != nullptr, \"must be set\");\n+  if (src._obj != nullptr) {\n@@ -40,3 +40,3 @@\n-  \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent, like during\n-  \/\/ a heap walk.  The object needs to be kept alive when it is published.\n-  Universe::heap()->keep_alive(src._obj);\n+    \/\/ obj was read with AS_NO_KEEPALIVE, or equivalent, like during\n+    \/\/ a heap walk.  The object needs to be kept alive when it is published.\n+    Universe::heap()->keep_alive(src._obj);\n@@ -44,8 +44,1 @@\n-  _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n-  _obj = nullptr;\n-}\n-\n-JvmtiTagMapKey::~JvmtiTagMapKey() {\n-  \/\/ If obj is set null it out, this is called for stack object on lookup,\n-  \/\/ and it should not have a WeakHandle created for it yet.\n-  if (_obj != nullptr) {\n+    _wh = WeakHandle(JvmtiExport::weak_tag_storage(), src._obj);\n@@ -53,1 +46,0 @@\n-    assert(_wh.is_null(), \"WeakHandle should be null\");\n@@ -55,1 +47,3 @@\n-    _wh.release(JvmtiExport::weak_tag_storage());\n+    \/\/ resizing needs to create a copy.\n+    _wh = src._wh;\n+    _obj = nullptr;\n@@ -59,0 +53,4 @@\n+void JvmtiTagMapKey::release_weak_handle() const {\n+  _wh.release(JvmtiExport::weak_tag_storage());\n+}\n+\n@@ -69,1 +67,4 @@\n-JvmtiTagMapTable::JvmtiTagMapTable() : _table(Constants::_table_size) {}\n+static const int INITIAL_TABLE_SIZE = 1007;\n+static const int MAX_TABLE_SIZE     = 0x3fffffff;\n+\n+JvmtiTagMapTable::JvmtiTagMapTable() : _table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {}\n@@ -74,0 +75,1 @@\n+      entry.release_weak_handle();\n@@ -107,9 +109,15 @@\n-  bool is_added = false;\n-  _table.put_if_absent(new_entry, tag, &is_added);\n-  assert(is_added, \"should be added\");\n-}\n-\n-void JvmtiTagMapTable::update(oop obj, jlong tag) {\n-  JvmtiTagMapKey new_entry(obj);\n-  bool is_updated = _table.put(new_entry, tag) == false;\n-  assert(is_updated, \"should be updated and not added\");\n+  bool is_added;\n+  if (obj->fast_no_hash_check()) {\n+    \/\/ Can't be in the table so add it fast.\n+    is_added = _table.put_when_absent(new_entry, tag);\n+  } else {\n+    jlong* value = _table.put_if_absent(new_entry, tag, &is_added);\n+    *value = tag; \/\/ assign the new tag\n+  }\n+  if (is_added) {\n+    if (_table.maybe_grow(5, true \/* use_large_table_sizes *\/)) {\n+      int max_bucket_size = DEBUG_ONLY(_table.verify()) NOT_DEBUG(0);\n+      log_info(jvmti, table) (\"JvmtiTagMap table resized to %d for %d entries max bucket %d\",\n+                              _table.table_size(), _table.number_of_entries(), max_bucket_size);\n+    }\n+  }\n@@ -120,2 +128,4 @@\n-  bool is_removed = _table.remove(jtme);\n-  assert(is_removed, \"remove not succesfull.\");\n+  auto clean = [] (const JvmtiTagMapKey& entry, jlong tag) {\n+    entry.release_weak_handle();\n+  };\n+  _table.remove(jtme, clean);\n@@ -128,4 +138,0 @@\n-void JvmtiTagMapTable::resize_if_needed() {\n-  _table.maybe_grow();\n-}\n-\n@@ -141,0 +147,1 @@\n+        entry.release_weak_handle();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":37,"deletions":30,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -51,3 +51,0 @@\n-  ~JvmtiTagMapKey();\n-\n-  void resolve();\n@@ -56,0 +53,1 @@\n+  void release_weak_handle() const;\n@@ -76,4 +74,0 @@\n- enum Constants {\n-  _table_size  = 1007\n- };\n-\n@@ -81,1 +75,0 @@\n-  void resize_if_needed();\n@@ -90,1 +83,0 @@\n-  void update(oop obj, jlong tag);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -88,0 +88,25 @@\n+\n+  \/\/ Calculate next \"good\" hashtable size based on requested count\n+  int calculate_resize(bool use_large_table_sizes) const {\n+    const int resize_factor = 2;     \/\/ by how much we will resize using current number of entries\n+\n+    \/\/ possible hashmap sizes - odd primes that roughly double in size.\n+    \/\/ To avoid excessive resizing the odd primes from 4801-76831 and\n+    \/\/ 76831-307261 have been removed.\n+    const int large_table_sizes[] =  { 107, 1009, 2017, 4049, 5051, 10103, 20201,\n+                                       40423, 76831, 307261, 614563, 1228891, 2457733,\n+                                       4915219, 9830479, 19660831, 39321619, 78643219 };\n+    const int large_array_size = sizeof(large_table_sizes)\/sizeof(int);\n+\n+    int requested = resize_factor * BASE::number_of_entries();\n+    int start_at = use_large_table_sizes ? 8 : 0;\n+    int newsize;\n+    for (int i = start_at; i < large_array_size; i++) {\n+      newsize = large_table_sizes[i];\n+      if (newsize >= requested) {\n+        return newsize;\n+      }\n+    }\n+    return requested; \/\/ greater than a size in the table\n+  }\n+\n@@ -89,1 +114,1 @@\n-  ResizeableResourceHashtable(unsigned size, unsigned max_size = 0)\n+  ResizeableResourceHashtable(unsigned size, unsigned max_size)\n@@ -94,1 +119,1 @@\n-  bool maybe_grow(int load_factor = 8) {\n+  bool maybe_grow(int load_factor = 8, bool use_large_table_sizes = false) {\n@@ -100,1 +125,1 @@\n-      unsigned new_size = MIN2<unsigned>(old_size * 2, _max_size);\n+      unsigned new_size = MIN2<unsigned>(calculate_resize(use_large_table_sizes), _max_size);\n@@ -117,1 +142,1 @@\n-        unsigned hash = HASH(node->_key);\n+        unsigned hash = node->_hash;\n@@ -134,0 +159,22 @@\n+\n+#ifdef ASSERT\n+  int verify() {\n+    Node** table = BASE::_table;\n+    \/\/ Return max bucket size.  If hashcode is broken, this will be\n+    \/\/ too high.\n+    int max_bucket_size = 0;\n+    int index = 0;\n+    Node* const* bucket = table;\n+    while (bucket < &table[BASE::_table_size]) {\n+      int count = 0;\n+      Node* node = *bucket;\n+      while (node != nullptr) {\n+        count++;\n+        node = node->_next;\n+      }\n+      max_bucket_size = MAX2(count, max_bucket_size);\n+      ++bucket;\n+    }\n+    return max_bucket_size;\n+  }\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":51,"deletions":4,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -43,2 +43,3 @@\n-  ResourceHashtableNode(unsigned hash, K const& key, V const& value) :\n-    _hash(hash), _key(key), _value(value), _next(nullptr) {}\n+  ResourceHashtableNode(unsigned hash, K const& key, V const& value,\n+                        ResourceHashtableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(value), _next(next) {}\n@@ -47,2 +48,3 @@\n-  ResourceHashtableNode(unsigned hash, K const& key) :\n-    _hash(hash), _key(key), _value(), _next(nullptr) {}\n+  ResourceHashtableNode(unsigned hash, K const& key,\n+                        ResourceHashtableNode* next = nullptr) :\n+    _hash(hash), _key(key), _value(), _next(next) {}\n@@ -139,0 +141,23 @@\n+ \/**\n+  * Inserts a value in the front of the table, assuming that\n+  * the entry is absent.\n+  * The table must be locked for the get or test that the entry\n+  * is absent, and for this operation.\n+  * This is a faster variant of put_if_absent because it adds to the\n+  * head of the bucket, and doesn't search the bucket.\n+  * @return: true: a new item is always added\n+  *\/\n+  bool put_when_absent(K const& key, V const& value) {\n+    unsigned hv = HASH(key);\n+    unsigned index = hv % table_size();\n+    assert(*lookup_node(hv, key) == nullptr, \"use put_if_absent\");\n+    Node** ptr = bucket_at(index);\n+    if (ALLOC_TYPE == AnyObj::C_HEAP) {\n+      *ptr = new (MEM_TYPE) Node(hv, key, value, *ptr);\n+    } else {\n+      *ptr = new Node(hv, key, value, *ptr);\n+    }\n+    _number_of_entries ++;\n+    return true;\n+  }\n+\n@@ -205,2 +230,2 @@\n-\n-  bool remove(K const& key) {\n+  template<typename Function>\n+  bool remove(K const& key, Function function) {\n@@ -213,0 +238,1 @@\n+      function(node->_key, node->_value);\n@@ -222,0 +248,5 @@\n+  bool remove(K const& key) {\n+    auto dummy = [&] (K& k, V& v) { };\n+    return remove(key, dummy);\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":37,"deletions":6,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8306843\n+ * @summary Test that 10M tags doesn't time out.\n+ * @requires vm.jvmti\n+ * @run main\/othervm\/native -agentlib:TagMapTest\n+ *                          -Xlog:jvmti+table\n+ *                          TagMapTest\n+ *\/\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+public class TagMapTest {\n+    private static final List<TagMapTest> items = new ArrayList<>();\n+\n+    private static native void setTag(Object object);\n+    private static native long getTag(Object object);\n+    private static native void iterate(boolean tagged);\n+\n+    public static void main(String[] args) {\n+        System.loadLibrary(\"TagMapTest\");\n+        for (int i = 0; i < 10_000_000; i++) {\n+            items.add(new TagMapTest());\n+        }\n+\n+        long startTime = System.nanoTime();\n+        for (TagMapTest item : items) {\n+            setTag(item);\n+        }\n+        System.out.println(\"setTag: \" + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + \" ms\");\n+\n+        startTime = System.nanoTime();\n+        for (TagMapTest item : items) {\n+            getTag(item);\n+        }\n+        System.out.println(\"getTag: \" + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + \" ms\");\n+\n+        startTime = System.nanoTime();\n+        iterate(true);\n+        System.out.println(\"iterate tagged: \" + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + \" ms\");\n+\n+        startTime = System.nanoTime();\n+        iterate(false);\n+        System.out.println(\"iterate all: \" + TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime) + \" ms\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetTag\/TagMapTest.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jvmti.h>\n+#include <cstdlib>\n+#include <cstring>\n+\n+namespace {\n+    jlong nextTag = 1;\n+    jvmtiEnv *jvmti = NULL;\n+\n+    void checkJvmti(int code, const char* message) {\n+        if (code != JVMTI_ERROR_NONE) {\n+            printf(\"Error %s: %d\\n\", message, code);\n+            abort();\n+        }\n+    }\n+\n+    jvmtiIterationControl JNICALL heapObjectCallback(jlong class_tag, jlong size, jlong* tag_ptr, void* user_data) {\n+        if (*tag_ptr == 0) {\n+            *tag_ptr = nextTag++;\n+        }\n+        return JVMTI_ITERATION_CONTINUE;\n+    }\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL Java_TagMapTest_setTag(JNIEnv* jni_env, jclass clazz, jobject object) {\n+    checkJvmti(jvmti->SetTag(object, nextTag++), \"could not set tag\");\n+}\n+\n+extern \"C\" JNIEXPORT jlong JNICALL Java_TagMapTest_getTag(JNIEnv* jni_env, jclass clazz, jobject object) {\n+    jlong tag;\n+    checkJvmti(jvmti->GetTag(object, &tag), \"could not get tag\");\n+    return tag;\n+}\n+\n+extern \"C\" JNIEXPORT void JNICALL Java_TagMapTest_iterate(JNIEnv* jni_env, jclass clazz, jboolean tagged) {\n+    checkJvmti(jvmti->IterateOverHeap(tagged ? JVMTI_HEAP_OBJECT_TAGGED : JVMTI_HEAP_OBJECT_EITHER, &heapObjectCallback, NULL), \"could not iterate\");\n+}\n+\n+extern \"C\" JNIEXPORT jint JNICALL Agent_OnLoad(JavaVM *vm, char *options, void *reserved) {\n+    if (vm->GetEnv(reinterpret_cast<void **>(&jvmti), JVMTI_VERSION) != JNI_OK || !jvmti) {\n+        printf(\"Could not initialize JVMTI\\n\");\n+        abort();\n+    }\n+    jvmtiCapabilities capabilities;\n+    memset(&capabilities, 0, sizeof(capabilities));\n+    capabilities.can_tag_objects = 1;\n+    checkJvmti(jvmti->AddCapabilities(&capabilities), \"adding capabilities\");\n+    printf(\"Loaded agent\\n\");\n+    fflush(stdout);\n+    return JVMTI_ERROR_NONE;\n+}\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SetTag\/libTagMapTest.cpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"}]}