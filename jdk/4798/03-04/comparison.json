{"files":[{"patch":"@@ -55,0 +55,1 @@\n+allfonts.emoji=Segoe UI Emoji\n@@ -200,52 +201,52 @@\n-sequence.allfonts=alphabetic\/default,dingbats,symbol\n-\n-sequence.serif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-sequence.sansserif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-sequence.monospaced.GBK=chinese-ms936,alphabetic,dingbats,symbol,chinese-ms936-extb\n-sequence.dialog.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-sequence.dialoginput.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-\n-sequence.serif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-sequence.sansserif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-sequence.monospaced.GB18030=chinese-gb18030,alphabetic,dingbats,symbol,chinese-gb18030-extb\n-sequence.dialog.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-sequence.dialoginput.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-\n-sequence.serif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-sequence.sansserif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-sequence.monospaced.x-windows-950=chinese-ms950,alphabetic,dingbats,symbol,chinese-ms950-extb\n-sequence.dialog.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-sequence.dialoginput.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-\n-sequence.serif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.sansserif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.monospaced.x-MS950-HKSCS=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialog.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialoginput.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-\n-sequence.serif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.sansserif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.monospaced.x-MS950-HKSCS-XP=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialog.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialoginput.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-\n-sequence.allfonts.UTF-8.hi=alphabetic\/1252,devanagari,dingbats,symbol\n-sequence.allfonts.UTF-8.ja=alphabetic,japanese,dingbats,symbol\n-\n-sequence.allfonts.windows-1255=hebrew,alphabetic\/1252,dingbats,symbol\n-\n-sequence.serif.windows-31j=alphabetic,japanese,dingbats,symbol\n-sequence.sansserif.windows-31j=alphabetic,japanese,dingbats,symbol\n-sequence.monospaced.windows-31j=japanese,alphabetic,dingbats,symbol\n-sequence.dialog.windows-31j=alphabetic,japanese,dingbats,symbol\n-sequence.dialoginput.windows-31j=alphabetic,japanese,dingbats,symbol\n-\n-sequence.serif.x-windows-949=alphabetic,korean,dingbats,symbol\n-sequence.sansserif.x-windows-949=alphabetic,korean,dingbats,symbol\n-sequence.monospaced.x-windows-949=korean,alphabetic,dingbats,symbol\n-sequence.dialog.x-windows-949=alphabetic,korean,dingbats,symbol\n-sequence.dialoginput.x-windows-949=alphabetic,korean,dingbats,symbol\n-\n-sequence.allfonts.x-windows-874=alphabetic,thai,dingbats,symbol\n-\n-sequence.fallback=symbols,\\\n+sequence.allfonts=alphabetic\/default,dingbats,symbol,symbols\n+\n+sequence.serif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.sansserif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.monospaced.GBK=chinese-ms936,alphabetic,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.dialog.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.dialoginput.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+\n+sequence.serif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.sansserif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.monospaced.GB18030=chinese-gb18030,alphabetic,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.dialog.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.dialoginput.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+\n+sequence.serif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.sansserif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.monospaced.x-windows-950=chinese-ms950,alphabetic,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialog.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialoginput.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+\n+sequence.serif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.sansserif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.monospaced.x-MS950-HKSCS=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialog.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialoginput.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+\n+sequence.serif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.sansserif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.monospaced.x-MS950-HKSCS-XP=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialog.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialoginput.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+\n+sequence.allfonts.UTF-8.hi=alphabetic\/1252,devanagari,dingbats,symbol,symbols\n+sequence.allfonts.UTF-8.ja=alphabetic,japanese,dingbats,symbol,symbols\n+\n+sequence.allfonts.windows-1255=hebrew,alphabetic\/1252,dingbats,symbol,symbols\n+\n+sequence.serif.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.sansserif.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.monospaced.windows-31j=japanese,alphabetic,dingbats,symbol,symbols\n+sequence.dialog.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.dialoginput.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+\n+sequence.serif.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+sequence.sansserif.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+sequence.monospaced.x-windows-949=korean,alphabetic,dingbats,symbol,symbols\n+sequence.dialog.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+sequence.dialoginput.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+\n+sequence.allfonts.x-windows-874=alphabetic,thai,dingbats,symbol,symbols\n+\n+sequence.fallback=emoji,\\\n@@ -263,0 +264,19 @@\n+exclusion.symbols=000d-0022,0024-0029,002b-002f,003a-00a8,00aa-00ad,00af-02dc,2002-2003,\\\n+                  2005-2005,200d-200d,2013-2014,2018-201a,201c-201e,2020-2022,2026-2026,\\\n+                  2030-2030,2039-203a,2044-2044,20ac-20ac,20e3-20e3,2126-2126,2190-2193,\\\n+                  219a-21a8,21ab-21ff,2206-2206,220f-220f,2211-2212,2219-221a,221e-221e,\\\n+                  222b-222b,2248-2248,2260-2260,231a-231b,23e9-23ec,23f0-23f0,23f3-23f3,\\\n+                  24b6-24c1,24c3-24cf,25a0-25a9,25ac-25b5,25b7-25bf,25c1-25fa,25fd-25ff,\\\n+                  260f-2610,2612-2612,2614-2615,263b-263b,263f-263f,2641-2641,2643-2653,\\\n+                  2672-267a,267c-267d,267f-267f,2693-2693,26a1-26a6,26a8-26ab,26bd-26be,\\\n+                  26c4-26c5,26c7-26c7,26ce-26ce,26d4-26d4,26dd-26dd,26e3-26e3,26ea-26ea,\\\n+                  26f2-26f3,26f5-26f5,26fa-26fa,26fd-26fd,2701-2701,2703-2705,270a-270b,\\\n+                  270e-270e,2710-2710,2713-2713,2715-2715,2717-2718,2728-2728,2731-2732,\\\n+                  2735-2743,2745-2746,2748-274c,274e-274e,2753-2755,2757-2757,2795-2797,\\\n+                  27b0-27b0,27bf-27bf,2936-2937,2b12-2b1c,2b50-2b52,2b55-2b55,3244-3247,\\\n+                  01f000-01f02b,01f0cf-01f0cf,01f172-01f17d,01f180-01f1ff,01f201-01f201,\\\n+                  01f210-01f236,01f238-01f23a,01f250-01f320,01f32d-01f335,01f337-01f37c,\\\n+                  01f37e-01f393,01f3a0-01f3ca,01f3cf-01f3d3,01f3e0-01f3f0,01f3f4-01f3f4,\\\n+                  01f3f8-01f43e,01f440-01f440,01f442-01f4fc,01f4ff-01f53d,01f54b-01f567,\\\n+                  01f57a-01f57a,01f595-01f596,01f5a4-01f5a4,01f5fb-01f64f,01f680-01f6c5,\\\n+                  01f6cc-01f6cc,01f6d0-01f6d2,01f6eb-01f6ec,01f6f4-01f6f6,01f910-01f93a,01f93c-01f9c0\n@@ -329,0 +349,1 @@\n+filename.Segoe_UI_Emoji=seguiemj.ttf\n","filename":"make\/data\/fontconfig\/windows.fontconfig.properties","additions":73,"deletions":52,"binary":false,"changes":125,"status":"modified"},{"patch":"@@ -91,0 +91,25 @@\n+    private static int unicodeToUnits(int unicode, int dstOffset, char[] dst) {\n+        if (unicode >= 0x10000) {\n+            int base = unicode - 0x10000;\n+            dst[dstOffset] = (char)((base >>> 10) + HI_SURROGATE_START);\n+            dst[dstOffset+1] = (char)((base % 0x400) + LO_SURROGATE_START);\n+            return 2;\n+        } else {\n+            dst[dstOffset] = (char) unicode;\n+            return 1;\n+        }\n+    }\n+\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) return charToGlyph(unicode);\n+        final char[] unicodeArray = new char[4];\n+        final int[] glyphArray = new int[4];\n+\n+        int size = unicodeToUnits(unicode, 0, unicodeArray);\n+        size += unicodeToUnits(variationSelector, size, unicodeArray);\n+\n+        nativeCharsToGlyphs(fFont.getNativeFontPtr(), size, unicodeArray, glyphArray);\n+\n+        return glyphArray[0];\n+    }\n+\n@@ -108,3 +133,1 @@\n-            int base = unicode - 0x10000;\n-            surrogates[0] = (char)((base >>> 10) + HI_SURROGATE_START);\n-            surrogates[1] = (char)((base % 0x400) + LO_SURROGATE_START);\n+            unicodeToUnits(unicode, 0, surrogates);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -54,1 +54,19 @@\n-    private int convertToGlyph(int unicode) {\n+    @Override\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) return charToGlyph(unicode);\n+        else {\n+            int glyph = convertToGlyph(unicode, variationSelector);\n+            if (glyph == missingGlyph) glyph = charToGlyph(unicode);\n+            return glyph;\n+        }\n+    }\n+\n+    @Override\n+    protected int convertToGlyph(int unicode) {\n+        int glyph = convertToGlyph(unicode, 0);\n+\/\/        setCachedGlyphCode(unicode, glyph);\n+        return glyph;\n+    }\n+\n+    @Override\n+    protected int convertToGlyph(int unicode, int variationSelector) {\n@@ -57,1 +75,1 @@\n-            int glyphCode = mapper.charToGlyph(unicode);\n+            int glyphCode = mapper.charToVariationGlyph(unicode, variationSelector);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCompositeGlyphMapper.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -80,0 +80,5 @@\n+    GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                       float x, float y) {\n+        throw new InternalError(\"Not implemented\");\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    private static native void getNativeGlyphRenderData(long nativeStrikePtr,\n+                                                        int glyphCode,\n+                                                        double x,\n+                                                        double y,\n+                                                        GlyphRenderData result);\n+\n@@ -224,0 +230,6 @@\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        GlyphRenderData result = new GlyphRenderData();\n+        getNativeGlyphRenderData(getNativeStrikePtr(), glyphCode, x, y, result);\n+        return result;\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CStrike.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                       float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/NativeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/NativeStrike.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -208,9 +208,3 @@\n-\/*\n- * Class:     sun_font_CStrike\n- * Method:    getNativeGlyphOutline\n- * Signature: (JJIDD)Ljava\/awt\/geom\/GeneralPath;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_sun_font_CStrike_getNativeGlyphOutline\n-    (JNIEnv *env, jclass clazz,\n-     jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos)\n+jobject getGlyphOutline(JNIEnv *env, AWTStrike *awtStrike,\n+                        CTFontRef font, CGGlyph glyph,\n+                        jdouble xPos, jdouble yPos)\n@@ -219,3 +213,0 @@\n-\n-JNI_COCOA_ENTER(env);\n-\n@@ -231,5 +222,0 @@\n-    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n-    AWTFont *awtfont = awtStrike->fAWTFont;\n-\n-AWT_FONT_CLEANUP_CHECK(awtfont);\n-\n@@ -241,5 +227,0 @@\n-    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n-\n-    CGGlyph glyph;\n-    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n-\n@@ -258,1 +239,0 @@\n-    CFRelease(font);\n@@ -292,1 +272,0 @@\n-JNI_COCOA_EXIT(env);\n@@ -296,0 +275,174 @@\n+\/*\n+ * Class:     sun_font_CStrike\n+ * Method:    getNativeGlyphOutline\n+ * Signature: (JJIDD)Ljava\/awt\/geom\/GeneralPath;\n+ *\/\n+JNIEXPORT jobject JNICALL\n+Java_sun_font_CStrike_getNativeGlyphOutline\n+        (JNIEnv *env, jclass clazz,\n+         jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos) {\n+    jobject generalPath = NULL;\n+\n+    JNI_COCOA_ENTER(env);\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n+    AWTFont *awtfont = awtStrike->fAWTFont;\n+    AWT_FONT_CLEANUP_CHECK(awtfont);\n+\n+    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n+    CGGlyph glyph;\n+    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n+\n+    generalPath = getGlyphOutline(env, awtStrike, font, glyph, xPos, yPos);\n+\n+    cleanup:\n+    CFRelease(font);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    JNI_COCOA_EXIT(env);\n+\n+    return generalPath;\n+}\n+\n+\/\/ OpenType data is Big-Endian\n+#define GET_BE_INT32(data, i) CFSwapInt32BigToHost(*(const UInt32*) ((const UInt8*) (data) + (i)))\n+#define GET_BE_INT16(data, i) CFSwapInt16BigToHost(*(const UInt16*) ((const UInt8*) (data) + (i)))\n+\n+static bool addBitmapRenderData(JNIEnv *env, AWTStrike *awtStrike,\n+                                CTFontRef font, CGGlyph glyph,\n+                                jdouble xPos, jdouble yPos, jobject result) {\n+    bool success = false;\n+\n+    DECLARE_CLASS_RETURN(jc_GlyphRenderData, \"sun\/font\/GlyphRenderData\", false);\n+    DECLARE_METHOD_RETURN(GlyphRenderDataAddBitmap, jc_GlyphRenderData, \"addBitmap\", \"(DDDDDDIIII[I)V\", false);\n+\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    CTFontDescriptorRef descriptor = NULL;\n+    CGFontRef cgFont = CTFontCopyGraphicsFont(font, &descriptor);\n+\n+    CFDataRef sbixTable = CGFontCopyTableForTag(cgFont, kCTFontTableSbix);\n+    if (sbixTable == NULL) goto cleanup;\n+\n+    \/\/ Parse sbix table\n+    const UInt8* sbix = CFDataGetBytePtr(sbixTable);\n+    UInt32 numStrikes = GET_BE_INT32(sbix, 4);\n+    \/\/ Find last strike which has data for our glyph\n+    \/\/ Last is usually the biggest\n+    const UInt8* glyphData = NULL;\n+    UInt32 size;\n+    UInt16 ppem, ppi;\n+    for (int i = numStrikes - 1; i >= 0; i--) {\n+        const UInt8* strike = sbix + GET_BE_INT32(sbix, 8 + 4 * i);\n+        UInt32 offset = GET_BE_INT32(strike, 4 + 4 * glyph);\n+        size = GET_BE_INT32(strike, 8 + 4 * glyph) - offset;\n+        if (size > 0) {\n+            ppem = GET_BE_INT16(strike, 0);\n+            ppi = GET_BE_INT16(strike, 2);\n+            glyphData = strike + offset;\n+            break;\n+        }\n+    }\n+    if (glyphData == NULL) goto cleanup;\n+\n+    \/\/ Read glyph data\n+    FourCharCode graphicType = GET_BE_INT32(glyphData, 4);\n+    glyphData += 8;\n+    size -= 8;\n+\n+    \/\/ Decode glyph image\n+    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, glyphData, size, NULL);\n+    CGImageRef image = NULL;\n+    if (graphicType == 'jpg ') {\n+        image = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, false, kCGRenderingIntentDefault);\n+    } else if (graphicType == 'png ') {\n+        image = CGImageCreateWithPNGDataProvider(dataProvider, NULL, false, kCGRenderingIntentDefault);\n+    }\n+    CGDataProviderRelease(dataProvider);\n+\n+    if (image != NULL) {\n+        CGBitmapInfo info = CGImageGetBitmapInfo(image);\n+        size_t bits = CGImageGetBitsPerPixel(image);\n+        jint colorModel = -1;\n+        if (info & (kCGImageAlphaPremultipliedLast | kCGImageAlphaLast)) colorModel = 0; \/\/ RGBA\n+        else if (info & (kCGImageAlphaPremultipliedFirst | kCGImageAlphaFirst)) colorModel = 1; \/\/ ARGB\n+        if (colorModel != -1 && (info & kCGBitmapFloatComponents) == 0 && bits == 32) {\n+            size_t width = CGImageGetWidth(image);\n+            size_t height = CGImageGetHeight(image);\n+            size_t pitch = CGImageGetBytesPerRow(image) \/ 4;\n+            dataProvider = CGImageGetDataProvider(image);\n+            CFDataRef data = CGDataProviderCopyData(dataProvider);\n+\n+            jbyteArray array = (*env)->NewIntArray(env, pitch * height);\n+            (*env)->SetIntArrayRegion(env, array, 0, pitch * height, (const jint*) CFDataGetBytePtr(data));\n+            CFRelease(data);\n+\n+            double pointSize = 72.0 * ppem \/ ppi;\n+            double scale = 1.0 \/ pointSize;\n+            font = CTFontCreateWithGraphicsFont(cgFont, pointSize, NULL, descriptor);\n+            CGRect bbox = CTFontGetBoundingRectsForGlyphs(font, kCTFontOrientationDefault, &glyph, NULL, 1);\n+            CFRelease(font);\n+            double tx = bbox.origin.x + xPos * pointSize \/ awtStrike->fSize;\n+            double ty = -bbox.origin.y - (double) height + yPos * pointSize \/ awtStrike->fSize;\n+\n+            jdouble m00 = awtStrike->fTx.a * scale, m10 = awtStrike->fTx.b * scale;\n+            jdouble m01 = -awtStrike->fTx.c * scale, m11 = -awtStrike->fTx.d * scale;\n+            jdouble m02 = m00 * tx + m01 * ty, m12 = m10 * tx + m11 * ty;\n+\n+            (*env)->CallVoidMethod(env, result, GlyphRenderDataAddBitmap,\n+                                   m00, m10, m01, m11, m02, m12,\n+                                   width, height, pitch, 0, array);\n+            success = true;\n+        }\n+        CGImageRelease(image);\n+    }\n+\n+    \/\/ Cleanup\n+    cleanup:\n+    if (cgFont) CFRelease(cgFont);\n+    if (descriptor) CFRelease(descriptor);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    return success;\n+}\n+\n+\/*\n+ * Class:     sun_font_CStrike\n+ * Method:    getNativeGlyphRenderData\n+ * Signature: (JIDDLsun\/font\/GlyphRenderData;)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_font_CStrike_getNativeGlyphRenderData\n+        (JNIEnv *env, jclass clazz,\n+         jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos, jobject result)\n+{\n+    JNI_COCOA_ENTER(env);\n+\n+    DECLARE_CLASS(jc_GlyphRenderData, \"sun\/font\/GlyphRenderData\");\n+    DECLARE_FIELD(GlyphRenderDataOutline, jc_GlyphRenderData, \"outline\", \"Ljava\/awt\/geom\/GeneralPath;\")\n+\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n+    AWTFont *awtfont = awtStrike->fAWTFont;\n+    AWT_FONT_CLEANUP_CHECK(awtfont);\n+\n+    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n+    CGGlyph glyph;\n+    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n+\n+    if (!addBitmapRenderData(env, awtStrike, font, glyph, xPos, yPos, result)) {\n+        jobject gp = getGlyphOutline(env, awtStrike, font, glyph, xPos, yPos);\n+        if (gp != NULL) {\n+            (*env)->SetObjectField(env, result, GlyphRenderDataOutline, gp);\n+        }\n+    }\n+\n+    cleanup:\n+    CFRelease(font);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    JNI_COCOA_EXIT(env);\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":177,"deletions":24,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -588,0 +588,1 @@\n+    glyphInfo->format = (UInt8) pixelSize;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+#define VS_START  0xFE00\n+#define VS_END    0xFE0F\n+#define VSS_START 0xE0100\n+#define VSS_END   0xE01FF\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CoreTextSupport.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,11 @@\n+int NextUnicode(const UniChar unicodes[], UnicodeScalarValue *codePoint, const size_t index, const size_t limit) {\n+    if (index >= limit) return 0;\n+    UniChar unicode = unicodes[index];\n+    UniChar nextUnicode = (index+1) < limit ? unicodes[index+1] : 0;\n+    bool surrogatePair = unicode >= HI_SURROGATE_START && unicode <= HI_SURROGATE_END\n+                         && nextUnicode >= LO_SURROGATE_START && nextUnicode <= LO_SURROGATE_END;\n+    *codePoint = surrogatePair ? (((int)(unicode - HI_SURROGATE_START)) << 10)\n+                                + nextUnicode - LO_SURROGATE_START + 0x10000 : unicode;\n+    return surrogatePair ? 2 : 1;\n+}\n+\n@@ -104,6 +115,11 @@\n-    size_t i;\n-    for (i = 0; i < count; i++) {\n-        UniChar unicode = unicodes[i];\n-        UniChar nextUnicode = (i+1) < count ? unicodes[i+1] : 0;\n-        bool surrogatePair = unicode >= HI_SURROGATE_START && unicode <= HI_SURROGATE_END\n-                             && nextUnicode >= LO_SURROGATE_START && nextUnicode <= LO_SURROGATE_END;\n+    size_t i, size;\n+    for (i = 0; i < count; i += size) {\n+        UnicodeScalarValue codePoint, variationCodePoint;\n+        int codePointSize = size = NextUnicode(unicodes, &codePoint, i, count);\n+        if (size == 0) break;\n+\n+        int variationSize = NextUnicode(unicodes, &variationCodePoint, i + size , count);\n+        bool hasVariationSelector = variationSize > 0 &&\n+                ((variationCodePoint >= VSS_START && variationCodePoint <= VSS_END) ||\n+                 (variationCodePoint >= VS_START && variationCodePoint <= VS_END));\n+        if (hasVariationSelector) size += variationSize;\n@@ -112,1 +128,1 @@\n-        if (glyph > 0) {\n+        if (glyph > 0 && (!hasVariationSelector || glyphs[i + codePointSize] > 0)) {\n@@ -114,1 +130,0 @@\n-            if (surrogatePair) i++;\n@@ -119,1 +134,1 @@\n-                                                                          surrogatePair ? 2 : 1);\n+                                                                          size);\n@@ -121,1 +136,1 @@\n-            CTFontGetGlyphsForCharacters(fallback, &unicodes[i], &glyphs[i], surrogatePair ? 2 : 1);\n+            CTFontGetGlyphsForCharacters(fallback, &unicodes[i], &glyphs[i], size);\n@@ -127,2 +142,0 @@\n-            int codePoint = surrogatePair ? (((int)(unicode - HI_SURROGATE_START)) << 10)\n-                                            + nextUnicode - LO_SURROGATE_START + 0x10000 : unicode;\n@@ -133,1 +146,0 @@\n-        if (surrogatePair) i++;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CoreTextSupport.m","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-        if (ginfo->rowBytes == ginfo->width) {\n+        if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE) {\n@@ -727,1 +727,1 @@\n-        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+        } else if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_BGRA) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1068,1 +1068,1 @@\n-    final int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n+    static int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n@@ -1081,1 +1081,1 @@\n-    final char getFormatCharGlyph(int charCode) {\n+    static char getFormatCharGlyph(int charCode) {\n@@ -1148,3 +1148,1 @@\n-        static final int VS_NOGLYPH = 0;\n-        private int getGlyph(int charCode, int variationSelector) {\n-            int targetSelector = -1;\n+        private int findVariationSelectorIndex(int variationSelector) {\n@@ -1153,2 +1151,1 @@\n-                    targetSelector = i;\n-                    break;\n+                    return i;\n@@ -1157,0 +1154,5 @@\n+            return -1;\n+        }\n+\n+        static final int VS_NOGLYPH = 0;\n+        private int getGlyph(int charCode, int targetSelector) {\n@@ -1172,0 +1174,1 @@\n+        if (variationSelector == 0) return getGlyph(charCode);\n@@ -1173,8 +1176,9 @@\n-        if (uvs == null) {\n-            glyph = getGlyph(charCode);\n-        } else {\n-            int result = uvs.getGlyph(charCode, variationSelector);\n-            if (result > 0) {\n-                glyph = (char)(result & 0xFFFF);\n-            } else {\n-                glyph = getGlyph(charCode);\n+        if (uvs != null) {\n+            int targetSelector = uvs.findVariationSelectorIndex(variationSelector);\n+            if (targetSelector != -1) {\n+                int result = uvs.getGlyph(charCode, targetSelector);\n+                if (result > 0) {\n+                    glyph = (char)(result & 0xFFFF);\n+                } else {\n+                    glyph = getGlyph(charCode);\n+                }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CMap.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -120,1 +120,5 @@\n-    private int convertToGlyph(int unicode) {\n+    protected int convertToGlyph(int unicode) {\n+        return convertToGlyph(unicode, 0);\n+    }\n+\n+    protected int convertToGlyph(int unicode, int variationSelector) {\n@@ -125,1 +129,1 @@\n-                int glyphCode = mapper.charToGlyph(unicode);\n+                int glyphCode = mapper.charToVariationGlyph(unicode, variationSelector);\n@@ -128,1 +132,1 @@\n-                    setCachedGlyphCode(unicode, glyphCode);\n+                    if (variationSelector == 0) setCachedGlyphCode(unicode, glyphCode);\n@@ -136,0 +140,22 @@\n+    @Override\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) return charToGlyph(unicode);\n+        else {\n+            int glyph = convertToGlyph(unicode, variationSelector);\n+            \/\/ Glyph variation not found, fallback to base glyph.\n+            \/\/ In fallback from variation glyph we ignore excluded chars,\n+            \/\/ this is needed for proper display of monochrome emoji (\\ufe0e)\n+            if (glyph == missingGlyph) {\n+                for (int slot = 0; slot < font.numSlots; slot++) {\n+                    CharToGlyphMapper mapper = getSlotMapper(slot);\n+                    glyph = mapper.charToGlyph(unicode);\n+                    if (glyph != mapper.getMissingGlyphCode()) {\n+                        glyph = compositeGlyphCode(slot, glyph);\n+                        break;\n+                    }\n+                }\n+            }\n+            return glyph;\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -172,1 +172,5 @@\n-        return path;\n+        if (path == null) {\n+            return new GeneralPath();\n+        } else {\n+            return path;\n+        }\n@@ -213,0 +217,5 @@\n+\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphRenderData(glyphCode & SLOTMASK, x, y);\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeStrike.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -233,0 +233,10 @@\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                              float x, float y) {\n+        try {\n+            return getScaler().getGlyphRenderData(pScalerContext, glyphCode, x, y);\n+        } catch (FontScalerException fe) {\n+            scaler = FontScaler.getNullScaler();\n+            return getGlyphRenderData(pScalerContext, glyphCode, x, y);\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFont.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -222,1 +222,2 @@\n-            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize)) {\n+            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize) &&\n+            !((TrueTypeFont)fileFont).hasCOLRTable()) {\n@@ -742,1 +743,3 @@\n-        int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);\n+        byte format = StrikeCache.unsafe.getByte(ptr+StrikeCache.formatOffset);\n+        if (format != StrikeCache.PIXEL_FORMAT_LCD) return origMinX;\n+\n@@ -747,4 +750,0 @@\n-        if (rowBytes == width) {\n-            return origMinX;\n-        }\n-\n@@ -907,1 +906,0 @@\n-    private static final GeneralPath NULL_OUTLINE = new GeneralPath();\n@@ -923,1 +921,0 @@\n-            if (gp == null) gp = NULL_OUTLINE;\n@@ -932,6 +929,3 @@\n-        if (gp == NULL_OUTLINE) gp = null;\n-        else {\n-            gp = (GeneralPath)gp.clone(); \/\/ mutable!\n-            if (x != 0f || y != 0f) {\n-                gp.transform(AffineTransform.getTranslateInstance(x, y));\n-            }\n+        gp = (GeneralPath)gp.clone(); \/\/ mutable!\n+        if (x != 0f || y != 0f) {\n+            gp.transform(AffineTransform.getTranslateInstance(x, y));\n@@ -942,0 +936,31 @@\n+    private\n+        WeakReference<ConcurrentHashMap<Integer, GlyphRenderData>> glyphRenderDataMapRef;\n+\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+\n+        GlyphRenderData grd = null;\n+        ConcurrentHashMap<Integer, GlyphRenderData> glyphRenderDataMap = null;\n+\n+        if (glyphRenderDataMapRef != null) {\n+            glyphRenderDataMap = glyphRenderDataMapRef.get();\n+            if (glyphRenderDataMap != null) {\n+                grd = glyphRenderDataMap.get(glyphCode);\n+            }\n+        }\n+\n+        if (grd == null) {\n+            grd = fileFont.getGlyphRenderData(pScalerContext, glyphCode, 0, 0);\n+            if (glyphRenderDataMap == null) {\n+                glyphRenderDataMap = new ConcurrentHashMap<>();\n+                glyphRenderDataMapRef = new WeakReference<>(glyphRenderDataMap);\n+            }\n+            glyphRenderDataMap.put(glyphCode, grd);\n+        }\n+        grd = new GlyphRenderData(grd); \/\/ mutable!\n+        if (x != 0f || y != 0f) {\n+            grd.transform(AffineTransform.getTranslateInstance(x, y));\n+        }\n+        return grd;\n+    }\n+\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFontStrike.java","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -121,1 +121,3 @@\n-        int sl = mapper.charToGlyph(ch) & CompositeGlyphMapper.SLOTMASK;\n+        int nch = nextCodePoint(lim);\n+        int vs = CharToGlyphMapper.isVariationSelector(nch) ? nch : 0;\n+        int sl = mapper.charToVariationGlyph(ch, vs) & CompositeGlyphMapper.SLOTMASK;\n@@ -123,1 +125,10 @@\n-        while ((ch = nextCodePoint(lim)) != DONE && (mapper.charToGlyph(ch) & CompositeGlyphMapper.SLOTMASK) == sl);\n+        do {\n+            if (vs == 0) {\n+                ch = nch;\n+            } else {\n+                ch = nextCodePoint(lim);\n+            }\n+            nch = nextCodePoint(lim);\n+            vs = CharToGlyphMapper.isVariationSelector(nch) ? nch : 0;\n+        } while(ch != DONE && isSameRun(ch, vs, sl));\n+        pushback(nch);\n@@ -129,0 +140,9 @@\n+    private boolean isSameRun(int ch, int variationSelector, int currentSlot) {\n+        \/\/ Every font is meant to be able to render format chars\n+        \/\/ So we make format chars stick to the current font run\n+        if (CMap.getFormatCharGlyph(ch) == CharToGlyphMapper.INVISIBLE_GLYPH_ID) {\n+            return true;\n+        }\n+        return (mapper.charToVariationGlyph(ch, variationSelector) & CompositeGlyphMapper.SLOTMASK) == currentSlot;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontRunIterator.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+    abstract GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                float x, float y)\n+                throws FontScalerException;\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontScaler.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    abstract GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontStrike.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-    public static final int MAX_LAYOUT_CHARCODE = 0x206F;\n+    public static final int MAX_LAYOUT_CHARCODE = CharToGlyphMapper.VSS_END;\n@@ -305,0 +305,15 @@\n+        else if (code >= 0x20d0 && code <= 0x20f0) { \/\/ U+20D0 - U+20F0 combining diacritical marks for symbols\n+            return true;\n+        }\n+        else if (code >= 0x1f1e6 && code <= 0x1f1ff) { \/\/ U+1F1E6 - U+1F1FF flag letters https:\/\/emojipedia.org\/emoji-flag-sequence\/\n+            return true;\n+        }\n+        else if (code == 0x1f3f4) { \/\/ black flag https:\/\/emojipedia.org\/emoji-tag-sequence\/\n+            return true;\n+        }\n+        else if (code >= 0x1f3fb && code <= 0x1f3ff) { \/\/ U+1F3FB - U+1F3FF emoji modifiers\n+            return true;\n+        }\n+        else if (CharToGlyphMapper.isVariationSelector(code)) {\n+            return true;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontUtilities.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -147,1 +147,2 @@\n-        return null;\n+        return FontScaler.getNullScaler().\n+            getGlyphOutline(0L, glyphCode, x,y);\n@@ -165,0 +166,15 @@\n+    synchronized GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                    float x, float y) throws FontScalerException {\n+        if (nativeScaler != 0L) {\n+            GlyphRenderData result = new GlyphRenderData();\n+            getGlyphRenderDataNative(font.get(),\n+                                     pScalerContext,\n+                                     nativeScaler,\n+                                     glyphCode,\n+                                     x, y, result);\n+            return result;\n+        }\n+        return FontScaler.getNullScaler().\n+                getGlyphRenderData(0L, glyphCode, x,y);\n+    }\n+\n@@ -255,0 +271,3 @@\n+    private native void getGlyphRenderDataNative(Font2D font, long pScalerContext,\n+            long pScaler, int glyphCode,\n+            float x, float y, GlyphRenderData result);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FreetypeFontScaler.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.awt.*;\n@@ -30,2 +29,0 @@\n-import java.awt.geom.AffineTransform;\n-import java.util.ArrayList;\n@@ -37,2 +34,0 @@\n-import static sun.font.CharToGlyphMapper.INVISIBLE_GLYPH_ID;\n-\n@@ -285,43 +280,0 @@\n-    public Shape extractOutlineAndSetAsFallback(FontInfo info, GlyphVector gv,\n-                                                float x, float y) {\n-        this.x = x;\n-        this.y = y;\n-        this.lcdRGBOrder = info.lcdRGBOrder;\n-        this.lcdSubPixPos = info.lcdSubPixPos;\n-        StandardGlyphVector sgv = StandardGlyphVector.getStandardGV(gv, info);\n-        usePositions = true;\n-        len = 0;\n-        strikelist = null;\n-        glyphindex = -1;\n-        Shape shape = sgv.getGlyphsOutline(0, sgv.getNumGlyphs(), x, y, this);\n-        if (len > 0) {\n-            AffineTransform dtx = new AffineTransform(info.devTx);\n-            dtx.transform(positions, 0, positions, 0, len);\n-        }\n-        info.fontStrike.getGlyphImagePtrs(glyphData, images, len);\n-        return shape;\n-    }\n-\n-    public void setPosition(float x, float y) {\n-        this.x = x;\n-        this.y = y;\n-    }\n-\n-    @SuppressWarnings(\"unchecked\")\n-    void addFallbackGlyph(StandardGlyphVector.GlyphStrike strike, int glyph, float x, float y) {\n-        if (glyph == INVISIBLE_GLYPH_ID) return;\n-\n-        if (strikelist == null) strikelist = new ArrayList<StandardGlyphVector.GlyphStrike>();\n-        ((ArrayList<StandardGlyphVector.GlyphStrike>) strikelist).add(strike);\n-\n-        int[] gd = glyphData;\n-        float[] pos = positions;\n-        ensureCapacity(len + 1);\n-        if (gd != glyphData && gd != null) System.arraycopy(gd, 0, glyphData, 0, len);\n-        if (pos != positions && pos != null) System.arraycopy(pos, 0, positions, 0, len * 2);\n-        glyphData[len] = glyph;\n-        positions[len*2] = x;\n-        positions[len*2+1] = y;\n-        len++;\n-    }\n-\n@@ -553,1 +505,10 @@\n-        return FontUtilities.isMacOSX || FontUtilities.isLinux;\n+        return true;\n+    }\n+\n+    \/**\n+     * @return {@link StrikeCache#PIXEL_FORMAT_GREYSCALE} for greyscale,\n+     * {@link StrikeCache#PIXEL_FORMAT_LCD} for LCD and {@link StrikeCache#PIXEL_FORMAT_BGRA} for BGRA glyph\n+     *\/\n+    public byte getPixelFormat(int glyphIndex) {\n+        return StrikeCache.unsafe.getByte(images[glyphIndex] +\n+                StrikeCache.formatOffset);\n@@ -557,5 +518,1 @@\n-        int width = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                               StrikeCache.widthOffset);\n-        int rowBytes = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                                  StrikeCache.rowBytesOffset);\n-        return rowBytes == width * 4;\n+        return getPixelFormat(glyphIndex) == StrikeCache.PIXEL_FORMAT_BGRA;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":11,"deletions":54,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\r\n+ * Copyright 2000-2022 JetBrains s.r.o.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+package sun.font;\r\n+\r\n+import jdk.internal.misc.Unsafe;\r\n+\r\n+import java.awt.*;\r\n+import java.awt.geom.AffineTransform;\r\n+import java.awt.geom.GeneralPath;\r\n+import java.awt.image.BufferedImage;\r\n+import java.awt.image.ColorModel;\r\n+import java.awt.image.DirectColorModel;\r\n+import java.util.ArrayList;\r\n+import java.util.List;\r\n+\r\n+\/**\r\n+ * Data for rendering any number of glyphs bypassing glyph cache.\r\n+ *\/\r\n+public class GlyphRenderData {\r\n+\r\n+    public GeneralPath outline;\r\n+    public List<ColorLayer> colorLayers;\r\n+    public List<Bitmap> bitmaps;\r\n+\r\n+    public GlyphRenderData() {}\r\n+    public GlyphRenderData(GlyphRenderData i) {\r\n+        if (i.outline != null) outline = (GeneralPath) i.outline.clone();\r\n+        if (i.colorLayers != null) {\r\n+            colorLayers = new ArrayList<>(i.colorLayers.size());\r\n+            for (ColorLayer l : i.colorLayers) {\r\n+                colorLayers.add(new ColorLayer(l.color, (GeneralPath) l.outline.clone()));\r\n+            }\r\n+        }\r\n+        if (i.bitmaps != null) {\r\n+            bitmaps = new ArrayList<>(i.bitmaps.size());\r\n+            for (Bitmap b : i.bitmaps) {\r\n+                bitmaps.add(new Bitmap(new AffineTransform(b.transform), b.image));\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    \/**\r\n+     * @param i must not be used afterwards\r\n+     *\/\r\n+    public void merge(GlyphRenderData i) {\r\n+        if (i.outline != null) {\r\n+            if (outline == null) outline = i.outline;\r\n+            else outline.append(i.outline.getPathIterator(null), false);\r\n+        }\r\n+        if (i.colorLayers != null) {\r\n+            if (colorLayers == null) colorLayers = i.colorLayers;\r\n+            else colorLayers.addAll(i.colorLayers);\r\n+        }\r\n+        if (i.bitmaps != null) {\r\n+            if (bitmaps == null) bitmaps = i.bitmaps;\r\n+            else bitmaps.addAll(i.bitmaps);\r\n+        }\r\n+    }\r\n+\r\n+    public void transform(AffineTransform transform) {\r\n+        if (outline != null) outline.transform(transform);\r\n+        if (colorLayers != null) {\r\n+            for (ColorLayer layer : colorLayers) {\r\n+                layer.outline.transform(transform);\r\n+            }\r\n+        }\r\n+        if (bitmaps != null) {\r\n+            for (Bitmap bitmap : bitmaps) {\r\n+                bitmap.transform.preConcatenate(transform);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public void draw(Graphics2D g) {\r\n+        if (outline != null) g.fill(outline);\r\n+        if (colorLayers != null) {\r\n+            Color color = g.getColor();\r\n+            for (ColorLayer layer : colorLayers) {\r\n+                g.setColor(layer.color == null ? color : layer.color);\r\n+                g.fill(layer.outline);\r\n+            }\r\n+            g.setColor(color);\r\n+        }\r\n+        if (bitmaps != null) {\r\n+            for (Bitmap bitmap : bitmaps) {\r\n+                g.drawImage(bitmap.image, bitmap.transform, null);\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    public record ColorLayer(Color color, GeneralPath outline) {}\r\n+\r\n+    public record Bitmap(AffineTransform transform, Image image) {}\r\n+\r\n+    \/\/ These methods exist for convenience and are called from native\r\n+\r\n+    private void setColorLayersList(int capacity) {\r\n+        colorLayers = new ArrayList<>(capacity);\r\n+    }\r\n+\r\n+    private void addColorLayers(GeneralPath outline) {\r\n+        colorLayers.add(new ColorLayer(null, outline));\r\n+    }\r\n+\r\n+    private void addColorLayers(int r, int g, int b, int a, GeneralPath outline) {\r\n+        colorLayers.add(new ColorLayer(new Color(r, g, b, a), outline));\r\n+    }\r\n+\r\n+    private static ColorModel colorModel(int bits, int r, int g, int b, int a) {\r\n+        if (Unsafe.getUnsafe().isBigEndian()) {\r\n+            r = Integer.reverse(r) >>> (32 - bits);\r\n+            g = Integer.reverse(g) >>> (32 - bits);\r\n+            b = Integer.reverse(b) >>> (32 - bits);\r\n+            a = Integer.reverse(a) >>> (32 - bits);\r\n+        }\r\n+        return new DirectColorModel(bits, r, g, b, a);\r\n+    }\r\n+    private static final ColorModel[] BITMAP_COLOR_MODELS = {\r\n+            colorModel(32, \/\/ macOS RGBA\r\n+                    0x000000ff,\r\n+                    0x0000ff00,\r\n+                    0x00ff0000,\r\n+                    0xff000000),\r\n+            colorModel(32, \/\/ macOS ARGB\r\n+                    0x0000ff00,\r\n+                    0x00ff0000,\r\n+                    0xff000000,\r\n+                    0x000000ff),\r\n+            colorModel(32, \/\/ Freetype BGRA\r\n+                    0x00ff0000,\r\n+                    0x0000ff00,\r\n+                    0x000000ff,\r\n+                    0xff000000)\r\n+    };\r\n+    private void addBitmap(double m00, double m10,\r\n+                           double m01, double m11,\r\n+                           double m02, double m12,\r\n+                           int width, int height, int pitch,\r\n+                           int colorModel, int[] data) {\r\n+        if (bitmaps == null) bitmaps = new ArrayList<>();\r\n+        ColorModel color = BITMAP_COLOR_MODELS[colorModel];\r\n+        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n+        for (int y = 0; y < height; y++) {\r\n+            for (int x = 0; x < width; x++) {\r\n+                image.setRGB(x, y, color.getRGB(data[pitch * y + x]));\r\n+            }\r\n+        }\r\n+        bitmaps.add(new Bitmap(new AffineTransform(m00, m10, m01, m11, m02, m12), image));\r\n+    }\r\n+}\r\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphRenderData.java","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -67,0 +67,5 @@\n+    GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                       float x, float y) {\n+        return new GlyphRenderData();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/NullFontScaler.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    \/* These 3 outline methods should be implemented to return\n+    \/* These 4 outline methods should be implemented to return\n@@ -114,0 +114,3 @@\n+\n+    abstract GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                float x, float y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/PhysicalFont.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -423,1 +423,1 @@\n-        return getGlyphsOutline(0, glyphs.length, 0, 0, null);\n+        return getGlyphsOutline(0, glyphs.length, 0, 0);\n@@ -427,1 +427,1 @@\n-        return getGlyphsOutline(0, glyphs.length, x, y, null);\n+        return getGlyphsOutline(0, glyphs.length, x, y);\n@@ -432,1 +432,1 @@\n-        return getGlyphsOutline(ix, 1, 0, 0, null);\n+        return getGlyphsOutline(ix, 1, 0, 0);\n@@ -437,1 +437,1 @@\n-        return getGlyphsOutline(ix, 1, x, y, null);\n+        return getGlyphsOutline(ix, 1, x, y);\n@@ -879,0 +879,19 @@\n+    public GlyphRenderData getGlyphRenderData(float x, float y) {\n+        return getGlyphRenderData(0, glyphs.length, x, y);\n+    }\n+\n+    public GlyphRenderData getGlyphRenderData(int start, int count, float x, float y) {\n+        setFRCTX();\n+        initPositions();\n+\n+        GlyphRenderData result = new GlyphRenderData();\n+        for (int i = start, e = start + count, n = start * 2; i < e; ++i, n += 2) {\n+            float px = x + positions[n];\n+            float py = y + positions[n+1];\n+\n+            getGlyphStrike(i).appendGlyphRenderData(glyphs[i], result, px, py);\n+        }\n+\n+        return result;\n+    }\n+\n@@ -1164,1 +1183,1 @@\n-     * Used by getOutline, getGlyphsOutline and GlyphList#extractOutlineAndSetAsFallback\n+     * Used by getOutline, getGlyphsOutline\n@@ -1166,1 +1185,1 @@\n-    Shape getGlyphsOutline(int start, int count, float x, float y, GlyphList fallbackList) {\n+    private Shape getGlyphsOutline(int start, int count, float x, float y) {\n@@ -1175,5 +1194,1 @@\n-            GlyphStrike strike = getGlyphStrike(i);\n-            boolean hasOutline = strike.appendGlyphOutline(glyphs[i], result, px, py);\n-            if (!hasOutline && fallbackList != null) {\n-                fallbackList.addFallbackGlyph(strike, glyphs[i], positions[n], positions[n+1]);\n-            }\n+            getGlyphStrike(i).appendGlyphOutline(glyphs[i], result, px, py);\n@@ -1790,1 +1805,0 @@\n-                if (gp == null) gp = new GeneralPath();\n@@ -1810,1 +1824,1 @@\n-        boolean appendGlyphOutline(int glyphID, GeneralPath result, float x, float y) {\n+        void appendGlyphOutline(int glyphID, GeneralPath result, float x, float y) {\n@@ -1815,1 +1829,0 @@\n-                if (gp == null) return false;\n@@ -1818,1 +1831,0 @@\n-                if (gp == null) return false;\n@@ -1824,1 +1836,13 @@\n-            return true;\n+        }\n+\n+        void appendGlyphRenderData(int glyphID, GlyphRenderData result, float x, float y) {\n+            \/\/ !!! fontStrike needs a method for this.  For that matter, GeneralPath does.\n+            GlyphRenderData grd;\n+            if (sgv.invdtx == null) {\n+                grd = strike.getGlyphRenderData(glyphID, x + dx, y + dy);\n+            } else {\n+                grd = strike.getGlyphRenderData(glyphID, 0, 0);\n+                grd.transform(sgv.invdtx);\n+                grd.transform(AffineTransform.getTranslateInstance(x + dx, y + dy));\n+            }\n+            result.merge(grd);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":40,"deletions":16,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.annotation.Native;\n@@ -118,0 +119,1 @@\n+    static int formatOffset;\n@@ -120,0 +122,5 @@\n+    @Native public static final byte PIXEL_FORMAT_UNKNOWN   = -1;\n+    @Native public static final byte PIXEL_FORMAT_GREYSCALE = 1;\n+    @Native public static final byte PIXEL_FORMAT_LCD       = 3;\n+    @Native public static final byte PIXEL_FORMAT_BGRA      = 4;\n+\n@@ -139,1 +146,1 @@\n-        long[] nativeInfo = new long[13];\n+        long[] nativeInfo = new long[14];\n@@ -156,0 +163,1 @@\n+        formatOffset = (int) nativeInfo[13];\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    public static final int COLRTag = 0x434f4c52; \/\/ 'COLR'\n@@ -876,0 +877,4 @@\n+    boolean hasCOLRTable() {\n+        return getDirectoryEntry(COLRTag) != null;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -367,1 +367,1 @@\n-    public static final OutlineTextRenderer outlineTextRenderer;\n+    public static final TextPipe outlineTextRenderer;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.font.StrikeCache;\n@@ -44,1 +45,1 @@\n-        boolean isColor = false;\n+        byte pixelFormat = StrikeCache.PIXEL_FORMAT_UNKNOWN;\n@@ -49,4 +50,4 @@\n-                boolean newIsColor = gl.isColorGlyph(i);\n-                if (newIsColor != isColor) {\n-                    drawGlyphListSegment(sg2d, gl, prevLimit, i, aaHint,\n-                            isColor);\n+                byte newFormat = gl.getPixelFormat(i);\n+                if (newFormat != pixelFormat) {\n+                    drawGlyphListSegment(sg2d, gl,\n+                            prevLimit, i, aaHint, pixelFormat);\n@@ -54,1 +55,1 @@\n-                    isColor = newIsColor;\n+                    pixelFormat = newFormat;\n@@ -58,1 +59,1 @@\n-        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, isColor);\n+        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, pixelFormat);\n@@ -63,1 +64,1 @@\n-                                      int aaHint, boolean isColor) {\n+                                      int aaHint, byte pixelFormat) {\n@@ -65,7 +66,3 @@\n-        if (isColor) {\n-            sg2d.loops.drawGlyphListColorLoop.\n-                    DrawGlyphListColor(sg2d, sg2d.surfaceData,\n-                            gl, fromglyph, toGlyph);\n-        } else {\n-            switch (aaHint) {\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:\n+        switch (pixelFormat) {\n+            case StrikeCache.PIXEL_FORMAT_GREYSCALE:\n+                if (aaHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF) {\n@@ -75,2 +72,1 @@\n-                    return;\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_ON:\n+                } else {\n@@ -80,8 +76,12 @@\n-                    return;\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:\n-                    sg2d.loops.drawGlyphListLCDLoop.\n-                            DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n-                                    gl, fromglyph, toGlyph);\n-                    return;\n-            }\n+                }\n+                return;\n+            case StrikeCache.PIXEL_FORMAT_LCD:\n+                sg2d.loops.drawGlyphListLCDLoop.\n+                        DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n+                                gl, fromglyph, toGlyph);\n+                return;\n+            case StrikeCache.PIXEL_FORMAT_BGRA:\n+                sg2d.loops.drawGlyphListColorLoop.\n+                        DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                                gl, fromglyph, toGlyph);\n+                return;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/GlyphListLoopPipe.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import sun.font.StandardGlyphVector;\n@@ -51,8 +50,4 @@\n-        GlyphList gl = GlyphList.getInstance();\n-        boolean renderFallback = false;\n-        try {\n-            if (info.pixelHeight > OutlineTextRenderer.THRESHHOLD) {\n-                SurfaceData.outlineTextRenderer.drawGlyphVector(sg2d,\n-                        new StandardGlyphVector(sg2d.getFont(), s, sg2d.getFontRenderContext()), (float) x, (float) y, gl);\n-                if (gl.getNumGlyphs() > 0) renderFallback = true;\n-            }\n+        if (info.pixelHeight > OutlineTextRenderer.THRESHHOLD) {\n+            SurfaceData.outlineTextRenderer.drawString(sg2d, s, x, y);\n+            return;\n+        }\n@@ -60,23 +55,17 @@\n-            float devx, devy;\n-            if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n-                double[] origin = {x + info.originX, y + info.originY};\n-                sg2d.transform.transform(origin, 0, origin, 0, 1);\n-                devx = (float)origin[0];\n-                devy = (float)origin[1];\n-            } else {\n-                devx = (float)(x + info.originX + sg2d.transX);\n-                devy = (float)(y + info.originY + sg2d.transY);\n-            }\n-            \/* setFromString returns false if shaping is needed, and we then back\n-             * off to a TextLayout. Such text may benefit slightly from a lower\n-             * overhead in this approach over the approach in previous releases.\n-             *\/\n-            if (renderFallback) {\n-                gl.setPosition(devx, devy);\n-                drawGlyphList(sg2d, gl);\n-                return;\n-            } else if (gl.setFromString(info, s, devx, devy)) {\n-                drawGlyphList(sg2d, gl);\n-                return;\n-            }\n-        } finally {\n+        float devx, devy;\n+        if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n+            double[] origin = {x + info.originX, y + info.originY};\n+            sg2d.transform.transform(origin, 0, origin, 0, 1);\n+            devx = (float)origin[0];\n+            devy = (float)origin[1];\n+        } else {\n+            devx = (float)(x + info.originX + sg2d.transX);\n+            devy = (float)(y + info.originY + sg2d.transY);\n+        }\n+        \/* setFromString returns false if shaping is needed, and we then back\n+         * off to a TextLayout. Such text may benefit slightly from a lower\n+         * overhead in this approach over the approach in previous releases.\n+         *\/\n+        GlyphList gl = GlyphList.getInstance();\n+        if (gl.setFromString(info, s, devx, devy)) {\n+            drawGlyphList(sg2d, gl);\n@@ -84,0 +73,5 @@\n+        } else {\n+            gl.dispose(); \/\/ release this asap.\n+            TextLayout tl = new TextLayout(s, sg2d.getFont(),\n+                                           sg2d.getFontRenderContext());\n+            tl.draw(sg2d, (float)x, (float)y);\n@@ -85,3 +79,0 @@\n-        TextLayout tl = new TextLayout(s, sg2d.getFont(),\n-                sg2d.getFontRenderContext());\n-        tl.draw(sg2d, (float)x, (float)y);\n@@ -98,0 +89,15 @@\n+        float x, y;\n+        if (info.pixelHeight > OutlineTextRenderer.THRESHHOLD) {\n+            SurfaceData.outlineTextRenderer.drawChars(\n+                                        sg2d, data, offset, length, ix, iy);\n+            return;\n+        }\n+        if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n+            double[] origin = {ix + info.originX, iy + info.originY};\n+            sg2d.transform.transform(origin, 0, origin, 0, 1);\n+            x = (float) origin[0];\n+            y = (float) origin[1];\n+        } else {\n+            x = ix + info.originX + sg2d.transX;\n+            y = iy + info.originY + sg2d.transY;\n+        }\n@@ -99,26 +105,2 @@\n-        boolean renderFallback = false;\n-        try {\n-            float x, y;\n-            if (info.pixelHeight > OutlineTextRenderer.THRESHHOLD) {\n-                SurfaceData.outlineTextRenderer.drawGlyphVector(sg2d,\n-                        new StandardGlyphVector(sg2d.getFont(), data, offset, length, sg2d.getFontRenderContext()), ix, iy, gl);\n-                if (gl.getNumGlyphs() > 0) renderFallback = true;\n-            }\n-            if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n-                double[] origin = {ix + info.originX, iy + info.originY};\n-                sg2d.transform.transform(origin, 0, origin, 0, 1);\n-                x = (float) origin[0];\n-                y = (float) origin[1];\n-            } else {\n-                x = ix + info.originX + sg2d.transX;\n-                y = iy + info.originY + sg2d.transY;\n-            }\n-            if (renderFallback) {\n-                gl.setPosition(x, y);\n-                drawGlyphList(sg2d, gl);\n-                return;\n-            } else if (gl.setFromChars(info, data, offset, length, x, y)) {\n-                drawGlyphList(sg2d, gl);\n-                return;\n-            }\n-        } finally {\n+        if (gl.setFromChars(info, data, offset, length, x, y)) {\n+            drawGlyphList(sg2d, gl);\n@@ -126,0 +108,7 @@\n+        } else {\n+            gl.dispose(); \/\/ release this asap.\n+            TextLayout tl = new TextLayout(new String(data, offset, length),\n+                                           sg2d.getFont(),\n+                                           sg2d.getFontRenderContext());\n+            tl.draw(sg2d, ix, iy);\n+\n@@ -127,4 +116,0 @@\n-        TextLayout tl = new TextLayout(new String(data, offset, length),\n-                sg2d.getFont(),\n-                sg2d.getFontRenderContext());\n-        tl.draw(sg2d, ix, iy);\n@@ -141,22 +126,12 @@\n-        GlyphList gl = GlyphList.getInstance();\n-        boolean renderFallback = false;\n-        try {\n-            if (info.pixelHeight > OutlineTextRenderer.THRESHHOLD) {\n-                SurfaceData.outlineTextRenderer.drawGlyphVector(sg2d, gv, x, y, gl);\n-                if (gl.getNumGlyphs() > 0) renderFallback = true;\n-            }\n-            if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n-                double[] origin = {x, y};\n-                sg2d.transform.transform(origin, 0, origin, 0, 1);\n-                x = (float) origin[0];\n-                y = (float) origin[1];\n-            } else {\n-                x += sg2d.transX; \/\/ don't use the glyph info origin, already in gv.\n-                y += sg2d.transY;\n-            }\n-\n-            if (renderFallback) gl.setPosition(x, y);\n-            else gl.setFromGlyphVector(info, gv, x, y);\n-            drawGlyphList(sg2d, gl, info.aaHint);\n-        } finally {\n-            gl.dispose();\n+        if (info.pixelHeight > OutlineTextRenderer.THRESHHOLD) {\n+            SurfaceData.outlineTextRenderer.drawGlyphVector(sg2d, gv, x, y);\n+            return;\n+        }\n+        if (sg2d.transformState >= SunGraphics2D.TRANSFORM_TRANSLATESCALE) {\n+            double[] origin = {x, y};\n+            sg2d.transform.transform(origin, 0, origin, 0, 1);\n+            x = (float) origin[0];\n+            y = (float) origin[1];\n+        } else {\n+            x += sg2d.transX; \/\/ don't use the glyph info origin, already in gv.\n+            y += sg2d.transY;\n@@ -164,0 +139,5 @@\n+\n+        GlyphList gl = GlyphList.getInstance();\n+        gl.setFromGlyphVector(info, gv, x, y);\n+        drawGlyphList(sg2d, gl, info.aaHint);\n+        gl.dispose();\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/GlyphListPipe.java","additions":67,"deletions":87,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -28,2 +28,5 @@\n-import sun.awt.SunHints;\n-import sun.font.GlyphList;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.font.TextLayout;\n+\n+import sun.font.GlyphRenderData;\n@@ -32,0 +35,1 @@\n+import sun.awt.SunHints;\n@@ -33,3 +37,1 @@\n-import java.awt.*;\n-import java.awt.font.FontRenderContext;\n-import java.awt.font.GlyphVector;\n+import java.awt.geom.GeneralPath;\n@@ -69,2 +71,2 @@\n-        StandardGlyphVector sgv = new StandardGlyphVector(g2d.getFont(), data, offset, length, g2d.getFontRenderContext());\n-        drawGlyphVector(g2d, sgv, (float) x, (float) y);\n+        String s = new String(data, offset, length);\n+        drawString(g2d, s, x, y);\n@@ -75,2 +77,28 @@\n-        StandardGlyphVector sgv = new StandardGlyphVector(g2d.getFont(), str, g2d.getFontRenderContext());\n-        drawGlyphVector(g2d, sgv, (float) x, (float) y);\n+        if (\"\".equals(str)) {\n+            return; \/\/ TextLayout constructor throws IAE on \"\".\n+        }\n+        TextLayout tl = new TextLayout(str, g2d.getFont(),\n+                                       g2d.getFontRenderContext());\n+\n+        int textAAHint = g2d.getFontInfo().aaHint;\n+\n+        int prevaaHint = - 1;\n+        if (textAAHint != SunHints.INTVAL_TEXT_ANTIALIAS_OFF &&\n+            g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {\n+            prevaaHint = g2d.antialiasHint;\n+            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_ON;\n+            g2d.validatePipe();\n+        } else if (textAAHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF\n+            && g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_OFF) {\n+            prevaaHint = g2d.antialiasHint;\n+            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_OFF;\n+            g2d.validatePipe();\n+        }\n+\n+        \/\/ This will end up calling our drawGlyphVector\n+        tl.draw(g2d, (float) x, (float) y);\n+\n+        if (prevaaHint != -1) {\n+             g2d.antialiasHint = prevaaHint;\n+             g2d.validatePipe();\n+        }\n@@ -81,2 +109,0 @@\n-        drawGlyphVector(g2d, gv, x, y, null);\n-    }\n@@ -84,2 +110,7 @@\n-    void drawGlyphVector(SunGraphics2D g2d, GlyphVector gv,\n-                                float x, float y, GlyphList fallbackList) {\n+        GlyphRenderData grd;\n+        if (gv instanceof StandardGlyphVector) {\n+            grd = ((StandardGlyphVector) gv).getGlyphRenderData(x, y);\n+        } else {\n+            grd = new GlyphRenderData();\n+            grd.outline = new GeneralPath(gv.getOutline(x, y));\n+        }\n@@ -87,2 +118,0 @@\n-        Shape s = fallbackList == null ? gv.getOutline(x, y) :\n-                fallbackList.extractOutlineAndSetAsFallback(g2d.getFontInfo(), gv, x, y);\n@@ -115,1 +144,1 @@\n-        g2d.fill(s);\n+        grd.draw(g2d);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/OutlineTextRenderer.java","additions":45,"deletions":16,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"sun_font_StrikeCache.h\"\n@@ -77,1 +78,2 @@\n-    UInt8         managed;\n+    UInt8        managed;\n+    UInt8        format; \/\/ sun_font_StrikeCache_PIXEL_FORMAT_*\n","filename":"src\/java.desktop\/share\/native\/common\/font\/fontscalerdefs.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,6 @@\n+\n+    \/* sun\/font\/GlyphRenderData *\/\n+    jfieldID glyphRenderDataOutline, glyphRenderDataColorLayers;\n+    jmethodID glyphRenderDataSetColorLayersListMID,\n+      glyphRenderDataAddColorLayerMID, glyphRenderDataAddColorLayerFGMID,\n+      glyphRenderDataAddBitmapMID;\n","filename":"src\/java.desktop\/share\/native\/common\/font\/sunfontids.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1090,1 +1090,1 @@\n-        if (ginfo->rowBytes == ginfo->width) {\n+        if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE) {\n@@ -1099,1 +1099,1 @@\n-        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+        } else if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_BGRA) {\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLTextRenderer.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -548,2 +548,1 @@\n-        \/* rowBytes==width tests if its a B&W or LCD glyph *\/\n-        if (ginfo->width == ginfo->rowBytes) {\n+        if (ginfo->format != sun_font_StrikeCache_PIXEL_FORMAT_LCD) {\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/DrawGlyphList.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include FT_COLOR_H\n@@ -99,0 +100,1 @@\n+    jboolean colorFont;\n@@ -597,0 +599,1 @@\n+            context->colorFont = FT_HAS_COLOR(scalerInfo->face) ? JNI_TRUE : JNI_FALSE;\n@@ -600,0 +603,1 @@\n+            context->colorFont = JNI_TRUE;\n@@ -764,1 +768,1 @@\n-        jboolean renderImage);\n+        jboolean renderImage, jboolean setupContext);\n@@ -793,1 +797,1 @@\n-          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);\n+          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE, JNI_TRUE);\n@@ -819,1 +823,1 @@\n-                                 pScalerContext, pScaler, glyphCode, JNI_FALSE);\n+                                 pScalerContext, pScaler, glyphCode, JNI_FALSE, JNI_TRUE);\n@@ -1130,1 +1134,1 @@\n-        pScalerContext, pScaler, glyphCode, JNI_TRUE);\n+        pScalerContext, pScaler, glyphCode, JNI_TRUE, JNI_TRUE);\n@@ -1137,1 +1141,1 @@\n-        jboolean renderImage) {\n+        jboolean renderImage, jboolean setupContext) {\n@@ -1155,4 +1159,6 @@\n-    error = setupFTContext(env, font2D, scalerInfo, context);\n-    if (error) {\n-        invalidateJavaScaler(env, scaler, scalerInfo);\n-        return ptr_to_jlong(getNullGlyphImage());\n+    if (setupContext) {\n+        error = setupFTContext(env, font2D, scalerInfo, context);\n+        if (error) {\n+            invalidateJavaScaler(env, scaler, scalerInfo);\n+            return ptr_to_jlong(getNullGlyphImage());\n+        }\n@@ -1168,1 +1174,2 @@\n-    if (context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) {\n+    if ((context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) ||\n+        context->colorFont) {\n@@ -1172,3 +1179,6 @@\n-    \/* Don't disable bitmaps when working with fixed-size glyph,\n-     * this is most probably a BGRA glyph *\/\n-    if (!context->useSbits && context->fixedSizeIndex == -1) {\n+    if (context->colorFont) {\n+        renderFlags |= FT_LOAD_COLOR;\n+    }\n+\n+    \/* Don't disable bitmaps for color glyphs *\/\n+    if (!context->useSbits && !context->colorFont) {\n@@ -1184,6 +1194,1 @@\n-    if (context->aaType == TEXT_AA_OFF) {\n-        \/* We disable MONO for non-scalable fonts, because that\n-         * is most probably a colored bitmap glyph *\/\n-        target = context->fixedSizeIndex == -1 ?\n-                 FT_LOAD_TARGET_MONO : FT_LOAD_TARGET_NORMAL;\n-    } else if (context->aaType == TEXT_AA_ON) {\n+    if (context->aaType == TEXT_AA_ON || context->colorFont) {\n@@ -1191,0 +1196,2 @@\n+    } else if (context->aaType == TEXT_AA_OFF) {\n+        target = FT_LOAD_TARGET_MONO;\n@@ -1198,4 +1205,0 @@\n-    if (context->fixedSizeIndex != -1) {\n-        \/\/ This is most probably a colored bitmap glyph, so enable COLOR\n-        renderFlags |= FT_LOAD_COLOR;\n-    }\n@@ -1217,1 +1220,1 @@\n-    if (context->doBold && outlineGlyph) { \/* if bold style *\/\n+    if (context->doBold && outlineGlyph && !context->colorFont) { \/* if bold style *\/\n@@ -1290,0 +1293,5 @@\n+    if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA) glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_BGRA;\n+    else if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD ||\n+             ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD_V) glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_LCD;\n+    else glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE;\n+\n@@ -1489,3 +1497,2 @@\n-static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,\n-        FTScalerContext *context, FTScalerInfo* scalerInfo,\n-        jint glyphCode, jfloat xpos, jfloat ypos) {\n+static FT_Outline* getFTOutlineNoSetup(FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                       jint glyphCode, jfloat xpos, jfloat ypos, jboolean allowBold) {\n@@ -1496,10 +1503,0 @@\n-    if (glyphCode >= INVISIBLE_GLYPHS ||\n-            isNullScalerContext(context) || scalerInfo == NULL) {\n-        return NULL;\n-    }\n-\n-    error = setupFTContext(env, font2D, scalerInfo, context);\n-    if (error) {\n-        return NULL;\n-    }\n-\n@@ -1516,1 +1513,1 @@\n-    if (context->doBold) { \/* if bold style *\/\n+    if (context->doBold && allowBold) { \/* if bold style *\/\n@@ -1527,0 +1524,18 @@\n+static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,\n+                                FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                jint glyphCode, jfloat xpos, jfloat ypos) {\n+    FT_Error error;\n+\n+    if (glyphCode >= INVISIBLE_GLYPHS ||\n+        isNullScalerContext(context) || scalerInfo == NULL) {\n+        return NULL;\n+    }\n+\n+    error = setupFTContext(env, font2D, scalerInfo, context);\n+    if (error) {\n+        return NULL;\n+    }\n+\n+    return getFTOutlineNoSetup(context, scalerInfo, glyphCode, xpos, ypos, JNI_TRUE);\n+}\n+\n@@ -1683,3 +1698,1 @@\n-static jobject getGlyphGeneralPath(JNIEnv* env, jobject font2D,\n-        FTScalerContext *context, FTScalerInfo *scalerInfo,\n-        jint glyphCode, jfloat xpos, jfloat ypos) {\n+static jobject outlineToGeneralPath(JNIEnv* env, FT_Outline* outline) {\n@@ -1687,1 +1700,0 @@\n-    FT_Outline* outline;\n@@ -1693,4 +1705,1 @@\n-    outline = getFTOutline(env, font2D, context, scalerInfo,\n-                           glyphCode, xpos, ypos);\n-\n-    if (outline == NULL) {\n+    if (outline == NULL || outline->n_points == 0) {\n@@ -1698,4 +1707,0 @@\n-    } else if (outline->n_points == 0) {\n-        return (*env)->NewObject(env,\n-                                 sunFontIDs.gpClass,\n-                                 sunFontIDs.gpCtrEmpty);\n@@ -1737,0 +1742,65 @@\n+static jboolean addColorLayersRenderData(JNIEnv* env, FTScalerContext *context,\n+                                         FTScalerInfo* scalerInfo, jint glyphCode,\n+                                         jfloat xpos, jfloat ypos, jobject result) {\n+\n+    FT_Error error;\n+\n+    FT_Color* colors;\n+    error = FT_Palette_Select(scalerInfo->face, 0, &colors);\n+    if (error) return JNI_FALSE;\n+\n+    FT_LayerIterator iterator;\n+    iterator.p = NULL;\n+    FT_UInt glyphIndex, colorIndex;\n+    if (!FT_Get_Color_Glyph_Layer(scalerInfo->face, glyphCode,\n+                                  &glyphIndex, &colorIndex, &iterator)) return JNI_FALSE;\n+    (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataSetColorLayersListMID, iterator.num_layers);\n+    do {\n+        FT_Outline* outline = getFTOutlineNoSetup(context, scalerInfo, glyphIndex, xpos, ypos, JNI_FALSE);\n+        jobject gp = outlineToGeneralPath(env, outline);\n+\n+        if (colorIndex == 0xFFFF) {\n+            (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddColorLayerFGMID, gp);\n+        } else {\n+            (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddColorLayerMID,\n+                                   colors[colorIndex].red, colors[colorIndex].green,\n+                                   colors[colorIndex].blue, colors[colorIndex].alpha, gp);\n+        }\n+    } while(FT_Get_Color_Glyph_Layer(scalerInfo->face, glyphCode,\n+                                     &glyphIndex, &colorIndex, &iterator));\n+\n+    return JNI_TRUE;\n+}\n+\n+static void addBitmapRenderData(JNIEnv *env, jobject scaler, jobject font2D,\n+                                FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                jint glyphCode, jfloat xpos, jfloat ypos, jobject result) {\n+    GlyphInfo* glyphInfo = (GlyphInfo*) getGlyphImageNativeInternal(\n+            env, scaler, font2D,\n+            (jlong) context, (jlong) scalerInfo,\n+            glyphCode, JNI_FALSE, JNI_FALSE);\n+\n+    FT_GlyphSlot ftglyph = scalerInfo->face->glyph;\n+\n+    if (ftglyph->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA) return;\n+\n+    int pitch = ftglyph->bitmap.pitch \/ 4;\n+    int size = pitch * ftglyph->bitmap.rows;\n+    jintArray array = (*env)->NewIntArray(env, size);\n+    (*env)->SetIntArrayRegion(env, array, 0, size, (jint*) ftglyph->bitmap.buffer);\n+\n+    double bitmapSize = (double) scalerInfo->face->available_sizes[context->fixedSizeIndex].size;\n+    double scale = (double) context->ptsz \/ bitmapSize \/ (double) (ftFixed1);\n+    double tx = ftglyph->bitmap_left + xpos * bitmapSize \/ (double) context->ptsz;\n+    double ty = -ftglyph->bitmap_top + ypos * bitmapSize \/ (double) context->ptsz;\n+\n+    jdouble m00 = (jdouble) context->transform.xx * scale, m10 = (jdouble) context->transform.xy * scale;\n+    jdouble m01 = (jdouble) context->transform.yx * scale, m11 = (jdouble) context->transform.yy * scale;\n+    jdouble m02 = m00 * tx + m01 * ty, m12 = m10 * tx + m11 * ty;\n+\n+    free(glyphInfo);\n+    (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddBitmapMID,\n+                           m00, m10, m01, m11, m02, m12,\n+                           ftglyph->bitmap.width, ftglyph->bitmap.rows, pitch, 2, array);\n+}\n+\n@@ -1751,7 +1821,9 @@\n-    jobject gp = getGlyphGeneralPath(env,\n-                               font2D,\n-                               context,\n-                               scalerInfo,\n-                               glyphCode,\n-                               xpos,\n-                               ypos);\n+    FT_Outline* outline = getFTOutline(env, font2D, context,\n+                                       scalerInfo, glyphCode,\n+                                       xpos, ypos);\n+    jobject gp = outlineToGeneralPath(env, outline);\n+    if (gp == NULL) { \/* can be legal *\/\n+        gp = (*env)->NewObject(env,\n+                               sunFontIDs.gpClass,\n+                               sunFontIDs.gpCtrEmpty);\n+    }\n@@ -1761,0 +1833,36 @@\n+\/*\n+ * Class:     sun_font_FreetypeFontScaler\n+ * Method:    getGlyphRenderDataNative\n+ * Signature: (Lsun\/font\/Font2D;JIFFLsun\/font\/GlyphRenderData;)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_font_FreetypeFontScaler_getGlyphRenderDataNative(\n+        JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,\n+        jlong pScaler, jint glyphCode, jfloat xpos, jfloat ypos, jobject result) {\n+\n+    FTScalerContext *context =\n+            (FTScalerContext*) jlong_to_ptr(pScalerContext);\n+    FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);\n+\n+    if (glyphCode >= INVISIBLE_GLYPHS ||\n+        isNullScalerContext(context) || scalerInfo == NULL) {\n+        return;\n+    }\n+\n+    FT_Error error = setupFTContext(env, font2D, scalerInfo, context);\n+    if (error) return;\n+\n+    if (context->fixedSizeIndex == -1) {\n+        if (!context->colorFont ||\n+            !addColorLayersRenderData(env, context, scalerInfo, glyphCode, xpos, ypos, result)) {\n+            FT_Outline* outline = getFTOutlineNoSetup(context, scalerInfo, glyphCode, xpos, ypos, JNI_TRUE);\n+            jobject gp = outlineToGeneralPath(env, outline);\n+            if (gp != NULL) {\n+                (*env)->SetObjectField(env, result, sunFontIDs.glyphRenderDataOutline, gp);\n+            }\n+        }\n+    } else {\n+        addBitmapRenderData(env, scaler, font2D, context, scalerInfo, glyphCode, xpos, ypos, result);\n+    }\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":165,"deletions":57,"binary":false,"changes":222,"status":"modified"},{"patch":"@@ -192,0 +192,14 @@\n+    CHECK_NULL(tmpClass = (*env)->FindClass(env, \"sun\/font\/GlyphRenderData\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataOutline =\n+         (*env)->GetFieldID(env, tmpClass, \"outline\", \"Ljava\/awt\/geom\/GeneralPath;\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataColorLayers =\n+         (*env)->GetFieldID(env, tmpClass, \"colorLayers\", \"Ljava\/util\/List;\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataSetColorLayersListMID =\n+          (*env)->GetMethodID(env, tmpClass, \"setColorLayersList\", \"(I)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddColorLayerMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addColorLayers\", \"(IIIILjava\/awt\/geom\/GeneralPath;)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddColorLayerFGMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addColorLayers\", \"(Ljava\/awt\/geom\/GeneralPath;)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddBitmapMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addBitmap\", \"(DDDDDDIIII[I)V\"));\n+\n@@ -317,1 +331,1 @@\n-    if ((*env)->GetArrayLength(env, results) < 13) {\n+    if ((*env)->GetArrayLength(env, results) < 14) {\n@@ -344,0 +358,1 @@\n+    nresults[13] = (size_t)&(info->format)-baseAddr;\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/****************************************************************************\r\n+ *\r\n+ * ftcolor.c\r\n+ *\r\n+ *   FreeType's glyph color management (body).\r\n+ *\r\n+ * Copyright (C) 2018-2022 by\r\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\r\n+ *\r\n+ * This file is part of the FreeType project, and may only be used,\r\n+ * modified, and distributed under the terms of the FreeType project\r\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\r\n+ * this file you indicate that you have read the license and\r\n+ * understand and accept it fully.\r\n+ *\r\n+ *\/\r\n+\r\n+\r\n+#include <freetype\/internal\/ftdebug.h>\r\n+#include <freetype\/internal\/sfnt.h>\r\n+#include <freetype\/internal\/tttypes.h>\r\n+#include <freetype\/ftcolor.h>\r\n+\r\n+\r\n+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS\r\n+\r\n+  static\r\n+  const FT_Palette_Data  null_palette_data = { 0, NULL, NULL, 0, NULL };\r\n+\r\n+\r\n+  \/* documentation is in ftcolor.h *\/\r\n+\r\n+  FT_EXPORT_DEF( FT_Error )\r\n+  FT_Palette_Data_Get( FT_Face           face,\r\n+                       FT_Palette_Data  *apalette_data )\r\n+  {\r\n+    if ( !face )\r\n+      return FT_THROW( Invalid_Face_Handle );\r\n+    if ( !apalette_data)\r\n+      return FT_THROW( Invalid_Argument );\r\n+\r\n+    if ( FT_IS_SFNT( face ) )\r\n+      *apalette_data = ( (TT_Face)face )->palette_data;\r\n+    else\r\n+      *apalette_data = null_palette_data;\r\n+\r\n+    return FT_Err_Ok;\r\n+  }\r\n+\r\n+\r\n+  \/* documentation is in ftcolor.h *\/\r\n+\r\n+  FT_EXPORT_DEF( FT_Error )\r\n+  FT_Palette_Select( FT_Face     face,\r\n+                     FT_UShort   palette_index,\r\n+                     FT_Color*  *apalette )\r\n+  {\r\n+    FT_Error  error;\r\n+\r\n+    TT_Face       ttface;\r\n+    SFNT_Service  sfnt;\r\n+\r\n+\r\n+    if ( !face )\r\n+      return FT_THROW( Invalid_Face_Handle );\r\n+\r\n+    if ( !FT_IS_SFNT( face ) )\r\n+    {\r\n+      if ( apalette )\r\n+        *apalette = NULL;\r\n+\r\n+      return FT_Err_Ok;\r\n+    }\r\n+\r\n+    ttface = (TT_Face)face;\r\n+    sfnt   = (SFNT_Service)ttface->sfnt;\r\n+\r\n+    error = sfnt->set_palette( ttface, palette_index );\r\n+    if ( error )\r\n+      return error;\r\n+\r\n+    ttface->palette_index = palette_index;\r\n+\r\n+    if ( apalette )\r\n+      *apalette = ttface->palette;\r\n+\r\n+    return FT_Err_Ok;\r\n+  }\r\n+\r\n+\r\n+  \/* documentation is in ftcolor.h *\/\r\n+\r\n+  FT_EXPORT_DEF( FT_Error )\r\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\r\n+                                   FT_Color  foreground_color )\r\n+  {\r\n+    TT_Face  ttface;\r\n+\r\n+\r\n+    if ( !face )\r\n+      return FT_THROW( Invalid_Face_Handle );\r\n+\r\n+    if ( !FT_IS_SFNT( face ) )\r\n+      return FT_Err_Ok;\r\n+\r\n+    ttface = (TT_Face)face;\r\n+\r\n+    ttface->foreground_color      = foreground_color;\r\n+    ttface->have_foreground_color = 1;\r\n+\r\n+    return FT_Err_Ok;\r\n+  }\r\n+\r\n+#else \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\r\n+\r\n+  FT_EXPORT_DEF( FT_Error )\r\n+  FT_Palette_Data_Get( FT_Face           face,\r\n+                       FT_Palette_Data  *apalette_data )\r\n+  {\r\n+    FT_UNUSED( face );\r\n+    FT_UNUSED( apalette_data );\r\n+\r\n+\r\n+    return FT_THROW( Unimplemented_Feature );\r\n+  }\r\n+\r\n+\r\n+  FT_EXPORT_DEF( FT_Error )\r\n+  FT_Palette_Select( FT_Face     face,\r\n+                     FT_UShort   palette_index,\r\n+                     FT_Color*  *apalette )\r\n+  {\r\n+    FT_UNUSED( face );\r\n+    FT_UNUSED( palette_index );\r\n+    FT_UNUSED( apalette );\r\n+\r\n+\r\n+    return FT_THROW( Unimplemented_Feature );\r\n+  }\r\n+\r\n+\r\n+  FT_EXPORT_DEF( FT_Error )\r\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\r\n+                                   FT_Color  foreground_color )\r\n+  {\r\n+    FT_UNUSED( face );\r\n+    FT_UNUSED( foreground_color );\r\n+\r\n+\r\n+    return FT_THROW( Unimplemented_Feature );\r\n+  }\r\n+\r\n+#endif \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\r\n+\r\n+\r\n+\/* END *\/\r\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcolor.c","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -307,0 +307,5 @@\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                              float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -295,0 +295,4 @@\n+     GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+         return new GlyphRenderData();\n+     }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeStrike.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,7 +188,5 @@\n-        int rowBytes = getSourceRowBytes();\n-        int width = getWidth();\n-        \/\/ 0x0 -> LCD is just for backward compatibiity\n-        if (width == 0 || getHeight() == 0) return Type.LCD;\n-        if (width == rowBytes) return Type.GRAYSCALE;\n-        if (width * 4 == rowBytes) return Type.BGRA;\n-        return Type.LCD;\n+        byte format = StrikeCache.unsafe.getByte(glyphInfoPtr + StrikeCache.formatOffset);\n+        if (format == StrikeCache.PIXEL_FORMAT_GREYSCALE) return Type.GRAYSCALE;\n+        else if (format == StrikeCache.PIXEL_FORMAT_LCD) return Type.LCD;\n+        else if (format == StrikeCache.PIXEL_FORMAT_BGRA) return Type.BGRA;\n+        else throw new IllegalStateException(\"Unknown glyph format: \" + format);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+    glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11FontScaler_md.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                              float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/NativeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/NativeStrike.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-        grayscale = (ginfo->rowBytes == ginfo->width);\n+        grayscale = (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DTextRenderer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -438,0 +438,1 @@\n+    glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_LCD;\n","filename":"src\/java.desktop\/windows\/native\/libfontmanager\/lcdglyph.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\r\n+ * Copyright 2021 JetBrains s.r.o.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @summary Checks that complex emoji are rendered with proper shaping.\r\n+ *\/\r\n+\r\n+import javax.imageio.ImageIO;\r\n+import java.awt.*;\r\n+import java.awt.image.BufferedImage;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+\r\n+public class ComplexEmoji {\r\n+    private static final int IMG_WIDTH = 60;\r\n+    private static final int IMG_HEIGHT = 20;\r\n+\r\n+    private static final String[] EMOJI = {\r\n+            \"\\ud83d\\udd25\", \/\/ Fire\r\n+            \"\\u2764\\ufe0f\", \/\/ Heart + color variation selector\r\n+            \"\\ud83e\\udd18\\ud83c\\udffb\", \/\/ Horns sign - white hand\r\n+            \"\\ud83d\\udc41\\ufe0f\\u200d\\ud83d\\udde8\\ufe0f\", \/\/ Eye in speech bubble - ZWJ sequence\r\n+            \"\\uD83C\\uDDE6\\uD83C\\uDDF6\", \/\/ Antarctica flag\r\n+            \"\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40\\udc65\\udb40\\udc6e\\udb40\\udc67\\udb40\\udc7f\", \/\/ England flag - tag sequence\r\n+    };\r\n+\r\n+    public static void main(String[] args) {\r\n+        \/\/ Platform-specific tricks\r\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\r\n+            EMOJI[4] = EMOJI[5] = null; \/\/ Flags and tags are not supported on Windows\r\n+        }\r\n+\r\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\r\n+        String errors = \"\";\r\n+        for (int i = 0; i < EMOJI.length; i++) {\r\n+            String emoji = EMOJI[i];\r\n+            if (emoji == null) continue;\r\n+            drawEmoji(img, emoji);\r\n+            String error = checkEmoji(img);\r\n+            if (error != null) {\r\n+                errors += \"\\n#\" + i + \": \" + error;\r\n+                try {\r\n+                    ImageIO.write(img, \"PNG\", new File(\"ComplexEmoji\" + i + \".png\"));\r\n+                } catch (IOException e) {\r\n+                    e.printStackTrace();\r\n+                }\r\n+            }\r\n+        }\r\n+        if (!errors.isEmpty()) throw new RuntimeException(errors);\r\n+    }\r\n+\r\n+    private static void drawEmoji(Image img, String emoji) {\r\n+        Graphics g = img.getGraphics();\r\n+        g.setColor(Color.white);\r\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\r\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\r\n+        \/\/ Try to trick shaper by prepending \"A\" letter\r\n+        \/\/ White on white will not be visible anyway\r\n+        g.drawString(\"A\" + emoji, 2, 15);\r\n+        g.dispose();\r\n+    }\r\n+\r\n+    private static String checkEmoji(BufferedImage img) {\r\n+        Point min = new Point(Integer.MAX_VALUE, Integer.MAX_VALUE);\r\n+        Point max = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);\r\n+        for (int x = 0; x < IMG_WIDTH; x++) {\r\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\r\n+                int rgb = img.getRGB(x, y);\r\n+                if (rgb != -1) {\r\n+                    if (x < min.x) min.x = x;\r\n+                    if (y < min.y) min.y = y;\r\n+                    if (x > max.x) max.x = x;\r\n+                    if (y > max.y) max.y = y;\r\n+                }\r\n+            }\r\n+        }\r\n+        if (min.x >= max.x || min.y >= max.y) {\r\n+            return \"Empty image\";\r\n+        }\r\n+        int width = max.x - min.x + 1;\r\n+        int height = max.y - min.y + 1;\r\n+        double ratio = (double) width \/ (double) height;\r\n+        if (ratio > 1.5) {\r\n+            return \"Too wide image, is there few glyphs instead of one?\";\r\n+        }\r\n+        return null;\r\n+    }\r\n+}\r\n","filename":"test\/jdk\/java\/awt\/font\/ComplexEmoji.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\r\n+ * Copyright 2021 JetBrains s.r.o.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @summary Checks that variation selectors work.\r\n+ *\/\r\n+\r\n+import javax.imageio.ImageIO;\r\n+import java.awt.*;\r\n+import java.awt.image.BufferedImage;\r\n+import java.io.File;\r\n+import java.io.IOException;\r\n+import java.util.Arrays;\r\n+import java.util.stream.Collectors;\r\n+\r\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\r\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;\r\n+\r\n+public class EmojiVariation {\r\n+    private static final int IMG_WIDTH = 100;\r\n+    private static final int IMG_HEIGHT = 50;\r\n+\r\n+    private static final Color SYMBOL_COLOR = Color.MAGENTA;\r\n+\r\n+    \/\/ These emoji must be monochrome by default\r\n+    private static final String[] SYMBOLS = {\r\n+            \"\\u0023\",\"\\u002a\",\"\\u0030\",\"\\u0031\",\"\\u0032\",\"\\u0033\",\"\\u0034\",\"\\u0035\",\"\\u0036\",\"\\u0037\",\"\\u0038\",\"\\u0039\",\r\n+            \"\\u00a9\",\"\\u00ae\",\"\\u203c\",\"\\u2049\",\"\\u2122\",\"\\u2139\",\"\\u2194\",\"\\u2195\",\"\\u2196\",\"\\u2197\",\"\\u2198\",\"\\u2199\",\r\n+            \"\\u21a9\",\"\\u21aa\",\"\\u2328\",\"\\u23cf\",\"\\u23ed\",\"\\u23ee\",\"\\u23ef\",\"\\u23f1\",\"\\u23f2\",\"\\u23f8\",\"\\u23f9\",\"\\u23fa\",\r\n+            \"\\u24c2\",\"\\u25aa\",\"\\u25ab\",\"\\u25b6\",\"\\u25c0\",\"\\u25fb\",\"\\u25fc\",\"\\u2600\",\"\\u2601\",\"\\u2602\",\"\\u2603\",\"\\u2604\",\r\n+            \"\\u260e\",\"\\u2611\",\"\\u2618\",\"\\u261d\",\"\\u2620\",\"\\u2622\",\"\\u2623\",\"\\u2626\",\"\\u262a\",\"\\u262e\",\"\\u262f\",\"\\u2638\",\r\n+            \"\\u2639\",\"\\u263a\",\"\\u2640\",\"\\u2642\",\"\\u265f\",\"\\u2660\",\"\\u2663\",\"\\u2665\",\"\\u2666\",\"\\u2668\",\"\\u267b\",\"\\u267e\",\r\n+            \"\\u2692\",\"\\u2694\",\"\\u2695\",\"\\u2696\",\"\\u2697\",\"\\u2699\",\"\\u269b\",\"\\u269c\",\"\\u26a0\",\"\\u26b0\",\"\\u26b1\",\"\\u26c8\",\r\n+            \"\\u26cf\",\"\\u26d1\",\"\\u26d3\",\"\\u26e9\",\"\\u26f0\",\"\\u26f1\",\"\\u26f4\",\"\\u26f7\",\"\\u26f8\",\"\\u26f9\",\"\\u2702\",\"\\u2708\",\r\n+            \"\\u2709\",\"\\u270c\",\"\\u270d\",\"\\u270f\",\"\\u2712\",\"\\u2714\",\"\\u2716\",\"\\u271d\",\"\\u2721\",\"\\u2733\",\"\\u2734\",\"\\u2744\",\r\n+            \"\\u2747\",\"\\u2763\",\"\\u2764\",\"\\u27a1\",\"\\u2934\",\"\\u2935\",\"\\u2b05\",\"\\u2b06\",\"\\u2b07\",\"\\u3030\",\"\\u303d\",\"\\u3297\",\r\n+            \"\\u3299\",\"\\ud83c\\udd70\",\"\\ud83c\\udd71\",\"\\ud83c\\udd7e\",\"\\ud83c\\udd7f\",\"\\ud83c\\ude02\",\"\\ud83c\\ude37\",\r\n+            \"\\ud83c\\udf21\",\"\\ud83c\\udf24\",\"\\ud83c\\udf25\",\"\\ud83c\\udf26\",\"\\ud83c\\udf27\",\"\\ud83c\\udf28\",\"\\ud83c\\udf29\",\r\n+            \"\\ud83c\\udf2a\",\"\\ud83c\\udf2b\",\"\\ud83c\\udf2c\",\"\\ud83c\\udf36\",\"\\ud83c\\udf7d\",\"\\ud83c\\udf96\",\"\\ud83c\\udf97\",\r\n+            \"\\ud83c\\udf99\",\"\\ud83c\\udf9a\",\"\\ud83c\\udf9b\",\"\\ud83c\\udf9e\",\"\\ud83c\\udf9f\",\"\\ud83c\\udfcb\",\"\\ud83c\\udfcc\",\r\n+            \"\\ud83c\\udfcd\",\"\\ud83c\\udfce\",\"\\ud83c\\udfd4\",\"\\ud83c\\udfd5\",\"\\ud83c\\udfd6\",\"\\ud83c\\udfd7\",\"\\ud83c\\udfd8\",\r\n+            \"\\ud83c\\udfd9\",\"\\ud83c\\udfda\",\"\\ud83c\\udfdb\",\"\\ud83c\\udfdc\",\"\\ud83c\\udfdd\",\"\\ud83c\\udfde\",\"\\ud83c\\udfdf\",\r\n+            \"\\ud83c\\udff3\",\"\\ud83c\\udff5\",\"\\ud83c\\udff7\",\"\\ud83d\\udc3f\",\"\\ud83d\\udc41\",\"\\ud83d\\udcfd\",\"\\ud83d\\udd49\",\r\n+            \"\\ud83d\\udd4a\",\"\\ud83d\\udd6f\",\"\\ud83d\\udd70\",\"\\ud83d\\udd73\",\"\\ud83d\\udd74\",\"\\ud83d\\udd75\",\"\\ud83d\\udd76\",\r\n+            \"\\ud83d\\udd77\",\"\\ud83d\\udd78\",\"\\ud83d\\udd79\",\"\\ud83d\\udd87\",\"\\ud83d\\udd8a\",\"\\ud83d\\udd8b\",\"\\ud83d\\udd8c\",\r\n+            \"\\ud83d\\udd8d\",\"\\ud83d\\udd90\",\"\\ud83d\\udda5\",\"\\ud83d\\udda8\",\"\\ud83d\\uddb1\",\"\\ud83d\\uddb2\",\"\\ud83d\\uddbc\",\r\n+            \"\\ud83d\\uddc2\",\"\\ud83d\\uddc3\",\"\\ud83d\\uddc4\",\"\\ud83d\\uddd1\",\"\\ud83d\\uddd2\",\"\\ud83d\\uddd3\",\"\\ud83d\\udddc\",\r\n+            \"\\ud83d\\udddd\",\"\\ud83d\\uddde\",\"\\ud83d\\udde1\",\"\\ud83d\\udde3\",\"\\ud83d\\udde8\",\"\\ud83d\\uddef\",\"\\ud83d\\uddf3\",\r\n+            \"\\ud83d\\uddfa\",\"\\ud83d\\udecb\",\"\\ud83d\\udecd\",\"\\ud83d\\udece\",\"\\ud83d\\udecf\",\"\\ud83d\\udee0\",\"\\ud83d\\udee1\",\r\n+            \"\\ud83d\\udee2\",\"\\ud83d\\udee3\",\"\\ud83d\\udee4\",\"\\ud83d\\udee5\",\"\\ud83d\\udee9\",\"\\ud83d\\udef0\",\"\\ud83d\\udef3\",\r\n+    };\r\n+\r\n+    private enum Variation {\r\n+        DEFAULT(\"\"),\r\n+        MONO(\"\\ufe0e\"),\r\n+        COLOR(\"\\ufe0f\");\r\n+\r\n+        final String suffix;\r\n+\r\n+        Variation(String suffix) {\r\n+            this.suffix = suffix;\r\n+        }\r\n+    }\r\n+\r\n+    public static void main(String[] args) {\r\n+        \/\/ Platform-specific tricks\r\n+       if (System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")) {\r\n+           \/\/ Many emoji on Linux don't have monochrome variants\r\n+           Arrays.fill(SYMBOLS, 28, 37, null);\r\n+            Arrays.fill(SYMBOLS, 83, 94, null);\r\n+            Arrays.fill(SYMBOLS, 117, SYMBOLS.length, null);\r\n+        } else if (System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\r\n+           \/\/ Many emoji on macOS don't have monochrome variants\r\n+           Arrays.fill(SYMBOLS, 28, 36, null);\r\n+            Arrays.fill(SYMBOLS, 83, 94, null);\r\n+            Arrays.fill(SYMBOLS, 127, SYMBOLS.length, null);\r\n+        }\r\n+\r\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\r\n+        String errors = \"\";\r\n+        for (String s : SYMBOLS) {\r\n+            if (s == null) continue;\r\n+            errors += test(img, s, Variation.DEFAULT, false);\r\n+            errors += test(img, s, Variation.MONO, false);\r\n+            errors += test(img, s, Variation.COLOR, true);\r\n+        }\r\n+\r\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\r\n+            \/\/ Bonus points: check that variation selectors work other way too\r\n+            String s = \"\\ud83d\\udd25\";\r\n+            errors += test(img, s, Variation.DEFAULT, true);\r\n+            errors += test(img, s, Variation.MONO, false);\r\n+            errors += test(img, s, Variation.COLOR, true);\r\n+        }\r\n+\r\n+        if (!errors.isEmpty()) throw new RuntimeException(errors);\r\n+    }\r\n+\r\n+    private static String test(BufferedImage img, String symbol, Variation variation, boolean expectColor) {\r\n+        draw(img, symbol + variation.suffix);\r\n+        String error = check(img, expectColor);\r\n+        if (error != null) {\r\n+            String name = symbol.chars().mapToObj(c -> {\r\n+                String s = Integer.toHexString(c);\r\n+                return \"0\".repeat(4 - s.length()) + s;\r\n+            }).collect(Collectors.joining(\"-\")) + \"-\" + variation;\r\n+            try {\r\n+                ImageIO.write(img, \"PNG\", new File(\"EmojiVariation-\" + name + \".png\"));\r\n+            } catch (IOException e) {\r\n+                e.printStackTrace();\r\n+            }\r\n+            return \"\\n\" + name + \": \" + error;\r\n+        }\r\n+        return \"\";\r\n+    }\r\n+\r\n+    private static void draw(Image img, String symbol) {\r\n+        Graphics2D g = (Graphics2D) img.getGraphics();\r\n+        g.setColor(Color.white);\r\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\r\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 50));\r\n+        g.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_OFF);\r\n+        g.setColor(SYMBOL_COLOR);\r\n+        g.drawString(symbol, 2, 42);\r\n+        g.dispose();\r\n+    }\r\n+\r\n+    private static String check(BufferedImage img, boolean expectColor) {\r\n+        boolean rendered = false;\r\n+        boolean color = false;\r\n+        for (int x = 0; x < IMG_WIDTH; x++) {\r\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\r\n+                int rgb = img.getRGB(x, y);\r\n+                if (rgb != Color.white.getRGB()) {\r\n+                    rendered = true;\r\n+                    if ((rgb & 0xff00ff) != 0xff00ff) {\r\n+                        \/\/ When monochrome symbol is rendered with AA=ON,\r\n+                        \/\/ pixel color may be anywhere between magenta (SYMBOL_COLOR) and white,\r\n+                        \/\/ which is 0xff00ff - 0xffffff. This means only green component may vary,\r\n+                        \/\/ red and green must always be 0xff\r\n+                        color = true;\r\n+                    }\r\n+                }\r\n+            }\r\n+        }\r\n+        if (!rendered) {\r\n+            return \"Empty image\";\r\n+        } else if (color != expectColor) {\r\n+            return expectColor ? \"Expected color but rendered mono\" : \"Expected mono but rendered color\";\r\n+        }\r\n+        return null;\r\n+    }\r\n+}\r\n","filename":"test\/jdk\/java\/awt\/font\/EmojiVariation.java","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\r\n+ * Copyright 2021 JetBrains s.r.o.\r\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n+ *\r\n+ * This code is free software; you can redistribute it and\/or modify it\r\n+ * under the terms of the GNU General Public License version 2 only, as\r\n+ * published by the Free Software Foundation.\r\n+ *\r\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\r\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n+ * version 2 for more details (a copy is included in the LICENSE file that\r\n+ * accompanied this code).\r\n+ *\r\n+ * You should have received a copy of the GNU General Public License version\r\n+ * 2 along with this work; if not, write to the Free Software Foundation,\r\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n+ *\r\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n+ * or visit www.oracle.com if you need additional information or have any\r\n+ * questions.\r\n+ *\/\r\n+\r\n+\/*\r\n+ * @test\r\n+ * @summary Checks that emoji rendered via glyph cache and bypassing it look similar.\r\n+ *\/\r\n+\r\n+import javax.imageio.ImageIO;\r\n+import java.awt.*;\r\n+import java.awt.image.BufferedImage;\r\n+import java.io.File;\r\n+\r\n+public class OutlineTextRendererEmoji {\r\n+    private static final int IMG_WIDTH = 84;\r\n+    private static final int IMG_HEIGHT = 84;\r\n+    private static final int EMOJI_X = 7;\r\n+    private static final int EMOJI_Y = 70;\r\n+    private static final int FONT_SIZE = 70;\r\n+    private static final String EMOJI = \"\\ud83d\\udd25\"; \/\/ Fire\r\n+\r\n+    private static final int CHECK_RADIUS = 10; \/\/ In pixels\r\n+    private static final double CHECK_TOLERANCE = 15; \/\/ Euclidean distance between colors\r\n+\r\n+    public static void main(String[] args) throws Exception {\r\n+        BufferedImage small = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\r\n+        BufferedImage big = new BufferedImage(IMG_WIDTH*2, IMG_HEIGHT*2, BufferedImage.TYPE_INT_RGB);\r\n+        drawEmoji(small, EMOJI_X, EMOJI_Y, FONT_SIZE);\r\n+        drawEmoji(big, EMOJI_X*2, EMOJI_Y*2, FONT_SIZE*2);\r\n+        checkEmoji(small, big);\r\n+    }\r\n+\r\n+    private static void drawEmoji(Image img, int x, int y, int size) {\r\n+        Graphics g = img.getGraphics();\r\n+        g.setColor(Color.white);\r\n+        g.fillRect(0, 0, img.getWidth(null), img.getHeight(null));\r\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, size));\r\n+        g.drawString(EMOJI, x, y);\r\n+        g.dispose();\r\n+    }\r\n+\r\n+    private static double distance(int rgb1, int rgb2) {\r\n+        double b = (rgb1 & 0xff) - (rgb2 & 0xff);\r\n+        double g = ((rgb1 >>> 8) & 0xff) - ((rgb2 >>> 8) & 0xff);\r\n+        double r = ((rgb1 >>> 16) & 0xff) - ((rgb2 >>> 16) & 0xff);\r\n+        double a = ((rgb1 >>> 24) & 0xff) - ((rgb2 >>> 24) & 0xff);\r\n+        return Math.sqrt(b*b + g*g + r*r + a*a);\r\n+    }\r\n+\r\n+    private static int sampleRectAvg(BufferedImage img, int x, int y, int width, int height) {\r\n+        int xTo = x + width, yTo = y + height;\r\n+        if (x < 0) x = 0;\r\n+        if (y < 0) y = 0;\r\n+        if (xTo > img.getWidth()) xTo = img.getWidth();\r\n+        if (yTo > img.getHeight()) yTo = img.getHeight();\r\n+\r\n+        int b = 0, g = 0, r = 0, a = 0;\r\n+        for (int i = x; i < xTo; i++) {\r\n+            for (int j = y; j < yTo; j++) {\r\n+                int c = img.getRGB(i, j);\r\n+                b += c & 0xff;\r\n+                g += (c >>> 8) & 0xff;\r\n+                r += (c >>> 16) & 0xff;\r\n+                a += (c >>> 24) & 0xff;\r\n+            }\r\n+        }\r\n+        int count = (xTo - x) * (yTo - y);\r\n+        b \/= count;\r\n+        g \/= count;\r\n+        r \/= count;\r\n+        a \/= count;\r\n+        return b | (g << 8) | (r << 16) | (a << 24);\r\n+    }\r\n+\r\n+    private static void checkEmoji(BufferedImage small, BufferedImage big) throws Exception {\r\n+        boolean empty = true, match = true;\r\n+        for (int x = 0; x < small.getWidth(); x++) {\r\n+            for (int y = 0; y < small.getHeight(); y++) {\r\n+                int s = sampleRectAvg(small, x-CHECK_RADIUS, y-CHECK_RADIUS, 1+2*CHECK_RADIUS, 1+2*CHECK_RADIUS);\r\n+                int b = sampleRectAvg(big, (x-CHECK_RADIUS)*2, (y-CHECK_RADIUS)*2, 1+4*CHECK_RADIUS, 1+4*CHECK_RADIUS);\r\n+                if (s != -1 || b != -1) {\r\n+                    empty = false;\r\n+                    if (distance(s, b) > CHECK_TOLERANCE) match = false;\r\n+                }\r\n+            }\r\n+        }\r\n+        if (empty) {\r\n+            throw new Exception(\"Empty image\");\r\n+        } if (!match) {\r\n+            ImageIO.write(small, \"PNG\", new File(\"OutlineTextRendererEmoji-small.png\"));\r\n+            ImageIO.write(big, \"PNG\", new File(\"OutlineTextRendererEmoji-big.png\"));\r\n+            throw new Exception(\"Images mismatch\");\r\n+        }\r\n+    }\r\n+}\r\n","filename":"test\/jdk\/java\/awt\/font\/OutlineTextRendererEmoji.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"}]}