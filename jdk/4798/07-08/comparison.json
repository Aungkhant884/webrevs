{"files":[{"patch":"@@ -80,5 +80,0 @@\n-    GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n-                                       float x, float y) {\n-        throw new InternalError(\"Not implemented\");\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CFont.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -88,5 +88,0 @@\n-    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n-                                       float x, float y) {\n-        return null;\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/NativeFont.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -329,0 +329,2 @@\n+    CFIndex sbixSize = CFDataGetLength(sbixTable);\n+    if (sbixSize < 8) goto cleanup; \/\/ Corrupted table\n@@ -331,0 +333,1 @@\n+    if (8 + 4 * numStrikes > sbixSize) goto cleanup; \/\/ Corrupted table\n@@ -338,0 +341,1 @@\n+        if (strike + 12 + 4 * glyph > sbix + sbixSize) goto cleanup; \/\/ Corrupted table\n@@ -348,0 +352,1 @@\n+    if (glyphData + 4 > sbix + sbixSize) goto cleanup; \/\/ Corrupted table\n@@ -353,0 +358,1 @@\n+    if (glyphData + size > sbix + sbixSize) goto cleanup; \/\/ Corrupted table\n@@ -403,0 +409,1 @@\n+    if (sbixTable) CFRelease(sbixTable);\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.awt.color.ColorSpace;\n@@ -31,3 +32,1 @@\n-import java.awt.image.BufferedImage;\n-import java.awt.image.ColorModel;\n-import java.awt.image.DirectColorModel;\n+import java.awt.image.*;\n@@ -130,1 +129,1 @@\n-    private static ColorModel colorModel(int bits, int r, int g, int b, int a) {\n+    private static DirectColorModel colorModel(boolean premultiplied, int bits, int r, int g, int b, int a) {\n@@ -137,1 +136,2 @@\n-        return new DirectColorModel(bits, r, g, b, a);\n+        return new DirectColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                bits, r, g, b, a, premultiplied, DataBuffer.TYPE_INT);\n@@ -139,2 +139,2 @@\n-    private static final ColorModel[] BITMAP_COLOR_MODELS = {\n-            colorModel(32, \/\/ macOS RGBA\n+    private static final DirectColorModel[] BITMAP_COLOR_MODELS = {\n+            colorModel(false, 32, \/\/ macOS RGBA\n@@ -145,1 +145,1 @@\n-            colorModel(32, \/\/ macOS ARGB\n+            colorModel(false, 32, \/\/ macOS ARGB\n@@ -150,1 +150,1 @@\n-            colorModel(32, \/\/ Freetype BGRA\n+            colorModel(true, 32, \/\/ Freetype BGRA\n@@ -162,7 +162,4 @@\n-        ColorModel color = BITMAP_COLOR_MODELS[colorModel];\n-        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n-        for (int y = 0; y < height; y++) {\n-            for (int x = 0; x < width; x++) {\n-                image.setRGB(x, y, color.getRGB(data[pitch * y + x]));\n-            }\n-        }\n+        DirectColorModel color = BITMAP_COLOR_MODELS[colorModel];\n+        DataBuffer buffer = new DataBufferInt(data, data.length);\n+        WritableRaster raster = Raster.createPackedRaster(buffer, width, height, pitch, color.getMasks(), null);\n+        BufferedImage image = new BufferedImage(color, raster, color.isAlphaPremultiplied(), null);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphRenderData.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-    \/* These 4 outline methods should be implemented to return\n+    \/* These 3 outline methods should be implemented to return\n@@ -114,3 +114,0 @@\n-\n-    abstract GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n-                                                float x, float y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/PhysicalFont.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -880,4 +880,0 @@\n-        return getGlyphRenderData(0, glyphs.length, x, y);\n-    }\n-\n-    public GlyphRenderData getGlyphRenderData(int start, int count, float x, float y) {\n@@ -888,1 +884,1 @@\n-        for (int i = start, e = start + count, n = start * 2; i < e; ++i, n += 2) {\n+        for (int i = 0, n = 0; i < glyphs.length; ++i, n += 2) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,15 +83,0 @@\n-        int textAAHint = g2d.getFontInfo().aaHint;\n-\n-        int prevaaHint = - 1;\n-        if (textAAHint != SunHints.INTVAL_TEXT_ANTIALIAS_OFF &&\n-            g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {\n-            prevaaHint = g2d.antialiasHint;\n-            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_ON;\n-            g2d.validatePipe();\n-        } else if (textAAHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF\n-            && g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_OFF) {\n-            prevaaHint = g2d.antialiasHint;\n-            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_OFF;\n-            g2d.validatePipe();\n-        }\n-\n@@ -100,5 +85,0 @@\n-\n-        if (prevaaHint != -1) {\n-             g2d.antialiasHint = prevaaHint;\n-             g2d.validatePipe();\n-        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/OutlineTextRenderer.java","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -307,5 +307,0 @@\n-    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n-                                              float x, float y) {\n-        return null;\n-    }\n-\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeFont.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import java.util.stream.Stream;\n@@ -49,0 +50,2 @@\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n@@ -109,0 +112,13 @@\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            throw new Error(\"Required font not found: \" + font);\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/font\/ComplexEmoji.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import java.util.stream.Stream;\n@@ -87,0 +88,3 @@\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+        requireFont(\"Zapf Dingbats\", \"Segoe UI Symbol\", \"DejaVu Sans\");\n+\n@@ -91,2 +95,2 @@\n-            Arrays.fill(SYMBOLS, 83, 94, null);\n-            Arrays.fill(SYMBOLS, 117, SYMBOLS.length, null);\n+           Arrays.fill(SYMBOLS, 83, 94, null);\n+           Arrays.fill(SYMBOLS, 117, SYMBOLS.length, null);\n@@ -96,2 +100,2 @@\n-            Arrays.fill(SYMBOLS, 83, 94, null);\n-            Arrays.fill(SYMBOLS, 127, SYMBOLS.length, null);\n+           Arrays.fill(SYMBOLS, 81, 94, null);\n+           Arrays.fill(SYMBOLS, 127, SYMBOLS.length, null);\n@@ -174,0 +178,13 @@\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            throw new Error(\"Required font not found: \" + font);\n+        }\n+    }\n","filename":"test\/jdk\/java\/awt\/font\/EmojiVariation.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -33,0 +33,4 @@\n+import java.util.stream.Stream;\n+\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;\n@@ -37,1 +41,1 @@\n-    private static final int EMOJI_X = 7;\n+    private static final int EMOJI_X = 0;\n@@ -42,2 +46,2 @@\n-    private static final int CHECK_RADIUS = 10; \/\/ In pixels\n-    private static final double CHECK_TOLERANCE = 15; \/\/ Euclidean distance between colors\n+    private static final int WINDOW_SIZE = 12; \/\/ In pixels\n+    private static final double THRESHOLD = 0.98;\n@@ -46,0 +50,2 @@\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n@@ -47,0 +53,1 @@\n+        BufferedImage rescaled = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n@@ -50,1 +57,1 @@\n-        checkEmoji(small, big);\n+        checkEmoji(small, big, rescaled);\n@@ -54,1 +61,1 @@\n-        Graphics g = img.getGraphics();\n+        Graphics2D g = (Graphics2D) img.getGraphics();\n@@ -58,0 +65,1 @@\n+        g.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);\n@@ -62,7 +70,4 @@\n-    private static double distance(int rgb1, int rgb2) {\n-        double b = (rgb1 & 0xff) - (rgb2 & 0xff);\n-        double g = ((rgb1 >>> 8) & 0xff) - ((rgb2 >>> 8) & 0xff);\n-        double r = ((rgb1 >>> 16) & 0xff) - ((rgb2 >>> 16) & 0xff);\n-        double a = ((rgb1 >>> 24) & 0xff) - ((rgb2 >>> 24) & 0xff);\n-        return Math.sqrt(b*b + g*g + r*r + a*a);\n-    }\n+    private static void checkEmoji(BufferedImage small, BufferedImage big, BufferedImage rescaled) throws Exception {\n+        Graphics2D g2d = rescaled.createGraphics();\n+        g2d.drawImage(big.getScaledInstance(small.getWidth(), small.getHeight(), Image.SCALE_SMOOTH), 0, 0, null);\n+        g2d.dispose();\n@@ -70,16 +75,8 @@\n-    private static int sampleRectAvg(BufferedImage img, int x, int y, int width, int height) {\n-        int xTo = x + width, yTo = y + height;\n-        if (x < 0) x = 0;\n-        if (y < 0) y = 0;\n-        if (xTo > img.getWidth()) xTo = img.getWidth();\n-        if (yTo > img.getHeight()) yTo = img.getHeight();\n-\n-        int b = 0, g = 0, r = 0, a = 0;\n-        for (int i = x; i < xTo; i++) {\n-            for (int j = y; j < yTo; j++) {\n-                int c = img.getRGB(i, j);\n-                b += c & 0xff;\n-                g += (c >>> 8) & 0xff;\n-                r += (c >>> 16) & 0xff;\n-                a += (c >>> 24) & 0xff;\n-            }\n+        double ssim = SSIM.calculate(small, rescaled, WINDOW_SIZE);\n+        System.out.println(\"SSIM is \" + ssim);\n+\n+        if (ssim < THRESHOLD) {\n+            ImageIO.write(small, \"PNG\", new File(\"OutlineTextRendererEmoji-small.png\"));\n+            ImageIO.write(big, \"PNG\", new File(\"OutlineTextRendererEmoji-big.png\"));\n+            ImageIO.write(rescaled, \"PNG\", new File(\"OutlineTextRendererEmoji-rescaled.png\"));\n+            throw new Exception(\"Images mismatch: \" + ssim);\n@@ -87,6 +84,0 @@\n-        int count = (xTo - x) * (yTo - y);\n-        b \/= count;\n-        g \/= count;\n-        r \/= count;\n-        a \/= count;\n-        return b | (g << 8) | (r << 16) | (a << 24);\n@@ -95,9 +86,58 @@\n-    private static void checkEmoji(BufferedImage small, BufferedImage big) throws Exception {\n-        boolean empty = true, match = true;\n-        for (int x = 0; x < small.getWidth(); x++) {\n-            for (int y = 0; y < small.getHeight(); y++) {\n-                int s = sampleRectAvg(small, x-CHECK_RADIUS, y-CHECK_RADIUS, 1+2*CHECK_RADIUS, 1+2*CHECK_RADIUS);\n-                int b = sampleRectAvg(big, (x-CHECK_RADIUS)*2, (y-CHECK_RADIUS)*2, 1+4*CHECK_RADIUS, 1+4*CHECK_RADIUS);\n-                if (s != -1 || b != -1) {\n-                    empty = false;\n-                    if (distance(s, b) > CHECK_TOLERANCE) match = false;\n+    private static class SSIM {\n+        private static double calculate(BufferedImage a, BufferedImage b, int windowSize) {\n+            if (a.getWidth() != b.getWidth() || a.getHeight() != b.getHeight()) {\n+                throw new IllegalArgumentException(\"Images must have same size\");\n+            }\n+            if (a.getWidth() % windowSize != 0 || a.getHeight() % windowSize != 0) {\n+                throw new IllegalArgumentException(\"Image sizes must be multiple of windowSize\");\n+            }\n+\n+            final double K1 = 0.01, K2 = 0.03;\n+            final double L = 255; \/\/ dynamic range per component (2^8 - 1)\n+            final double c1 = Math.pow(L * K1, 2);\n+            final double c2 = Math.pow(L * K2, 2);\n+\n+            double result = 0, alpha = 0;\n+            int windows = 0;\n+            for (int y = 0; y <= a.getHeight() - windowSize; y++) {\n+                for (int x = 0; x <= a.getWidth() - windowSize; x++) {\n+\n+                    \/\/ Calculate averages\n+                    double[] avgA = vec(), avgB = vec();\n+                    for (int py = 0; py < windowSize; py++) {\n+                        for (int px = 0; px < windowSize; px++) {\n+                            avgA = add(avgA, vec(a.getRGB(x + px, y + py)));\n+                            avgB = add(avgB, vec(b.getRGB(x + px, y + py)));\n+                        }\n+                    }\n+                    avgA = div(avgA, windowSize * windowSize);\n+                    avgB = div(avgB, windowSize * windowSize);\n+\n+                    \/\/ Calculate variance and covariance\n+                    double[] varA = vec(), varB = vec(), cov = vec();\n+                    for (int py = 0; py < windowSize; py++) {\n+                        for (int px = 0; px < windowSize; px++) {\n+                            double[] da = sub(avgA, vec(a.getRGB(x + px, y + py)));\n+                            double[] db = sub(avgB, vec(b.getRGB(x + px, y + py)));\n+                            varA = add(varA, mul(da, da));\n+                            varB = add(varB, mul(db, db));\n+                            cov = add(cov, mul(da, db));\n+                        }\n+                    }\n+                    varA = div(varA, windowSize * windowSize);\n+                    varB = div(varB, windowSize * windowSize);\n+                    cov = div(cov, windowSize * windowSize);\n+\n+                    \/\/ Calculate ssim\n+                    double[] ssim = vec();\n+                    for (int i = 0; i < 4; i++) {\n+                        ssim[i] = (\n+                                (2 * avgA[i] * avgB[i] + c1) * (2 * cov[i] + c2)\n+                        ) \/ (\n+                                (avgA[i]*avgA[i] + avgB[i]*avgB[i] + c1) * (varA[i] + varB[i] + c2)\n+                        );\n+                    }\n+\n+                    result += ssim[0] + ssim[1] + ssim[2];\n+                    alpha += ssim[3];\n+                    windows++;\n@@ -106,0 +146,3 @@\n+            if (alpha == windows) result \/= 3.0;\n+            else result = (result + alpha) \/ 4.0;\n+            return result \/ (double) windows;\n@@ -107,6 +150,34 @@\n-        if (empty) {\n-            throw new Exception(\"Empty image\");\n-        } if (!match) {\n-            ImageIO.write(small, \"PNG\", new File(\"OutlineTextRendererEmoji-small.png\"));\n-            ImageIO.write(big, \"PNG\", new File(\"OutlineTextRendererEmoji-big.png\"));\n-            throw new Exception(\"Images mismatch\");\n+\n+        private static double[] vec(double... v) {\n+            if (v.length == 0) return new double[4];\n+            else if (v.length == 1) return new double[] {v[0],v[0],v[0],v[0]};\n+            else return v;\n+        }\n+        private static double[] vec(int color) {\n+            return vec(color & 0xff, (color >> 8) & 0xff, (color >> 16) & 0xff, (color >> 24) & 0xff);\n+        }\n+\n+        interface Op {  double apply(double a, double b); }\n+        private static double[] apply(Op op, double[] a, double... b) {\n+            b = vec(b);\n+            double[] r = new double[4];\n+            for (int i = 0; i < 4; i++) r[i] = op.apply(a[i], b[i]);\n+            return r;\n+        }\n+\n+        private static double[] add(double[] a, double... b) { return apply((i, j) -> i + j, a, b); }\n+        private static double[] sub(double[] a, double... b) { return apply((i, j) -> i - j, a, b); }\n+        private static double[] mul(double[] a, double... b) { return apply((i, j) -> i * j, a, b); }\n+        private static double[] div(double[] a, double... b) { return apply((i, j) -> i \/ j, a, b); }\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            throw new Error(\"Required font not found: \" + font);\n","filename":"test\/jdk\/java\/awt\/font\/OutlineTextRendererEmoji.java","additions":120,"deletions":49,"binary":false,"changes":169,"status":"modified"}]}