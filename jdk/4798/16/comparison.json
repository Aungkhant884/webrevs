{"files":[{"patch":"@@ -91,0 +91,25 @@\n+    private static int unicodeToUnits(int unicode, int dstOffset, char[] dst) {\n+        if (unicode >= 0x10000) {\n+            int base = unicode - 0x10000;\n+            dst[dstOffset] = (char)((base >>> 10) + HI_SURROGATE_START);\n+            dst[dstOffset+1] = (char)((base % 0x400) + LO_SURROGATE_START);\n+            return 2;\n+        } else {\n+            dst[dstOffset] = (char) unicode;\n+            return 1;\n+        }\n+    }\n+\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) return charToGlyph(unicode);\n+        final char[] unicodeArray = new char[4];\n+        final int[] glyphArray = new int[4];\n+\n+        int size = unicodeToUnits(unicode, 0, unicodeArray);\n+        size += unicodeToUnits(variationSelector, size, unicodeArray);\n+\n+        nativeCharsToGlyphs(fFont.getNativeFontPtr(), size, unicodeArray, glyphArray);\n+\n+        return glyphArray[0];\n+    }\n+\n@@ -108,3 +133,1 @@\n-            int base = unicode - 0x10000;\n-            surrogates[0] = (char)((base >>> 10) + HI_SURROGATE_START);\n-            surrogates[1] = (char)((base % 0x400) + LO_SURROGATE_START);\n+            unicodeToUnits(unicode, 0, surrogates);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCharToGlyphMapper.java","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -54,1 +54,18 @@\n-    private int convertToGlyph(int unicode) {\n+    @Override\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) return charToGlyph(unicode);\n+        else {\n+            int glyph = convertToGlyph(unicode, variationSelector);\n+            if (glyph == missingGlyph) glyph = charToGlyph(unicode);\n+            return glyph;\n+        }\n+    }\n+\n+    @Override\n+    protected int convertToGlyph(int unicode) {\n+        int glyph = convertToGlyph(unicode, 0);\n+        return glyph;\n+    }\n+\n+    @Override\n+    protected int convertToGlyph(int unicode, int variationSelector) {\n@@ -57,1 +74,1 @@\n-            int glyphCode = mapper.charToGlyph(unicode);\n+            int glyphCode = mapper.charToVariationGlyph(unicode, variationSelector);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CCompositeGlyphMapper.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    private static native void getNativeGlyphRenderData(long nativeStrikePtr,\n+                                                        int glyphCode,\n+                                                        double x,\n+                                                        double y,\n+                                                        GlyphRenderData result);\n+\n@@ -221,0 +227,6 @@\n+\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        GlyphRenderData result = new GlyphRenderData();\n+        getNativeGlyphRenderData(getNativeStrikePtr(), glyphCode, x, y, result);\n+        return result;\n+    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/CStrike.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/font\/NativeStrike.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -208,9 +208,3 @@\n-\/*\n- * Class:     sun_font_CStrike\n- * Method:    getNativeGlyphOutline\n- * Signature: (JJIDD)Ljava\/awt\/geom\/GeneralPath;\n- *\/\n-JNIEXPORT jobject JNICALL\n-Java_sun_font_CStrike_getNativeGlyphOutline\n-    (JNIEnv *env, jclass clazz,\n-     jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos)\n+jobject getGlyphOutline(JNIEnv *env, AWTStrike *awtStrike,\n+                        CTFontRef font, CGGlyph glyph,\n+                        jdouble xPos, jdouble yPos)\n@@ -219,3 +213,0 @@\n-\n-JNI_COCOA_ENTER(env);\n-\n@@ -231,5 +222,0 @@\n-    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n-    AWTFont *awtfont = awtStrike->fAWTFont;\n-\n-AWT_FONT_CLEANUP_CHECK(awtfont);\n-\n@@ -241,5 +227,0 @@\n-    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n-\n-    CGGlyph glyph;\n-    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n-\n@@ -258,1 +239,0 @@\n-    CFRelease(font);\n@@ -292,1 +272,0 @@\n-JNI_COCOA_EXIT(env);\n@@ -296,0 +275,181 @@\n+\/*\n+ * Class:     sun_font_CStrike\n+ * Method:    getNativeGlyphOutline\n+ * Signature: (JJIDD)Ljava\/awt\/geom\/GeneralPath;\n+ *\/\n+JNIEXPORT jobject JNICALL\n+Java_sun_font_CStrike_getNativeGlyphOutline\n+        (JNIEnv *env, jclass clazz,\n+         jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos) {\n+    jobject generalPath = NULL;\n+\n+    JNI_COCOA_ENTER(env);\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n+    AWTFont *awtfont = awtStrike->fAWTFont;\n+    AWT_FONT_CLEANUP_CHECK(awtfont);\n+\n+    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n+    CGGlyph glyph;\n+    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n+\n+    generalPath = getGlyphOutline(env, awtStrike, font, glyph, xPos, yPos);\n+\n+    cleanup:\n+    CFRelease(font);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    JNI_COCOA_EXIT(env);\n+\n+    return generalPath;\n+}\n+\n+\/\/ OpenType data is Big-Endian\n+#define GET_BE_INT32(data, i) CFSwapInt32BigToHost(*(const UInt32*) ((const UInt8*) (data) + (i)))\n+#define GET_BE_INT16(data, i) CFSwapInt16BigToHost(*(const UInt16*) ((const UInt8*) (data) + (i)))\n+\n+static bool addBitmapRenderData(JNIEnv *env, AWTStrike *awtStrike,\n+                                CTFontRef font, CGGlyph glyph,\n+                                jdouble xPos, jdouble yPos, jobject result) {\n+    bool success = false;\n+\n+    DECLARE_CLASS_RETURN(jc_GlyphRenderData, \"sun\/font\/GlyphRenderData\", false);\n+    DECLARE_METHOD_RETURN(GlyphRenderDataAddBitmap, jc_GlyphRenderData, \"addBitmap\", \"(DDDDDDIIII[I)V\", false);\n+\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    CTFontDescriptorRef descriptor = NULL;\n+    CGFontRef cgFont = CTFontCopyGraphicsFont(font, &descriptor);\n+\n+    CFDataRef sbixTable = CGFontCopyTableForTag(cgFont, kCTFontTableSbix);\n+    if (sbixTable == NULL) goto cleanup;\n+\n+    \/\/ Parse sbix table\n+    CFIndex sbixSize = CFDataGetLength(sbixTable);\n+    if (sbixSize < 8) goto cleanup; \/\/ Corrupted table\n+    const UInt8* sbix = CFDataGetBytePtr(sbixTable);\n+    UInt32 numStrikes = GET_BE_INT32(sbix, 4);\n+    if (8 + 4 * numStrikes > sbixSize) goto cleanup; \/\/ Corrupted table\n+    \/\/ Find last strike which has data for our glyph\n+    \/\/ Last is usually the biggest\n+    const UInt8* glyphData = NULL;\n+    UInt32 size;\n+    UInt16 ppem, ppi;\n+    for (int i = numStrikes - 1; i >= 0; i--) {\n+        const UInt8* strike = sbix + GET_BE_INT32(sbix, 8 + 4 * i);\n+        if (strike + 12 + 4 * glyph > sbix + sbixSize) goto cleanup; \/\/ Corrupted table\n+        UInt32 offset = GET_BE_INT32(strike, 4 + 4 * glyph);\n+        size = GET_BE_INT32(strike, 8 + 4 * glyph) - offset;\n+        if (size > 0) {\n+            ppem = GET_BE_INT16(strike, 0);\n+            ppi = GET_BE_INT16(strike, 2);\n+            glyphData = strike + offset;\n+            break;\n+        }\n+    }\n+    if (glyphData == NULL) goto cleanup;\n+    if (glyphData + 4 > sbix + sbixSize) goto cleanup; \/\/ Corrupted table\n+\n+    \/\/ Read glyph data\n+    FourCharCode graphicType = GET_BE_INT32(glyphData, 4);\n+    glyphData += 8;\n+    size -= 8;\n+    if (glyphData + size > sbix + sbixSize) goto cleanup; \/\/ Corrupted table\n+\n+    \/\/ Decode glyph image\n+    CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, glyphData, size, NULL);\n+    CGImageRef image = NULL;\n+    if (graphicType == 'jpg ') {\n+        image = CGImageCreateWithJPEGDataProvider(dataProvider, NULL, false, kCGRenderingIntentDefault);\n+    } else if (graphicType == 'png ') {\n+        image = CGImageCreateWithPNGDataProvider(dataProvider, NULL, false, kCGRenderingIntentDefault);\n+    }\n+    CGDataProviderRelease(dataProvider);\n+\n+    if (image != NULL) {\n+        CGBitmapInfo info = CGImageGetBitmapInfo(image);\n+        size_t bits = CGImageGetBitsPerPixel(image);\n+        jint colorModel = -1;\n+        if (info & (kCGImageAlphaPremultipliedLast | kCGImageAlphaLast)) colorModel = 0; \/\/ RGBA\n+        else if (info & (kCGImageAlphaPremultipliedFirst | kCGImageAlphaFirst)) colorModel = 1; \/\/ ARGB\n+        if (colorModel != -1 && (info & kCGBitmapFloatComponents) == 0 && bits == 32) {\n+            size_t width = CGImageGetWidth(image);\n+            size_t height = CGImageGetHeight(image);\n+            size_t pitch = CGImageGetBytesPerRow(image) \/ 4;\n+            dataProvider = CGImageGetDataProvider(image);\n+            CFDataRef data = CGDataProviderCopyData(dataProvider);\n+\n+            jbyteArray array = (*env)->NewIntArray(env, pitch * height);\n+            (*env)->SetIntArrayRegion(env, array, 0, pitch * height, (const jint*) CFDataGetBytePtr(data));\n+            CFRelease(data);\n+\n+            double pointSize = 72.0 * ppem \/ ppi;\n+            double scale = 1.0 \/ pointSize;\n+            font = CTFontCreateWithGraphicsFont(cgFont, pointSize, NULL, descriptor);\n+            CGRect bbox = CTFontGetBoundingRectsForGlyphs(font, kCTFontOrientationDefault, &glyph, NULL, 1);\n+            CFRelease(font);\n+            double tx = bbox.origin.x + xPos * pointSize \/ awtStrike->fSize;\n+            double ty = -bbox.origin.y - (double) height + yPos * pointSize \/ awtStrike->fSize;\n+\n+            jdouble m00 = awtStrike->fTx.a * scale, m10 = awtStrike->fTx.b * scale;\n+            jdouble m01 = -awtStrike->fTx.c * scale, m11 = -awtStrike->fTx.d * scale;\n+            jdouble m02 = m00 * tx + m01 * ty, m12 = m10 * tx + m11 * ty;\n+\n+            (*env)->CallVoidMethod(env, result, GlyphRenderDataAddBitmap,\n+                                   m00, m10, m01, m11, m02, m12,\n+                                   width, height, pitch, 0, array);\n+            success = true;\n+        }\n+        CGImageRelease(image);\n+    }\n+\n+    \/\/ Cleanup\n+    cleanup:\n+    if (sbixTable) CFRelease(sbixTable);\n+    if (cgFont) CFRelease(cgFont);\n+    if (descriptor) CFRelease(descriptor);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    return success;\n+}\n+\n+\/*\n+ * Class:     sun_font_CStrike\n+ * Method:    getNativeGlyphRenderData\n+ * Signature: (JIDDLsun\/font\/GlyphRenderData;)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_font_CStrike_getNativeGlyphRenderData\n+        (JNIEnv *env, jclass clazz,\n+         jlong awtStrikePtr, jint glyphCode, jdouble xPos, jdouble yPos, jobject result)\n+{\n+    JNI_COCOA_ENTER(env);\n+\n+    DECLARE_CLASS(jc_GlyphRenderData, \"sun\/font\/GlyphRenderData\");\n+    DECLARE_FIELD(GlyphRenderDataOutline, jc_GlyphRenderData, \"outline\", \"Ljava\/awt\/geom\/GeneralPath;\")\n+\n+    AWT_FONT_CLEANUP_SETUP;\n+\n+    AWTStrike *awtStrike = (AWTStrike *)jlong_to_ptr(awtStrikePtr);\n+    AWTFont *awtfont = awtStrike->fAWTFont;\n+    AWT_FONT_CLEANUP_CHECK(awtfont);\n+\n+    \/\/ get the right font and glyph for this \"Java GlyphCode\"\n+    CGGlyph glyph;\n+    const CTFontRef font = CTS_CopyCTFallbackFontAndGlyphForJavaGlyphCode(awtfont, glyphCode, &glyph);\n+\n+    if (!addBitmapRenderData(env, awtStrike, font, glyph, xPos, yPos, result)) {\n+        jobject gp = getGlyphOutline(env, awtStrike, font, glyph, xPos, yPos);\n+        if (gp != NULL) {\n+            (*env)->SetObjectField(env, result, GlyphRenderDataOutline, gp);\n+        }\n+    }\n+\n+    cleanup:\n+    CFRelease(font);\n+\n+    AWT_FONT_CLEANUP_FINISH;\n+    JNI_COCOA_EXIT(env);\n+}\n+\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/AWTStrike.m","additions":184,"deletions":24,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -588,0 +588,1 @@\n+    glyphInfo->format = (UInt8) pixelSize;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CGGlyphImages.m","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,4 @@\n+#define VS_START  0xFE00\n+#define VS_END    0xFE0F\n+#define VSS_START 0xE0100\n+#define VSS_END   0xE01FF\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CoreTextSupport.h","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -91,0 +91,11 @@\n+int NextUnicode(const UniChar unicodes[], UnicodeScalarValue *codePoint, const size_t index, const size_t limit) {\n+    if (index >= limit) return 0;\n+    UniChar unicode = unicodes[index];\n+    UniChar nextUnicode = (index+1) < limit ? unicodes[index+1] : 0;\n+    bool surrogatePair = unicode >= HI_SURROGATE_START && unicode <= HI_SURROGATE_END\n+                         && nextUnicode >= LO_SURROGATE_START && nextUnicode <= LO_SURROGATE_END;\n+    *codePoint = surrogatePair ? (((int)(unicode - HI_SURROGATE_START)) << 10)\n+                                + nextUnicode - LO_SURROGATE_START + 0x10000 : unicode;\n+    return surrogatePair ? 2 : 1;\n+}\n+\n@@ -104,6 +115,11 @@\n-    size_t i;\n-    for (i = 0; i < count; i++) {\n-        UniChar unicode = unicodes[i];\n-        UniChar nextUnicode = (i+1) < count ? unicodes[i+1] : 0;\n-        bool surrogatePair = unicode >= HI_SURROGATE_START && unicode <= HI_SURROGATE_END\n-                             && nextUnicode >= LO_SURROGATE_START && nextUnicode <= LO_SURROGATE_END;\n+    size_t i, size;\n+    for (i = 0; i < count; i += size) {\n+        UnicodeScalarValue codePoint, variationCodePoint;\n+        int codePointSize = size = NextUnicode(unicodes, &codePoint, i, count);\n+        if (size == 0) break;\n+\n+        int variationSize = NextUnicode(unicodes, &variationCodePoint, i + size , count);\n+        bool hasVariationSelector = variationSize > 0 &&\n+                ((variationCodePoint >= VSS_START && variationCodePoint <= VSS_END) ||\n+                 (variationCodePoint >= VS_START && variationCodePoint <= VS_END));\n+        if (hasVariationSelector) size += variationSize;\n@@ -112,1 +128,1 @@\n-        if (glyph > 0) {\n+        if (glyph > 0 && (!hasVariationSelector || glyphs[i + codePointSize] > 0)) {\n@@ -114,1 +130,0 @@\n-            if (surrogatePair) i++;\n@@ -119,1 +134,1 @@\n-                                                                          surrogatePair ? 2 : 1);\n+                                                                          size);\n@@ -121,1 +136,1 @@\n-            CTFontGetGlyphsForCharacters(fallback, &unicodes[i], &glyphs[i], surrogatePair ? 2 : 1);\n+            CTFontGetGlyphsForCharacters(fallback, &unicodes[i], &glyphs[i], size);\n@@ -127,2 +142,0 @@\n-            int codePoint = surrogatePair ? (((int)(unicode - HI_SURROGATE_START)) << 10)\n-                                            + nextUnicode - LO_SURROGATE_START + 0x10000 : unicode;\n@@ -133,1 +146,0 @@\n-        if (surrogatePair) i++;\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/font\/CoreTextSupport.m","additions":25,"deletions":13,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -716,1 +716,1 @@\n-        if (ginfo->rowBytes == ginfo->width) {\n+        if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE) {\n@@ -727,1 +727,1 @@\n-        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+        } else if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_BGRA) {\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/java2d\/metal\/MTLTextRenderer.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1067,1 +1067,1 @@\n-    final int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n+    static int getControlCodeGlyph(int charCode, boolean noSurrogates) {\n@@ -1080,1 +1080,1 @@\n-    final char getFormatCharGlyph(int charCode) {\n+    static char getFormatCharGlyph(int charCode) {\n@@ -1147,3 +1147,1 @@\n-        static final int VS_NOGLYPH = 0;\n-        private int getGlyph(int charCode, int variationSelector) {\n-            int targetSelector = -1;\n+        private int findVariationSelectorIndex(int variationSelector) {\n@@ -1152,2 +1150,1 @@\n-                    targetSelector = i;\n-                    break;\n+                    return i;\n@@ -1156,0 +1153,5 @@\n+            return -1;\n+        }\n+\n+        static final int VS_NOGLYPH = 0;\n+        private int getGlyph(int charCode, int targetSelector) {\n@@ -1171,0 +1173,1 @@\n+        if (variationSelector == 0) return getGlyph(charCode);\n@@ -1172,8 +1175,9 @@\n-        if (uvs == null) {\n-            glyph = getGlyph(charCode);\n-        } else {\n-            int result = uvs.getGlyph(charCode, variationSelector);\n-            if (result > 0) {\n-                glyph = (char)(result & 0xFFFF);\n-            } else {\n-                glyph = getGlyph(charCode);\n+        if (uvs != null) {\n+            int targetSelector = uvs.findVariationSelectorIndex(variationSelector);\n+            if (targetSelector != -1) {\n+                int result = uvs.getGlyph(charCode, targetSelector);\n+                if (result > 0) {\n+                    glyph = (char)(result & 0xFFFF);\n+                } else {\n+                    glyph = getGlyph(charCode);\n+                }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CMap.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -120,1 +120,5 @@\n-    private int convertToGlyph(int unicode) {\n+    protected int convertToGlyph(int unicode) {\n+        return convertToGlyph(unicode, 0);\n+    }\n+\n+    protected int convertToGlyph(int unicode, int variationSelector) {\n@@ -125,1 +129,1 @@\n-                int glyphCode = mapper.charToGlyph(unicode);\n+                int glyphCode = mapper.charToVariationGlyph(unicode, variationSelector);\n@@ -128,1 +132,1 @@\n-                    setCachedGlyphCode(unicode, glyphCode);\n+                    if (variationSelector == 0) setCachedGlyphCode(unicode, glyphCode);\n@@ -136,0 +140,22 @@\n+    @Override\n+    public int charToVariationGlyph(int unicode, int variationSelector) {\n+        if (variationSelector == 0) return charToGlyph(unicode);\n+        else {\n+            int glyph = convertToGlyph(unicode, variationSelector);\n+            \/\/ Glyph variation not found, fallback to base glyph.\n+            \/\/ In fallback from variation glyph we ignore excluded chars,\n+            \/\/ this is needed for proper display of monochrome emoji (\\ufe0e)\n+            if (glyph == missingGlyph) {\n+                for (int slot = 0; slot < font.numSlots; slot++) {\n+                    CharToGlyphMapper mapper = getSlotMapper(slot);\n+                    glyph = mapper.charToGlyph(unicode);\n+                    if (glyph != mapper.getMissingGlyphCode()) {\n+                        glyph = compositeGlyphCode(slot, glyph);\n+                        break;\n+                    }\n+                }\n+            }\n+            return glyph;\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeGlyphMapper.java","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -217,0 +217,5 @@\n+\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        PhysicalStrike strike = getStrikeForGlyph(glyphCode);\n+        return strike.getGlyphRenderData(glyphCode & SLOTMASK, x, y);\n+    }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/CompositeStrike.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -233,0 +233,10 @@\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                              float x, float y) {\n+        try {\n+            return getScaler().getGlyphRenderData(pScalerContext, glyphCode, x, y);\n+        } catch (FontScalerException fe) {\n+            scaler = FontScaler.getNullScaler();\n+            return getGlyphRenderData(pScalerContext, glyphCode, x, y);\n+        }\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFont.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -222,1 +222,2 @@\n-            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize)) {\n+            !((TrueTypeFont)fileFont).useEmbeddedBitmapsForSize(intPtSize) &&\n+            !((TrueTypeFont)fileFont).hasCOLRTable()) {\n@@ -742,1 +743,3 @@\n-        int width = StrikeCache.unsafe.getChar(ptr+StrikeCache.widthOffset);\n+        byte format = StrikeCache.unsafe.getByte(ptr+StrikeCache.formatOffset);\n+        if (format != StrikeCache.PIXEL_FORMAT_LCD) return origMinX;\n+\n@@ -747,4 +750,0 @@\n-        if (rowBytes == width) {\n-            return origMinX;\n-        }\n-\n@@ -937,0 +936,31 @@\n+    private\n+        WeakReference<ConcurrentHashMap<Integer, GlyphRenderData>> glyphRenderDataMapRef;\n+\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+\n+        GlyphRenderData grd = null;\n+        ConcurrentHashMap<Integer, GlyphRenderData> glyphRenderDataMap = null;\n+\n+        if (glyphRenderDataMapRef != null) {\n+            glyphRenderDataMap = glyphRenderDataMapRef.get();\n+            if (glyphRenderDataMap != null) {\n+                grd = glyphRenderDataMap.get(glyphCode);\n+            }\n+        }\n+\n+        if (grd == null) {\n+            grd = fileFont.getGlyphRenderData(pScalerContext, glyphCode, 0, 0);\n+            if (glyphRenderDataMap == null) {\n+                glyphRenderDataMap = new ConcurrentHashMap<>();\n+                glyphRenderDataMapRef = new WeakReference<>(glyphRenderDataMap);\n+            }\n+            glyphRenderDataMap.put(glyphCode, grd);\n+        }\n+        grd = new GlyphRenderData(grd); \/\/ mutable!\n+        if (x != 0f || y != 0f) {\n+            grd.transform(AffineTransform.getTranslateInstance(x, y));\n+        }\n+        return grd;\n+    }\n+\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FileFontStrike.java","additions":36,"deletions":6,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -121,1 +121,3 @@\n-        int sl = mapper.charToGlyph(ch) & CompositeGlyphMapper.SLOTMASK;\n+        int nch = nextCodePoint(lim);\n+        int vs = CharToGlyphMapper.isVariationSelector(nch) ? nch : 0;\n+        int sl = mapper.charToVariationGlyph(ch, vs) & CompositeGlyphMapper.SLOTMASK;\n@@ -123,1 +125,10 @@\n-        while ((ch = nextCodePoint(lim)) != DONE && (mapper.charToGlyph(ch) & CompositeGlyphMapper.SLOTMASK) == sl);\n+        do {\n+            if (vs == 0) {\n+                ch = nch;\n+            } else {\n+                ch = nextCodePoint(lim);\n+            }\n+            nch = nextCodePoint(lim);\n+            vs = CharToGlyphMapper.isVariationSelector(nch) ? nch : 0;\n+        } while(ch != DONE && isSameRun(ch, vs, sl));\n+        pushback(nch);\n@@ -129,0 +140,9 @@\n+    private boolean isSameRun(int ch, int variationSelector, int currentSlot) {\n+        \/\/ Every font is meant to be able to render format chars\n+        \/\/ So we make format chars stick to the current font run\n+        if (CMap.getFormatCharGlyph(ch) == CharToGlyphMapper.INVISIBLE_GLYPH_ID) {\n+            return true;\n+        }\n+        return (mapper.charToVariationGlyph(ch, variationSelector) & CompositeGlyphMapper.SLOTMASK) == currentSlot;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontRunIterator.java","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -171,0 +171,4 @@\n+    abstract GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                float x, float y)\n+                throws FontScalerException;\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontScaler.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+    abstract GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontStrike.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    public static final int MAX_LAYOUT_CHARCODE = 0x206F;\n+    public static final int MAX_LAYOUT_CHARCODE = CharToGlyphMapper.VSS_END;\n@@ -308,0 +308,15 @@\n+        else if (code >= 0x20d0 && code <= 0x20f0) { \/\/ U+20D0 - U+20F0 combining diacritical marks for symbols\n+            return true;\n+        }\n+        else if (code >= 0x1f1e6 && code <= 0x1f1ff) { \/\/ U+1F1E6 - U+1F1FF flag letters https:\/\/emojipedia.org\/emoji-flag-sequence\/\n+            return true;\n+        }\n+        else if (code == 0x1f3f4) { \/\/ black flag https:\/\/emojipedia.org\/emoji-tag-sequence\/\n+            return true;\n+        }\n+        else if (code >= 0x1f3fb && code <= 0x1f3ff) { \/\/ U+1F3FB - U+1F3FF emoji modifiers\n+            return true;\n+        }\n+        else if (CharToGlyphMapper.isVariationSelector(code)) {\n+            return true;\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontUtilities.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -166,0 +166,15 @@\n+    synchronized GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                                    float x, float y) throws FontScalerException {\n+        if (nativeScaler != 0L) {\n+            GlyphRenderData result = new GlyphRenderData();\n+            getGlyphRenderDataNative(font.get(),\n+                                     pScalerContext,\n+                                     nativeScaler,\n+                                     glyphCode,\n+                                     x, y, result);\n+            return result;\n+        }\n+        return FontScaler.getNullScaler().\n+                getGlyphRenderData(0L, glyphCode, x,y);\n+    }\n+\n@@ -256,0 +271,3 @@\n+    private native void getGlyphRenderDataNative(Font2D font, long pScalerContext,\n+            long pScaler, int glyphCode,\n+            float x, float y, GlyphRenderData result);\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FreetypeFontScaler.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -505,1 +505,10 @@\n-        return FontUtilities.isMacOSX;\n+        return true;\n+    }\n+\n+    \/**\n+     * @return {@link StrikeCache#PIXEL_FORMAT_GREYSCALE} for greyscale,\n+     * {@link StrikeCache#PIXEL_FORMAT_LCD} for LCD and {@link StrikeCache#PIXEL_FORMAT_BGRA} for BGRA glyph\n+     *\/\n+    public byte getPixelFormat(int glyphIndex) {\n+        return StrikeCache.unsafe.getByte(images[glyphIndex] +\n+                StrikeCache.formatOffset);\n@@ -509,5 +518,1 @@\n-        int width = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                               StrikeCache.widthOffset);\n-        int rowBytes = StrikeCache.unsafe.getChar(images[glyphIndex] +\n-                                                  StrikeCache.rowBytesOffset);\n-        return rowBytes == width * 4;\n+        return getPixelFormat(glyphIndex) == StrikeCache.PIXEL_FORMAT_BGRA;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright 2000-2022 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.font;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.awt.*;\n+import java.awt.color.ColorSpace;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.GeneralPath;\n+import java.awt.image.*;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Data for rendering any number of glyphs bypassing glyph cache.\n+ *\/\n+public class GlyphRenderData {\n+\n+    public GeneralPath outline;\n+    public List<ColorLayer> colorLayers;\n+    public List<Bitmap> bitmaps;\n+\n+    public GlyphRenderData() {}\n+    public GlyphRenderData(GlyphRenderData i) {\n+        if (i.outline != null) outline = (GeneralPath) i.outline.clone();\n+        if (i.colorLayers != null) {\n+            colorLayers = new ArrayList<>(i.colorLayers.size());\n+            for (ColorLayer l : i.colorLayers) {\n+                colorLayers.add(new ColorLayer(l.color, (GeneralPath) l.outline.clone()));\n+            }\n+        }\n+        if (i.bitmaps != null) {\n+            bitmaps = new ArrayList<>(i.bitmaps.size());\n+            for (Bitmap b : i.bitmaps) {\n+                bitmaps.add(new Bitmap(new AffineTransform(b.transform), b.image));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * @param i must not be used afterwards\n+     *\/\n+    public void merge(GlyphRenderData i) {\n+        if (i.outline != null) {\n+            if (outline == null) outline = i.outline;\n+            else outline.append(i.outline.getPathIterator(null), false);\n+        }\n+        if (i.colorLayers != null) {\n+            if (colorLayers == null) colorLayers = i.colorLayers;\n+            else colorLayers.addAll(i.colorLayers);\n+        }\n+        if (i.bitmaps != null) {\n+            if (bitmaps == null) bitmaps = i.bitmaps;\n+            else bitmaps.addAll(i.bitmaps);\n+        }\n+    }\n+\n+    public void transform(AffineTransform transform) {\n+        if (outline != null) outline.transform(transform);\n+        if (colorLayers != null) {\n+            for (ColorLayer layer : colorLayers) {\n+                layer.outline.transform(transform);\n+            }\n+        }\n+        if (bitmaps != null) {\n+            for (Bitmap bitmap : bitmaps) {\n+                bitmap.transform.preConcatenate(transform);\n+            }\n+        }\n+    }\n+\n+    public void draw(Graphics2D g) {\n+        if (outline != null) g.fill(outline);\n+        if (colorLayers != null) {\n+            Color color = g.getColor();\n+            for (ColorLayer layer : colorLayers) {\n+                g.setColor(layer.color == null ? color : layer.color);\n+                g.fill(layer.outline);\n+            }\n+            g.setColor(color);\n+        }\n+        if (bitmaps != null) {\n+            for (Bitmap bitmap : bitmaps) {\n+                g.drawImage(bitmap.image, bitmap.transform, null);\n+            }\n+        }\n+    }\n+\n+    public record ColorLayer(Color color, GeneralPath outline) {}\n+\n+    public record Bitmap(AffineTransform transform, Image image) {}\n+\n+    \/\/ These methods exist for convenience and are called from native\n+\n+    private void setColorLayersList(int capacity) {\n+        colorLayers = new ArrayList<>(capacity);\n+    }\n+\n+    private void addColorLayers(GeneralPath outline) {\n+        colorLayers.add(new ColorLayer(null, outline));\n+    }\n+\n+    private void addColorLayers(int r, int g, int b, int a, GeneralPath outline) {\n+        colorLayers.add(new ColorLayer(new Color(r, g, b, a), outline));\n+    }\n+\n+    private static DirectColorModel colorModel(boolean premultiplied, int bits, int r, int g, int b, int a) {\n+        if (Unsafe.getUnsafe().isBigEndian()) {\n+            r = Integer.reverse(r) >>> (32 - bits);\n+            g = Integer.reverse(g) >>> (32 - bits);\n+            b = Integer.reverse(b) >>> (32 - bits);\n+            a = Integer.reverse(a) >>> (32 - bits);\n+        }\n+        return new DirectColorModel(ColorSpace.getInstance(ColorSpace.CS_sRGB),\n+                bits, r, g, b, a, premultiplied, DataBuffer.TYPE_INT);\n+    }\n+    private static final DirectColorModel[] BITMAP_COLOR_MODELS = {\n+            colorModel(false, 32, \/\/ macOS RGBA\n+                    0x000000ff,\n+                    0x0000ff00,\n+                    0x00ff0000,\n+                    0xff000000),\n+            colorModel(false, 32, \/\/ macOS ARGB\n+                    0x0000ff00,\n+                    0x00ff0000,\n+                    0xff000000,\n+                    0x000000ff),\n+            colorModel(true, 32, \/\/ Freetype BGRA\n+                    0x00ff0000,\n+                    0x0000ff00,\n+                    0x000000ff,\n+                    0xff000000)\n+    };\n+    private void addBitmap(double m00, double m10,\n+                           double m01, double m11,\n+                           double m02, double m12,\n+                           int width, int height, int pitch,\n+                           int colorModel, int[] data) {\n+        if (bitmaps == null) bitmaps = new ArrayList<>();\n+        DirectColorModel color = BITMAP_COLOR_MODELS[colorModel];\n+        DataBuffer buffer = new DataBufferInt(data, data.length);\n+        WritableRaster raster = Raster.createPackedRaster(buffer, width, height, pitch, color.getMasks(), null);\n+        BufferedImage image = new BufferedImage(color, raster, color.isAlphaPremultiplied(), null);\n+        bitmaps.add(new Bitmap(new AffineTransform(m00, m10, m01, m11, m02, m12), image));\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphRenderData.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -67,0 +67,5 @@\n+    GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                       float x, float y) {\n+        return new GlyphRenderData();\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/NullFontScaler.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -879,0 +879,15 @@\n+    public GlyphRenderData getGlyphRenderData(float x, float y) {\n+        setFRCTX();\n+        initPositions();\n+\n+        GlyphRenderData result = new GlyphRenderData();\n+        for (int i = 0, n = 0; i < glyphs.length; ++i, n += 2) {\n+            float px = x + positions[n];\n+            float py = y + positions[n+1];\n+\n+            getGlyphStrike(i).appendGlyphRenderData(glyphs[i], result, px, py);\n+        }\n+\n+        return result;\n+    }\n+\n@@ -1818,0 +1833,13 @@\n+\n+        void appendGlyphRenderData(int glyphID, GlyphRenderData result, float x, float y) {\n+            \/\/ !!! fontStrike needs a method for this.  For that matter, GeneralPath does.\n+            GlyphRenderData grd;\n+            if (sgv.invdtx == null) {\n+                grd = strike.getGlyphRenderData(glyphID, x + dx, y + dy);\n+            } else {\n+                grd = strike.getGlyphRenderData(glyphID, 0, 0);\n+                grd.transform(sgv.invdtx);\n+                grd.transform(AffineTransform.getTranslateInstance(x + dx, y + dy));\n+            }\n+            result.merge(grd);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StandardGlyphVector.java","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.lang.annotation.Native;\n@@ -117,0 +118,1 @@\n+    static int formatOffset;\n@@ -119,0 +121,5 @@\n+    @Native public static final byte PIXEL_FORMAT_UNKNOWN   = -1;\n+    @Native public static final byte PIXEL_FORMAT_GREYSCALE = 1;\n+    @Native public static final byte PIXEL_FORMAT_LCD       = 3;\n+    @Native public static final byte PIXEL_FORMAT_BGRA      = 4;\n+\n@@ -143,1 +150,1 @@\n-        long[] nativeInfo = new long[13];\n+        long[] nativeInfo = new long[14];\n@@ -160,0 +167,1 @@\n+        formatOffset = (int) nativeInfo[13];\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/StrikeCache.java","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -100,0 +100,1 @@\n+    public static final int COLRTag = 0x434f4c52; \/\/ 'COLR'\n@@ -880,0 +881,4 @@\n+    boolean hasCOLRTable() {\n+        return getDirectoryEntry(COLRTag) != null;\n+    }\n+\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/TrueTypeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import sun.font.StrikeCache;\n@@ -44,1 +45,1 @@\n-        boolean isColor = false;\n+        byte pixelFormat = StrikeCache.PIXEL_FORMAT_UNKNOWN;\n@@ -49,4 +50,4 @@\n-                boolean newIsColor = gl.isColorGlyph(i);\n-                if (newIsColor != isColor) {\n-                    drawGlyphListSegment(sg2d, gl, prevLimit, i, aaHint,\n-                            isColor);\n+                byte newFormat = gl.getPixelFormat(i);\n+                if (newFormat != pixelFormat) {\n+                    drawGlyphListSegment(sg2d, gl,\n+                            prevLimit, i, aaHint, pixelFormat);\n@@ -54,1 +55,1 @@\n-                    isColor = newIsColor;\n+                    pixelFormat = newFormat;\n@@ -58,1 +59,1 @@\n-        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, isColor);\n+        drawGlyphListSegment(sg2d, gl, prevLimit, len, aaHint, pixelFormat);\n@@ -63,1 +64,1 @@\n-                                      int aaHint, boolean isColor) {\n+                                      int aaHint, byte pixelFormat) {\n@@ -65,7 +66,3 @@\n-        if (isColor) {\n-            sg2d.loops.drawGlyphListColorLoop.\n-                    DrawGlyphListColor(sg2d, sg2d.surfaceData,\n-                            gl, fromglyph, toGlyph);\n-        } else {\n-            switch (aaHint) {\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_OFF:\n+        switch (pixelFormat) {\n+            case StrikeCache.PIXEL_FORMAT_GREYSCALE:\n+                if (aaHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF) {\n@@ -75,2 +72,1 @@\n-                    return;\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_ON:\n+                } else {\n@@ -80,8 +76,12 @@\n-                    return;\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_HRGB:\n-                case SunHints.INTVAL_TEXT_ANTIALIAS_LCD_VRGB:\n-                    sg2d.loops.drawGlyphListLCDLoop.\n-                            DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n-                                    gl, fromglyph, toGlyph);\n-                    return;\n-            }\n+                }\n+                return;\n+            case StrikeCache.PIXEL_FORMAT_LCD:\n+                sg2d.loops.drawGlyphListLCDLoop.\n+                        DrawGlyphListLCD(sg2d, sg2d.surfaceData,\n+                                gl, fromglyph, toGlyph);\n+                return;\n+            case StrikeCache.PIXEL_FORMAT_BGRA:\n+                sg2d.loops.drawGlyphListColorLoop.\n+                        DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                                gl, fromglyph, toGlyph);\n+                return;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/GlyphListLoopPipe.java","additions":25,"deletions":25,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+\n+import sun.font.GlyphRenderData;\n+import sun.font.StandardGlyphVector;\n@@ -34,3 +37,1 @@\n-import java.awt.Shape;\n-import java.awt.geom.AffineTransform;\n-import java.awt.font.TextLayout;\n+import java.awt.geom.GeneralPath;\n@@ -81,16 +82,0 @@\n-        Shape s = tl.getOutline(AffineTransform.getTranslateInstance(x, y));\n-\n-        int textAAHint = g2d.getFontInfo().aaHint;\n-\n-        int prevaaHint = - 1;\n-        if (textAAHint != SunHints.INTVAL_TEXT_ANTIALIAS_OFF &&\n-            g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_ON) {\n-            prevaaHint = g2d.antialiasHint;\n-            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_ON;\n-            g2d.validatePipe();\n-        } else if (textAAHint == SunHints.INTVAL_TEXT_ANTIALIAS_OFF\n-            && g2d.antialiasHint != SunHints.INTVAL_ANTIALIAS_OFF) {\n-            prevaaHint = g2d.antialiasHint;\n-            g2d.antialiasHint =  SunHints.INTVAL_ANTIALIAS_OFF;\n-            g2d.validatePipe();\n-        }\n@@ -98,6 +83,2 @@\n-        g2d.fill(s);\n-\n-        if (prevaaHint != -1) {\n-             g2d.antialiasHint = prevaaHint;\n-             g2d.validatePipe();\n-        }\n+        \/\/ This will end up calling our drawGlyphVector\n+        tl.draw(g2d, (float) x, (float) y);\n@@ -109,0 +90,7 @@\n+        GlyphRenderData grd;\n+        if (gv instanceof StandardGlyphVector) {\n+            grd = ((StandardGlyphVector) gv).getGlyphRenderData(x, y);\n+        } else {\n+            grd = new GlyphRenderData();\n+            grd.outline = new GeneralPath(gv.getOutline(x, y));\n+        }\n@@ -110,1 +98,0 @@\n-        Shape s = gv.getOutline(x, y);\n@@ -137,1 +124,1 @@\n-        g2d.fill(s);\n+        grd.draw(g2d);\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/OutlineTextRenderer.java","additions":14,"deletions":27,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"sun_font_StrikeCache.h\"\n@@ -77,1 +78,2 @@\n-    UInt8         managed;\n+    UInt8        managed;\n+    UInt8        format; \/\/ sun_font_StrikeCache_PIXEL_FORMAT_*\n","filename":"src\/java.desktop\/share\/native\/common\/font\/fontscalerdefs.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -83,0 +83,6 @@\n+\n+    \/* sun\/font\/GlyphRenderData *\/\n+    jfieldID glyphRenderDataOutline, glyphRenderDataColorLayers;\n+    jmethodID glyphRenderDataSetColorLayersListMID,\n+      glyphRenderDataAddColorLayerMID, glyphRenderDataAddColorLayerFGMID,\n+      glyphRenderDataAddBitmapMID;\n","filename":"src\/java.desktop\/share\/native\/common\/font\/sunfontids.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1090,1 +1090,1 @@\n-        if (ginfo->rowBytes == ginfo->width) {\n+        if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE) {\n@@ -1099,1 +1099,1 @@\n-        } else if (ginfo->rowBytes == ginfo->width * 4) {\n+        } else if (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_BGRA) {\n","filename":"src\/java.desktop\/share\/native\/common\/java2d\/opengl\/OGLTextRenderer.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -548,2 +548,1 @@\n-        \/* rowBytes==width tests if its a B&W or LCD glyph *\/\n-        if (ginfo->width == ginfo->rowBytes) {\n+        if (ginfo->format != sun_font_StrikeCache_PIXEL_FORMAT_LCD) {\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/DrawGlyphList.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -47,0 +47,10 @@\n+\/\/ Linux is built with system Freetype by default,\n+\/\/ and it's often a bit old and doesn't have FT_COLOR_H.\n+\/\/ Thus, we disable colored outlines on Linux to be able\n+\/\/ to build on older Linuxes, this is not a big problem,\n+\/\/ as Linux uses bitmap emoji anyway.\n+#if defined(_WIN32) || defined(__APPLE__)\n+#include FT_COLOR_H\n+#define ENABLE_COLOR_OUTLINES\n+#endif\n+\n@@ -59,0 +69,10 @@\n+#define  FT26Dot6ToInt(x) (((int)(x)) >> 6)\n+#define  FT26Dot6ToIntRound(x) (((int)(x + (1 << 5))) >> 6)\n+#define  FT26Dot6ToIntCeil(x) (((int)(x - 1 + (1 << 6))) >> 6)\n+#define  IntToFT26Dot6(x) (((FT_Fixed)(x)) << 6)\n+\n+\/\/ Define these manually when building with old Freetype (before 2.5)\n+#if !defined(FT_LOAD_COLOR)\n+#define FT_LOAD_COLOR ( 1L << 20 )\n+#define FT_PIXEL_MODE_BGRA 7\n+#endif\n@@ -93,0 +113,3 @@\n+    int        fixedSizeIndex;\/* -1 for scalable fonts and index inside\n+                               * scalerInfo->face->available_sizes otherwise *\/\n+    jboolean colorFont;\n@@ -95,0 +118,7 @@\n+\/* SampledBGRABitmap contains (possibly) downscaled image data\n+ * prepared for sampling when generating transformed bitmap *\/\n+typedef struct SampledBGRABitmap {\n+    unsigned char* data;\n+    int left, top, width, height, rowBytes, xDownscale, yDownscale;\n+} SampledBGRABitmap;\n+\n@@ -325,1 +355,1 @@\n-    (context->doBold ? BOLD_FACTOR(units_per_EM, y_scale) : 0)\n+    ((context->doBold && !context->colorFont) ? BOLD_FACTOR(units_per_EM, y_scale) : 0)\n@@ -564,1 +594,1 @@\n-    if (context->doItalize) {\n+    if (context->doItalize && !context->colorFont) {\n@@ -591,0 +621,4 @@\n+        context->colorFont =\n+            FT_HAS_COLOR(scalerInfo->face) || !FT_IS_SCALABLE(scalerInfo->face) ?\n+            JNI_TRUE : JNI_FALSE;\n+\n@@ -594,1 +628,23 @@\n-        errCode = FT_Set_Char_Size(scalerInfo->face, 0, context->ptsz, 72, 72);\n+        int charSize;\n+        if (FT_IS_SCALABLE(scalerInfo->face)) { \/\/ Standard scalable face\n+            context->fixedSizeIndex = -1;\n+            charSize = context->ptsz;\n+        } else { \/\/ Non-scalable face (that should only be bitmap faces)\n+            const int ptsz = context->ptsz;\n+            \/\/ Best size is smallest, but not smaller than requested\n+            int bestSizeIndex = 0;\n+            FT_Pos bestSize = scalerInfo->face->available_sizes[0].size;\n+            int i;\n+            for (i = 1; i < scalerInfo->face->num_fixed_sizes; i++) {\n+                FT_Pos size = scalerInfo->face->available_sizes[i].size;\n+                if ((size >= ptsz && bestSize >= ptsz && size < bestSize) ||\n+                    (size < ptsz && bestSize < ptsz && size > bestSize) ||\n+                    (size >= ptsz && bestSize < ptsz)) {\n+                    bestSizeIndex = i;\n+                    bestSize = size;\n+                }\n+            }\n+            context->fixedSizeIndex = bestSizeIndex;\n+            charSize = (int) bestSize;\n+        }\n+        errCode = FT_Set_Char_Size(scalerInfo->face, 0, charSize, 72, 72);\n@@ -607,1 +663,2 @@\n-#define OBLIQUE_MODIFIER(y)  (context->doItalize ? ((y)*FT_MATRIX_OBLIQUE_XY\/FT_MATRIX_ONE) : 0)\n+#define OBLIQUE_MODIFIER(y) \\\n+    ((context->doItalize && !context->colorFont) ? ((y)*FT_MATRIX_OBLIQUE_XY\/FT_MATRIX_ONE) : 0)\n@@ -668,30 +725,56 @@\n-    \/*\n-     * See FreeType source code: src\/base\/ftobjs.c ft_recompute_scaled_metrics()\n-     * http:\/\/icedtea.classpath.org\/bugzilla\/show_bug.cgi?id=1659\n-     *\/\n-    \/* ascent *\/\n-    ax = 0;\n-    ay = -(jfloat) (FT_MulFixFloatShift6(\n-                       ((jlong) scalerInfo->face->ascender),\n-                       (jlong) scalerInfo->face->size->metrics.y_scale));\n-    \/* descent *\/\n-    dx = 0;\n-    dy = -(jfloat) (FT_MulFixFloatShift6(\n-                       ((jlong) scalerInfo->face->descender),\n-                       (jlong) scalerInfo->face->size->metrics.y_scale));\n-    \/* baseline *\/\n-    bx = by = 0;\n-\n-    \/* leading *\/\n-    lx = 0;\n-    ly = (jfloat) (FT_MulFixFloatShift6(\n-                      (jlong) scalerInfo->face->height,\n-                      (jlong) scalerInfo->face->size->metrics.y_scale))\n-                  + ay - dy;\n-    \/* max advance *\/\n-    mx = (jfloat) FT26Dot6ToFloat(\n-                     scalerInfo->face->size->metrics.max_advance +\n-                     OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +\n-                     BOLD_MODIFIER(scalerInfo->face->units_per_EM,\n-                             scalerInfo->face->size->metrics.y_scale));\n-    my = 0;\n+    if (context->fixedSizeIndex == -1) {\n+        \/*\n+         * See FreeType source code: src\/base\/ftobjs.c ft_recompute_scaled_metrics()\n+         * http:\/\/icedtea.classpath.org\/bugzilla\/show_bug.cgi?id=1659\n+         *\/\n+        \/* ascent *\/\n+        ax = 0;\n+        ay = -(jfloat) (FT_MulFixFloatShift6(\n+                ((jlong) scalerInfo->face->ascender),\n+                (jlong) scalerInfo->face->size->metrics.y_scale));\n+        \/* descent *\/\n+        dx = 0;\n+        dy = -(jfloat) (FT_MulFixFloatShift6(\n+                ((jlong) scalerInfo->face->descender),\n+                (jlong) scalerInfo->face->size->metrics.y_scale));\n+        \/* baseline *\/\n+        bx = by = 0;\n+\n+        \/* leading *\/\n+        lx = 0;\n+        ly = (jfloat) (FT_MulFixFloatShift6(\n+                (jlong) scalerInfo->face->height,\n+                (jlong) scalerInfo->face->size->metrics.y_scale))\n+             + ay - dy;\n+        \/* max advance *\/\n+        mx = (jfloat) FT26Dot6ToFloat(\n+                scalerInfo->face->size->metrics.max_advance +\n+                OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +\n+                BOLD_MODIFIER(scalerInfo->face->units_per_EM,\n+                              scalerInfo->face->size->metrics.y_scale));\n+        my = 0;\n+    } else {\n+        \/* Just manually scale metrics for non-scalable fonts *\/\n+        FT_Fixed scale = FT_DivFix(context->ptsz,\n+                                   scalerInfo->face->available_sizes[context->fixedSizeIndex].size);\n+        \/* ascent *\/\n+        ax = 0;\n+        ay = -(jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.ascender, scale);\n+        \/* descent *\/\n+        dx = 0;\n+        dy = -(jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.descender, scale);\n+        \/* baseline *\/\n+        bx = by = 0;\n+\n+        \/* leading *\/\n+        lx = 0;\n+        ly = (jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.height, scale) + ay - dy;\n+        \/* max advance *\/\n+        \/* no bold\/italic transformations for non-scalable fonts *\/\n+        mx = (jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.max_advance, scale);\n+        my = 0;\n+    }\n@@ -715,1 +798,1 @@\n-        jboolean renderImage);\n+        jboolean renderImage, jboolean setupContext);\n@@ -744,1 +827,1 @@\n-          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE);\n+          env, scaler, font2D, pScalerContext, pScaler, glyphCode, JNI_FALSE, JNI_TRUE);\n@@ -770,1 +853,1 @@\n-                                 pScalerContext, pScaler, glyphCode, JNI_FALSE);\n+                                 pScalerContext, pScaler, glyphCode, JNI_FALSE, JNI_TRUE);\n@@ -887,0 +970,175 @@\n+\/* Get enclosing axis-aligned rectangle of transformed bitmap bounds *\/\n+static FT_BBox getTransformedBitmapBoundingBox(FT_GlyphSlot ftglyph,\n+                                               const FT_Matrix* transform) {\n+    FT_Vector corners[4];\n+    corners[0].x = corners[2].x = IntToFT26Dot6(ftglyph->bitmap_left);\n+    corners[0].y = corners[1].y = IntToFT26Dot6(ftglyph->bitmap_top);\n+    corners[1].x = corners[3].x = IntToFT26Dot6(ftglyph->bitmap_left +\n+                                                (FT_Int) ftglyph->bitmap.width);\n+    corners[2].y = corners[3].y = IntToFT26Dot6(ftglyph->bitmap_top -\n+                                                (FT_Int) ftglyph->bitmap.rows);\n+\n+    FT_Vector_Transform(corners, transform);\n+    FT_BBox bb = {corners[0].x, corners[0].y, corners[0].x, corners[0].y};\n+    int i;\n+    for (i = 1; i < 4; i++) {\n+        FT_Vector_Transform(corners + i, transform);\n+        if (corners[i].x < bb.xMin) bb.xMin = corners[i].x;\n+        if (corners[i].x > bb.xMax) bb.xMax = corners[i].x;\n+        if (corners[i].y < bb.yMin) bb.yMin = corners[i].y;\n+        if (corners[i].y > bb.yMax) bb.yMax = corners[i].y;\n+    }\n+    bb.xMin = FT26Dot6ToInt(bb.xMin);\n+    bb.yMin = FT26Dot6ToInt(bb.yMin);\n+    bb.xMax = FT26Dot6ToIntCeil(bb.xMax);\n+    bb.yMax = FT26Dot6ToIntCeil(bb.yMax);\n+    return bb;\n+}\n+\n+\/* Generate SampledBGRABitmap, downscaling original image when necessary.\n+ * It may allocate memory for downscaled image,\n+ * so it must be freed with freeSampledBGRABitmap() *\/\n+static SampledBGRABitmap createSampledBGRABitmap(FT_GlyphSlot ftglyph,\n+                                                 int xDownscale,\n+                                                 int yDownscale) {\n+    SampledBGRABitmap sampledBitmap;\n+    if (xDownscale == 1 && yDownscale == 1) { \/\/ No downscale, use original data\n+        sampledBitmap.data = ftglyph->bitmap.buffer;\n+        sampledBitmap.left = ftglyph->bitmap_left;\n+        sampledBitmap.top = ftglyph->bitmap_top;\n+        sampledBitmap.width = (int) ftglyph->bitmap.width;\n+        sampledBitmap.height = (int) ftglyph->bitmap.rows;\n+        sampledBitmap.rowBytes = ftglyph->bitmap.pitch;\n+        sampledBitmap.xDownscale = 1;\n+        sampledBitmap.yDownscale = 1;\n+    } else { \/\/ Generate downscaled bitmap\n+        sampledBitmap.left = ftglyph->bitmap_left \/ xDownscale;\n+        sampledBitmap.top = (ftglyph->bitmap_top + yDownscale - 1) \/ yDownscale;\n+        sampledBitmap.width = (int)\n+                (ftglyph->bitmap_left + (FT_Pos) ftglyph->bitmap.width -\n+                 sampledBitmap.left * xDownscale + xDownscale - 1) \/ xDownscale;\n+        sampledBitmap.height = (int)\n+                (sampledBitmap.top * yDownscale - ftglyph->bitmap_top +\n+                 (FT_Pos) ftglyph->bitmap.rows + yDownscale - 1) \/ yDownscale;\n+        sampledBitmap.data =\n+                malloc(4 * sampledBitmap.width * sampledBitmap.height);\n+        sampledBitmap.rowBytes = sampledBitmap.width * 4;\n+        sampledBitmap.xDownscale = xDownscale;\n+        sampledBitmap.yDownscale = yDownscale;\n+        int xOffset = sampledBitmap.left * xDownscale - ftglyph->bitmap_left;\n+        int yOffset = ftglyph->bitmap_top - sampledBitmap.top * yDownscale;\n+        int x, y;\n+        for (y = 0; y < sampledBitmap.height; y++) {\n+            for (x = 0; x < sampledBitmap.width; x++) {\n+                \/\/ Average pixels\n+                int b = 0, g = 0, r = 0, a = 0;\n+                int xFrom = x * xDownscale + xOffset,\n+                        yFrom = y * yDownscale + yOffset,\n+                        xTo = xFrom + xDownscale,\n+                        yTo = yFrom + yDownscale;\n+                if (xFrom < 0) xFrom = 0;\n+                if (xTo > (int) ftglyph->bitmap.width) xTo = (int) ftglyph->bitmap.width;\n+                if (yFrom < 0) yFrom = 0;\n+                if (yTo > (int) ftglyph->bitmap.rows) yTo = (int) ftglyph->bitmap.rows;\n+                int i, j;\n+                for (j = yFrom; j < yTo; j++) {\n+                    for (i = xFrom; i < xTo; i++) {\n+                        int offset = j * ftglyph->bitmap.pitch + i * 4;\n+                        b += ftglyph->bitmap.buffer[offset + 0];\n+                        g += ftglyph->bitmap.buffer[offset + 1];\n+                        r += ftglyph->bitmap.buffer[offset + 2];\n+                        a += ftglyph->bitmap.buffer[offset + 3];\n+                    }\n+                }\n+                int offset = y * sampledBitmap.rowBytes + x * 4;\n+                sampledBitmap.data[offset + 0] = b \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 1] = g \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 2] = r \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 3] = a \/ xDownscale \/ yDownscale;\n+            }\n+        }\n+    }\n+    return sampledBitmap;\n+}\n+static void freeSampledBGRABitmap(SampledBGRABitmap* bitmap) {\n+    if (bitmap->xDownscale != 1 || bitmap->yDownscale != 1) {\n+        free(bitmap->data);\n+    }\n+}\n+\/* Get color (returned via b, g, r and a variables, [0-256))\n+ * from specific pixel in bitmap.\n+ * Returns black-transparent (0,0,0,0) color when sampling out of bounds *\/\n+static void sampleBGRABitmapGlyph(int* b, int* g, int* r, int* a,\n+                                  const SampledBGRABitmap* bitmap,\n+                                  int x, int y) {\n+    int column = x - bitmap->left, row = bitmap->top - y;\n+    if (column < 0 || column >= bitmap->width ||\n+        row < 0 || row >= bitmap->height) {\n+        *b = *g = *r = *a = 0;\n+    } else {\n+        int offset = row * bitmap->rowBytes + column * 4;\n+        *b = bitmap->data[offset + 0];\n+        *g = bitmap->data[offset + 1];\n+        *r = bitmap->data[offset + 2];\n+        *a = bitmap->data[offset + 3];\n+    }\n+}\n+static int bilinearColorMix(int c00, int c10, int c01, int c11,\n+                            float x, float y) {\n+    float top = (float) c00 + x * (float) (c10 - c00);\n+    float bottom = (float) c01 + x * (float) (c11 - c01);\n+    return (int) (top + y * (bottom - top));\n+}\n+\/* Transform ftglyph into pre-allocated glyphInfo with transform matrix *\/\n+static void transformBGRABitmapGlyph(FT_GlyphSlot ftglyph, GlyphInfo* glyphInfo,\n+                                     const FT_Matrix* transform,\n+                                     const FT_BBox* dstBoundingBox,\n+                                     const jboolean linear) {\n+    FT_Matrix inv = *transform;\n+    FT_Matrix_Invert(&inv); \/\/ Transformed -> original bitmap space\n+    int invScaleX = (int) sqrt((double) FTFixedToFloat(FT_MulFix(inv.xx, inv.xx) +\n+                                                       FT_MulFix(inv.xy, inv.xy)));\n+    int invScaleY = (int) sqrt((double) FTFixedToFloat(FT_MulFix(inv.yx, inv.yx) +\n+                                                       FT_MulFix(inv.yy, inv.yy)));\n+    if (invScaleX < 1) invScaleX = 1;\n+    if (invScaleY < 1) invScaleY = 1;\n+    SampledBGRABitmap sampledBitmap =\n+            createSampledBGRABitmap(ftglyph, invScaleX, invScaleY);\n+    int x, y;\n+    for (y = 0; y < glyphInfo->height; y++) {\n+        for (x = 0; x < glyphInfo->width; x++) {\n+            FT_Vector position = {\n+                    IntToFT26Dot6(dstBoundingBox->xMin + x),\n+                    IntToFT26Dot6(dstBoundingBox->yMax - y)\n+            };\n+            FT_Vector_Transform(&position, &inv);\n+            int sampleX = FT26Dot6ToInt(position.x \/ invScaleX),\n+                    sampleY = FT26Dot6ToInt(position.y \/ invScaleY);\n+            int b, g, r, a;\n+            sampleBGRABitmapGlyph(&b, &g, &r, &a,\n+                                  &sampledBitmap, sampleX, sampleY);\n+            if (linear) {\n+                int bX, gX, rX, aX, bY, gY, rY, aY, bXY, gXY, rXY, aXY;\n+                sampleBGRABitmapGlyph(&bX, &gX, &rX, &aX,\n+                                      &sampledBitmap, sampleX + 1, sampleY);\n+                sampleBGRABitmapGlyph(&bY, &gY, &rY, &aY,\n+                                      &sampledBitmap, sampleX, sampleY + 1);\n+                sampleBGRABitmapGlyph(&bXY, &gXY, &rXY, &aXY,\n+                                      &sampledBitmap, sampleX + 1, sampleY + 1);\n+                float fractX = FT26Dot6ToFloat((position.x \/ invScaleX) & 63),\n+                        fractY = FT26Dot6ToFloat((position.y \/ invScaleY) & 63);\n+                b = bilinearColorMix(b, bX, bY, bXY, fractX, fractY);\n+                g = bilinearColorMix(g, gX, gY, gXY, fractX, fractY);\n+                r = bilinearColorMix(r, rX, rY, rXY, fractX, fractY);\n+                a = bilinearColorMix(a, aX, aY, aXY, fractX, fractY);\n+            }\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 0] = b;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 1] = g;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 2] = r;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 3] = a;\n+        }\n+    }\n+    freeSampledBGRABitmap(&sampledBitmap);\n+}\n+\n+\n@@ -906,1 +1164,1 @@\n-        pScalerContext, pScaler, glyphCode, JNI_TRUE);\n+        pScalerContext, pScaler, glyphCode, JNI_TRUE, JNI_TRUE);\n@@ -913,1 +1171,1 @@\n-        jboolean renderImage) {\n+        jboolean renderImage, jboolean setupContext) {\n@@ -931,4 +1189,6 @@\n-    error = setupFTContext(env, font2D, scalerInfo, context);\n-    if (error) {\n-        invalidateJavaScaler(env, scaler, scalerInfo);\n-        return ptr_to_jlong(getNullGlyphImage());\n+    if (setupContext) {\n+        error = setupFTContext(env, font2D, scalerInfo, context);\n+        if (error) {\n+            invalidateJavaScaler(env, scaler, scalerInfo);\n+            return ptr_to_jlong(getNullGlyphImage());\n+        }\n@@ -944,1 +1204,2 @@\n-    if (context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) {\n+    if ((context->aaType == TEXT_AA_ON && context->fmType == TEXT_FM_ON) ||\n+        context->colorFont) {\n@@ -948,1 +1209,6 @@\n-    if (!context->useSbits) {\n+    if (context->colorFont) {\n+        renderFlags |= FT_LOAD_COLOR;\n+    }\n+\n+    \/* Don't disable bitmaps for color glyphs *\/\n+    if (!context->useSbits && !context->colorFont) {\n@@ -958,3 +1224,1 @@\n-    if (context->aaType == TEXT_AA_OFF) {\n-        target = FT_LOAD_TARGET_MONO;\n-    } else if (context->aaType == TEXT_AA_ON) {\n+    if (context->aaType == TEXT_AA_ON || context->colorFont) {\n@@ -962,0 +1226,2 @@\n+    } else if (context->aaType == TEXT_AA_OFF) {\n+        target = FT_LOAD_TARGET_MONO;\n@@ -979,0 +1245,4 @@\n+    \/* After call to FT_Render_Glyph, glyph format will be changed from\n+     * FT_GLYPH_FORMAT_OUTLINE to FT_GLYPH_FORMAT_BITMAP, so save this value *\/\n+    int outlineGlyph = ftglyph->format == FT_GLYPH_FORMAT_OUTLINE;\n+\n@@ -980,1 +1250,1 @@\n-    if (context->doBold) { \/* if bold style *\/\n+    if (context->doBold && outlineGlyph && !context->colorFont) { \/* if bold style *\/\n@@ -986,1 +1256,1 @@\n-    if (renderImage && (ftglyph->format == FT_GLYPH_FORMAT_OUTLINE)) {\n+    if (renderImage && outlineGlyph) {\n@@ -1001,0 +1271,4 @@\n+    FT_Fixed manualScale = context->fixedSizeIndex == -1 ? ftFixed1 : FT_DivFix(\n+            context->ptsz, scalerInfo->face->available_sizes[context->fixedSizeIndex].size);\n+    FT_Matrix manualTransform;\n+    FT_BBox manualTransformBoundingBox;\n@@ -1002,2 +1276,21 @@\n-        width  = (UInt16) ftglyph->bitmap.width;\n-        rowBytes = width;\n+        if (context->fixedSizeIndex == -1) {\n+            width  = (UInt16) ftglyph->bitmap.width;\n+            height = (UInt16) ftglyph->bitmap.rows;\n+        } else {\n+            \/* Fixed size glyph, prepare matrix and\n+             * bounding box for manual transformation *\/\n+            manualTransform.xx = FT_MulFix(context->transform.xx, manualScale);\n+            manualTransform.xy = FT_MulFix(context->transform.xy, manualScale);\n+            manualTransform.yx = FT_MulFix(context->transform.yx, manualScale);\n+            manualTransform.yy = FT_MulFix(context->transform.yy, manualScale);\n+            manualTransformBoundingBox =\n+                    getTransformedBitmapBoundingBox(ftglyph, &manualTransform);\n+            width  = (UInt16) (manualTransformBoundingBox.xMax -\n+                               manualTransformBoundingBox.xMin);\n+            height = (UInt16) (manualTransformBoundingBox.yMax -\n+                               manualTransformBoundingBox.yMin);\n+        }\n+        if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {\n+            glyphInfo = getNullGlyphImage();\n+            return ptr_to_jlong(glyphInfo);\n+        }\n@@ -1005,1 +1298,5 @@\n-           rowBytes = PADBYTES + width + PADBYTES;\n+            rowBytes = PADBYTES + width + PADBYTES;\n+        } else if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA) {\n+            rowBytes = width * 4;\n+        } else {\n+            rowBytes = width;\n@@ -1007,6 +1304,1 @@\n-        height = (UInt16) ftglyph->bitmap.rows;\n-            if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {\n-              glyphInfo = getNullGlyphImage();\n-              return ptr_to_jlong(glyphInfo);\n-            }\n-     } else {\n+    } else {\n@@ -1016,1 +1308,1 @@\n-     }\n+    }\n@@ -1031,0 +1323,5 @@\n+    if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA) glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_BGRA;\n+    else if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD ||\n+             ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_LCD_V) glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_LCD;\n+    else glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE;\n+\n@@ -1032,2 +1329,7 @@\n-        glyphInfo->topLeftX  = (float)  ftglyph->bitmap_left;\n-        glyphInfo->topLeftY  = (float) -ftglyph->bitmap_top;\n+        if (context->fixedSizeIndex == -1) {\n+            glyphInfo->topLeftX = (float)  ftglyph->bitmap_left;\n+            glyphInfo->topLeftY = (float) -ftglyph->bitmap_top;\n+        } else {\n+            glyphInfo->topLeftX =  (float)  manualTransformBoundingBox.xMin;\n+            glyphInfo->topLeftY =  (float) -manualTransformBoundingBox.yMax;\n+        }\n@@ -1044,1 +1346,1 @@\n-    if (context->fmType == TEXT_FM_ON) {\n+    if (context->fmType == TEXT_FM_ON && outlineGlyph) {\n@@ -1052,1 +1354,2 @@\n-            glyphInfo->advanceX = FT26Dot6ToFloat(ftglyph->advance.x);\n+            glyphInfo->advanceX = FT26Dot6ToIntRound(\n+                    FT_MulFix(ftglyph->advance.x, manualScale));\n@@ -1056,1 +1359,2 @@\n-            glyphInfo->advanceY = FT26Dot6ToFloat(-ftglyph->advance.y);\n+            glyphInfo->advanceY = FT26Dot6ToIntRound(\n+                    -FT_MulFix(ftglyph->advance.y, manualScale));\n@@ -1058,2 +1362,4 @@\n-            glyphInfo->advanceX = FT26Dot6ToFloat(ftglyph->advance.x);\n-            glyphInfo->advanceY = FT26Dot6ToFloat(-ftglyph->advance.y);\n+            glyphInfo->advanceX = FT26Dot6ToFloat(\n+                    FT_MulFix(ftglyph->advance.x, manualScale));\n+            glyphInfo->advanceY = FT26Dot6ToFloat(\n+                    -FT_MulFix(ftglyph->advance.y, manualScale));\n@@ -1069,0 +1375,1 @@\n+        \/\/4 bytes per pixel for BGRA glyphs\n@@ -1070,14 +1377,5 @@\n-        if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {\n-            \/* convert from 8 pixels per byte to 1 byte per pixel *\/\n-            CopyBW2Grey8(ftglyph->bitmap.buffer,\n-                         ftglyph->bitmap.pitch,\n-                         (void *) glyphInfo->image,\n-                         width,\n-                         width,\n-                         height);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {\n-            \/* byte per pixel to byte per pixel => just copy *\/\n-            memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {\n-            \/* 4 bits per pixel to byte per pixel *\/\n-            CopyGrey4ToGrey8(ftglyph->bitmap.buffer,\n+        if (context->fixedSizeIndex == -1) {\n+            \/\/ Standard format convertation without image transformation\n+            if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {\n+                \/* convert from 8 pixels per byte to 1 byte per pixel *\/\n+                CopyBW2Grey8(ftglyph->bitmap.buffer,\n@@ -1089,17 +1387,35 @@\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {\n-            \/* 3 bytes per pixel to 3 bytes per pixel *\/\n-            CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,\n-                                     ftglyph->bitmap.pitch,\n-                                     (void *) (glyphInfo->image+PADBYTES),\n-                                     rowBytes,\n-                                     width,\n-                                     height);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {\n-            \/* 3 bytes per pixel to 3 bytes per pixel *\/\n-            CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,\n-                                      ftglyph->bitmap.pitch,\n-                                      (void *) glyphInfo->image,\n-                                      width*3,\n-                                      width,\n-                                      height);\n-            glyphInfo->rowBytes *=3;\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {\n+                \/* byte per pixel to byte per pixel => just copy *\/\n+                memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {\n+                \/* 4 bits per pixel to byte per pixel *\/\n+                CopyGrey4ToGrey8(ftglyph->bitmap.buffer,\n+                                 ftglyph->bitmap.pitch,\n+                                 (void *) glyphInfo->image,\n+                                 width,\n+                                 width,\n+                                 height);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {\n+                \/* 3 bytes per pixel to 3 bytes per pixel *\/\n+                CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,\n+                                         ftglyph->bitmap.pitch,\n+                                         (void *) (glyphInfo->image+PADBYTES),\n+                                         rowBytes,\n+                                         width,\n+                                         height);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {\n+                \/* 3 bytes per pixel to 3 bytes per pixel *\/\n+                CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,\n+                                          ftglyph->bitmap.pitch,\n+                                          (void *) glyphInfo->image,\n+                                          width*3,\n+                                          width,\n+                                          height);\n+                glyphInfo->rowBytes *=3;\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_BGRA) {\n+                \/* 4 bytes per pixel to 4 bytes per pixel => just copy *\/\n+                memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n+            } else {\n+                free(glyphInfo);\n+                glyphInfo = getNullGlyphImage();\n+            }\n@@ -1107,2 +1423,11 @@\n-            free(glyphInfo);\n-            glyphInfo = getNullGlyphImage();\n+            \/\/ Here we have to transform image manually\n+            \/\/ Only BGRA format is supported (should be enough)\n+            if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_BGRA) {\n+                transformBGRABitmapGlyph(ftglyph, glyphInfo,\n+                                         &manualTransform,\n+                                         &manualTransformBoundingBox,\n+                                         context->aaType != TEXT_AA_OFF);\n+            } else {\n+                free(glyphInfo);\n+                glyphInfo = getNullGlyphImage();\n+            }\n@@ -1202,3 +1527,2 @@\n-static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,\n-        FTScalerContext *context, FTScalerInfo* scalerInfo,\n-        jint glyphCode, jfloat xpos, jfloat ypos) {\n+static FT_Outline* getFTOutlineNoSetup(FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                       jint glyphCode, jfloat xpos, jfloat ypos) {\n@@ -1209,10 +1533,0 @@\n-    if (glyphCode >= INVISIBLE_GLYPHS ||\n-            isNullScalerContext(context) || scalerInfo == NULL) {\n-        return NULL;\n-    }\n-\n-    error = setupFTContext(env, font2D, scalerInfo, context);\n-    if (error) {\n-        return NULL;\n-    }\n-\n@@ -1227,0 +1541,1 @@\n+    int outlineGlyph = ftglyph->format == FT_GLYPH_FORMAT_OUTLINE;\n@@ -1229,1 +1544,1 @@\n-    if (context->doBold) { \/* if bold style *\/\n+    if (context->doBold && outlineGlyph && !context->colorFont) { \/* if bold style *\/\n@@ -1240,0 +1555,18 @@\n+static FT_Outline* getFTOutline(JNIEnv* env, jobject font2D,\n+                                FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                jint glyphCode, jfloat xpos, jfloat ypos) {\n+    FT_Error error;\n+\n+    if (glyphCode >= INVISIBLE_GLYPHS ||\n+        isNullScalerContext(context) || scalerInfo == NULL) {\n+        return NULL;\n+    }\n+\n+    error = setupFTContext(env, font2D, scalerInfo, context);\n+    if (error) {\n+        return NULL;\n+    }\n+\n+    return getFTOutlineNoSetup(context, scalerInfo, glyphCode, xpos, ypos);\n+}\n+\n@@ -1396,3 +1729,1 @@\n-static jobject getGlyphGeneralPath(JNIEnv* env, jobject font2D,\n-        FTScalerContext *context, FTScalerInfo *scalerInfo,\n-        jint glyphCode, jfloat xpos, jfloat ypos) {\n+static jobject outlineToGeneralPath(JNIEnv* env, FT_Outline* outline) {\n@@ -1400,1 +1731,0 @@\n-    FT_Outline* outline;\n@@ -1406,3 +1736,0 @@\n-    outline = getFTOutline(env, font2D, context, scalerInfo,\n-                           glyphCode, xpos, ypos);\n-\n@@ -1446,0 +1773,69 @@\n+static jboolean addColorLayersRenderData(JNIEnv* env, FTScalerContext *context,\n+                                         FTScalerInfo* scalerInfo, jint glyphCode,\n+                                         jfloat xpos, jfloat ypos, jobject result) {\n+\n+#ifdef ENABLE_COLOR_OUTLINES\n+    FT_Error error;\n+\n+    FT_Color* colors;\n+    error = FT_Palette_Select(scalerInfo->face, 0, &colors);\n+    if (error) return JNI_FALSE;\n+\n+    FT_LayerIterator iterator;\n+    iterator.p = NULL;\n+    FT_UInt glyphIndex, colorIndex;\n+    if (!FT_Get_Color_Glyph_Layer(scalerInfo->face, glyphCode,\n+                                  &glyphIndex, &colorIndex, &iterator)) return JNI_FALSE;\n+    (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataSetColorLayersListMID, iterator.num_layers);\n+    do {\n+        FT_Outline* outline = getFTOutlineNoSetup(context, scalerInfo, glyphIndex, xpos, ypos);\n+        jobject gp = outlineToGeneralPath(env, outline);\n+\n+        if (colorIndex == 0xFFFF) {\n+            (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddColorLayerFGMID, gp);\n+        } else {\n+            (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddColorLayerMID,\n+                                   colors[colorIndex].red, colors[colorIndex].green,\n+                                   colors[colorIndex].blue, colors[colorIndex].alpha, gp);\n+        }\n+    } while(FT_Get_Color_Glyph_Layer(scalerInfo->face, glyphCode,\n+                                     &glyphIndex, &colorIndex, &iterator));\n+\n+    return JNI_TRUE;\n+#else\n+    return JNI_FALSE;\n+#endif\n+}\n+\n+static void addBitmapRenderData(JNIEnv *env, jobject scaler, jobject font2D,\n+                                FTScalerContext *context, FTScalerInfo* scalerInfo,\n+                                jint glyphCode, jfloat xpos, jfloat ypos, jobject result) {\n+    GlyphInfo* glyphInfo = (GlyphInfo*) jlong_to_ptr(getGlyphImageNativeInternal(\n+            env, scaler, font2D,\n+            ptr_to_jlong(context), ptr_to_jlong(scalerInfo),\n+            glyphCode, JNI_FALSE, JNI_FALSE));\n+\n+    FT_GlyphSlot ftglyph = scalerInfo->face->glyph;\n+\n+    if (ftglyph->bitmap.pixel_mode != FT_PIXEL_MODE_BGRA) return;\n+\n+    int pitch = ftglyph->bitmap.pitch \/ 4;\n+    int size = pitch * ftglyph->bitmap.rows;\n+    jintArray array = (*env)->NewIntArray(env, size);\n+    (*env)->SetIntArrayRegion(env, array, 0, size, (jint*) ftglyph->bitmap.buffer);\n+\n+    double bitmapSize = (double) scalerInfo->face->available_sizes[context->fixedSizeIndex].size;\n+    double scale = (double) context->ptsz \/ bitmapSize \/ (double) (ftFixed1);\n+    double tx = ftglyph->bitmap_left + xpos * bitmapSize \/ (double) context->ptsz;\n+    double ty = -ftglyph->bitmap_top + ypos * bitmapSize \/ (double) context->ptsz;\n+\n+    jdouble m00 = (jdouble) context->transform.xx * scale, m10 = (jdouble) context->transform.xy * scale;\n+    jdouble m01 = (jdouble) context->transform.yx * scale, m11 = (jdouble) context->transform.yy * scale;\n+    jdouble m02 = m00 * tx + m01 * ty, m12 = m10 * tx + m11 * ty;\n+\n+    free(glyphInfo);\n+    (*env)->CallVoidMethod(env, result, sunFontIDs.glyphRenderDataAddBitmapMID,\n+                           m00, m10, m01, m11, m02, m12,\n+                           ftglyph->bitmap.width, ftglyph->bitmap.rows, pitch, 2, array);\n+}\n+\n@@ -1460,7 +1856,4 @@\n-    jobject gp = getGlyphGeneralPath(env,\n-                               font2D,\n-                               context,\n-                               scalerInfo,\n-                               glyphCode,\n-                               xpos,\n-                               ypos);\n+    FT_Outline* outline = getFTOutline(env, font2D, context,\n+                                       scalerInfo, glyphCode,\n+                                       xpos, ypos);\n+    jobject gp = outlineToGeneralPath(env, outline);\n@@ -1475,0 +1868,36 @@\n+\/*\n+ * Class:     sun_font_FreetypeFontScaler\n+ * Method:    getGlyphRenderDataNative\n+ * Signature: (Lsun\/font\/Font2D;JIFFLsun\/font\/GlyphRenderData;)V\n+ *\/\n+JNIEXPORT void JNICALL\n+Java_sun_font_FreetypeFontScaler_getGlyphRenderDataNative(\n+        JNIEnv *env, jobject scaler, jobject font2D, jlong pScalerContext,\n+        jlong pScaler, jint glyphCode, jfloat xpos, jfloat ypos, jobject result) {\n+\n+    FTScalerContext *context =\n+            (FTScalerContext*) jlong_to_ptr(pScalerContext);\n+    FTScalerInfo* scalerInfo = (FTScalerInfo *) jlong_to_ptr(pScaler);\n+\n+    if (glyphCode >= INVISIBLE_GLYPHS ||\n+        isNullScalerContext(context) || scalerInfo == NULL) {\n+        return;\n+    }\n+\n+    FT_Error error = setupFTContext(env, font2D, scalerInfo, context);\n+    if (error) return;\n+\n+    if (context->fixedSizeIndex == -1) {\n+        if (!context->colorFont ||\n+            !addColorLayersRenderData(env, context, scalerInfo, glyphCode, xpos, ypos, result)) {\n+            FT_Outline* outline = getFTOutlineNoSetup(context, scalerInfo, glyphCode, xpos, ypos);\n+            jobject gp = outlineToGeneralPath(env, outline);\n+            if (gp != NULL) {\n+                (*env)->SetObjectField(env, result, sunFontIDs.glyphRenderDataOutline, gp);\n+            }\n+        }\n+    } else {\n+        addBitmapRenderData(env, scaler, font2D, context, scalerInfo, glyphCode, xpos, ypos, result);\n+    }\n+}\n+\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":557,"deletions":128,"binary":false,"changes":685,"status":"modified"},{"patch":"@@ -192,0 +192,14 @@\n+    CHECK_NULL(tmpClass = (*env)->FindClass(env, \"sun\/font\/GlyphRenderData\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataOutline =\n+         (*env)->GetFieldID(env, tmpClass, \"outline\", \"Ljava\/awt\/geom\/GeneralPath;\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataColorLayers =\n+         (*env)->GetFieldID(env, tmpClass, \"colorLayers\", \"Ljava\/util\/List;\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataSetColorLayersListMID =\n+          (*env)->GetMethodID(env, tmpClass, \"setColorLayersList\", \"(I)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddColorLayerMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addColorLayers\", \"(IIIILjava\/awt\/geom\/GeneralPath;)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddColorLayerFGMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addColorLayers\", \"(Ljava\/awt\/geom\/GeneralPath;)V\"));\n+    CHECK_NULL(sunFontIDs.glyphRenderDataAddBitmapMID =\n+          (*env)->GetMethodID(env, tmpClass, \"addBitmap\", \"(DDDDDDIIII[I)V\"));\n+\n@@ -317,1 +331,1 @@\n-    if ((*env)->GetArrayLength(env, results) < 13) {\n+    if ((*env)->GetArrayLength(env, results) < 14) {\n@@ -344,0 +358,1 @@\n+    nresults[13] = (size_t)&(info->format)-baseAddr;\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/sunFont.c","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/****************************************************************************\n+ *\n+ * ftcolor.c\n+ *\n+ *   FreeType's glyph color management (body).\n+ *\n+ * Copyright (C) 2018-2022 by\n+ * David Turner, Robert Wilhelm, and Werner Lemberg.\n+ *\n+ * This file is part of the FreeType project, and may only be used,\n+ * modified, and distributed under the terms of the FreeType project\n+ * license, LICENSE.TXT.  By continuing to use, modify, or distribute\n+ * this file you indicate that you have read the license and\n+ * understand and accept it fully.\n+ *\n+ *\/\n+\n+\n+#include <freetype\/internal\/ftdebug.h>\n+#include <freetype\/internal\/sfnt.h>\n+#include <freetype\/internal\/tttypes.h>\n+#include <freetype\/ftcolor.h>\n+\n+\n+#ifdef TT_CONFIG_OPTION_COLOR_LAYERS\n+\n+  static\n+  const FT_Palette_Data  null_palette_data = { 0, NULL, NULL, 0, NULL };\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Data_Get( FT_Face           face,\n+                       FT_Palette_Data  *apalette_data )\n+  {\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+    if ( !apalette_data)\n+      return FT_THROW( Invalid_Argument );\n+\n+    if ( FT_IS_SFNT( face ) )\n+      *apalette_data = ( (TT_Face)face )->palette_data;\n+    else\n+      *apalette_data = null_palette_data;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Select( FT_Face     face,\n+                     FT_UShort   palette_index,\n+                     FT_Color*  *apalette )\n+  {\n+    FT_Error  error;\n+\n+    TT_Face       ttface;\n+    SFNT_Service  sfnt;\n+\n+\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+\n+    if ( !FT_IS_SFNT( face ) )\n+    {\n+      if ( apalette )\n+        *apalette = NULL;\n+\n+      return FT_Err_Ok;\n+    }\n+\n+    ttface = (TT_Face)face;\n+    sfnt   = (SFNT_Service)ttface->sfnt;\n+\n+    error = sfnt->set_palette( ttface, palette_index );\n+    if ( error )\n+      return error;\n+\n+    ttface->palette_index = palette_index;\n+\n+    if ( apalette )\n+      *apalette = ttface->palette;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+\n+  \/* documentation is in ftcolor.h *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\n+                                   FT_Color  foreground_color )\n+  {\n+    TT_Face  ttface;\n+\n+\n+    if ( !face )\n+      return FT_THROW( Invalid_Face_Handle );\n+\n+    if ( !FT_IS_SFNT( face ) )\n+      return FT_Err_Ok;\n+\n+    ttface = (TT_Face)face;\n+\n+    ttface->foreground_color      = foreground_color;\n+    ttface->have_foreground_color = 1;\n+\n+    return FT_Err_Ok;\n+  }\n+\n+#else \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Data_Get( FT_Face           face,\n+                       FT_Palette_Data  *apalette_data )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( apalette_data );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Select( FT_Face     face,\n+                     FT_UShort   palette_index,\n+                     FT_Color*  *apalette )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( palette_index );\n+    FT_UNUSED( apalette );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+\n+  FT_EXPORT_DEF( FT_Error )\n+  FT_Palette_Set_Foreground_Color( FT_Face   face,\n+                                   FT_Color  foreground_color )\n+  {\n+    FT_UNUSED( face );\n+    FT_UNUSED( foreground_color );\n+\n+\n+    return FT_THROW( Unimplemented_Feature );\n+  }\n+\n+#endif \/* !TT_CONFIG_OPTION_COLOR_LAYERS *\/\n+\n+\n+\/* END *\/\n","filename":"src\/java.desktop\/share\/native\/libfreetype\/src\/base\/ftcolor.c","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -295,0 +295,4 @@\n+     GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+         return new GlyphRenderData();\n+     }\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/NativeStrike.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    native void doDrawGlyphList(long dstData, long xgc,\n+    native boolean doDrawGlyphList(long dstData, long xgc,\n@@ -81,1 +81,17 @@\n-            doDrawGlyphList(x11sd.getNativeOps(), xgc, clip, gl);\n+            boolean allGlyphsRendered = doDrawGlyphList(x11sd.getNativeOps(), xgc, clip, gl);\n+            \/\/ There are some color glyphs, which we couldn't draw\n+            if (!allGlyphsRendered) {\n+                gl.startGlyphIteration();\n+                for (int i = 0; i < gl.getNumGlyphs(); i++) {\n+                    if (gl.isColorGlyph(i)) {\n+                        int end;\n+                        for (end = i + 1; end < gl.getNumGlyphs(); end++) {\n+                            if (!gl.isColorGlyph(end)) break;\n+                        }\n+                        sg2d.loops.drawGlyphListColorLoop.\n+                                DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                                        gl, i, end);\n+                        i = end - 1;\n+                    } else gl.setGlyphIndex(i);\n+                }\n+            }\n@@ -92,1 +108,1 @@\n-        void doDrawGlyphList(long dstData, long xgc,\n+        boolean doDrawGlyphList(long dstData, long xgc,\n@@ -96,1 +112,1 @@\n-            super.doDrawGlyphList(dstData, xgc, clip, gl);\n+            return super.doDrawGlyphList(dstData, xgc, clip, gl);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11TextRenderer.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+    \/**\n+     * BGRA glyphs are rendered as images\n+     * and therefore don't belong to any glyph set\n+     *\/\n+    public static final int BGRA_GLYPH_SET = -1;\n+\n@@ -50,0 +56,1 @@\n+    final EnumMap<XRGlyphCacheEntry.Type, Integer> glyphSetsByType;\n@@ -66,0 +73,5 @@\n+        glyphSetsByType = new EnumMap<>(XRGlyphCacheEntry.Type.class);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.GRAYSCALE, grayGlyphSet);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.LCD, lcdGlyphSet);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.BGRA, BGRA_GLYPH_SET);\n+\n@@ -107,1 +119,1 @@\n-    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList) {\n+    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList, int parentXid) {\n@@ -117,1 +129,2 @@\n-            if (imgPtrs[i] == 0L) {\n+            if (imgPtrs[i] == 0L ||\n+                imgPtrs[i] == StrikeCache.invisibleGlyphPtr) {\n@@ -127,1 +140,1 @@\n-                    uncachedGlyphs = new ArrayList<XRGlyphCacheEntry>();\n+                    uncachedGlyphs = new ArrayList<>();\n@@ -137,1 +150,1 @@\n-            uploadGlyphs(entries, uncachedGlyphs, glyphList, null);\n+            uploadGlyphs(entries, uncachedGlyphs, glyphList, parentXid);\n@@ -143,1 +156,3 @@\n-    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs, ArrayList<XRGlyphCacheEntry> uncachedGlyphs, GlyphList gl, int[] glIndices) {\n+    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs,\n+                                ArrayList<XRGlyphCacheEntry> uncachedGlyphs,\n+                                GlyphList gl, int parentXid) {\n@@ -152,4 +167,13 @@\n-        boolean containsLCDGlyphs = containsLCDGlyphs(uncachedGlyphs);\n-        List<XRGlyphCacheEntry>[] seperatedGlyphList = seperateGlyphTypes(uncachedGlyphs, containsLCDGlyphs);\n-        List<XRGlyphCacheEntry> grayGlyphList = seperatedGlyphList[0];\n-        List<XRGlyphCacheEntry> lcdGlyphList = seperatedGlyphList[1];\n+        EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>>\n+                glyphListsByType = separateGlyphTypes(uncachedGlyphs);\n+\n+        uploadGlyphs(grayGlyphSet, gl,\n+                     glyphListsByType.get(XRGlyphCacheEntry.Type.GRAYSCALE));\n+        uploadGlyphs(lcdGlyphSet, gl,\n+                     glyphListsByType.get(XRGlyphCacheEntry.Type.LCD));\n+        List<XRGlyphCacheEntry> bgraGlyphs = glyphListsByType.getOrDefault(\n+                XRGlyphCacheEntry.Type.BGRA, List.of());\n+        if (!bgraGlyphs.isEmpty()) {\n+            con.addBGRAGlyphImages(parentXid, bgraGlyphs);\n+        }\n+    }\n@@ -157,0 +181,5 @@\n+    private void uploadGlyphs(int glyphSet, GlyphList glyphList,\n+                              List<XRGlyphCacheEntry> cacheEntries) {\n+        if (cacheEntries == null || cacheEntries.isEmpty()) {\n+            return;\n+        }\n@@ -163,6 +192,2 @@\n-            if (grayGlyphList != null && grayGlyphList.size() > 0) {\n-                con.XRenderAddGlyphs(grayGlyphSet, gl, grayGlyphList, generateGlyphImageStream(grayGlyphList));\n-            }\n-            if (lcdGlyphList != null && lcdGlyphList.size() > 0) {\n-                con.XRenderAddGlyphs(lcdGlyphSet, gl, lcdGlyphList, generateGlyphImageStream(lcdGlyphList));\n-            }\n+            con.XRenderAddGlyphs(glyphSet, glyphList, cacheEntries,\n+                    generateGlyphImageStream(cacheEntries));\n@@ -170,1 +195,1 @@\n-            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<XRGlyphCacheEntry>(1);\n+            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<>(1);\n@@ -172,2 +197,1 @@\n-\n-            for (XRGlyphCacheEntry entry : uncachedGlyphs) {\n+            for (XRGlyphCacheEntry entry : cacheEntries) {\n@@ -175,6 +199,2 @@\n-\n-                if (entry.getGlyphSet() == grayGlyphSet) {\n-                    con.XRenderAddGlyphs(grayGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n-                } else {\n-                    con.XRenderAddGlyphs(lcdGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n-                }\n+                con.XRenderAddGlyphs(glyphSet, glyphList, tmpList,\n+                                     generateGlyphImageStream(tmpList));\n@@ -186,1 +206,1 @@\n-     * Separates lcd and grayscale glyphs queued for upload, and sets the\n+     * Separates bgra, lcd and grayscale glyphs queued for upload, and sets the\n@@ -189,4 +209,4 @@\n-    protected List<XRGlyphCacheEntry>[] seperateGlyphTypes(List<XRGlyphCacheEntry> glyphList, boolean containsLCDGlyphs) {\n-        ArrayList<XRGlyphCacheEntry> lcdGlyphs = null;\n-        ArrayList<XRGlyphCacheEntry> grayGlyphs = null;\n-\n+    protected EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>>\n+            separateGlyphTypes(List<XRGlyphCacheEntry> glyphList) {\n+        EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>> glyphLists =\n+                new EnumMap<>(XRGlyphCacheEntry.Type.class);\n@@ -194,13 +214,4 @@\n-            if (cacheEntry.isGrayscale(containsLCDGlyphs)) {\n-                if (grayGlyphs == null) {\n-                    grayGlyphs = new ArrayList<>(glyphList.size());\n-                }\n-                cacheEntry.setGlyphSet(grayGlyphSet);\n-                grayGlyphs.add(cacheEntry);\n-            } else {\n-                if (lcdGlyphs == null) {\n-                    lcdGlyphs = new ArrayList<>(glyphList.size());\n-                }\n-                cacheEntry.setGlyphSet(lcdGlyphSet);\n-                lcdGlyphs.add(cacheEntry);\n-            }\n+            XRGlyphCacheEntry.Type cacheEntryType = cacheEntry.getType();\n+            cacheEntry.setGlyphSet(glyphSetsByType.get(cacheEntryType));\n+            glyphLists.computeIfAbsent(cacheEntryType, ignore ->\n+                    new ArrayList<>(glyphList.size())).add(cacheEntry);\n@@ -208,5 +219,1 @@\n-        \/\/ Arrays and generics don't play well together\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-        List<XRGlyphCacheEntry>[] tmp =\n-            (List<XRGlyphCacheEntry>[]) (new List[] { grayGlyphs, lcdGlyphs });\n-        return tmp;\n+        return glyphLists;\n@@ -229,14 +236,1 @@\n-    protected boolean containsLCDGlyphs(List<XRGlyphCacheEntry> entries) {\n-        boolean containsLCDGlyphs = false;\n-\n-        for (XRGlyphCacheEntry entry : entries) {\n-            containsLCDGlyphs = !(entry.getSourceRowBytes() == entry.getWidth());\n-\n-            if (containsLCDGlyphs) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    protected void clearCache(XRGlyphCacheEntry[] glyps) {\n+    protected void clearCache(XRGlyphCacheEntry[] glyphs) {\n@@ -255,2 +249,4 @@\n-        for (XRGlyphCacheEntry glyph : glyps) {\n-            glyph.setPinned();\n+        for (XRGlyphCacheEntry glyph : glyphs) {\n+            if (glyph != null) {\n+                glyph.setPinned();\n+            }\n@@ -271,2 +267,4 @@\n-        for (XRGlyphCacheEntry glyph : glyps) {\n-            glyph.setUnpinned();\n+        for (XRGlyphCacheEntry glyph : glyphs) {\n+            if (glyph != null) {\n+                glyph.setUnpinned();\n+            }\n@@ -281,0 +279,2 @@\n+        long[] removedBGRAGlyphPtrs = null;\n+        int removedBGRAGlyphPtrsCount = 0;\n@@ -293,1 +293,1 @@\n-            } else {\n+            } else if (entry.getGlyphSet() == lcdGlyphSet) {\n@@ -295,0 +295,11 @@\n+            } else if (entry.getGlyphSet() == BGRA_GLYPH_SET) {\n+                if (removedBGRAGlyphPtrs == null) {\n+                    removedBGRAGlyphPtrs = new long[10];\n+                } else if (removedBGRAGlyphPtrsCount >= removedBGRAGlyphPtrs.length) {\n+                    long[] n = new long[removedBGRAGlyphPtrs.length * 2];\n+                    System.arraycopy(removedBGRAGlyphPtrs, 0, n, 0,\n+                                     removedBGRAGlyphPtrs.length);\n+                    removedBGRAGlyphPtrs = n;\n+                }\n+                removedBGRAGlyphPtrs[removedBGRAGlyphPtrsCount++] =\n+                        entry.getBgraGlyphInfoPtr();\n@@ -307,0 +318,5 @@\n+\n+        if (removedBGRAGlyphPtrsCount > 0) {\n+            con.freeBGRAGlyphImages(removedBGRAGlyphPtrs,\n+                                    removedBGRAGlyphPtrsCount);\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCache.java","additions":82,"deletions":66,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    long glyphInfoPtr;\n+    long glyphInfoPtr, bgraGlyphInfoPtr;\n@@ -55,0 +55,8 @@\n+    public long getBgraGlyphInfoPtr() {\n+        return bgraGlyphInfoPtr;\n+    }\n+\n+    public void setBgraGlyphInfoPtr(long bgraGlyphInfoPtr) {\n+        this.bgraGlyphInfoPtr = bgraGlyphInfoPtr;\n+    }\n+\n@@ -135,1 +143,1 @@\n-        int paddedWidth = getPaddedWidth(uploadAsLCD);\n+        int paddedWidth = getPaddedWidth();\n@@ -137,1 +145,1 @@\n-        if (!uploadAsLCD) {\n+        if (getType() == Type.GRAYSCALE) {\n@@ -179,2 +187,6 @@\n-    public boolean isGrayscale(boolean listContainsLCDGlyphs) {\n-        return getSourceRowBytes() == getWidth() && !(getWidth() == 0 && getHeight() == 0 && listContainsLCDGlyphs);\n+    public Type getType() {\n+        byte format = StrikeCache.unsafe.getByte(glyphInfoPtr + StrikeCache.formatOffset);\n+        if (format == StrikeCache.PIXEL_FORMAT_GREYSCALE) return Type.GRAYSCALE;\n+        else if (format == StrikeCache.PIXEL_FORMAT_LCD) return Type.LCD;\n+        else if (format == StrikeCache.PIXEL_FORMAT_BGRA) return Type.BGRA;\n+        else throw new IllegalStateException(\"Unknown glyph format: \" + format);\n@@ -183,3 +195,3 @@\n-    public int getPaddedWidth(boolean listContainsLCDGlyphs) {\n-        int width = getWidth();\n-        return isGrayscale(listContainsLCDGlyphs) ? (int) Math.ceil(width \/ 4.0) * 4 : width;\n+    public int getPaddedWidth() {\n+        return getType() == Type.GRAYSCALE ?\n+                (int) Math.ceil(getWidth() \/ 4.0) * 4 : getWidth();\n@@ -188,3 +200,2 @@\n-    public int getDestinationRowBytes(boolean listContainsLCDGlyphs) {\n-        boolean grayscale = isGrayscale(listContainsLCDGlyphs);\n-        return grayscale ? getPaddedWidth(grayscale) : getWidth() * 4;\n+    public int getDestinationRowBytes() {\n+        return getType() == Type.GRAYSCALE ? getPaddedWidth() : getWidth() * 4;\n@@ -193,2 +204,2 @@\n-    public int getGlyphDataLenth(boolean listContainsLCDGlyphs) {\n-        return getDestinationRowBytes(listContainsLCDGlyphs) * getHeight();\n+    public int getGlyphDataLenth() {\n+        return getDestinationRowBytes() * getHeight();\n@@ -220,0 +231,9 @@\n+\n+\n+    public enum Type {\n+        GRAYSCALE,\n+        LCD,\n+        BGRA\n+    }\n+\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-            XRGlyphCacheEntry[] cachedGlyphs = glyphCache.cacheGlyphs(gl);\n+            XRGlyphCacheEntry[] cachedGlyphs =\n+                    glyphCache.cacheGlyphs(gl, x11sd.getXid());\n@@ -83,1 +84,3 @@\n-            int activeGlyphSet = cachedGlyphs[0].getGlyphSet();\n+            \/* Do not initialize it to cachedGlyphs[0].getGlyphSet(),\n+             * as it may cause NPE *\/\n+            int activeGlyphSet = 0;\n@@ -88,0 +91,4 @@\n+            \/* Accumulated advances are used to adjust glyph positions\n+             * when mixing BGRA and standard glyphs as they have\n+             * completely different methods of rendering. *\/\n+            float accumulatedXEltAdvanceX = 0, accumulatedXEltAdvanceY = 0;\n@@ -95,1 +102,0 @@\n-                eltList.getGlyphs().addInt(cacheEntry.getGlyphID());\n@@ -98,0 +104,11 @@\n+                if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                    \/* BGRA glyphs store pointers to BGRAGlyphInfo\n+                     * struct instead of glyph index *\/\n+                    eltList.getGlyphs().addInt(\n+                            (int) (cacheEntry.getBgraGlyphInfoPtr() >> 32));\n+                    eltList.getGlyphs().addInt(\n+                            (int) cacheEntry.getBgraGlyphInfoPtr());\n+                } else {\n+                    eltList.getGlyphs().addInt(cacheEntry.getGlyphID());\n+                }\n+\n@@ -106,1 +123,5 @@\n-                        || eltList.getCharCnt(eltIndex) == MAX_ELT_GLYPH_COUNT) {\n+                        \/* We don't care about number of glyphs when\n+                         * rendering BGRA glyphs because they are not rendered\n+                         * using XRenderCompositeText. *\/\n+                        || (glyphSet != XRGlyphCache.BGRA_GLYPH_SET &&\n+                            eltList.getCharCnt(eltIndex) == MAX_ELT_GLYPH_COUNT)) {\n@@ -139,7 +160,14 @@\n-                    \/\/ Offset of the current glyph is the difference\n-                    \/\/ to the last glyph and this one\n-                    eltList.setXOff(eltIndex, (posX - oldPosX));\n-                    eltList.setYOff(eltIndex, (posY - oldPosY));\n-\n-                    oldPosX = posX;\n-                    oldPosY = posY;\n+                    if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                        \/\/ BGRA glyphs use absolute positions\n+                        eltList.setXOff(eltIndex,\n+                                        (int) (accumulatedXEltAdvanceX + posX));\n+                        eltList.setYOff(eltIndex,\n+                                        (int) (accumulatedXEltAdvanceY + posY));\n+                    } else {\n+                        \/\/ Offset of the current glyph is the difference\n+                        \/\/ to the last glyph and this one\n+                        eltList.setXOff(eltIndex, (posX - oldPosX));\n+                        eltList.setYOff(eltIndex, (posY - oldPosY));\n+                        oldPosX = posX;\n+                        oldPosY = posY;\n+                    }\n@@ -150,0 +178,7 @@\n+                if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                    advX += cacheEntry.getXAdvance();\n+                    advY += cacheEntry.getYAdvance();\n+                } else {\n+                    accumulatedXEltAdvanceX += cacheEntry.getXAdvance();\n+                    accumulatedXEltAdvanceY += cacheEntry.getYAdvance();\n+                }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRTextRenderer.java","additions":46,"deletions":11,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+    public void addBGRAGlyphImages(int drawable,\n+                                   List<XRGlyphCacheEntry> cacheEntries);\n+\n+    public void freeBGRAGlyphImages(long[] glyphInfoPointers, int glyphCount);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRBackend.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -253,0 +253,20 @@\n+    public void addBGRAGlyphImages(int drawable,\n+                                   List<XRGlyphCacheEntry> cacheEntries) {\n+        long[] glyphInfoPtrs = getGlyphInfoPtrs(cacheEntries);\n+        addBGRAGlyphImagesNative(drawable, glyphInfoPtrs,\n+                                 glyphInfoPtrs.length, FMTPTR_ARGB32);\n+        \/* addBGRAGlyphImagesNative replaced values in\n+         * glyphInfoPtrs with pointers to BGRAGlyphInfo structs, save them *\/\n+        int i = 0;\n+        for (XRGlyphCacheEntry cacheEntry : cacheEntries) {\n+            cacheEntry.setBgraGlyphInfoPtr(glyphInfoPtrs[i++]);\n+        }\n+    }\n+\n+    private native void addBGRAGlyphImagesNative(int drawable,\n+                                                 long[] glyphInfoPtrs,\n+                                                 int glyphCnt, long format32);\n+\n+    public native void freeBGRAGlyphImages(long[] glyphInfoPointers,\n+                                           int glyphCount);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRBackendNative.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+    glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11FontScaler_md.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                       jint clipRight, jint clipBottom)\n+                       jint clipRight, jint clipBottom, jboolean *allGlyphsRendered)\n@@ -127,1 +127,1 @@\n-        rowBytes = glyphs[glyphCounter].width;\n+        rowBytes = glyphs[glyphCounter].rowBytes;\n@@ -133,0 +133,5 @@\n+        if ((int) rowBytes == width * 4) { \/\/ Skip colored glyphs\n+            *allGlyphsRendered = JNI_FALSE;\n+            continue;\n+        }\n+\n@@ -209,1 +214,1 @@\n-                 SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs)\n+                 SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs, jboolean *allGlyphsRendered)\n@@ -262,1 +267,1 @@\n-                       cx1, cy1, cx2, cy2);\n+                       cx1, cy1, cx2, cy2, allGlyphsRendered);\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11TextRenderer_md.c","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -62,0 +62,8 @@\n+\/* BGRA glyph that is rendered using XRenderComposite instead of\n+ * XRenderCompositeText32. Used for colored glyphs *\/\n+typedef struct _BGRAGlyphInfo {\n+    GlyphInfo* glyphInfo;\n+    Pixmap pixmap;\n+    Picture picture;\n+} BGRAGlyphInfo;\n+\n@@ -882,0 +890,68 @@\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_xr_XRBackendNative_addBGRAGlyphImagesNative\n+        (JNIEnv* env, jclass clazz, jint drawable,\n+         jlongArray javaGlyphInfoPointersArray, jint glyphCnt, jlong format32) {\n+    jlong* glyphInfoPointers;\n+    if ((glyphInfoPointers = (jlong *)\n+        (*env)->GetPrimitiveArrayCritical(env, javaGlyphInfoPointersArray, NULL)) == NULL) {\n+        return;\n+    }\n+\n+    XRenderPictFormat* format = (XRenderPictFormat*) jlong_to_ptr(format32);\n+    XRenderPictureAttributes pictureAttributes;\n+\n+    int i;\n+    for (i = 0; i < glyphCnt; i++) {\n+        GlyphInfo* glyphInfo = (GlyphInfo*) jlong_to_ptr(glyphInfoPointers[i]);\n+\n+        Pixmap pixmap = XCreatePixmap(awt_display, (Drawable) drawable,\n+                                      glyphInfo->width, glyphInfo->height, 32);\n+        GC gc = XCreateGC(awt_display, (Drawable) pixmap, 0L, NULL);\n+        XImage* image = XCreateImage(awt_display, NULL, 32, ZPixmap, 0,\n+                                     (char*) glyphInfo->image,\n+                                     glyphInfo->width, glyphInfo->height,\n+                                     32, glyphInfo->rowBytes);\n+        XPutImage(awt_display, pixmap, gc, image, 0, 0, 0, 0,\n+                  glyphInfo->width, glyphInfo->height);\n+        image->data = NULL;\n+        XDestroyImage(image);\n+        XFreeGC(awt_display, gc);\n+        Picture picture = XRenderCreatePicture(awt_display, pixmap, format,\n+                                               0, &pictureAttributes);\n+\n+        BGRAGlyphInfo* bgraGlyphInfo =\n+                (BGRAGlyphInfo*) malloc(sizeof(BGRAGlyphInfo));\n+        bgraGlyphInfo->glyphInfo = glyphInfo;\n+        bgraGlyphInfo->pixmap = pixmap;\n+        bgraGlyphInfo->picture = picture;\n+\n+        glyphInfoPointers[i] = ptr_to_jlong(bgraGlyphInfo);\n+    }\n+\n+    (*env)->ReleasePrimitiveArrayCritical(env, javaGlyphInfoPointersArray,\n+                                          glyphInfoPointers, JNI_ABORT);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_xr_XRBackendNative_freeBGRAGlyphImages\n+        (JNIEnv* env, jclass clazz,\n+         jlongArray javaGlyphInfoPointersArray, jint glyphCnt) {\n+    jlong* glyphInfoPointers;\n+    if ((glyphInfoPointers = (jlong *)\n+        (*env)->GetPrimitiveArrayCritical(env, javaGlyphInfoPointersArray, NULL)) == NULL) {\n+        return;\n+    }\n+\n+    int i;\n+    for (i = 0; i < glyphCnt; i++) {\n+        BGRAGlyphInfo* bgraGlyphInfo =\n+                (BGRAGlyphInfo*) jlong_to_ptr(glyphInfoPointers[i]);\n+        XRenderFreePicture(awt_display, bgraGlyphInfo->picture);\n+        XFreePixmap(awt_display, bgraGlyphInfo->pixmap);\n+        free(bgraGlyphInfo);\n+    }\n+\n+    (*env)->ReleasePrimitiveArrayCritical(env, javaGlyphInfoPointersArray,\n+                                          glyphInfoPointers, JNI_ABORT);\n+}\n+\n@@ -959,8 +1035,35 @@\n-    for (i=0; i < eltCnt; i++) {\n-      xelts[i].nchars = elts[i*4 + 0];\n-      xelts[i].xOff = elts[i*4 + 1];\n-      xelts[i].yOff = elts[i*4 + 2];\n-      xelts[i].glyphset = (GlyphSet) elts[i*4 + 3];\n-      xelts[i].chars = &xids[charCnt];\n-\n-      charCnt += xelts[i].nchars;\n+    int totalXElts = 0;\n+    for (i = 0; i < eltCnt; i++) {\n+        int nchars = elts[i*4];\n+        int xOff = elts[i*4 + 1];\n+        int yOff = elts[i*4 + 2];\n+        int glyphset = (GlyphSet) elts[i*4 + 3];\n+        if (glyphset == -1) { \/\/ BGRA glyph, render as image\n+            float x = (float) xOff;\n+            float y = (float) yOff;\n+            int ch;\n+            for (ch = 0; ch < nchars; ch++) {\n+                BGRAGlyphInfo* bgraGlyphInfo = (BGRAGlyphInfo*)\n+                        (((jlong) xids[charCnt + ch * 2] << 32) |\n+                        (((jlong) xids[charCnt + ch * 2 + 1]) & 0xFFFFFFFF));\n+                GlyphInfo* glyph = bgraGlyphInfo->glyphInfo;\n+                XRenderComposite(awt_display, PictOpOver,\n+                                 bgraGlyphInfo->picture,\n+                                 (Picture) 0, (Picture) dst,\n+                                 0, 0, 0, 0,\n+                                 (int) (x + glyph->topLeftX),\n+                                 (int) (y + glyph->topLeftY),\n+                                 glyph->width, glyph->height);\n+                x += glyph->advanceX;\n+                y += glyph->advanceY;\n+            }\n+            charCnt += nchars * 2;\n+        } else { \/\/ Standard XRender glyph\n+            xelts[totalXElts].nchars = nchars;\n+            xelts[totalXElts].xOff = xOff;\n+            xelts[totalXElts].yOff = yOff;\n+            xelts[totalXElts].glyphset = glyphset;\n+            xelts[totalXElts].chars = &xids[charCnt];\n+            charCnt += nchars;\n+            totalXElts++;\n+        }\n@@ -969,3 +1072,5 @@\n-    XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n-                           (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n-                            sx, sy, 0, 0, xelts, eltCnt);\n+    if (totalXElts > 0) {\n+        XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n+                               (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n+                               sx, sy, 0, 0, xelts, totalXElts);\n+    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/java2d\/x11\/XRBackendNative.c","additions":116,"deletions":11,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs);\n+ SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs, jboolean *allGlyphsRendered);\n@@ -53,1 +53,1 @@\n- * Signature: (Lsun\/java2d\/SurfaceData;Ljava\/awt\/Rectangle;ILsun\/font\/GlyphList;J)V\n+ * Signature: (Lsun\/java2d\/SurfaceData;Ljava\/awt\/Rectangle;ILsun\/font\/GlyphList;J)Z\n@@ -55,1 +55,1 @@\n-JNIEXPORT void JNICALL Java_sun_font_X11TextRenderer_doDrawGlyphList\n+JNIEXPORT jboolean JNICALL Java_sun_font_X11TextRenderer_doDrawGlyphList\n@@ -67,1 +67,1 @@\n-        return;\n+        return JNI_TRUE;\n@@ -71,1 +71,1 @@\n-        return;\n+        return JNI_TRUE;\n@@ -73,0 +73,1 @@\n+    jboolean allGlyphsRendered = JNI_TRUE;\n@@ -74,1 +75,1 @@\n-                     &bounds, gbv->glyphs, gbv->numGlyphs);\n+                     &bounds, gbv->glyphs, gbv->numGlyphs, &allGlyphsRendered);\n@@ -76,0 +77,1 @@\n+    return allGlyphsRendered;\n","filename":"src\/java.desktop\/unix\/native\/libfontmanager\/X11TextRenderer.c","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -88,0 +88,5 @@\n+    public GlyphRenderData getGlyphRenderData(long pScalerContext, int glyphCode,\n+                                              float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/NativeFont.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,4 @@\n+    GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+        return null;\n+    }\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/NativeStrike.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+allfonts.emoji=Segoe UI Emoji\n@@ -201,53 +202,53 @@\n-sequence.allfonts=alphabetic\/default,dingbats,symbol\n-\n-sequence.serif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-sequence.sansserif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-sequence.monospaced.GBK=chinese-ms936,alphabetic,dingbats,symbol,chinese-ms936-extb\n-sequence.dialog.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-sequence.dialoginput.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb\n-\n-sequence.serif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-sequence.sansserif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-sequence.monospaced.GB18030=chinese-gb18030,alphabetic,dingbats,symbol,chinese-gb18030-extb\n-sequence.dialog.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-sequence.dialoginput.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb\n-\n-sequence.serif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-sequence.sansserif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-sequence.monospaced.x-windows-950=chinese-ms950,alphabetic,dingbats,symbol,chinese-ms950-extb\n-sequence.dialog.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-sequence.dialoginput.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb\n-\n-sequence.serif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.sansserif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.monospaced.x-MS950-HKSCS=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialog.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialoginput.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-\n-sequence.serif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.sansserif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.monospaced.x-MS950-HKSCS-XP=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialog.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-sequence.dialoginput.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb\n-\n-sequence.allfonts.UTF-8.hi=alphabetic\/1252,devanagari,dingbats,symbol\n-sequence.allfonts.UTF-8.ja=alphabetic,japanese,dingbats,symbol\n-sequence.allfonts.UTF-8.ko=alphabetic,korean,dingbats,symbol\n-\n-sequence.allfonts.windows-1255=hebrew,alphabetic\/1252,dingbats,symbol\n-\n-sequence.serif.windows-31j=alphabetic,japanese,dingbats,symbol\n-sequence.sansserif.windows-31j=alphabetic,japanese,dingbats,symbol\n-sequence.monospaced.windows-31j=japanese,alphabetic,dingbats,symbol\n-sequence.dialog.windows-31j=alphabetic,japanese,dingbats,symbol\n-sequence.dialoginput.windows-31j=alphabetic,japanese,dingbats,symbol\n-\n-sequence.serif.x-windows-949=alphabetic,korean,dingbats,symbol\n-sequence.sansserif.x-windows-949=alphabetic,korean,dingbats,symbol\n-sequence.monospaced.x-windows-949=korean,alphabetic,dingbats,symbol\n-sequence.dialog.x-windows-949=alphabetic,korean,dingbats,symbol\n-sequence.dialoginput.x-windows-949=alphabetic,korean,dingbats,symbol\n-\n-sequence.allfonts.x-windows-874=alphabetic,thai,dingbats,symbol\n-\n-sequence.fallback=symbols,\\\n+sequence.allfonts=alphabetic\/default,dingbats,symbol,symbols\n+\n+sequence.serif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.sansserif.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.monospaced.GBK=chinese-ms936,alphabetic,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.dialog.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+sequence.dialoginput.GBK=alphabetic,chinese-ms936,dingbats,symbol,chinese-ms936-extb,symbols\n+\n+sequence.serif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.sansserif.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.monospaced.GB18030=chinese-gb18030,alphabetic,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.dialog.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+sequence.dialoginput.GB18030=alphabetic,chinese-gb18030,dingbats,symbol,chinese-gb18030-extb,symbols\n+\n+sequence.serif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.sansserif.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.monospaced.x-windows-950=chinese-ms950,alphabetic,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialog.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialoginput.x-windows-950=alphabetic,chinese-ms950,dingbats,symbol,chinese-ms950-extb,symbols\n+\n+sequence.serif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.sansserif.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.monospaced.x-MS950-HKSCS=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialog.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialoginput.x-MS950-HKSCS=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+\n+sequence.serif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.sansserif.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.monospaced.x-MS950-HKSCS-XP=chinese-ms950,alphabetic,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialog.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+sequence.dialoginput.x-MS950-HKSCS-XP=alphabetic,chinese-ms950,chinese-hkscs,dingbats,symbol,chinese-ms950-extb,symbols\n+\n+sequence.allfonts.UTF-8.hi=alphabetic\/1252,devanagari,dingbats,symbol,symbols\n+sequence.allfonts.UTF-8.ja=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.allfonts.UTF-8.ko=alphabetic,korean,dingbats,symbol,symbols\n+\n+sequence.allfonts.windows-1255=hebrew,alphabetic\/1252,dingbats,symbol,symbols\n+\n+sequence.serif.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.sansserif.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.monospaced.windows-31j=japanese,alphabetic,dingbats,symbol,symbols\n+sequence.dialog.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+sequence.dialoginput.windows-31j=alphabetic,japanese,dingbats,symbol,symbols\n+\n+sequence.serif.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+sequence.sansserif.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+sequence.monospaced.x-windows-949=korean,alphabetic,dingbats,symbol,symbols\n+sequence.dialog.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+sequence.dialoginput.x-windows-949=alphabetic,korean,dingbats,symbol,symbols\n+\n+sequence.allfonts.x-windows-874=alphabetic,thai,dingbats,symbol,symbols\n+\n+sequence.fallback=emoji,\\\n@@ -265,0 +266,19 @@\n+exclusion.symbols=000d-0022,0024-0029,002b-002f,003a-00a8,00aa-00ad,00af-02dc,2002-2003,\\\n+                  2005-2005,200d-200d,2013-2014,2018-201a,201c-201e,2020-2022,2026-2026,\\\n+                  2030-2030,2039-203a,2044-2044,20ac-20ac,20e3-20e3,2126-2126,2190-2193,\\\n+                  219a-21a8,21ab-21ff,2206-2206,220f-220f,2211-2212,2219-221a,221e-221e,\\\n+                  222b-222b,2248-2248,2260-2260,231a-231b,23e9-23ec,23f0-23f0,23f3-23f3,\\\n+                  24b6-24c1,24c3-24cf,25a0-25a9,25ac-25b5,25b7-25bf,25c1-25fa,25fd-25ff,\\\n+                  260f-2610,2612-2612,2614-2615,263b-263b,263f-263f,2641-2641,2643-2653,\\\n+                  2672-267a,267c-267d,267f-267f,2693-2693,26a1-26a6,26a8-26ab,26bd-26be,\\\n+                  26c4-26c5,26c7-26c7,26ce-26ce,26d4-26d4,26dd-26dd,26e3-26e3,26ea-26ea,\\\n+                  26f2-26f3,26f5-26f5,26fa-26fa,26fd-26fd,2701-2701,2703-2705,270a-270b,\\\n+                  270e-270e,2710-2710,2713-2713,2715-2715,2717-2718,2728-2728,2731-2732,\\\n+                  2735-2743,2745-2746,2748-274c,274e-274e,2753-2755,2757-2757,2795-2797,\\\n+                  27b0-27b0,27bf-27bf,2936-2937,2b12-2b1c,2b50-2b52,2b55-2b55,3244-3247,\\\n+                  01f000-01f02b,01f0cf-01f0cf,01f172-01f17d,01f180-01f1ff,01f201-01f201,\\\n+                  01f210-01f236,01f238-01f23a,01f250-01f320,01f32d-01f335,01f337-01f37c,\\\n+                  01f37e-01f393,01f3a0-01f3ca,01f3cf-01f3d3,01f3e0-01f3f0,01f3f4-01f3f4,\\\n+                  01f3f8-01f43e,01f440-01f440,01f442-01f4fc,01f4ff-01f53d,01f54b-01f567,\\\n+                  01f57a-01f57a,01f595-01f596,01f5a4-01f5a4,01f5fb-01f64f,01f680-01f6c5,\\\n+                  01f6cc-01f6cc,01f6d0-01f6d2,01f6eb-01f6ec,01f6f4-01f6f6,01f910-01f93a,01f93c-01f9c0\n@@ -331,0 +351,1 @@\n+filename.Segoe_UI_Emoji=seguiemj.ttf\n","filename":"src\/java.desktop\/windows\/data\/fontconfig\/fontconfig.properties","additions":74,"deletions":53,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -795,1 +795,1 @@\n-        grayscale = (ginfo->rowBytes == ginfo->width);\n+        grayscale = (ginfo->format == sun_font_StrikeCache_PIXEL_FORMAT_GREYSCALE);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/java2d\/d3d\/D3DTextRenderer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -438,0 +438,1 @@\n+    glyphInfo->format = sun_font_StrikeCache_PIXEL_FORMAT_LCD;\n","filename":"src\/java.desktop\/windows\/native\/libfontmanager\/lcdglyph.c","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269806\n+ * @summary Checks that complex emoji are rendered with proper shaping.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.stream.Stream;\n+\n+public class ComplexEmoji {\n+    private static final int IMG_WIDTH = 60;\n+    private static final int IMG_HEIGHT = 20;\n+\n+    private static final String[] EMOJI = {\n+            \"\\ud83d\\udd25\", \/\/ Fire\n+            \"\\u2764\\ufe0f\", \/\/ Heart + color variation selector\n+            \"\\ud83e\\udd18\\ud83c\\udffb\", \/\/ Horns sign - white hand\n+            \"\\ud83d\\udc41\\ufe0f\\u200d\\ud83d\\udde8\\ufe0f\", \/\/ Eye in speech bubble - ZWJ sequence\n+            \"\\uD83C\\uDDE6\\uD83C\\uDDF6\", \/\/ Antarctica flag\n+            \"\\ud83c\\udff4\\udb40\\udc67\\udb40\\udc62\\udb40\\udc65\\udb40\\udc6e\\udb40\\udc67\\udb40\\udc7f\", \/\/ England flag - tag sequence\n+    };\n+\n+    public static void main(String[] args) {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n+        \/\/ Platform-specific tricks\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n+            EMOJI[4] = EMOJI[5] = null; \/\/ Flags and tags are not supported on Windows\n+        }\n+\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        String errors = \"\";\n+        for (int i = 0; i < EMOJI.length; i++) {\n+            String emoji = EMOJI[i];\n+            if (emoji == null) continue;\n+            drawEmoji(img, emoji);\n+            String error = checkEmoji(img);\n+            if (error != null) {\n+                errors += \"\\n#\" + i + \": \" + error;\n+                try {\n+                    ImageIO.write(img, \"PNG\", new File(\"ComplexEmoji\" + i + \".png\"));\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+        if (!errors.isEmpty()) throw new RuntimeException(errors);\n+    }\n+\n+    private static void drawEmoji(Image img, String emoji) {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n+        \/\/ Try to trick shaper by prepending \"A\" letter\n+        \/\/ White on white will not be visible anyway\n+        g.drawString(\"A\" + emoji, 2, 15);\n+        g.dispose();\n+    }\n+\n+    private static String checkEmoji(BufferedImage img) {\n+        Point min = new Point(Integer.MAX_VALUE, Integer.MAX_VALUE);\n+        Point max = new Point(Integer.MIN_VALUE, Integer.MIN_VALUE);\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                int rgb = img.getRGB(x, y);\n+                if (rgb != -1) {\n+                    if (x < min.x) min.x = x;\n+                    if (y < min.y) min.y = y;\n+                    if (x > max.x) max.x = x;\n+                    if (y > max.y) max.y = y;\n+                }\n+            }\n+        }\n+        if (min.x >= max.x || min.y >= max.y) {\n+            return \"Empty image\";\n+        }\n+        int width = max.x - min.x + 1;\n+        int height = max.y - min.y + 1;\n+        double ratio = (double) width \/ (double) height;\n+        if (ratio > 1.5) {\n+            return \"Too wide image, is there few glyphs instead of one?\";\n+        }\n+        return null;\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/ComplexEmoji.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8263583 8269806\n+ * @summary Checks that emoji character has a non-empty and identical\n+ *          representation when rendered to different types of images,\n+ *          including an accelerated surface.\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 Emoji\n+ *\/\n+\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.VolatileImage;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+public class Emoji {\n+    private static final int IMG_WIDTH = 20;\n+    private static final int IMG_HEIGHT = 20;\n+    private static final Font FONT = new Font(\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"linux\") ?\n+                    \"Noto Color Emoji\" : Font.DIALOG, Font.PLAIN, 12);\n+\n+    public static void main(String[] args) {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n+        GraphicsConfiguration cfg\n+                = GraphicsEnvironment.getLocalGraphicsEnvironment()\n+                .getDefaultScreenDevice().getDefaultConfiguration();\n+\n+        VolatileImage vImg = cfg.createCompatibleVolatileImage(IMG_WIDTH,\n+                                                               IMG_HEIGHT);\n+        BufferedImage refImg;\n+        int attempt = 0;\n+        do {\n+            if (++attempt > 10) {\n+                throw new RuntimeException(\"Failed to render to VolatileImage\");\n+            }\n+            if (vImg.validate(cfg) == VolatileImage.IMAGE_INCOMPATIBLE) {\n+                throw new RuntimeException(\"Unexpected validation failure\");\n+            }\n+            drawEmoji(vImg);\n+            refImg = vImg.getSnapshot();\n+        } while (vImg.contentsLost());\n+\n+        boolean rendered = false;\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                if (refImg.getRGB(x, y) != 0xFFFFFFFF) {\n+                    rendered = true;\n+                    break;\n+                }\n+            }\n+        }\n+        if (!rendered) {\n+            throw new RuntimeException(\"Emoji character wasn't rendered\");\n+        }\n+\n+        List<Integer> imageTypes = List.of(\n+                BufferedImage.TYPE_INT_RGB,\n+                BufferedImage.TYPE_INT_ARGB,\n+                BufferedImage.TYPE_INT_ARGB_PRE,\n+                BufferedImage.TYPE_INT_BGR,\n+                BufferedImage.TYPE_3BYTE_BGR,\n+                BufferedImage.TYPE_4BYTE_ABGR,\n+                BufferedImage.TYPE_4BYTE_ABGR_PRE\n+        );\n+        for (Integer type : imageTypes) {\n+            BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, type);\n+            drawEmoji(img);\n+            for (int x = 0; x < IMG_WIDTH; x++) {\n+                for (int y = 0; y < IMG_HEIGHT; y++) {\n+                    if (refImg.getRGB(x, y) != img.getRGB(x, y)) {\n+                        throw new RuntimeException(\n+                                \"Rendering differs for image type \" + type);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void drawEmoji(Image img) {\n+        Graphics g = img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(FONT);\n+        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n+        g.dispose();\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/Emoji.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269806\n+ * @summary Checks that variation selectors work.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_OFF;\n+\n+public class EmojiVariation {\n+    private static final int IMG_WIDTH = 100;\n+    private static final int IMG_HEIGHT = 50;\n+\n+    private static final Color SYMBOL_COLOR = Color.MAGENTA;\n+\n+    \/\/ These emoji must be monochrome by default\n+    private static final String[] SYMBOLS = {\n+            \"\\u0023\",\"\\u002a\",\"\\u0030\",\"\\u0031\",\"\\u0032\",\"\\u0033\",\"\\u0034\",\"\\u0035\",\"\\u0036\",\"\\u0037\",\"\\u0038\",\"\\u0039\",\n+            \"\\u00a9\",\"\\u00ae\",\"\\u203c\",\"\\u2049\",\"\\u2122\",\"\\u2139\",\"\\u2194\",\"\\u2195\",\"\\u2196\",\"\\u2197\",\"\\u2198\",\"\\u2199\",\n+            \"\\u21a9\",\"\\u21aa\",\"\\u2328\",\"\\u23cf\",\"\\u23ed\",\"\\u23ee\",\"\\u23ef\",\"\\u23f1\",\"\\u23f2\",\"\\u23f8\",\"\\u23f9\",\"\\u23fa\",\n+            \"\\u24c2\",\"\\u25aa\",\"\\u25ab\",\"\\u25b6\",\"\\u25c0\",\"\\u25fb\",\"\\u25fc\",\"\\u2600\",\"\\u2601\",\"\\u2602\",\"\\u2603\",\"\\u2604\",\n+            \"\\u260e\",\"\\u2611\",\"\\u2618\",\"\\u261d\",\"\\u2620\",\"\\u2622\",\"\\u2623\",\"\\u2626\",\"\\u262a\",\"\\u262e\",\"\\u262f\",\"\\u2638\",\n+            \"\\u2639\",\"\\u263a\",\"\\u2640\",\"\\u2642\",\"\\u265f\",\"\\u2660\",\"\\u2663\",\"\\u2665\",\"\\u2666\",\"\\u2668\",\"\\u267b\",\"\\u267e\",\n+            \"\\u2692\",\"\\u2694\",\"\\u2695\",\"\\u2696\",\"\\u2697\",\"\\u2699\",\"\\u269b\",\"\\u269c\",\"\\u26a0\",\"\\u26b0\",\"\\u26b1\",\"\\u26c8\",\n+            \"\\u26cf\",\"\\u26d1\",\"\\u26d3\",\"\\u26e9\",\"\\u26f0\",\"\\u26f1\",\"\\u26f4\",\"\\u26f7\",\"\\u26f8\",\"\\u26f9\",\"\\u2702\",\"\\u2708\",\n+            \"\\u2709\",\"\\u270c\",\"\\u270d\",\"\\u270f\",\"\\u2712\",\"\\u2714\",\"\\u2716\",\"\\u271d\",\"\\u2721\",\"\\u2733\",\"\\u2734\",\"\\u2744\",\n+            \"\\u2747\",\"\\u2763\",\"\\u2764\",\"\\u27a1\",\"\\u2934\",\"\\u2935\",\"\\u2b05\",\"\\u2b06\",\"\\u2b07\",\"\\u3030\",\"\\u303d\",\"\\u3297\",\n+            \"\\u3299\",\"\\ud83c\\udd70\",\"\\ud83c\\udd71\",\"\\ud83c\\udd7e\",\"\\ud83c\\udd7f\",\"\\ud83c\\ude02\",\"\\ud83c\\ude37\",\n+            \"\\ud83c\\udf21\",\"\\ud83c\\udf24\",\"\\ud83c\\udf25\",\"\\ud83c\\udf26\",\"\\ud83c\\udf27\",\"\\ud83c\\udf28\",\"\\ud83c\\udf29\",\n+            \"\\ud83c\\udf2a\",\"\\ud83c\\udf2b\",\"\\ud83c\\udf2c\",\"\\ud83c\\udf36\",\"\\ud83c\\udf7d\",\"\\ud83c\\udf96\",\"\\ud83c\\udf97\",\n+            \"\\ud83c\\udf99\",\"\\ud83c\\udf9a\",\"\\ud83c\\udf9b\",\"\\ud83c\\udf9e\",\"\\ud83c\\udf9f\",\"\\ud83c\\udfcb\",\"\\ud83c\\udfcc\",\n+            \"\\ud83c\\udfcd\",\"\\ud83c\\udfce\",\"\\ud83c\\udfd4\",\"\\ud83c\\udfd5\",\"\\ud83c\\udfd6\",\"\\ud83c\\udfd7\",\"\\ud83c\\udfd8\",\n+            \"\\ud83c\\udfd9\",\"\\ud83c\\udfda\",\"\\ud83c\\udfdb\",\"\\ud83c\\udfdc\",\"\\ud83c\\udfdd\",\"\\ud83c\\udfde\",\"\\ud83c\\udfdf\",\n+            \"\\ud83c\\udff3\",\"\\ud83c\\udff5\",\"\\ud83c\\udff7\",\"\\ud83d\\udc3f\",\"\\ud83d\\udc41\",\"\\ud83d\\udcfd\",\"\\ud83d\\udd49\",\n+            \"\\ud83d\\udd4a\",\"\\ud83d\\udd6f\",\"\\ud83d\\udd70\",\"\\ud83d\\udd73\",\"\\ud83d\\udd74\",\"\\ud83d\\udd75\",\"\\ud83d\\udd76\",\n+            \"\\ud83d\\udd77\",\"\\ud83d\\udd78\",\"\\ud83d\\udd79\",\"\\ud83d\\udd87\",\"\\ud83d\\udd8a\",\"\\ud83d\\udd8b\",\"\\ud83d\\udd8c\",\n+            \"\\ud83d\\udd8d\",\"\\ud83d\\udd90\",\"\\ud83d\\udda5\",\"\\ud83d\\udda8\",\"\\ud83d\\uddb1\",\"\\ud83d\\uddb2\",\"\\ud83d\\uddbc\",\n+            \"\\ud83d\\uddc2\",\"\\ud83d\\uddc3\",\"\\ud83d\\uddc4\",\"\\ud83d\\uddd1\",\"\\ud83d\\uddd2\",\"\\ud83d\\uddd3\",\"\\ud83d\\udddc\",\n+            \"\\ud83d\\udddd\",\"\\ud83d\\uddde\",\"\\ud83d\\udde1\",\"\\ud83d\\udde3\",\"\\ud83d\\udde8\",\"\\ud83d\\uddef\",\"\\ud83d\\uddf3\",\n+            \"\\ud83d\\uddfa\",\"\\ud83d\\udecb\",\"\\ud83d\\udecd\",\"\\ud83d\\udece\",\"\\ud83d\\udecf\",\"\\ud83d\\udee0\",\"\\ud83d\\udee1\",\n+            \"\\ud83d\\udee2\",\"\\ud83d\\udee3\",\"\\ud83d\\udee4\",\"\\ud83d\\udee5\",\"\\ud83d\\udee9\",\"\\ud83d\\udef0\",\"\\ud83d\\udef3\",\n+    };\n+\n+    private enum Variation {\n+        DEFAULT(\"\"),\n+        MONO(\"\\ufe0e\"),\n+        COLOR(\"\\ufe0f\");\n+\n+        final String suffix;\n+\n+        Variation(String suffix) {\n+            this.suffix = suffix;\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+        requireFont(\"Zapf Dingbats\", \"Segoe UI Symbol\", \"DejaVu Sans\");\n+\n+        \/\/ Platform-specific tricks\n+       if (System.getProperty(\"os.name\").toLowerCase().contains(\"linux\")) {\n+           \/\/ Many emoji on Linux don't have monochrome variants\n+           Arrays.fill(SYMBOLS, 28, 37, null);\n+           Arrays.fill(SYMBOLS, 83, 94, null);\n+           Arrays.fill(SYMBOLS, 117, SYMBOLS.length, null);\n+        } else if (System.getProperty(\"os.name\").toLowerCase().contains(\"mac\")) {\n+           \/\/ Many emoji on macOS don't have monochrome variants\n+           Arrays.fill(SYMBOLS, 28, 36, null);\n+           Arrays.fill(SYMBOLS, 81, 94, null);\n+           Arrays.fill(SYMBOLS, 127, SYMBOLS.length, null);\n+        }\n+\n+        BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        String errors = \"\";\n+        for (String s : SYMBOLS) {\n+            if (s == null) continue;\n+            errors += test(img, s, Variation.DEFAULT, false);\n+            errors += test(img, s, Variation.MONO, false);\n+            errors += test(img, s, Variation.COLOR, true);\n+        }\n+\n+        if (System.getProperty(\"os.name\").toLowerCase().contains(\"windows\")) {\n+            \/\/ Bonus points: check that variation selectors work other way too\n+            String s = \"\\ud83d\\udd25\";\n+            errors += test(img, s, Variation.DEFAULT, true);\n+            errors += test(img, s, Variation.MONO, false);\n+            errors += test(img, s, Variation.COLOR, true);\n+        }\n+\n+        if (!errors.isEmpty()) throw new RuntimeException(errors);\n+    }\n+\n+    private static String test(BufferedImage img, String symbol, Variation variation, boolean expectColor) {\n+        draw(img, symbol + variation.suffix);\n+        String error = check(img, expectColor);\n+        if (error != null) {\n+            String name = symbol.chars().mapToObj(c -> {\n+                String s = Integer.toHexString(c);\n+                return \"0\".repeat(4 - s.length()) + s;\n+            }).collect(Collectors.joining(\"-\")) + \"-\" + variation;\n+            try {\n+                ImageIO.write(img, \"PNG\", new File(\"EmojiVariation-\" + name + \".png\"));\n+            } catch (IOException e) {\n+                e.printStackTrace();\n+            }\n+            return \"\\n\" + name + \": \" + error;\n+        }\n+        return \"\";\n+    }\n+\n+    private static void draw(Image img, String symbol) {\n+        Graphics2D g = (Graphics2D) img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 50));\n+        g.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_OFF);\n+        g.setColor(SYMBOL_COLOR);\n+        g.drawString(symbol, 2, 42);\n+        g.dispose();\n+    }\n+\n+    private static String check(BufferedImage img, boolean expectColor) {\n+        boolean rendered = false;\n+        boolean color = false;\n+        for (int x = 0; x < IMG_WIDTH; x++) {\n+            for (int y = 0; y < IMG_HEIGHT; y++) {\n+                int rgb = img.getRGB(x, y);\n+                if (rgb != Color.white.getRGB()) {\n+                    rendered = true;\n+                    if ((rgb & 0xff00ff) != 0xff00ff) {\n+                        \/\/ When monochrome symbol is rendered with AA=ON,\n+                        \/\/ pixel color may be anywhere between magenta (SYMBOL_COLOR) and white,\n+                        \/\/ which is 0xff00ff - 0xffffff. This means only green component may vary,\n+                        \/\/ red and green must always be 0xff\n+                        color = true;\n+                    }\n+                }\n+            }\n+        }\n+        if (!rendered) {\n+            return \"Empty image\";\n+        } else if (color != expectColor) {\n+            return expectColor ? \"Expected color but rendered mono\" : \"Expected mono but rendered color\";\n+        }\n+        return null;\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/EmojiVariation.java","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright 2021 JetBrains s.r.o.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key headful\n- * @bug 8263583\n- * @summary Checks that emoji character has a non-empty and identical\n- *          representation when rendered to different types of images,\n- *          including an accelerated (OpenGL or Metal) surface.\n- * @requires (os.family == \"mac\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 MacEmoji\n- *\/\n-\n-import java.awt.*;\n-import java.awt.image.BufferedImage;\n-import java.awt.image.VolatileImage;\n-import java.util.List;\n-\n-public class MacEmoji {\n-    private static final int IMG_WIDTH = 20;\n-    private static final int IMG_HEIGHT = 20;\n-\n-    public static void main(String[] args) {\n-        GraphicsConfiguration cfg\n-                = GraphicsEnvironment.getLocalGraphicsEnvironment()\n-                .getDefaultScreenDevice().getDefaultConfiguration();\n-\n-        VolatileImage vImg = cfg.createCompatibleVolatileImage(IMG_WIDTH,\n-                                                               IMG_HEIGHT);\n-        BufferedImage refImg;\n-        int attempt = 0;\n-        do {\n-            if (++attempt > 10) {\n-                throw new RuntimeException(\"Failed to render to VolatileImage\");\n-            }\n-            if (vImg.validate(cfg) == VolatileImage.IMAGE_INCOMPATIBLE) {\n-                throw new RuntimeException(\"Unexpected validation failure\");\n-            }\n-            drawEmoji(vImg);\n-            refImg = vImg.getSnapshot();\n-        } while (vImg.contentsLost());\n-\n-        boolean rendered = false;\n-        for (int x = 0; x < IMG_WIDTH; x++) {\n-            for (int y = 0; y < IMG_HEIGHT; y++) {\n-                if (refImg.getRGB(x, y) != 0xFFFFFFFF) {\n-                    rendered = true;\n-                    break;\n-                }\n-            }\n-        }\n-        if (!rendered) {\n-            throw new RuntimeException(\"Emoji character wasn't rendered\");\n-        }\n-\n-        List<Integer> imageTypes = List.of(\n-                BufferedImage.TYPE_INT_RGB,\n-                BufferedImage.TYPE_INT_ARGB,\n-                BufferedImage.TYPE_INT_ARGB_PRE,\n-                BufferedImage.TYPE_INT_BGR,\n-                BufferedImage.TYPE_3BYTE_BGR,\n-                BufferedImage.TYPE_4BYTE_ABGR,\n-                BufferedImage.TYPE_4BYTE_ABGR_PRE\n-        );\n-        for (Integer type : imageTypes) {\n-            BufferedImage img = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, type);\n-            drawEmoji(img);\n-            for (int x = 0; x < IMG_WIDTH; x++) {\n-                for (int y = 0; y < IMG_HEIGHT; y++) {\n-                    if (refImg.getRGB(x, y) != img.getRGB(x, y)) {\n-                        throw new RuntimeException(\n-                                \"Rendering differs for image type \" + type);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    private static void drawEmoji(Image img) {\n-        Graphics g = img.getGraphics();\n-        g.setColor(Color.white);\n-        g.fillRect(0, 0, IMG_WIDTH, IMG_HEIGHT);\n-        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n-        g.drawString(\"\\uD83D\\uDE00\" \/* U+1F600 'GRINNING FACE' *\/, 2, 15);\n-        g.dispose();\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/font\/MacEmoji.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright 2021 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8269806\n+ * @summary Checks that emoji rendered via glyph cache and bypassing it look similar.\n+ *\/\n+\n+import javax.imageio.ImageIO;\n+import java.awt.*;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.util.stream.Stream;\n+\n+import static java.awt.RenderingHints.KEY_TEXT_ANTIALIASING;\n+import static java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON;\n+\n+public class OutlineTextRendererEmoji {\n+    private static final int IMG_WIDTH = 84;\n+    private static final int IMG_HEIGHT = 84;\n+    private static final int EMOJI_X = 0;\n+    private static final int EMOJI_Y = 70;\n+    private static final int FONT_SIZE = 70;\n+    private static final String EMOJI = \"\\ud83d\\udd25\"; \/\/ Fire\n+\n+    private static final int WINDOW_SIZE = 12; \/\/ In pixels\n+    private static final double THRESHOLD = 0.98;\n+\n+    public static void main(String[] args) throws Exception {\n+        requireFont(\"Apple Color Emoji\", \"Segoe UI Emoji\", \"Noto Color Emoji\");\n+\n+        BufferedImage small = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        BufferedImage rescaled = new BufferedImage(IMG_WIDTH, IMG_HEIGHT, BufferedImage.TYPE_INT_RGB);\n+        BufferedImage big = new BufferedImage(IMG_WIDTH*2, IMG_HEIGHT*2, BufferedImage.TYPE_INT_RGB);\n+        drawEmoji(small, EMOJI_X, EMOJI_Y, FONT_SIZE);\n+        drawEmoji(big, EMOJI_X*2, EMOJI_Y*2, FONT_SIZE*2);\n+        checkEmoji(small, big, rescaled);\n+    }\n+\n+    private static void drawEmoji(Image img, int x, int y, int size) {\n+        Graphics2D g = (Graphics2D) img.getGraphics();\n+        g.setColor(Color.white);\n+        g.fillRect(0, 0, img.getWidth(null), img.getHeight(null));\n+        g.setFont(new Font(Font.DIALOG, Font.PLAIN, size));\n+        g.setRenderingHint(KEY_TEXT_ANTIALIASING, VALUE_TEXT_ANTIALIAS_ON);\n+        g.drawString(EMOJI, x, y);\n+        g.dispose();\n+    }\n+\n+    private static void checkEmoji(BufferedImage small, BufferedImage big, BufferedImage rescaled) throws Exception {\n+        Graphics2D g2d = rescaled.createGraphics();\n+        g2d.drawImage(big.getScaledInstance(small.getWidth(), small.getHeight(), Image.SCALE_SMOOTH), 0, 0, null);\n+        g2d.dispose();\n+\n+        double ssim = SSIM.calculate(small, rescaled, WINDOW_SIZE);\n+        System.out.println(\"SSIM is \" + ssim);\n+\n+        if (ssim < THRESHOLD) {\n+            ImageIO.write(small, \"PNG\", new File(\"OutlineTextRendererEmoji-small.png\"));\n+            ImageIO.write(big, \"PNG\", new File(\"OutlineTextRendererEmoji-big.png\"));\n+            ImageIO.write(rescaled, \"PNG\", new File(\"OutlineTextRendererEmoji-rescaled.png\"));\n+            throw new Exception(\"Images mismatch: \" + ssim);\n+        }\n+    }\n+\n+    private static class SSIM {\n+        private static double calculate(BufferedImage a, BufferedImage b, int windowSize) {\n+            if (a.getWidth() != b.getWidth() || a.getHeight() != b.getHeight()) {\n+                throw new IllegalArgumentException(\"Images must have same size\");\n+            }\n+            if (a.getWidth() % windowSize != 0 || a.getHeight() % windowSize != 0) {\n+                throw new IllegalArgumentException(\"Image sizes must be multiple of windowSize\");\n+            }\n+\n+            final double K1 = 0.01, K2 = 0.03;\n+            final double L = 255; \/\/ dynamic range per component (2^8 - 1)\n+            final double c1 = Math.pow(L * K1, 2);\n+            final double c2 = Math.pow(L * K2, 2);\n+\n+            double result = 0, alpha = 0;\n+            int windows = 0;\n+            for (int y = 0; y <= a.getHeight() - windowSize; y++) {\n+                for (int x = 0; x <= a.getWidth() - windowSize; x++) {\n+\n+                    \/\/ Calculate averages\n+                    double[] avgA = vec(), avgB = vec();\n+                    for (int py = 0; py < windowSize; py++) {\n+                        for (int px = 0; px < windowSize; px++) {\n+                            avgA = add(avgA, vec(a.getRGB(x + px, y + py)));\n+                            avgB = add(avgB, vec(b.getRGB(x + px, y + py)));\n+                        }\n+                    }\n+                    avgA = div(avgA, windowSize * windowSize);\n+                    avgB = div(avgB, windowSize * windowSize);\n+\n+                    \/\/ Calculate variance and covariance\n+                    double[] varA = vec(), varB = vec(), cov = vec();\n+                    for (int py = 0; py < windowSize; py++) {\n+                        for (int px = 0; px < windowSize; px++) {\n+                            double[] da = sub(avgA, vec(a.getRGB(x + px, y + py)));\n+                            double[] db = sub(avgB, vec(b.getRGB(x + px, y + py)));\n+                            varA = add(varA, mul(da, da));\n+                            varB = add(varB, mul(db, db));\n+                            cov = add(cov, mul(da, db));\n+                        }\n+                    }\n+                    varA = div(varA, windowSize * windowSize);\n+                    varB = div(varB, windowSize * windowSize);\n+                    cov = div(cov, windowSize * windowSize);\n+\n+                    \/\/ Calculate ssim\n+                    double[] ssim = vec();\n+                    for (int i = 0; i < 4; i++) {\n+                        ssim[i] = (\n+                                (2 * avgA[i] * avgB[i] + c1) * (2 * cov[i] + c2)\n+                        ) \/ (\n+                                (avgA[i]*avgA[i] + avgB[i]*avgB[i] + c1) * (varA[i] + varB[i] + c2)\n+                        );\n+                    }\n+\n+                    result += ssim[0] + ssim[1] + ssim[2];\n+                    alpha += ssim[3];\n+                    windows++;\n+                }\n+            }\n+            if (alpha == windows) result \/= 3.0;\n+            else result = (result + alpha) \/ 4.0;\n+            return result \/ (double) windows;\n+        }\n+\n+        private static double[] vec(double... v) {\n+            if (v.length == 0) return new double[4];\n+            else if (v.length == 1) return new double[] {v[0],v[0],v[0],v[0]};\n+            else return v;\n+        }\n+        private static double[] vec(int color) {\n+            return vec(color & 0xff, (color >> 8) & 0xff, (color >> 16) & 0xff, (color >> 24) & 0xff);\n+        }\n+\n+        interface Op {  double apply(double a, double b); }\n+        private static double[] apply(Op op, double[] a, double... b) {\n+            b = vec(b);\n+            double[] r = new double[4];\n+            for (int i = 0; i < 4; i++) r[i] = op.apply(a[i], b[i]);\n+            return r;\n+        }\n+\n+        private static double[] add(double[] a, double... b) { return apply((i, j) -> i + j, a, b); }\n+        private static double[] sub(double[] a, double... b) { return apply((i, j) -> i - j, a, b); }\n+        private static double[] mul(double[] a, double... b) { return apply((i, j) -> i * j, a, b); }\n+        private static double[] div(double[] a, double... b) { return apply((i, j) -> i \/ j, a, b); }\n+    }\n+\n+    private static void requireFont(String macOS, String windows, String linux) {\n+        String os = System.getProperty(\"os.name\").toLowerCase();\n+        String font;\n+        if (os.contains(\"mac\")) font = macOS;\n+        else if (os.contains(\"windows\")) font = windows;\n+        else if (os.contains(\"linux\")) font = linux;\n+        else return;\n+        String[] fs = GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();\n+        if (Stream.of(fs).noneMatch(s -> s.equals(font))) {\n+            System.err.println(\"Required font not found: \" + font);\n+            System.exit(0);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/font\/OutlineTextRendererEmoji.java","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"}]}