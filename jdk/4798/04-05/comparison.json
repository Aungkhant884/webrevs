{"files":[{"patch":"@@ -1,171 +1,171 @@\n-\/*\r\n- * Copyright 2000-2022 JetBrains s.r.o.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package sun.font;\r\n-\r\n-import jdk.internal.misc.Unsafe;\r\n-\r\n-import java.awt.*;\r\n-import java.awt.geom.AffineTransform;\r\n-import java.awt.geom.GeneralPath;\r\n-import java.awt.image.BufferedImage;\r\n-import java.awt.image.ColorModel;\r\n-import java.awt.image.DirectColorModel;\r\n-import java.util.ArrayList;\r\n-import java.util.List;\r\n-\r\n-\/**\r\n- * Data for rendering any number of glyphs bypassing glyph cache.\r\n- *\/\r\n-public class GlyphRenderData {\r\n-\r\n-    public GeneralPath outline;\r\n-    public List<ColorLayer> colorLayers;\r\n-    public List<Bitmap> bitmaps;\r\n-\r\n-    public GlyphRenderData() {}\r\n-    public GlyphRenderData(GlyphRenderData i) {\r\n-        if (i.outline != null) outline = (GeneralPath) i.outline.clone();\r\n-        if (i.colorLayers != null) {\r\n-            colorLayers = new ArrayList<>(i.colorLayers.size());\r\n-            for (ColorLayer l : i.colorLayers) {\r\n-                colorLayers.add(new ColorLayer(l.color, (GeneralPath) l.outline.clone()));\r\n-            }\r\n-        }\r\n-        if (i.bitmaps != null) {\r\n-            bitmaps = new ArrayList<>(i.bitmaps.size());\r\n-            for (Bitmap b : i.bitmaps) {\r\n-                bitmaps.add(new Bitmap(new AffineTransform(b.transform), b.image));\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    \/**\r\n-     * @param i must not be used afterwards\r\n-     *\/\r\n-    public void merge(GlyphRenderData i) {\r\n-        if (i.outline != null) {\r\n-            if (outline == null) outline = i.outline;\r\n-            else outline.append(i.outline.getPathIterator(null), false);\r\n-        }\r\n-        if (i.colorLayers != null) {\r\n-            if (colorLayers == null) colorLayers = i.colorLayers;\r\n-            else colorLayers.addAll(i.colorLayers);\r\n-        }\r\n-        if (i.bitmaps != null) {\r\n-            if (bitmaps == null) bitmaps = i.bitmaps;\r\n-            else bitmaps.addAll(i.bitmaps);\r\n-        }\r\n-    }\r\n-\r\n-    public void transform(AffineTransform transform) {\r\n-        if (outline != null) outline.transform(transform);\r\n-        if (colorLayers != null) {\r\n-            for (ColorLayer layer : colorLayers) {\r\n-                layer.outline.transform(transform);\r\n-            }\r\n-        }\r\n-        if (bitmaps != null) {\r\n-            for (Bitmap bitmap : bitmaps) {\r\n-                bitmap.transform.preConcatenate(transform);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void draw(Graphics2D g) {\r\n-        if (outline != null) g.fill(outline);\r\n-        if (colorLayers != null) {\r\n-            Color color = g.getColor();\r\n-            for (ColorLayer layer : colorLayers) {\r\n-                g.setColor(layer.color == null ? color : layer.color);\r\n-                g.fill(layer.outline);\r\n-            }\r\n-            g.setColor(color);\r\n-        }\r\n-        if (bitmaps != null) {\r\n-            for (Bitmap bitmap : bitmaps) {\r\n-                g.drawImage(bitmap.image, bitmap.transform, null);\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public record ColorLayer(Color color, GeneralPath outline) {}\r\n-\r\n-    public record Bitmap(AffineTransform transform, Image image) {}\r\n-\r\n-    \/\/ These methods exist for convenience and are called from native\r\n-\r\n-    private void setColorLayersList(int capacity) {\r\n-        colorLayers = new ArrayList<>(capacity);\r\n-    }\r\n-\r\n-    private void addColorLayers(GeneralPath outline) {\r\n-        colorLayers.add(new ColorLayer(null, outline));\r\n-    }\r\n-\r\n-    private void addColorLayers(int r, int g, int b, int a, GeneralPath outline) {\r\n-        colorLayers.add(new ColorLayer(new Color(r, g, b, a), outline));\r\n-    }\r\n-\r\n-    private static ColorModel colorModel(int bits, int r, int g, int b, int a) {\r\n-        if (Unsafe.getUnsafe().isBigEndian()) {\r\n-            r = Integer.reverse(r) >>> (32 - bits);\r\n-            g = Integer.reverse(g) >>> (32 - bits);\r\n-            b = Integer.reverse(b) >>> (32 - bits);\r\n-            a = Integer.reverse(a) >>> (32 - bits);\r\n-        }\r\n-        return new DirectColorModel(bits, r, g, b, a);\r\n-    }\r\n-    private static final ColorModel[] BITMAP_COLOR_MODELS = {\r\n-            colorModel(32, \/\/ macOS RGBA\r\n-                    0x000000ff,\r\n-                    0x0000ff00,\r\n-                    0x00ff0000,\r\n-                    0xff000000),\r\n-            colorModel(32, \/\/ macOS ARGB\r\n-                    0x0000ff00,\r\n-                    0x00ff0000,\r\n-                    0xff000000,\r\n-                    0x000000ff),\r\n-            colorModel(32, \/\/ Freetype BGRA\r\n-                    0x00ff0000,\r\n-                    0x0000ff00,\r\n-                    0x000000ff,\r\n-                    0xff000000)\r\n-    };\r\n-    private void addBitmap(double m00, double m10,\r\n-                           double m01, double m11,\r\n-                           double m02, double m12,\r\n-                           int width, int height, int pitch,\r\n-                           int colorModel, int[] data) {\r\n-        if (bitmaps == null) bitmaps = new ArrayList<>();\r\n-        ColorModel color = BITMAP_COLOR_MODELS[colorModel];\r\n-        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\r\n-        for (int y = 0; y < height; y++) {\r\n-            for (int x = 0; x < width; x++) {\r\n-                image.setRGB(x, y, color.getRGB(data[pitch * y + x]));\r\n-            }\r\n-        }\r\n-        bitmaps.add(new Bitmap(new AffineTransform(m00, m10, m01, m11, m02, m12), image));\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright 2000-2022 JetBrains s.r.o.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.font;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+import java.awt.*;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.GeneralPath;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DirectColorModel;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Data for rendering any number of glyphs bypassing glyph cache.\n+ *\/\n+public class GlyphRenderData {\n+\n+    public GeneralPath outline;\n+    public List<ColorLayer> colorLayers;\n+    public List<Bitmap> bitmaps;\n+\n+    public GlyphRenderData() {}\n+    public GlyphRenderData(GlyphRenderData i) {\n+        if (i.outline != null) outline = (GeneralPath) i.outline.clone();\n+        if (i.colorLayers != null) {\n+            colorLayers = new ArrayList<>(i.colorLayers.size());\n+            for (ColorLayer l : i.colorLayers) {\n+                colorLayers.add(new ColorLayer(l.color, (GeneralPath) l.outline.clone()));\n+            }\n+        }\n+        if (i.bitmaps != null) {\n+            bitmaps = new ArrayList<>(i.bitmaps.size());\n+            for (Bitmap b : i.bitmaps) {\n+                bitmaps.add(new Bitmap(new AffineTransform(b.transform), b.image));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * @param i must not be used afterwards\n+     *\/\n+    public void merge(GlyphRenderData i) {\n+        if (i.outline != null) {\n+            if (outline == null) outline = i.outline;\n+            else outline.append(i.outline.getPathIterator(null), false);\n+        }\n+        if (i.colorLayers != null) {\n+            if (colorLayers == null) colorLayers = i.colorLayers;\n+            else colorLayers.addAll(i.colorLayers);\n+        }\n+        if (i.bitmaps != null) {\n+            if (bitmaps == null) bitmaps = i.bitmaps;\n+            else bitmaps.addAll(i.bitmaps);\n+        }\n+    }\n+\n+    public void transform(AffineTransform transform) {\n+        if (outline != null) outline.transform(transform);\n+        if (colorLayers != null) {\n+            for (ColorLayer layer : colorLayers) {\n+                layer.outline.transform(transform);\n+            }\n+        }\n+        if (bitmaps != null) {\n+            for (Bitmap bitmap : bitmaps) {\n+                bitmap.transform.preConcatenate(transform);\n+            }\n+        }\n+    }\n+\n+    public void draw(Graphics2D g) {\n+        if (outline != null) g.fill(outline);\n+        if (colorLayers != null) {\n+            Color color = g.getColor();\n+            for (ColorLayer layer : colorLayers) {\n+                g.setColor(layer.color == null ? color : layer.color);\n+                g.fill(layer.outline);\n+            }\n+            g.setColor(color);\n+        }\n+        if (bitmaps != null) {\n+            for (Bitmap bitmap : bitmaps) {\n+                g.drawImage(bitmap.image, bitmap.transform, null);\n+            }\n+        }\n+    }\n+\n+    public record ColorLayer(Color color, GeneralPath outline) {}\n+\n+    public record Bitmap(AffineTransform transform, Image image) {}\n+\n+    \/\/ These methods exist for convenience and are called from native\n+\n+    private void setColorLayersList(int capacity) {\n+        colorLayers = new ArrayList<>(capacity);\n+    }\n+\n+    private void addColorLayers(GeneralPath outline) {\n+        colorLayers.add(new ColorLayer(null, outline));\n+    }\n+\n+    private void addColorLayers(int r, int g, int b, int a, GeneralPath outline) {\n+        colorLayers.add(new ColorLayer(new Color(r, g, b, a), outline));\n+    }\n+\n+    private static ColorModel colorModel(int bits, int r, int g, int b, int a) {\n+        if (Unsafe.getUnsafe().isBigEndian()) {\n+            r = Integer.reverse(r) >>> (32 - bits);\n+            g = Integer.reverse(g) >>> (32 - bits);\n+            b = Integer.reverse(b) >>> (32 - bits);\n+            a = Integer.reverse(a) >>> (32 - bits);\n+        }\n+        return new DirectColorModel(bits, r, g, b, a);\n+    }\n+    private static final ColorModel[] BITMAP_COLOR_MODELS = {\n+            colorModel(32, \/\/ macOS RGBA\n+                    0x000000ff,\n+                    0x0000ff00,\n+                    0x00ff0000,\n+                    0xff000000),\n+            colorModel(32, \/\/ macOS ARGB\n+                    0x0000ff00,\n+                    0x00ff0000,\n+                    0xff000000,\n+                    0x000000ff),\n+            colorModel(32, \/\/ Freetype BGRA\n+                    0x00ff0000,\n+                    0x0000ff00,\n+                    0x000000ff,\n+                    0xff000000)\n+    };\n+    private void addBitmap(double m00, double m10,\n+                           double m01, double m11,\n+                           double m02, double m12,\n+                           int width, int height, int pitch,\n+                           int colorModel, int[] data) {\n+        if (bitmaps == null) bitmaps = new ArrayList<>();\n+        ColorModel color = BITMAP_COLOR_MODELS[colorModel];\n+        BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);\n+        for (int y = 0; y < height; y++) {\n+            for (int x = 0; x < width; x++) {\n+                image.setRGB(x, y, color.getRGB(data[pitch * y + x]));\n+            }\n+        }\n+        bitmaps.add(new Bitmap(new AffineTransform(m00, m10, m01, m11, m02, m12), image));\n+    }\n+}\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphRenderData.java","additions":171,"deletions":171,"binary":false,"changes":342,"status":"modified"}]}