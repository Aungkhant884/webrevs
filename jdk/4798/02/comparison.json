{"files":[{"patch":"@@ -505,1 +505,1 @@\n-        return FontUtilities.isMacOSX;\n+        return FontUtilities.isMacOSX || FontUtilities.isLinux;\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/GlyphList.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,0 +53,9 @@\n+#define  FT26Dot6ToInt(x) (((int)(x)) >> 6)\n+#define  FT26Dot6ToIntCeil(x) (((int)(x - 1 + (1 << 6))) >> 6)\n+#define  IntToFT26Dot6(x) (((FT_Fixed)(x)) << 6)\n+\n+\/\/ Define these manually when building with old Freetype (before 2.5)\n+#if !defined(FT_LOAD_COLOR)\n+#define FT_LOAD_COLOR ( 1L << 20 )\n+#define FT_PIXEL_MODE_BGRA 7\n+#endif\n@@ -87,0 +96,2 @@\n+    int        fixedSizeIndex;\/* -1 for scalable fonts and index inside\n+                               * scalerInfo->face->available_sizes otherwise *\/\n@@ -89,0 +100,7 @@\n+\/* SampledBGRABitmap contains (possibly) downscaled image data\n+ * prepared for sampling when generating transformed bitmap *\/\n+typedef struct SampledBGRABitmap {\n+    unsigned char* data;\n+    int left, top, width, height, rowBytes, xDownscale, yDownscale;\n+} SampledBGRABitmap;\n+\n@@ -576,1 +594,23 @@\n-        errCode = FT_Set_Char_Size(scalerInfo->face, 0, context->ptsz, 72, 72);\n+        int charSize;\n+        if (FT_IS_SCALABLE(scalerInfo->face)) { \/\/ Standard scalable face\n+            context->fixedSizeIndex = -1;\n+            charSize = context->ptsz;\n+        } else { \/\/ Non-scalable face (that should only be bitmap faces)\n+            const int ptsz = context->ptsz;\n+            \/\/ Best size is smallest, but not smaller than requested\n+            int bestSizeIndex = 0;\n+            FT_Pos bestSize = scalerInfo->face->available_sizes[0].size;\n+            int i;\n+            for (i = 1; i < scalerInfo->face->num_fixed_sizes; i++) {\n+                FT_Pos size = scalerInfo->face->available_sizes[i].size;\n+                if ((size >= ptsz && bestSize >= ptsz && size < bestSize) ||\n+                    (size < ptsz && bestSize < ptsz && size > bestSize) ||\n+                    (size >= ptsz && bestSize < ptsz)) {\n+                    bestSizeIndex = i;\n+                    bestSize = size;\n+                }\n+            }\n+            context->fixedSizeIndex = bestSizeIndex;\n+            charSize = (int) bestSize;\n+        }\n+        errCode = FT_Set_Char_Size(scalerInfo->face, 0, charSize, 72, 72);\n@@ -650,30 +690,56 @@\n-    \/*\n-     * See FreeType source code: src\/base\/ftobjs.c ft_recompute_scaled_metrics()\n-     * http:\/\/icedtea.classpath.org\/bugzilla\/show_bug.cgi?id=1659\n-     *\/\n-    \/* ascent *\/\n-    ax = 0;\n-    ay = -(jfloat) (FT_MulFixFloatShift6(\n-                       ((jlong) scalerInfo->face->ascender),\n-                       (jlong) scalerInfo->face->size->metrics.y_scale));\n-    \/* descent *\/\n-    dx = 0;\n-    dy = -(jfloat) (FT_MulFixFloatShift6(\n-                       ((jlong) scalerInfo->face->descender),\n-                       (jlong) scalerInfo->face->size->metrics.y_scale));\n-    \/* baseline *\/\n-    bx = by = 0;\n-\n-    \/* leading *\/\n-    lx = 0;\n-    ly = (jfloat) (FT_MulFixFloatShift6(\n-                      (jlong) scalerInfo->face->height,\n-                      (jlong) scalerInfo->face->size->metrics.y_scale))\n-                  + ay - dy;\n-    \/* max advance *\/\n-    mx = (jfloat) FT26Dot6ToFloat(\n-                     scalerInfo->face->size->metrics.max_advance +\n-                     OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +\n-                     BOLD_MODIFIER(scalerInfo->face->units_per_EM,\n-                             scalerInfo->face->size->metrics.y_scale));\n-    my = 0;\n+    if (context->fixedSizeIndex == -1) {\n+        \/*\n+         * See FreeType source code: src\/base\/ftobjs.c ft_recompute_scaled_metrics()\n+         * http:\/\/icedtea.classpath.org\/bugzilla\/show_bug.cgi?id=1659\n+         *\/\n+        \/* ascent *\/\n+        ax = 0;\n+        ay = -(jfloat) (FT_MulFixFloatShift6(\n+                ((jlong) scalerInfo->face->ascender),\n+                (jlong) scalerInfo->face->size->metrics.y_scale));\n+        \/* descent *\/\n+        dx = 0;\n+        dy = -(jfloat) (FT_MulFixFloatShift6(\n+                ((jlong) scalerInfo->face->descender),\n+                (jlong) scalerInfo->face->size->metrics.y_scale));\n+        \/* baseline *\/\n+        bx = by = 0;\n+\n+        \/* leading *\/\n+        lx = 0;\n+        ly = (jfloat) (FT_MulFixFloatShift6(\n+                (jlong) scalerInfo->face->height,\n+                (jlong) scalerInfo->face->size->metrics.y_scale))\n+             + ay - dy;\n+        \/* max advance *\/\n+        mx = (jfloat) FT26Dot6ToFloat(\n+                scalerInfo->face->size->metrics.max_advance +\n+                OBLIQUE_MODIFIER(scalerInfo->face->size->metrics.height) +\n+                BOLD_MODIFIER(scalerInfo->face->units_per_EM,\n+                              scalerInfo->face->size->metrics.y_scale));\n+        my = 0;\n+    } else {\n+        \/* Just manually scale metrics for non-scalable fonts *\/\n+        FT_Fixed scale = FT_DivFix(context->ptsz,\n+                                   scalerInfo->face->available_sizes[context->fixedSizeIndex].size);\n+        \/* ascent *\/\n+        ax = 0;\n+        ay = -(jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.ascender, scale);\n+        \/* descent *\/\n+        dx = 0;\n+        dy = -(jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.descender, scale);\n+        \/* baseline *\/\n+        bx = by = 0;\n+\n+        \/* leading *\/\n+        lx = 0;\n+        ly = (jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.height, scale) + ay - dy;\n+        \/* max advance *\/\n+        \/* no bold\/italic transformations for non-scalable fonts *\/\n+        mx = (jfloat) FT_MulFixFloatShift6(\n+                scalerInfo->face->size->metrics.max_advance, scale);\n+        my = 0;\n+    }\n@@ -869,0 +935,175 @@\n+\/* Get enclosing axis-aligned rectangle of transformed bitmap bounds *\/\n+static FT_BBox getTransformedBitmapBoundingBox(FT_GlyphSlot ftglyph,\n+                                               const FT_Matrix* transform) {\n+    FT_Vector corners[4];\n+    corners[0].x = corners[2].x = IntToFT26Dot6(ftglyph->bitmap_left);\n+    corners[0].y = corners[1].y = IntToFT26Dot6(ftglyph->bitmap_top);\n+    corners[1].x = corners[3].x = IntToFT26Dot6(ftglyph->bitmap_left +\n+                                                (FT_Int) ftglyph->bitmap.width);\n+    corners[2].y = corners[3].y = IntToFT26Dot6(ftglyph->bitmap_top -\n+                                                (FT_Int) ftglyph->bitmap.rows);\n+\n+    FT_Vector_Transform(corners, transform);\n+    FT_BBox bb = {corners[0].x, corners[0].y, corners[0].x, corners[0].y};\n+    int i;\n+    for (i = 1; i < 4; i++) {\n+        FT_Vector_Transform(corners + i, transform);\n+        if (corners[i].x < bb.xMin) bb.xMin = corners[i].x;\n+        if (corners[i].x > bb.xMax) bb.xMax = corners[i].x;\n+        if (corners[i].y < bb.yMin) bb.yMin = corners[i].y;\n+        if (corners[i].y > bb.yMax) bb.yMax = corners[i].y;\n+    }\n+    bb.xMin = FT26Dot6ToInt(bb.xMin);\n+    bb.yMin = FT26Dot6ToInt(bb.yMin);\n+    bb.xMax = FT26Dot6ToIntCeil(bb.xMax);\n+    bb.yMax = FT26Dot6ToIntCeil(bb.yMax);\n+    return bb;\n+}\n+\n+\/* Generate SampledBGRABitmap, downscaling original image when necessary.\n+ * It may allocate memory for downscaled image,\n+ * so it must be freed with freeSampledBGRABitmap() *\/\n+static SampledBGRABitmap createSampledBGRABitmap(FT_GlyphSlot ftglyph,\n+                                                 int xDownscale,\n+                                                 int yDownscale) {\n+    SampledBGRABitmap sampledBitmap;\n+    if (xDownscale == 1 && yDownscale == 1) { \/\/ No downscale, use original data\n+        sampledBitmap.data = ftglyph->bitmap.buffer;\n+        sampledBitmap.left = ftglyph->bitmap_left;\n+        sampledBitmap.top = ftglyph->bitmap_top;\n+        sampledBitmap.width = (int) ftglyph->bitmap.width;\n+        sampledBitmap.height = (int) ftglyph->bitmap.rows;\n+        sampledBitmap.rowBytes = ftglyph->bitmap.pitch;\n+        sampledBitmap.xDownscale = 1;\n+        sampledBitmap.yDownscale = 1;\n+    } else { \/\/ Generate downscaled bitmap\n+        sampledBitmap.left = ftglyph->bitmap_left \/ xDownscale;\n+        sampledBitmap.top = (ftglyph->bitmap_top + yDownscale - 1) \/ yDownscale;\n+        sampledBitmap.width = (int)\n+                (ftglyph->bitmap_left + (FT_Pos) ftglyph->bitmap.width -\n+                 sampledBitmap.left * xDownscale + xDownscale - 1) \/ xDownscale;\n+        sampledBitmap.height = (int)\n+                (sampledBitmap.top * yDownscale - ftglyph->bitmap_top +\n+                 (FT_Pos) ftglyph->bitmap.rows + yDownscale - 1) \/ yDownscale;\n+        sampledBitmap.data =\n+                malloc(4 * sampledBitmap.width * sampledBitmap.height);\n+        sampledBitmap.rowBytes = sampledBitmap.width * 4;\n+        sampledBitmap.xDownscale = xDownscale;\n+        sampledBitmap.yDownscale = yDownscale;\n+        int xOffset = sampledBitmap.left * xDownscale - ftglyph->bitmap_left;\n+        int yOffset = ftglyph->bitmap_top - sampledBitmap.top * yDownscale;\n+        int x, y;\n+        for (y = 0; y < sampledBitmap.height; y++) {\n+            for (x = 0; x < sampledBitmap.width; x++) {\n+                \/\/ Average pixels\n+                int b = 0, g = 0, r = 0, a = 0;\n+                int xFrom = x * xDownscale + xOffset,\n+                        yFrom = y * yDownscale + yOffset,\n+                        xTo = xFrom + xDownscale,\n+                        yTo = yFrom + yDownscale;\n+                if (xFrom < 0) xFrom = 0;\n+                if (xTo > (int) ftglyph->bitmap.width) xTo = (int) ftglyph->bitmap.width;\n+                if (yFrom < 0) yFrom = 0;\n+                if (yTo > (int) ftglyph->bitmap.rows) yTo = (int) ftglyph->bitmap.rows;\n+                int i, j;\n+                for (j = yFrom; j < yTo; j++) {\n+                    for (i = xFrom; i < xTo; i++) {\n+                        int offset = j * ftglyph->bitmap.pitch + i * 4;\n+                        b += ftglyph->bitmap.buffer[offset + 0];\n+                        g += ftglyph->bitmap.buffer[offset + 1];\n+                        r += ftglyph->bitmap.buffer[offset + 2];\n+                        a += ftglyph->bitmap.buffer[offset + 3];\n+                    }\n+                }\n+                int offset = y * sampledBitmap.rowBytes + x * 4;\n+                sampledBitmap.data[offset + 0] = b \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 1] = g \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 2] = r \/ xDownscale \/ yDownscale;\n+                sampledBitmap.data[offset + 3] = a \/ xDownscale \/ yDownscale;\n+            }\n+        }\n+    }\n+    return sampledBitmap;\n+}\n+static void freeSampledBGRABitmap(SampledBGRABitmap* bitmap) {\n+    if (bitmap->xDownscale != 1 || bitmap->yDownscale != 1) {\n+        free(bitmap->data);\n+    }\n+}\n+\/* Get color (returned via b, g, r and a variables, [0-256))\n+ * from specific pixel in bitmap.\n+ * Returns black-transparent (0,0,0,0) color when sampling out of bounds *\/\n+static void sampleBGRABitmapGlyph(int* b, int* g, int* r, int* a,\n+                                  const SampledBGRABitmap* bitmap,\n+                                  int x, int y) {\n+    int column = x - bitmap->left, row = bitmap->top - y;\n+    if (column < 0 || column >= bitmap->width ||\n+        row < 0 || row >= bitmap->height) {\n+        *b = *g = *r = *a = 0;\n+    } else {\n+        int offset = row * bitmap->rowBytes + column * 4;\n+        *b = bitmap->data[offset + 0];\n+        *g = bitmap->data[offset + 1];\n+        *r = bitmap->data[offset + 2];\n+        *a = bitmap->data[offset + 3];\n+    }\n+}\n+static int bilinearColorMix(int c00, int c10, int c01, int c11,\n+                            float x, float y) {\n+    float top = (float) c00 + x * (float) (c10 - c00);\n+    float bottom = (float) c01 + x * (float) (c11 - c01);\n+    return (int) (top + y * (bottom - top));\n+}\n+\/* Transform ftglyph into pre-allocated glyphInfo with transform matrix *\/\n+static void transformBGRABitmapGlyph(FT_GlyphSlot ftglyph, GlyphInfo* glyphInfo,\n+                                     const FT_Matrix* transform,\n+                                     const FT_BBox* dstBoundingBox,\n+                                     const jboolean linear) {\n+    FT_Matrix inv = *transform;\n+    FT_Matrix_Invert(&inv); \/\/ Transformed -> original bitmap space\n+    int invScaleX = (int) sqrt((double) FTFixedToFloat(FT_MulFix(inv.xx, inv.xx) +\n+                                                       FT_MulFix(inv.xy, inv.xy)));\n+    int invScaleY = (int) sqrt((double) FTFixedToFloat(FT_MulFix(inv.yx, inv.yx) +\n+                                                       FT_MulFix(inv.yy, inv.yy)));\n+    if (invScaleX < 1) invScaleX = 1;\n+    if (invScaleY < 1) invScaleY = 1;\n+    SampledBGRABitmap sampledBitmap =\n+            createSampledBGRABitmap(ftglyph, invScaleX, invScaleY);\n+    int x, y;\n+    for (y = 0; y < glyphInfo->height; y++) {\n+        for (x = 0; x < glyphInfo->width; x++) {\n+            FT_Vector position = {\n+                    IntToFT26Dot6(dstBoundingBox->xMin + x),\n+                    IntToFT26Dot6(dstBoundingBox->yMax - y)\n+            };\n+            FT_Vector_Transform(&position, &inv);\n+            int sampleX = FT26Dot6ToInt(position.x \/ invScaleX),\n+                    sampleY = FT26Dot6ToInt(position.y \/ invScaleY);\n+            int b, g, r, a;\n+            sampleBGRABitmapGlyph(&b, &g, &r, &a,\n+                                  &sampledBitmap, sampleX, sampleY);\n+            if (linear) {\n+                int bX, gX, rX, aX, bY, gY, rY, aY, bXY, gXY, rXY, aXY;\n+                sampleBGRABitmapGlyph(&bX, &gX, &rX, &aX,\n+                                      &sampledBitmap, sampleX + 1, sampleY);\n+                sampleBGRABitmapGlyph(&bY, &gY, &rY, &aY,\n+                                      &sampledBitmap, sampleX, sampleY + 1);\n+                sampleBGRABitmapGlyph(&bXY, &gXY, &rXY, &aXY,\n+                                      &sampledBitmap, sampleX + 1, sampleY + 1);\n+                float fractX = FT26Dot6ToFloat((position.x \/ invScaleX) & 63),\n+                        fractY = FT26Dot6ToFloat((position.y \/ invScaleY) & 63);\n+                b = bilinearColorMix(b, bX, bY, bXY, fractX, fractY);\n+                g = bilinearColorMix(g, gX, gY, gXY, fractX, fractY);\n+                r = bilinearColorMix(r, rX, rY, rXY, fractX, fractY);\n+                a = bilinearColorMix(a, aX, aY, aXY, fractX, fractY);\n+            }\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 0] = b;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 1] = g;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 2] = r;\n+            glyphInfo->image[y*glyphInfo->rowBytes + x * 4 + 3] = a;\n+        }\n+    }\n+    freeSampledBGRABitmap(&sampledBitmap);\n+}\n+\n+\n@@ -930,1 +1171,3 @@\n-    if (!context->useSbits) {\n+    \/* Don't disable bitmaps when working with fixed-size glyph,\n+     * this is most probably a BGRA glyph *\/\n+    if (!context->useSbits && context->fixedSizeIndex == -1) {\n@@ -941,1 +1184,4 @@\n-        target = FT_LOAD_TARGET_MONO;\n+        \/* We disable MONO for non-scalable fonts, because that\n+         * is most probably a colored bitmap glyph *\/\n+        target = context->fixedSizeIndex == -1 ?\n+                 FT_LOAD_TARGET_MONO : FT_LOAD_TARGET_NORMAL;\n@@ -951,0 +1197,4 @@\n+    if (context->fixedSizeIndex != -1) {\n+        \/\/ This is most probably a colored bitmap glyph, so enable COLOR\n+        renderFlags |= FT_LOAD_COLOR;\n+    }\n@@ -961,0 +1211,4 @@\n+    \/* After call to FT_Render_Glyph, glyph format will be changed from\n+     * FT_GLYPH_FORMAT_OUTLINE to FT_GLYPH_FORMAT_BITMAP, so save this value *\/\n+    int outlineGlyph = ftglyph->format == FT_GLYPH_FORMAT_OUTLINE;\n+\n@@ -962,1 +1216,1 @@\n-    if (context->doBold) { \/* if bold style *\/\n+    if (context->doBold && outlineGlyph) { \/* if bold style *\/\n@@ -968,1 +1222,1 @@\n-    if (renderImage && (ftglyph->format == FT_GLYPH_FORMAT_OUTLINE)) {\n+    if (renderImage && outlineGlyph) {\n@@ -983,0 +1237,4 @@\n+    FT_Fixed manualScale = context->fixedSizeIndex == -1 ? ftFixed1 : FT_DivFix(\n+            context->ptsz, scalerInfo->face->available_sizes[context->fixedSizeIndex].size);\n+    FT_Matrix manualTransform;\n+    FT_BBox manualTransformBoundingBox;\n@@ -984,2 +1242,21 @@\n-        width  = (UInt16) ftglyph->bitmap.width;\n-        rowBytes = width;\n+        if (context->fixedSizeIndex == -1) {\n+            width  = (UInt16) ftglyph->bitmap.width;\n+            height = (UInt16) ftglyph->bitmap.rows;\n+        } else {\n+            \/* Fixed size glyph, prepare matrix and\n+             * bounding box for manual transformation *\/\n+            manualTransform.xx = FT_MulFix(context->transform.xx, manualScale);\n+            manualTransform.xy = FT_MulFix(context->transform.xy, manualScale);\n+            manualTransform.yx = FT_MulFix(context->transform.yx, manualScale);\n+            manualTransform.yy = FT_MulFix(context->transform.yy, manualScale);\n+            manualTransformBoundingBox =\n+                    getTransformedBitmapBoundingBox(ftglyph, &manualTransform);\n+            width  = (UInt16) (manualTransformBoundingBox.xMax -\n+                               manualTransformBoundingBox.xMin);\n+            height = (UInt16) (manualTransformBoundingBox.yMax -\n+                               manualTransformBoundingBox.yMin);\n+        }\n+        if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {\n+            glyphInfo = getNullGlyphImage();\n+            return ptr_to_jlong(glyphInfo);\n+        }\n@@ -987,1 +1264,5 @@\n-           rowBytes = PADBYTES + width + PADBYTES;\n+            rowBytes = PADBYTES + width + PADBYTES;\n+        } else if (ftglyph->bitmap.pixel_mode == FT_PIXEL_MODE_BGRA) {\n+            rowBytes = width * 4;\n+        } else {\n+            rowBytes = width;\n@@ -989,6 +1270,1 @@\n-        height = (UInt16) ftglyph->bitmap.rows;\n-            if (width > MAX_GLYPH_DIM || height > MAX_GLYPH_DIM) {\n-              glyphInfo = getNullGlyphImage();\n-              return ptr_to_jlong(glyphInfo);\n-            }\n-     } else {\n+    } else {\n@@ -998,1 +1274,1 @@\n-     }\n+    }\n@@ -1014,2 +1290,7 @@\n-        glyphInfo->topLeftX  = (float)  ftglyph->bitmap_left;\n-        glyphInfo->topLeftY  = (float) -ftglyph->bitmap_top;\n+        if (context->fixedSizeIndex == -1) {\n+            glyphInfo->topLeftX = (float)  ftglyph->bitmap_left;\n+            glyphInfo->topLeftY = (float) -ftglyph->bitmap_top;\n+        } else {\n+            glyphInfo->topLeftX =  (float)  manualTransformBoundingBox.xMin;\n+            glyphInfo->topLeftY =  (float) -manualTransformBoundingBox.yMax;\n+        }\n@@ -1026,1 +1307,1 @@\n-    if (context->fmType == TEXT_FM_ON) {\n+    if (context->fmType == TEXT_FM_ON && outlineGlyph) {\n@@ -1034,1 +1315,2 @@\n-            glyphInfo->advanceX = FT26Dot6ToFloat(ftglyph->advance.x);\n+            glyphInfo->advanceX = FT26Dot6ToFloat(\n+                    FT_MulFix(ftglyph->advance.x, manualScale));\n@@ -1038,1 +1320,2 @@\n-            glyphInfo->advanceY = FT26Dot6ToFloat(-ftglyph->advance.y);\n+            glyphInfo->advanceY = FT26Dot6ToFloat(\n+                    -FT_MulFix(ftglyph->advance.y, manualScale));\n@@ -1040,2 +1323,4 @@\n-            glyphInfo->advanceX = FT26Dot6ToFloat(ftglyph->advance.x);\n-            glyphInfo->advanceY = FT26Dot6ToFloat(-ftglyph->advance.y);\n+            glyphInfo->advanceX = FT26Dot6ToFloat(\n+                    FT_MulFix(ftglyph->advance.x, manualScale));\n+            glyphInfo->advanceY = FT26Dot6ToFloat(\n+                    -FT_MulFix(ftglyph->advance.y, manualScale));\n@@ -1051,0 +1336,1 @@\n+        \/\/4 bytes per pixel for BGRA glyphs\n@@ -1052,14 +1338,5 @@\n-        if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {\n-            \/* convert from 8 pixels per byte to 1 byte per pixel *\/\n-            CopyBW2Grey8(ftglyph->bitmap.buffer,\n-                         ftglyph->bitmap.pitch,\n-                         (void *) glyphInfo->image,\n-                         width,\n-                         width,\n-                         height);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {\n-            \/* byte per pixel to byte per pixel => just copy *\/\n-            memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {\n-            \/* 4 bits per pixel to byte per pixel *\/\n-            CopyGrey4ToGrey8(ftglyph->bitmap.buffer,\n+        if (context->fixedSizeIndex == -1) {\n+            \/\/ Standard format convertation without image transformation\n+            if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_MONO) {\n+                \/* convert from 8 pixels per byte to 1 byte per pixel *\/\n+                CopyBW2Grey8(ftglyph->bitmap.buffer,\n@@ -1071,17 +1348,35 @@\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {\n-            \/* 3 bytes per pixel to 3 bytes per pixel *\/\n-            CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,\n-                                     ftglyph->bitmap.pitch,\n-                                     (void *) (glyphInfo->image+PADBYTES),\n-                                     rowBytes,\n-                                     width,\n-                                     height);\n-        } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {\n-            \/* 3 bytes per pixel to 3 bytes per pixel *\/\n-            CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,\n-                                      ftglyph->bitmap.pitch,\n-                                      (void *) glyphInfo->image,\n-                                      width*3,\n-                                      width,\n-                                      height);\n-            glyphInfo->rowBytes *=3;\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY) {\n+                \/* byte per pixel to byte per pixel => just copy *\/\n+                memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_GRAY4) {\n+                \/* 4 bits per pixel to byte per pixel *\/\n+                CopyGrey4ToGrey8(ftglyph->bitmap.buffer,\n+                                 ftglyph->bitmap.pitch,\n+                                 (void *) glyphInfo->image,\n+                                 width,\n+                                 width,\n+                                 height);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD) {\n+                \/* 3 bytes per pixel to 3 bytes per pixel *\/\n+                CopyFTSubpixelToSubpixel(ftglyph->bitmap.buffer,\n+                                         ftglyph->bitmap.pitch,\n+                                         (void *) (glyphInfo->image+PADBYTES),\n+                                         rowBytes,\n+                                         width,\n+                                         height);\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_LCD_V) {\n+                \/* 3 bytes per pixel to 3 bytes per pixel *\/\n+                CopyFTSubpixelVToSubpixel(ftglyph->bitmap.buffer,\n+                                          ftglyph->bitmap.pitch,\n+                                          (void *) glyphInfo->image,\n+                                          width*3,\n+                                          width,\n+                                          height);\n+                glyphInfo->rowBytes *=3;\n+            } else if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_BGRA) {\n+                \/* 4 bytes per pixel to 4 bytes per pixel => just copy *\/\n+                memcpy(glyphInfo->image, ftglyph->bitmap.buffer, imageSize);\n+            } else {\n+                free(glyphInfo);\n+                glyphInfo = getNullGlyphImage();\n+            }\n@@ -1089,2 +1384,11 @@\n-            free(glyphInfo);\n-            glyphInfo = getNullGlyphImage();\n+            \/\/ Here we have to transform image manually\n+            \/\/ Only BGRA format is supported (should be enough)\n+            if (ftglyph->bitmap.pixel_mode ==  FT_PIXEL_MODE_BGRA) {\n+                transformBGRABitmapGlyph(ftglyph, glyphInfo,\n+                                         &manualTransform,\n+                                         &manualTransformBoundingBox,\n+                                         context->aaType != TEXT_AA_OFF);\n+            } else {\n+                free(glyphInfo);\n+                glyphInfo = getNullGlyphImage();\n+            }\n","filename":"src\/java.desktop\/share\/native\/libfontmanager\/freetypeScaler.c","additions":389,"deletions":85,"binary":false,"changes":474,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    native void doDrawGlyphList(long dstData, long xgc,\n+    native boolean doDrawGlyphList(long dstData, long xgc,\n@@ -81,1 +81,17 @@\n-            doDrawGlyphList(x11sd.getNativeOps(), xgc, clip, gl);\n+            boolean allGlyphsRendered = doDrawGlyphList(x11sd.getNativeOps(), xgc, clip, gl);\n+            \/\/ There are some color glyphs, which we couldn't draw\n+            if (!allGlyphsRendered) {\n+                gl.startGlyphIteration();\n+                for (int i = 0; i < gl.getNumGlyphs(); i++) {\n+                    if (gl.isColorGlyph(i)) {\n+                        int end;\n+                        for (end = i + 1; end < gl.getNumGlyphs(); end++) {\n+                            if (!gl.isColorGlyph(end)) break;\n+                        }\n+                        sg2d.loops.drawGlyphListColorLoop.\n+                                DrawGlyphListColor(sg2d, sg2d.surfaceData,\n+                                        gl, i, end);\n+                        i = end - 1;\n+                    } else gl.setGlyphIndex(i);\n+                }\n+            }\n@@ -92,1 +108,1 @@\n-        void doDrawGlyphList(long dstData, long xgc,\n+        boolean doDrawGlyphList(long dstData, long xgc,\n@@ -96,1 +112,1 @@\n-            super.doDrawGlyphList(dstData, xgc, clip, gl);\n+            return super.doDrawGlyphList(dstData, xgc, clip, gl);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/X11TextRenderer.java","additions":20,"deletions":4,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+    \/**\n+     * BGRA glyphs are rendered as images\n+     * and therefore don't belong to any glyph set\n+     *\/\n+    public static final int BGRA_GLYPH_SET = -1;\n+\n@@ -50,0 +56,1 @@\n+    final EnumMap<XRGlyphCacheEntry.Type, Integer> glyphSetsByType;\n@@ -66,0 +73,5 @@\n+        glyphSetsByType = new EnumMap<>(XRGlyphCacheEntry.Type.class);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.GRAYSCALE, grayGlyphSet);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.LCD, lcdGlyphSet);\n+        glyphSetsByType.put(XRGlyphCacheEntry.Type.BGRA, BGRA_GLYPH_SET);\n+\n@@ -107,1 +119,1 @@\n-    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList) {\n+    public XRGlyphCacheEntry[] cacheGlyphs(GlyphList glyphList, int parentXid) {\n@@ -117,1 +129,2 @@\n-            if (imgPtrs[i] == 0L) {\n+            if (imgPtrs[i] == 0L ||\n+                imgPtrs[i] == StrikeCache.invisibleGlyphPtr) {\n@@ -127,1 +140,1 @@\n-                    uncachedGlyphs = new ArrayList<XRGlyphCacheEntry>();\n+                    uncachedGlyphs = new ArrayList<>();\n@@ -137,1 +150,1 @@\n-            uploadGlyphs(entries, uncachedGlyphs, glyphList, null);\n+            uploadGlyphs(entries, uncachedGlyphs, glyphList, parentXid);\n@@ -143,1 +156,3 @@\n-    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs, ArrayList<XRGlyphCacheEntry> uncachedGlyphs, GlyphList gl, int[] glIndices) {\n+    protected void uploadGlyphs(XRGlyphCacheEntry[] glyphs,\n+                                ArrayList<XRGlyphCacheEntry> uncachedGlyphs,\n+                                GlyphList gl, int parentXid) {\n@@ -152,4 +167,13 @@\n-        boolean containsLCDGlyphs = containsLCDGlyphs(uncachedGlyphs);\n-        List<XRGlyphCacheEntry>[] seperatedGlyphList = seperateGlyphTypes(uncachedGlyphs, containsLCDGlyphs);\n-        List<XRGlyphCacheEntry> grayGlyphList = seperatedGlyphList[0];\n-        List<XRGlyphCacheEntry> lcdGlyphList = seperatedGlyphList[1];\n+        EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>>\n+                glyphListsByType = separateGlyphTypes(uncachedGlyphs);\n+\n+        uploadGlyphs(grayGlyphSet, gl,\n+                     glyphListsByType.get(XRGlyphCacheEntry.Type.GRAYSCALE));\n+        uploadGlyphs(lcdGlyphSet, gl,\n+                     glyphListsByType.get(XRGlyphCacheEntry.Type.LCD));\n+        List<XRGlyphCacheEntry> bgraGlyphs = glyphListsByType.getOrDefault(\n+                XRGlyphCacheEntry.Type.BGRA, List.of());\n+        if (!bgraGlyphs.isEmpty()) {\n+            con.addBGRAGlyphImages(parentXid, bgraGlyphs);\n+        }\n+    }\n@@ -157,0 +181,5 @@\n+    private void uploadGlyphs(int glyphSet, GlyphList glyphList,\n+                              List<XRGlyphCacheEntry> cacheEntries) {\n+        if (cacheEntries == null || cacheEntries.isEmpty()) {\n+            return;\n+        }\n@@ -163,6 +192,2 @@\n-            if (grayGlyphList != null && grayGlyphList.size() > 0) {\n-                con.XRenderAddGlyphs(grayGlyphSet, gl, grayGlyphList, generateGlyphImageStream(grayGlyphList));\n-            }\n-            if (lcdGlyphList != null && lcdGlyphList.size() > 0) {\n-                con.XRenderAddGlyphs(lcdGlyphSet, gl, lcdGlyphList, generateGlyphImageStream(lcdGlyphList));\n-            }\n+            con.XRenderAddGlyphs(glyphSet, glyphList, cacheEntries,\n+                    generateGlyphImageStream(cacheEntries));\n@@ -170,1 +195,1 @@\n-            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<XRGlyphCacheEntry>(1);\n+            ArrayList<XRGlyphCacheEntry> tmpList = new ArrayList<>(1);\n@@ -172,2 +197,1 @@\n-\n-            for (XRGlyphCacheEntry entry : uncachedGlyphs) {\n+            for (XRGlyphCacheEntry entry : cacheEntries) {\n@@ -175,6 +199,2 @@\n-\n-                if (entry.getGlyphSet() == grayGlyphSet) {\n-                    con.XRenderAddGlyphs(grayGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n-                } else {\n-                    con.XRenderAddGlyphs(lcdGlyphSet, gl, tmpList, generateGlyphImageStream(tmpList));\n-                }\n+                con.XRenderAddGlyphs(glyphSet, glyphList, tmpList,\n+                                     generateGlyphImageStream(tmpList));\n@@ -186,2 +206,2 @@\n-     * Seperates lcd and grayscale glyphs queued for upload, and sets the\n-     * appropriate glyphset for the cache entries.\n+     * Separates bgra, lcd and grayscale glyphs queued for upload, and sets the\n+     * appropriate glyph set for the cache entries.\n@@ -189,4 +209,4 @@\n-    protected List<XRGlyphCacheEntry>[] seperateGlyphTypes(List<XRGlyphCacheEntry> glyphList, boolean containsLCDGlyphs) {\n-        ArrayList<XRGlyphCacheEntry> lcdGlyphs = null;\n-        ArrayList<XRGlyphCacheEntry> grayGlyphs = null;\n-\n+    protected EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>>\n+            separateGlyphTypes(List<XRGlyphCacheEntry> glyphList) {\n+        EnumMap<XRGlyphCacheEntry.Type, List<XRGlyphCacheEntry>> glyphLists =\n+                new EnumMap<>(XRGlyphCacheEntry.Type.class);\n@@ -194,13 +214,4 @@\n-            if (cacheEntry.isGrayscale(containsLCDGlyphs)) {\n-                if (grayGlyphs == null) {\n-                    grayGlyphs = new ArrayList<>(glyphList.size());\n-                }\n-                cacheEntry.setGlyphSet(grayGlyphSet);\n-                grayGlyphs.add(cacheEntry);\n-            } else {\n-                if (lcdGlyphs == null) {\n-                    lcdGlyphs = new ArrayList<>(glyphList.size());\n-                }\n-                cacheEntry.setGlyphSet(lcdGlyphSet);\n-                lcdGlyphs.add(cacheEntry);\n-            }\n+            XRGlyphCacheEntry.Type cacheEntryType = cacheEntry.getType();\n+            cacheEntry.setGlyphSet(glyphSetsByType.get(cacheEntryType));\n+            glyphLists.computeIfAbsent(cacheEntryType, ignore ->\n+                    new ArrayList<>(glyphList.size())).add(cacheEntry);\n@@ -208,5 +219,1 @@\n-        \/\/ Arrays and generics don't play well together\n-        @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n-        List<XRGlyphCacheEntry>[] tmp =\n-            (List<XRGlyphCacheEntry>[]) (new List[] { grayGlyphs, lcdGlyphs });\n-        return tmp;\n+        return glyphLists;\n@@ -229,14 +236,1 @@\n-    protected boolean containsLCDGlyphs(List<XRGlyphCacheEntry> entries) {\n-        boolean containsLCDGlyphs = false;\n-\n-        for (XRGlyphCacheEntry entry : entries) {\n-            containsLCDGlyphs = !(entry.getSourceRowBytes() == entry.getWidth());\n-\n-            if (containsLCDGlyphs) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    protected void clearCache(XRGlyphCacheEntry[] glyps) {\n+    protected void clearCache(XRGlyphCacheEntry[] glyphs) {\n@@ -255,2 +249,4 @@\n-        for (XRGlyphCacheEntry glyph : glyps) {\n-            glyph.setPinned();\n+        for (XRGlyphCacheEntry glyph : glyphs) {\n+            if (glyph != null) {\n+                glyph.setPinned();\n+            }\n@@ -271,2 +267,4 @@\n-        for (XRGlyphCacheEntry glyph : glyps) {\n-            glyph.setUnpinned();\n+        for (XRGlyphCacheEntry glyph : glyphs) {\n+            if (glyph != null) {\n+                glyph.setUnpinned();\n+            }\n@@ -281,0 +279,2 @@\n+        long[] removedBGRAGlyphPtrs = null;\n+        int removedBGRAGlyphPtrsCount = 0;\n@@ -293,1 +293,1 @@\n-            } else {\n+            } else if (entry.getGlyphSet() == lcdGlyphSet) {\n@@ -295,0 +295,11 @@\n+            } else if (entry.getGlyphSet() == BGRA_GLYPH_SET) {\n+                if (removedBGRAGlyphPtrs == null) {\n+                    removedBGRAGlyphPtrs = new long[10];\n+                } else if (removedBGRAGlyphPtrsCount >= removedBGRAGlyphPtrs.length) {\n+                    long[] n = new long[removedBGRAGlyphPtrs.length * 2];\n+                    System.arraycopy(removedBGRAGlyphPtrs, 0, n, 0,\n+                                     removedBGRAGlyphPtrs.length);\n+                    removedBGRAGlyphPtrs = n;\n+                }\n+                removedBGRAGlyphPtrs[removedBGRAGlyphPtrsCount++] =\n+                        entry.getBgraGlyphInfoPtr();\n@@ -307,0 +318,5 @@\n+\n+        if (removedBGRAGlyphPtrsCount > 0) {\n+            con.freeBGRAGlyphImages(removedBGRAGlyphPtrs,\n+                                    removedBGRAGlyphPtrsCount);\n+        }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCache.java","additions":83,"deletions":67,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-    long glyphInfoPtr;\n+    long glyphInfoPtr, bgraGlyphInfoPtr;\n@@ -50,1 +50,1 @@\n-        \/* TODO: Does it make sence to cache results? *\/\n+        \/* TODO: Does it make sense to cache results? *\/\n@@ -55,0 +55,8 @@\n+    public long getBgraGlyphInfoPtr() {\n+        return bgraGlyphInfoPtr;\n+    }\n+\n+    public void setBgraGlyphInfoPtr(long bgraGlyphInfoPtr) {\n+        this.bgraGlyphInfoPtr = bgraGlyphInfoPtr;\n+    }\n+\n@@ -135,1 +143,1 @@\n-        int paddedWidth = getPaddedWidth(uploadAsLCD);\n+        int paddedWidth = getPaddedWidth();\n@@ -137,1 +145,1 @@\n-        if (!uploadAsLCD) {\n+        if (getType() == Type.GRAYSCALE) {\n@@ -179,2 +187,8 @@\n-    public boolean isGrayscale(boolean listContainsLCDGlyphs) {\n-        return getSourceRowBytes() == getWidth() && !(getWidth() == 0 && getHeight() == 0 && listContainsLCDGlyphs);\n+    public Type getType() {\n+        int rowBytes = getSourceRowBytes();\n+        int width = getWidth();\n+        \/\/ 0x0 -> LCD is just for backward compatibiity\n+        if (width == 0 || getHeight() == 0) return Type.LCD;\n+        if (width == rowBytes) return Type.GRAYSCALE;\n+        if (width * 4 == rowBytes) return Type.BGRA;\n+        return Type.LCD;\n@@ -183,3 +197,3 @@\n-    public int getPaddedWidth(boolean listContainsLCDGlyphs) {\n-        int width = getWidth();\n-        return isGrayscale(listContainsLCDGlyphs) ? (int) Math.ceil(width \/ 4.0) * 4 : width;\n+    public int getPaddedWidth() {\n+        return getType() == Type.GRAYSCALE ?\n+                (int) Math.ceil(getWidth() \/ 4.0) * 4 : getWidth();\n@@ -188,3 +202,2 @@\n-    public int getDestinationRowBytes(boolean listContainsLCDGlyphs) {\n-        boolean grayscale = isGrayscale(listContainsLCDGlyphs);\n-        return grayscale ? getPaddedWidth(grayscale) : getWidth() * 4;\n+    public int getDestinationRowBytes() {\n+        return getType() == Type.GRAYSCALE ? getPaddedWidth() : getWidth() * 4;\n@@ -193,2 +206,2 @@\n-    public int getGlyphDataLenth(boolean listContainsLCDGlyphs) {\n-        return getDestinationRowBytes(listContainsLCDGlyphs) * getHeight();\n+    public int getGlyphDataLenth() {\n+        return getDestinationRowBytes() * getHeight();\n@@ -220,0 +233,9 @@\n+\n+\n+    public enum Type {\n+        GRAYSCALE,\n+        LCD,\n+        BGRA\n+    }\n+\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRGlyphCacheEntry.java","additions":36,"deletions":14,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -81,1 +81,2 @@\n-            XRGlyphCacheEntry[] cachedGlyphs = glyphCache.cacheGlyphs(gl);\n+            XRGlyphCacheEntry[] cachedGlyphs =\n+                    glyphCache.cacheGlyphs(gl, x11sd.getXid());\n@@ -83,1 +84,3 @@\n-            int activeGlyphSet = cachedGlyphs[0].getGlyphSet();\n+            \/* Do not initialize it to cachedGlyphs[0].getGlyphSet(),\n+             * as it may cause NPE *\/\n+            int activeGlyphSet = 0;\n@@ -88,0 +91,4 @@\n+            \/* Accumulated advances are used to adjust glyph positions\n+             * when mixing BGRA and standard glyphs as they have\n+             * completely different methods of rendering. *\/\n+            float accumulatedXEltAdvanceX = 0, accumulatedXEltAdvanceY = 0;\n@@ -95,1 +102,0 @@\n-                eltList.getGlyphs().addInt(cacheEntry.getGlyphID());\n@@ -98,0 +104,11 @@\n+                if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                    \/* BGRA glyphs store pointers to BGRAGlyphInfo\n+                     * struct instead of glyph index *\/\n+                    eltList.getGlyphs().addInt(\n+                            (int) (cacheEntry.getBgraGlyphInfoPtr() >> 32));\n+                    eltList.getGlyphs().addInt(\n+                            (int) cacheEntry.getBgraGlyphInfoPtr());\n+                } else {\n+                    eltList.getGlyphs().addInt(cacheEntry.getGlyphID());\n+                }\n+\n@@ -106,1 +123,5 @@\n-                        || eltList.getCharCnt(eltIndex) == MAX_ELT_GLYPH_COUNT) {\n+                        \/* We don't care about number of glyphs when\n+                         * rendering BGRA glyphs because they are not rendered\n+                         * using XRenderCompositeText. *\/\n+                        || (glyphSet != XRGlyphCache.BGRA_GLYPH_SET &&\n+                            eltList.getCharCnt(eltIndex) == MAX_ELT_GLYPH_COUNT)) {\n@@ -139,7 +160,14 @@\n-                    \/\/ Offset of the current glyph is the difference\n-                    \/\/ to the last glyph and this one\n-                    eltList.setXOff(eltIndex, (posX - oldPosX));\n-                    eltList.setYOff(eltIndex, (posY - oldPosY));\n-\n-                    oldPosX = posX;\n-                    oldPosY = posY;\n+                    if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                        \/\/ BGRA glyphs use absolute positions\n+                        eltList.setXOff(eltIndex,\n+                                        (int) (accumulatedXEltAdvanceX + posX));\n+                        eltList.setYOff(eltIndex,\n+                                        (int) (accumulatedXEltAdvanceY + posY));\n+                    } else {\n+                        \/\/ Offset of the current glyph is the difference\n+                        \/\/ to the last glyph and this one\n+                        eltList.setXOff(eltIndex, (posX - oldPosX));\n+                        eltList.setYOff(eltIndex, (posY - oldPosY));\n+                        oldPosX = posX;\n+                        oldPosY = posY;\n+                    }\n@@ -150,0 +178,7 @@\n+                if (glyphSet == XRGlyphCache.BGRA_GLYPH_SET) {\n+                    advX += cacheEntry.getXAdvance();\n+                    advY += cacheEntry.getYAdvance();\n+                } else {\n+                    accumulatedXEltAdvanceX += cacheEntry.getXAdvance();\n+                    accumulatedXEltAdvanceY += cacheEntry.getYAdvance();\n+                }\n","filename":"src\/java.desktop\/unix\/classes\/sun\/font\/XRTextRenderer.java","additions":46,"deletions":11,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -97,0 +97,5 @@\n+    public void addBGRAGlyphImages(int drawable,\n+                                   List<XRGlyphCacheEntry> cacheEntries);\n+\n+    public void freeBGRAGlyphImages(long[] glyphInfoPointers, int glyphCount);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRBackend.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -253,0 +253,20 @@\n+    public void addBGRAGlyphImages(int drawable,\n+                                   List<XRGlyphCacheEntry> cacheEntries) {\n+        long[] glyphInfoPtrs = getGlyphInfoPtrs(cacheEntries);\n+        addBGRAGlyphImagesNative(drawable, glyphInfoPtrs,\n+                                 glyphInfoPtrs.length, FMTPTR_ARGB32);\n+        \/* addBGRAGlyphImagesNative replaced values in\n+         * glyphInfoPtrs with pointers to BGRAGlyphInfo structs, save them *\/\n+        int i = 0;\n+        for (XRGlyphCacheEntry cacheEntry : cacheEntries) {\n+            cacheEntry.setBgraGlyphInfoPtr(glyphInfoPtrs[i++]);\n+        }\n+    }\n+\n+    private native void addBGRAGlyphImagesNative(int drawable,\n+                                                 long[] glyphInfoPtrs,\n+                                                 int glyphCnt, long format32);\n+\n+    public native void freeBGRAGlyphImages(long[] glyphInfoPointers,\n+                                           int glyphCount);\n+\n","filename":"src\/java.desktop\/unix\/classes\/sun\/java2d\/xr\/XRBackendNative.java","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                       jint clipRight, jint clipBottom)\n+                       jint clipRight, jint clipBottom, jboolean *allGlyphsRendered)\n@@ -127,1 +127,1 @@\n-        rowBytes = glyphs[glyphCounter].width;\n+        rowBytes = glyphs[glyphCounter].rowBytes;\n@@ -133,0 +133,5 @@\n+        if ((int) rowBytes == width * 4) { \/\/ Skip colored glyphs\n+            *allGlyphsRendered = JNI_FALSE;\n+            continue;\n+        }\n+\n@@ -209,1 +214,1 @@\n-                 SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs)\n+                 SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs, jboolean *allGlyphsRendered)\n@@ -262,1 +267,1 @@\n-                       cx1, cy1, cx2, cy2);\n+                       cx1, cy1, cx2, cy2, allGlyphsRendered);\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11TextRenderer_md.c","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -62,0 +62,8 @@\n+\/* BGRA glyph that is rendered using XRenderComposite instead of\n+ * XRenderCompositeText32. Used for colored glyphs *\/\n+typedef struct _BGRAGlyphInfo {\n+    GlyphInfo* glyphInfo;\n+    Pixmap pixmap;\n+    Picture picture;\n+} BGRAGlyphInfo;\n+\n@@ -882,0 +890,68 @@\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_xr_XRBackendNative_addBGRAGlyphImagesNative\n+        (JNIEnv* env, jclass clazz, jint drawable,\n+         jlongArray javaGlyphInfoPointersArray, jint glyphCnt, jlong format32) {\n+    jlong* glyphInfoPointers;\n+    if ((glyphInfoPointers = (jlong *)\n+        (*env)->GetPrimitiveArrayCritical(env, javaGlyphInfoPointersArray, NULL)) == NULL) {\n+        return;\n+    }\n+\n+    XRenderPictFormat* format = (XRenderPictFormat*) jlong_to_ptr(format32);\n+    XRenderPictureAttributes pictureAttributes;\n+\n+    int i;\n+    for (i = 0; i < glyphCnt; i++) {\n+        GlyphInfo* glyphInfo = (GlyphInfo*) jlong_to_ptr(glyphInfoPointers[i]);\n+\n+        Pixmap pixmap = XCreatePixmap(awt_display, (Drawable) drawable,\n+                                      glyphInfo->width, glyphInfo->height, 32);\n+        GC gc = XCreateGC(awt_display, (Drawable) pixmap, 0L, NULL);\n+        XImage* image = XCreateImage(awt_display, NULL, 32, ZPixmap, 0,\n+                                     (char*) glyphInfo->image,\n+                                     glyphInfo->width, glyphInfo->height,\n+                                     32, glyphInfo->rowBytes);\n+        XPutImage(awt_display, pixmap, gc, image, 0, 0, 0, 0,\n+                  glyphInfo->width, glyphInfo->height);\n+        image->data = NULL;\n+        XDestroyImage(image);\n+        XFreeGC(awt_display, gc);\n+        Picture picture = XRenderCreatePicture(awt_display, pixmap, format,\n+                                               0, &pictureAttributes);\n+\n+        BGRAGlyphInfo* bgraGlyphInfo =\n+                (BGRAGlyphInfo*) malloc(sizeof(BGRAGlyphInfo));\n+        bgraGlyphInfo->glyphInfo = glyphInfo;\n+        bgraGlyphInfo->pixmap = pixmap;\n+        bgraGlyphInfo->picture = picture;\n+\n+        glyphInfoPointers[i] = (jlong) bgraGlyphInfo;\n+    }\n+\n+    (*env)->ReleasePrimitiveArrayCritical(env, javaGlyphInfoPointersArray,\n+                                          glyphInfoPointers, JNI_ABORT);\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_sun_java2d_xr_XRBackendNative_freeBGRAGlyphImages\n+        (JNIEnv* env, jclass clazz,\n+         jlongArray javaGlyphInfoPointersArray, jint glyphCnt) {\n+    jlong* glyphInfoPointers;\n+    if ((glyphInfoPointers = (jlong *)\n+        (*env)->GetPrimitiveArrayCritical(env, javaGlyphInfoPointersArray, NULL)) == NULL) {\n+        return;\n+    }\n+\n+    int i;\n+    for (i = 0; i < glyphCnt; i++) {\n+        BGRAGlyphInfo* bgraGlyphInfo =\n+                (BGRAGlyphInfo*) jlong_to_ptr(glyphInfoPointers[i]);\n+        XRenderFreePicture(awt_display, bgraGlyphInfo->picture);\n+        XFreePixmap(awt_display, bgraGlyphInfo->pixmap);\n+        free(bgraGlyphInfo);\n+    }\n+\n+    (*env)->ReleasePrimitiveArrayCritical(env, javaGlyphInfoPointersArray,\n+                                          glyphInfoPointers, JNI_ABORT);\n+}\n+\n@@ -959,8 +1035,35 @@\n-    for (i=0; i < eltCnt; i++) {\n-      xelts[i].nchars = elts[i*4 + 0];\n-      xelts[i].xOff = elts[i*4 + 1];\n-      xelts[i].yOff = elts[i*4 + 2];\n-      xelts[i].glyphset = (GlyphSet) elts[i*4 + 3];\n-      xelts[i].chars = &xids[charCnt];\n-\n-      charCnt += xelts[i].nchars;\n+    int totalXElts = 0;\n+    for (i = 0; i < eltCnt; i++) {\n+        int nchars = elts[i*4];\n+        int xOff = elts[i*4 + 1];\n+        int yOff = elts[i*4 + 2];\n+        int glyphset = (GlyphSet) elts[i*4 + 3];\n+        if (glyphset == -1) { \/\/ BGRA glyph, render as image\n+            float x = (float) xOff;\n+            float y = (float) yOff;\n+            int ch;\n+            for (ch = 0; ch < nchars; ch++) {\n+                BGRAGlyphInfo* bgraGlyphInfo = (BGRAGlyphInfo*)\n+                        (((jlong) xids[charCnt + ch * 2] << 32) |\n+                        (((jlong) xids[charCnt + ch * 2 + 1]) & 0xFFFFFFFF));\n+                GlyphInfo* glyph = bgraGlyphInfo->glyphInfo;\n+                XRenderComposite(awt_display, PictOpOver,\n+                                 bgraGlyphInfo->picture,\n+                                 (Picture) 0, (Picture) dst,\n+                                 0, 0, 0, 0,\n+                                 (int) (x + glyph->topLeftX),\n+                                 (int) (y + glyph->topLeftY),\n+                                 glyph->width, glyph->height);\n+                x += glyph->advanceX;\n+                y += glyph->advanceY;\n+            }\n+            charCnt += nchars * 2;\n+        } else { \/\/ Standard XRender glyph\n+            xelts[totalXElts].nchars = nchars;\n+            xelts[totalXElts].xOff = xOff;\n+            xelts[totalXElts].yOff = yOff;\n+            xelts[totalXElts].glyphset = glyphset;\n+            xelts[totalXElts].chars = &xids[charCnt];\n+            charCnt += nchars;\n+            totalXElts++;\n+        }\n@@ -969,3 +1072,5 @@\n-    XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n-                           (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n-                            sx, sy, 0, 0, xelts, eltCnt);\n+    if (totalXElts > 0) {\n+        XRenderCompositeText32(awt_display, op, (Picture) src, (Picture) dst,\n+                               (XRenderPictFormat *) jlong_to_ptr(maskFmt),\n+                               sx, sy, 0, 0, xelts, totalXElts);\n+    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/java2d\/x11\/XRBackendNative.c","additions":116,"deletions":11,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n- SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs);\n+ SurfaceDataBounds *bounds, ImageRef *glyphs, jint totalGlyphs, jboolean *allGlyphsRendered);\n@@ -53,1 +53,1 @@\n- * Signature: (Lsun\/java2d\/SurfaceData;Ljava\/awt\/Rectangle;ILsun\/font\/GlyphList;J)V\n+ * Signature: (Lsun\/java2d\/SurfaceData;Ljava\/awt\/Rectangle;ILsun\/font\/GlyphList;J)Z\n@@ -55,1 +55,1 @@\n-JNIEXPORT void JNICALL Java_sun_font_X11TextRenderer_doDrawGlyphList\n+JNIEXPORT jboolean JNICALL Java_sun_font_X11TextRenderer_doDrawGlyphList\n@@ -67,1 +67,1 @@\n-        return;\n+        return JNI_TRUE;\n@@ -71,1 +71,1 @@\n-        return;\n+        return JNI_TRUE;\n@@ -73,0 +73,1 @@\n+    jboolean allGlyphsRendered = JNI_TRUE;\n@@ -74,1 +75,1 @@\n-                     &bounds, gbv->glyphs, gbv->numGlyphs);\n+                     &bounds, gbv->glyphs, gbv->numGlyphs, &allGlyphsRendered);\n@@ -76,0 +77,1 @@\n+    return allGlyphsRendered;\n","filename":"src\/java.desktop\/unix\/native\/libfontmanager\/X11TextRenderer.c","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8263583\n+ * @bug 8263583 8269806\n@@ -31,2 +31,2 @@\n- * @requires (os.family == \"mac\")\n- * @run main\/othervm -Dsun.java2d.uiScale=1 MacEmoji\n+ * @requires (os.family == \"mac\" | os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.uiScale=1 Emoji\n@@ -40,1 +40,1 @@\n-public class MacEmoji {\n+public class Emoji {\n@@ -43,0 +43,3 @@\n+    private static final Font FONT = new Font(\n+            System.getProperty(\"os.name\").toLowerCase().contains(\"linux\") ?\n+                    \"Noto Color Emoji\" : Font.DIALOG, Font.PLAIN, 12);\n@@ -104,1 +107,1 @@\n-        g.setFont(new Font(Font.DIALOG, Font.PLAIN, 12));\n+        g.setFont(FONT);\n","filename":"test\/jdk\/java\/awt\/font\/Emoji.java","additions":8,"deletions":5,"binary":false,"changes":13,"previous_filename":"test\/jdk\/java\/awt\/font\/MacEmoji.java","status":"renamed"}]}