{"files":[{"patch":"@@ -1,285 +1,285 @@\n-\/*\r\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\r\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\r\n- *\r\n- * This code is free software; you can redistribute it and\/or modify it\r\n- * under the terms of the GNU General Public License version 2 only, as\r\n- * published by the Free Software Foundation.\r\n- *\r\n- * This code is distributed in the hope that it will be useful, but WITHOUT\r\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\r\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\r\n- * version 2 for more details (a copy is included in the LICENSE file that\r\n- * accompanied this code).\r\n- *\r\n- * You should have received a copy of the GNU General Public License version\r\n- * 2 along with this work; if not, write to the Free Software Foundation,\r\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\r\n- *\r\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\r\n- * or visit www.oracle.com if you need additional information or have any\r\n- * questions.\r\n- *\/\r\n-\r\n-package sun.font;\r\n-\r\n-import java.awt.*;\r\n-import java.awt.geom.GeneralPath;\r\n-import java.awt.geom.Point2D;\r\n-import java.awt.geom.Rectangle2D;\r\n-\r\n-public class EmojiFont extends Font2D {\r\n-\r\n-    private Font2D symbol, emoji;\r\n-    private volatile boolean init;\r\n-\r\n-    public EmojiFont() {\r\n-        handle = new Font2DHandle(this);\r\n-        fullName = \"Emoji.plain\";\r\n-        familyName = \"Emoji\";\r\n-        fontRank = JRE_RANK;\r\n-        style = Font.PLAIN;\r\n-    }\r\n-\r\n-    private void init() {\r\n-        if (!init) {\r\n-            synchronized (this) {\r\n-                if (!init) {\r\n-                    SunFontManager fm = SunFontManager.getInstance();\r\n-                    symbol = fm.findFont2D(\"Segoe UI Symbol\", Font.PLAIN, FontManager.NO_FALLBACK);\r\n-                    emoji = fm.findFont2D(\"Segoe UI Emoji\", Font.PLAIN, FontManager.NO_FALLBACK);\r\n-                    init = true;\r\n-                }\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void getStyleMetrics(float pointSize, float[] metrics, int offset) {\r\n-        init();\r\n-        if (emoji != null) {\r\n-            emoji.getStyleMetrics(pointSize, metrics, offset);\r\n-        } else if (symbol != null) {\r\n-            symbol.getStyleMetrics(pointSize, metrics, offset);\r\n-        } else {\r\n-            super.getStyleMetrics(pointSize, metrics, offset);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    FontStrike createStrike(FontStrikeDesc desc) {\r\n-        init();\r\n-        return new Strike(desc);\r\n-    }\r\n-\r\n-    @Override\r\n-    protected int getValidatedGlyphCode(int glyphCode) {\r\n-        init();\r\n-        Font2D slot = (glyphCode & 1) == 1 ? emoji : symbol;\r\n-        if (emoji != null) {\r\n-            int result = slot.getValidatedGlyphCode(glyphCode >>> 1);\r\n-            if (result != slot.getMissingGlyphCode()) {\r\n-                return glyphCode;\r\n-            }\r\n-        }\r\n-        return getMissingGlyphCode();\r\n-    }\r\n-\r\n-    @Override\r\n-    CharToGlyphMapper getMapper() {\r\n-        init();\r\n-        if (mapper == null) {\r\n-            mapper = new Mapper();\r\n-        }\r\n-        return mapper;\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean hasSupplementaryChars() {\r\n-        init();\r\n-        return (emoji != null && emoji.hasSupplementaryChars()) ||\r\n-                (symbol != null && symbol.hasSupplementaryChars());\r\n-    }\r\n-\r\n-    @Override\r\n-    public int getNumGlyphs() {\r\n-        init();\r\n-        return Math.max(emoji != null ? emoji.getNumGlyphs() : 0,\r\n-                symbol != null ? symbol.getNumGlyphs() : 0);\r\n-    }\r\n-\r\n-    @Override\r\n-    public boolean canDisplay(int cp) {\r\n-        return (Character.isEmoji(cp) || Character.isEmojiComponent(cp)) && getMapper().canDisplay(cp);\r\n-    }\r\n-\r\n-    @Override\r\n-    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\r\n-        SlotInfo info = ((glyphCode & 1) == 1 ? emoji : symbol)\r\n-                .getSlotInfoForGlyph(glyphCode >>> 1);\r\n-        info.slotShift++;\r\n-        return info;\r\n-    }\r\n-\r\n-    private class Strike extends FontStrike {\r\n-\r\n-        private final FontStrike symbol, emoji;\r\n-\r\n-        private Strike(FontStrikeDesc desc) {\r\n-            this.desc = desc;\r\n-            this.disposer = new FontStrikeDisposer(EmojiFont.this, desc);\r\n-            symbol = EmojiFont.this.symbol == null ? null :\r\n-                    EmojiFont.this.symbol.getStrike(desc);\r\n-            emoji = EmojiFont.this.emoji == null ? null :\r\n-                    EmojiFont.this.emoji.getStrike(desc);\r\n-        }\r\n-\r\n-        private FontStrike getStrikeForGlyph(int glyphCode) {\r\n-            return (glyphCode & 1) == 1 ? emoji : symbol;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getNumGlyphs() {\r\n-            return EmojiFont.this.getNumGlyphs();\r\n-        }\r\n-\r\n-        @Override\r\n-        StrikeMetrics getFontMetrics() {\r\n-            if (strikeMetrics == null) {\r\n-                StrikeMetrics compMetrics = new StrikeMetrics();\r\n-                if (emoji != null) {\r\n-                    compMetrics.merge(emoji.getFontMetrics());\r\n-                }\r\n-                if (symbol != null) {\r\n-                    compMetrics.merge(symbol.getFontMetrics());\r\n-                }\r\n-                strikeMetrics = compMetrics;\r\n-            }\r\n-            return strikeMetrics;\r\n-        }\r\n-\r\n-        @Override\r\n-        void getGlyphImagePtrs(int[] glyphCodes, long[] images, int len) {\r\n-            for (int i = 0; i < len; i++) {\r\n-                images[i] = getGlyphImagePtr(glyphCodes[i]);\r\n-            }\r\n-        }\r\n-\r\n-        @Override\r\n-        long getGlyphImagePtr(int glyphCode) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            return strike.getGlyphImagePtr(glyphCode >>> 1);\r\n-        }\r\n-\r\n-        @Override\r\n-        void getGlyphImageBounds(int glyphCode, Point2D.Float pt, Rectangle result) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            strike.getGlyphImageBounds(glyphCode >>> 1, pt, result);\r\n-        }\r\n-\r\n-        @Override\r\n-        Point2D.Float getGlyphMetrics(int glyphCode) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            return strike.getGlyphMetrics(glyphCode >>> 1);\r\n-        }\r\n-\r\n-        @Override\r\n-        Point2D.Float getCharMetrics(char ch) {\r\n-            return getGlyphMetrics(getMapper().charToGlyph(ch));\r\n-        }\r\n-\r\n-        @Override\r\n-        float getGlyphAdvance(int glyphCode) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            return strike.getGlyphAdvance(glyphCode >>> 1);\r\n-        }\r\n-\r\n-        @Override\r\n-        float getCodePointAdvance(int cp) {\r\n-            return getGlyphAdvance(getMapper().charToGlyph(cp));\r\n-        }\r\n-\r\n-        @Override\r\n-        Rectangle2D.Float getGlyphOutlineBounds(int glyphCode) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            return strike.getGlyphOutlineBounds(glyphCode >>> 1);\r\n-        }\r\n-\r\n-        @Override\r\n-        GeneralPath getGlyphOutline(int glyphCode, float x, float y) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            GeneralPath path = strike.getGlyphOutline(glyphCode >>> 1, x, y);\r\n-            return path != null ? path : new GeneralPath();\r\n-        }\r\n-\r\n-        @Override\r\n-        GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\r\n-            FontStrike strike = getStrikeForGlyph(glyphCode);\r\n-            return strike.getGlyphRenderData(glyphCode >>> 1, x, y);\r\n-        }\r\n-    }\r\n-\r\n-    class Mapper extends CharToGlyphMapper {\r\n-\r\n-        private final CharToGlyphMapper symbol, emoji;\r\n-\r\n-        private Mapper() {\r\n-            symbol = EmojiFont.this.symbol == null ? null :\r\n-                    EmojiFont.this.symbol.getMapper();\r\n-            emoji = EmojiFont.this.emoji == null ? null :\r\n-                    EmojiFont.this.emoji.getMapper();\r\n-            if (EmojiFont.this.emoji != null) {\r\n-                missingGlyph = compositeGlyphCode(true, EmojiFont.this.emoji.getMissingGlyphCode());\r\n-            } else if (EmojiFont.this.symbol != null) {\r\n-                missingGlyph = compositeGlyphCode(false, EmojiFont.this.symbol.getMissingGlyphCode());\r\n-            }\r\n-        }\r\n-\r\n-        private int compositeGlyphCode(boolean slot, int glyphCode) {\r\n-            return slot ? (glyphCode << 1) | 1 : glyphCode << 1;\r\n-        }\r\n-\r\n-        private boolean getSlot(int unicode, int variationSelector) {\r\n-            return switch (variationSelector) {\r\n-                case 0xFE0F -> true;\r\n-                case 0xFE0E -> false;\r\n-                default -> Character.isEmojiPresentation(unicode);\r\n-            };\r\n-        }\r\n-\r\n-        @Override\r\n-        public int getNumGlyphs() {\r\n-            return EmojiFont.this.getNumGlyphs();\r\n-        }\r\n-\r\n-        @Override\r\n-        public int charToVariationGlyph(int unicode, int variationSelector) {\r\n-            boolean slot = getSlot(unicode, variationSelector);\r\n-            CharToGlyphMapper mapper = slot ? emoji : symbol;\r\n-            if (mapper != null) {\r\n-                int glyph = mapper.charToGlyph(unicode);\r\n-                if (glyph != mapper.getMissingGlyphCode()) {\r\n-                    return compositeGlyphCode(slot, glyph);\r\n-                }\r\n-            }\r\n-            mapper = slot ? symbol : emoji;\r\n-            if (mapper != null) {\r\n-                int glyph = mapper.charToGlyph(unicode);\r\n-                if (glyph != mapper.getMissingGlyphCode()) {\r\n-                    return compositeGlyphCode(!slot, glyph);\r\n-                }\r\n-            }\r\n-            return missingGlyph;\r\n-        }\r\n-\r\n-        @Override\r\n-        public int charToGlyph(int unicode) {\r\n-            return charToVariationGlyph(unicode, 0);\r\n-        }\r\n-\r\n-        @Override\r\n-        public int charToGlyph(char unicode) {\r\n-            return charToGlyph((int) unicode);\r\n-        }\r\n-    }\r\n-}\r\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.font;\n+\n+import java.awt.*;\n+import java.awt.geom.GeneralPath;\n+import java.awt.geom.Point2D;\n+import java.awt.geom.Rectangle2D;\n+\n+public class EmojiFont extends Font2D {\n+\n+    private Font2D symbol, emoji;\n+    private volatile boolean init;\n+\n+    public EmojiFont() {\n+        handle = new Font2DHandle(this);\n+        fullName = \"Emoji.plain\";\n+        familyName = \"Emoji\";\n+        fontRank = JRE_RANK;\n+        style = Font.PLAIN;\n+    }\n+\n+    private void init() {\n+        if (!init) {\n+            synchronized (this) {\n+                if (!init) {\n+                    SunFontManager fm = SunFontManager.getInstance();\n+                    symbol = fm.findFont2D(\"Segoe UI Symbol\", Font.PLAIN, FontManager.NO_FALLBACK);\n+                    emoji = fm.findFont2D(\"Segoe UI Emoji\", Font.PLAIN, FontManager.NO_FALLBACK);\n+                    init = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void getStyleMetrics(float pointSize, float[] metrics, int offset) {\n+        init();\n+        if (emoji != null) {\n+            emoji.getStyleMetrics(pointSize, metrics, offset);\n+        } else if (symbol != null) {\n+            symbol.getStyleMetrics(pointSize, metrics, offset);\n+        } else {\n+            super.getStyleMetrics(pointSize, metrics, offset);\n+        }\n+    }\n+\n+    @Override\n+    FontStrike createStrike(FontStrikeDesc desc) {\n+        init();\n+        return new Strike(desc);\n+    }\n+\n+    @Override\n+    protected int getValidatedGlyphCode(int glyphCode) {\n+        init();\n+        Font2D slot = (glyphCode & 1) == 1 ? emoji : symbol;\n+        if (emoji != null) {\n+            int result = slot.getValidatedGlyphCode(glyphCode >>> 1);\n+            if (result != slot.getMissingGlyphCode()) {\n+                return glyphCode;\n+            }\n+        }\n+        return getMissingGlyphCode();\n+    }\n+\n+    @Override\n+    CharToGlyphMapper getMapper() {\n+        init();\n+        if (mapper == null) {\n+            mapper = new Mapper();\n+        }\n+        return mapper;\n+    }\n+\n+    @Override\n+    public boolean hasSupplementaryChars() {\n+        init();\n+        return (emoji != null && emoji.hasSupplementaryChars()) ||\n+                (symbol != null && symbol.hasSupplementaryChars());\n+    }\n+\n+    @Override\n+    public int getNumGlyphs() {\n+        init();\n+        return Math.max(emoji != null ? emoji.getNumGlyphs() : 0,\n+                symbol != null ? symbol.getNumGlyphs() : 0);\n+    }\n+\n+    @Override\n+    public boolean canDisplay(int cp) {\n+        return (Character.isEmoji(cp) || Character.isEmojiComponent(cp)) && getMapper().canDisplay(cp);\n+    }\n+\n+    @Override\n+    public SlotInfo getSlotInfoForGlyph(int glyphCode) {\n+        SlotInfo info = ((glyphCode & 1) == 1 ? emoji : symbol)\n+                .getSlotInfoForGlyph(glyphCode >>> 1);\n+        info.slotShift++;\n+        return info;\n+    }\n+\n+    private class Strike extends FontStrike {\n+\n+        private final FontStrike symbol, emoji;\n+\n+        private Strike(FontStrikeDesc desc) {\n+            this.desc = desc;\n+            this.disposer = new FontStrikeDisposer(EmojiFont.this, desc);\n+            symbol = EmojiFont.this.symbol == null ? null :\n+                    EmojiFont.this.symbol.getStrike(desc);\n+            emoji = EmojiFont.this.emoji == null ? null :\n+                    EmojiFont.this.emoji.getStrike(desc);\n+        }\n+\n+        private FontStrike getStrikeForGlyph(int glyphCode) {\n+            return (glyphCode & 1) == 1 ? emoji : symbol;\n+        }\n+\n+        @Override\n+        public int getNumGlyphs() {\n+            return EmojiFont.this.getNumGlyphs();\n+        }\n+\n+        @Override\n+        StrikeMetrics getFontMetrics() {\n+            if (strikeMetrics == null) {\n+                StrikeMetrics compMetrics = new StrikeMetrics();\n+                if (emoji != null) {\n+                    compMetrics.merge(emoji.getFontMetrics());\n+                }\n+                if (symbol != null) {\n+                    compMetrics.merge(symbol.getFontMetrics());\n+                }\n+                strikeMetrics = compMetrics;\n+            }\n+            return strikeMetrics;\n+        }\n+\n+        @Override\n+        void getGlyphImagePtrs(int[] glyphCodes, long[] images, int len) {\n+            for (int i = 0; i < len; i++) {\n+                images[i] = getGlyphImagePtr(glyphCodes[i]);\n+            }\n+        }\n+\n+        @Override\n+        long getGlyphImagePtr(int glyphCode) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            return strike.getGlyphImagePtr(glyphCode >>> 1);\n+        }\n+\n+        @Override\n+        void getGlyphImageBounds(int glyphCode, Point2D.Float pt, Rectangle result) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            strike.getGlyphImageBounds(glyphCode >>> 1, pt, result);\n+        }\n+\n+        @Override\n+        Point2D.Float getGlyphMetrics(int glyphCode) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            return strike.getGlyphMetrics(glyphCode >>> 1);\n+        }\n+\n+        @Override\n+        Point2D.Float getCharMetrics(char ch) {\n+            return getGlyphMetrics(getMapper().charToGlyph(ch));\n+        }\n+\n+        @Override\n+        float getGlyphAdvance(int glyphCode) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            return strike.getGlyphAdvance(glyphCode >>> 1);\n+        }\n+\n+        @Override\n+        float getCodePointAdvance(int cp) {\n+            return getGlyphAdvance(getMapper().charToGlyph(cp));\n+        }\n+\n+        @Override\n+        Rectangle2D.Float getGlyphOutlineBounds(int glyphCode) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            return strike.getGlyphOutlineBounds(glyphCode >>> 1);\n+        }\n+\n+        @Override\n+        GeneralPath getGlyphOutline(int glyphCode, float x, float y) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            GeneralPath path = strike.getGlyphOutline(glyphCode >>> 1, x, y);\n+            return path != null ? path : new GeneralPath();\n+        }\n+\n+        @Override\n+        GlyphRenderData getGlyphRenderData(int glyphCode, float x, float y) {\n+            FontStrike strike = getStrikeForGlyph(glyphCode);\n+            return strike.getGlyphRenderData(glyphCode >>> 1, x, y);\n+        }\n+    }\n+\n+    class Mapper extends CharToGlyphMapper {\n+\n+        private final CharToGlyphMapper symbol, emoji;\n+\n+        private Mapper() {\n+            symbol = EmojiFont.this.symbol == null ? null :\n+                    EmojiFont.this.symbol.getMapper();\n+            emoji = EmojiFont.this.emoji == null ? null :\n+                    EmojiFont.this.emoji.getMapper();\n+            if (EmojiFont.this.emoji != null) {\n+                missingGlyph = compositeGlyphCode(true, EmojiFont.this.emoji.getMissingGlyphCode());\n+            } else if (EmojiFont.this.symbol != null) {\n+                missingGlyph = compositeGlyphCode(false, EmojiFont.this.symbol.getMissingGlyphCode());\n+            }\n+        }\n+\n+        private int compositeGlyphCode(boolean slot, int glyphCode) {\n+            return slot ? (glyphCode << 1) | 1 : glyphCode << 1;\n+        }\n+\n+        private boolean getSlot(int unicode, int variationSelector) {\n+            return switch (variationSelector) {\n+                case 0xFE0F -> true;\n+                case 0xFE0E -> false;\n+                default -> Character.isEmojiPresentation(unicode);\n+            };\n+        }\n+\n+        @Override\n+        public int getNumGlyphs() {\n+            return EmojiFont.this.getNumGlyphs();\n+        }\n+\n+        @Override\n+        public int charToVariationGlyph(int unicode, int variationSelector) {\n+            boolean slot = getSlot(unicode, variationSelector);\n+            CharToGlyphMapper mapper = slot ? emoji : symbol;\n+            if (mapper != null) {\n+                int glyph = mapper.charToGlyph(unicode);\n+                if (glyph != mapper.getMissingGlyphCode()) {\n+                    return compositeGlyphCode(slot, glyph);\n+                }\n+            }\n+            mapper = slot ? symbol : emoji;\n+            if (mapper != null) {\n+                int glyph = mapper.charToGlyph(unicode);\n+                if (glyph != mapper.getMissingGlyphCode()) {\n+                    return compositeGlyphCode(!slot, glyph);\n+                }\n+            }\n+            return missingGlyph;\n+        }\n+\n+        @Override\n+        public int charToGlyph(int unicode) {\n+            return charToVariationGlyph(unicode, 0);\n+        }\n+\n+        @Override\n+        public int charToGlyph(char unicode) {\n+            return charToGlyph((int) unicode);\n+        }\n+    }\n+}\n","filename":"src\/java.desktop\/windows\/classes\/sun\/font\/EmojiFont.java","additions":285,"deletions":285,"binary":false,"changes":570,"status":"modified"}]}