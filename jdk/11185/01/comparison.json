{"files":[{"patch":"@@ -93,1 +93,1 @@\n-<li><a href=\"#using-sjavac\">Using sjavac<\/a><\/li>\n+<li><a href=\"#using-the-javac-server\">Using the javac server<\/a><\/li>\n@@ -822,2 +822,2 @@\n-<h3 id=\"using-sjavac\">Using sjavac<\/h3>\n-<p>To speed up compilation of Java code, especially during incremental compilations, the sjavac server is automatically enabled in the configuration step by default. To explicitly enable or disable sjavac, use either <code>--enable-javac-server<\/code> or <code>--disable-javac-server<\/code>.<\/p>\n+<h3 id=\"using-the-javac-server\">Using the javac server<\/h3>\n+<p>To speed up compilation of Java code, especially during incremental compilations, the javac server is automatically enabled in the configuration step by default. To explicitly enable or disable the javac server, use either <code>--enable-javac-server<\/code> or <code>--disable-javac-server<\/code>.<\/p>\n","filename":"doc\/building.html","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1336,1 +1336,1 @@\n-### Using sjavac\n+### Using the javac server\n@@ -1338,4 +1338,4 @@\n-To speed up compilation of Java code, especially during incremental compilations,\n-the sjavac server is automatically enabled in the configuration step by default.\n-To explicitly enable or disable sjavac, use either `--enable-javac-server`\n-or `--disable-javac-server`.\n+To speed up compilation of Java code, especially during incremental\n+compilations, the javac server is automatically enabled in the configuration\n+step by default. To explicitly enable or disable the javac server, use either\n+`--enable-javac-server` or `--disable-javac-server`.\n","filename":"doc\/building.md","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -128,0 +128,15 @@\n+# Setup the compilation of the javac server build tool. Technically, this is not\n+# really \"interim\" langtools, but just like it, it is needed henceforth for all\n+# java compilation using the interim compiler.\n+$(eval $(call SetupJavaCompilation, BUILD_JAVAC_SERVER, \\\n+    COMPILER := bootjdk, \\\n+    TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+    SRC := $(TOPDIR)\/make\/langtools\/tools, \\\n+    INCLUDES := javacserver, \\\n+    BIN := $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes, \\\n+))\n+\n+TARGETS += $(BUILD_JAVAC_SERVER)\n+\n+################################################################################\n+\n","filename":"make\/CompileInterimLangtools.gmk","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -327,1 +327,1 @@\n-\t    $(call PrepareSmartJavac)\n+\t    $(call PrepareJavacServer)\n@@ -342,1 +342,1 @@\n-\t    $(call CleanupSmartJavac)\n+\t    $(call CleanupJavacServer)\n@@ -354,1 +354,1 @@\n-\t$(call CleanupSmartJavac)\n+\t$(call CleanupJavacServer)\n@@ -367,1 +367,1 @@\n-\t$(call WaitForSmartJavacFinish)\n+\t$(call WaitForJavacServerFinish)\n@@ -371,1 +371,1 @@\n-\t$(call WaitForSmartJavacFinish)\n+\t$(call WaitForJavacServerFinish)\n","filename":"make\/Init.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -496,1 +496,1 @@\n-  define PrepareSmartJavac\n+  define PrepareJavacServer\n@@ -503,2 +503,2 @@\n-  define CleanupSmartJavac\n-\t[ -f $(JAVAC_SERVER_DIR)\/server.port ] && $(ECHO) Stopping sjavac server && \\\n+  define CleanupJavacServer\n+\t[ -f $(JAVAC_SERVER_DIR)\/server.port ] && $(ECHO) Stopping javac server && \\\n@@ -513,1 +513,1 @@\n-    define WaitForSmartJavacFinish\n+    define WaitForJavacServerFinish\n@@ -519,1 +519,1 @@\n-    define WaitForSmartJavacFinish\n+    define WaitForJavacServerFinish\n","filename":"make\/InitSupport.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -222,1 +222,1 @@\n-      $1_JAVAC := $$(INTERIM_LANGTOOLS_ARGS) -m jdk.compiler.interim\/com.sun.tools.sjavac.Main\n+      $1_JAVAC := $$(INTERIM_LANGTOOLS_ARGS) -cp $(BUILDTOOLS_OUTPUTDIR)\/langtools_javacserver_classes javacserver.Main\n","filename":"make\/common\/JavaCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,22 +0,0 @@\n-<component name=\"ProjectRunConfigurationManager\">\n-  <configuration default=\"false\" name=\"sjavac\" type=\"Application\" factoryName=\"Application\">\n-    <extension name=\"coverage\" enabled=\"false\" merge=\"false\" sample_coverage=\"true\" runner=\"idea\" \/>\n-    <option name=\"MAIN_CLASS_NAME\" value=\"com.sun.tools.sjavac.Main\" \/>\n-    <option name=\"VM_PARAMETERS\" value='@XPATCH@ --add-exports=jdk.compiler\/com.sun.tools.sjavac=ALL-UNNAMED' \/>\n-    <option name=\"PROGRAM_PARAMETERS\" value=\"\" \/>\n-    <option name=\"WORKING_DIRECTORY\" value=\"file:\/\/$PROJECT_DIR$\" \/>\n-    <option name=\"ALTERNATIVE_JRE_PATH_ENABLED\" value=\"true\" \/>\n-    <option name=\"ALTERNATIVE_JRE_PATH\" value=\"@IDEA_TARGET_JDK@\" \/>\n-    <option name=\"ENABLE_SWING_INSPECTOR\" value=\"false\" \/>\n-    <option name=\"ENV_VARIABLES\" \/>\n-    <option name=\"PASS_PARENT_ENVS\" value=\"true\" \/>\n-    <module name=\"langtools\" \/>\n-    <envs \/>\n-    <RunnerSettings RunnerId=\"Run\" \/>\n-    <ConfigurationWrapper RunnerId=\"Run\" \/>\n-    <method>\n-      <option name=\"Make\" enabled=\"false\" \/>\n-      <option name=\"AntTarget\" enabled=\"true\" antfile=\"file:\/\/$PROJECT_DIR$\/make\/ide\/idea\/langtools\/build.xml\" target=\"build-all-classes\" \/>\n-    <\/method>\n-  <\/configuration>\n-<\/component>\n","filename":"make\/ide\/idea\/langtools\/template\/runConfigurations\/sjavac.xml","additions":0,"deletions":22,"binary":false,"changes":22,"status":"deleted"},{"patch":"@@ -62,1 +62,0 @@\n-tool.sjavac.main.class=com.sun.tools.sjavac.Main\n","filename":"make\/langtools\/build.properties","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -241,1 +241,0 @@\n-        <build-tool name=\"sjavac\"\/>\n","filename":"make\/langtools\/build.xml","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac;\n+package javacserver;\n","filename":"make\/langtools\/tools\/javacserver\/AutoFlushWriter.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/AutoFlushWriter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac;\n+package javacserver;\n","filename":"make\/langtools\/tools\/javacserver\/Log.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Log.java","status":"renamed"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver;\n+\n+import java.util.Arrays;\n+\n+import javacserver.client.ClientMain;\n+import javacserver.server.ServerMain;\n+\n+import static javacserver.options.Option.STARTSERVER;\n+\n+\/**\n+ * The application entry point of the smart javac wrapper tool.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class Main {\n+\n+    public static void main(String... args)  {\n+        System.exit(go(args));\n+    }\n+\n+    public static int go(String[] args) {\n+\n+        \/\/ Server or client mode?\n+        boolean serverMode = Arrays.asList(args)\n+                                   .stream()\n+                                   .anyMatch(arg -> arg.startsWith(STARTSERVER.arg));\n+\n+        return serverMode ? ServerMain.run(args) : ClientMain.run(args);\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/Main.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver;\n+\n+\/** Result codes.\n+ *\/\n+public enum Result {\n+    OK(0),        \/\/ Compilation completed with no errors.\n+    ERROR(1),     \/\/ Completed but reported errors.\n+    CMDERR(2),    \/\/ Bad command-line arguments\n+    SYSERR(3),    \/\/ System error or resource exhaustion.\n+    ABNORMAL(4);  \/\/ Compiler terminated abnormally\n+\n+    Result(int exitCode) {\n+        this.exitCode = exitCode;\n+    }\n+\n+    public static Result of(int exitcode) {\n+        for (Result result : values()) {\n+            if (result.exitCode == exitcode) {\n+                return result;\n+            }\n+        }\n+\n+        return ABNORMAL;\n+    }\n+\n+    public boolean isOK() {\n+        return (exitCode == 0);\n+    }\n+\n+    public final int exitCode;\n+}\n","filename":"make\/langtools\/tools\/javacserver\/Result.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Utilities.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class Util {\n+\n+\n+\n+    public static String extractStringOption(String opName, String s) {\n+        return extractStringOption(opName, s, null);\n+    }\n+\n+    private static String extractStringOptionWithDelimiter(String opName, String s, String deflt, char delimiter) {\n+        int p = s.indexOf(opName+\"=\");\n+        if (p == -1) return deflt;\n+        p+=opName.length()+1;\n+        int pe = s.indexOf(delimiter, p);\n+        if (pe == -1) pe = s.length();\n+        return s.substring(p, pe);\n+    }\n+\n+    public static String extractStringOption(String opName, String s, String deflt) {\n+        return extractStringOptionWithDelimiter(opName, s, deflt, ',');\n+    }\n+\n+    public static String extractStringOptionLine(String opName, String s, String deflt) {\n+        return extractStringOptionWithDelimiter(opName, s, deflt, '\\n').strip();\n+    }\n+\n+    public static int extractIntOption(String opName, String s, int deflt) {\n+        int p = s.indexOf(opName+\"=\");\n+        if (p == -1) return deflt;\n+        p+=opName.length()+1;\n+        int pe = s.indexOf(',', p);\n+        if (pe == -1) pe = s.length();\n+        int v = 0;\n+        try {\n+            v = Integer.parseInt(s.substring(p, pe));\n+        } catch (Exception e) {}\n+        return v;\n+    }\n+\n+\n+    \/**\n+     * Convenience method to create a set with strings.\n+     *\/\n+    public static Set<String> set(String... ss) {\n+        Set<String> set = new HashSet<>();\n+        set.addAll(Arrays.asList(ss));\n+        return set;\n+    }\n+\n+    \/**\n+     * Normalize windows drive letter paths to upper case to enable string\n+     * comparison.\n+     *\n+     * @param file File name to normalize\n+     * @return The normalized string if file has a drive letter at the beginning,\n+     *         otherwise the original string.\n+     *\/\n+    public static String normalizeDriveLetter(String file) {\n+        if (file.length() > 2 && file.charAt(1) == ':') {\n+            return Character.toUpperCase(file.charAt(0)) + file.substring(1);\n+        } else if (file.length() > 3 && file.charAt(0) == '*'\n+                   && file.charAt(2) == ':') {\n+            \/\/ Handle a wildcard * at the beginning of the string.\n+            return file.substring(0, 1) + Character.toUpperCase(file.charAt(1))\n+                   + file.substring(2);\n+        }\n+        return file;\n+    }\n+\n+\n+    public static <E> Set<E> union(Set<? extends E> s1,\n+                                   Set<? extends E> s2) {\n+        Set<E> union = new HashSet<>();\n+        union.addAll(s1);\n+        union.addAll(s2);\n+        return union;\n+    }\n+\n+    public static <E> Set<E> subtract(Set<? extends E> orig,\n+                                      Set<? extends E> toSubtract) {\n+        Set<E> difference = new HashSet<>(orig);\n+        difference.removeAll(toSubtract);\n+        return difference;\n+    }\n+\n+    public static String getStackTrace(Throwable t) {\n+        StringWriter sw = new StringWriter();\n+        t.printStackTrace(new PrintWriter(sw));\n+        return sw.toString();\n+    }\n+\n+    public static <E> Set<E> intersection(Collection<? extends E> c1,\n+                                          Collection<? extends E> c2) {\n+        Set<E> intersection = new HashSet<E>(c1);\n+        intersection.retainAll(c2);\n+        return intersection;\n+    }\n+\n+\n+    public static Stream<String> getLines(String str) {\n+        return str.isEmpty()\n+                ? Stream.empty()\n+                : Stream.of(str.split(Pattern.quote(System.lineSeparator())));\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/Util.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.client;\n+\n+import java.io.OutputStreamWriter;\n+import java.io.Writer;\n+\n+import javacserver.AutoFlushWriter;\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.comp.SjavacImpl;\n+import javacserver.options.Options;\n+import javacserver.server.Sjavac;\n+\n+\/**\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class ClientMain {\n+\n+    public static int run(String[] args) {\n+        return run(args,\n+                   new AutoFlushWriter(new OutputStreamWriter(System.out)),\n+                   new AutoFlushWriter(new OutputStreamWriter(System.err)));\n+    }\n+\n+    public static int run(String[] args, Writer out, Writer err) {\n+\n+        Log.setLogForCurrentThread(new Log(out, err));\n+\n+        Options options;\n+        try {\n+            options = Options.parseArgs(args);\n+        } catch (IllegalArgumentException e) {\n+            Log.error(e.getMessage());\n+            return Result.CMDERR.exitCode;\n+        }\n+\n+        Log.setLogLevel(options.getLogLevel());\n+\n+        \/\/ Prepare sjavac object\n+        boolean useServer = options.getServerConf() != null;\n+        Sjavac sjavac = useServer ? new SjavacClient(options) : new SjavacImpl();\n+\n+        \/\/ Perform compilation\n+        Result result = sjavac.compile(args);\n+\n+        \/\/ If sjavac is running in the foreground we should shut it down at this point\n+        if (!useServer) {\n+            sjavac.shutdown();\n+        }\n+\n+        return result.exitCode;\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/client\/ClientMain.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac.client;\n+package javacserver.client;\n","filename":"make\/langtools\/tools\/javacserver\/client\/PortFileInaccessibleException.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/client\/PortFileInaccessibleException.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac.client;\n+package javacserver.client;\n@@ -43,8 +43,7 @@\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Util;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.server.PortFile;\n-import com.sun.tools.sjavac.server.Sjavac;\n-import com.sun.tools.sjavac.server.SjavacServer;\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.Util;\n+import javacserver.options.Options;\n+import javacserver.server.PortFile;\n+import javacserver.server.Sjavac;\n+import javacserver.server.SjavacServer;\n@@ -65,1 +64,1 @@\n-    \/\/ It should point to a com.sun.tools.sjavac.Main that supports --startserver\n+    \/\/ It should point to a javacserver.Main that supports --startserver\n@@ -147,1 +146,1 @@\n-                    result = Main.Result.valueOf(content);\n+                    result = Result.valueOf(content);\n","filename":"make\/langtools\/tools\/javacserver\/client\/SjavacClient.java","additions":11,"deletions":12,"binary":false,"changes":23,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/client\/SjavacClient.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,1 @@\n-package com.sun.tools.sjavac.comp;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.server.Sjavac;\n+package javacserver.comp;\n@@ -37,0 +33,4 @@\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.server.Sjavac;\n+\n","filename":"make\/langtools\/tools\/javacserver\/comp\/PooledSjavac.java","additions":6,"deletions":6,"binary":false,"changes":12,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/PooledSjavac.java","status":"renamed"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.comp;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.stream.Stream;\n+\n+import com.sun.tools.javac.Main;\n+\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.Util;\n+import javacserver.options.Option;\n+import javacserver.server.Sjavac;\n+\n+\/**\n+ * The sjavac implementation that interacts with javac and performs the actual\n+ * compilation.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class SjavacImpl implements Sjavac {\n+\n+    @Override\n+    @SuppressWarnings(\"deprecated\")\n+    public Result compile(String[] args) {\n+        \/\/ Direct logging to our byte array stream.\n+        StringWriter strWriter = new StringWriter();\n+        PrintWriter printWriter = new PrintWriter(strWriter);\n+\n+        \/\/ Prepare arguments\n+        String[] passThroughArgs = Stream.of(args)\n+                                         .filter(arg -> !arg.startsWith(Option.SERVER.arg))\n+                                         .toArray(String[]::new);\n+        \/\/ Compile\n+        int exitcode = Main.compile(passThroughArgs, printWriter);\n+        Result result = Result.of(exitcode);\n+\n+        \/\/ Process compiler output (which is always errors)\n+        printWriter.flush();\n+        Util.getLines(strWriter.toString()).forEach(Log::error);\n+\n+        return result;\n+\n+    }\n+\n+    @Override\n+    public void shutdown() {\n+        \/\/ Nothing to clean up\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/comp\/SjavacImpl.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac.options;\n+package javacserver.options;\n","filename":"make\/langtools\/tools\/javacserver\/options\/ArgumentIterator.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/options\/ArgumentIterator.java","status":"renamed"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.options;\n+\n+import java.io.IOException;\n+import java.io.Reader;\n+import java.nio.charset.Charset;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+\/**\n+ * Various utility methods for processing Java tool command line arguments.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class CommandLine {\n+    \/**\n+     * Process Win32-style command files for the specified command line\n+     * arguments and return the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with @files expanded\n+     * @throws IOException if there is a problem reading any of the @files\n+     *\/\n+    public static List<String> parse(List<String> args) throws IOException {\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, args);\n+        return newArgs;\n+    }\n+\n+    private static void appendParsedCommandArgs(List<String> newArgs, List<String> args) throws IOException {\n+        for (String arg : args) {\n+            if (arg.length() > 1 && arg.charAt(0) == '@') {\n+                arg = arg.substring(1);\n+                if (arg.charAt(0) == '@') {\n+                    newArgs.add(arg);\n+                } else {\n+                    loadCmdFile(arg, newArgs);\n+                }\n+            } else {\n+                newArgs.add(arg);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Process the given environment variable and appends any Win32-style\n+     * command files for the specified command line arguments and return\n+     * the resulting arguments. A command file argument\n+     * is of the form '@file' where 'file' is the name of the file whose\n+     * contents are to be parsed for additional arguments. The contents of\n+     * the command file are parsed using StreamTokenizer and the original\n+     * '@file' argument replaced with the resulting tokens. Recursive command\n+     * files are not supported. The '@' character itself can be quoted with\n+     * the sequence '@@'.\n+     * @param envVariable the env variable to process\n+     * @param args the arguments that may contain @files\n+     * @return the arguments, with environment variable's content and expansion of @files\n+     * @throws IOException if there is a problem reading any of the @files\n+     * @throws UnmatchedQuote\n+     *\/\n+    public static List<String> parse(String envVariable, List<String> args)\n+            throws IOException, UnmatchedQuote {\n+\n+        List<String> inArgs = new ArrayList<>();\n+        appendParsedEnvVariables(inArgs, envVariable);\n+        inArgs.addAll(args);\n+        List<String> newArgs = new ArrayList<>();\n+        appendParsedCommandArgs(newArgs, inArgs);\n+        return newArgs;\n+    }\n+\n+    private static void loadCmdFile(String name, List<String> args) throws IOException {\n+        try (Reader r = Files.newBufferedReader(Paths.get(name), Charset.defaultCharset())) {\n+            Tokenizer t = new Tokenizer(r);\n+            String s;\n+            while ((s = t.nextToken()) != null) {\n+                args.add(s);\n+            }\n+        }\n+    }\n+\n+    public static class Tokenizer {\n+        private final Reader in;\n+        private int ch;\n+\n+        public Tokenizer(Reader in) throws IOException {\n+            this.in = in;\n+            ch = in.read();\n+        }\n+\n+        public String nextToken() throws IOException {\n+            skipWhite();\n+            if (ch == -1) {\n+                return null;\n+            }\n+\n+            StringBuilder sb = new StringBuilder();\n+            char quoteChar = 0;\n+\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case ' ':\n+                    case '\\t':\n+                    case '\\f':\n+                        if (quoteChar == 0) {\n+                            return sb.toString();\n+                        }\n+                        sb.append((char) ch);\n+                        break;\n+\n+                    case '\\n':\n+                    case '\\r':\n+                        return sb.toString();\n+\n+                    case '\\'':\n+                    case '\"':\n+                        if (quoteChar == 0) {\n+                            quoteChar = (char) ch;\n+                        } else if (quoteChar == ch) {\n+                            quoteChar = 0;\n+                        } else {\n+                            sb.append((char) ch);\n+                        }\n+                        break;\n+\n+                    case '\\\\':\n+                        if (quoteChar != 0) {\n+                            ch = in.read();\n+                            switch (ch) {\n+                                case '\\n':\n+                                case '\\r':\n+                                    while (ch == ' ' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == '\\f') {\n+                                        ch = in.read();\n+                                    }\n+                                    continue;\n+\n+                                case 'n':\n+                                    ch = '\\n';\n+                                    break;\n+                                case 'r':\n+                                    ch = '\\r';\n+                                    break;\n+                                case 't':\n+                                    ch = '\\t';\n+                                    break;\n+                                case 'f':\n+                                    ch = '\\f';\n+                                    break;\n+                            }\n+                        }\n+                        sb.append((char) ch);\n+                        break;\n+\n+                    default:\n+                        sb.append((char) ch);\n+                }\n+\n+                ch = in.read();\n+            }\n+\n+            return sb.toString();\n+        }\n+\n+        void skipWhite() throws IOException {\n+            while (ch != -1) {\n+                switch (ch) {\n+                    case ' ':\n+                    case '\\t':\n+                    case '\\n':\n+                    case '\\r':\n+                    case '\\f':\n+                        break;\n+\n+                    case '#':\n+                        ch = in.read();\n+                        while (ch != '\\n' && ch != '\\r' && ch != -1) {\n+                            ch = in.read();\n+                        }\n+                        break;\n+\n+                    default:\n+                        return;\n+                }\n+\n+                ch = in.read();\n+            }\n+        }\n+    }\n+\n+    @SuppressWarnings(\"fallthrough\")\n+    private static void appendParsedEnvVariables(List<String> newArgs, String envVariable)\n+            throws UnmatchedQuote {\n+\n+        if (envVariable == null) {\n+            return;\n+        }\n+        String in = System.getenv(envVariable);\n+        if (in == null || in.trim().isEmpty()) {\n+            return;\n+        }\n+\n+        final char NUL = (char)0;\n+        final int len = in.length();\n+\n+        int pos = 0;\n+        StringBuilder sb = new StringBuilder();\n+        char quote = NUL;\n+        char ch;\n+\n+        loop:\n+        while (pos < len) {\n+            ch = in.charAt(pos);\n+            switch (ch) {\n+                case '\\\"': case '\\'':\n+                    if (quote == NUL) {\n+                        quote = ch;\n+                    } else if (quote == ch) {\n+                        quote = NUL;\n+                    } else {\n+                        sb.append(ch);\n+                    }\n+                    pos++;\n+                    break;\n+                case '\\f': case '\\n': case '\\r': case '\\t': case ' ':\n+                    if (quote == NUL) {\n+                        newArgs.add(sb.toString());\n+                        sb.setLength(0);\n+                        while (ch == '\\f' || ch == '\\n' || ch == '\\r' || ch == '\\t' || ch == ' ') {\n+                            pos++;\n+                            if (pos >= len) {\n+                                break loop;\n+                            }\n+                            ch = in.charAt(pos);\n+                        }\n+                        break;\n+                    }\n+                    \/\/ fall through\n+                default:\n+                    sb.append(ch);\n+                    pos++;\n+            }\n+        }\n+        if (sb.length() != 0) {\n+            newArgs.add(sb.toString());\n+        }\n+        if (quote != NUL) {\n+            throw new UnmatchedQuote(envVariable);\n+        }\n+    }\n+\n+    public static class UnmatchedQuote extends Exception {\n+        private static final long serialVersionUID = 0;\n+\n+        public final String variableName;\n+\n+        UnmatchedQuote(String variable) {\n+            this.variableName = variable;\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/options\/CommandLine.java","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.options;\n+\n+\/**\n+ * Sjavac options can be classified as:\n+ *\n+ *  (1) relevant only for sjavac, such as --server\n+ *  (2) relevant for sjavac and javac, such as -d, or\n+ *  (3) relevant only for javac, such as -g.\n+ *\n+ * This enum represents all options from (1) and (2). Note that instances of\n+ * this enum only entail static information about the option. For storage of\n+ * option values, refer to Options.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public enum Option {\n+    SERVER(\"--server:\", \"Specify server configuration file of running server\") {\n+        @Override\n+        protected void processMatching(ArgumentIterator iter, Options.ArgDecoderOptionHelper helper) {\n+            helper.serverConf(iter.current().substring(arg.length()));\n+        }\n+    },\n+    STARTSERVER(\"--startserver:\", \"Start server and use the given configuration file\") {\n+        @Override\n+        protected void processMatching(ArgumentIterator iter, Options.ArgDecoderOptionHelper helper) {\n+            helper.startServerConf(iter.current().substring(arg.length()));\n+        }\n+    };\n+\n+\n+    public final String arg;\n+\n+    final String description;\n+\n+    private Option(String arg, String description) {\n+        this.arg = arg;\n+        this.description = description;\n+    }\n+\n+    \/\/ Future cleanup: Change the \"=\" syntax to \":\" syntax to be consistent and\n+    \/\/ to follow the javac-option style.\n+\n+    public boolean hasOption() {\n+        return arg.endsWith(\":\") || arg.endsWith(\"=\");\n+    }\n+\n+\n+    \/**\n+     * Process current argument of argIter.\n+     *\n+     * It's final, since the option customization is typically done in\n+     * processMatching.\n+     *\n+     * @param argIter Iterator to read current and succeeding arguments from.\n+     * @param helper The helper to report back to.\n+     * @return true iff the argument was processed by this option.\n+     *\/\n+    public final boolean processCurrent(ArgumentIterator argIter,\n+                                        Options.ArgDecoderOptionHelper helper) {\n+        String fullArg = argIter.current(); \/\/ \"-tr\" or \"-log=level\"\n+        if (hasOption() ? fullArg.startsWith(arg) : fullArg.equals(arg)) {\n+            processMatching(argIter, helper);\n+            return true;\n+        }\n+        \/\/ Did not match\n+        return false;\n+    }\n+\n+    \/** Called by process if the current argument matches this option. *\/\n+    protected abstract void processMatching(ArgumentIterator argIter,\n+                                            Options.ArgDecoderOptionHelper helper);\n+}\n","filename":"make\/langtools\/tools\/javacserver\/options\/Option.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.options;\n+\n+import java.util.List;\n+\n+\/**\n+ * Instances of this class represent values for sjavac command line options.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class Options {\n+    private String logLevel = \"info\";\n+\n+    private boolean startServer = false;\n+\n+    \/\/ Server configuration string\n+    private String serverConf;\n+\n+    \/** Get the log level. *\/\n+    public String getLogLevel() {\n+        return logLevel;\n+    }\n+\n+    \/** Return true iff a new server should be started *\/\n+    public boolean startServerFlag() {\n+        return startServer;\n+    }\n+\n+    \/** Return the server configuration string. *\/\n+    public String getServerConf() {\n+        return serverConf;\n+    }\n+\n+    \/**\n+     * Parses the given argument array and returns a corresponding Options\n+     * instance.\n+     *\/\n+    public static Options parseArgs(String... args) {\n+        Options options = new Options();\n+        options.new ArgDecoderOptionHelper().traverse(args);\n+        return options;\n+    }\n+\n+    \/\/ OptionHelper that records the traversed options in this Options instance.\n+    public class ArgDecoderOptionHelper {\n+        public void reportError(String msg) {\n+            throw new IllegalArgumentException(msg);\n+        }\n+\n+        public void serverConf(String conf) {\n+            if (serverConf != null)\n+                reportError(\"Can not specify more than one server configuration.\");\n+            else\n+                serverConf = conf;\n+        }\n+\n+        public void startServerConf(String conf) {\n+            if (serverConf != null)\n+                reportError(\"Can not specify more than one server configuration.\");\n+            else {\n+                startServer = true;\n+                serverConf = conf;\n+            }\n+        }\n+\n+        \/**\n+         * Traverses an array of arguments and performs the appropriate callbacks.\n+         *\n+         * @param args the arguments to traverse.\n+         *\/\n+        void traverse(String[] args) {\n+            Iterable<String> allArgs;\n+            try {\n+                allArgs = CommandLine.parse(List.of(args)); \/\/ Detect @file and load it as a command line.\n+            } catch (java.io.IOException e) {\n+                throw new IllegalArgumentException(\"Problem reading @\"+e.getMessage());\n+            }\n+            ArgumentIterator argIter = new ArgumentIterator(allArgs);\n+\n+            nextArg:\n+            while (argIter.hasNext()) {\n+\n+                String arg = argIter.next();\n+\n+                if (arg.startsWith(\"-\")) {\n+                    for (Option opt : Option.values()) {\n+                        if (opt.processCurrent(argIter, this))\n+                            continue nextArg;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/options\/Options.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,4 +26,1 @@\n-package com.sun.tools.sjavac.server;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.Log;\n+package javacserver.server;\n@@ -34,0 +31,3 @@\n+import javacserver.Log;\n+import javacserver.Result;\n+\n","filename":"make\/langtools\/tools\/javacserver\/server\/IdleResetSjavac.java","additions":5,"deletions":5,"binary":false,"changes":10,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/IdleResetSjavac.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac.server;\n+package javacserver.server;\n@@ -38,3 +38,2 @@\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.client.PortFileInaccessibleException;\n+import javacserver.Log;\n+import javacserver.client.PortFileInaccessibleException;\n@@ -154,1 +153,0 @@\n-        Assert.check(containsPortInfo);\n@@ -162,1 +160,0 @@\n-        Assert.check(containsPortInfo);\n@@ -170,1 +167,0 @@\n-        Assert.check(lock != null);\n","filename":"make\/langtools\/tools\/javacserver\/server\/PortFile.java","additions":4,"deletions":8,"binary":false,"changes":12,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/PortFile.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n-package com.sun.tools.sjavac.server;\n-\n-import com.sun.tools.sjavac.Log;\n+package javacserver.server;\n@@ -34,0 +32,2 @@\n+import javacserver.Log;\n+\n","filename":"make\/langtools\/tools\/javacserver\/server\/PortFileMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/PortFileMonitor.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,1 @@\n-package com.sun.tools.sjavac.server;\n-\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Util;\n+package javacserver.server;\n@@ -38,1 +34,5 @@\n-import static com.sun.tools.sjavac.server.SjavacServer.LINE_TYPE_RC;\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.Util;\n+\n+import static javacserver.server.SjavacServer.LINE_TYPE_RC;\n@@ -104,1 +104,1 @@\n-            Main.Result rc = sjavac.compile(args);\n+            Result rc = sjavac.compile(args);\n","filename":"make\/langtools\/tools\/javacserver\/server\/RequestHandler.java","additions":8,"deletions":8,"binary":false,"changes":16,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/RequestHandler.java","status":"renamed"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package javacserver.server;\n+\n+import java.io.IOException;\n+import java.io.PrintStream;\n+\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.server.log.LazyInitFileLog;\n+import javacserver.server.log.LoggingOutputStream;\n+\n+import static javacserver.Log.Level.ERROR;\n+import static javacserver.Log.Level.INFO;\n+\n+\/**\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class ServerMain {\n+\n+    \/\/ For logging server internal (non request specific) errors.\n+    private static LazyInitFileLog errorLog;\n+\n+    public static int run(String[] args) {\n+\n+        \/\/ Under normal operation, all logging messages generated server-side\n+        \/\/ are due to compilation requests. These logging messages should\n+        \/\/ be relayed back to the requesting client rather than written to the\n+        \/\/ server log. The only messages that should be written to the server\n+        \/\/ log (in production mode) should be errors,\n+        Log.setLogForCurrentThread(errorLog = new LazyInitFileLog(\"server.log\"));\n+        Log.setLogLevel(ERROR); \/\/ should be set to ERROR.\n+\n+        \/\/ Make sure no exceptions go under the radar\n+        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n+            Log.setLogForCurrentThread(errorLog);\n+            Log.error(e);\n+        });\n+\n+        \/\/ Inevitably someone will try to print messages using System.{out,err}.\n+        \/\/ Make sure this output also ends up in the log.\n+        System.setOut(new PrintStream(new LoggingOutputStream(System.out, INFO, \"[stdout] \")));\n+        System.setErr(new PrintStream(new LoggingOutputStream(System.err, ERROR, \"[stderr] \")));\n+\n+        \/\/ Any options other than --startserver?\n+        if (args.length > 1) {\n+            Log.error(\"When spawning a background server, only a single --startserver argument is allowed.\");\n+            return Result.CMDERR.exitCode;\n+        }\n+\n+        int exitCode;\n+        try {\n+            SjavacServer server = new SjavacServer(args[0]);\n+            exitCode = server.startServer();\n+        } catch (IOException | InterruptedException ex) {\n+            ex.printStackTrace();\n+            exitCode = Result.ERROR.exitCode;\n+        }\n+\n+        return exitCode;\n+    }\n+\n+    public static LazyInitFileLog getErrorLog() {\n+        return errorLog;\n+    }\n+}\n","filename":"make\/langtools\/tools\/javacserver\/server\/ServerMain.java","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,5 +26,1 @@\n-package com.sun.tools.sjavac.server;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-\n-import java.io.Writer;\n+package javacserver.server;\n@@ -32,0 +28,1 @@\n+import javacserver.Result;\n","filename":"make\/langtools\/tools\/javacserver\/server\/Sjavac.java","additions":3,"deletions":6,"binary":false,"changes":9,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/Sjavac.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac.server;\n+package javacserver.server;\n@@ -29,1 +29,0 @@\n-import java.io.FileWriter;\n@@ -31,2 +30,0 @@\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n@@ -43,7 +40,5 @@\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Util;\n-import com.sun.tools.sjavac.client.PortFileInaccessibleException;\n-import com.sun.tools.sjavac.comp.PooledSjavac;\n-import com.sun.tools.sjavac.comp.SjavacImpl;\n+import javacserver.Log;\n+import javacserver.Result;\n+import javacserver.Util;\n+import javacserver.comp.PooledSjavac;\n+import javacserver.comp.SjavacImpl;\n","filename":"make\/langtools\/tools\/javacserver\/server\/SjavacServer.java","additions":7,"deletions":12,"binary":false,"changes":19,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/SjavacServer.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package com.sun.tools.sjavac.server;\n+package javacserver.server;\n","filename":"make\/langtools\/tools\/javacserver\/server\/Terminable.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/Terminable.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n-package com.sun.tools.sjavac.server.log;\n-\n-import com.sun.tools.sjavac.Log;\n+package javacserver.server.log;\n@@ -37,0 +35,2 @@\n+import javacserver.Log;\n+\n","filename":"make\/langtools\/tools\/javacserver\/server\/log\/LazyInitFileLog.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/log\/LazyInitFileLog.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,1 @@\n-package com.sun.tools.sjavac.server.log;\n-\n-import com.sun.tools.sjavac.Log;\n+package javacserver.server.log;\n@@ -35,0 +33,2 @@\n+import javacserver.Log;\n+\n","filename":"make\/langtools\/tools\/javacserver\/server\/log\/LoggingOutputStream.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/log\/LoggingOutputStream.java","status":"renamed"},{"patch":"@@ -217,2 +217,0 @@\n-        } else if (fm.getClass().getName().equals(\"com.sun.tools.sjavac.comp.SmartFileManager\")) {\n-            useCtProps = !options.isSet(\"ignore.symbol.file\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,299 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The build state class captures the source code and generated artifacts\n- * from a build. There are usually two build states, the previous one (prev),\n- * loaded from the javac_state file, and the current one (now).\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class BuildState {\n-    private Map<String,Module> modules = new HashMap<>();\n-    private Map<String,Package> packages = new HashMap<>();\n-    private Map<String,Source> sources = new HashMap<>();\n-    private Map<String,File> artifacts = new HashMap<>();\n-    \/\/ Map from package to a set of packages that depend on said package.\n-    private Map<String,Set<String>> dependents = new HashMap<>();\n-\n-    public  Map<String,Module> modules() { return modules; }\n-    public  Map<String,Package> packages() { return packages; }\n-    public  Map<String,Source> sources() { return sources; }\n-    public  Map<String,File> artifacts() { return artifacts; }\n-    public  Map<String,Set<String>> dependents() { return dependents; }\n-\n-    \/**\n-     * Lookup a module from a name. Create the module if it does\n-     * not exist yet.\n-     *\/\n-    public Module lookupModule(String mod) {\n-        Module m = modules.get(mod);\n-        if (m == null) {\n-            m = new Module(mod, \"???\");\n-            modules.put(mod, m);\n-        }\n-        return m;\n-    }\n-\n-    \/**\n-     * Find a module from a given package name. For example:\n-     * The package name \"base:java.lang\" will fetch the module named \"base\".\n-     * The package name \":java.net\" will fetch the default module.\n-     *\/\n-    Module findModuleFromPackageName(String pkg) {\n-        int cp = pkg.indexOf(':');\n-        Assert.check(cp != -1, \"Could not find package name\");\n-        String mod = pkg.substring(0, cp);\n-        return lookupModule(mod);\n-    }\n-\n-    \/**\n-     * Store references to all packages, sources and artifacts for all modules\n-     * into the build state. I.e. flatten the module tree structure\n-     * into global maps stored in the BuildState for easy access.\n-     *\n-     * @param m The set of modules.\n-     *\/\n-    public void flattenPackagesSourcesAndArtifacts(Map<String,Module> m) {\n-        modules = m;\n-        \/\/ Extract all the found packages.\n-        for (Module i : modules.values()) {\n-            for (Map.Entry<String,Package> j : i.packages().entrySet()) {\n-                Package p = packages.get(j.getKey());\n-                \/\/ Check that no two different packages are stored under same name.\n-                Assert.check(p == null || p == j.getValue());\n-                if (p == null) {\n-                    p = j.getValue();\n-                    packages.put(j.getKey(),j.getValue());\n-                }\n-                for (Map.Entry<String,Source> k : p.sources().entrySet()) {\n-                    Source s = sources.get(k.getKey());\n-                    \/\/ Check that no two different sources are stored under same name.\n-                    Assert.check(s == null || s == k.getValue());\n-                    if (s == null) {\n-                        s = k.getValue();\n-                        sources.put(k.getKey(), k.getValue());\n-                    }\n-                }\n-                for (Map.Entry<String,File> g : p.artifacts().entrySet()) {\n-                    File f = artifacts.get(g.getKey());\n-                    \/\/ Check that no two artifacts are stored under the same file.\n-                    Assert.check(f == null || f == g.getValue());\n-                    if (f == null) {\n-                        f = g.getValue();\n-                        artifacts.put(g.getKey(), g.getValue());\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Store references to all artifacts found in the module tree into the maps\n-     * stored in the build state.\n-     *\n-     * @param m The set of modules.\n-     *\/\n-    public void flattenArtifacts(Map<String,Module> m) {\n-        modules = m;\n-        \/\/ Extract all the found packages.\n-        for (Module i : modules.values()) {\n-            for (Map.Entry<String,Package> j : i.packages().entrySet()) {\n-                Package p = packages.get(j.getKey());\n-                \/\/ Check that no two different packages are stored under same name.\n-                Assert.check(p == null || p == j.getValue());\n-                p = j.getValue();\n-                packages.put(j.getKey(),j.getValue());\n-                for (Map.Entry<String,File> g : p.artifacts().entrySet()) {\n-                    File f = artifacts.get(g.getKey());\n-                    \/\/ Check that no two artifacts are stored under the same file.\n-                    Assert.check(f == null || f == g.getValue());\n-                    artifacts.put(g.getKey(), g.getValue());\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Calculate the package dependents (ie the reverse of the dependencies).\n-     *\/\n-    public void calculateDependents() {\n-        dependents = new HashMap<>();\n-\n-        for (String s : packages.keySet()) {\n-            Package p = packages.get(s);\n-\n-            \/\/ Collect all dependencies of the classes in this package\n-            Set<String> deps = p.typeDependencies()  \/\/ maps fqName -> set of dependencies\n-                                .values()\n-                                .stream()\n-                                .reduce(Collections.emptySet(), Util::union);\n-\n-            \/\/ Now reverse the direction\n-\n-            for (String dep : deps) {\n-                \/\/ Add the dependent information to the global dependent map.\n-                String depPkgStr = \":\" + dep.substring(0, dep.lastIndexOf('.'));\n-                dependents.merge(depPkgStr, Collections.singleton(s), Util::union);\n-\n-                \/\/ Also add the dependent information to the package specific map.\n-                \/\/ Normally, you do not compile java.lang et al. Therefore\n-                \/\/ there are several packages that p depends upon that you\n-                \/\/ do not have in your state database. This is perfectly fine.\n-                Package dp = packages.get(depPkgStr);\n-                if (dp != null) {\n-                    \/\/ But this package did exist in the state database.\n-                    dp.addDependent(p.name());\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Verify that the setModules method above did the right thing when\n-     * running through the {@literal module->package->source} structure.\n-     *\/\n-    public void checkInternalState(String msg, boolean linkedOnly, Map<String,Source> srcs) {\n-        boolean baad = false;\n-        Map<String,Source> original = new HashMap<>();\n-        Map<String,Source> calculated = new HashMap<>();\n-\n-        for (String s : sources.keySet()) {\n-            Source ss = sources.get(s);\n-            if (ss.isLinkedOnly() == linkedOnly) {\n-                calculated.put(s,ss);\n-            }\n-        }\n-        for (String s : srcs.keySet()) {\n-            Source ss = srcs.get(s);\n-            if (ss.isLinkedOnly() == linkedOnly) {\n-                original.put(s,ss);\n-            }\n-        }\n-        if (original.size() != calculated.size()) {\n-            Log.error(\"INTERNAL ERROR \"+msg+\" original and calculated are not the same size!\");\n-            baad = true;\n-        }\n-        if (!original.keySet().equals(calculated.keySet())) {\n-            Log.error(\"INTERNAL ERROR \"+msg+\" original and calculated do not have the same domain!\");\n-            baad = true;\n-        }\n-        if (!baad) {\n-            for (String s : original.keySet()) {\n-                Source s1 = original.get(s);\n-                Source s2 = calculated.get(s);\n-                if (s1 == null || s2 == null || !s1.equals(s2)) {\n-                    Log.error(\"INTERNAL ERROR \"+msg+\" original and calculated have differing elements for \"+s);\n-                }\n-                baad = true;\n-            }\n-        }\n-        if (baad) {\n-            for (String s : original.keySet()) {\n-                Source ss = original.get(s);\n-                Source sss = calculated.get(s);\n-                if (sss == null) {\n-                    Log.error(\"The file \"+s+\" does not exist in calculated tree of sources.\");\n-                }\n-            }\n-            for (String s : calculated.keySet()) {\n-                Source ss = calculated.get(s);\n-                Source sss = original.get(s);\n-                if (sss == null) {\n-                    Log.error(\"The file \"+s+\" does not exist in original set of found sources.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Load a module from the javac state file.\n-     *\/\n-    public Module loadModule(String l) {\n-        Module m = Module.load(l);\n-        modules.put(m.name(), m);\n-        return m;\n-    }\n-\n-    \/**\n-     * Load a package from the javac state file.\n-     *\/\n-    public Package loadPackage(Module lastModule, String l) {\n-        Package p = Package.load(lastModule, l);\n-        lastModule.addPackage(p);\n-        packages.put(p.name(), p);\n-        return p;\n-    }\n-\n-    \/**\n-     * Load a source from the javac state file.\n-     *\/\n-    public Source loadSource(Package lastPackage, String l, boolean is_generated) {\n-        Source s = Source.load(lastPackage, l, is_generated);\n-        lastPackage.addSource(s);\n-        sources.put(s.name(), s);\n-        return s;\n-    }\n-\n-    \/**\n-     * During an incremental compile we need to copy the old javac state\n-     * information about packages that were not recompiled.\n-     *\/\n-    public void copyPackagesExcept(BuildState prev, Set<String> recompiled, Set<String> removed) {\n-        for (String pkg : prev.packages().keySet()) {\n-            \/\/ Do not copy recompiled or removed packages.\n-            if (recompiled.contains(pkg) || removed.contains(pkg))\n-                continue;\n-\n-            Module mnew = findModuleFromPackageName(pkg);\n-            Package pprev = prev.packages().get(pkg);\n-\n-            \/\/ Even though we haven't recompiled this package, we may have\n-            \/\/ information about its public API: It may be a classpath dependency\n-            if (packages.containsKey(pkg)) {\n-                pprev.setPubapi(PubApi.mergeTypes(pprev.getPubApi(),\n-                                                  packages.get(pkg).getPubApi()));\n-            }\n-\n-            mnew.addPackage(pprev);\n-            \/\/ Do not forget to update the flattened data. (See JDK-8071904)\n-            packages.put(pkg, pprev);\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/BuildState.java","additions":0,"deletions":299,"binary":false,"changes":299,"status":"deleted"},{"patch":"@@ -1,159 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.BufferedWriter;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.Set;\n-\n-import com.sun.tools.sjavac.comp.CompilationService;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The clean properties transform should not be necessary.\n- * Eventually we will cleanup the property file sources in the OpenJDK instead.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CleanProperties implements Transformer {\n-    public void setExtra(String e) {\n-        \/\/ Any extra information is ignored for clean properties.\n-    }\n-\n-    public void setExtra(Options a) {\n-        \/\/ Any extra information is ignored for clean properties.\n-    }\n-\n-    public boolean transform(CompilationService sjavac,\n-                             Map<String,Set<URI>> pkgSrcs,\n-                             Set<URI>             visibleSrcs,\n-                             Map<String,Set<String>> oldPackageDependencies,\n-                             URI destRoot,\n-                             Map<String,Set<URI>>    packageArtifacts,\n-                             Map<String, Map<String, Set<String>>> packageDependencies,\n-                             Map<String, Map<String, Set<String>>> packageCpDependencies,\n-                             Map<String, PubApi> packagePublicApis,\n-                             Map<String, PubApi> dependencyPublicApis,\n-                             int debugLevel,\n-                             boolean incremental,\n-                             int numCores) {\n-        boolean rc = true;\n-        for (String pkgName : pkgSrcs.keySet()) {\n-            String pkgNameF = pkgName.replace('.',File.separatorChar);\n-            for (URI u : pkgSrcs.get(pkgName)) {\n-                File src = new File(u);\n-                boolean r = clean(pkgName, pkgNameF, src, new File(destRoot), debugLevel,\n-                                  packageArtifacts);\n-                if (r == false) {\n-                    rc = false;\n-                }\n-            }\n-        }\n-        return rc;\n-    }\n-\n-    boolean clean(String pkgName,\n-                  String pkgNameF,\n-                  File src,\n-                  File destRoot,\n-                  int debugLevel,\n-                  Map<String,Set<URI>> packageArtifacts) {\n-        \/\/ Load the properties file.\n-        Properties p = new Properties();\n-        try {\n-            p.load(new FileInputStream(src));\n-        } catch (IOException e) {\n-            Log.error(\"Error reading file \"+src.getPath());\n-            return false;\n-        }\n-\n-        \/\/ Sort the properties in increasing key order.\n-        List<String> sortedKeys = new ArrayList<>();\n-        for (Object key : p.keySet()) {\n-            sortedKeys.add((String)key);\n-        }\n-        Collections.sort(sortedKeys);\n-\n-        \/\/ Collect the properties into a string buffer.\n-        StringBuilder data = new StringBuilder();\n-        for (String key : sortedKeys) {\n-            data.append(CompileProperties.escape(key))\n-                .append(\":\")\n-                .append(CompileProperties.escape((String) p.get(key)))\n-                .append(\"\\n\");\n-        }\n-\n-        String destFilename = destRoot.getPath()+File.separator+pkgNameF+File.separator+src.getName();\n-        File dest = new File(destFilename);\n-\n-        \/\/ Make sure the dest directories exist.\n-        if (!dest.getParentFile().isDirectory()) {\n-            if (!dest.getParentFile().mkdirs()) {\n-                Log.error(\"Could not create the directory \"+dest.getParentFile().getPath());\n-                return false;\n-            }\n-        }\n-\n-        Set<URI> as = packageArtifacts.get(pkgName);\n-        if (as == null) {\n-            as = new HashSet<>();\n-            packageArtifacts.put(pkgName, as);\n-        }\n-        as.add(dest.toURI());\n-\n-        if (dest.exists() && dest.lastModified() > src.lastModified()) {\n-            \/\/ A cleaned property file exists, and its timestamp is newer than the source.\n-            \/\/ Assume that we do not need to clean!\n-            \/\/ Thus we are done.\n-            return true;\n-        }\n-\n-        Log.info(\"Cleaning property file \"+pkgNameF+File.separator+src.getName());\n-        try (Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dest)))) {\n-            writer.write(data.toString());\n-        } catch ( IOException e ) {\n-            Log.error(\"Could not write file \"+dest.getPath());\n-            return false;\n-        }\n-        return true;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/CleanProperties.java","additions":0,"deletions":159,"binary":false,"changes":159,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.net.URI;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-\/**\n- * A compile chunk is a list of sources\/packages to be compiled. Possibly a subset of\n- * the total number of sources\/packages to be compiled for this sjavac invocation.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CompileChunk implements Comparable<CompileChunk> {\n-    public int numPackages;\n-    public int numDependents;\n-    public Set<URI> srcs = new HashSet<>();\n-    public StringBuilder pkgNames = new StringBuilder();\n-    public String pkgFromTos = \"\";\n-\n-    public int compareTo(CompileChunk c) {\n-        if (numDependents == c.numDependents) return 0;\n-        if (numDependents > c.numDependents) return -1;\n-        return -1;\n-    }\n-\n-    boolean equal(CompileChunk c) {\n-        return numDependents == c.numDependents;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/CompileChunk.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,355 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Random;\n-import java.util.Set;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.comp.CompilationService;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-import com.sun.tools.sjavac.server.CompilationSubResult;\n-import com.sun.tools.sjavac.server.SysInfo;\n-\n-\/**\n- * This transform compiles a set of packages containing Java sources.\n- * The compile request is divided into separate sets of source files.\n- * For each set a separate request thread is dispatched to a javac server\n- * and the meta data is accumulated. The number of sets correspond more or\n- * less to the number of cores. Less so now, than it will in the future.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own\n- * risk.  This code and its internal interfaces are subject to change\n- * or deletion without notice.<\/b><\/p>\n- *\/\n-public class CompileJavaPackages implements Transformer {\n-\n-    \/\/ The current limited sharing of data between concurrent JavaCompilers\n-    \/\/ in the server will not give speedups above 3 cores. Thus this limit.\n-    \/\/ We hope to improve this in the future.\n-    static final int limitOnConcurrency = 3;\n-\n-    Options args;\n-\n-    public void setExtra(String e) {\n-    }\n-\n-    public void setExtra(Options a) {\n-        args = a;\n-    }\n-\n-    public boolean transform(final CompilationService sjavac,\n-                             Map<String,Set<URI>> pkgSrcs,\n-                             final Set<URI>             visibleSources,\n-                             Map<String,Set<String>> oldPackageDependents,\n-                             URI destRoot,\n-                             final Map<String,Set<URI>>    packageArtifacts,\n-                             final Map<String,Map<String, Set<String>>> packageDependencies,\n-                             final Map<String,Map<String, Set<String>>> packageCpDependencies,\n-                             final Map<String, PubApi> packagePubapis,\n-                             final Map<String, PubApi> dependencyPubapis,\n-                             int debugLevel,\n-                             boolean incremental,\n-                             int numCores) {\n-\n-        Log.debug(\"Performing CompileJavaPackages transform...\");\n-\n-        boolean rc = true;\n-        boolean concurrentCompiles = true;\n-\n-        \/\/ Fetch the id.\n-        final String id = String.valueOf(new Random().nextInt());\n-        \/\/ Only keep portfile and sjavac settings..\n-        \/\/String psServerSettings = Util.cleanSubOptions(Util.set(\"portfile\",\"sjavac\",\"background\",\"keepalive\"), sjavac.serverSettings());\n-\n-        SysInfo sysinfo = sjavac.getSysInfo();\n-        int numMBytes = (int)(sysinfo.maxMemory \/ ((long)(1024*1024)));\n-        Log.debug(\"Server reports \"+numMBytes+\"MiB of memory and \"+sysinfo.numCores+\" cores\");\n-\n-        if (numCores <= 0) {\n-            \/\/ Set the requested number of cores to the number of cores on the server.\n-            numCores = sysinfo.numCores;\n-            Log.debug(\"Number of jobs not explicitly set, defaulting to \"+sysinfo.numCores);\n-        } else if (sysinfo.numCores < numCores) {\n-            \/\/ Set the requested number of cores to the number of cores on the server.\n-            Log.debug(\"Limiting jobs from explicitly set \"+numCores+\" to cores available on server: \"+sysinfo.numCores);\n-            numCores = sysinfo.numCores;\n-        } else {\n-            Log.debug(\"Number of jobs explicitly set to \"+numCores);\n-        }\n-        \/\/ More than three concurrent cores does not currently give a speedup, at least for compiling the jdk\n-        \/\/ in the OpenJDK. This will change in the future.\n-        int numCompiles = numCores;\n-        if (numCores > limitOnConcurrency) numCompiles = limitOnConcurrency;\n-        \/\/ Split the work up in chunks to compiled.\n-\n-        int numSources = 0;\n-        for (String s : pkgSrcs.keySet()) {\n-            Set<URI> ss = pkgSrcs.get(s);\n-            numSources += ss.size();\n-        }\n-\n-        int sourcesPerCompile = numSources \/ numCompiles;\n-\n-        \/\/ For 64 bit Java, it seems we can compile the OpenJDK 8800 files with a 1500M of heap\n-        \/\/ in a single chunk, with reasonable performance.\n-        \/\/ For 32 bit java, it seems we need 1G of heap.\n-        \/\/ Number experimentally determined when compiling the OpenJDK.\n-        \/\/ Includes space for reasonably efficient garbage collection etc,\n-        \/\/ Calculating backwards gives us a requirement of\n-        \/\/ 1500M\/8800 = 175 KiB for 64 bit platforms\n-        \/\/ and 1G\/8800 = 119 KiB for 32 bit platform\n-        \/\/ for each compile.....\n-        int kbPerFile = 175;\n-        String osarch = System.getProperty(\"os.arch\");\n-        String dataModel = System.getProperty(\"sun.arch.data.model\");\n-        if (\"32\".equals(dataModel)) {\n-            \/\/ For 32 bit platforms, assume it is slightly smaller\n-            \/\/ because of smaller object headers and pointers.\n-            kbPerFile = 119;\n-        }\n-        int numRequiredMBytes = (kbPerFile*numSources)\/1024;\n-        Log.debug(\"For os.arch \"+osarch+\" the empirically determined heap required per file is \"+kbPerFile+\"KiB\");\n-        Log.debug(\"Server has \"+numMBytes+\"MiB of heap.\");\n-        Log.debug(\"Heuristics say that we need \"+numRequiredMBytes+\"MiB of heap for all source files.\");\n-        \/\/ Perform heuristics to see how many cores we can use,\n-        \/\/ or if we have to the work serially in smaller chunks.\n-        if (numMBytes < numRequiredMBytes) {\n-            \/\/ Ouch, cannot fit even a single compile into the heap.\n-            \/\/ Split it up into several serial chunks.\n-            concurrentCompiles = false;\n-            \/\/ Limit the number of sources for each compile to 500.\n-            if (numSources < 500) {\n-                numCompiles = 1;\n-                sourcesPerCompile = numSources;\n-                Log.debug(\"Compiling as a single source code chunk to stay within heap size limitations!\");\n-            } else if (sourcesPerCompile > 500) {\n-                \/\/ This number is very low, and tuned to dealing with the OpenJDK\n-                \/\/ where the source is >very< circular! In normal application,\n-                \/\/ with less circularity the number could perhaps be increased.\n-                numCompiles = numSources \/ 500;\n-                sourcesPerCompile = numSources\/numCompiles;\n-                Log.debug(\"Compiling source as \"+numCompiles+\" code chunks serially to stay within heap size limitations!\");\n-            }\n-        } else {\n-            if (numCompiles > 1) {\n-                \/\/ Ok, we can fit at least one full compilation on the heap.\n-                float usagePerCompile = (float)numRequiredMBytes \/ ((float)numCompiles * (float)0.7);\n-                int usage = (int)(usagePerCompile * (float)numCompiles);\n-                Log.debug(\"Heuristics say that for \"+numCompiles+\" concurrent compiles we need \"+usage+\"MiB\");\n-                if (usage > numMBytes) {\n-                    \/\/ Ouch it does not fit. Reduce to a single chunk.\n-                    numCompiles = 1;\n-                    sourcesPerCompile = numSources;\n-                    \/\/ What if the relationship between number of compile_chunks and num_required_mbytes\n-                    \/\/ is not linear? Then perhaps 2 chunks would fit where 3 does not. Well, this is\n-                    \/\/ something to experiment upon in the future.\n-                    Log.debug(\"Limiting compile to a single thread to stay within heap size limitations!\");\n-                }\n-            }\n-        }\n-\n-        Log.debug(\"Compiling sources in \"+numCompiles+\" chunk(s)\");\n-\n-        \/\/ Create the chunks to be compiled.\n-        final CompileChunk[] compileChunks = createCompileChunks(pkgSrcs, oldPackageDependents,\n-                numCompiles, sourcesPerCompile);\n-\n-        if (Log.isDebugging()) {\n-            int cn = 1;\n-            for (CompileChunk cc : compileChunks) {\n-                Log.debug(\"Chunk \"+cn+\" for \"+id+\" ---------------\");\n-                cn++;\n-                for (URI u : cc.srcs) {\n-                    Log.debug(\"\"+u);\n-                }\n-            }\n-        }\n-\n-        long start = System.currentTimeMillis();\n-\n-        \/\/ Prepare compilation calls\n-        List<Callable<CompilationSubResult>> compilationCalls = new ArrayList<>();\n-        final Object lock = new Object();\n-        for (int i = 0; i < numCompiles; i++) {\n-            CompileChunk cc = compileChunks[i];\n-            if (cc.srcs.isEmpty()) {\n-                continue;\n-            }\n-\n-            String chunkId = id + \"-\" + String.valueOf(i);\n-            Log log = Log.get();\n-            compilationCalls.add(() -> {\n-                Log.setLogForCurrentThread(log);\n-                CompilationSubResult result = sjavac.compile(\"n\/a\",\n-                                                             chunkId,\n-                                                             args.prepJavacArgs(),\n-                                                             Collections.emptyList(),\n-                                                             cc.srcs,\n-                                                             visibleSources);\n-                synchronized (lock) {\n-                    Util.getLines(result.stdout).forEach(Log::info);\n-                    Util.getLines(result.stderr).forEach(Log::error);\n-                }\n-                return result;\n-            });\n-        }\n-\n-        \/\/ Perform compilations and collect results\n-        List<CompilationSubResult> subResults = new ArrayList<>();\n-        List<Future<CompilationSubResult>> futs = new ArrayList<>();\n-        ExecutorService exec = Executors.newFixedThreadPool(concurrentCompiles ? compilationCalls.size() : 1);\n-        for (Callable<CompilationSubResult> compilationCall : compilationCalls) {\n-            futs.add(exec.submit(compilationCall));\n-        }\n-        for (Future<CompilationSubResult> fut : futs) {\n-            try {\n-                subResults.add(fut.get());\n-            } catch (ExecutionException ee) {\n-                Log.error(\"Compilation failed: \" + ee.getMessage());\n-                Log.error(ee);\n-            } catch (InterruptedException ie) {\n-                Log.error(\"Compilation interrupted: \" + ie.getMessage());\n-                Log.error(ie);\n-                Thread.currentThread().interrupt();\n-            }\n-        }\n-        exec.shutdownNow();\n-\n-        \/\/ Process each sub result\n-        for (CompilationSubResult subResult : subResults) {\n-            for (String pkg : subResult.packageArtifacts.keySet()) {\n-                Set<URI> pkgArtifacts = subResult.packageArtifacts.get(pkg);\n-                packageArtifacts.merge(pkg, pkgArtifacts, Util::union);\n-            }\n-\n-            for (String pkg : subResult.packageDependencies.keySet()) {\n-                packageDependencies.putIfAbsent(pkg, new HashMap<>());\n-                packageDependencies.get(pkg).putAll(subResult.packageDependencies.get(pkg));\n-            }\n-\n-            for (String pkg : subResult.packageCpDependencies.keySet()) {\n-                packageCpDependencies.putIfAbsent(pkg, new HashMap<>());\n-                packageCpDependencies.get(pkg).putAll(subResult.packageCpDependencies.get(pkg));\n-            }\n-\n-            for (String pkg : subResult.packagePubapis.keySet()) {\n-                packagePubapis.merge(pkg, subResult.packagePubapis.get(pkg), PubApi::mergeTypes);\n-            }\n-\n-            for (String pkg : subResult.dependencyPubapis.keySet()) {\n-                dependencyPubapis.merge(pkg, subResult.dependencyPubapis.get(pkg), PubApi::mergeTypes);\n-            }\n-\n-            \/\/ Check the return values.\n-            if (subResult.result != Result.OK) {\n-                rc = false;\n-            }\n-        }\n-\n-        long duration = System.currentTimeMillis() - start;\n-        long minutes = duration\/60000;\n-        long seconds = (duration-minutes*60000)\/1000;\n-        Log.debug(\"Compilation of \"+numSources+\" source files took \"+minutes+\"m \"+seconds+\"s\");\n-\n-        return rc;\n-    }\n-\n-    \/**\n-     * Split up the sources into compile chunks. If old package dependents information\n-     * is available, sort the order of the chunks into the most dependent first!\n-     * (Typically that chunk contains the java.lang package.) In the future\n-     * we could perhaps improve the heuristics to put the sources into even more sensible chunks.\n-     * Now the package are simple sorted in alphabetical order and chunked, then the chunks\n-     * are sorted on how dependent they are.\n-     *\n-     * @param pkgSrcs The sources to compile.\n-     * @param oldPackageDependents Old package dependents, if non-empty, used to sort the chunks.\n-     * @param numCompiles The number of chunks.\n-     * @param sourcesPerCompile The number of sources per chunk.\n-     * @return\n-     *\/\n-    CompileChunk[] createCompileChunks(Map<String,Set<URI>> pkgSrcs,\n-                                       Map<String,Set<String>> oldPackageDependents,\n-                                       int numCompiles,\n-                                       int sourcesPerCompile) {\n-\n-        CompileChunk[] compileChunks = new CompileChunk[numCompiles];\n-        for (int i=0; i<compileChunks.length; ++i) {\n-            compileChunks[i] = new CompileChunk();\n-        }\n-\n-        \/\/ Now go through the packages and spread out the source on the different chunks.\n-        int ci = 0;\n-        \/\/ Sort the packages\n-        String[] packageNames = pkgSrcs.keySet().toArray(new String[0]);\n-        Arrays.sort(packageNames);\n-        String from = null;\n-        for (String pkgName : packageNames) {\n-            CompileChunk cc = compileChunks[ci];\n-            Set<URI> s = pkgSrcs.get(pkgName);\n-            if (cc.srcs.size()+s.size() > sourcesPerCompile && ci < numCompiles-1) {\n-                from = null;\n-                ci++;\n-                cc = compileChunks[ci];\n-            }\n-            cc.numPackages++;\n-            cc.srcs.addAll(s);\n-\n-            \/\/ Calculate nice package names to use as information when compiling.\n-            String justPkgName = Util.justPackageName(pkgName);\n-            \/\/ Fetch how many packages depend on this package from the old build state.\n-            Set<String> ss = oldPackageDependents.get(pkgName);\n-            if (ss != null) {\n-                \/\/ Accumulate this information onto this chunk.\n-                cc.numDependents += ss.size();\n-            }\n-            if (from == null || from.trim().equals(\"\")) from = justPkgName;\n-            cc.pkgNames.append(justPkgName+\"(\"+s.size()+\") \");\n-            cc.pkgFromTos = from+\" to \"+justPkgName;\n-        }\n-        \/\/ If we are compiling serially, sort the chunks, so that the chunk (with the most dependents) (usually the chunk\n-        \/\/ containing java.lang.Object, is to be compiled first!\n-        \/\/ For concurrent compilation, this does not matter.\n-        Arrays.sort(compileChunks);\n-        return compileChunks;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/CompileJavaPackages.java","additions":0,"deletions":355,"binary":false,"changes":355,"status":"deleted"},{"patch":"@@ -1,231 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.BufferedWriter;\n-import java.io.File;\n-import java.io.FileInputStream;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.PrintStream;\n-import java.io.Writer;\n-import java.net.URI;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Properties;\n-import java.util.Set;\n-\n-import com.sun.tools.sjavac.comp.CompilationService;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * Compile properties transform a properties file into a Java source file.\n- * Java has built in support for reading properties from either a text file\n- * in the source or a compiled java source file.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CompileProperties implements Transformer {\n-    \/\/ Any extra information passed from the command line, for example if:\n-    \/\/ -tr .proppp=com.sun.tools.javac.smart.CompileProperties,sun.util.resources.LocaleNamesBundle\n-    \/\/ then extra will be \"sun.util.resources.LocaleNamesBundle\"\n-    String extra;\n-\n-    public void setExtra(String e) {\n-        extra = e;\n-    }\n-\n-    public void setExtra(Options a) {\n-    }\n-\n-    public boolean transform(CompilationService compilationService,\n-                             Map<String,Set<URI>> pkgSrcs,\n-                             Set<URI>             visibleSrcs,\n-                             Map<String,Set<String>> oldPackageDependents,\n-                             URI destRoot,\n-                             Map<String,Set<URI>>    packageArtifacts,\n-                             Map<String,Map<String, Set<String>>> packageDependencies,\n-                             Map<String,Map<String, Set<String>>> packageCpDependencies,\n-                             Map<String, PubApi> packagePublicApis,\n-                             Map<String, PubApi> dependencyPublicApis,\n-                             int debugLevel,\n-                             boolean incremental,\n-                             int numCores) {\n-        boolean rc = true;\n-        for (String pkgName : pkgSrcs.keySet()) {\n-            String pkgNameF = Util.toFileSystemPath(pkgName);\n-            for (URI u : pkgSrcs.get(pkgName)) {\n-                File src = new File(u);\n-                boolean r = compile(pkgName, pkgNameF, src, new File(destRoot), debugLevel,\n-                                    packageArtifacts);\n-                if (r == false) {\n-                    rc = false;\n-                }\n-            }\n-        }\n-        return rc;\n-    }\n-\n-    boolean compile(String pkgName, String pkgNameF, File src, File destRoot, int debugLevel,\n-                    Map<String,Set<URI>> packageArtifacts)\n-    {\n-        String superClass = \"java.util.ListResourceBundle\";\n-\n-        if (extra != null) {\n-            superClass = extra;\n-        }\n-        \/\/ Load the properties file.\n-        Properties p = new Properties();\n-        try {\n-            p.load(new FileInputStream(src));\n-        } catch (IOException e) {\n-            Log.error(\"Error reading file \"+src.getPath());\n-            return false;\n-        }\n-\n-        \/\/ Calculate the name of the Java source file to be generated.\n-        int dp = src.getName().lastIndexOf(\".\");\n-        String classname = src.getName().substring(0,dp);\n-\n-        \/\/ Sort the properties in increasing key order.\n-        List<String> sortedKeys = new ArrayList<>();\n-        for (Object key : p.keySet()) {\n-            sortedKeys.add((String)key);\n-        }\n-        Collections.sort(sortedKeys);\n-        Iterator<String> keys = sortedKeys.iterator();\n-\n-        \/\/ Collect the properties into a string buffer.\n-        StringBuilder data = new StringBuilder();\n-        while (keys.hasNext()) {\n-            String key = keys.next();\n-            data.append(\"            { \\\"\" + escape(key) + \"\\\", \\\"\" +\n-                        escape((String)p.get(key)) + \"\\\" },\\n\");\n-        }\n-\n-        \/\/ Create dest file name. It is derived from the properties file name.\n-        String destFilename = destRoot.getPath()+File.separator+pkgNameF+File.separator+classname+\".java\";\n-        File dest = new File(destFilename);\n-\n-        \/\/ Make sure the dest directories exist.\n-        if (!dest.getParentFile().isDirectory()) {\n-            if (!dest.getParentFile().mkdirs()) {\n-                Log.error(\"Could not create the directory \"+dest.getParentFile().getPath());\n-                return false;\n-            }\n-        }\n-\n-        Set<URI> as = packageArtifacts.get(pkgName);\n-        if (as == null) {\n-            as = new HashSet<>();\n-            packageArtifacts.put(pkgName, as);\n-        }\n-        as.add(dest.toURI());\n-\n-        if (dest.exists() && dest.lastModified() > src.lastModified()) {\n-            \/\/ A generated file exists, and its timestamp is newer than the source.\n-            \/\/ Assume that we do not need to regenerate the dest file!\n-            \/\/ Thus we are done.\n-            return true;\n-        }\n-\n-        String packageString = \"package \" + pkgNameF.replace(File.separatorChar,'.') + \";\\n\\n\";\n-\n-        Log.info(\"Compiling property file \"+pkgNameF+File.separator+src.getName());\n-        try (Writer writer = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(dest)))) {\n-            MessageFormat format = new MessageFormat(FORMAT);\n-            writer.write(format.format(new Object[] { packageString, classname, superClass, data }));\n-        } catch ( IOException e ) {\n-            Log.error(\"Could not write file \"+dest.getPath());\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    private static final String FORMAT =\n-            \"{0}\" +\n-            \"public final class {1} extends {2} '{'\\n\" +\n-            \"    protected final Object[][] getContents() '{'\\n\" +\n-            \"        return new Object[][] '{'\\n\" +\n-            \"{3}\" +\n-            \"        };\\n\" +\n-            \"    }\\n\" +\n-            \"}\\n\";\n-\n-    public static String escape(String theString) {\n-        int len = theString.length();\n-        StringBuilder outBuffer = new StringBuilder(len*2);\n-\n-        for(int x=0; x<len; x++) {\n-            char aChar = theString.charAt(x);\n-            switch(aChar) {\n-                case '\\\\':outBuffer.append('\\\\'); outBuffer.append('\\\\');\n-                break;\n-                case '\\t':outBuffer.append('\\\\'); outBuffer.append('t');\n-                break;\n-                case '\\n':outBuffer.append('\\\\'); outBuffer.append('n');\n-                break;\n-                case '\\r':outBuffer.append('\\\\'); outBuffer.append('r');\n-                break;\n-                case '\\f':outBuffer.append('\\\\'); outBuffer.append('f');\n-                break;\n-                default:\n-                    if ((aChar < 0x0020) || (aChar > 0x007e)) {\n-                        outBuffer.append('\\\\');\n-                        outBuffer.append('u');\n-                        outBuffer.append(toHex((aChar >> 12) & 0xF));\n-                        outBuffer.append(toHex((aChar >>  8) & 0xF));\n-                        outBuffer.append(toHex((aChar >>  4) & 0xF));\n-                        outBuffer.append(toHex( aChar        & 0xF));\n-                    } else {\n-                        if (aChar == '\"') {\n-                            outBuffer.append('\\\\');\n-                        }\n-                        outBuffer.append(aChar);\n-                    }\n-            }\n-        }\n-        return outBuffer.toString();\n-    }\n-\n-    private static char toHex(int nibble) {\n-        return hexDigit[(nibble & 0xF)];\n-    }\n-\n-    private static final char[] hexDigit = {\n-        '0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'\n-    };\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/CompileProperties.java","additions":0,"deletions":231,"binary":false,"changes":231,"status":"deleted"},{"patch":"@@ -1,118 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.Files;\n-import java.nio.file.StandardCopyOption;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import com.sun.tools.sjavac.comp.CompilationService;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The copy file transform simply copies a matching file from -src to -d .\n- * Such files are typically images, xml documents and other data files.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CopyFile implements Transformer {\n-\n-    public void setExtra(String e) {\n-    }\n-\n-    public void setExtra(Options a) {\n-    }\n-\n-    public boolean transform(CompilationService compilationService,\n-                             Map<String,Set<URI>> pkgSrcs,\n-                             Set<URI> visibleSrcs,\n-                             Map<String,Set<String>> oldPackageDependents,\n-                             URI destRoot,\n-                             Map<String,Set<URI>>    packageArtifacts,\n-                             Map<String,Map<String, Set<String>>> packageDependencies,\n-                             Map<String,Map<String, Set<String>>> packageCpDependencies,\n-                             Map<String, PubApi> packagePubapis,\n-                             Map<String, PubApi> dependencyPubapis,\n-                             int debugLevel,\n-                             boolean incremental,\n-                             int numCores)\n-    {\n-        boolean rc = true;\n-        String dest_filename;\n-        File dest;\n-\n-        for (String pkgName : pkgSrcs.keySet()) {\n-            String pkgNameF = Util.toFileSystemPath(pkgName);\n-            for (URI u : pkgSrcs.get(pkgName)) {\n-                File src = new File(u);\n-                File destDir;\n-                destDir = new File(destRoot.getPath()+File.separator+pkgNameF);\n-                dest_filename = destRoot.getPath()+File.separator+pkgNameF+File.separator+src.getName();\n-                dest = new File(dest_filename);\n-\n-                if (!destDir.isDirectory()) {\n-                    if (!destDir.mkdirs()) {\n-                       Log.error(\"Error: The copier could not create the directory \"+\n-                                           destDir.getPath());\n-                        return false;\n-                    }\n-                }\n-\n-                Set<URI> as = packageArtifacts.get(pkgName);\n-                if (as == null) {\n-                    as = new HashSet<>();\n-                    packageArtifacts.put(pkgName, as);\n-                }\n-                as.add(dest.toURI());\n-\n-                if (dest.exists() && dest.lastModified() > src.lastModified()) {\n-                    \/\/ A copied file exists, and its timestamp is newer than the source.\n-                    continue;\n-                }\n-\n-                Log.info(\"Copying \"+pkgNameF+File.separator+src.getName());\n-\n-                try {\n-                    Files.copy(src.toPath(), dest.toPath(), StandardCopyOption.REPLACE_EXISTING);\n-                }\n-                catch(IOException e){\n-                    Log.error(\"Could not copy the file \"+src.getPath()+\" to \"+dest.getPath());\n-                    rc = false;\n-                }\n-            }\n-        }\n-        return rc;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/CopyFile.java","additions":0,"deletions":118,"binary":false,"changes":118,"status":"deleted"},{"patch":"@@ -1,974 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.FileNotFoundException;\n-import java.io.FileReader;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.Writer;\n-import java.net.URI;\n-import java.nio.file.NoSuchFileException;\n-import java.text.SimpleDateFormat;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import com.sun.tools.sjavac.comp.CompilationService;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The javac state class maintains the previous (prev) and the current (now)\n- * build states and everything else that goes into the javac_state file.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class JavacState {\n-    \/\/ The arguments to the compile. If not identical, then it cannot\n-    \/\/ be an incremental build!\n-    String theArgs;\n-    \/\/ The number of cores limits how many threads are used for heavy concurrent work.\n-    int numCores;\n-\n-    \/\/ The bin_dir\/javac_state\n-    private File javacState;\n-\n-    \/\/ The previous build state is loaded from javac_state\n-    private BuildState prev;\n-    \/\/ The current build state is constructed during the build,\n-    \/\/ then saved as the new javac_state.\n-    private BuildState now;\n-\n-    \/\/ Something has changed in the javac_state. It needs to be saved!\n-    private boolean needsSaving;\n-    \/\/ If this is a new javac_state file, then do not print unnecessary messages.\n-    private boolean newJavacState;\n-\n-    \/\/ These are packages where something has changed and the package\n-    \/\/ needs to be recompiled. Actions that trigger recompilation:\n-    \/\/ * source belonging to the package has changed\n-    \/\/ * artifact belonging to the package is lost, or its timestamp has been changed.\n-    \/\/ * an unknown artifact has appeared, we simply delete it, but we also trigger a recompilation.\n-    \/\/ * a package that is tainted, taints all packages that depend on it.\n-    private Set<String> taintedPackages;\n-    \/\/ After a compile, the pubapis are compared with the pubapis stored in the javac state file.\n-    \/\/ Any packages where the pubapi differ are added to this set.\n-    \/\/ Later we use this set and the dependency information to taint dependent packages.\n-    private Set<String> packagesWithChangedPublicApis;\n-    \/\/ When a module-info.java file is changed, taint the module,\n-    \/\/ then taint all modules that depend on that that module.\n-    \/\/ A module dependency can occur directly through a require, or\n-    \/\/ indirectly through a module that does a public export for the first tainted module.\n-    \/\/ When all modules are tainted, then taint all packages belonging to these modules.\n-    \/\/ Then rebuild. It is perhaps possible (and valuable?) to do a more fine-grained examination of the\n-    \/\/ change in module-info.java, but that will have to wait.\n-    private Set<String> taintedModules;\n-    \/\/ The set of all packages that has been recompiled.\n-    \/\/ Copy over the javac_state for the packages that did not need recompilation,\n-    \/\/ verbatim from the previous (prev) to the new (now) build state.\n-    private Set<String> recompiledPackages;\n-\n-    \/\/ The output directories filled with tasty artifacts.\n-    private File binDir, gensrcDir, headerDir, stateDir;\n-\n-    \/\/ The current status of the file system.\n-    private Set<File> binArtifacts;\n-    private Set<File> gensrcArtifacts;\n-    private Set<File> headerArtifacts;\n-\n-    \/\/ The status of the sources.\n-    Set<Source> removedSources = null;\n-    Set<Source> addedSources = null;\n-    Set<Source> modifiedSources = null;\n-\n-    \/\/ Visible sources for linking. These are the only\n-    \/\/ ones that -sourcepath is allowed to see.\n-    Set<URI> visibleSrcs;\n-\n-    \/\/ Setup transform that always exist.\n-    private CompileJavaPackages compileJavaPackages = new CompileJavaPackages();\n-\n-    \/\/ Command line options.\n-    private Options options;\n-\n-    JavacState(Options op, boolean removeJavacState) {\n-        options = op;\n-        numCores = options.getNumCores();\n-        theArgs = options.getStateArgsString();\n-        binDir = Util.pathToFile(options.getDestDir());\n-        gensrcDir = Util.pathToFile(options.getGenSrcDir());\n-        headerDir = Util.pathToFile(options.getHeaderDir());\n-        stateDir = Util.pathToFile(options.getStateDir());\n-        javacState = new File(stateDir, \"javac_state\");\n-        if (removeJavacState && javacState.exists()) {\n-            javacState.delete();\n-        }\n-        newJavacState = false;\n-        if (!javacState.exists()) {\n-            newJavacState = true;\n-            \/\/ If there is no javac_state then delete the contents of all the artifact dirs!\n-            \/\/ We do not want to risk building a broken incremental build.\n-            \/\/ BUT since the makefiles still copy things straight into the bin_dir et al,\n-            \/\/ we avoid deleting files here, if the option --permit-unidentified-classes was supplied.\n-            if (!options.areUnidentifiedArtifactsPermitted()) {\n-                deleteContents(binDir);\n-                deleteContents(gensrcDir);\n-                deleteContents(headerDir);\n-            }\n-            needsSaving = true;\n-        }\n-        prev = new BuildState();\n-        now = new BuildState();\n-        taintedPackages = new HashSet<>();\n-        recompiledPackages = new HashSet<>();\n-        packagesWithChangedPublicApis = new HashSet<>();\n-    }\n-\n-    public BuildState prev() { return prev; }\n-    public BuildState now() { return now; }\n-\n-    \/**\n-     * Remove args not affecting the state.\n-     *\/\n-    static String[] removeArgsNotAffectingState(String[] args) {\n-        String[] out = new String[args.length];\n-        int j = 0;\n-        for (int i = 0; i<args.length; ++i) {\n-            if (args[i].equals(\"-j\")) {\n-                \/\/ Just skip it and skip following value\n-                i++;\n-            } else if (args[i].startsWith(\"--server:\")) {\n-                \/\/ Just skip it.\n-            } else if (args[i].startsWith(\"--log=\")) {\n-                \/\/ Just skip it.\n-            } else if (args[i].equals(\"--compare-found-sources\")) {\n-                \/\/ Just skip it and skip verify file name\n-                i++;\n-            } else {\n-                \/\/ Copy argument.\n-                out[j] = args[i];\n-                j++;\n-            }\n-        }\n-        String[] ret = new String[j];\n-        System.arraycopy(out, 0, ret, 0, j);\n-        return ret;\n-    }\n-\n-    \/**\n-     * Specify which sources are visible to the compiler through -sourcepath.\n-     *\/\n-    public void setVisibleSources(Map<String,Source> vs) {\n-        visibleSrcs = new HashSet<>();\n-        for (String s : vs.keySet()) {\n-            Source src = vs.get(s);\n-            visibleSrcs.add(src.file().toURI());\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if this is an incremental build.\n-     *\/\n-    public boolean isIncremental() {\n-        return !prev.sources().isEmpty();\n-    }\n-\n-    \/**\n-     * Find all artifacts that exists on disk.\n-     *\/\n-    public void findAllArtifacts() {\n-        binArtifacts = findAllFiles(binDir);\n-        gensrcArtifacts = findAllFiles(gensrcDir);\n-        headerArtifacts = findAllFiles(headerDir);\n-    }\n-\n-    \/**\n-     * Lookup the artifacts generated for this package in the previous build.\n-     *\/\n-    private Map<String,File> fetchPrevArtifacts(String pkg) {\n-        Package p = prev.packages().get(pkg);\n-        if (p != null) {\n-            return p.artifacts();\n-        }\n-        return new HashMap<>();\n-    }\n-\n-    \/**\n-     * Delete all prev artifacts in the currently tainted packages.\n-     *\/\n-    public void deleteClassArtifactsInTaintedPackages() {\n-        for (String pkg : taintedPackages) {\n-            Map<String,File> arts = fetchPrevArtifacts(pkg);\n-            for (File f : arts.values()) {\n-                if (f.exists() && f.getName().endsWith(\".class\")) {\n-                    f.delete();\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Mark the javac_state file to be in need of saving and as a side effect,\n-     * it gets a new timestamp.\n-     *\/\n-    private void needsSaving() {\n-        needsSaving = true;\n-    }\n-\n-    \/**\n-     * Save the javac_state file.\n-     *\/\n-    public void save() throws IOException {\n-        if (!needsSaving)\n-            return;\n-        try (FileWriter out = new FileWriter(javacState)) {\n-            StringBuilder b = new StringBuilder();\n-            long millisNow = System.currentTimeMillis();\n-            Date d = new Date(millisNow);\n-            SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss SSS\");\n-            b.append(\"# javac_state ver 0.4 generated \"+millisNow+\" \"+df.format(d)+\"\\n\");\n-            b.append(\"# This format might change at any time. Please do not depend on it.\\n\");\n-            b.append(\"# R arguments\\n\");\n-            b.append(\"# M module\\n\");\n-            b.append(\"# P package\\n\");\n-            b.append(\"# S C source_tobe_compiled timestamp\\n\");\n-            b.append(\"# S L link_only_source timestamp\\n\");\n-            b.append(\"# G C generated_source timestamp\\n\");\n-            b.append(\"# A artifact timestamp\\n\");\n-            b.append(\"# D S dependent -> source dependency\\n\");\n-            b.append(\"# D C dependent -> classpath dependency\\n\");\n-            b.append(\"# I pubapi\\n\");\n-            b.append(\"R \").append(theArgs).append(\"\\n\");\n-\n-            \/\/ Copy over the javac_state for the packages that did not need recompilation.\n-            now.copyPackagesExcept(prev, recompiledPackages, new HashSet<String>());\n-            \/\/ Save the packages, ie package names, dependencies, pubapis and artifacts!\n-            \/\/ I.e. the lot.\n-            Module.saveModules(now.modules(), b);\n-\n-            String s = b.toString();\n-            out.write(s, 0, s.length());\n-        }\n-    }\n-\n-    \/**\n-     * Load a javac_state file.\n-     *\/\n-    public static JavacState load(Options options) {\n-        JavacState db = new JavacState(options, false);\n-        Module  lastModule = null;\n-        Package lastPackage = null;\n-        Source  lastSource = null;\n-        boolean noFileFound = false;\n-        boolean foundCorrectVerNr = false;\n-        boolean newCommandLine = false;\n-        boolean syntaxError = false;\n-\n-        Log.debug(\"Loading javac state file: \" + db.javacState);\n-\n-        try (BufferedReader in = new BufferedReader(new FileReader(db.javacState))) {\n-            for (;;) {\n-                String l = in.readLine();\n-                if (l==null) break;\n-                if (l.length()>=3 && l.charAt(1) == ' ') {\n-                    char c = l.charAt(0);\n-                    if (c == 'M') {\n-                        lastModule = db.prev.loadModule(l);\n-                    } else\n-                    if (c == 'P') {\n-                        if (lastModule == null) { syntaxError = true; break; }\n-                        lastPackage = db.prev.loadPackage(lastModule, l);\n-                    } else\n-                    if (c == 'D') {\n-                        if (lastModule == null || lastPackage == null) { syntaxError = true; break; }\n-                        char depType = l.charAt(2);\n-                        if (depType != 'S' && depType != 'C')\n-                            throw new RuntimeException(\"Bad dependency string: \" + l);\n-                        lastPackage.parseAndAddDependency(l.substring(4), depType == 'C');\n-                    } else\n-                    if (c == 'I') {\n-                        if (lastModule == null || lastPackage == null) { syntaxError = true; break; }\n-                        lastPackage.getPubApi().appendItem(l.substring(2)); \/\/ Strip \"I \"\n-                    } else\n-                    if (c == 'A') {\n-                        if (lastModule == null || lastPackage == null) { syntaxError = true; break; }\n-                        lastPackage.loadArtifact(l);\n-                    } else\n-                    if (c == 'S') {\n-                        if (lastModule == null || lastPackage == null) { syntaxError = true; break; }\n-                        lastSource = db.prev.loadSource(lastPackage, l, false);\n-                    } else\n-                    if (c == 'G') {\n-                        if (lastModule == null || lastPackage == null) { syntaxError = true; break; }\n-                        lastSource = db.prev.loadSource(lastPackage, l, true);\n-                    } else\n-                    if (c == 'R') {\n-                        String ncmdl = \"R \"+db.theArgs;\n-                        if (!l.equals(ncmdl)) {\n-                            newCommandLine = true;\n-                        }\n-                    } else\n-                         if (c == '#') {\n-                        if (l.startsWith(\"# javac_state ver \")) {\n-                            int sp = l.indexOf(\" \", 18);\n-                            if (sp != -1) {\n-                                String ver = l.substring(18,sp);\n-                                if (!ver.equals(\"0.4\")) {\n-                    break;\n-                                 }\n-                foundCorrectVerNr = true;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        } catch (FileNotFoundException | NoSuchFileException e) {\n-            \/\/ Silently create a new javac_state file.\n-            noFileFound = true;\n-        } catch (IOException e) {\n-            Log.warn(\"Dropping old javac_state because of errors when reading it.\");\n-            db = new JavacState(options, true);\n-            foundCorrectVerNr = true;\n-            newCommandLine = false;\n-            syntaxError = false;\n-    }\n-        if (foundCorrectVerNr == false && !noFileFound) {\n-            Log.debug(\"Dropping old javac_state since it is of an old version.\");\n-            db = new JavacState(options, true);\n-        } else\n-        if (newCommandLine == true && !noFileFound) {\n-            Log.debug(\"Dropping old javac_state since a new command line is used!\");\n-            db = new JavacState(options, true);\n-        } else\n-        if (syntaxError == true) {\n-            Log.warn(\"Dropping old javac_state since it contains syntax errors.\");\n-            db = new JavacState(options, true);\n-        }\n-        db.prev.calculateDependents();\n-        return db;\n-    }\n-\n-    \/**\n-     * Mark a java package as tainted, ie it needs recompilation.\n-     *\/\n-    public void taintPackage(String name, String because) {\n-        if (!taintedPackages.contains(name)) {\n-            if (because != null) Log.debug(\"Tainting \"+Util.justPackageName(name)+\" because \"+because);\n-            \/\/ It has not been tainted before.\n-            taintedPackages.add(name);\n-            needsSaving();\n-            Package nowp = now.packages().get(name);\n-            if (nowp != null) {\n-                for (String d : nowp.dependents()) {\n-                    taintPackage(d, because);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * This packages need recompilation.\n-     *\/\n-    public Set<String> taintedPackages() {\n-        return taintedPackages;\n-    }\n-\n-    \/**\n-     * Clean out the tainted package set, used after the first round of compiles,\n-     * prior to propagating dependencies.\n-     *\/\n-    public void clearTaintedPackages() {\n-        taintedPackages = new HashSet<>();\n-    }\n-\n-    \/**\n-     * Go through all sources and check which have been removed, added or modified\n-     * and taint the corresponding packages.\n-     *\/\n-    public void checkSourceStatus(boolean check_gensrc) {\n-        removedSources = calculateRemovedSources();\n-        for (Source s : removedSources) {\n-            if (!s.isGenerated() || check_gensrc) {\n-                taintPackage(s.pkg().name(), \"source \"+s.name()+\" was removed\");\n-            }\n-        }\n-\n-        addedSources = calculateAddedSources();\n-        for (Source s : addedSources) {\n-            String msg = null;\n-            if (isIncremental()) {\n-                \/\/ When building from scratch, there is no point\n-                \/\/ printing \"was added\" for every file since all files are added.\n-                \/\/ However for an incremental build it makes sense.\n-                msg = \"source \"+s.name()+\" was added\";\n-            }\n-            if (!s.isGenerated() || check_gensrc) {\n-                taintPackage(s.pkg().name(), msg);\n-            }\n-        }\n-\n-        modifiedSources = calculateModifiedSources();\n-        for (Source s : modifiedSources) {\n-            if (!s.isGenerated() || check_gensrc) {\n-                taintPackage(s.pkg().name(), \"source \"+s.name()+\" was modified\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Acquire the compile_java_packages suffix rule for .java files.\n-     *\/\n-    public Map<String,Transformer> getJavaSuffixRule() {\n-        Map<String,Transformer> sr = new HashMap<>();\n-        sr.put(\".java\", compileJavaPackages);\n-        return sr;\n-    }\n-\n-\n-    \/**\n-     * If artifacts have gone missing, force a recompile of the packages\n-     * they belong to.\n-     *\/\n-    public void taintPackagesThatMissArtifacts() {\n-        for (Package pkg : prev.packages().values()) {\n-            for (File f : pkg.artifacts().values()) {\n-                if (!f.exists()) {\n-                    \/\/ Hmm, the artifact on disk does not exist! Someone has removed it....\n-                    \/\/ Lets rebuild the package.\n-                    taintPackage(pkg.name(), \"\"+f+\" is missing.\");\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Propagate recompilation through the dependency chains.\n-     * Avoid re-tainting packages that have already been compiled.\n-     *\/\n-    public void taintPackagesDependingOnChangedPackages(Set<String> pkgsWithChangedPubApi, Set<String> recentlyCompiled) {\n-        \/\/ For each to-be-recompiled-candidates...\n-        for (Package pkg : new HashSet<>(prev.packages().values())) {\n-            \/\/ Find out what it depends upon...\n-            Set<String> deps = pkg.typeDependencies()\n-                                  .values()\n-                                  .stream()\n-                                  .flatMap(Collection::stream)\n-                                  .collect(Collectors.toSet());\n-            for (String dep : deps) {\n-                String depPkg = \":\" + dep.substring(0, dep.lastIndexOf('.'));\n-                if (depPkg.equals(pkg.name()))\n-                    continue;\n-                \/\/ Checking if that dependency has changed\n-                if (pkgsWithChangedPubApi.contains(depPkg) && !recentlyCompiled.contains(pkg.name())) {\n-                    taintPackage(pkg.name(), \"its depending on \" + depPkg);\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Compare the javac_state recorded public apis of packages on the classpath\n-     * with the actual public apis on the classpath.\n-     *\/\n-    public void taintPackagesDependingOnChangedClasspathPackages() throws IOException {\n-\n-        \/\/ 1. Collect fully qualified names of all interesting classpath dependencies\n-        Set<String> fqDependencies = new HashSet<>();\n-        for (Package pkg : prev.packages().values()) {\n-            \/\/ Check if this package was compiled. If it's presence is recorded\n-            \/\/ because it was on the class path and we needed to save it's\n-            \/\/ public api, it's not a candidate for tainting.\n-            if (pkg.sources().isEmpty())\n-                continue;\n-\n-            pkg.typeClasspathDependencies().values().forEach(fqDependencies::addAll);\n-        }\n-\n-        \/\/ 2. Extract the public APIs from the on disk .class files\n-        \/\/ (Reason for doing step 1 in a separate phase is to avoid extracting\n-        \/\/ public APIs of the same class twice.)\n-        PubApiExtractor pubApiExtractor = new PubApiExtractor(options);\n-        Map<String, PubApi> onDiskPubApi = new HashMap<>();\n-        for (String cpDep : fqDependencies) {\n-            onDiskPubApi.put(cpDep, pubApiExtractor.getPubApi(cpDep));\n-        }\n-        pubApiExtractor.close();\n-\n-        \/\/ 3. Compare them with the public APIs as of last compilation (loaded from javac_state)\n-        nextPkg:\n-        for (Package pkg : prev.packages().values()) {\n-            \/\/ Check if this package was compiled. If it's presence is recorded\n-            \/\/ because it was on the class path and we needed to save it's\n-            \/\/ public api, it's not a candidate for tainting.\n-            if (pkg.sources().isEmpty())\n-                continue;\n-\n-            Set<String> cpDepsOfThisPkg = new HashSet<>();\n-            for (Set<String> cpDeps : pkg.typeClasspathDependencies().values())\n-                cpDepsOfThisPkg.addAll(cpDeps);\n-\n-            for (String fqDep : cpDepsOfThisPkg) {\n-\n-                String depPkg = \":\" + fqDep.substring(0, fqDep.lastIndexOf('.'));\n-                PubApi prevPkgApi = prev.packages().get(depPkg).getPubApi();\n-\n-                \/\/ This PubApi directly lists the members of the class,\n-                \/\/ i.e. [ MEMBER1, MEMBER2, ... ]\n-                PubApi prevDepApi = prevPkgApi.types.get(fqDep).pubApi;\n-\n-                \/\/ In order to dive *into* the class, we need to add\n-                \/\/ .types.get(fqDep).pubApi below.\n-                PubApi currentDepApi = onDiskPubApi.get(fqDep).types.get(fqDep).pubApi;\n-\n-                if (!currentDepApi.isBackwardCompatibleWith(prevDepApi)) {\n-                    List<String> apiDiff = currentDepApi.diff(prevDepApi);\n-                    taintPackage(pkg.name(), \"depends on classpath \"\n-                                + \"package which has an updated package api: \"\n-                                + String.join(\"\\n\", apiDiff));\n-                    \/\/Log.debug(\"========================================\");\n-                    \/\/Log.debug(\"------ PREV API ------------------------\");\n-                    \/\/prevDepApi.asListOfStrings().forEach(Log::debug);\n-                    \/\/Log.debug(\"------ CURRENT API ---------------------\");\n-                    \/\/currentDepApi.asListOfStrings().forEach(Log::debug);\n-                    \/\/Log.debug(\"========================================\");\n-                    continue nextPkg;\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Scan all output dirs for artifacts and remove those files (artifacts?)\n-     * that are not recognized as such, in the javac_state file.\n-     *\/\n-    public void removeUnidentifiedArtifacts() {\n-        Set<File> allKnownArtifacts = new HashSet<>();\n-        for (Package pkg : prev.packages().values()) {\n-            for (File f : pkg.artifacts().values()) {\n-                allKnownArtifacts.add(f);\n-            }\n-        }\n-        \/\/ Do not forget about javac_state....\n-        allKnownArtifacts.add(javacState);\n-\n-        for (File f : binArtifacts) {\n-            if (!allKnownArtifacts.contains(f) &&\n-                !options.isUnidentifiedArtifactPermitted(f.getAbsolutePath())) {\n-                Log.debug(\"Removing \"+f.getPath()+\" since it is unknown to the javac_state.\");\n-                f.delete();\n-            }\n-        }\n-        for (File f : headerArtifacts) {\n-            if (!allKnownArtifacts.contains(f)) {\n-                Log.debug(\"Removing \"+f.getPath()+\" since it is unknown to the javac_state.\");\n-                f.delete();\n-            }\n-        }\n-        for (File f : gensrcArtifacts) {\n-            if (!allKnownArtifacts.contains(f)) {\n-                Log.debug(\"Removing \"+f.getPath()+\" since it is unknown to the javac_state.\");\n-                f.delete();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Remove artifacts that are no longer produced when compiling!\n-     *\/\n-    public void removeSuperfluousArtifacts(Set<String> recentlyCompiled) {\n-        \/\/ Nothing to do, if nothing was recompiled.\n-        if (recentlyCompiled.size() == 0) return;\n-\n-        for (String pkg : now.packages().keySet()) {\n-            \/\/ If this package has not been recompiled, skip the check.\n-            if (!recentlyCompiled.contains(pkg)) continue;\n-            Collection<File> arts = now.artifacts().values();\n-            for (File f : fetchPrevArtifacts(pkg).values()) {\n-                if (!arts.contains(f)) {\n-                    Log.debug(\"Removing \"+f.getPath()+\" since it is now superfluous!\");\n-                    if (f.exists()) f.delete();\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Return those files belonging to prev, but not now.\n-     *\/\n-    private Set<Source> calculateRemovedSources() {\n-        Set<Source> removed = new HashSet<>();\n-        for (String src : prev.sources().keySet()) {\n-            if (now.sources().get(src) == null) {\n-                removed.add(prev.sources().get(src));\n-            }\n-        }\n-        return removed;\n-    }\n-\n-    \/**\n-     * Return those files belonging to now, but not prev.\n-     *\/\n-    private Set<Source> calculateAddedSources() {\n-        Set<Source> added = new HashSet<>();\n-        for (String src : now.sources().keySet()) {\n-            if (prev.sources().get(src) == null) {\n-                added.add(now.sources().get(src));\n-            }\n-        }\n-        return added;\n-    }\n-\n-    \/**\n-     * Return those files where the timestamp is newer.\n-     * If a source file timestamp suddenly is older than what is known\n-     * about it in javac_state, then consider it modified, but print\n-     * a warning!\n-     *\/\n-    private Set<Source> calculateModifiedSources() {\n-        Set<Source> modified = new HashSet<>();\n-        for (String src : now.sources().keySet()) {\n-            Source n = now.sources().get(src);\n-            Source t = prev.sources().get(src);\n-            if (prev.sources().get(src) != null) {\n-                if (t != null) {\n-                    if (n.lastModified() > t.lastModified()) {\n-                        modified.add(n);\n-                    } else if (n.lastModified() < t.lastModified()) {\n-                        modified.add(n);\n-                        Log.warn(\"The source file \"+n.name()+\" timestamp has moved backwards in time.\");\n-                    }\n-                }\n-            }\n-        }\n-        return modified;\n-    }\n-\n-    \/**\n-     * Recursively delete a directory and all its contents.\n-     *\/\n-    private void deleteContents(File dir) {\n-        if (dir != null && dir.exists()) {\n-            for (File f : dir.listFiles()) {\n-                if (f.isDirectory()) {\n-                    deleteContents(f);\n-                }\n-                if (!options.isUnidentifiedArtifactPermitted(f.getAbsolutePath())) {\n-                    Log.debug(\"Removing \"+f.getAbsolutePath());\n-                    f.delete();\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Run the copy translator only.\n-     *\/\n-    public void performCopying(File binDir, Map<String,Transformer> suffixRules) {\n-        Map<String,Transformer> sr = new HashMap<>();\n-        for (Map.Entry<String,Transformer> e : suffixRules.entrySet()) {\n-            if (e.getValue().getClass().equals(CopyFile.class)) {\n-                sr.put(e.getKey(), e.getValue());\n-            }\n-        }\n-        perform(null, binDir, sr);\n-    }\n-\n-    \/**\n-     * Run all the translators that translate into java source code.\n-     * I.e. all translators that are not copy nor compile_java_source.\n-     *\/\n-    public void performTranslation(File gensrcDir, Map<String,Transformer> suffixRules) {\n-        Map<String,Transformer> sr = new HashMap<>();\n-        for (Map.Entry<String,Transformer> e : suffixRules.entrySet()) {\n-            Class<?> trClass = e.getValue().getClass();\n-            if (trClass == CompileJavaPackages.class || trClass == CopyFile.class)\n-                continue;\n-\n-            sr.put(e.getKey(), e.getValue());\n-        }\n-        perform(null, gensrcDir, sr);\n-    }\n-\n-    \/**\n-     * Compile all the java sources. Return true, if it needs to be called again!\n-     *\/\n-    public boolean performJavaCompilations(CompilationService sjavac,\n-                                           Options args,\n-                                           Set<String> recentlyCompiled,\n-                                           boolean[] rcValue) {\n-        Map<String,Transformer> suffixRules = new HashMap<>();\n-        suffixRules.put(\".java\", compileJavaPackages);\n-        compileJavaPackages.setExtra(args);\n-        rcValue[0] = perform(sjavac, binDir, suffixRules);\n-        recentlyCompiled.addAll(taintedPackages());\n-        clearTaintedPackages();\n-        boolean again = !packagesWithChangedPublicApis.isEmpty();\n-        taintPackagesDependingOnChangedPackages(packagesWithChangedPublicApis, recentlyCompiled);\n-        packagesWithChangedPublicApis = new HashSet<>();\n-        return again && rcValue[0];\n-\n-        \/\/ TODO: Figure out why 'again' checks packagesWithChangedPublicAPis.\n-        \/\/ (It shouldn't matter if packages had changed pub apis as long as no\n-        \/\/ one depends on them. Wouldn't it make more sense to let 'again'\n-        \/\/ depend on taintedPackages?)\n-    }\n-\n-    \/**\n-     * Store the source into the set of sources belonging to the given transform.\n-     *\/\n-    private void addFileToTransform(Map<Transformer,Map<String,Set<URI>>> gs, Transformer t, Source s) {\n-        Map<String,Set<URI>> fs = gs.get(t);\n-        if (fs == null) {\n-            fs = new HashMap<>();\n-            gs.put(t, fs);\n-        }\n-        Set<URI> ss = fs.get(s.pkg().name());\n-        if (ss == null) {\n-            ss = new HashSet<>();\n-            fs.put(s.pkg().name(), ss);\n-        }\n-        ss.add(s.file().toURI());\n-    }\n-\n-    \/**\n-     * For all packages, find all sources belonging to the package, group the sources\n-     * based on their transformers and apply the transformers on each source code group.\n-     *\/\n-    private boolean perform(CompilationService sjavac,\n-                            File outputDir,\n-                            Map<String,Transformer> suffixRules) {\n-        boolean rc = true;\n-        \/\/ Group sources based on transforms. A source file can only belong to a single transform.\n-        Map<Transformer,Map<String,Set<URI>>> groupedSources = new HashMap<>();\n-        for (Source src : now.sources().values()) {\n-            Transformer t = suffixRules.get(src.suffix());\n-            if (t != null) {\n-                if (taintedPackages.contains(src.pkg().name()) && !src.isLinkedOnly()) {\n-                    addFileToTransform(groupedSources, t, src);\n-                }\n-            }\n-        }\n-        \/\/ Go through the transforms and transform them.\n-        for (Map.Entry<Transformer, Map<String, Set<URI>>> e : groupedSources.entrySet()) {\n-            Transformer t = e.getKey();\n-            Map<String, Set<URI>> srcs = e.getValue();\n-            \/\/ These maps need to be synchronized since multiple threads will be\n-            \/\/ writing results into them.\n-            Map<String, Set<URI>> packageArtifacts = Collections.synchronizedMap(new HashMap<>());\n-            Map<String, Map<String, Set<String>>> packageDependencies = Collections.synchronizedMap(new HashMap<>());\n-            Map<String, Map<String, Set<String>>> packageCpDependencies = Collections.synchronizedMap(new HashMap<>());\n-            Map<String, PubApi> packagePublicApis = Collections.synchronizedMap(new HashMap<>());\n-            Map<String, PubApi> dependencyPublicApis = Collections.synchronizedMap(new HashMap<>());\n-\n-            boolean r = t.transform(sjavac,\n-                                    srcs,\n-                                    visibleSrcs,\n-                                    prev.dependents(),\n-                                    outputDir.toURI(),\n-                                    packageArtifacts,\n-                                    packageDependencies,\n-                                    packageCpDependencies,\n-                                    packagePublicApis,\n-                                    dependencyPublicApis,\n-                                    0,\n-                                    isIncremental(),\n-                                    numCores);\n-            if (!r)\n-                rc = false;\n-\n-            for (String p : srcs.keySet()) {\n-                recompiledPackages.add(p);\n-            }\n-            \/\/ The transform is done! Extract all the artifacts and store the info into the Package objects.\n-            for (Map.Entry<String, Set<URI>> a : packageArtifacts.entrySet()) {\n-                Module mnow = now.findModuleFromPackageName(a.getKey());\n-                mnow.addArtifacts(a.getKey(), a.getValue());\n-            }\n-            \/\/ Extract all the dependencies and store the info into the Package objects.\n-            for (Map.Entry<String, Map<String, Set<String>>> a : packageDependencies.entrySet()) {\n-                Map<String, Set<String>> deps = a.getValue();\n-                Module mnow = now.findModuleFromPackageName(a.getKey());\n-                mnow.setDependencies(a.getKey(), deps, false);\n-            }\n-            for (Map.Entry<String, Map<String, Set<String>>> a : packageCpDependencies.entrySet()) {\n-                Map<String, Set<String>> deps = a.getValue();\n-                Module mnow = now.findModuleFromPackageName(a.getKey());\n-                mnow.setDependencies(a.getKey(), deps, true);\n-            }\n-\n-            \/\/ This map contains the public api of the types that this\n-            \/\/ compilation depended upon. This means that it may not contain\n-            \/\/ full packages. In other words, we shouldn't remove knowledge of\n-            \/\/ public apis but merge these with what we already have.\n-            for (Map.Entry<String, PubApi> a : dependencyPublicApis.entrySet()) {\n-                String pkg = a.getKey();\n-                PubApi packagePartialPubApi = a.getValue();\n-                Package pkgNow = now.findModuleFromPackageName(pkg).lookupPackage(pkg);\n-                PubApi currentPubApi = pkgNow.getPubApi();\n-                PubApi newPubApi = PubApi.mergeTypes(currentPubApi, packagePartialPubApi);\n-                pkgNow.setPubapi(newPubApi);\n-\n-                \/\/ See JDK-8071904\n-                if (now.packages().containsKey(pkg))\n-                    now.packages().get(pkg).setPubapi(newPubApi);\n-                else\n-                    now.packages().put(pkg, pkgNow);\n-            }\n-\n-            \/\/ The packagePublicApis cover entire packages (since sjavac compiles\n-            \/\/ stuff on package level). This means that if a type is missing\n-            \/\/ in the public api of a given package, it means that it has been\n-            \/\/ removed. In other words, we should *set* the pubapi to whatever\n-            \/\/ this map contains, and not merge it with what we already have.\n-            for (Map.Entry<String, PubApi> a : packagePublicApis.entrySet()) {\n-                String pkg = a.getKey();\n-                PubApi newPubApi = a.getValue();\n-                Module mprev = prev.findModuleFromPackageName(pkg);\n-                Module mnow = now.findModuleFromPackageName(pkg);\n-                mnow.setPubapi(pkg, newPubApi);\n-                if (mprev.hasPubapiChanged(pkg, newPubApi)) {\n-                    \/\/ Aha! The pubapi of this package has changed!\n-                    \/\/ It can also be a new compile from scratch.\n-                    if (mprev.lookupPackage(pkg).existsInJavacState()) {\n-                        \/\/ This is an incremental compile! The pubapi\n-                        \/\/ did change. Trigger recompilation of dependents.\n-                        packagesWithChangedPublicApis.add(pkg);\n-                        Log.debug(\"The API of \" + Util.justPackageName(pkg) + \" has changed!\");\n-                    }\n-                }\n-            }\n-        }\n-        return rc;\n-    }\n-\n-    \/**\n-     * Utility method to recursively find all files below a directory.\n-     *\/\n-    private static Set<File> findAllFiles(File dir) {\n-        Set<File> foundFiles = new HashSet<>();\n-        if (dir == null) {\n-            return foundFiles;\n-        }\n-        recurse(dir, foundFiles);\n-        return foundFiles;\n-    }\n-\n-    private static void recurse(File dir, Set<File> foundFiles) {\n-        for (File f : dir.listFiles()) {\n-            if (f.isFile()) {\n-                foundFiles.add(f);\n-            } else if (f.isDirectory()) {\n-                recurse(f, foundFiles);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Compare the calculate source list, with an explicit list, usually\n-     * supplied from the makefile. Used to detect bugs where the makefile and\n-     * sjavac have different opinions on which files should be compiled.\n-     *\/\n-    public void compareWithMakefileList(File makefileSourceList)\n-            throws ProblemException {\n-        \/\/ If we are building on win32 using for example cygwin the paths in the\n-        \/\/ makefile source list\n-        \/\/ might be \/cygdrive\/c\/.... which does not match c:\\....\n-        \/\/ We need to adjust our calculated sources to be identical, if\n-        \/\/ necessary.\n-        boolean mightNeedRewriting = File.pathSeparatorChar == ';';\n-\n-        if (makefileSourceList == null)\n-            return;\n-\n-        Set<String> calculatedSources = new HashSet<>();\n-        Set<String> listedSources = new HashSet<>();\n-\n-        \/\/ Create a set of filenames with full paths.\n-        for (Source s : now.sources().values()) {\n-            \/\/ Don't include link only sources when comparing sources to compile\n-            if (!s.isLinkedOnly()) {\n-                String path = s.file().getPath();\n-                if (mightNeedRewriting)\n-                    path = Util.normalizeDriveLetter(path);\n-                calculatedSources.add(path);\n-            }\n-        }\n-        \/\/ Read in the file and create another set of filenames with full paths.\n-        try(BufferedReader in = new BufferedReader(new FileReader(makefileSourceList))) {\n-            for (;;) {\n-                String l = in.readLine();\n-                if (l==null) break;\n-                l = l.trim();\n-                if (mightNeedRewriting) {\n-                    if (l.indexOf(\":\") == 1 && l.indexOf(\"\\\\\") == 2) {\n-                        \/\/ Everything a-ok, the format is already C:\\foo\\bar\n-                    } else if (l.indexOf(\":\") == 1 && l.indexOf(\"\/\") == 2) {\n-                        \/\/ The format is C:\/foo\/bar, rewrite into the above format.\n-                        l = l.replaceAll(\"\/\",\"\\\\\\\\\");\n-                    } else if (l.charAt(0) == '\/' && l.indexOf(\"\/\",1) != -1) {\n-                        \/\/ The format might be: \/cygdrive\/c\/foo\/bar, rewrite into the above format.\n-                        \/\/ Do not hardcode the name cygdrive here.\n-                        int slash = l.indexOf(\"\/\",1);\n-                        l = l.replaceAll(\"\/\",\"\\\\\\\\\");\n-                        l = \"\"+l.charAt(slash+1)+\":\"+l.substring(slash+2);\n-                    }\n-                    if (Character.isLowerCase(l.charAt(0))) {\n-                        l = Character.toUpperCase(l.charAt(0))+l.substring(1);\n-                    }\n-                }\n-                listedSources.add(l);\n-            }\n-        } catch (FileNotFoundException | NoSuchFileException e) {\n-            throw new ProblemException(\"Could not open \"+makefileSourceList.getPath()+\" since it does not exist!\");\n-        } catch (IOException e) {\n-            throw new ProblemException(\"Could not read \"+makefileSourceList.getPath());\n-        }\n-\n-        for (String s : listedSources) {\n-            if (!calculatedSources.contains(s)) {\n-                 throw new ProblemException(\"The makefile listed source \"+s+\" was not calculated by the smart javac wrapper!\");\n-            }\n-        }\n-\n-        for (String s : calculatedSources) {\n-            if (!listedSources.contains(s)) {\n-                throw new ProblemException(\"The smart javac wrapper calculated source \"+s+\" was not listed by the makefiles!\");\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/JavacState.java","additions":0,"deletions":974,"binary":false,"changes":974,"status":"deleted"},{"patch":"@@ -1,58 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import static com.sun.tools.sjavac.options.Option.STARTSERVER;\n-\n-import java.util.Arrays;\n-\n-import com.sun.tools.sjavac.client.ClientMain;\n-import com.sun.tools.sjavac.server.ServerMain;\n-\n-\/**\n- * The application entry point of the smart javac wrapper tool.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Main {\n-\n-    public static void main(String... args)  {\n-        System.exit(go(args));\n-    }\n-\n-    public static int go(String[] args) {\n-\n-        \/\/ Server or client mode?\n-        boolean serverMode = Arrays.asList(args)\n-                                   .stream()\n-                                   .anyMatch(arg -> arg.startsWith(STARTSERVER.arg));\n-\n-        return serverMode ? ServerMain.run(args) : ClientMain.run(args);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Main.java","additions":0,"deletions":58,"binary":false,"changes":58,"status":"deleted"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.net.URI;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The module is the root of a set of packages\/sources\/artifacts.\n- * At the moment there is only one module in use, the empty\/no-name\/default module.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Module implements Comparable<Module> {\n-    private String name;\n-    private String dirname;\n-    private Map<String,Package> packages = new HashMap<>();\n-    private Map<String,Source> sources = new HashMap<>();\n-    private Map<String,File> artifacts = new HashMap<>();\n-\n-    public Module(String n, String dn) {\n-        name = n;\n-        dirname = n;\n-    }\n-\n-    public String name() { return name; }\n-    public String dirname() { return dirname; }\n-    public Map<String,Package> packages() { return packages; }\n-    public Map<String,Source> sources() { return sources; }\n-    public Map<String,File> artifacts() { return artifacts; }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return (o instanceof Module module) && name.equals(module.name);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return name.hashCode();\n-    }\n-\n-    @Override\n-    public int compareTo(Module o) {\n-        return name.compareTo(o.name);\n-    }\n-\n-    public void save(StringBuilder b) {\n-        b.append(\"M \").append(name).append(\":\").append(\"\\n\");\n-        Package.savePackages(packages, b);\n-    }\n-\n-    public static Module load(String l) {\n-        int cp = l.indexOf(':',2);\n-        if (cp == -1) return null;\n-        String name = l.substring(2,cp);\n-        return new Module(name, \"\");\n-    }\n-\n-    public static void saveModules(Map<String,Module> ms, StringBuilder b) {\n-        for (Module m : ms.values()) {\n-            m.save(b);\n-        }\n-    }\n-\n-    public void addPackage(Package p) {\n-        packages.put(p.name(), p);\n-    }\n-\n-    public Package lookupPackage(String pkg) {\n-        \/\/ See JDK-8071904\n-        Package p = packages.get(pkg);\n-        if (p == null) {\n-            p = new Package(this, pkg);\n-            packages.put(pkg, p);\n-        }\n-        return p;\n-    }\n-\n-    public void addSource(String pkg, Source src) {\n-        Package p = lookupPackage(pkg);\n-        src.setPackage(p);\n-        p.addSource(src);\n-        sources.put(src.file().getPath(), src);\n-    }\n-\n-    public Source lookupSource(String path) {\n-        return sources.get(path);\n-    }\n-\n-    public void addArtifacts(String pkg, Set<URI> as) {\n-        Package p = lookupPackage(pkg);\n-        for (URI u : as) {\n-            p.addArtifact(new File(u));\n-        }\n-    }\n-\n-    public void setDependencies(String pkg, Map<String, Set<String>> deps, boolean cp) {\n-        lookupPackage(pkg).setDependencies(deps, cp);\n-    }\n-\n-    public void setPubapi(String pkg, PubApi ps) {\n-        Package p = lookupPackage(pkg);\n-        p.setPubapi(ps);\n-    }\n-\n-    public boolean hasPubapiChanged(String pkg, PubApi newPubApi) {\n-        Package p = lookupPackage(pkg);\n-        return p.hasPubApiChanged(newPubApi);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Module.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,293 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.net.URI;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.TreeMap;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The Package class maintains meta information about a package.\n- * For example its sources, dependents, its pubapi and its artifacts.\n- *\n- * It might look odd that we track dependents\/pubapi\/artifacts on\n- * a package level, but it makes sense since recompiling a full package\n- * takes as long as recompiling a single java file in that package,\n- * if you take into account the startup time of the jvm.\n- *\n- * Also the dependency information will be much smaller (good for the javac_state file size)\n- * and it simplifies tracking artifact generation, you do not always know from which\n- * source a class file was generated, but you always know which package it belongs to.\n- *\n- * It is also educational to see package dependencies triggering recompilation of\n- * other packages. Even though the recompilation was perhaps not necessary,\n- * the visible recompilation of the dependent packages indicates how much circular\n- * dependencies your code has.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Package implements Comparable<Package> {\n-    \/\/ The module this package belongs to. (There is a legacy module with an empty string name,\n-    \/\/ used for all legacy sources.)\n-    private Module mod;\n-    \/\/ Name of this package, module:pkg\n-    \/\/ ex1 jdk.base:java.lang\n-    \/\/ ex2 :java.lang (when in legacy mode)\n-    private String name;\n-    \/\/ The directory path to the package. If the package belongs to a module,\n-    \/\/ then that module's file system name is part of the path.\n-    private String dirname;\n-    \/\/ This package has the following dependents, that depend on this package.\n-    private Set<String> dependents = new HashSet<>();\n-\n-    \/\/ Fully qualified name of class in this package -> fully qualified name of dependency\n-    private Map<String, Set<String>> dependencies = new TreeMap<>();\n-    \/\/ Fully qualified name of class in this package -> fully qualified name of dependency on class path\n-    private Map<String, Set<String>> cpDependencies = new TreeMap<>();\n-\n-    \/\/ This is the public api of this package.\n-    private PubApi pubApi = new PubApi();\n-    \/\/ Map from source file name to Source info object.\n-    private Map<String,Source> sources = new HashMap<>();\n-    \/\/ This package generated these artifacts.\n-    private Map<String,File> artifacts = new HashMap<>();\n-\n-    public Package(Module m, String n) {\n-        int c = n.indexOf(\":\");\n-        Assert.check(c != -1);\n-        Assert.check(m.name().equals(m.name()));\n-        name = n;\n-        dirname = n.replace('.', File.separatorChar);\n-        if (m.name().length() > 0) {\n-            \/\/ There is a module here, prefix the module dir name to the path.\n-            dirname = m.dirname()+File.separatorChar+dirname;\n-        }\n-    }\n-\n-    public Module mod() { return mod; }\n-    public String name() { return name; }\n-    public String dirname() { return dirname; }\n-    public Map<String,Source> sources() { return sources; }\n-    public Map<String,File> artifacts() { return artifacts; }\n-    public PubApi getPubApi() { return pubApi; }\n-\n-    public Map<String,Set<String>> typeDependencies() { return dependencies; }\n-    public Map<String,Set<String>> typeClasspathDependencies() { return cpDependencies; }\n-\n-    public Set<String> dependents() { return dependents; }\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return (o instanceof Package pac) && name.equals(pac.name);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return name.hashCode();\n-    }\n-\n-    @Override\n-    public int compareTo(Package o) {\n-        return name.compareTo(o.name);\n-    }\n-\n-    public void addSource(Source s) {\n-        sources.put(s.file().getPath(), s);\n-    }\n-\n-    private static Pattern DEP_PATTERN = Pattern.compile(\"(.*) -> (.*)\");\n-    public void parseAndAddDependency(String d, boolean cp) {\n-        Matcher m = DEP_PATTERN.matcher(d);\n-        if (!m.matches())\n-            throw new IllegalArgumentException(\"Bad dependency string: \" + d);\n-        addDependency(m.group(1), m.group(2), cp);\n-    }\n-\n-    public void addDependency(String fullyQualifiedFrom,\n-                              String fullyQualifiedTo,\n-                              boolean cp) {\n-        Map<String, Set<String>> map = cp ? cpDependencies : dependencies;\n-        if (!map.containsKey(fullyQualifiedFrom))\n-            map.put(fullyQualifiedFrom, new HashSet<>());\n-        map.get(fullyQualifiedFrom).add(fullyQualifiedTo);\n-    }\n-\n-    public void addDependent(String d) {\n-        dependents.add(d);\n-    }\n-\n-    \/**\n-     * Check if we have knowledge in the javac state that\n-     * describe the results of compiling this package before.\n-     *\/\n-    public boolean existsInJavacState() {\n-        return artifacts.size() > 0 || !pubApi.isEmpty();\n-    }\n-\n-    public boolean hasPubApiChanged(PubApi newPubApi) {\n-        return !newPubApi.isBackwardCompatibleWith(pubApi);\n-    }\n-\n-    public void setPubapi(PubApi newPubApi) {\n-        pubApi = newPubApi;\n-    }\n-\n-    public void setDependencies(Map<String, Set<String>> ds, boolean cp) {\n-        (cp ? cpDependencies : dependencies).clear();\n-        for (String fullyQualifiedFrom : ds.keySet())\n-            for (String fullyQualifiedTo : ds.get(fullyQualifiedFrom))\n-                addDependency(fullyQualifiedFrom, fullyQualifiedTo, cp);\n-    }\n-\n-    public void save(StringBuilder b) {\n-        b.append(\"P \").append(name).append(\"\\n\");\n-        Source.saveSources(sources, b);\n-        saveDependencies(b);\n-        savePubapi(b);\n-        saveArtifacts(b);\n-    }\n-\n-    public static Package load(Module module, String l) {\n-        String name = l.substring(2);\n-        return new Package(module, name);\n-    }\n-\n-    public void saveDependencies(StringBuilder b) {\n-\n-        \/\/ Dependencies where *to* is among sources\n-        for (String fullyQualifiedFrom : dependencies.keySet()) {\n-            for (String fullyQualifiedTo : dependencies.get(fullyQualifiedFrom)) {\n-                b.append(String.format(\"D S %s -> %s%n\", fullyQualifiedFrom, fullyQualifiedTo));\n-            }\n-        }\n-\n-        \/\/ Dependencies where *to* is on class path\n-        for (String fullyQualifiedFrom : cpDependencies.keySet()) {\n-            for (String fullyQualifiedTo : cpDependencies.get(fullyQualifiedFrom)) {\n-                b.append(String.format(\"D C %s -> %s%n\", fullyQualifiedFrom, fullyQualifiedTo));\n-            }\n-        }\n-    }\n-\n-    public void savePubapi(StringBuilder b) {\n-        pubApi.asListOfStrings()\n-              .stream()\n-              .flatMap(l -> Stream.of(\"I \", l, \"\\n\"))\n-              .forEach(b::append);\n-    }\n-\n-    public static void savePackages(Map<String,Package> packages, StringBuilder b) {\n-        List<String> sorted_packages = new ArrayList<>();\n-        for (String key : packages.keySet() ) {\n-            sorted_packages.add(key);\n-        }\n-        Collections.sort(sorted_packages);\n-        for (String s : sorted_packages) {\n-            Package p = packages.get(s);\n-            p.save(b);\n-        }\n-    }\n-\n-    public void addArtifact(String a) {\n-        artifacts.put(a, new File(a));\n-    }\n-\n-    public void addArtifact(File f) {\n-        artifacts.put(f.getPath(), f);\n-    }\n-\n-    public void addArtifacts(Set<URI> as) {\n-        for (URI u : as) {\n-            addArtifact(new File(u));\n-        }\n-    }\n-\n-    public void setArtifacts(Set<URI> as) {\n-        Assert.check(!artifacts.isEmpty());\n-        artifacts = new HashMap<>();\n-        addArtifacts(as);\n-    }\n-\n-    public void loadArtifact(String l) {\n-        \/\/ Find next space after \"A \".\n-        int dp = l.indexOf(' ',2);\n-        String fn = l.substring(2,dp);\n-        long last_modified = Long.parseLong(l.substring(dp+1));\n-        File f = new File(fn);\n-        if (f.exists() && f.lastModified() != last_modified) {\n-            \/\/ Hmm, the artifact on disk does not have the same last modified\n-            \/\/ timestamp as the information from the build database.\n-            \/\/ We no longer trust the artifact on disk. Delete it.\n-            \/\/ The smart javac wrapper will then rebuild the artifact.\n-            Log.debug(\"Removing \"+f.getPath()+\" since its timestamp does not match javac_state.\");\n-            f.delete();\n-        }\n-        artifacts.put(f.getPath(), f);\n-    }\n-\n-    public void saveArtifacts(StringBuilder b) {\n-        List<File> sorted_artifacts = new ArrayList<>();\n-        for (File f : artifacts.values()) {\n-            sorted_artifacts.add(f);\n-        }\n-        Collections.sort(sorted_artifacts);\n-        for (File f : sorted_artifacts) {\n-            \/\/ The last modified information is only used\n-            \/\/ to detect tampering with the output dir.\n-            \/\/ If the outputdir has been modified, not by javac,\n-            \/\/ then a mismatch will be detected in the last modified\n-            \/\/ timestamps stored in the build database compared\n-            \/\/ to the timestamps on disk and the artifact will be deleted.\n-\n-            b.append(\"A \"+f.getPath()+\" \"+f.lastModified()+\"\\n\");\n-        }\n-    }\n-\n-    \/**\n-     * Always clean out a tainted package before it is recompiled.\n-     *\/\n-    public void deleteArtifacts() {\n-        for (File a : artifacts.values()) {\n-            a.delete();\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Package.java","additions":0,"deletions":293,"binary":false,"changes":293,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-\/**\n- * Used to signal serious problems when running sjavac.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ProblemException extends Exception {\n-    static final long serialVersionUID = -3387516993124229949L;\n-    public ProblemException(String s) {\n-        super(s);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/ProblemException.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.util.Arrays;\n-\n-import javax.tools.JavaCompiler.CompilationTask;\n-import javax.tools.JavaFileManager;\n-\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.code.ClassFinder;\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.code.Symtab;\n-import com.sun.tools.javac.main.JavaCompiler;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Convert;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.javac.util.Names;\n-import com.sun.tools.sjavac.comp.PubapiVisitor;\n-import com.sun.tools.sjavac.comp.SmartFileManager;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-public class PubApiExtractor {\n-    \/\/ Setup a compiler context for finding classes in the classpath\n-    \/\/ and to execute annotation processors.\n-    final Context context;\n-    final CompilationTask task;\n-\n-    final SmartFileManager fileManager;\n-\n-    \/**\n-     * Setup a compilation context, used for reading public apis of classes on the classpath\n-     * as well as annotation processors.\n-     *\/\n-    public PubApiExtractor(Options options) {\n-        JavacTool compiler = com.sun.tools.javac.api.JavacTool.create();\n-        fileManager = new SmartFileManager(compiler.getStandardFileManager(null, null, null));\n-        context = new com.sun.tools.javac.util.Context();\n-        String[] args = options.prepJavacArgs();\n-        task = compiler.getTask(new PrintWriter(System.err),\n-                                fileManager,\n-                                null,\n-                                Arrays.asList(args),\n-                                null,\n-                                null,\n-                                context);\n-        \/\/ Trigger a creation of the JavaCompiler, necessary to get a sourceCompleter for ClassFinder.\n-        \/\/ The sourceCompleter is used for build situations where a classpath class references other classes\n-        \/\/ that happens to be on the sourcepath.\n-        JavaCompiler.instance(context);\n-\n-\/\/        context.put(JavaFileManager.class, fileManager);\n-    }\n-\n-    public PubApi getPubApi(String fullyQualifiedClassName) {\n-        Symtab syms = Symtab.instance(context);\n-        ClassFinder cr = ClassFinder.instance(context);\n-        Names ns = Names.instance(context);\n-        Name n = ns.fromString(fullyQualifiedClassName);\n-        ClassSymbol cs = cr.loadClass(syms.inferModule(Convert.packagePart(n)), n);\n-        PubapiVisitor v = new PubapiVisitor();\n-        v.visit(cs);\n-        return v.getCollectedPubApi();\n-    }\n-\n-    public void close() throws IOException {\n-        fileManager.close();\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/PubApiExtractor.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -1,308 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.PathMatcher;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.util.Set;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.ArrayList;\n-import java.util.Map;\n-import java.util.regex.PatternSyntaxException;\n-\n-\/** A Source object maintains information about a source file.\n- * For example which package it belongs to and kind of source it is.\n- * The class also knows how to find source files (scanRoot) given include\/exclude\n- * patterns and a root.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Source implements Comparable<Source> {\n-    \/\/ The package the source belongs to.\n-   private Package pkg;\n-    \/\/ Name of this source file, relative its source root.\n-    \/\/ For example: java\/lang\/Object.java\n-    \/\/ Or if the source file is inside a module:\n-    \/\/ jdk.base\/java\/lang\/Object.java\n-    private String name;\n-    \/\/ What kind of file is this.\n-    private String suffix;\n-    \/\/ When this source file was last_modified\n-    private long lastModified;\n-    \/\/ The source File.\n-    private File file;\n-    \/\/ If the source is generated.\n-    private boolean isGenerated;\n-    \/\/ If the source is only linked to, not compiled.\n-    private boolean linkedOnly;\n-\n-    @Override\n-    public boolean equals(Object o) {\n-        return (o instanceof Source source) && name.equals(source.name);\n-    }\n-\n-    @Override\n-    public int compareTo(Source o) {\n-        return name.compareTo(o.name);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return name.hashCode();\n-    }\n-\n-    public Source(Module m, String n, File f) {\n-        name = n;\n-        int dp = n.lastIndexOf(\".\");\n-        if (dp != -1) {\n-            suffix = n.substring(dp);\n-        } else {\n-            suffix = \"\";\n-        }\n-        file = f;\n-        lastModified = f.lastModified();\n-        linkedOnly = false;\n-    }\n-\n-    public Source(Package p, String n, long lm) {\n-        pkg = p;\n-        name = n;\n-        int dp = n.lastIndexOf(\".\");\n-        if (dp != -1) {\n-            suffix = n.substring(dp);\n-        } else {\n-            suffix = \"\";\n-        }\n-        file = null;\n-        lastModified = lm;\n-        linkedOnly = false;\n-        int ls = n.lastIndexOf('\/');\n-    }\n-\n-    public String name() { return name; }\n-    public String suffix() { return suffix; }\n-    public Package pkg() { return pkg; }\n-    public File   file() { return file; }\n-    public long lastModified() {\n-        return lastModified;\n-    }\n-\n-    public void setPackage(Package p) {\n-        pkg = p;\n-    }\n-\n-    public void markAsGenerated() {\n-        isGenerated = true;\n-    }\n-\n-    public boolean isGenerated() {\n-        return isGenerated;\n-    }\n-\n-    public void markAsLinkedOnly() {\n-        linkedOnly = true;\n-    }\n-\n-    public boolean isLinkedOnly() {\n-        return linkedOnly;\n-    }\n-\n-    private void save(StringBuilder b) {\n-        String CL = linkedOnly?\"L\":\"C\";\n-        String GS = isGenerated?\"G\":\"S\";\n-        b.append(GS+\" \"+CL+\" \"+name+\" \"+file.lastModified()+\"\\n\");\n-    }\n-    \/\/ Parse a line that looks like this:\n-    \/\/ S C \/code\/alfa\/A.java 1357631228000\n-    public static Source load(Package lastPackage, String l, boolean isGenerated) {\n-        int sp = l.indexOf(' ',4);\n-        if (sp == -1) return null;\n-        String name = l.substring(4,sp);\n-        long last_modified = Long.parseLong(l.substring(sp+1));\n-\n-        boolean isLinkedOnly = false;\n-        if (l.charAt(2) == 'L') {\n-            isLinkedOnly = true;\n-        } else if (l.charAt(2) == 'C') {\n-            isLinkedOnly = false;\n-        } else return null;\n-\n-        Source s = new Source(lastPackage, name, last_modified);\n-        s.file = new File(name);\n-        if (isGenerated) s.markAsGenerated();\n-        if (isLinkedOnly) s.markAsLinkedOnly();\n-        return s;\n-    }\n-\n-    public static void saveSources(Map<String,Source> sources, StringBuilder b) {\n-        List<String> sorted_sources = new ArrayList<>();\n-        for (String key : sources.keySet()) {\n-            sorted_sources.add(key);\n-        }\n-        Collections.sort(sorted_sources);\n-        for (String key : sorted_sources) {\n-            Source s = sources.get(key);\n-            s.save(b);\n-        }\n-    }\n-\n-    \/**\n-     * Recurse into the directory root and find all files matching the excl\/incl\/exclfiles\/inclfiles rules.\n-     * Detects the existence of module-info.java files and presumes that the directory it resides in\n-     * is the name of the current module.\n-     *\/\n-    public static void scanRoot(File root,\n-                                Set<String> suffixes,\n-                                List<String> excludes,\n-                                List<String> includes,\n-                                Map<String,Source> foundFiles,\n-                                Map<String,Module> foundModules,\n-                                final Module currentModule,\n-                                boolean permitSourcesWithoutPackage,\n-                                boolean inGensrc,\n-                                boolean inLinksrc)\n-                                        throws IOException, ProblemException {\n-\n-        if (root == null)\n-            return;\n-\n-        FileSystem fs = root.toPath().getFileSystem();\n-\n-        if (includes.isEmpty()) {\n-            includes = Collections.singletonList(\"**\");\n-        }\n-\n-        List<PathMatcher> includeMatchers = createPathMatchers(fs, includes);\n-        List<PathMatcher> excludeMatchers = createPathMatchers(fs, excludes);\n-\n-        Files.walkFileTree(root.toPath(), new SimpleFileVisitor<Path>() {\n-            @Override\n-            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n-\n-                Path relToRoot = root.toPath().relativize(file);\n-\n-                if (includeMatchers.stream().anyMatch(im -> im.matches(relToRoot))\n-                        && excludeMatchers.stream().noneMatch(em -> em.matches(relToRoot))\n-                        && suffixes.contains(Util.fileSuffix(file))) {\n-\n-                    \/\/ TODO: Test this.\n-                    Source existing = foundFiles.get(file);\n-                    if (existing != null) {\n-                        throw new IOException(\"You have already added the file \"+file+\" from \"+existing.file().getPath());\n-                    }\n-                    existing = currentModule.lookupSource(file.toString());\n-                    if (existing != null) {\n-\n-                            \/\/ Oops, the source is already added, could be ok, could be not, let's check.\n-                            if (inLinksrc) {\n-                                \/\/ So we are collecting sources for linking only.\n-                                if (existing.isLinkedOnly()) {\n-                                    \/\/ Ouch, this one is also for linking only. Bad.\n-                                    throw new IOException(\"You have already added the link only file \" + file + \" from \" + existing.file().getPath());\n-                                }\n-                                \/\/ Ok, the existing source is to be compiled. Thus this link only is redundant\n-                                \/\/ since all compiled are also linked to. Continue to the next source.\n-                                \/\/ But we need to add the source, so that it will be visible to linking,\n-                                \/\/ if not the multi core compile will fail because a JavaCompiler cannot\n-                                \/\/ find the necessary dependencies for its part of the source.\n-                                foundFiles.put(file.toString(), existing);\n-                            } else {\n-                                \/\/ We are looking for sources to compile, if we find an existing to be compiled\n-                                \/\/ source with the same name, it is an internal error, since we must\n-                                \/\/ find the sources to be compiled before we find the sources to be linked to.\n-                                throw new IOException(\"Internal error: Double add of file \" + file + \" from \" + existing.file().getPath());\n-                            }\n-\n-                    } else {\n-\n-                        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-                        \/\/ Add source\n-                        Source s = new Source(currentModule, file.toString(), file.toFile());\n-                        if (inGensrc) {\n-                            s.markAsGenerated();\n-                        }\n-                        if (inLinksrc) {\n-                            s.markAsLinkedOnly();\n-                        }\n-                        String pkg = packageOfJavaFile(root.toPath(), file);\n-                        pkg = currentModule.name() + \":\" + pkg;\n-                        foundFiles.put(file.toString(), s);\n-                        currentModule.addSource(pkg, s);\n-                        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-                    }\n-                }\n-\n-                return FileVisitResult.CONTINUE;\n-            }\n-        });\n-    }\n-\n-    private static List<PathMatcher> createPathMatchers(FileSystem fs, List<String> patterns) {\n-        List<PathMatcher> matchers = new ArrayList<>();\n-        for (String pattern : patterns) {\n-            try {\n-                matchers.add(fs.getPathMatcher(\"glob:\" + pattern));\n-            } catch (PatternSyntaxException e) {\n-                Log.error(\"Invalid pattern: \" + pattern);\n-                throw e;\n-            }\n-        }\n-        return matchers;\n-    }\n-\n-    private static String packageOfJavaFile(Path sourceRoot, Path javaFile) {\n-        Path javaFileDir = javaFile.getParent();\n-        Path packageDir = sourceRoot.relativize(javaFileDir);\n-        List<String> separateDirs = new ArrayList<>();\n-        for (Path pathElement : packageDir) {\n-            separateDirs.add(pathElement.getFileName().toString());\n-        }\n-        return String.join(\".\", separateDirs);\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"%s[pkg: %s, name: %s, suffix: %s, file: %s, isGenerated: %b, linkedOnly: %b]\",\n-                             getClass().getSimpleName(),\n-                             pkg,\n-                             name,\n-                             suffix,\n-                             file,\n-                             isGenerated,\n-                             linkedOnly);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Source.java","additions":0,"deletions":308,"binary":false,"changes":308,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.Writer;\n-import java.net.URI;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import com.sun.tools.sjavac.comp.CompilationService;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * The transform interface is used to transform content inside a package, from one form to another.\n- * Usually the output form is an unpredictable number of output files. (eg class files)\n- * but can also be an unpredictable number of generated source files (eg idl2java)\n- * or a single predictable output file (eg when copying, cleaning or compiling a properties file).\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public interface Transformer {\n-    \/**\n-     * The transform method takes a set of package names, mapped to their source files and to the\n-     * pubapis of the packages.\n-     *\n-     * The transform implementation must:\n-     *    store the names of the generated artifacts for each package into package_artifacts\n-     *    store found dependencies to other packages into the supplied set package_dependencies\n-     *    store the public api for a package into the supplied set package_pubapis\n-     *\n-     * Any benign messages as a result of running the transform\n-     * are written into stdout, and errors are written to stderr.\n-     *\n-     * The debug_level can be 0=silent (only warnings and errors) 1=normal 2=verbose 3 or greater=debug\n-     * setExtra is used to set the extra information information that can be passed on\n-     * the command line to the smart javac wrapper.\n-     *\n-     * If sjavac is building incrementally from an existing javac_state, the var incremental is true.\n-     *\n-     * The transformer will only be called if some source in the package (or dependency) has\n-     * a modified timestamp. Thus the transformer might get called with many sources, of which\n-     * only one has changed. The transformer is allowed to regenerate all artifacts but\n-     * a better transformer will only write those artifacts that need updating.\n-     *\n-     * However the transformer must verify that the existing artifacts really are there!\n-     * and it must always update package_artifacts, package_dependencies, and package_pubapis correctly.\n-     * This means that at least for Java source, it will always have to recompile the sources.\n-     *\n-     * The transformer is allowed to put files anywhere in the dest_root.\n-     * An example of this is, can be the META-INF transformer that copy files\n-     * below META-INF directories to the single META-INF directory below dest_root.\n-     *\n-     * False is returned if there was an error that prevented the transform.\n-     * I.e. something was printed on stderr.\n-     *\n-     * If num_cores is set to a non-zero value. The transform should attempt to use no more than these\n-     * number of threads for heavy work.\n-     *\/\n-    boolean transform(CompilationService sjavac,\n-                      Map<String,Set<URI>> pkgSrcs,\n-                      Set<URI>             visibleSources,\n-                      Map<String,Set<String>> oldPackageDependencies,\n-                      URI destRoot,\n-                      Map<String,Set<URI>>    packageArtifacts,\n-                      Map<String, Map<String, Set<String>>> packageDependencies,   \/\/ Package name -> Fully Qualified Type [from] -> Set of fully qualified type [to]\n-                      Map<String, Map<String, Set<String>>> packageCpDependencies, \/\/ Package name -> Fully Qualified Type [from] -> Set of fully qualified type [to]\n-                      Map<String, PubApi>     packagePublicApis,\n-                      Map<String, PubApi>     dependencyApis,\n-                      int debugLevel,\n-                      boolean incremental,\n-                      int numCores);\n-\n-    void setExtra(String e);\n-    void setExtra(Options args);\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Transformer.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"patch":"@@ -1,255 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac;\n-\n-import java.io.File;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Path;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.StringTokenizer;\n-import java.util.function.Function;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-\/**\n- * Utilities.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Util {\n-\n-    public static String toFileSystemPath(String pkgId) {\n-        if (pkgId == null || pkgId.length()==0) return null;\n-        String pn;\n-        if (pkgId.charAt(0) == ':') {\n-            \/\/ When the module is the default empty module.\n-            \/\/ Do not prepend the module directory, because there is none.\n-            \/\/ Thus :java.foo.bar translates to java\/foo\/bar (or \\)\n-            pn = pkgId.substring(1).replace('.',File.separatorChar);\n-        } else {\n-            \/\/ There is a module. Thus jdk.base:java.foo.bar translates\n-            \/\/ into jdk.base\/java\/foo\/bar\n-            int cp = pkgId.indexOf(':');\n-            String mn = pkgId.substring(0,cp);\n-            pn = mn+File.separatorChar+pkgId.substring(cp+1).replace('.',File.separatorChar);\n-        }\n-        return pn;\n-    }\n-\n-    public static String justPackageName(String pkgName) {\n-        int c = pkgName.indexOf(\":\");\n-        if (c == -1)\n-            throw new IllegalArgumentException(\"Expected ':' in package name (\" + pkgName + \")\");\n-        return pkgName.substring(c+1);\n-    }\n-\n-    public static String extractStringOption(String opName, String s) {\n-        return extractStringOption(opName, s, null);\n-    }\n-\n-    private static String extractStringOptionWithDelimiter(String opName, String s, String deflt, char delimiter) {\n-        int p = s.indexOf(opName+\"=\");\n-        if (p == -1) return deflt;\n-        p+=opName.length()+1;\n-        int pe = s.indexOf(delimiter, p);\n-        if (pe == -1) pe = s.length();\n-        return s.substring(p, pe);\n-    }\n-\n-    public static String extractStringOption(String opName, String s, String deflt) {\n-        return extractStringOptionWithDelimiter(opName, s, deflt, ',');\n-    }\n-\n-    public static String extractStringOptionLine(String opName, String s, String deflt) {\n-        return extractStringOptionWithDelimiter(opName, s, deflt, '\\n').strip();\n-    }\n-\n-    public static boolean extractBooleanOption(String opName, String s, boolean deflt) {\n-        String str = extractStringOption(opName, s);\n-        return \"true\".equals(str) ? true\n-             : \"false\".equals(str) ? false\n-             : deflt;\n-    }\n-\n-    public static int extractIntOption(String opName, String s) {\n-        return extractIntOption(opName, s, 0);\n-    }\n-\n-    public static int extractIntOption(String opName, String s, int deflt) {\n-        int p = s.indexOf(opName+\"=\");\n-        if (p == -1) return deflt;\n-        p+=opName.length()+1;\n-        int pe = s.indexOf(',', p);\n-        if (pe == -1) pe = s.length();\n-        int v = 0;\n-        try {\n-            v = Integer.parseInt(s.substring(p, pe));\n-        } catch (Exception e) {}\n-        return v;\n-    }\n-\n-    \/**\n-     * Extract the package name from a fully qualified class name.\n-     *\n-     * Example: Given \"pkg.subpkg.A\" this method returns \":pkg.subpkg\".\n-     * Given \"C\" this method returns \":\".\n-     *\n-     * @returns package name of the given class name\n-     *\/\n-    public static String pkgNameOfClassName(String fqClassName) {\n-        int i = fqClassName.lastIndexOf('.');\n-        String pkg = i == -1 ? \"\" : fqClassName.substring(0, i);\n-        return \":\" + pkg;\n-    }\n-\n-    \/**\n-     * Clean out unwanted sub options supplied inside a primary option.\n-     * For example to only had portfile remaining from:\n-     *    settings=\"--server:id=foo,portfile=bar\"\n-     * do settings = cleanOptions(\"--server:\",Util.set(\"-portfile\"),settings);\n-     *    now settings equals \"--server:portfile=bar\"\n-     *\n-     * @param allowedSubOptions A set of the allowed sub options, id portfile etc.\n-     * @param s The option settings string.\n-     *\/\n-    public static String cleanSubOptions(Set<String> allowedSubOptions, String s) {\n-        StringBuilder sb = new StringBuilder();\n-        StringTokenizer st = new StringTokenizer(s, \",\");\n-        while (st.hasMoreTokens()) {\n-            String o = st.nextToken();\n-            int p = o.indexOf('=');\n-            if (p>0) {\n-                String key = o.substring(0,p);\n-                String val = o.substring(p+1);\n-                if (allowedSubOptions.contains(key)) {\n-                    if (sb.length() > 0) sb.append(',');\n-                    sb.append(key+\"=\"+val);\n-                }\n-            }\n-        }\n-        return sb.toString();\n-    }\n-\n-    \/**\n-     * Convenience method to create a set with strings.\n-     *\/\n-    public static Set<String> set(String... ss) {\n-        Set<String> set = new HashSet<>();\n-        set.addAll(Arrays.asList(ss));\n-        return set;\n-    }\n-\n-    \/**\n-     * Normalize windows drive letter paths to upper case to enable string\n-     * comparison.\n-     *\n-     * @param file File name to normalize\n-     * @return The normalized string if file has a drive letter at the beginning,\n-     *         otherwise the original string.\n-     *\/\n-    public static String normalizeDriveLetter(String file) {\n-        if (file.length() > 2 && file.charAt(1) == ':') {\n-            return Character.toUpperCase(file.charAt(0)) + file.substring(1);\n-        } else if (file.length() > 3 && file.charAt(0) == '*'\n-                   && file.charAt(2) == ':') {\n-            \/\/ Handle a wildcard * at the beginning of the string.\n-            return file.substring(0, 1) + Character.toUpperCase(file.charAt(1))\n-                   + file.substring(2);\n-        }\n-        return file;\n-    }\n-\n-    \/**\n-     * Locate the setting for the server properties.\n-     *\/\n-    public static String findServerSettings(String[] args) {\n-        for (String s : args) {\n-            if (s.startsWith(\"--server:\")) {\n-                return s;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public static <E> Set<E> union(Set<? extends E> s1,\n-                                   Set<? extends E> s2) {\n-        Set<E> union = new HashSet<>();\n-        union.addAll(s1);\n-        union.addAll(s2);\n-        return union;\n-    }\n-\n-    public static <E> Set<E> subtract(Set<? extends E> orig,\n-                                      Set<? extends E> toSubtract) {\n-        Set<E> difference = new HashSet<>(orig);\n-        difference.removeAll(toSubtract);\n-        return difference;\n-    }\n-\n-    public static String getStackTrace(Throwable t) {\n-        StringWriter sw = new StringWriter();\n-        t.printStackTrace(new PrintWriter(sw));\n-        return sw.toString();\n-    }\n-\n-    \/\/ TODO: Remove when refactoring from java.io.File to java.nio.file.Path.\n-    public static File pathToFile(Path path) {\n-        return path == null ? null : path.toFile();\n-    }\n-\n-    public static <E> Set<E> intersection(Collection<? extends E> c1,\n-                                          Collection<? extends E> c2) {\n-        Set<E> intersection = new HashSet<E>(c1);\n-        intersection.retainAll(c2);\n-        return intersection;\n-    }\n-\n-    public static <I, T> Map<I, T> indexBy(Collection<? extends T> c,\n-                                           Function<? super T, ? extends I> indexFunction) {\n-        return c.stream().collect(Collectors.<T, I, T>toMap(indexFunction, o -> o));\n-    }\n-\n-    public static String fileSuffix(Path file) {\n-        String fileNameStr = file.getFileName().toString();\n-        int dotIndex = fileNameStr.indexOf('.');\n-        return dotIndex == -1 ? \"\" : fileNameStr.substring(dotIndex);\n-    }\n-\n-    public static Stream<String> getLines(String str) {\n-        return str.isEmpty()\n-                ? Stream.empty()\n-                : Stream.of(str.split(Pattern.quote(System.lineSeparator())));\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/Util.java","additions":0,"deletions":255,"binary":false,"changes":255,"status":"deleted"},{"patch":"@@ -1,87 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.client;\n-\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.AutoFlushWriter;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Util;\n-import com.sun.tools.sjavac.comp.SjavacImpl;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.server.Sjavac;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ClientMain {\n-\n-    public static int run(String[] args) {\n-        return run(args,\n-                   new AutoFlushWriter(new OutputStreamWriter(System.out)),\n-                   new AutoFlushWriter(new OutputStreamWriter(System.err)));\n-    }\n-\n-    public static int run(String[] args, Writer out, Writer err) {\n-\n-        Log.setLogForCurrentThread(new Log(out, err));\n-\n-        Options options;\n-        try {\n-            options = Options.parseArgs(args);\n-        } catch (IllegalArgumentException e) {\n-            Log.error(e.getMessage());\n-            return Result.CMDERR.exitCode;\n-        }\n-\n-        Log.setLogLevel(options.getLogLevel());\n-\n-        Log.debug(\"==========================================================\");\n-        Log.debug(\"Launching sjavac client with the following parameters:\");\n-        Log.debug(\"    \" + options.getStateArgsString());\n-        Log.debug(\"==========================================================\");\n-\n-        \/\/ Prepare sjavac object\n-        boolean useServer = options.getServerConf() != null;\n-        Sjavac sjavac = useServer ? new SjavacClient(options) : new SjavacImpl();\n-\n-        \/\/ Perform compilation\n-        Result result = sjavac.compile(args);\n-\n-        \/\/ If sjavac is running in the foreground we should shut it down at this point\n-        if (!useServer) {\n-            sjavac.shutdown();\n-        }\n-\n-        return result.exitCode;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/client\/ClientMain.java","additions":0,"deletions":87,"binary":false,"changes":87,"status":"deleted"},{"patch":"@@ -1,171 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.net.URI;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Set;\n-\n-import javax.tools.JavaFileObject;\n-import javax.tools.StandardJavaFileManager;\n-import javax.tools.StandardLocation;\n-import javax.tools.ToolProvider;\n-\n-import com.sun.tools.javac.api.JavacTaskImpl;\n-import com.sun.tools.javac.api.JavacTool;\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Dependencies;\n-import com.sun.tools.javac.util.ListBuffer;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Util;\n-import com.sun.tools.sjavac.comp.dependencies.NewDependencyCollector;\n-import com.sun.tools.sjavac.comp.dependencies.PublicApiCollector;\n-import com.sun.tools.sjavac.server.CompilationSubResult;\n-import com.sun.tools.sjavac.server.SysInfo;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class CompilationService {\n-\n-    public SysInfo getSysInfo() {\n-        return new SysInfo(Runtime.getRuntime().availableProcessors(),\n-                           Runtime.getRuntime().maxMemory());\n-    }\n-\n-    public CompilationSubResult compile(String protocolId,\n-                                     String invocationId,\n-                                     String[] args,\n-                                     List<File> explicitSources,\n-                                     Set<URI> sourcesToCompile,\n-                                     Set<URI> visibleSources) {\n-\n-        JavacTool compiler = (JavacTool) ToolProvider.getSystemJavaCompiler();\n-        try (StandardJavaFileManager fm = compiler.getStandardFileManager(null, null, null)) {\n-            SmartFileManager sfm = new SmartFileManager(fm);\n-            Context context = new Context();\n-\n-            Dependencies.GraphDependencies.preRegister(context);\n-\n-            \/\/ Now setup the actual compilation\n-            CompilationSubResult compilationResult = new CompilationSubResult(Result.OK);\n-\n-            \/\/ First deal with explicit source files on cmdline and in at file\n-            ListBuffer<JavaFileObject> explicitJFOs = new ListBuffer<>();\n-            for (JavaFileObject jfo : fm.getJavaFileObjectsFromFiles(explicitSources)) {\n-                explicitJFOs.append(SmartFileManager.locWrap(jfo, StandardLocation.SOURCE_PATH));\n-            }\n-            \/\/ Now deal with sources supplied as source_to_compile\n-            ListBuffer<File> sourcesToCompileFiles = new ListBuffer<>();\n-            for (URI u : sourcesToCompile)\n-                sourcesToCompileFiles.append(new File(u));\n-\n-            for (JavaFileObject jfo : fm.getJavaFileObjectsFromFiles(sourcesToCompileFiles))\n-                explicitJFOs.append(SmartFileManager.locWrap(jfo, StandardLocation.SOURCE_PATH));\n-\n-            \/\/ Create a log to capture compiler output\n-            StringWriter stderrLog = new StringWriter();\n-            Result result;\n-            PublicApiCollector pubApiCollector = new PublicApiCollector(context, explicitJFOs);\n-            PathAndPackageVerifier papVerifier = new PathAndPackageVerifier();\n-            NewDependencyCollector depsCollector = new NewDependencyCollector(context, explicitJFOs);\n-            try {\n-                if (explicitJFOs.size() > 0) {\n-                    sfm.setVisibleSources(visibleSources);\n-                    sfm.cleanArtifacts();\n-\n-                    \/\/ Do the compilation!\n-                    JavacTaskImpl task =\n-                            (JavacTaskImpl) compiler.getTask(new PrintWriter(stderrLog),\n-                                                             sfm,\n-                                                             null,\n-                                                             Arrays.asList(args),\n-                                                             null,\n-                                                             explicitJFOs,\n-                                                             context);\n-                    sfm.setSymbolFileEnabled(!com.sun.tools.javac.util.Options.instance(context).isSet(\"ignore.symbol.file\"));\n-                    task.addTaskListener(depsCollector);\n-                    task.addTaskListener(pubApiCollector);\n-                    task.addTaskListener(papVerifier);\n-                    logJavacInvocation(args);\n-                    result = task.doCall();\n-                    Log.debug(\"javac result: \" + result);\n-                    sfm.flush();\n-                } else {\n-                    result = Result.ERROR;\n-                }\n-            } catch (Exception e) {\n-                Log.error(Util.getStackTrace(e));\n-                stderrLog.append(Util.getStackTrace(e));\n-                result = Result.ERROR;\n-            }\n-\n-            compilationResult.packageArtifacts = sfm.getPackageArtifacts();\n-\n-            if (papVerifier.errorsDiscovered()) {\n-                result = Result.ERROR;\n-            }\n-\n-            compilationResult.packageDependencies = depsCollector.getDependencies(false);\n-            compilationResult.packageCpDependencies = depsCollector.getDependencies(true);\n-\n-            compilationResult.packagePubapis = pubApiCollector.getPubApis(true);\n-            compilationResult.dependencyPubapis = pubApiCollector.getPubApis(false);\n-            compilationResult.stderr = stderrLog.toString();\n-            compilationResult.result = result;\n-\n-            return compilationResult;\n-        } catch (IOException e) {\n-            throw new Error(e);\n-        }\n-    }\n-\n-    private void logJavacInvocation(String[] args) {\n-        Log.debug(\"Invoking javac with args\");\n-        Iterator<String> argIter = Arrays.asList(args).iterator();\n-        while (argIter.hasNext()) {\n-            String arg = argIter.next();\n-            String line = \"    \" + arg;\n-            if (arg.matches(\"\\\\-(d|cp|classpath|sourcepath|source|target)\")\n-                    && argIter.hasNext()) {\n-                line += \" \" + argIter.next();\n-            }\n-            Log.debug(line);\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/CompilationService.java","additions":0,"deletions":171,"binary":false,"changes":171,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import javax.tools.FileObject;\n-import javax.tools.ForwardingFileObject;\n-import javax.tools.JavaFileManager.Location;\n-\n-import com.sun.tools.javac.api.ClientCodeWrapper.Trusted;\n-\n-@Trusted\n-public class FileObjectWithLocation<F extends FileObject> extends ForwardingFileObject<F> {\n-\n-    private final Location loc;\n-\n-    public FileObjectWithLocation(F delegate, Location loc) {\n-        super(delegate);\n-        this.loc = loc;\n-    }\n-\n-    public Location getLocation() {\n-        return loc;\n-    }\n-\n-    public FileObject getDelegate() {\n-        return fileObject;\n-    }\n-\n-    public String toString() {\n-        return \"FileObjectWithLocation[\" + fileObject + \"]\";\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/FileObjectWithLocation.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import javax.tools.ForwardingJavaFileObject;\n-import javax.tools.JavaFileManager.Location;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.api.ClientCodeWrapper.Trusted;\n-\n-@Trusted\n-public class JavaFileObjectWithLocation<F extends JavaFileObject> extends ForwardingJavaFileObject<F> {\n-\n-    private final Location loc;\n-\n-    public JavaFileObjectWithLocation(F delegate, Location loc) {\n-        super(delegate);\n-        this.loc = loc;\n-    }\n-\n-    public Location getLocation() {\n-        return loc;\n-    }\n-\n-    public F getDelegate() {\n-        return fileObject;\n-    }\n-\n-    public String toString() {\n-        return \"JavaFileObjectWithLocation[loc: \" + loc + \", \" + fileObject + \"]\";\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return loc.hashCode() ^ fileObject.hashCode();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        return (obj instanceof JavaFileObjectWithLocation<?> javaFileObjectWithLocation)\n-                && loc.equals(javaFileObjectWithLocation.loc)\n-                && fileObject.equals(javaFileObjectWithLocation.fileObject);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/JavaFileObjectWithLocation.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.Set;\n-\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.source.tree.CompilationUnitTree;\n-import com.sun.source.util.TaskEvent;\n-import com.sun.source.util.TaskListener;\n-import com.sun.tools.javac.tree.JCTree;\n-import com.sun.tools.javac.tree.JCTree.JCFieldAccess;\n-import com.sun.tools.javac.tree.JCTree.JCIdent;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.javac.util.Name;\n-import com.sun.tools.sjavac.Log;\n-\n-public class PathAndPackageVerifier implements TaskListener {\n-\n-    \/\/ Stores the set of compilation units whose source file path does not\n-    \/\/ match the package declaration.\n-    Set<CompilationUnitTree> misplacedCompilationUnits = new HashSet<>();\n-\n-    @Override\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public void finished(TaskEvent e) {\n-        if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n-\n-            CompilationUnitTree cu = e.getCompilationUnit();\n-            if (cu == null)\n-                return;\n-\n-            JavaFileObject jfo = cu.getSourceFile();\n-            if (jfo == null)\n-                return; \/\/ No source file -> package doesn't matter\n-\n-            JCTree pkg = (JCTree) cu.getPackageName();\n-            if (pkg == null)\n-                return; \/\/ Default package. See JDK-8048144.\n-\n-            Path dir = Paths.get(jfo.toUri()).normalize().getParent();\n-            if (!checkPathAndPackage(dir, pkg))\n-                misplacedCompilationUnits.add(cu);\n-        }\n-\n-        if (e.getKind() == TaskEvent.Kind.COMPILATION) {\n-            for (CompilationUnitTree cu : misplacedCompilationUnits) {\n-                Log.error(\"Misplaced compilation unit.\");\n-                Log.error(\"    Directory: \" + Paths.get(cu.getSourceFile().toUri()).getParent());\n-                Log.error(\"    Package:   \" + cu.getPackageName());\n-            }\n-        }\n-    }\n-\n-    public boolean errorsDiscovered() {\n-        return misplacedCompilationUnits.size() > 0;\n-    }\n-\n-    \/* Returns true if dir matches pkgName.\n-     *\n-     * Examples:\n-     *     (a\/b\/c, a.b.c) gives true\n-     *     (i\/j\/k, i.x.k) gives false\n-     *\n-     * Currently (x\/a\/b\/c, a.b.c) also gives true. See JDK-8059598.\n-     *\/\n-    private boolean checkPathAndPackage(Path dir, JCTree pkgName) {\n-        Iterator<String> pathIter = new ParentIterator(dir);\n-        Iterator<String> pkgIter = new EnclosingPkgIterator(pkgName);\n-        while (pathIter.hasNext() && pkgIter.hasNext()) {\n-            if (!pathIter.next().equals(pkgIter.next()))\n-                return false;\n-        }\n-        return !pkgIter.hasNext(); \/*&& !pathIter.hasNext() See JDK-8059598 *\/\n-    }\n-\n-    \/* Iterates over the names of the parents of the given path:\n-     * Example: dir1\/dir2\/dir3  results in  dir3 -> dir2 -> dir1\n-     *\/\n-    private static class ParentIterator implements Iterator<String> {\n-        Path next;\n-        ParentIterator(Path initial) {\n-            next = initial;\n-        }\n-        @Override\n-        public boolean hasNext() {\n-            return next != null;\n-        }\n-        @Override\n-        public String next() {\n-            String tmp = next.getFileName().toString();\n-            next = next.getParent();\n-            return tmp;\n-        }\n-    }\n-\n-    \/* Iterates over the names of the enclosing packages:\n-     * Example: pkg1.pkg2.pkg3  results in  pkg3 -> pkg2 -> pkg1\n-     *\/\n-    private static class EnclosingPkgIterator implements Iterator<String> {\n-        JCTree next;\n-        EnclosingPkgIterator(JCTree initial) {\n-            next = initial;\n-        }\n-        @Override\n-        public boolean hasNext() {\n-            return next != null;\n-        }\n-        @Override\n-        public String next() {\n-            Name name;\n-            if (next instanceof JCIdent identNext) {\n-                name = identNext.name;\n-                next = null;\n-            } else {\n-                JCFieldAccess fa = (JCFieldAccess) next;\n-                name = fa.name;\n-                next = fa.selected;\n-            }\n-            return name.toString();\n-        }\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/PathAndPackageVerifier.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n-import javax.lang.model.element.Element;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.Log;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- * Utility class containing public API information.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class PubAPIs {\n-    protected static final Context.Key<PubAPIs> pubApisKey = new Context.Key<>();\n-\n-    \/\/ The log to be used for error reporting.\n-    protected Log log;\n-\n-    \/\/ Map from a class name to its public api.\n-    \/\/ Will the Name encode the module in the future?\n-    \/\/ If not, this will have to change to map from Module+Name to public api.\n-    protected Map<ClassSymbol, PubApi> publicApiPerClass = new HashMap<>();\n-\n-    public static PubAPIs instance(Context context) {\n-        PubAPIs instance = context.get(pubApisKey);\n-        if (instance == null)\n-            instance = new PubAPIs(context);\n-        return instance;\n-    }\n-\n-    private PubAPIs(Context context) {\n-        context.put(pubApisKey, this);\n-        log = Log.instance(context);\n-    }\n-\n-    \/**\n-     * Convert the map from class names to their pubapi to a map\n-     * from package names to their pubapi.\n-     *\/\n-    public Map<String, PubApi> getPubapis(Collection<JavaFileObject> explicitJFOs, boolean explicits) {\n-\n-        \/\/ Maps \":java.lang\" to a package level pub api (with only types on top level)\n-        Map<String, PubApi> result = new HashMap<>();\n-        for (ClassSymbol cs : publicApiPerClass.keySet()) {\n-\n-            boolean amongExplicits = explicitJFOs.contains(cs.sourcefile);\n-            if (explicits != amongExplicits)\n-                continue;\n-\n-            String pkg = \":\" + cs.packge().fullname;\n-            PubApi currentPubApi = result.getOrDefault(pkg, new PubApi());\n-            result.put(pkg, PubApi.mergeTypes(currentPubApi, publicApiPerClass.get(cs)));\n-        }\n-\n-        return result;\n-    }\n-\n-    \/**\n-     * Visit the api of a class and construct a pubapi and\n-     * store it into the pubapi_perclass map.\n-     *\/\n-    @SuppressWarnings(\"deprecation\")\n-    public void visitPubapi(Element e) {\n-\n-        \/\/ Skip anonymous classes for now\n-        if (e == null)\n-            return;\n-\n-        PubapiVisitor v = new PubapiVisitor();\n-        v.visit(e);\n-        publicApiPerClass.put((ClassSymbol) e, v.getCollectedPubApi());\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/PubAPIs.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -1,172 +0,0 @@\n-\/*\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import static javax.lang.model.element.Modifier.PRIVATE;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.*;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.util.ElementScanner14;\n-\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-import com.sun.tools.sjavac.pubapi.PubApiTypeParam;\n-import com.sun.tools.sjavac.pubapi.PubMethod;\n-import com.sun.tools.sjavac.pubapi.PubType;\n-import com.sun.tools.sjavac.pubapi.PubVar;\n-import com.sun.tools.sjavac.pubapi.TypeDesc;\n-\n-\/** Utility class that constructs a textual representation\n- * of the public api of a class.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class PubapiVisitor extends ElementScanner14<Void, Void> {\n-\n-    private PubApi collectedApi = new PubApi();\n-\n-    private boolean isNonPrivate(Element e) {\n-        return !e.getModifiers().contains(PRIVATE);\n-    }\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public Void visitType(TypeElement e, Void p) {\n-        if (isNonPrivate(e)) {\n-            PubApi prevApi = collectedApi;\n-            collectedApi = new PubApi();\n-            super.visitType(e, p);\n-            if (!isAnonymous(e)) {\n-                String name = ((ClassSymbol) e).flatname.toString();\n-                PubType t = new PubType(e.getModifiers(),\n-                                        name,\n-                                        \/\/e.getQualifiedName().toString(),\n-                                        collectedApi);\n-                prevApi.types.put(t.fqName, t);\n-            }\n-            collectedApi = prevApi;\n-        }\n-        return null;\n-    }\n-\n-    private boolean isAnonymous(TypeElement e) {\n-        return e.getQualifiedName().length() == 0;\n-    }\n-\n-    private static String encodeChar(int c) {\n-        return String.format(\"\\\\u%04x\", c);\n-    }\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public Void visitVariable(VariableElement e, Void p) {\n-        if (isNonPrivate(e)) {\n-            Object constVal = e.getConstantValue();\n-            String constValStr = null;\n-            \/\/ TODO: This doesn't seem to be entirely accurate. What if I change\n-            \/\/ from, say, 0 to 0L? (And the field is public static final so that\n-            \/\/ it could get inlined.)\n-            if (constVal != null) {\n-                if (e.asType().toString().equals(\"char\")) {\n-                    \/\/ What type is 'value'? Is it already a char?\n-                    char c = constVal.toString().charAt(0);\n-                    constValStr = \"'\" + encodeChar(c) + \"'\";\n-                } else {\n-                    constValStr = constVal.toString()\n-                                          .chars()\n-                                          .mapToObj(PubapiVisitor::encodeChar)\n-                                          .collect(Collectors.joining(\"\", \"\\\"\", \"\\\"\"));\n-                }\n-            }\n-\n-            PubVar v = new PubVar(e.getModifiers(),\n-                                  TypeDesc.fromType(e.asType()),\n-                                  e.toString(),\n-                                  constValStr);\n-            collectedApi.variables.put(v.identifier, v);\n-        }\n-\n-        \/\/ Safe to not recurse here, because the only thing\n-        \/\/ to visit here is the constructor of a variable declaration.\n-        \/\/ If it happens to contain an anonymous inner class (which it might)\n-        \/\/ then this class is never visible outside of the package anyway, so\n-        \/\/ we are allowed to ignore it here.\n-        return null;\n-    }\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public Void visitRecordComponent(RecordComponentElement e, Void p) {\n-        PubVar v = new PubVar(e.getModifiers(),\n-                TypeDesc.fromType(e.asType()),\n-                e.toString(),\n-                null);\n-        collectedApi.recordComponents.put(v.identifier, v);\n-        return null;\n-    }\n-\n-    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-    public Void visitExecutable(ExecutableElement e, Void p) {\n-        if (isNonPrivate(e)) {\n-            PubMethod m = new PubMethod(e.getModifiers(),\n-                                        getTypeParameters(e.getTypeParameters()),\n-                                        TypeDesc.fromType(e.getReturnType()),\n-                                        e.getSimpleName().toString(),\n-                                        getTypeDescs(getParamTypes(e)),\n-                                        getTypeDescs(e.getThrownTypes()));\n-            collectedApi.methods.put(m.asSignatureString(), m);\n-        }\n-        return null;\n-    }\n-\n-    private List<PubApiTypeParam> getTypeParameters(List<? extends TypeParameterElement> elements) {\n-        return elements.stream()\n-                       .map(e -> new PubApiTypeParam(e.getSimpleName().toString(), getTypeDescs(e.getBounds())))\n-                       .toList();\n-    }\n-\n-    private List<TypeMirror> getParamTypes(ExecutableElement e) {\n-        return e.getParameters()\n-                .stream()\n-                .map(VariableElement::asType)\n-                .toList();\n-    }\n-\n-    private List<TypeDesc> getTypeDescs(List<? extends TypeMirror> list) {\n-        return list.stream()\n-                   .map(TypeDesc::fromType)\n-                   .toList();\n-    }\n-\n-    public PubApi getCollectedPubApi() {\n-        return collectedApi;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/PubapiVisitor.java","additions":0,"deletions":172,"binary":false,"changes":172,"status":"deleted"},{"patch":"@@ -1,399 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.javac.file.JavacFileManager;\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.sjavac.JavacState;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Module;\n-import com.sun.tools.sjavac.ProblemException;\n-import com.sun.tools.sjavac.Source;\n-import com.sun.tools.sjavac.Transformer;\n-import com.sun.tools.sjavac.Util;\n-import com.sun.tools.sjavac.options.Option;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.options.SourceLocation;\n-import com.sun.tools.sjavac.server.Sjavac;\n-import java.io.UncheckedIOException;\n-\n-import javax.tools.JavaFileManager;\n-\n-\/**\n- * The sjavac implementation that interacts with javac and performs the actual\n- * compilation.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SjavacImpl implements Sjavac {\n-\n-    @Override\n-    public Result compile(String[] args) {\n-        Options options;\n-        try {\n-            options = Options.parseArgs(args);\n-        } catch (IllegalArgumentException e) {\n-            Log.error(e.getMessage());\n-            return Result.CMDERR;\n-        }\n-\n-        if (!validateOptions(options))\n-            return Result.CMDERR;\n-\n-        if (srcDstOverlap(options.getSources(), options.getDestDir())) {\n-            return Result.CMDERR;\n-        }\n-\n-        if (!createIfMissing(options.getDestDir()))\n-            return Result.ERROR;\n-\n-        Path stateDir = options.getStateDir();\n-        if (stateDir != null && !createIfMissing(options.getStateDir()))\n-            return Result.ERROR;\n-\n-        Path gensrc = options.getGenSrcDir();\n-        if (gensrc != null && !createIfMissing(gensrc))\n-            return Result.ERROR;\n-\n-        Path hdrdir = options.getHeaderDir();\n-        if (hdrdir != null && !createIfMissing(hdrdir))\n-            return Result.ERROR;\n-\n-        if (stateDir == null) {\n-            \/\/ Prepare context. Direct logging to our byte array stream.\n-            Context context = new Context();\n-            StringWriter strWriter = new StringWriter();\n-            PrintWriter printWriter = new PrintWriter(strWriter);\n-            com.sun.tools.javac.util.Log.preRegister(context, printWriter);\n-            JavacFileManager.preRegister(context);\n-\n-            \/\/ Prepare arguments\n-            String[] passThroughArgs = Stream.of(args)\n-                                             .filter(arg -> !arg.startsWith(Option.SERVER.arg))\n-                                             .toArray(String[]::new);\n-            \/\/ Compile\n-            Result result = new Main(\"javac\", printWriter).compile(passThroughArgs, context);\n-\n-            \/\/ Process compiler output (which is always errors)\n-            printWriter.flush();\n-            Util.getLines(strWriter.toString()).forEach(Log::error);\n-\n-            \/\/ Clean up\n-            JavaFileManager fileManager = context.get(JavaFileManager.class);\n-            if (fileManager instanceof JavacFileManager javacFileManager) {\n-                try {\n-                    javacFileManager.close();\n-                } catch (IOException es) {\n-                    throw new UncheckedIOException(es);\n-                }\n-            }\n-            return result;\n-\n-        } else {\n-            \/\/ Load the prev build state database.\n-            JavacState javac_state = JavacState.load(options);\n-\n-            \/\/ Setup the suffix rules from the command line.\n-            Map<String, Transformer> suffixRules = new HashMap<>();\n-\n-            \/\/ Handling of .java-compilation\n-            suffixRules.putAll(javac_state.getJavaSuffixRule());\n-\n-            \/\/ Handling of -copy and -tr\n-            suffixRules.putAll(options.getTranslationRules());\n-\n-            \/\/ All found modules are put here.\n-            Map<String,Module> modules = new HashMap<>();\n-            \/\/ We start out in the legacy empty no-name module.\n-            \/\/ As soon as we stumble on a module-info.java file we change to that module.\n-            Module current_module = new Module(\"\", \"\");\n-            modules.put(\"\", current_module);\n-\n-            try {\n-                \/\/ Find all sources, use the suffix rules to know which files are sources.\n-                Map<String,Source> sources = new HashMap<>();\n-\n-                \/\/ Find the files, this will automatically populate the found modules\n-                \/\/ with found packages where the sources are found!\n-                findSourceFiles(options.getSources(),\n-                                suffixRules.keySet(),\n-                                sources,\n-                                modules,\n-                                current_module,\n-                                options.isDefaultPackagePermitted(),\n-                                false);\n-\n-                if (sources.isEmpty()) {\n-                    Log.error(\"Found nothing to compile!\");\n-                    return Result.ERROR;\n-                }\n-\n-\n-                \/\/ Create a map of all source files that are available for linking. Both -src and\n-                \/\/ -sourcepath point to such files. It is possible to specify multiple\n-                \/\/ -sourcepath options to enable different filtering rules. If the\n-                \/\/ filters are the same for multiple sourcepaths, they may be concatenated\n-                \/\/ using :(;). Before sending the list of sourcepaths to javac, they are\n-                \/\/ all concatenated. The list created here is used by the SmartFileWrapper to\n-                \/\/ make sure only the correct sources are actually available.\n-                \/\/ We might find more modules here as well.\n-                Map<String,Source> sources_to_link_to = new HashMap<>();\n-\n-                List<SourceLocation> sourceResolutionLocations = new ArrayList<>();\n-                sourceResolutionLocations.addAll(options.getSources());\n-                sourceResolutionLocations.addAll(options.getSourceSearchPaths());\n-                findSourceFiles(sourceResolutionLocations,\n-                                Collections.singleton(\".java\"),\n-                                sources_to_link_to,\n-                                modules,\n-                                current_module,\n-                                options.isDefaultPackagePermitted(),\n-                                true);\n-\n-                \/\/ Add the set of sources to the build database.\n-                javac_state.now().flattenPackagesSourcesAndArtifacts(modules);\n-                javac_state.now().checkInternalState(\"checking sources\", false, sources);\n-                javac_state.now().checkInternalState(\"checking linked sources\", true, sources_to_link_to);\n-                javac_state.setVisibleSources(sources_to_link_to);\n-\n-                int round = 0;\n-                printRound(round);\n-\n-                \/\/ If there is any change in the source files, taint packages\n-                \/\/ and mark the database in need of saving.\n-                javac_state.checkSourceStatus(false);\n-\n-                \/\/ Find all existing artifacts. Their timestamp will match the last modified timestamps stored\n-                \/\/ in javac_state, simply because loading of the JavacState will clean out all artifacts\n-                \/\/ that do not match the javac_state database.\n-                javac_state.findAllArtifacts();\n-\n-                \/\/ Remove unidentified artifacts from the bin, gensrc and header dirs.\n-                \/\/ (Unless we allow them to be there.)\n-                \/\/ I.e. artifacts that are not known according to the build database (javac_state).\n-                \/\/ For examples, files that have been manually copied into these dirs.\n-                \/\/ Artifacts with bad timestamps (ie the on disk timestamp does not match the timestamp\n-                \/\/ in javac_state) have already been removed when the javac_state was loaded.\n-                if (!options.areUnidentifiedArtifactsPermitted()) {\n-                    javac_state.removeUnidentifiedArtifacts();\n-                }\n-                \/\/ Go through all sources and taint all packages that miss artifacts.\n-                javac_state.taintPackagesThatMissArtifacts();\n-\n-                \/\/ Check recorded classpath public apis. Taint packages that depend on\n-                \/\/ classpath classes whose public apis have changed.\n-                javac_state.taintPackagesDependingOnChangedClasspathPackages();\n-\n-                \/\/ Now clean out all known artifacts belonging to tainted packages.\n-                javac_state.deleteClassArtifactsInTaintedPackages();\n-                \/\/ Copy files, for example property files, images files, xml files etc etc.\n-                javac_state.performCopying(Util.pathToFile(options.getDestDir()), suffixRules);\n-                \/\/ Translate files, for example compile properties or compile idls.\n-                javac_state.performTranslation(Util.pathToFile(gensrc), suffixRules);\n-                \/\/ Add any potentially generated java sources to the tobe compiled list.\n-                \/\/ (Generated sources must always have a package.)\n-                Map<String,Source> generated_sources = new HashMap<>();\n-\n-                Source.scanRoot(Util.pathToFile(options.getGenSrcDir()),\n-                                Util.set(\".java\"),\n-                                Collections.emptyList(),\n-                                Collections.emptyList(),\n-                                generated_sources,\n-                                modules,\n-                                current_module,\n-                                false,\n-                                true,\n-                                false);\n-                javac_state.now().flattenPackagesSourcesAndArtifacts(modules);\n-                \/\/ Recheck the source files and their timestamps again.\n-                javac_state.checkSourceStatus(true);\n-\n-                \/\/ Now do a safety check that the list of source files is identical\n-                \/\/ to the list Make believes we are compiling. If we do not get this\n-                \/\/ right, then incremental builds will fail with subtility.\n-                \/\/ If any difference is detected, then we will fail hard here.\n-                \/\/ This is an important safety net.\n-                javac_state.compareWithMakefileList(Util.pathToFile(options.getSourceReferenceList()));\n-\n-                \/\/ Do the compilations, repeatedly until no tainted packages exist.\n-                boolean again;\n-                \/\/ Collect the name of all compiled packages.\n-                Set<String> recently_compiled = new HashSet<>();\n-                boolean[] rc = new boolean[1];\n-\n-                CompilationService compilationService = new CompilationService();\n-                do {\n-                    if (round > 0)\n-                        printRound(round);\n-                    \/\/ Clean out artifacts in tainted packages.\n-                    javac_state.deleteClassArtifactsInTaintedPackages();\n-                    again = javac_state.performJavaCompilations(compilationService,\n-                                                                options,\n-                                                                recently_compiled,\n-                                                                rc);\n-                    if (!rc[0]) {\n-                        Log.debug(\"Compilation failed.\");\n-                        break;\n-                    }\n-                    if (!again) {\n-                        Log.debug(\"Nothing left to do.\");\n-                    }\n-                    round++;\n-                } while (again);\n-                Log.debug(\"No need to do another round.\");\n-\n-                \/\/ Only update the state if the compile went well.\n-                if (rc[0]) {\n-                    javac_state.save();\n-                    \/\/ Reflatten only the artifacts.\n-                    javac_state.now().flattenArtifacts(modules);\n-                    \/\/ Remove artifacts that were generated during the last compile, but not this one.\n-                    javac_state.removeSuperfluousArtifacts(recently_compiled);\n-                }\n-\n-                return rc[0] ? Result.OK : Result.ERROR;\n-            } catch (ProblemException e) {\n-                \/\/ For instance make file list mismatch.\n-                Log.error(e.getMessage());\n-                Log.debug(e);\n-                return Result.ERROR;\n-            } catch (Exception e) {\n-                Log.error(e);\n-                return Result.ERROR;\n-            }\n-        }\n-    }\n-\n-    @Override\n-    public void shutdown() {\n-        \/\/ Nothing to clean up\n-    }\n-\n-    private static boolean validateOptions(Options options) {\n-\n-        String err = null;\n-\n-        if (options.getDestDir() == null) {\n-            err = \"Please specify output directory.\";\n-        } else if (options.isJavaFilesAmongJavacArgs()) {\n-            err = \"Sjavac does not handle explicit compilation of single .java files.\";\n-        } else if (!options.getImplicitPolicy().equals(\"none\")) {\n-            err = \"The only allowed setting for sjavac is -implicit:none\";\n-        } else if (options.getSources().isEmpty() && options.getStateDir() != null) {\n-            err = \"You have to specify -src when using --state-dir.\";\n-        } else if (options.getTranslationRules().size() > 1\n-                && options.getGenSrcDir() == null) {\n-            err = \"You have translators but no gensrc dir (-s) specified!\";\n-        }\n-\n-        if (err != null)\n-            Log.error(err);\n-\n-        return err == null;\n-\n-    }\n-\n-    private static boolean srcDstOverlap(List<SourceLocation> locs, Path dest) {\n-        for (SourceLocation loc : locs) {\n-            if (isOverlapping(loc.getPath(), dest)) {\n-                Log.error(\"Source location \" + loc.getPath() + \" overlaps with destination \" + dest);\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private static boolean isOverlapping(Path p1, Path p2) {\n-        p1 = p1.toAbsolutePath().normalize();\n-        p2 = p2.toAbsolutePath().normalize();\n-        return p1.startsWith(p2) || p2.startsWith(p1);\n-    }\n-\n-    private static boolean createIfMissing(Path dir) {\n-\n-        if (Files.isDirectory(dir))\n-            return true;\n-\n-        if (Files.exists(dir)) {\n-            Log.error(dir + \" is not a directory.\");\n-            return false;\n-        }\n-\n-        try {\n-            Files.createDirectories(dir);\n-        } catch (IOException e) {\n-            Log.error(\"Could not create directory: \" + e.getMessage());\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    \/** Find source files in the given source locations. *\/\n-    public static void findSourceFiles(List<SourceLocation> sourceLocations,\n-                                       Set<String> sourceTypes,\n-                                       Map<String,Source> foundFiles,\n-                                       Map<String, Module> foundModules,\n-                                       Module currentModule,\n-                                       boolean permitSourcesInDefaultPackage,\n-                                       boolean inLinksrc)\n-                                               throws IOException {\n-\n-        for (SourceLocation source : sourceLocations) {\n-            source.findSourceFiles(sourceTypes,\n-                                   foundFiles,\n-                                   foundModules,\n-                                   currentModule,\n-                                   permitSourcesInDefaultPackage,\n-                                   inLinksrc);\n-        }\n-    }\n-\n-    private static void printRound(int round) {\n-        Log.debug(\"****************************************\");\n-        Log.debug(\"* Round \" + round + \"                              *\");\n-        Log.debug(\"****************************************\");\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/SjavacImpl.java","additions":0,"deletions":399,"binary":false,"changes":399,"status":"deleted"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.net.URI;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.tools.*;\n-import javax.tools.JavaFileObject.Kind;\n-\n-import com.sun.tools.javac.file.JavacFileManager;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.javac.util.ListBuffer;\n-\n-\/**\n- * Intercepts reads and writes to the file system to gather\n- * information about what artifacts are generated.\n- *\n- * Traps writes to certain files, if the content written is identical\n- * to the existing file.\n- *\n- * Can also blind out the file manager from seeing certain files in the file system.\n- * Necessary to prevent javac from seeing some sources where the source path points.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-@com.sun.tools.javac.api.ClientCodeWrapper.Trusted\n-public class SmartFileManager extends ForwardingJavaFileManager<JavaFileManager> {\n-\n-    \/\/ Set of sources that can be seen by javac.\n-    Set<URI> visibleSources = new HashSet<>();\n-    \/\/ Map from modulename:packagename to artifacts.\n-    Map<String,Set<URI>> packageArtifacts = new HashMap<>();\n-\n-    public SmartFileManager(JavaFileManager fileManager) {\n-        super(fileManager);\n-    }\n-\n-    public void setVisibleSources(Set<URI> s) {\n-        visibleSources = s;\n-    }\n-\n-    public void cleanArtifacts() {\n-        packageArtifacts = new HashMap<>();\n-    }\n-\n-    \/**\n-     * Set whether or not to use ct.sym as an alternate to rt.jar.\n-     *\/\n-    public void setSymbolFileEnabled(boolean b) {\n-        if (!(fileManager instanceof JavacFileManager javacFileManager))\n-            throw new IllegalStateException();\n-        javacFileManager.setSymbolFileEnabled(b);\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public String inferBinaryName(Location location, JavaFileObject file) {\n-        return super.inferBinaryName(location, locUnwrap(file));\n-    }\n-\n-\n-    public Map<String,Set<URI>> getPackageArtifacts() {\n-        return packageArtifacts;\n-    }\n-\n-    @Override @DefinedBy(Api.COMPILER)\n-    public Iterable<JavaFileObject> list(Location location,\n-                                         String packageName,\n-                                         Set<Kind> kinds,\n-                                         boolean recurse) throws IOException {\n-        \/\/ TODO: Do this lazily by returning an iterable with a filtering Iterator\n-        \/\/ Acquire the list of files.\n-        Iterable<JavaFileObject> files = super.list(location, packageName, kinds, recurse);\n-        if (visibleSources.isEmpty()) {\n-            return locWrapMany(files, location);\n-        }\n-        \/\/ Now filter!\n-        ListBuffer<JavaFileObject> filteredFiles = new ListBuffer<>();\n-        for (JavaFileObject f : files) {\n-            URI uri = f.toUri();\n-            String t = uri.toString();\n-            if (t.startsWith(\"jar:\")\n-                || t.endsWith(\".class\")\n-                || visibleSources.contains(uri)) {\n-                filteredFiles.add(f);\n-            }\n-        }\n-\n-        return locWrapMany(filteredFiles, location);\n-    }\n-\n-    @Override @DefinedBy(Api.COMPILER)\n-    public JavaFileObject getJavaFileForInput(Location location,\n-                                              String className,\n-                                              Kind kind) throws IOException {\n-        JavaFileObject file = super.getJavaFileForInput(location, className, kind);\n-        file = locWrap(file, location);\n-        if (file == null || visibleSources.isEmpty()) {\n-            return file;\n-        }\n-\n-        if (visibleSources.contains(file.toUri()) || isModuleInfo(file)) {\n-            return file;\n-        }\n-        return null;\n-    }\n-\n-    @Override @DefinedBy(Api.COMPILER)\n-    public JavaFileObject getJavaFileForOutput(Location location,\n-                                               String className,\n-                                               Kind kind,\n-                                               FileObject sibling) throws IOException {\n-        JavaFileObject file = super.getJavaFileForOutput(location, className, kind, sibling);\n-        file = locWrap(file, location);\n-        if (file == null) return file;\n-        int dp = className.lastIndexOf('.');\n-        String pkg_name = \"\";\n-        if (dp != -1) {\n-            pkg_name = className.substring(0, dp);\n-        }\n-        \/\/ When modules are in use, then the mod_name might be something like \"jdk_base\"\n-        String mod_name = \"\";\n-        addArtifact(mod_name+\":\"+pkg_name, file.toUri());\n-        return file;\n-    }\n-\n-    @Override @DefinedBy(Api.COMPILER)\n-    public FileObject getFileForInput(Location location,\n-                                      String packageName,\n-                                      String relativeName) throws IOException {\n-        FileObject file =  super.getFileForInput(location, packageName, relativeName);\n-        file = locWrap(file, location);\n-        if (file == null || visibleSources.isEmpty()) {\n-            return file;\n-        }\n-\n-        if (visibleSources.contains(file.toUri()) || isModuleInfo(file)) {\n-            return file;\n-        }\n-        return null;\n-    }\n-\n-    private boolean isModuleInfo(FileObject fo) {\n-        return (fo instanceof JavaFileObject javaFileObject)\n-                && (javaFileObject.isNameCompatible(\"module-info\", Kind.SOURCE)\n-                    || javaFileObject.isNameCompatible(\"module-info\", Kind.CLASS));\n-    }\n-\n-    @Override @DefinedBy(Api.COMPILER)\n-    public FileObject getFileForOutput(Location location,\n-                                       String packageName,\n-                                       String relativeName,\n-                                       FileObject sibling) throws IOException {\n-        FileObject superFile = super.getFileForOutput(location, packageName, relativeName, sibling);\n-        FileObject file = locWrap(superFile, location);\n-        if (file == null) return file;\n-\n-        if (location.equals(StandardLocation.NATIVE_HEADER_OUTPUT) && superFile instanceof JavaFileObject) {\n-           file = new SmartFileObject((JavaFileObject) file);\n-           packageName = \":\" + packageNameFromFileName(relativeName);\n-        }\n-        if (packageName.equals(\"\")) {\n-            packageName = \":\";\n-        }\n-        addArtifact(packageName, file.toUri());\n-        return file;\n-    }\n-\n-    @Override @DefinedBy(Api.COMPILER)\n-    public Location getLocationForModule(Location location, JavaFileObject fo) throws IOException {\n-        return super.getLocationForModule(location, locUnwrap(fo));\n-    }\n-\n-    private static String packageNameFromFileName(String fn) {\n-        StringBuilder sb = new StringBuilder();\n-        int p = fn.indexOf('_'), pp = 0;\n-        while (p != -1) {\n-            if (sb.length() > 0) sb.append('.');\n-            sb.append(fn.substring(pp,p));\n-            if (p == fn.length()-1) break;\n-            pp = p+1;\n-            p = fn.indexOf('_',pp);\n-        }\n-        return sb.toString();\n-    }\n-\n-    void addArtifact(String pkgName, URI art) {\n-        Set<URI> s = packageArtifacts.get(pkgName);\n-        if (s == null) {\n-            s = new HashSet<>();\n-            packageArtifacts.put(pkgName, s);\n-        }\n-        s.add(art);\n-    }\n-\n-    public static JavaFileObject locWrap(JavaFileObject jfo, Location loc) {\n-\n-        \/\/ From sjavac's perspective platform classes are not interesting and\n-        \/\/ there is no need to track the location for these file objects.\n-        \/\/ Also, there exists some jfo instanceof checks which breaks if\n-        \/\/ the jfos for platform classes are wrapped.\n-        if (loc == StandardLocation.PLATFORM_CLASS_PATH)\n-            return jfo;\n-\n-        return jfo == null ? null : new JavaFileObjectWithLocation<>(jfo, loc);\n-    }\n-\n-    private static FileObject locWrap(FileObject fo, Location loc) {\n-        if (fo instanceof JavaFileObject javaFileObject)\n-            return locWrap(javaFileObject, loc);\n-        return fo == null ? null : new FileObjectWithLocation<>(fo, loc);\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    @Override\n-    public boolean isSameFile(FileObject a, FileObject b) {\n-        return super.isSameFile(locUnwrap(a), locUnwrap(b));\n-    }\n-\n-    private static ListBuffer<JavaFileObject> locWrapMany(Iterable<JavaFileObject> jfos,\n-                                                          Location loc) {\n-        ListBuffer<JavaFileObject> locWrapped = new ListBuffer<>();\n-        for (JavaFileObject f : jfos)\n-            locWrapped.add(locWrap(f, loc));\n-        return locWrapped;\n-    }\n-\n-    private static FileObject locUnwrap(FileObject fo) {\n-        if (fo instanceof FileObjectWithLocation<?> fileObjectWithLocation)\n-            return fileObjectWithLocation.getDelegate();\n-        if (fo instanceof JavaFileObjectWithLocation<?> javaFileObjectWithLocation)\n-            return javaFileObjectWithLocation.getDelegate();\n-        return fo;\n-    }\n-\n-    private static JavaFileObject locUnwrap(JavaFileObject fo) {\n-        if (fo instanceof JavaFileObjectWithLocation<?> javaFileObjectWithLocation)\n-            return javaFileObjectWithLocation.getDelegate();\n-        return fo;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/SmartFileManager.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"},{"patch":"@@ -1,142 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import java.io.*;\n-import java.net.URI;\n-import java.nio.file.NoSuchFileException;\n-\n-import javax.lang.model.element.Modifier;\n-import javax.lang.model.element.NestingKind;\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-\n-\/**\n- * The SmartFileObject will return an outputstream that cache the written data\n- * and compare the new content with the old content on disk. Only if they differ,\n- * will the file be updated.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SmartFileObject implements JavaFileObject {\n-\n-    JavaFileObject file;\n-\n-    public SmartFileObject(JavaFileObject r) {\n-        file = r;\n-    }\n-\n-    @Override\n-    public boolean equals(Object other) {\n-        return file.equals(other);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return file.hashCode();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public Kind getKind() {\n-        return file.getKind();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public boolean isNameCompatible(String simpleName, Kind kind) {\n-        return file.isNameCompatible(simpleName, kind);\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public URI toUri() {\n-        return file.toUri();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public String getName() {\n-        return file.getName();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public InputStream openInputStream() throws IOException {\n-        return file.openInputStream();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public OutputStream openOutputStream() throws IOException {\n-        return file.openOutputStream();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-        return file.getCharContent(ignoreEncodingErrors);\n-    }\n-\n-    static String lineseparator = System.getProperty(\"line.separator\");\n-\n-    @DefinedBy(Api.COMPILER)\n-    public Writer openWriter() throws IOException {\n-        StringBuilder s = new StringBuilder();\n-        try (BufferedReader r = new BufferedReader(file.openReader(true))) {\n-            while (r.ready()) {\n-                s.append(r.readLine()+lineseparator);\n-            }\n-        } catch (FileNotFoundException | NoSuchFileException e) {\n-            \/\/ Perfectly ok.\n-        }\n-        return new SmartWriter(file, s.toString(), file.getName());\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public long getLastModified() {\n-        return file.getLastModified();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public boolean delete() {\n-        return file.delete();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public Modifier getAccessLevel() {\n-        return file.getAccessLevel();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public NestingKind getNestingKind() {\n-        return file.getNestingKind();\n-    }\n-\n-    @DefinedBy(Api.COMPILER)\n-    public Reader openReader(boolean ignoreEncodingErrors) throws IOException {\n-        return file.openReader(ignoreEncodingErrors);\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/SmartFileObject.java","additions":0,"deletions":142,"binary":false,"changes":142,"status":"deleted"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp;\n-\n-import com.sun.tools.sjavac.Log;\n-\n-import java.io.*;\n-import javax.tools.JavaFileObject;\n-\n-\/**\n- * The SmartWriter will cache the written data and when the writer is closed,\n- * then it will compare the cached data with the old_content string.\n- * If different, then it will write all the new content to the file.\n- * If not, the file is not touched.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SmartWriter extends Writer {\n-\n-    String name;\n-    JavaFileObject file;\n-    String oldContent;\n-    StringWriter newContent = new StringWriter();\n-    boolean closed;\n-\n-    public SmartWriter(JavaFileObject f, String s, String n) {\n-        name = n;\n-        file = f;\n-        oldContent = s;\n-        newContent = new StringWriter();\n-        closed = false;\n-    }\n-\n-    public void write(char[] chars, int i, int i1) {\n-        newContent.write(chars, i, i1);\n-    }\n-\n-    public void close() throws IOException {\n-        if (closed) return;\n-        closed = true;\n-        String s = newContent.toString();\n-        if (!oldContent.equals(s)) {\n-            int p = file.getName().lastIndexOf(File.separatorChar);\n-            try (Writer writer = file.openWriter()) {\n-                writer.write(s);\n-            }\n-            Log.debug(\"Writing \" + file.getName().substring(p + 1));\n-        }\n-    }\n-\n-    public void flush() throws IOException {\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/SmartWriter.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,197 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp.dependencies;\n-\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import javax.tools.JavaFileManager.Location;\n-import javax.tools.JavaFileObject;\n-import javax.tools.StandardLocation;\n-\n-import com.sun.source.util.TaskEvent;\n-import com.sun.source.util.TaskListener;\n-import com.sun.tools.javac.code.Kinds.Kind;\n-import com.sun.tools.javac.code.Symbol;\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.code.Symbol.TypeSymbol;\n-import com.sun.tools.javac.code.Type;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.javac.util.Dependencies.GraphDependencies;\n-import com.sun.tools.javac.util.Dependencies.GraphDependencies.CompletionNode;\n-import com.sun.tools.javac.util.GraphUtils.Node;\n-import com.sun.tools.sjavac.Util;\n-import com.sun.tools.sjavac.comp.JavaFileObjectWithLocation;\n-import com.sun.tools.sjavac.comp.PubAPIs;\n-\n-\n-public class NewDependencyCollector implements TaskListener {\n-\n-    private final Context context;\n-    private final Collection<JavaFileObject> explicitJFOs;\n-\n-    private Map<String, Map<String, Set<String>>> deps;\n-    private Map<String, Map<String, Set<String>>> cpDeps;\n-\n-    public NewDependencyCollector(Context context,\n-                                  Collection<JavaFileObject> explicitJFOs) {\n-        this.context = context;\n-        this.explicitJFOs = explicitJFOs;\n-    }\n-\n-    @Override\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public void finished(TaskEvent e) {\n-        if (e.getKind() == TaskEvent.Kind.COMPILATION) {\n-            collectPubApisOfDependencies(context, explicitJFOs);\n-            deps = getDependencies(context, explicitJFOs, false);\n-            cpDeps = getDependencies(context, explicitJFOs, true);\n-        }\n-    }\n-\n-    public Map<String, Map<String, Set<String>>> getDependencies(boolean cp) {\n-        return cp ? cpDeps : deps;\n-    }\n-\n-    private Set<CompletionNode> getDependencyNodes(Context context,\n-                                                   Collection<JavaFileObject> explicitJFOs,\n-                                                   boolean explicits) {\n-        GraphDependencies deps = (GraphDependencies) GraphDependencies.instance(context);\n-\n-        return deps.getNodes()\n-                   .stream()\n-                   .map(n -> (CompletionNode) n)\n-                   .filter(n -> n.getClassSymbol().fullname != null)\n-                   .filter(n -> explicits == explicitJFOs.contains(n.getClassSymbol().classfile))\n-                   .collect(Collectors.toSet());\n-    }\n-\n-    private void collectPubApisOfDependencies(Context context,\n-                                              Collection<JavaFileObject> explicitJFOs) {\n-        PubAPIs pubApis = PubAPIs.instance(context);\n-        for (CompletionNode cDepNode : getDependencyNodes(context, explicitJFOs, false)) {\n-            ClassSymbol cs = cDepNode.getClassSymbol().outermostClass();\n-            Location loc = getLocationOf(cs);\n-            \/\/ We're completely ignorant of PLATFORM_CLASS_PATH classes\n-            if (loc == StandardLocation.CLASS_PATH || loc == StandardLocation.SOURCE_PATH)\n-                pubApis.visitPubapi(cs);\n-        }\n-    }\n-\n-    private Location getLocationOf(ClassSymbol cs) {\n-        JavaFileObject jfo = cs.outermostClass().classfile;\n-        if (jfo instanceof JavaFileObjectWithLocation<?> javaFileObjectWithLocation) {\n-            return javaFileObjectWithLocation.getLocation();\n-        }\n-\n-        \/\/ jfo is most likely on PLATFORM_CLASS_PATH.\n-        \/\/ See notes in SmartFileManager::locWrap\n-\n-        return null;\n-    }\n-\n-    \/\/ :Package -> fully qualified class name [from] -> set of fully qualified class names [to]\n-    private Map<String, Map<String, Set<String>>> getDependencies(Context context,\n-                                                                  Collection<JavaFileObject> explicitJFOs,\n-                                                                  boolean cp) {\n-        Map<String, Map<String, Set<String>>> result = new HashMap<>();\n-\n-        for (CompletionNode cnode : getDependencyNodes(context, explicitJFOs, true)) {\n-\n-            String fqDep = cnode.getClassSymbol().outermostClass().flatname.toString();\n-            String depPkg = Util.pkgNameOfClassName(fqDep);\n-\n-            Map<String, Set<String>> depsForThisClass = result.get(depPkg);\n-            if (depsForThisClass == null) {\n-                result.put(depPkg, depsForThisClass = new HashMap<>());\n-            }\n-\n-            Set<String> fqDeps = depsForThisClass.get(fqDep);\n-            if (fqDeps == null) {\n-                depsForThisClass.put(fqDep, fqDeps = new HashSet<>());\n-            }\n-\n-            for (Node<?,?> depNode : getAllDependencies(cnode)) {\n-                CompletionNode cDepNode = (CompletionNode) depNode;\n-                \/\/ Symbol is not regarded to depend on itself.\n-                if (cDepNode == cnode) {\n-                    continue;\n-                }\n-                \/\/ Skip anonymous classes\n-                if (cDepNode.getClassSymbol().fullname == null) {\n-                    continue;\n-                }\n-                if (isSymbolRelevant(cp, cDepNode.getClassSymbol())) {\n-                    fqDeps.add(cDepNode.getClassSymbol().outermostClass().flatname.toString());\n-                }\n-            }\n-\n-            \/\/ The completion dependency graph is not transitively closed for inheritance relations.\n-            \/\/ For sjavac's purposes however, a class depends on its super-supertype, so below we\n-            \/\/ make sure that we include supertypes.\n-            for (ClassSymbol cs : allSupertypes(cnode.getClassSymbol())) {\n-                if (isSymbolRelevant(cp, cs)) {\n-                    fqDeps.add(cs.outermostClass().flatname.toString());\n-                }\n-            }\n-\n-        }\n-        return result;\n-    }\n-\n-    public boolean isSymbolRelevant(boolean cp, ClassSymbol cs) {\n-        Location csLoc = getLocationOf(cs);\n-        Location relevantLocation = cp ? StandardLocation.CLASS_PATH : StandardLocation.SOURCE_PATH;\n-        return csLoc == relevantLocation;\n-    }\n-\n-    private Set<ClassSymbol> allSupertypes(TypeSymbol t) {\n-        if (t == null || !(t instanceof ClassSymbol classSymbol)) {\n-            return Collections.emptySet();\n-        }\n-        Set<ClassSymbol> result = new HashSet<>();\n-        result.add(classSymbol);\n-        result.addAll(allSupertypes(classSymbol.getSuperclass().tsym));\n-        for (Type it : classSymbol.getInterfaces()) {\n-            result.addAll(allSupertypes(it.tsym));\n-        }\n-        return result;\n-    }\n-\n-    private Collection<? extends Node<?, ?>> getAllDependencies(CompletionNode cnode) {\n-        return Stream.of(cnode.getSupportedDependencyKinds())\n-                     .flatMap(dk -> cnode.getDependenciesByKind(dk).stream())\n-                     .collect(Collectors.toSet());\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/dependencies\/NewDependencyCollector.java","additions":0,"deletions":197,"binary":false,"changes":197,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.comp.dependencies;\n-\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import javax.tools.JavaFileObject;\n-\n-import com.sun.source.tree.Tree;\n-import com.sun.source.util.TaskEvent;\n-import com.sun.source.util.TaskListener;\n-import com.sun.tools.javac.code.Symbol.ClassSymbol;\n-import com.sun.tools.javac.tree.JCTree.JCClassDecl;\n-import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n-import com.sun.tools.javac.util.Context;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.comp.PubAPIs;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\n-public class PublicApiCollector implements TaskListener {\n-\n-    private Context context;\n-    private final Set<ClassSymbol> classSymbols = new HashSet<>();\n-    private final Collection<JavaFileObject> explicitJFOs;\n-\n-    \/\/ Result collected upon compilation task finished\n-    private Map<String, PubApi> explicitPubApis;\n-    private Map<String, PubApi> nonExplicitPubApis;\n-\n-    public PublicApiCollector(Context context,\n-                              Collection<JavaFileObject> explicitJFOs) {\n-        this.context = context;\n-        this.explicitJFOs = explicitJFOs;\n-    }\n-\n-    @Override\n-    @DefinedBy(Api.COMPILER_TREE)\n-    public void finished(TaskEvent e) {\n-        switch (e.getKind()) {\n-        case ANALYZE:\n-            collectClassSymbols((JCCompilationUnit) e.getCompilationUnit());\n-            break;\n-        case COMPILATION:\n-            Log.debug(\"Compilation finished\");\n-            Log.debug(\"Extracting pub APIs for the following symbols:\");\n-            for (ClassSymbol cs : classSymbols)\n-                Log.debug(\"    \" + cs.fullname);\n-            extractPubApis();\n-\n-            \/\/ Save result for later retrieval. (Important that we do this\n-            \/\/ before we return from this method, because we may not access\n-            \/\/ symbols after compilation is finished.)\n-            PubAPIs pa = PubAPIs.instance(context);\n-            explicitPubApis = pa.getPubapis(explicitJFOs, true);\n-            nonExplicitPubApis = pa.getPubapis(explicitJFOs, false);\n-\n-            Log.debug(\"done\");\n-            break;\n-        }\n-    }\n-\n-    private void collectClassSymbols(JCCompilationUnit cu) {\n-        for (Tree t : cu.getTypeDecls()) {\n-            if (t instanceof JCClassDecl classDecl)  \/\/ Can also be a JCSkip\n-                classSymbols.add(classDecl.sym);\n-        }\n-    }\n-\n-    private void extractPubApis() {\n-        \/\/ To handle incremental builds (subsequent sjavac invocations) we need\n-        \/\/ to keep track of the public API of what we depend upon.\n-        \/\/\n-        \/\/ During the recompilation loop (within a single sjavac invocation) we\n-        \/\/ need to keep track of public API of what we're compiling to decide if\n-        \/\/ any dependants needs to be tainted.\n-        PubAPIs pubApis = PubAPIs.instance(context);\n-        classSymbols.forEach(pubApis::visitPubapi);\n-    }\n-\n-    public Map<String, PubApi> getPubApis(boolean explicit) {\n-        return explicit ? explicitPubApis : nonExplicitPubApis;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/comp\/dependencies\/PublicApiCollector.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,383 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.options;\n-\n-import java.io.File;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-import com.sun.tools.sjavac.CopyFile;\n-import com.sun.tools.sjavac.Transformer;\n-\n-\n-\/**\n- * Sjavac options can be classified as:\n- *\n- *  (1) relevant only for sjavac, such as --server\n- *  (2) relevant for sjavac and javac, such as -d, or\n- *  (3) relevant only for javac, such as -g.\n- *\n- * This enum represents all options from (1) and (2). Note that instances of\n- * this enum only entail static information about the option. For storage of\n- * option values, refer to com.sun.tools.sjavac.options.Options.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public enum Option {\n-\n-    SRC(\"-src\", \"Location of source files to be compiled\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            List<Path> paths = getFileListArg(iter, helper);\n-            if (paths != null)\n-                helper.sourceRoots(paths);\n-        }\n-    },\n-    SOURCE_PATH(\"--source-path\", \"Specify search path for sources.\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            List<Path> paths = getFileListArg(iter, helper);\n-            if (paths != null)\n-                helper.sourcepath(paths);\n-        }\n-    },\n-    SOURCEPATH(\"-sourcepath\", \"An alias for -sourcepath\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            SOURCE_PATH.processMatching(iter, helper);\n-        }\n-    },\n-    MODULE_PATH(\"--module-path\", \"Specify search path for modules.\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            List<Path> paths = getFileListArg(iter, helper);\n-            if (paths != null)\n-                helper.modulepath(paths);\n-        }\n-    },\n-    P(\"-p\", \"An alias for --module-path\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            MODULE_PATH.processMatching(iter, helper);\n-        }\n-    },\n-    CLASS_PATH(\"--class-path\", \"Specify search path for classes.\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            List<Path> paths = getFileListArg(iter, helper);\n-            if (paths != null)\n-                helper.classpath(paths);\n-        }\n-    },\n-    CLASSPATH(\"-classpath\", \"An alias for -classpath.\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            CLASS_PATH.processMatching(iter, helper);\n-        }\n-    },\n-    CP(\"-cp\", \"An alias for -classpath\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            CLASS_PATH.processMatching(iter, helper);\n-        }\n-    },\n-    X(\"-x\", \"Exclude files matching the given pattern\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            String pattern = getFilePatternArg(iter, helper);\n-            if (pattern != null)\n-                helper.exclude(pattern);\n-        }\n-    },\n-    I(\"-i\", \"Include only files matching the given pattern\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            String pattern = getFilePatternArg(iter, helper);\n-            if (pattern != null)\n-                helper.include(pattern);\n-        }\n-    },\n-    TR(\"-tr\", \"Translate resources\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-\n-            if (!iter.hasNext()) {\n-                helper.reportError(arg + \" must be followed by a translation rule\");\n-                return;\n-            }\n-\n-            String trArg = iter.next();\n-\n-            \/\/ Validate argument syntax. Examples:\n-            \/\/   .prop=com.sun.tools.javac.smart.CompileProperties\n-            \/\/   .idl=com.sun.corba.CompileIdl\n-            \/\/   .g3=antlr.CompileGrammar,debug=true\n-            String ident = \"[a-zA-Z_][a-zA-Z0-9_]*\";\n-            Pattern p = Pattern.compile(\"(?<suffix>\\\\.\" + ident + \")=\" +\n-                                        \"(?<class>\" + ident + \"(\\\\.\" + ident + \")*)\" +\n-                                        \"(?<extra>,.*)?\");\n-            \/\/ Check syntax\n-            Matcher m = p.matcher(trArg);\n-            if (!m.matches()) {\n-                helper.reportError(\"The string \\\"\" + trArg + \"\\\" is not a \" +\n-                                   \"valid translate pattern\");\n-                return;\n-            }\n-\n-            \/\/ Extract relevant parts\n-            String suffix = m.group(\"suffix\");\n-            String classname = m.group(\"class\");\n-            String extra = m.group(\"extra\");\n-\n-            \/\/ Valid suffix?\n-            if (suffix.matches(\"\\\\.(class|java)\")) {\n-                helper.reportError(\"You cannot have a translator for \" +\n-                                   suffix + \" files!\");\n-                return;\n-            }\n-\n-            \/\/ Construct transformer\n-            try {\n-                Class<?> trCls = Class.forName(classname);\n-                Transformer transformer =\n-                    (Transformer) trCls.getConstructor().newInstance();\n-                transformer.setExtra(extra);\n-                helper.addTransformer(suffix, transformer);\n-            } catch (Exception e) {\n-                helper.reportError(\"Cannot use \" + classname +\n-                                   \" as a translator: \" + e.getMessage());\n-            }\n-        }\n-    },\n-    COPY(\"-copy\", \"Copy resources\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            if (!iter.hasNext()) {\n-                helper.reportError(arg + \" must be followed by a resource type\");\n-                return;\n-            }\n-\n-            String copyArg = iter.next();\n-\n-            \/\/ Validate argument syntax. Examples: .gif, .html\n-            if (!copyArg.matches(\"\\\\.[a-zA-Z_][a-zA-Z0-9_]*\")) {\n-                helper.reportError(\"The string \\\"\" + copyArg + \"\\\" is not a \" +\n-                                   \"valid resource type.\");\n-                return;\n-            }\n-\n-            helper.addTransformer(copyArg, new CopyFile());\n-        }\n-    },\n-    J(\"-j\", \"Number of cores\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            if (!iter.hasNext() || !iter.peek().matches(\"\\\\d+\")) {\n-                helper.reportError(arg + \" must be followed by an integer\");\n-                return;\n-            }\n-            helper.numCores(Integer.parseInt(iter.next()));\n-        }\n-    },\n-    SERVER(\"--server:\", \"Specify server configuration file of running server\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.serverConf(iter.current().substring(arg.length()));\n-        }\n-    },\n-    STARTSERVER(\"--startserver:\", \"Start server and use the given configuration file\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.startServerConf(iter.current().substring(arg.length()));\n-        }\n-    },\n-    IMPLICIT(\"-implicit:\", \"Specify how to treat implicitly referenced source code\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.implicit(iter.current().substring(arg.length()));\n-        }\n-    },\n-    LOG(\"--log=\", \"Specify logging level\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.logLevel(iter.current().substring(arg.length()));\n-        }\n-    },\n-    VERBOSE(\"-verbose\", \"Set verbosity level to \\\"info\\\"\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.logLevel(\"info\");\n-        }\n-    },\n-    PERMIT_ARTIFACT(\"--permit-artifact=\", \"Allow this artifact in destination directory\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            String a = iter.current().substring(arg.length());\n-            helper.permitArtifact(Paths.get(a).toFile().getAbsolutePath());\n-        }\n-    },\n-    PERMIT_UNIDENTIFIED_ARTIFACTS(\"--permit-unidentified-artifacts\", \"Allow unidentified artifacts in destination directory\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.permitUnidentifiedArtifacts();\n-        }\n-    },\n-    PERMIT_SOURCES_WITHOUT_PACKAGE(\"--permit-sources-without-package\", \"Permit sources in the default package\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            helper.permitDefaultPackage();\n-        }\n-    },\n-    COMPARE_FOUND_SOURCES(\"--compare-found-sources\", \"Compare found sources with given sources\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            Path referenceSourceList = getFileArg(iter, helper, true, false);\n-            if (referenceSourceList != null)\n-                helper.compareFoundSources(referenceSourceList);\n-        }\n-    },\n-    D(\"-d\", \"Output destination directory\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            Path dir = getFileArg(iter, helper, false, true);\n-            if (dir != null)\n-                helper.destDir(dir);\n-        }\n-    },\n-    S(\"-s\", \"Directory for generated sources\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            Path dir = getFileArg(iter, helper, false, true);\n-            if (dir != null)\n-                helper.generatedSourcesDir(dir);\n-        }\n-    },\n-    H(\"-h\", \"Directory for header files\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            Path dir = getFileArg(iter, helper, false, true);\n-            if (dir != null)\n-                helper.headerDir(dir);\n-        }\n-    },\n-    STATE_DIR(\"--state-dir=\", \"Directory used to store sjavac state and log files.\") {\n-        @Override\n-        protected void processMatching(ArgumentIterator iter, OptionHelper helper) {\n-            String p = iter.current().substring(arg.length());\n-            helper.stateDir(Paths.get(p));\n-        }\n-    };\n-\n-\n-    public final String arg;\n-\n-    final String description;\n-\n-    private Option(String arg, String description) {\n-        this.arg = arg;\n-        this.description = description;\n-    }\n-\n-    \/** Retrieve and verify syntax of file list argument. *\/\n-    List<Path> getFileListArg(ArgumentIterator iter, OptionHelper helper) {\n-        if (!iter.hasNext()) {\n-            helper.reportError(arg + \" must be followed by a list of files \" +\n-                              \"separated by \" + File.pathSeparator);\n-            return null;\n-        }\n-        List<Path> result = new ArrayList<>();\n-        for (String pathStr : iter.next().split(File.pathSeparator))\n-            result.add(Paths.get(pathStr));\n-        return result;\n-    }\n-\n-    \/** Retrieve and verify syntax of file argument. *\/\n-    Path getFileArg(ArgumentIterator iter, OptionHelper helper, boolean fileAcceptable, boolean dirAcceptable) {\n-\n-        if (!iter.hasNext()) {\n-            String errmsg = arg + \" must be followed by \";\n-            if (fileAcceptable && dirAcceptable) errmsg += \"a file or directory.\";\n-            else if (fileAcceptable) errmsg += \"a file.\";\n-            else if (dirAcceptable)  errmsg += \"a directory.\";\n-            else throw new IllegalArgumentException(\"File or directory must be acceptable.\");\n-            helper.reportError(errmsg);\n-            return null;\n-        }\n-\n-        return Paths.get(iter.next());\n-    }\n-\n-    \/** Retrieve the next file or package argument. *\/\n-    String getFilePatternArg(ArgumentIterator iter, OptionHelper helper) {\n-\n-        if (!iter.hasNext()) {\n-            helper.reportError(arg + \" must be followed by a glob pattern.\");\n-            return null;\n-        }\n-\n-        return iter.next();\n-    }\n-\n-    \/\/ Future cleanup: Change the \"=\" syntax to \":\" syntax to be consistent and\n-    \/\/ to follow the javac-option style.\n-\n-    public boolean hasOption() {\n-        return arg.endsWith(\":\") || arg.endsWith(\"=\");\n-    }\n-\n-\n-    \/**\n-     * Process current argument of argIter.\n-     *\n-     * It's final, since the option customization is typically done in\n-     * processMatching.\n-     *\n-     * @param argIter Iterator to read current and succeeding arguments from.\n-     * @param helper The helper to report back to.\n-     * @return true iff the argument was processed by this option.\n-     *\/\n-    public final boolean processCurrent(ArgumentIterator argIter,\n-                                        OptionHelper helper) {\n-        String fullArg = argIter.current(); \/\/ \"-tr\" or \"-log=level\"\n-        if (hasOption() ? fullArg.startsWith(arg) : fullArg.equals(arg)) {\n-            processMatching(argIter, helper);\n-            return true;\n-        }\n-        \/\/ Did not match\n-        return false;\n-    }\n-\n-    \/** Called by process if the current argument matches this option. *\/\n-    protected abstract void processMatching(ArgumentIterator argIter,\n-                                            OptionHelper helper);\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/options\/Option.java","additions":0,"deletions":383,"binary":false,"changes":383,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.options;\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.List;\n-\n-import com.sun.tools.javac.main.CommandLine;\n-import com.sun.tools.sjavac.Transformer;\n-\n-\/**\n- * This class is used to decode sjavac options.\n- * See com.sun.tools.sjavac.options.Options for example usage.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public abstract class OptionHelper {\n-\n-    \/** Handle error *\/\n-    public abstract void reportError(String msg);\n-\n-    \/** Record a package exclusion pattern *\/\n-    public abstract void exclude(String excl);\n-\n-    \/** Record a package inclusion pattern *\/\n-    public abstract void include(String incl);\n-\n-    \/** Record a root of sources to be compiled *\/\n-    public abstract void sourceRoots(List<Path> path);\n-\n-    \/** Record a suffix + transformer *\/\n-    public abstract void addTransformer(String suffix, Transformer tr);\n-\n-    \/** Record a sourcepath to be used *\/\n-    public abstract void sourcepath(List<Path> path);\n-\n-    \/** Record a modulepath to be used *\/\n-    public abstract void modulepath(List<Path> path);\n-\n-    \/** Record a classpath to be used *\/\n-    public abstract void classpath(List<Path> path);\n-\n-    \/** Record the number of cores *\/\n-    public abstract void numCores(int parseInt);\n-\n-    \/** Record desired log level *\/\n-    public abstract void logLevel(String level);\n-\n-    \/** Record path for reference source list *\/\n-    public abstract void compareFoundSources(Path referenceList);\n-\n-    \/** Record a single permitted artifact *\/\n-    public abstract void permitArtifact(String f);\n-\n-    \/** Record the fact that unidentified artifacts are permitted *\/\n-    public abstract void permitUnidentifiedArtifacts();\n-\n-    \/** Record the fact that sources in the default package are permitted *\/\n-    public abstract void permitDefaultPackage();\n-\n-    \/** Record server configuration parameters *\/\n-    public abstract void serverConf(String serverConf);\n-\n-    \/** Record server launch configuration parameters *\/\n-    public abstract void startServerConf(String serverConf);\n-\n-    \/** Record some arguments to be passed on to javac *\/\n-    public abstract void javacArg(String... arg);\n-\n-    \/** Sets the destination directory for the compilation *\/\n-    public abstract void destDir(Path dir);\n-\n-    \/** Sets the directory for generated sources *\/\n-    public abstract void generatedSourcesDir(Path genSrcDir);\n-\n-    \/** Sets the directory for generated headers *\/\n-    public abstract void headerDir(Path dir);\n-\n-    \/** Sets the directory for state and log files generated by sjavac *\/\n-    public abstract void stateDir(Path dir);\n-\n-    \/** Sets the implicit policy *\/\n-    public abstract void implicit(String policy);\n-\n-\n-    \/**\n-     * Traverses an array of arguments and performs the appropriate callbacks.\n-     *\n-     * @param args the arguments to traverse.\n-     *\/\n-    void traverse(String[] args) {\n-        Iterable<String> allArgs;\n-        try {\n-            allArgs = CommandLine.parse(List.of(args)); \/\/ Detect @file and load it as a command line.\n-        } catch (java.io.IOException e) {\n-            throw new IllegalArgumentException(\"Problem reading @\"+e.getMessage());\n-        }\n-        ArgumentIterator argIter = new ArgumentIterator(allArgs);\n-\n-        nextArg:\n-        while (argIter.hasNext()) {\n-\n-            String arg = argIter.next();\n-\n-            if (arg.startsWith(\"-\")) {\n-                for (Option opt : Option.values()) {\n-                    if (opt.processCurrent(argIter, this))\n-                        continue nextArg;\n-                }\n-\n-                javacArg(arg);\n-\n-                \/\/ Does this javac argument take an argument? If so, don't\n-                \/\/ let it pass on to sjavac as a source root directory.\n-                for (com.sun.tools.javac.main.Option javacOpt : com.sun.tools.javac.main.Option.values()) {\n-                    if (javacOpt.matches(arg)) {\n-                        boolean takesArgument = javacOpt.hasArg();\n-                        boolean separateToken = !arg.contains(\":\") && !arg.contains(\"=\");\n-                        if (takesArgument && separateToken)\n-                            javacArg(argIter.next());\n-                    }\n-                }\n-            } else {\n-                sourceRoots(Arrays.asList(Paths.get(arg)));\n-            }\n-        }\n-    }\n-\n-    public static String unescapeCmdArg(String arg) {\n-        return arg.replaceAll(\"%20\", \" \")\n-                  .replaceAll(\"%2C\", \",\");\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/options\/OptionHelper.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,521 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.options;\n-\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.StringJoiner;\n-\n-import com.sun.tools.sjavac.Transformer;\n-import com.sun.tools.sjavac.Util;\n-\n-\/**\n- * Instances of this class represent values for sjavac command line options.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class Options {\n-\n-    \/\/ Output directories\n-    private Path destDir, genSrcDir, headerDir, stateDir;\n-\n-    \/\/ Input directories\n-    private List<SourceLocation> sources = new ArrayList<>();\n-    private List<SourceLocation> sourceSearchPaths = new ArrayList<>();\n-    private List<SourceLocation> classSearchPaths = new ArrayList<>();\n-    private List<SourceLocation> moduleSearchPaths = new ArrayList<>();\n-\n-    private String logLevel = \"info\";\n-\n-    private Set<String> permitted_artifacts = new HashSet<>();\n-    private boolean permitUnidentifiedArtifacts = false;\n-    private boolean permitSourcesInDefaultPackage = false;\n-\n-    private Path sourceReferenceList;\n-    private int numCores = 4;\n-    private String implicitPolicy = \"none\";\n-    private List<String> javacArgs = new ArrayList<>();\n-\n-    private Map<String, Transformer> trRules = new HashMap<>();\n-\n-    private boolean startServer = false;\n-\n-    \/\/ Server configuration string\n-    private String serverConf;\n-\n-    \/** Get the policy for implicit classes *\/\n-    public String getImplicitPolicy() {\n-        return implicitPolicy;\n-    }\n-\n-    \/** Get the path for generated sources (or null if no such path is set) *\/\n-    public Path getGenSrcDir() {\n-        return genSrcDir;\n-    }\n-\n-    \/** Get the path for the destination directory *\/\n-    public Path getDestDir() {\n-        return destDir;\n-    }\n-\n-    \/** Get the path for the header directory (or null if no such path is set) *\/\n-    public Path getHeaderDir() {\n-        return headerDir;\n-    }\n-\n-    \/** Get the path for the state directory, defaults to destDir. *\/\n-    public Path getStateDir() {\n-        return stateDir;\n-    }\n-\n-    \/** Get all source locations for files to be compiled *\/\n-    public List<SourceLocation> getSources() {\n-        return sources;\n-    }\n-\n-    \/**\n-     * Get all paths to search for classes in .java format. (Java-files in\n-     * found here should not be compiled.\n-     *\/\n-    public List<SourceLocation> getSourceSearchPaths() {\n-        return sourceSearchPaths;\n-    }\n-\n-    \/** Get all paths to search for classes in. *\/\n-    public List<SourceLocation> getClassSearchPath() {\n-        return classSearchPaths;\n-    }\n-\n-    \/** Get all paths to search for modules in. *\/\n-    public List<SourceLocation> getModuleSearchPaths() {\n-        return moduleSearchPaths;\n-    }\n-\n-    \/** Get the log level. *\/\n-    public String getLogLevel() {\n-        return logLevel;\n-    }\n-\n-    \/** Returns true iff the artifact is permitted in the output dir. *\/\n-    public boolean isUnidentifiedArtifactPermitted(String f) {\n-        return permitted_artifacts.contains(f);\n-    }\n-\n-    \/** Returns true iff artifacts in the output directories should be kept,\n-     * even if they would not be generated in a clean build. *\/\n-    public boolean areUnidentifiedArtifactsPermitted() {\n-        return permitUnidentifiedArtifacts;\n-    }\n-\n-    \/** Returns true iff sources in the default package should be permitted. *\/\n-    public boolean isDefaultPackagePermitted() {\n-        return permitSourcesInDefaultPackage;\n-    }\n-\n-    \/** Get the path to the list of reference sources (or null if none is set) *\/\n-    public Path getSourceReferenceList() {\n-        return sourceReferenceList;\n-    }\n-\n-    \/** Get the number of cores to be used by sjavac *\/\n-    public int getNumCores() {\n-        return numCores;\n-    }\n-\n-    \/** Returns all arguments relevant to javac but irrelevant to sjavac. *\/\n-    public List<String> getJavacArgs() {\n-        return javacArgs;\n-    }\n-\n-    \/**\n-     * Get a map which maps suffixes to transformers (for example\n-     * \".java\" {@literal ->} CompileJavaPackages)\n-     *\/\n-    public Map<String, Transformer> getTranslationRules() {\n-        return trRules;\n-    }\n-\n-    \/** Return true iff a new server should be started *\/\n-    public boolean startServerFlag() {\n-        return startServer;\n-    }\n-\n-    \/** Return the server configuration string. *\/\n-    public String getServerConf() {\n-        return serverConf;\n-    }\n-\n-    \/**\n-     * Parses the given argument array and returns a corresponding Options\n-     * instance.\n-     *\/\n-    public static Options parseArgs(String... args) {\n-        Options options = new Options();\n-        options.new ArgDecoderOptionHelper().traverse(args);\n-        return options;\n-    }\n-\n-    \/** Returns true iff a .java file is among the javac arguments *\/\n-    public boolean isJavaFilesAmongJavacArgs() {\n-        for (String javacArg : javacArgs)\n-            if (javacArg.endsWith(\".java\"))\n-                return true;\n-        return false;\n-    }\n-\n-    \/**\n-     * Returns a string representation of the options that affect the result of\n-     * the compilation. (Used for saving the state of the options used in a\n-     * previous compile.)\n-     *\/\n-    public String getStateArgsString() {\n-\n-        \/\/ Local utility class for collecting the arguments\n-        class StateArgs {\n-\n-            private List<String> args = new ArrayList<>();\n-\n-            void addArg(Option opt) {\n-                args.add(opt.arg);\n-            }\n-\n-            void addArg(Option opt, Object val) {\n-                addArg(opt);\n-                args.add(val.toString());\n-            }\n-\n-            void addSourceLocations(Option opt, List<SourceLocation> locs) {\n-                for (SourceLocation sl : locs) {\n-                    for (String pkg : sl.includes) addArg(Option.I, pkg);\n-                    for (String pkg : sl.excludes) addArg(Option.X, pkg);\n-                    addArg(opt, sl.getPath());\n-                }\n-            }\n-\n-            String getResult() {\n-                return String.join(\" \", args);\n-            }\n-\n-            public void addAll(Collection<String> toAdd) {\n-                args.addAll(toAdd);\n-            }\n-        }\n-\n-        StateArgs args = new StateArgs();\n-\n-        \/\/ Directories\n-        if (genSrcDir != null)\n-            args.addArg(Option.S, genSrcDir.normalize());\n-\n-        if (headerDir != null)\n-            args.addArg(Option.H, headerDir.normalize());\n-\n-        if (destDir != null)\n-            args.addArg(Option.D, destDir.normalize());\n-\n-        if (stateDir != null)\n-            args.addArg(Option.STATE_DIR, stateDir.normalize());\n-\n-        \/\/ Source roots\n-        args.addSourceLocations(Option.SRC, sources);\n-        args.addSourceLocations(Option.SOURCE_PATH, sourceSearchPaths);\n-        args.addSourceLocations(Option.CLASS_PATH,  classSearchPaths);\n-        args.addSourceLocations(Option.MODULE_PATH, moduleSearchPaths);\n-\n-        \/\/ Boolean options\n-        if (permitSourcesInDefaultPackage)\n-            args.addArg(Option.PERMIT_SOURCES_WITHOUT_PACKAGE);\n-\n-        for (String f : permitted_artifacts) {\n-            args.addArg(Option.PERMIT_ARTIFACT, f);\n-        }\n-\n-        if (permitUnidentifiedArtifacts)\n-            args.addArg(Option.PERMIT_UNIDENTIFIED_ARTIFACTS);\n-\n-        \/\/ Translation rules\n-        for (Map.Entry<String, Transformer> tr : trRules.entrySet()) {\n-            String val = tr.getKey() + \"=\" + tr.getValue().getClass().getName();\n-            args.addArg(Option.TR, val);\n-        }\n-\n-        \/\/ Javac args\n-        args.addAll(javacArgs);\n-\n-        return args.getResult();\n-    }\n-\n-\n-    \/** Extract the arguments to be passed on to javac. *\/\n-    public String[] prepJavacArgs() {\n-        List<String> args = new ArrayList<>();\n-\n-        \/\/ Output directories\n-        args.add(\"-d\");\n-        args.add(destDir.toString());\n-\n-        if (getGenSrcDir() != null) {\n-            args.add(\"-s\");\n-            args.add(genSrcDir.toString());\n-        }\n-\n-        if (headerDir != null) {\n-            args.add(\"-h\");\n-            args.add(headerDir.toString());\n-        }\n-\n-        \/\/ Prep sourcepath\n-        List<SourceLocation> sourcepath = new ArrayList<>();\n-        sourcepath.addAll(sources);\n-        sourcepath.addAll(sourceSearchPaths);\n-        if (sourcepath.size() > 0) {\n-            args.add(\"-sourcepath\");\n-            args.add(concatenateSourceLocations(sourcepath));\n-        }\n-\n-        \/\/ Prep classpath\n-        if (classSearchPaths.size() > 0) {\n-            args.add(\"-classpath\");\n-            args.add(concatenateSourceLocations(classSearchPaths));\n-        }\n-\n-        \/\/ Enable dependency generation\n-        args.add(\"--debug=completionDeps=source,class\");\n-\n-        \/\/ This can't be anything but 'none'. Enforced by sjavac main method.\n-        args.add(\"-implicit:\" + implicitPolicy);\n-\n-        \/\/ If this option is not used, Object for instance is erroneously\n-        \/\/ picked up from PLATFORM_CLASS_PATH instead of CLASS_PATH.\n-        \/\/\n-        \/\/ Discussing this further led to the decision of letting bootclasspath\n-        \/\/ be a dummy (empty) directory when building the JDK.\n-        \/\/args.add(\"-XXuserPathsFirst\");\n-\n-        \/\/ Append javac-options (i.e. pass through options not recognized by\n-        \/\/ sjavac to javac.)\n-        args.addAll(javacArgs);\n-\n-        return args.toArray(new String[args.size()]);\n-    }\n-\n-    \/\/ Helper method to join a list of source locations separated by\n-    \/\/ File.pathSeparator\n-    private static String concatenateSourceLocations(List<SourceLocation> locs) {\n-        StringJoiner joiner = new StringJoiner(java.io.File.pathSeparator);\n-        for (SourceLocation loc : locs) {\n-            joiner.add(loc.getPath().toString());\n-        }\n-        return joiner.toString();\n-    }\n-\n-    \/\/ OptionHelper that records the traversed options in this Options instance.\n-    private class ArgDecoderOptionHelper extends OptionHelper {\n-\n-        List<String> includes, excludes, includeFiles, excludeFiles;\n-        {\n-            resetFilters();\n-        }\n-\n-        boolean headerProvided = false;\n-        boolean genSrcProvided = false;\n-        boolean stateProvided = false;\n-\n-        @Override\n-        public void reportError(String msg) {\n-            throw new IllegalArgumentException(msg);\n-        }\n-\n-        @Override\n-        public void sourceRoots(List<Path> paths) {\n-            sources.addAll(createSourceLocations(paths));\n-        }\n-\n-        @Override\n-        public void exclude(String exclPattern) {\n-            exclPattern = Util.normalizeDriveLetter(exclPattern);\n-            excludes.add(exclPattern);\n-        }\n-\n-        @Override\n-        public void include(String inclPattern) {\n-            inclPattern = Util.normalizeDriveLetter(inclPattern);\n-            includes.add(inclPattern);\n-        }\n-\n-        @Override\n-        public void addTransformer(String suffix, Transformer tr) {\n-            if (trRules.containsKey(suffix)) {\n-                reportError(\"More than one transformer specified for \" +\n-                            \"suffix \" + suffix + \".\");\n-                return;\n-            }\n-            trRules.put(suffix, tr);\n-        }\n-\n-        @Override\n-        public void sourcepath(List<Path> paths) {\n-            sourceSearchPaths.addAll(createSourceLocations(paths));\n-        }\n-\n-        @Override\n-        public void modulepath(List<Path> paths) {\n-            moduleSearchPaths.addAll(createSourceLocations(paths));\n-        }\n-\n-        @Override\n-        public void classpath(List<Path> paths) {\n-            classSearchPaths.addAll(createSourceLocations(paths));\n-        }\n-\n-        @Override\n-        public void numCores(int n) {\n-            numCores = n;\n-        }\n-\n-        @Override\n-        public void logLevel(String level) {\n-            logLevel = level;\n-        }\n-\n-        @Override\n-        public void compareFoundSources(Path referenceList) {\n-            sourceReferenceList = referenceList;\n-        }\n-\n-        @Override\n-        public void permitArtifact(String f) {\n-            permitted_artifacts.add(f);\n-        }\n-\n-        @Override\n-        public void permitUnidentifiedArtifacts() {\n-            permitUnidentifiedArtifacts = true;\n-        }\n-\n-        @Override\n-        public void permitDefaultPackage() {\n-            permitSourcesInDefaultPackage = true;\n-        }\n-\n-        @Override\n-        public void serverConf(String conf) {\n-            if (serverConf != null)\n-                reportError(\"Can not specify more than one server configuration.\");\n-            else\n-                serverConf = conf;\n-        }\n-\n-        @Override\n-        public void implicit(String policy) {\n-            implicitPolicy = policy;\n-        }\n-\n-        @Override\n-        public void startServerConf(String conf) {\n-            if (serverConf != null)\n-                reportError(\"Can not specify more than one server configuration.\");\n-            else {\n-                startServer = true;\n-                serverConf = conf;\n-            }\n-        }\n-\n-        @Override\n-        public void javacArg(String... arg) {\n-            javacArgs.addAll(Arrays.asList(arg));\n-        }\n-\n-        @Override\n-        public void destDir(Path dir) {\n-            if (destDir != null) {\n-                reportError(\"Destination directory already specified.\");\n-                return;\n-            }\n-            destDir = dir.toAbsolutePath();\n-        }\n-\n-        @Override\n-        public void generatedSourcesDir(Path dir) {\n-            if (genSrcProvided) {\n-                reportError(\"Directory for generated sources already specified.\");\n-                return;\n-            }\n-            genSrcProvided = true;\n-            genSrcDir = dir.toAbsolutePath();\n-        }\n-\n-        @Override\n-        public void headerDir(Path dir) {\n-            if (headerProvided) {\n-                reportError(\"Header directory already specified.\");\n-                return;\n-            }\n-            headerProvided = true;\n-            headerDir = dir.toAbsolutePath();\n-        }\n-\n-        @Override\n-        public void stateDir(Path dir) {\n-            if (stateProvided) {\n-                reportError(\"State directory already specified.\");\n-                return;\n-            }\n-            stateProvided = true;\n-            stateDir = dir.toAbsolutePath();\n-        }\n-\n-        private List<SourceLocation> createSourceLocations(List<Path> paths) {\n-            List<SourceLocation> result = new ArrayList<>();\n-            for (Path path : paths) {\n-                result.add(new SourceLocation(\n-                        path,\n-                        includes,\n-                        excludes));\n-            }\n-            resetFilters();\n-            return result;\n-        }\n-\n-        private void resetFilters() {\n-            includes = new ArrayList<>();\n-            excludes = new ArrayList<>();\n-            includeFiles = new ArrayList<>();\n-            excludeFiles = new ArrayList<>();\n-        }\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/options\/Options.java","additions":0,"deletions":521,"binary":false,"changes":521,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.options;\n-\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Module;\n-import com.sun.tools.sjavac.ProblemException;\n-import com.sun.tools.sjavac.Source;\n-\n-\/**\n- * Represents a directory to be used for input to sjavac. (For instance a\n- * sourcepath or classpath.)\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SourceLocation {\n-\n-    \/\/ Path to the root directory\n-    private Path path;\n-\n-    \/\/ Package include \/ exclude patterns and file includes \/ excludes.\n-    List<String> includes, excludes;\n-\n-    public SourceLocation(Path path,\n-                          List<String> includes,\n-                          List<String> excludes) {\n-        this.path = path;\n-        this.includes = includes;\n-        this.excludes = excludes;\n-    }\n-\n-\n-    \/**\n-     * Finds all files with the given suffix that pass the include \/ exclude\n-     * filters in this source location.\n-     *\n-     * @param suffixes The set of suffixes to search for\n-     * @param foundFiles The map in which to store the found files\n-     * @param foundModules The map in which to store the found modules\n-     * @param currentModule The current module\n-     * @param permitSourcesInDefaultPackage true if sources in default package\n-     *                                      are to be permitted\n-     * @param inLinksrc true if in link source\n-     *\/\n-    public void findSourceFiles(Set<String> suffixes,\n-                                Map<String, Source> foundFiles,\n-                                Map<String, Module> foundModules,\n-                                Module currentModule,\n-                                boolean permitSourcesInDefaultPackage,\n-                                boolean inLinksrc)\n-                                        throws IOException {\n-        try {\n-            Source.scanRoot(path.toFile(),\n-                            suffixes,\n-                            excludes,\n-                            includes,\n-                            foundFiles,\n-                            foundModules,\n-                            currentModule,\n-                            permitSourcesInDefaultPackage,\n-                            false,\n-                            inLinksrc);\n-        } catch (ProblemException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-    \/** Get the root directory of this source location *\/\n-    public Path getPath() {\n-        return path;\n-    }\n-\n-    \/** Get the package include patterns *\/\n-    public List<String> getIncludes() {\n-        return includes;\n-    }\n-\n-    \/** Get the package exclude patterns *\/\n-    public List<String> getExcludes() {\n-        return excludes;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"%s[\\\"%s\\\", includes: %s, excludes: %s]\",\n-                             getClass().getSimpleName(), path, includes, excludes);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/options\/SourceLocation.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-\n-import javax.lang.model.type.TypeKind;\n-\n-public class ArrayTypeDesc extends TypeDesc implements Serializable {\n-\n-    private static final long serialVersionUID = -1177329549163314996L;\n-\n-    TypeDesc compTypeDesc;\n-\n-    public ArrayTypeDesc(TypeDesc compTypeDesc) {\n-        super(TypeKind.ARRAY);\n-        this.compTypeDesc = compTypeDesc;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (!super.equals(obj))\n-            return false;\n-        return compTypeDesc.equals(((ArrayTypeDesc) obj).compTypeDesc);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return super.hashCode() ^ compTypeDesc.hashCode();\n-    }\n-\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/ArrayTypeDesc.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-\n-import javax.lang.model.type.TypeKind;\n-\n-import com.sun.tools.javac.util.StringUtils;\n-\n-public class PrimitiveTypeDesc extends TypeDesc implements Serializable {\n-\n-    private static final long serialVersionUID = 6051065543149129106L;\n-\n-    public PrimitiveTypeDesc(TypeKind typeKind) {\n-        super(typeKind);\n-        if (!typeKind.isPrimitive() && typeKind != TypeKind.VOID)\n-            throw new IllegalArgumentException(\"Only primitives or void accepted\");\n-    }\n-\n-    \/\/ This class has no fields, so the inherited hashCode and equals should do fine.\n-\n-    @Override\n-    public String toString() {\n-        return StringUtils.toLowerCase(typeKind.toString());\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PrimitiveTypeDesc.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,437 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-\n-import static com.sun.tools.sjavac.Util.union;\n-\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import javax.lang.model.element.Modifier;\n-\n-import com.sun.tools.javac.util.Assert;\n-import com.sun.tools.javac.util.StringUtils;\n-\n-@SuppressWarnings(\"serial\") \/\/ Types of instance fields are not Serializable\n-public class PubApi implements Serializable {\n-\n-    private static final long serialVersionUID = 5926627347801986850L;\n-\n-    \/\/ Used to have Set here. Problem is that the objects are mutated during\n-    \/\/ javac_state loading, causing them to change hash codes. We could probably\n-    \/\/ change back to Set once javac_state loading is cleaned up.\n-    public final Map<String, PubType> types = new HashMap<>();\n-    public final Map<String, PubVar> variables = new HashMap<>();\n-    public final Map<String, PubMethod> methods = new HashMap<>();\n-    public final Map<String, PubVar> recordComponents = new HashMap<>();\n-\n-    public PubApi() {\n-    }\n-\n-    public PubApi(Collection<PubType> types,\n-                  Collection<PubVar> variables,\n-                  Collection<PubMethod> methods) {\n-        types.forEach(this::addPubType);\n-        variables.forEach(this::addPubVar);\n-        methods.forEach(this::addPubMethod);\n-    }\n-\n-    \/\/ Currently this is implemented as equality. This is far from optimal. It\n-    \/\/ should preferably make sure that all previous methods are still available\n-    \/\/ and no abstract methods are added. It should also be aware of inheritance\n-    \/\/ of course.\n-    public boolean isBackwardCompatibleWith(PubApi older) {\n-        return equals(older);\n-    }\n-\n-    private static String typeLine(PubType type) {\n-        if (type.fqName.isEmpty())\n-            throw new RuntimeException(\"empty class name \" + type);\n-        return String.format(\"TYPE %s%s\", asString(type.modifiers), type.fqName);\n-    }\n-\n-    private static String varLine(PubVar var) {\n-        return String.format(\"VAR %s%s %s%s\",\n-                             asString(var.modifiers),\n-                             TypeDesc.encodeAsString(var.type),\n-                             var.identifier,\n-                             var.getConstValue().map(v -> \" = \" + v).orElse(\"\"));\n-    }\n-\n-    private static String methodLine(PubMethod method) {\n-        return String.format(\"METHOD %s%s%s %s(%s)%s\",\n-                             asString(method.modifiers),\n-                             method.typeParams.isEmpty() ? \"\" : (\"<\" + method.typeParams.stream().map(PubApiTypeParam::asString).collect(Collectors.joining(\",\")) + \"> \"),\n-                             TypeDesc.encodeAsString(method.returnType),\n-                             method.identifier,\n-                             commaSeparated(method.paramTypes),\n-                             method.throwDecls.isEmpty()\n-                                 ? \"\"\n-                                 : \" throws \" + commaSeparated(method.throwDecls));\n-    }\n-\n-    public List<String> asListOfStrings() {\n-        List<String> lines = new ArrayList<>();\n-\n-        \/\/ Types\n-        types.values()\n-             .stream()\n-             .sorted(Comparator.comparing(PubApi::typeLine))\n-             .forEach(type -> {\n-                 lines.add(typeLine(type));\n-                 for (String subline : type.pubApi.asListOfStrings())\n-                     lines.add(\"  \" + subline);\n-             });\n-\n-        \/\/ Variables\n-        variables.values()\n-                 .stream()\n-                 .map(PubApi::varLine)\n-                 .sorted()\n-                 .forEach(lines::add);\n-\n-        \/\/ Methods\n-        methods.values()\n-               .stream()\n-               .map(PubApi::methodLine)\n-               .sorted()\n-               .forEach(lines::add);\n-\n-        return lines;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (getClass() != obj.getClass())\n-            return false;\n-        PubApi other = (PubApi) obj;\n-        return types.equals(other.types)\n-            && variables.equals(other.variables)\n-            && methods.equals(other.methods);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return types.keySet().hashCode()\n-             ^ variables.keySet().hashCode()\n-             ^ methods.keySet().hashCode();\n-    }\n-\n-    private static String commaSeparated(List<TypeDesc> typeDescs) {\n-        return typeDescs.stream()\n-                        .map(TypeDesc::encodeAsString)\n-                        .collect(Collectors.joining(\",\"));\n-    }\n-\n-    \/\/ Create space separated list of modifiers (with a trailing space)\n-    private static String asString(Set<Modifier> modifiers) {\n-        return modifiers.stream()\n-                        .map(mod -> mod + \" \")\n-                        .sorted()\n-                        .collect(Collectors.joining());\n-    }\n-\n-    \/\/ Used to combine class PubApis to package level PubApis\n-    public static PubApi mergeTypes(PubApi api1, PubApi api2) {\n-        Assert.check(api1.methods.isEmpty(), \"Can only merge types.\");\n-        Assert.check(api2.methods.isEmpty(), \"Can only merge types.\");\n-        Assert.check(api1.variables.isEmpty(), \"Can only merge types.\");\n-        Assert.check(api2.variables.isEmpty(), \"Can only merge types.\");\n-        PubApi merged = new PubApi();\n-        merged.types.putAll(api1.types);\n-        merged.types.putAll(api2.types);\n-        return merged;\n-    }\n-\n-\n-    \/\/ Used for line-by-line parsing\n-    private PubType lastInsertedType = null;\n-\n-    private static final String MODIFIERS = Stream.of(Modifier.values())\n-                                                  .map(Modifier::name)\n-                                                  .map(StringUtils::toLowerCase)\n-                                                  .collect(Collectors.joining(\"|\", \"(\", \")\"));\n-\n-    private static final Pattern MOD_PATTERN = Pattern.compile(\"(\" + MODIFIERS + \" )*\");\n-    private static final Pattern METHOD_PATTERN = Pattern.compile(\"(?<ret>.+?) (?<name>\\\\S+)\\\\((?<params>.*)\\\\)( throws (?<throws>.*))?\");\n-    private static final Pattern VAR_PATTERN = Pattern.compile(\"VAR (?<modifiers>(\"+MODIFIERS+\" )*)(?<type>.+?) (?<id>\\\\S+)( = (?<val>.*))?\");\n-    private static final Pattern TYPE_PATTERN = Pattern.compile(\"TYPE (?<modifiers>(\"+MODIFIERS+\" )*)(?<fullyQualified>\\\\S+)\");\n-\n-    public void appendItem(String l) {\n-        try {\n-            if (l.startsWith(\"  \")) {\n-                lastInsertedType.pubApi.appendItem(l.substring(2));\n-                return;\n-            }\n-\n-            if (l.startsWith(\"METHOD\")) {\n-                l = l.substring(\"METHOD \".length());\n-                Set<Modifier> modifiers = new HashSet<>();\n-                Matcher modMatcher = MOD_PATTERN.matcher(l);\n-                if (modMatcher.find()) {\n-                    String modifiersStr = modMatcher.group();\n-                    modifiers.addAll(parseModifiers(modifiersStr));\n-                    l = l.substring(modifiersStr.length());\n-                }\n-                List<PubApiTypeParam> typeParams = new ArrayList<>();\n-                if (l.startsWith(\"<\")) {\n-                    int closingPos = findClosingTag(l, 0);\n-                    String str = l.substring(1, closingPos);\n-                    l = l.substring(closingPos+1);\n-                    typeParams.addAll(parseTypeParams(splitOnTopLevelCommas(str)));\n-                }\n-                Matcher mm = METHOD_PATTERN.matcher(l);\n-                if (!mm.matches())\n-                    throw new AssertionError(\"Could not parse return type, identifier, parameter types or throws declaration of method: \" + l);\n-\n-                List<String> params = splitOnTopLevelCommas(mm.group(\"params\"));\n-                String th = Optional.ofNullable(mm.group(\"throws\")).orElse(\"\");\n-                List<String> throwz = splitOnTopLevelCommas(th);\n-                PubMethod m = new PubMethod(modifiers,\n-                                            typeParams,\n-                                            TypeDesc.decodeString(mm.group(\"ret\")),\n-                                            mm.group(\"name\"),\n-                                            parseTypeDescs(params),\n-                                            parseTypeDescs(throwz));\n-                addPubMethod(m);\n-                return;\n-            }\n-\n-            Matcher vm = VAR_PATTERN.matcher(l);\n-            if (vm.matches()) {\n-                addPubVar(new PubVar(parseModifiers(vm.group(\"modifiers\")),\n-                                     TypeDesc.decodeString(vm.group(\"type\")),\n-                                     vm.group(\"id\"),\n-                                     vm.group(\"val\")));\n-                return;\n-            }\n-\n-            Matcher tm = TYPE_PATTERN.matcher(l);\n-            if (tm.matches()) {\n-                addPubType(new PubType(parseModifiers(tm.group(\"modifiers\")),\n-                                       tm.group(\"fullyQualified\"),\n-                                       new PubApi()));\n-                return;\n-            }\n-\n-            throw new AssertionError(\"No matching line pattern.\");\n-        } catch (Throwable e) {\n-            throw new AssertionError(\"Could not parse API line: \" + l, e);\n-        }\n-    }\n-\n-    public void addPubType(PubType t) {\n-        types.put(t.fqName, t);\n-        lastInsertedType = t;\n-    }\n-\n-    public void addPubVar(PubVar v) {\n-        variables.put(v.identifier, v);\n-    }\n-\n-    public void addPubMethod(PubMethod m) {\n-        methods.put(m.asSignatureString(), m);\n-    }\n-\n-    private static List<TypeDesc> parseTypeDescs(List<String> strs) {\n-        return strs.stream()\n-                   .map(TypeDesc::decodeString)\n-                   .toList();\n-    }\n-\n-    private static List<PubApiTypeParam> parseTypeParams(List<String> strs) {\n-        return strs.stream().map(PubApi::parseTypeParam).toList();\n-    }\n-\n-    \/\/ Parse a type parameter string. Example input:\n-    \/\/     identifier\n-    \/\/     identifier extends Type (& Type)*\n-    private static PubApiTypeParam parseTypeParam(String typeParamString) {\n-        int extPos = typeParamString.indexOf(\" extends \");\n-        if (extPos == -1)\n-            return new PubApiTypeParam(typeParamString, Collections.emptyList());\n-        String identifier = typeParamString.substring(0, extPos);\n-        String rest = typeParamString.substring(extPos + \" extends \".length());\n-        List<TypeDesc> bounds = parseTypeDescs(splitOnTopLevelChars(rest, '&'));\n-        return new PubApiTypeParam(identifier, bounds);\n-    }\n-\n-    public Set<Modifier> parseModifiers(String modifiers) {\n-        if (modifiers == null)\n-            return Collections.emptySet();\n-        return Stream.of(modifiers.split(\" \"))\n-                     .map(String::trim)\n-                     .map(StringUtils::toUpperCase)\n-                     .filter(s -> !s.isEmpty())\n-                     .map(Modifier::valueOf)\n-                     .collect(Collectors.toSet());\n-    }\n-\n-    \/\/ Find closing tag of the opening tag at the given 'pos'.\n-    private static int findClosingTag(String l, int pos) {\n-        while (true) {\n-            pos = pos + 1;\n-            if (l.charAt(pos) == '>')\n-                return pos;\n-            if (l.charAt(pos) == '<')\n-                pos = findClosingTag(l, pos);\n-        }\n-    }\n-\n-    public List<String> splitOnTopLevelCommas(String s) {\n-        return splitOnTopLevelChars(s, ',');\n-    }\n-\n-    public static List<String> splitOnTopLevelChars(String s, char split) {\n-        if (s.isEmpty())\n-            return Collections.emptyList();\n-        List<String> result = new ArrayList<>();\n-        StringBuilder buf = new StringBuilder();\n-        int depth = 0;\n-        for (char c : s.toCharArray()) {\n-            if (c == split && depth == 0) {\n-                result.add(buf.toString().trim());\n-                buf = new StringBuilder();\n-            } else {\n-                if (c == '<') depth++;\n-                if (c == '>') depth--;\n-                buf.append(c);\n-            }\n-        }\n-        result.add(buf.toString().trim());\n-        return result;\n-    }\n-\n-    public boolean isEmpty() {\n-        return types.isEmpty() && variables.isEmpty() && methods.isEmpty();\n-    }\n-\n-    \/\/ Used for descriptive debug messages when figuring out what triggers\n-    \/\/ recompilation.\n-    public List<String> diff(PubApi prevApi) {\n-        return diff(\"\", prevApi);\n-    }\n-    private List<String> diff(String scopePrefix, PubApi prevApi) {\n-\n-        List<String> diffs = new ArrayList<>();\n-\n-        for (String typeKey : union(types.keySet(), prevApi.types.keySet())) {\n-            PubType type = types.get(typeKey);\n-            PubType prevType = prevApi.types.get(typeKey);\n-            if (prevType == null) {\n-                diffs.add(\"Type \" + scopePrefix + typeKey + \" was added\");\n-            } else if (type == null) {\n-                diffs.add(\"Type \" + scopePrefix + typeKey + \" was removed\");\n-            } else {\n-                \/\/ Check modifiers\n-                if (!type.modifiers.equals(prevType.modifiers)) {\n-                    diffs.add(\"Modifiers for type \" + scopePrefix + typeKey\n-                            + \" changed from \" + prevType.modifiers + \" to \"\n-                            + type.modifiers);\n-                }\n-\n-                \/\/ Recursively check types pub API\n-                diffs.addAll(type.pubApi.diff(prevType.pubApi));\n-            }\n-        }\n-\n-        for (String varKey : union(variables.keySet(), prevApi.variables.keySet())) {\n-            PubVar var = variables.get(varKey);\n-            PubVar prevVar = prevApi.variables.get(varKey);\n-            if (prevVar == null) {\n-                diffs.add(\"Variable \" + scopePrefix + varKey + \" was added\");\n-            } else if (var == null) {\n-                diffs.add(\"Variable \" + scopePrefix + varKey + \" was removed\");\n-            } else {\n-                if (!var.modifiers.equals(prevVar.modifiers)) {\n-                    diffs.add(\"Modifiers for var \" + scopePrefix + varKey\n-                            + \" changed from \" + prevVar.modifiers + \" to \"\n-                            + var.modifiers);\n-                }\n-                if (!var.type.equals(prevVar.type)) {\n-                    diffs.add(\"Type of \" + scopePrefix + varKey\n-                            + \" changed from \" + prevVar.type + \" to \"\n-                            + var.type);\n-                }\n-                if (!var.getConstValue().equals(prevVar.getConstValue())) {\n-                    diffs.add(\"Const value of \" + scopePrefix + varKey\n-                            + \" changed from \" + prevVar.getConstValue().orElse(\"<none>\")\n-                            + \" to \" + var.getConstValue().orElse(\"<none>\"));\n-                }\n-            }\n-        }\n-\n-        for (String methodKey : union(methods.keySet(), prevApi.methods.keySet())) {\n-            PubMethod method = methods.get(methodKey);\n-            PubMethod prevMethod = prevApi.methods.get(methodKey);\n-            if (prevMethod == null) {\n-                diffs.add(\"Method \" + scopePrefix + methodKey + \" was added\");\n-            } else if (method == null) {\n-                diffs.add(\"Method \" + scopePrefix + methodKey + \" was removed\");\n-            } else {\n-                if (!method.modifiers.equals(prevMethod.modifiers)) {\n-                    diffs.add(\"Modifiers for method \" + scopePrefix + methodKey\n-                            + \" changed from \" + prevMethod.modifiers + \" to \"\n-                            + method.modifiers);\n-                }\n-                if (!method.typeParams.equals(prevMethod.typeParams)) {\n-                    diffs.add(\"Type parameters for method \" + scopePrefix\n-                            + methodKey + \" changed from \" + prevMethod.typeParams\n-                            + \" to \" + method.typeParams);\n-                }\n-                if (!method.throwDecls.equals(prevMethod.throwDecls)) {\n-                    diffs.add(\"Throw decl for method \" + scopePrefix + methodKey\n-                            + \" changed from \" + prevMethod.throwDecls + \" to \"\n-                            + \" to \" + method.throwDecls);\n-                }\n-            }\n-        }\n-\n-        return diffs;\n-    }\n-\n-    public String toString() {\n-        return String.format(\"%s[types: %s, variables: %s, methods: %s]\",\n-                             getClass().getSimpleName(),\n-                             types.values(),\n-                             variables.values(),\n-                             methods.values());\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PubApi.java","additions":0,"deletions":437,"binary":false,"changes":437,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-@SuppressWarnings(\"serial\") \/\/ Types of instance fields are not Serializable\n-public class PubApiTypeParam implements Serializable {\n-\n-    private static final long serialVersionUID = 8899204612014329162L;\n-\n-    private final String identifier;\n-    private final List<TypeDesc> bounds;\n-\n-    public PubApiTypeParam(String identifier, List<TypeDesc> bounds) {\n-        this.identifier = identifier;\n-        this.bounds = bounds;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (getClass() != obj.getClass())\n-            return false;\n-        PubApiTypeParam other = (PubApiTypeParam) obj;\n-        return identifier.equals(other.identifier)\n-            && bounds.equals(other.bounds);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return identifier.hashCode() ^ bounds.hashCode();\n-    }\n-\n-    public String asString() {\n-        if (bounds.isEmpty())\n-            return identifier;\n-        String boundsStr = bounds.stream()\n-                                 .map(TypeDesc::encodeAsString)\n-                                 .collect(Collectors.joining(\" & \"));\n-        return identifier + \" extends \" + boundsStr;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"%s[id: %s, bounds: %s]\",\n-                             getClass().getSimpleName(),\n-                             identifier,\n-                             bounds);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PubApiTypeParam.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,117 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-\n-import javax.lang.model.element.Modifier;\n-\n-@SuppressWarnings(\"serial\") \/\/ Types of instance fields are not Serializable\n-public class PubMethod implements Serializable {\n-\n-    private static final long serialVersionUID = -7813050194553446243L;\n-\n-    Set<Modifier> modifiers;\n-    List<PubApiTypeParam> typeParams;\n-    TypeDesc returnType;\n-    String identifier;\n-    List<TypeDesc> paramTypes;\n-    List<TypeDesc> throwDecls;\n-\n-    public PubMethod(Set<Modifier> modifiers,\n-                     List<PubApiTypeParam> typeParams,\n-                     TypeDesc returnType,\n-                     String identifier,\n-                     List<TypeDesc> paramTypes,\n-                     List<TypeDesc> throwDecls) {\n-        this.modifiers = modifiers;\n-        this.typeParams = typeParams;\n-        this.returnType = returnType;\n-        this.identifier = identifier;\n-        this.paramTypes = paramTypes;\n-        this.throwDecls = throwDecls;\n-    }\n-\n-    \/\/ We need to include return type and type parameters to be sure to have\n-    \/\/ different values for different methods. (A method can be overloaded with\n-    \/\/ the only difference being the upper bound of the return type.)\n-    public String asSignatureString() {\n-        StringBuilder sb = new StringBuilder();\n-\n-        \/\/ <A extends String, Serializable, B extends List>\n-        if (typeParams.size() > 0) {\n-            sb.append(typeParams.stream()\n-                                .map(PubApiTypeParam::asString)\n-                                .collect(Collectors.joining(\",\", \"<\", \"> \")));\n-        }\n-        sb.append(TypeDesc.encodeAsString(returnType));\n-        sb.append(\" \");\n-        sb.append(identifier);\n-        sb.append(\"(\");\n-        sb.append(paramTypes.stream()\n-                            .map(TypeDesc::encodeAsString)\n-                            .collect(Collectors.joining(\",\")));\n-        sb.append(\")\");\n-        return sb.toString();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (getClass() != obj.getClass())\n-            return false;\n-        PubMethod other = (PubMethod) obj;\n-        return modifiers.equals(other.modifiers)\n-            && typeParams.equals(other.typeParams)\n-            && returnType.equals(other.returnType)\n-            && identifier.equals(other.identifier)\n-            && paramTypes.equals(other.paramTypes)\n-            && throwDecls.equals(other.throwDecls);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return modifiers.hashCode()\n-             ^ typeParams.hashCode()\n-             ^ returnType.hashCode()\n-             ^ identifier.hashCode()\n-             ^ paramTypes.hashCode()\n-             ^ throwDecls.hashCode();\n-    }\n-\n-    public String toString() {\n-        return String.format(\"%s[modifiers: %s, typeParams: %s, retType: %s, identifier: %s, params: %s, throws: %s]\",\n-                             getClass().getSimpleName(),\n-                             modifiers,\n-                             typeParams,\n-                             returnType,\n-                             identifier,\n-                             paramTypes,\n-                             throwDecls);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PubMethod.java","additions":0,"deletions":117,"binary":false,"changes":117,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Modifier;\n-\n-@SuppressWarnings(\"serial\") \/\/ Types of instance fields are not Serializable\n-public class PubType implements Serializable {\n-\n-    private static final long serialVersionUID = -7423416049253889793L;\n-\n-    public final Set<Modifier> modifiers;\n-    public final String fqName;\n-    public final PubApi pubApi;\n-\n-    public PubType(Set<Modifier> modifiers,\n-                   String fqName,\n-                   PubApi pubApi) {\n-        this.modifiers = modifiers;\n-        this.fqName = fqName;\n-        this.pubApi = pubApi;\n-    }\n-\n-    public String getFqName() {\n-        return fqName.toString();\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (getClass() != obj.getClass())\n-            return false;\n-        PubType other = (PubType) obj;\n-        return modifiers.equals(other.modifiers)\n-            && fqName.equals(other.fqName)\n-            && pubApi.equals(other.pubApi);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return modifiers.hashCode() ^ fqName.hashCode() ^ pubApi.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"%s[modifiers: %s, fqName: %s, pubApi: %s]\",\n-                             getClass().getSimpleName(),\n-                             modifiers,\n-                             fqName,\n-                             pubApi);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PubType.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,89 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-import java.util.Optional;\n-import java.util.Set;\n-\n-import javax.lang.model.element.Modifier;\n-\n-@SuppressWarnings(\"serial\") \/\/ Types of instance fields are not Serializable\n-public class PubVar implements Serializable {\n-\n-    private static final long serialVersionUID = 5806536061153374575L;\n-\n-    public final Set<Modifier> modifiers;\n-    public final TypeDesc type;\n-    public final String identifier;\n-    private final String constValue;\n-\n-    public PubVar(Set<Modifier> modifiers,\n-                  TypeDesc type,\n-                  String identifier,\n-                  String constValue) {\n-        this.modifiers = modifiers;\n-        this.type = type;\n-        this.identifier = identifier;\n-        this.constValue = constValue;\n-    }\n-\n-    public String getIdentifier() {\n-        return identifier;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (getClass() != obj.getClass())\n-            return false;\n-        PubVar other = (PubVar) obj;\n-        return modifiers.equals(other.modifiers)\n-            && type.equals(other.type)\n-            && identifier.equals(other.identifier)\n-            && getConstValue().equals(other.getConstValue());\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return modifiers.hashCode()\n-             ^ type.hashCode()\n-             ^ identifier.hashCode()\n-             ^ getConstValue().hashCode();\n-    }\n-\n-    public String toString() {\n-        return String.format(\"%s[modifiers: %s, type: %s, identifier: %s, constValue: %s]\",\n-                             getClass().getSimpleName(),\n-                             modifiers,\n-                             type,\n-                             identifier,\n-                             constValue);\n-    }\n-\n-    public Optional<String> getConstValue() {\n-        return Optional.ofNullable(constValue);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/PubVar.java","additions":0,"deletions":89,"binary":false,"changes":89,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-\n-import javax.lang.model.type.TypeKind;\n-\n-public class ReferenceTypeDesc extends TypeDesc implements Serializable {\n-\n-    private static final long serialVersionUID = 3357616754544796372L;\n-\n-    \/\/ Example: \"java.util.Vector<java.lang.String>\"\n-    String javaType;\n-\n-    public ReferenceTypeDesc(String javaType) {\n-        super(TypeKind.DECLARED);\n-        this.javaType = javaType;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (!super.equals(obj))\n-            return false;\n-        return javaType.equals(((ReferenceTypeDesc) obj).javaType);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return super.hashCode() ^ javaType.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"%s[type: %s]\", getClass().getSimpleName(), javaType);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/ReferenceTypeDesc.java","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-\n-import javax.lang.model.type.ArrayType;\n-import javax.lang.model.type.DeclaredType;\n-import javax.lang.model.type.ErrorType;\n-import javax.lang.model.type.NoType;\n-import javax.lang.model.type.PrimitiveType;\n-import javax.lang.model.type.TypeKind;\n-import javax.lang.model.type.TypeMirror;\n-import javax.lang.model.type.TypeVariable;\n-import javax.lang.model.type.TypeVisitor;\n-import javax.lang.model.util.SimpleTypeVisitor14;\n-\n-import com.sun.tools.javac.code.Type.ClassType;\n-import com.sun.tools.javac.util.DefinedBy;\n-import com.sun.tools.javac.util.DefinedBy.Api;\n-import com.sun.tools.javac.util.StringUtils;\n-\n-public abstract class TypeDesc implements Serializable {\n-\n-    private static final long serialVersionUID = -8201634143915519172L;\n-\n-    TypeKind typeKind;\n-\n-    public TypeDesc(TypeKind typeKind) {\n-        this.typeKind = typeKind;\n-    }\n-\n-    public static TypeDesc decodeString(String s) {\n-        s = s.trim();\n-        if (s.endsWith(\"[]\")) {\n-            String componentPart = s.substring(0, s.length()-2);\n-            return new ArrayTypeDesc(decodeString(componentPart));\n-        }\n-\n-        if (s.startsWith(\"#\"))\n-            return new TypeVarTypeDesc(s.substring(1));\n-\n-        if (s.matches(\"boolean|byte|char|double|float|int|long|short|void\")) {\n-            TypeKind tk = TypeKind.valueOf(StringUtils.toUpperCase(s));\n-            return new PrimitiveTypeDesc(tk);\n-        }\n-\n-        return new ReferenceTypeDesc(s);\n-    }\n-\n-    public static String encodeAsString(TypeDesc td) {\n-        if (td.typeKind.isPrimitive() || td.typeKind == TypeKind.VOID)\n-            return StringUtils.toLowerCase(td.typeKind.toString());\n-\n-        if (td.typeKind == TypeKind.ARRAY)\n-            return encodeAsString(((ArrayTypeDesc) td).compTypeDesc) + \"[]\";\n-\n-        if (td.typeKind == TypeKind.TYPEVAR)\n-            return \"#\" + ((TypeVarTypeDesc) td).identifier;\n-\n-        if (td.typeKind == TypeKind.DECLARED)\n-            return ((ReferenceTypeDesc) td).javaType.toString();\n-\n-        throw new AssertionError(\"Unhandled type: \" + td.typeKind);\n-    }\n-\n-    public static TypeDesc fromType(TypeMirror type) {\n-        TypeVisitor<TypeDesc, Void> v = new SimpleTypeVisitor14<TypeDesc, Void>() {\n-            @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-            public TypeDesc visitArray(ArrayType t, Void p) {\n-                return new ArrayTypeDesc(t.getComponentType().accept(this, p));\n-            }\n-\n-            @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-            public TypeDesc visitDeclared(DeclaredType t, Void p) {\n-                return new ReferenceTypeDesc(((ClassType) t).tsym.flatName().toString());\n-            }\n-\n-            @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-            public TypeDesc visitNoType(NoType t, Void p) {\n-                return new PrimitiveTypeDesc(TypeKind.VOID);\n-            }\n-\n-            @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-            public TypeDesc visitTypeVariable(TypeVariable t, Void p) {\n-                return new TypeVarTypeDesc(t.toString());\n-            }\n-\n-            @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-            public TypeDesc visitPrimitive(PrimitiveType t, Void p) {\n-                return new PrimitiveTypeDesc(t.getKind());\n-            }\n-\n-            @Override @DefinedBy(Api.LANGUAGE_MODEL)\n-            public TypeDesc visitError(ErrorType t, Void p) {\n-                return new ReferenceTypeDesc(\"<error type>\");\n-            }\n-        };\n-\n-        TypeDesc td = v.visit(type);\n-        if (td == null)\n-            throw new AssertionError(\"Unhandled type mirror: \" + type + \" (\" + type.getClass() + \")\");\n-        return td;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (getClass() != obj.getClass())\n-            return false;\n-        return typeKind.equals(((TypeDesc) obj).typeKind);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return typeKind.hashCode();\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/TypeDesc.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -1,61 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.pubapi;\n-\n-import java.io.Serializable;\n-\n-import javax.lang.model.type.TypeKind;\n-\n-public class TypeVarTypeDesc extends TypeDesc implements Serializable {\n-\n-    private static final long serialVersionUID = 3357616754544796373L;\n-\n-    String identifier; \/\/ Example: \"T\"\n-\n-    public TypeVarTypeDesc(String identifier) {\n-        super(TypeKind.TYPEVAR);\n-        this.identifier = identifier;\n-    }\n-\n-    @Override\n-    public boolean equals(Object obj) {\n-        if (!super.equals(obj))\n-            return false;\n-        return identifier.equals(((TypeVarTypeDesc) obj).identifier);\n-    }\n-\n-    @Override\n-    public int hashCode() {\n-        return super.hashCode() ^ identifier.hashCode();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return String.format(\"%s[identifier: %s]\",\n-                             getClass().getSimpleName(),\n-                             identifier);\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/pubapi\/TypeVarTypeDesc.java","additions":0,"deletions":61,"binary":false,"changes":61,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.server;\n-\n-import java.io.Serializable;\n-import java.net.URI;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Set;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-\n-\/**\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-@SuppressWarnings(\"serial\") \/\/ Types of instance fields are not Serializable\n-public class CompilationSubResult implements Serializable {\n-\n-    static final long serialVersionUID = 46739181113L;\n-\n-    public Result result;\n-    public Map<String, Set<URI>> packageArtifacts = new HashMap<>();\n-    public Map<String, Map<String, Set<String>>> packageDependencies = new HashMap<>();\n-    public Map<String, Map<String, Set<String>>> packageCpDependencies = new HashMap<>();\n-    public Map<String, PubApi> packagePubapis = new HashMap<>();\n-    public Map<String, PubApi> dependencyPubapis = new HashMap<>();\n-    public String stdout = \"\";\n-    public String stderr = \"\";\n-\n-    public CompilationSubResult(Result result) {\n-        this.result = result;\n-    }\n-\n-    public void setResult(Result result) {\n-        this.result = result;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/CompilationSubResult.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,98 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.tools.sjavac.server;\n-\n-import java.io.FileWriter;\n-import java.io.FilterOutputStream;\n-import java.io.FilterWriter;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.lang.Thread.UncaughtExceptionHandler;\n-\n-import com.sun.tools.javac.main.Main;\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.Log;\n-import com.sun.tools.sjavac.Log.Level;\n-import com.sun.tools.sjavac.server.log.LazyInitFileLog;\n-import com.sun.tools.sjavac.server.log.LoggingOutputStream;\n-\n-import static com.sun.tools.sjavac.Log.Level.ERROR;\n-import static com.sun.tools.sjavac.Log.Level.INFO;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class ServerMain {\n-\n-    \/\/ For logging server internal (non request specific) errors.\n-    private static LazyInitFileLog errorLog;\n-\n-    public static int run(String[] args) {\n-\n-        \/\/ Under normal operation, all logging messages generated server-side\n-        \/\/ are due to compilation requests. These logging messages should\n-        \/\/ be relayed back to the requesting client rather than written to the\n-        \/\/ server log. The only messages that should be written to the server\n-        \/\/ log (in production mode) should be errors,\n-        Log.setLogForCurrentThread(errorLog = new LazyInitFileLog(\"server.log\"));\n-        Log.setLogLevel(ERROR); \/\/ should be set to ERROR.\n-\n-        \/\/ Make sure no exceptions go under the radar\n-        Thread.setDefaultUncaughtExceptionHandler((t, e) -> {\n-            Log.setLogForCurrentThread(errorLog);\n-            Log.error(e);\n-        });\n-\n-        \/\/ Inevitably someone will try to print messages using System.{out,err}.\n-        \/\/ Make sure this output also ends up in the log.\n-        System.setOut(new PrintStream(new LoggingOutputStream(System.out, INFO, \"[stdout] \")));\n-        System.setErr(new PrintStream(new LoggingOutputStream(System.err, ERROR, \"[stderr] \")));\n-\n-        \/\/ Any options other than --startserver?\n-        if (args.length > 1) {\n-            Log.error(\"When spawning a background server, only a single --startserver argument is allowed.\");\n-            return Result.CMDERR.exitCode;\n-        }\n-\n-        int exitCode;\n-        try {\n-            SjavacServer server = new SjavacServer(args[0]);\n-            exitCode = server.startServer();\n-        } catch (IOException | InterruptedException ex) {\n-            ex.printStackTrace();\n-            exitCode = Result.ERROR.exitCode;\n-        }\n-\n-        return exitCode;\n-    }\n-\n-    public static LazyInitFileLog getErrorLog() {\n-        return errorLog;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/ServerMain.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * A utility class used to report information about the system\n- * where the javac server is running.\n- *\n- * <p><b>This is NOT part of any supported API.\n- * If you write code that depends on this, you do so at your own\n- * risk.  This code and its internal interfaces are subject to change\n- * or deletion without notice.<\/b><\/p>\n- *\/\n-package com.sun.tools.sjavac.server;\n-\n-import java.io.Serializable;\n-\n-\/**\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SysInfo implements Serializable {\n-\n-    static final long serialVersionUID = -3096346807579L;\n-\n-    public int numCores;\n-    public long maxMemory;\n-\n-    public SysInfo(int nc, long mm) {\n-        numCores = nc;\n-        maxMemory = mm;\n-    }\n-}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/sjavac\/server\/SysInfo.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-                            \"com\/sun\/tools\/sjavac\/client\/ClientMain\"),\n+                            \"com\/sun\/tools\/javac\/main\/Main\"),\n@@ -56,1 +56,1 @@\n-                             \"[class,load] com.sun.tools.sjavac.client.ClientMain\",\n+                             \"[class,load] com.sun.tools.javac.main.Main\",\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/UnusedCPDuringDump.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-              \"com.sun.tools.sjavac.Util\", \"com.sun.tools.sjavac.Main\"},\n+              \"com.sun.tools.jdeps.JdepsTask\", \"com.sun.tools.jdeps.Main\"},\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\/JimageClassProtDomain.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,12 +60,0 @@\n-###########################################################################\n-#\n-# sjavac\n-\n-tools\/sjavac\/IncCompileFullyQualifiedRef.java                                   8152055    generic-all    Requires dependency code to deal with in-method dependencies.\n-tools\/sjavac\/IncCompileWithChanges.java                                         8152055    generic-all    Requires dependency code to deal with in-method dependencies.\n-\n-tools\/sjavac\/ApiExtraction.java                                                 8158002    generic-all    Requires investigation\n-tools\/sjavac\/IgnoreSymbolFile.java                                              8158002    generic-all    Requires investigation\n-tools\/sjavac\/ClasspathDependencies.java                                         8158002    generic-all    Requires investigation\n-\n-\n","filename":"test\/langtools\/ProblemList.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -66,4 +66,0 @@\n-langtools_sjavac = \\\n-    tools\/all \\\n-    tools\/sjavac\n-\n","filename":"test\/langtools\/TEST.groups","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,1 +71,0 @@\n-                \"com.sun.tools.sjavac\",\n","filename":"test\/langtools\/tools\/javac\/NoStringToLower.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,2 +74,1 @@\n- * javac, javah, javap, and sjavac. (For javadoc support,\n- * see JavadocTester.)\n+ * javac, javah, and javap. (For javadoc support, see JavadocTester.)\n@@ -993,1 +992,0 @@\n-\n","filename":"test\/langtools\/tools\/lib\/toolbox\/ToolBox.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,217 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8054717\n- * @summary Make sure extraction of non-private APIs work as expected.\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- *          jdk.compiler\/com.sun.tools.sjavac.options\n- *          jdk.compiler\/com.sun.tools.sjavac.pubapi\n- * @build Wrapper toolbox.ToolBox toolbox.JavacTask\n- * @run main Wrapper ApiExtraction\n- *\/\n-\n-import static java.util.Arrays.asList;\n-import static java.util.Collections.emptyList;\n-import static javax.lang.model.element.Modifier.FINAL;\n-import static javax.lang.model.element.Modifier.PROTECTED;\n-import static javax.lang.model.element.Modifier.PUBLIC;\n-import static javax.lang.model.element.Modifier.STATIC;\n-\n-import java.io.IOException;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-\n-import javax.lang.model.type.TypeKind;\n-\n-import com.sun.tools.sjavac.PubApiExtractor;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.pubapi.PrimitiveTypeDesc;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-import com.sun.tools.sjavac.pubapi.PubMethod;\n-import com.sun.tools.sjavac.pubapi.PubType;\n-import com.sun.tools.sjavac.pubapi.PubVar;\n-import com.sun.tools.sjavac.pubapi.ReferenceTypeDesc;\n-\n-import toolbox.JavacTask;\n-import toolbox.ToolBox;\n-\n-public class ApiExtraction {\n-    public static void main(String[] args) throws IOException {\n-\n-        String testSrc = String.join(\"\\n\",\n-                \"import java.util.*;\",\n-                \"public final class TestClass extends Thread {\",\n-\n-                \/\/ Fields with various combination of modifiers\n-                \"    private String s1 = \\\"str 1\\\";\",\n-                \"    public String s2 = \\\"str 2\\\";\",\n-                \"    protected final String s3 = \\\"str 3\\\";\",\n-                \"    static String s4 = \\\"str 4\\\";\",\n-\n-                \/\/ Methods with various combinations of types and modifiers\n-                \"    protected void m1() {}\",\n-                \"    public static Map<Integer, List<String>> m2() {\",\n-                \"        return null;\",\n-                \"    }\",\n-                \"    final void m3(Set<Map<Integer, Map<String, String>>> s) {}\",\n-\n-                \/\/ Some inner classes\n-                \"    static class DummyInner1 implements Runnable {\",\n-                \"        protected int field;\",\n-                \"        public void run() {}\",\n-                \"    }\",\n-                \"    final class DummyInner2 { }\",\n-                \"}\");\n-\n-        \/\/ Create class file to extract API from\n-        new JavacTask(new ToolBox()).sources(testSrc).run();\n-\n-        \/\/ Extract PubApi\n-        Options options = Options.parseArgs(\"-d\", \"bin\", \"--state-dir=bin\", \"-cp\", \".\");\n-        PubApiExtractor pubApiExtr = new PubApiExtractor(options);\n-        PubApi actualApi = pubApiExtr.getPubApi(\"TestClass\");\n-        pubApiExtr.close();\n-\n-        \/\/ Validate result\n-        PubApi expectedApi = getExpectedPubApi();\n-        if (!expectedApi.equals(actualApi)) {\n-            List<String> diffs = expectedApi.diff(actualApi);\n-            System.out.println(diffs.size() + \" differences found.\");\n-            for (String diff : diffs) {\n-                System.out.println(diff);\n-            }\n-            throw new AssertionError(\"Actual API differs from expected API.\");\n-        }\n-    }\n-\n-    private static PubApi getExpectedPubApi() {\n-\n-        ReferenceTypeDesc string = new ReferenceTypeDesc(\"java.lang.String\");\n-\n-        \/\/ Fields\n-        \/\/ (s1 is private and therefore not included)\n-        PubVar s2 = new PubVar(setOf(PUBLIC), string, \"s2\", null);\n-        PubVar s4 = new PubVar(setOf(STATIC), string, \"s4\", null);\n-        PubVar s3 = new PubVar(setOf(PROTECTED, FINAL), string, \"s3\",\n-                                   \"\\\"\\\\u0073\\\\u0074\\\\u0072\\\\u0020\\\\u0033\\\"\");\n-\n-        \/\/ Methods\n-        PubMethod init = new PubMethod(setOf(PUBLIC),\n-                                       emptyList(),\n-                                       new PrimitiveTypeDesc(TypeKind.VOID),\n-                                       \"<init>\",\n-                                       emptyList(),\n-                                       emptyList());\n-\n-        PubMethod clinit = new PubMethod(setOf(STATIC),\n-                                         emptyList(),\n-                                         new PrimitiveTypeDesc(TypeKind.VOID),\n-                                         \"<clinit>\",\n-                                         emptyList(),\n-                                         emptyList());\n-\n-        PubMethod m1 = new PubMethod(setOf(PROTECTED),\n-                                     emptyList(),\n-                                     new PrimitiveTypeDesc(TypeKind.VOID),\n-                                     \"m1\",\n-                                     emptyList(),\n-                                     emptyList());\n-\n-        PubMethod m2 = new PubMethod(setOf(PUBLIC, STATIC),\n-                                     emptyList(),\n-                                     new ReferenceTypeDesc(\"java.util.Map\"),\n-                                     \"m2\",\n-                                     emptyList(),\n-                                     emptyList());\n-\n-        PubMethod m3 = new PubMethod(setOf(FINAL),\n-                                     emptyList(),\n-                                     new PrimitiveTypeDesc(TypeKind.VOID),\n-                                     \"m3\",\n-                                     asList(new ReferenceTypeDesc(\"java.util.Set\")),\n-                                     emptyList());\n-\n-        \/\/ Complete class\n-        PubType testClass = new PubType(setOf(PUBLIC, FINAL),\n-                                        \"TestClass\",\n-                                        new PubApi(asList(getDummyInner1(), getDummyInner2()),\n-                                                   asList(s2, s3, s4),\n-                                                   asList(init, clinit, m1, m2, m3)));\n-\n-        \/\/ Wrap in \"package level\" PubApi\n-        return new PubApi(asList(testClass), emptyList(), emptyList());\n-    }\n-\n-    private static PubType getDummyInner1() {\n-        PubMethod init = new PubMethod(setOf(),\n-                                       emptyList(),\n-                                       new PrimitiveTypeDesc(TypeKind.VOID),\n-                                       \"<init>\",\n-                                       emptyList(),\n-                                       emptyList());\n-\n-        PubMethod run = new PubMethod(setOf(PUBLIC),\n-                                      emptyList(),\n-                                      new PrimitiveTypeDesc(TypeKind.VOID),\n-                                      \"run\",\n-                                      emptyList(),\n-                                      emptyList());\n-\n-        PubVar field = new PubVar(setOf(PROTECTED),\n-                                  new PrimitiveTypeDesc(TypeKind.INT),\n-                                  \"field\",\n-                                  null);\n-\n-        return new PubType(setOf(STATIC),\n-                           \"TestClass$DummyInner1\",\n-                           new PubApi(emptyList(),\n-                                      asList(field),\n-                                      asList(init, run)));\n-    }\n-\n-    private static PubType getDummyInner2() {\n-        PubMethod init = new PubMethod(setOf(),\n-                                       emptyList(),\n-                                       new PrimitiveTypeDesc(TypeKind.VOID),\n-                                       \"<init>\",\n-                                       emptyList(),\n-                                       emptyList());\n-\n-        return new PubType(setOf(FINAL),\n-                           \"TestClass$DummyInner2\",\n-                           new PubApi(emptyList(),\n-                                      emptyList(),\n-                                      asList(init)));\n-    }\n-\n-    @SafeVarargs\n-    private static <T> Set<T> setOf(T... elements) {\n-        return new HashSet<>(asList(elements));\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/ApiExtraction.java","additions":0,"deletions":217,"binary":false,"changes":217,"status":"deleted"},{"patch":"@@ -1,137 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8054717\n- * @summary Make sure changes of public API on classpath triggers recompilation\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox toolbox.Assert\n- * @run main Wrapper ClasspathDependencies\n- *\/\n-\n-\n-import java.io.IOException;\n-import java.nio.file.FileVisitResult;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.nio.file.SimpleFileVisitor;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.file.attribute.FileTime;\n-\n-import static toolbox.Assert.check;\n-\n-public class ClasspathDependencies extends SjavacBase {\n-\n-    public static void main(String... args) throws Exception {\n-\n-        Path root = Paths.get(ClasspathDependencies.class.getSimpleName() + \"Test\");\n-\n-        delete(root);\n-\n-        Path src = root.resolve(\"src\");\n-        Path classes = root.resolve(\"classes\");\n-        Path srcDep = root.resolve(\"srcDep\");\n-        Path classesDep = root.resolve(\"classesDep\");\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        headline(\"Create a test dependency, Dep.class, and put it in the classpath dir\");\n-        String depCode = \"package dep; public class Dep { public void m1() {} }\";\n-        toolbox.writeFile(srcDep.resolve(\"dep\/Dep.java\"), depCode);\n-        int rc = compile(\"-d\", classesDep, \"--state-dir=\" + classesDep, srcDep);\n-        check(rc == 0, \"Compilation failed unexpectedly\");\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        headline(\"Compile and link against the Dep.class\");\n-        toolbox.writeFile(src.resolve(\"pkg\/C.java\"),\n-                          \"package pkg;\" +\n-                          \"import dep.Dep;\" +\n-                          \"public class C { Dep dep; public void m() { new Dep().m1(); } }\");\n-        rc = compile(\"-d\", classes, \"--state-dir=\" + classes, src, \"-cp\", classesDep);\n-        check(rc == 0, \"Compilation failed unexpectedly\");\n-        FileTime modTime1 = Files.getLastModifiedTime(classes.resolve(\"pkg\/C.class\"));\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        headline(\"Update dependency (without changing the public api)\");\n-        Thread.sleep(2000);\n-        depCode = depCode.replaceAll(\"}$\", \"private void m2() {} }\");\n-        toolbox.writeFile(srcDep.resolve(\"dep\/Dep.java\"), depCode);\n-        rc = compile(\"-d\", classesDep, \"--state-dir=\" + classesDep, srcDep);\n-        check(rc == 0, \"Compilation failed unexpectedly\");\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        headline(\"Make sure that this does not trigger recompilation of C.java\");\n-        rc = compile(\"-d\", classes, \"--state-dir=\" + classes, src, \"-cp\", classesDep);\n-        check(rc == 0, \"Compilation failed unexpectedly\");\n-        FileTime modTime2 = Files.getLastModifiedTime(classes.resolve(\"pkg\/C.class\"));\n-        check(modTime1.equals(modTime2), \"Recompilation erroneously triggered\");\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        headline(\"Update public API of dependency\");\n-        Thread.sleep(2000);\n-        depCode = depCode.replace(\"m1()\", \"m1(String... arg)\");\n-        toolbox.writeFile(srcDep.resolve(\"dep\/Dep.java\"), depCode);\n-        rc = compile(\"-d\", classesDep, \"--state-dir=\" + classesDep, srcDep);\n-        check(rc == 0, \"Compilation failed unexpectedly\");\n-\n-        \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-        headline(\"Make sure that recompilation of C.java is triggered\");\n-        rc = compile(\"-d\", classes, \"--state-dir=\" + classes, src, \"-cp\", classesDep);\n-        check(rc == 0, \"Compilation failed unexpectedly\");\n-        FileTime modTime3 = Files.getLastModifiedTime(classes.resolve(\"pkg\/C.class\"));\n-        check(modTime2.compareTo(modTime3) < 0, \"Recompilation not triggered\");\n-    }\n-\n-    static void headline(String str) {\n-        System.out.println();\n-        System.out.println(str);\n-        System.out.println(str.replaceAll(\".\", \"-\"));\n-    }\n-\n-    static void delete(Path root) throws IOException {\n-        if (!Files.exists(root))\n-            return;\n-        Files.walkFileTree(root, new SimpleFileVisitor<Path>() {\n-                 @Override\n-                 public FileVisitResult visitFile(Path f, BasicFileAttributes a)\n-                         throws IOException {\n-                     Files.delete(f);\n-                     return FileVisitResult.CONTINUE;\n-                 }\n-\n-                 @Override\n-                 public FileVisitResult postVisitDirectory(Path dir, IOException e)\n-                         throws IOException {\n-                     if (e != null)\n-                         throw e;\n-                     if (!dir.equals(root))\n-                         Files.delete(dir);\n-                     return FileVisitResult.CONTINUE;\n-                 }\n-            });\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/ClasspathDependencies.java","additions":0,"deletions":137,"binary":false,"changes":137,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify that circular sources split on multiple cores can be compiled\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper CompileCircularSources\n- *\/\n-\n-import java.io.IOException;\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class CompileCircularSources extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        CompileCircularSources ccs = new CompileCircularSources();\n-        ccs.test();\n-    }\n-\n-    void test() throws Exception {\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(GENSRC);\n-\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A { beta.B b; }\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { gamma.C c; }\");\n-        tb.writeFile(GENSRC.resolve(\"gamma\/C.java\"),\n-                     \"package gamma; public class C { alfa.omega.A a; }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"-h\", HEADERS.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-j\", \"3\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state,\n-                                     new_bin_state,\n-                                     BIN + \"\/alfa\/omega\/A.class\",\n-                                     BIN + \"\/beta\/B.class\",\n-                                     BIN + \"\/gamma\/C.class\",\n-                                     BIN + \"\/javac_state\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/CompileCircularSources.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,68 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Tests compiling class A that depends on class B without compiling class B\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper CompileExcludingDependency\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class CompileExcludingDependency extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        CompileExcludingDependency ced = new CompileExcludingDependency();\n-        ced.test();\n-    }\n-\n-    \/\/ Verify that excluding classes from compilation but not from linking works\n-    void test() throws Exception {\n-        Files.createDirectories(BIN);\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A { beta.B b; }\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { }\");\n-\n-        compile(\"-x\", \"beta\/*\",\n-                \"-src\", GENSRC.toString(),\n-                \"-x\", \"alfa\/omega\/*\",\n-                \"-sourcepath\", GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN);\n-\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state, new_bin_state,\n-                                     BIN + \"\/alfa\/omega\/A.class\",\n-                                     BIN + \"\/javac_state\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/CompileExcludingDependency.java","additions":0,"deletions":68,"binary":false,"changes":68,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test \\@atfile with command line content\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper CompileWithAtFile\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class CompileWithAtFile extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        CompileWithAtFile cwf = new CompileWithAtFile();\n-        cwf.test();\n-    }\n-\n-    void test() throws Exception {\n-        tb.writeFile(GENSRC.resolve(\"list.txt\"),\n-                     \"-i alfa\/omega\/A.java\\n\" +\n-                     \"-i beta\/B.java\\n\" +\n-                     GENSRC + \"\\n\" +\n-                     \"-d \" + BIN + \"\\n\" +\n-                     \"--state-dir=\" + BIN + \"\\n\");\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; import beta.B; public class A { B b; }\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { }\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/C.java\"),\n-                     \"broken\");\n-\n-        Files.createDirectory(BIN);\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-\n-        compile(\"@\" + GENSRC + \"\/list.txt\");\n-\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state, new_bin_state,\n-                         BIN + \"\/javac_state\",\n-                         BIN + \"\/alfa\/omega\/A.class\",\n-                         BIN + \"\/beta\/B.class\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/CompileWithAtFile.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify that we can make sources invisible to linking (sourcepath)\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper CompileWithInvisibleSources\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class CompileWithInvisibleSources extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        CompileWithInvisibleSources cis = new CompileWithInvisibleSources();\n-        cis.test();\n-    }\n-\n-    \/\/ Compile gensrc and link against gensrc2 and gensrc3\n-    \/\/ gensrc2 contains broken code in beta.B, thus exclude that package\n-    \/\/ gensrc3 contains a proper beta.B\n-    void test() throws Exception {\n-        Files.createDirectories(BIN);\n-\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; import beta.B; import gamma.C; public class A { B b; C c; }\");\n-        tb.writeFile(GENSRC2.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { broken\");\n-        tb.writeFile(GENSRC2.resolve(\"gamma\/C.java\"),\n-                     \"package gamma; public class C { }\");\n-        tb.writeFile(GENSRC3.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-x\", \"beta\/*\",\n-                \"-sourcepath\", GENSRC2.toString(),\n-                \"-sourcepath\", GENSRC3.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\");\n-\n-        System.out.println(\"The first compile went well!\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state, new_bin_state,\n-                                     BIN + \"\/alfa\/omega\/A.class\",\n-                                     BIN + \"\/javac_state\");\n-\n-        System.out.println(\"----- Compile with exluded beta went well!\");\n-        tb.cleanDirectory(BIN);\n-        compileExpectFailure(GENSRC.toString(),\n-                             \"-sourcepath\", GENSRC2.toString(),\n-                             \"-sourcepath\", GENSRC3.toString(),\n-                             \"-d\", BIN.toString(),\n-                             \"--state-dir=\" + BIN,\n-                             \"-h\", HEADERS.toString(),\n-                             \"-j\", \"1\");\n-\n-        System.out.println(\"----- Compile without exluded beta failed, as expected! Good!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/CompileWithInvisibleSources.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary verify that we can override sources to be compiled\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper CompileWithOverrideSources\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class CompileWithOverrideSources extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        CompileWithOverrideSources cos = new CompileWithOverrideSources();\n-        cos.test();\n-    }\n-\n-    \/\/ Compile gensrc and gensrc2. However do not compile broken beta.B in gensrc,\n-    \/\/ only compile ok beta.B in gensrc2\n-    void test() throws Exception {\n-        Files.createDirectories(BIN);\n-\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; import beta.B; import gamma.C; public class A { B b; C c; }\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { broken\");\n-        tb.writeFile(GENSRC.resolve(\"gamma\/C.java\"),\n-                     \"package gamma; public class C { }\");\n-\n-        tb.writeFile(GENSRC2.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { }\");\n-\n-        compile(\"-x\", \"beta\/*\",\n-                GENSRC.toString(),\n-                GENSRC2.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state, new_bin_state,\n-                                     BIN + \"\/alfa\/omega\/A.class\",\n-                                     BIN + \"\/beta\/B.class\",\n-                                     BIN + \"\/gamma\/C.class\",\n-                                     BIN + \"\/javac_state\");\n-\n-        System.out.println(\"----- Compile with exluded beta went well!\");\n-        tb.cleanDirectory(BIN);\n-        compileExpectFailure(GENSRC.toString(),\n-                             GENSRC2.toString(),\n-                             \"-d\", BIN.toString(),\n-                             \"--state-dir=\" + BIN,\n-                             \"-h\", HEADERS.toString(),\n-                             \"-j\", \"1\");\n-\n-        System.out.println(\"----- Compile without exluded beta failed, as expected! Good!\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/CompileWithOverrideSources.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8144226\n- * @summary Ensures that excluded files are inaccessible (even for implicit\n- *          compilation)\n- * @modules jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- *          jdk.compiler\/com.sun.tools.sjavac.server\n- * @library \/tools\/lib\n- * @build Wrapper toolbox.ToolBox toolbox.Assert\n- * @run main Wrapper HiddenFiles\n- *\/\n-\n-\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-\n-import toolbox.Assert;\n-\n-public class HiddenFiles extends SjavacBase {\n-\n-    public static void main(String[] ignore) throws Exception {\n-        Path BIN = Paths.get(\"bin\");\n-        Path STATE_DIR = Paths.get(\"state-dir\");\n-        Path SRC = Paths.get(\"src\");\n-\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(STATE_DIR);\n-\n-        toolbox.writeJavaFiles(SRC, \"package pkg; class A { B b; }\");\n-        toolbox.writeJavaFiles(SRC, \"package pkg; class B { }\");\n-\n-        \/\/ This compilation should fail (return RC_FATAL) since A.java refers to B.java and B.java\n-        \/\/ is excluded.\n-        int rc = compile(\"-x\", \"pkg\/B.java\", SRC.toString(),\n-                         \"-d\", BIN.toString(),\n-                         \"--state-dir=\" + STATE_DIR);\n-\n-        Assert.check(rc == Result.ERROR.exitCode, \"Compilation succeeded unexpectedly.\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/HiddenFiles.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8044131\n- * @summary Tests the hooks used for detecting idleness of the sjavac server.\n- * @modules jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac.server\n- * @build Wrapper\n- * @run main Wrapper IdleShutdown\n- *\/\n-\n-import java.util.concurrent.atomic.AtomicLong;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.server.IdleResetSjavac;\n-import com.sun.tools.sjavac.server.Sjavac;\n-import com.sun.tools.sjavac.server.Terminable;\n-\n-\n-public class IdleShutdown {\n-\n-    final static long TEST_START = System.currentTimeMillis();\n-    final static long TIMEOUT_MS = 3000;\n-\n-    public static void main(String[] args) throws InterruptedException {\n-\n-        final AtomicLong timeoutTimestamp = new AtomicLong(-1);\n-\n-        log(\"Starting IdleCallbackJavacService with timeout: \" + TIMEOUT_MS);\n-        Sjavac service = new IdleResetSjavac(\n-                new NoopJavacService(),\n-                new Terminable() {\n-                    public void shutdown(String msg) {\n-                        \/\/ Record the idle timeout time\n-                        log(\"Timeout detected\");\n-                        timeoutTimestamp.set(System.currentTimeMillis());\n-                    }\n-                },\n-                TIMEOUT_MS);\n-\n-        \/\/ Make sure it didn't timeout immediately\n-        if (timeoutTimestamp.get() != -1)\n-            throw new AssertionError(\"Premature timeout detected.\");\n-\n-        \/\/ Use Sjavac object and wait less than TIMEOUT_MS in between calls\n-        Thread.sleep(TIMEOUT_MS - 1000);\n-        log(\"Compiling\");\n-        service.compile(new String[0]);\n-\n-        Thread.sleep(TIMEOUT_MS - 1000);\n-        log(\"Compiling\");\n-        service.compile(new String[0]);\n-\n-        if (timeoutTimestamp.get() != -1)\n-            throw new AssertionError(\"Premature timeout detected.\");\n-\n-        long expectedTimeout = System.currentTimeMillis() + TIMEOUT_MS;\n-\n-        \/\/ Wait for actual timeout\n-        log(\"Awaiting idle timeout\");\n-        Thread.sleep(TIMEOUT_MS + 1000);\n-\n-        \/\/ Check result\n-        if (timeoutTimestamp.get() == -1)\n-            throw new AssertionError(\"Timeout never occurred\");\n-\n-        long error = Math.abs(expectedTimeout - timeoutTimestamp.get());\n-        log(\"Timeout error: \" + error + \" ms\");\n-        String timeoutFactorText = System.getProperty(\"test.timeout.factor\", \"1.0\");\n-        double timeoutFactor = Double.parseDouble(timeoutFactorText);\n-        double allowedError = TIMEOUT_MS * 0.1 * timeoutFactor;\n-        if (error > allowedError) {\n-            throw new AssertionError(\"Timeout error too large, error is \" + error +\n-                                     \" milliseconds, we allowed \" + allowedError + \" milliseconds\");\n-        }\n-        log(\"Shutting down\");\n-        service.shutdown();\n-    }\n-\n-    private static void log(String msg) {\n-        long logTime = System.currentTimeMillis() - TEST_START;\n-        System.out.printf(\"After %5d ms: %s%n\", logTime, msg);\n-    }\n-\n-    private static class NoopJavacService implements Sjavac {\n-        @Override\n-        public void shutdown() {\n-        }\n-        @Override\n-        public Result compile(String[] args) {\n-            \/\/ Attempt to trigger idle timeout during a call by sleeping\n-            try {\n-                Thread.sleep(TIMEOUT_MS + 1000);\n-            } catch (InterruptedException e) {\n-            }\n-            return Result.OK;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IdleShutdown.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8047183\n- * @summary JDK build fails with sjavac enabled\n- * @modules jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper\n- * @run main Wrapper IgnoreSymbolFile\n- *\/\n-\n-import java.io.File;\n-import java.io.FileWriter;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n-\n-public class IgnoreSymbolFile {\n-    public static void main(String... args) throws Exception {\n-        IgnoreSymbolFile test = new IgnoreSymbolFile();\n-        test.run();\n-    }\n-\n-    void run() throws Exception {\n-        String body =\n-                \"package p;\\n\"\n-                + \"import sun.reflect.annotation.*;\\n\"\n-                + \"class X {\\n\"\n-                + \"    ExceptionProxy proxy;\"\n-                + \"}\";\n-        writeFile(\"src\/p\/X.java\", body);\n-\n-        new File(\"classes\").mkdirs();\n-\n-        int rc1 = compile(\"-d\", \"classes\",\n-                          \"--state-dir=classes\",\n-                          \"-Werror\",\n-                          \"src\");\n-        if (rc1 == 0)\n-            error(\"compilation succeeded unexpectedly\");\n-\n-        int rc2 = compile(\"-d\", \"classes\",\n-                          \"--state-dir=classes\",\n-                          \"-Werror\",\n-                          \"-XDignore.symbol.file=true\",\n-                          \"src\");\n-        if (rc2 != 0)\n-            error(\"compilation failed unexpectedly: rc=\" + rc2);\n-\n-        if (errors > 0)\n-            throw new Exception(errors + \" errors occurred\");\n-    }\n-\n-    int compile(String... args) throws ReflectiveOperationException {\n-        \/\/ Use reflection to avoid a compile-time dependency on sjavac Main\n-        System.err.println(\"compile: \" + Arrays.toString(args));\n-        Class<?> c = Class.forName(\"com.sun.tools.sjavac.Main\");\n-        Method m = c.getDeclaredMethod(\"go\", String[].class);\n-        int rc = (Integer) m.invoke(null, (Object) args);\n-        System.err.println(\"rc=\" + rc);\n-        return rc;\n-    }\n-\n-    void writeFile(String path, String body) throws IOException {\n-        File f = new File(path);\n-        if (f.getParentFile() != null)\n-            f.getParentFile().mkdirs();\n-        try (FileWriter w = new FileWriter(f)) {\n-            w.write(body);\n-        }\n-    }\n-\n-    void error(String msg) {\n-        System.err.println(\"Error: \" + msg);\n-        errors++;\n-    }\n-\n-    int errors;\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IgnoreSymbolFile.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,71 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8056258\n- * @summary Analysis of public API does not take super classes into account\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompInheritance\n- *\/\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-public class IncCompInheritance extends SjavacBase {\n-    public static void main(String... args) throws Exception {\n-\n-        Path root = Paths.get(IncCompInheritance.class.getSimpleName() + \"Test\");\n-        Path src = root.resolve(\"src\");\n-        Path classes = root.resolve(\"classes\");\n-\n-        \/\/ Prep source files: A <- B <- C\n-        String a = \"package pkga; public class A { public void m() {} }\";\n-        String b = \"package pkgb; public class B extends pkga.A {}\";\n-        String c = \"package pkgc; public class C extends pkgb.B {{ new pkgb.B().m(); }}\";\n-        toolbox.writeFile(src.resolve(\"pkga\/A.java\"), a);\n-        toolbox.writeFile(src.resolve(\"pkgb\/B.java\"), b);\n-        toolbox.writeFile(src.resolve(\"pkgc\/C.java\"), c);\n-\n-        \/\/ Initial compile (should succeed)\n-        int rc1 = compile(\"-d\", classes, \"--state-dir=\" + classes, src);\n-        if (rc1 != 0)\n-            throw new AssertionError(\"Compilation failed unexpectedly\");\n-\n-        \/\/ Remove method A.m\n-        Thread.sleep(2500); \/\/ Make sure we get a new timestamp\n-        String aModified = \"package pkga; public class A { }\";\n-        toolbox.writeFile(src.resolve(\"pkga\/A.java\"), aModified);\n-\n-        \/\/ Incremental compile (C should now be recompiled even though it\n-        \/\/ depends on A only through inheritance via B).\n-        \/\/ Since A.m is removed, this should fail.\n-        int rc2 = compile(\"-d\", classes, \"--state-dir=\" + classes, src);\n-        if (rc2 == 0)\n-            throw new AssertionError(\"Compilation succeeded unexpectedly\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompInheritance.java","additions":0,"deletions":71,"binary":false,"changes":71,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify native files are removed when native method is removed\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompileChangeNative\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class IncCompileChangeNative extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        IncCompileChangeNative cn = new IncCompileChangeNative();\n-        cn.test();\n-    }\n-\n-    \/\/ Remember the previous bin and headers state here.\n-    Map<String,Long> previous_bin_state;\n-    Map<String,Long> previous_headers_state;\n-\n-    void test() throws Exception {\n-        Files.createDirectories(GENSRC);\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(HEADERS);\n-\n-        initialCompile();\n-        incrementalCompileDropAllNatives();\n-        incrementalCompileAddNative();\n-    }\n-\n-    \/\/ Update B.java with one less native method i.e. it has no longer any methods\n-    \/\/ Verify that beta_B.h is removed\n-    void incrementalCompileDropAllNatives() throws Exception {\n-        previous_bin_state = collectState(BIN);\n-        previous_headers_state = collectState(HEADERS);\n-        System.out.println(\"\\nIn incrementalCompileDropAllNatives() \");\n-        System.out.println(\"Verify that beta_B.h is removed\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; import alfa.omega.A; \" +\n-                     \"public class B { private int b() { return A.DEFINITION; } }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyNewerFiles(previous_bin_state, new_bin_state,\n-                         BIN + \"\/beta\/B.class\",\n-                         BIN + \"\/beta\/BINT.class\",\n-                         BIN + \"\/javac_state\");\n-        previous_bin_state = new_bin_state;\n-\n-        Map<String,Long> new_headers_state = collectState(HEADERS);\n-        verifyThatFilesHaveBeenRemoved(previous_headers_state, new_headers_state,\n-                                       HEADERS + \"\/beta_B.h\");\n-        previous_headers_state = new_headers_state;\n-    }\n-\n-    \/\/ Update the B.java with a final static annotated with @Native\n-    \/\/ Verify that beta_B.h is added again\n-    void incrementalCompileAddNative() throws Exception {\n-        System.out.println(\"\\nIn incrementalCompileAddNative() \");\n-        System.out.println(\"Verify that beta_B.h is added again\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; import alfa.omega.A; public class B {\"+\n-                     \"private int b() { return A.DEFINITION; } \"+\n-                     \"@java.lang.annotation.Native final static int alfa = 42; }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyNewerFiles(previous_bin_state, new_bin_state,\n-                         BIN + \"\/beta\/B.class\",\n-                         BIN + \"\/beta\/BINT.class\",\n-                         BIN + \"\/javac_state\");\n-        previous_bin_state = new_bin_state;\n-\n-        Map<String,Long> new_headers_state = collectState(HEADERS);\n-        verifyThatFilesHaveBeenAdded(previous_headers_state, new_headers_state,\n-                                     HEADERS + \"\/beta_B.h\");\n-        previous_headers_state = new_headers_state;\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompileChangeNative.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify deletion of a source file results in dropping of all .class files including inner classes\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompileDropClasses\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class IncCompileDropClasses extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        IncCompileDropClasses dc = new IncCompileDropClasses();\n-        dc.test();\n-    }\n-\n-    \/\/ Remember the previous bin and headers state here.\n-    Map<String,Long> previous_bin_state;\n-    Map<String,Long> previous_headers_state;\n-\n-    void test() throws Exception {\n-        Files.createDirectories(GENSRC);\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(HEADERS);\n-\n-        initialCompile();\n-        incrementalCompileDroppingClasses();\n-    }\n-\n-    \/\/ Testing that deleting AA.java deletes all generated inner class including AA.class\n-    void incrementalCompileDroppingClasses() throws Exception {\n-        previous_bin_state = collectState(BIN);\n-        previous_headers_state = collectState(HEADERS);\n-        System.out.println(\"\\nIn incrementalCompileDroppingClasses() \");\n-        System.out.println(\"Testing that deleting AA.java deletes all generated inner class including AA.class\");\n-        removeFrom(GENSRC, \"alfa\/omega\/AA.java\");\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenRemoved(previous_bin_state, new_bin_state,\n-                                       BIN + \"\/alfa\/omega\/AA$1.class\",\n-                                       BIN + \"\/alfa\/omega\/AA$AAAA.class\",\n-                                       BIN + \"\/alfa\/omega\/AA$AAA.class\",\n-                                       BIN + \"\/alfa\/omega\/AAAAA.class\",\n-                                       BIN + \"\/alfa\/omega\/AA.class\");\n-\n-        previous_bin_state = new_bin_state;\n-        Map<String,Long> new_headers_state = collectState(HEADERS);\n-        verifyEqual(previous_headers_state, new_headers_state);\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompileDropClasses.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify that \"alfa.omega.A a\" does create a proper dependency\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @ignore Requires dependency code to deal with in-method dependencies.\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompileFullyQualifiedRef\n- *\/\n-\n-import java.util.Map;\n-\n-import toolbox.ToolBox;\n-\n-public class IncCompileFullyQualifiedRef extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        IncCompileFullyQualifiedRef fr = new IncCompileFullyQualifiedRef();\n-        fr.test();\n-    }\n-\n-    void test() throws Exception {\n-        clean(TEST_ROOT);\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A { \"+\n-                     \"  public final static int DEFINITION = 18; \"+\n-                     \"  public void hello() { }\"+\n-                     \"}\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; public class B { \"+\n-                     \"  public void world() { alfa.omega.A a; }\"+\n-                     \"}\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-\n-        \/\/ Change pubapi of A, this should trigger a recompile of B.\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A { \"+\n-                     \"  public final static int DEFINITION = 19; \"+\n-                     \"  public void hello() { }\"+\n-                     \"}\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-\n-        verifyNewerFiles(previous_bin_state, new_bin_state,\n-                         BIN + \"\/alfa\/omega\/A.class\",\n-                         BIN + \"\/beta\/B.class\",\n-                         BIN + \"\/javac_state\");\n-        clean(GENSRC,BIN);\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompileFullyQualifiedRef.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -1,77 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify no change in sources implies no change in binaries\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompileNoChanges\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class IncCompileNoChanges  extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        IncCompileNoChanges nc = new IncCompileNoChanges();\n-        nc.test();\n-    }\n-\n-    \/\/ Remember the previous bin and headers state here.\n-    Map<String,Long> previous_bin_state;\n-    Map<String,Long> previous_headers_state;\n-\n-    void test() throws Exception {\n-        Files.createDirectories(GENSRC);\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(HEADERS);\n-\n-        initialCompile();\n-        incrementalCompileNoChanges();\n-    }\n-\n-    \/\/ Testing that no change in sources implies no change in binaries\n-    void incrementalCompileNoChanges() throws Exception {\n-        previous_bin_state = collectState(BIN);\n-        previous_headers_state = collectState(HEADERS);\n-        System.out.println(\"\\nIn incrementalCompileNoChanges() \");\n-        System.out.println(\"Testing that no change in sources implies no change in binaries\");\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyEqual(new_bin_state, previous_bin_state);\n-        Map<String,Long> new_headers_state = collectState(HEADERS);\n-        verifyEqual(previous_headers_state, new_headers_state);\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompileNoChanges.java","additions":0,"deletions":77,"binary":false,"changes":77,"status":"deleted"},{"patch":"@@ -1,90 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify native files are rewritten\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompileUpdateNative\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class IncCompileUpdateNative extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        IncCompileUpdateNative un = new IncCompileUpdateNative();\n-        un.test();\n-    }\n-\n-    \/\/ Remember the previous bin and headers state here.\n-    Map<String,Long> previous_bin_state;\n-    Map<String,Long> previous_headers_state;\n-\n-    void test() throws Exception {\n-        Files.createDirectories(GENSRC);\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(HEADERS);\n-\n-        initialCompile();\n-        incrementalCompileChangeNative();\n-    }\n-\n-    \/\/ Update B.java with a new value for the final static annotated with @Native\n-    \/\/ Verify that beta_B.h is rewritten again\n-    void incrementalCompileChangeNative() throws Exception {\n-        previous_bin_state = collectState(BIN);\n-        previous_headers_state = collectState(HEADERS);\n-        System.out.println(\"\\nIn incrementalCompileChangeNative() \");\n-        System.out.println(\"Verify that beta_B.h is rewritten again\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; import alfa.omega.A; public class B {\"+\n-                     \"private int b() { return A.DEFINITION; } \"+\n-                      \"@java.lang.annotation.Native final static int alfa = 43; }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyNewerFiles(previous_bin_state, new_bin_state,\n-                         BIN + \"\/beta\/B.class\",\n-                         BIN + \"\/beta\/BINT.class\",\n-                         BIN + \"\/javac_state\");\n-        previous_bin_state = new_bin_state;\n-\n-        Map<String,Long> new_headers_state = collectState(HEADERS);\n-        verifyNewerFiles(previous_headers_state, new_headers_state,\n-                         HEADERS + \"\/beta_B.h\");\n-        previous_headers_state = new_headers_state;\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompileUpdateNative.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"deleted"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify incremental changes in gensrc are handled as expected\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @ignore Requires dependency code to deal with in-method dependencies.\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper IncCompileWithChanges\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-import toolbox.ToolBox;\n-\n-public class IncCompileWithChanges extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        IncCompileWithChanges wc = new IncCompileWithChanges();\n-        wc.test();\n-    }\n-\n-    \/\/ Remember the previous bin and headers state here.\n-    Map<String,Long> previous_bin_state;\n-    Map<String,Long> previous_headers_state;\n-\n-    void test() throws Exception {\n-        clean(TEST_ROOT);\n-        Files.createDirectories(GENSRC);\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(HEADERS);\n-\n-        initialCompile();\n-        incrementalCompileWithChange();\n-    }\n-\n-    \/* Update A.java with a new timestamp and new final static definition.\n-     * This should trigger a recompile, not only of alfa, but also beta.\n-     * Generated native header should not be updated since native api of B was not modified.\n-     *\/\n-    void incrementalCompileWithChange() throws Exception {\n-        previous_bin_state = collectState(BIN);\n-        previous_headers_state = collectState(HEADERS);\n-        System.out.println(\"\\nIn incrementalCompileWithChange() \");\n-        System.out.println(\"A.java updated to trigger a recompile\");\n-        System.out.println(\"Generated native header should not be updated since native api of B was not modified\");\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A implements AINT { \" +\n-                     \"public final static int DEFINITION = 18;\" +\n-                     \"public void aint() { } private void foo() { } }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-\n-        verifyNewerFiles(previous_bin_state, new_bin_state,\n-                         BIN + \"\/alfa\/omega\/A.class\",\n-                         BIN + \"\/alfa\/omega\/AINT.class\",\n-                         BIN + \"\/alfa\/omega\/AA$AAAA.class\",\n-                         BIN + \"\/alfa\/omega\/AAAAA.class\",\n-                         BIN + \"\/alfa\/omega\/AA$AAA.class\",\n-                         BIN + \"\/alfa\/omega\/AA.class\",\n-                         BIN + \"\/alfa\/omega\/AA$1.class\",\n-                         BIN + \"\/beta\/B.class\",\n-                         BIN + \"\/beta\/BINT.class\",\n-                         BIN + \"\/javac_state\");\n-        previous_bin_state = new_bin_state;\n-\n-        Map<String,Long> new_headers_state = collectState(HEADERS);\n-        verifyEqual(new_headers_state, previous_headers_state);\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncCompileWithChanges.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -1,169 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8037085\n- * @summary Ensures that sjavac can handle various exclusion patterns.\n- *\n- * @modules jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- *          jdk.compiler\/com.sun.tools.sjavac.server\n- * @library \/tools\/lib\n- * @build Wrapper toolbox.ToolBox toolbox.Assert\n- * @run main Wrapper IncludeExcludePatterns\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-\n-import toolbox.Assert;\n-\n-public class IncludeExcludePatterns extends SjavacBase {\n-\n-    final Path SRC = Paths.get(\"src\");\n-    final Path BIN = Paths.get(\"bin\");\n-    final Path STATE_DIR = Paths.get(\"state-dir\");\n-\n-    \/\/ An arbitrarily but sufficiently complicated source tree.\n-    final Path A = Paths.get(\"pkga\/A.java\");\n-    final Path X1 = Paths.get(\"pkga\/subpkg\/Xx.java\");\n-    final Path Y = Paths.get(\"pkga\/subpkg\/subsubpkg\/Y.java\");\n-    final Path B = Paths.get(\"pkgb\/B.java\");\n-    final Path C = Paths.get(\"pkgc\/C.java\");\n-    final Path X2 = Paths.get(\"pkgc\/Xx.java\");\n-\n-    final Path[] ALL_PATHS = {A, X1, Y, B, C, X2};\n-\n-    public static void main(String[] ignore) throws Exception {\n-        new IncludeExcludePatterns().runTest();\n-    }\n-\n-    public void runTest() throws IOException, ReflectiveOperationException {\n-        Files.createDirectories(BIN);\n-        Files.createDirectories(STATE_DIR);\n-        for (Path p : ALL_PATHS) {\n-            writeDummyClass(p);\n-        }\n-\n-        \/\/ Single file\n-        testPattern(\"pkga\/A.java\", A);\n-\n-        \/\/ Leading wild cards\n-        testPattern(\"*\/A.java\", A);\n-        testPattern(\"**\/Xx.java\", X1, X2);\n-        testPattern(\"**x.java\", X1, X2);\n-\n-        \/\/ Wild card in middle of path\n-        testPattern(\"pkga\/*\/Xx.java\", X1);\n-        testPattern(\"pkga\/**\/Y.java\", Y);\n-\n-        \/\/ Trailing wild cards\n-        testPattern(\"pkga\/*\", A);\n-        testPattern(\"pkga\/**\", A, X1, Y);\n-\n-        \/\/ Multiple wildcards\n-        testPattern(\"pkga\/*\/*\/Y.java\", Y);\n-        testPattern(\"**\/*\/**\", X1, Y);\n-\n-    }\n-\n-    \/\/ Given \"src\/pkg\/subpkg\/A.java\" this method returns \"A\"\n-    String classNameOf(Path javaFile) {\n-        return javaFile.getFileName()\n-                       .toString()\n-                       .replace(\".java\", \"\");\n-    }\n-\n-    \/\/ Puts an empty (dummy) class definition in the given path.\n-    void writeDummyClass(Path javaFile) throws IOException {\n-        String pkg = javaFile.getParent().toString().replace(File.separatorChar, '.');\n-        String cls = javaFile.getFileName().toString().replace(\".java\", \"\");\n-        toolbox.writeFile(SRC.resolve(javaFile), \"package \" + pkg + \"; class \" + cls + \" {}\");\n-    }\n-\n-    void testPattern(String filterArgs, Path... sourcesExpectedToBeVisible)\n-            throws ReflectiveOperationException, IOException {\n-        testFilter(\"-i \" + filterArgs, Arrays.asList(sourcesExpectedToBeVisible));\n-\n-        Set<Path> complement = new HashSet<>(Arrays.asList(ALL_PATHS));\n-        complement.removeAll(Arrays.asList(sourcesExpectedToBeVisible));\n-        testFilter(\"-x \" + filterArgs, complement);\n-    }\n-\n-    void testFilter(String filterArgs, Collection<Path> sourcesExpectedToBeVisible)\n-            throws IOException, ReflectiveOperationException {\n-        System.out.println(\"Testing filter: \" + filterArgs);\n-        toolbox.cleanDirectory(BIN);\n-        toolbox.cleanDirectory(STATE_DIR);\n-        String args = filterArgs + \" \" + SRC\n-                + \" -d \" + BIN\n-                + \" --state-dir=\" + STATE_DIR;\n-        int rc = compile((Object[]) args.split(\" \"));\n-\n-        \/\/ Compilation should always pass in these tests\n-        Assert.check(rc == Result.OK.exitCode, \"Compilation failed unexpectedly.\");\n-\n-        \/\/ The resulting .class files should correspond to the visible source files\n-        Set<Path> result = allFilesInDir(BIN);\n-        Set<Path> expected = correspondingClassFiles(sourcesExpectedToBeVisible);\n-        if (!result.equals(expected)) {\n-            System.out.println(\"Result:\");\n-            printPaths(result);\n-            System.out.println(\"Expected:\");\n-            printPaths(expected);\n-            Assert.error(\"Test case failed: \" + filterArgs);\n-        }\n-    }\n-\n-    void printPaths(Collection<Path> paths) {\n-        paths.stream()\n-             .sorted()\n-             .forEachOrdered(p -> System.out.println(\"    \" + p));\n-    }\n-\n-    \/\/ Given \"pkg\/A.java, pkg\/B.java\" this method returns \"bin\/pkg\/A.class, bin\/pkg\/B.class\"\n-    Set<Path> correspondingClassFiles(Collection<Path> javaFiles) {\n-        return javaFiles.stream()\n-                        .map(javaFile -> javaFile.resolveSibling(classNameOf(javaFile) + \".class\"))\n-                        .map(BIN::resolve)\n-                        .collect(Collectors.toSet());\n-    }\n-\n-    Set<Path> allFilesInDir(Path p) throws IOException {\n-        try (Stream<Path> files = Files.walk(p).filter(Files::isRegularFile)) {\n-            return files.collect(Collectors.toSet());\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/IncludeExcludePatterns.java","additions":0,"deletions":169,"binary":false,"changes":169,"status":"deleted"},{"patch":"@@ -1,179 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8035063\n- * @summary Tests the preparation of javac-arguments.\n- *\n- * @modules jdk.compiler\/com.sun.tools.sjavac.options\n- * @build Wrapper\n- * @run main Wrapper JavacOptionPrep\n- *\/\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Paths;\n-import java.util.Arrays;\n-import java.util.Iterator;\n-\n-import com.sun.tools.sjavac.options.Options;\n-\n-\n-public class JavacOptionPrep {\n-\n-    enum TestPath {\n-        CP1, CP2, SRC1, SRC2, SOURCEPATH1, SOURCEPATH2;\n-\n-        public String toString() {\n-            return name().toLowerCase();\n-        }\n-    }\n-\n-    private final static String SEP = File.pathSeparator;\n-\n-    public static void main(String[] unused) throws IOException {\n-\n-        for (TestPath p : TestPath.values())\n-            Files.createDirectory(Paths.get(p.toString()));\n-\n-        \/\/ Test some various cases:\n-        \/\/  - Paths combined with File.pathSeparator (CP1 \/ CP2)\n-        \/\/  - Paths given as duplicate options (SOURCEPATH1 \/ SOURCEPATH2)\n-        \/\/  - Sources provided by -src (SRC1)\n-        \/\/  - Sources provided without preceding option (SRC2)\n-        \/\/  - An unrecognized option which is to be passed on to javac\n-        String sjavacArgs = \"-cp \" + TestPath.CP1 + SEP + TestPath.CP2 +\n-                            \" -d dest\" +\n-                            \" -h header\" +\n-                            \" -sourcepath \" + TestPath.SOURCEPATH1 +\n-                            \" -src \" + TestPath.SRC1 +\n-                            \" -s gensrc\" +\n-                            \" -sourcepath \" + TestPath.SOURCEPATH2 +\n-                            \" \" + TestPath.SRC2 +\n-                            \" -unrecognized\";\n-\n-        Options options = Options.parseArgs(sjavacArgs.split(\" \"));\n-\n-        \/\/ Extract javac-options\n-        String[] javacArgs = options.prepJavacArgs();\n-\n-        \/\/ Check the result\n-        boolean destDirFound = false;\n-        boolean userPathsFirst = false;\n-        boolean headerDirFound = false;\n-        boolean gensrcDirFound = false;\n-        boolean classPathFound = false;\n-        boolean sourcePathFound = false;\n-        boolean unrecognizedFound = false;\n-        boolean implicitNoneFound = false;\n-\n-        Iterator<String> javacArgIter = Arrays.asList(javacArgs).iterator();\n-        while (javacArgIter.hasNext()) {\n-\n-            String option = javacArgIter.next();\n-\n-            \/\/ Ignore this option for now. When the file=... requirement goes\n-            \/\/ away, this will be easier to handle.\n-            if (option.startsWith(\"--debug=completionDeps\"))\n-                continue;\n-\n-            switch (option) {\n-            case \"-classpath\":\n-            case \"-cp\":\n-                classPathFound = true;\n-                assertEquals(TestPath.CP1 + SEP + TestPath.CP2,\n-                             javacArgIter.next());\n-                break;\n-\n-            case \"-d\":\n-                destDirFound = true;\n-                assertEquals(Paths.get(\"dest\").toAbsolutePath().toString(),\n-                             javacArgIter.next());\n-                break;\n-\n-            case \"-h\":\n-                headerDirFound = true;\n-                assertEquals(Paths.get(\"header\").toAbsolutePath().toString(),\n-                             javacArgIter.next());\n-                break;\n-\n-            case \"-s\":\n-                gensrcDirFound = true;\n-                assertEquals(Paths.get(\"gensrc\").toAbsolutePath().toString(),\n-                             javacArgIter.next());\n-                break;\n-\n-            case \"-sourcepath\":\n-                sourcePathFound = true;\n-                assertEquals(TestPath.SRC1 + SEP +\n-                             TestPath.SRC2 + SEP +\n-                             TestPath.SOURCEPATH1 + SEP +\n-                             TestPath.SOURCEPATH2,\n-                             javacArgIter.next());\n-                break;\n-\n-            case \"-unrecognized\":\n-                unrecognizedFound = true;\n-                break;\n-\n-            case \"-implicit:none\":\n-                implicitNoneFound = true;\n-                break;\n-\n-                \/\/ Note that *which* files to actually compile is not dealt\n-                \/\/ with by prepJavacArgs.\n-\n-            default:\n-                throw new AssertionError(\"Unexpected option found: \" + option);\n-            }\n-        }\n-\n-        if (!destDirFound)\n-            throw new AssertionError(\"Dest directory not found.\");\n-\n-        if (!headerDirFound)\n-            throw new AssertionError(\"Header directory not found.\");\n-\n-        if (!gensrcDirFound)\n-            throw new AssertionError(\"Generated source directory not found.\");\n-\n-        if (!classPathFound)\n-            throw new AssertionError(\"Class path not found.\");\n-\n-        if (!sourcePathFound)\n-            throw new AssertionError(\"Source path not found.\");\n-\n-        if (!unrecognizedFound)\n-            throw new AssertionError(\"\\\"-unrecognized\\\" not found.\");\n-\n-        if (!implicitNoneFound)\n-            throw new AssertionError(\"\\\"-implicit:none\\\" not found.\");\n-    }\n-\n-    static void assertEquals(Object expected, Object actual) {\n-        if (!expected.equals(actual))\n-            throw new AssertionError(\"Expected \" + expected + \" but got \" + actual);\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/JavacOptionPrep.java","additions":0,"deletions":179,"binary":false,"changes":179,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test --no-state option\n- * @bug 8135131\n-  * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox toolbox.Assert\n- * @run main Wrapper NoState\n- *\/\n-\n-import java.io.IOException;\n-import java.nio.file.*;\n-import java.util.stream.Stream;\n-\n-import toolbox.Assert;\n-\n-public class NoState extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        new NoState().run();\n-    }\n-\n-    public void run() throws Exception {\n-        tb.writeFile(GENSRC.resolve(\"pkg\/A.java\"), \"package pkg; class A {}\");\n-        Files.createDirectory(BIN);\n-        compile(\"-d\", BIN.toString(),\n-                GENSRC + \"\/pkg\/A.java\");\n-\n-        \/\/ Make sure file was compiled\n-        Assert.check(Files.exists(BIN.resolve(\"pkg\/A.class\")));\n-\n-        \/\/ Make sure we have no other files (such as a javac_state file) in the bin directory\n-        Assert.check(countPathsInDir(BIN) == 1);\n-        Assert.check(countPathsInDir(BIN.resolve(\"pkg\")) == 1);\n-    }\n-\n-    private long countPathsInDir(Path dir) throws IOException {\n-        try (Stream<Path> files = Files.list(dir)) {\n-            return files.count();\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/NoState.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8035063 8054465\n- * @summary Tests decoding of String[] into Options.\n- *\n- * @modules jdk.compiler\/com.sun.tools.sjavac\n- *          jdk.compiler\/com.sun.tools.sjavac.client\n- *          jdk.compiler\/com.sun.tools.sjavac.comp\n- *          jdk.compiler\/com.sun.tools.sjavac.options\n- * @build Wrapper\n- * @run main Wrapper OptionDecoding\n- *\/\n-\n-import static util.OptionTestUtil.assertEquals;\n-import static util.OptionTestUtil.checkFilesFound;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import com.sun.tools.sjavac.CopyFile;\n-import com.sun.tools.sjavac.Module;\n-import com.sun.tools.sjavac.Source;\n-import com.sun.tools.sjavac.client.ClientMain;\n-import com.sun.tools.sjavac.comp.SjavacImpl;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.options.SourceLocation;\n-\n-public class OptionDecoding {\n-\n-    public static void main(String[] args) throws IOException {\n-        testPaths();\n-        testDupPaths();\n-        testSimpleOptions();\n-        testServerConf();\n-        testSearchPaths();\n-        testTranslationRules();\n-    }\n-\n-    \/\/ Test decoding of output paths\n-    static void testPaths() throws IOException {\n-        final String H = \"headers\";\n-        final String G = \"gensrc\";\n-        final String D = \"dest\";\n-        final String stateDir = \"stateDir\";\n-        final String CMP = \"srcRefList.txt\";\n-\n-        Options options = Options.parseArgs(\"-h\", H, \"-s\", G, \"-d\", D, \"--state-dir=\" + stateDir,\n-                                            \"--compare-found-sources\", CMP);\n-\n-        assertEquals(Paths.get(H).toAbsolutePath(), options.getHeaderDir());\n-        assertEquals(Paths.get(G).toAbsolutePath(), options.getGenSrcDir());\n-        assertEquals(Paths.get(D).toAbsolutePath(), options.getDestDir());\n-        assertEquals(Paths.get(stateDir).toAbsolutePath(), options.getStateDir());\n-        assertEquals(Paths.get(CMP), options.getSourceReferenceList());\n-    }\n-\n-    \/\/ Providing duplicate header \/ dest \/ gensrc paths should produce an error.\n-    static void testDupPaths() throws IOException {\n-        try {\n-            Options.parseArgs(\"-h\", \"dir1\", \"-h\", \"dir2\");\n-            throw new RuntimeException(\"Duplicate header directories should fail.\");\n-        } catch (IllegalArgumentException iae) {\n-            \/\/ Expected\n-        }\n-\n-        try {\n-            Options.parseArgs(\"-s\", \"dir1\", \"-s\", \"dir2\");\n-            throw new RuntimeException(\"Duplicate paths for generated sources should fail.\");\n-        } catch (IllegalArgumentException iae) {\n-            \/\/ Expected\n-        }\n-\n-        try {\n-            Options.parseArgs(\"-d\", \"dir1\", \"-d\", \"dir2\");\n-            throw new RuntimeException(\"Duplicate destination directories should fail.\");\n-        } catch (IllegalArgumentException iae) {\n-            \/\/ Expected\n-        }\n-    }\n-\n-    \/\/ Test basic options\n-    static void testSimpleOptions() {\n-        Options options = Options.parseArgs(\"-j\", \"17\", \"--log=debug\");\n-        assertEquals(17, options.getNumCores());\n-        assertEquals(\"debug\", options.getLogLevel());\n-        assertEquals(false, options.isDefaultPackagePermitted());\n-        assertEquals(false, options.areUnidentifiedArtifactsPermitted());\n-        assertEquals(false, options.isUnidentifiedArtifactPermitted(Paths.get(\"bar.txt\").toFile().getAbsolutePath()));\n-\n-        options = Options.parseArgs(\"--permit-unidentified-artifacts\",\n-                                    \"--permit-artifact=bar.txt\",\n-                                    \"--permit-sources-without-package\");\n-        assertEquals(\"info\", options.getLogLevel());\n-        assertEquals(true, options.isDefaultPackagePermitted());\n-        assertEquals(true, options.areUnidentifiedArtifactsPermitted());\n-        assertEquals(true, options.isUnidentifiedArtifactPermitted(Paths.get(\"bar.txt\").toFile().getAbsolutePath()));\n-    }\n-\n-    \/\/ Test server configuration options\n-    static void testServerConf() {\n-        Options options = Options.parseArgs(\"--server:someServerConfiguration\");\n-        assertEquals(\"someServerConfiguration\", options.getServerConf());\n-        assertEquals(false, options.startServerFlag());\n-\n-        options = Options.parseArgs(\"--startserver:someServerConfiguration\");\n-        assertEquals(\"someServerConfiguration\", options.getServerConf());\n-        assertEquals(true, options.startServerFlag());\n-    }\n-\n-    \/\/ Test input paths\n-    static void testSearchPaths() {\n-        List<String> i, x, iF, xF;\n-        i = x = iF = xF = new ArrayList<>();\n-\n-        SourceLocation dir1 = new SourceLocation(Paths.get(\"dir1\"), i, x);\n-        SourceLocation dir2 = new SourceLocation(Paths.get(\"dir2\"), i, x);\n-        String dir1_PS_dir2 = \"dir1\" + File.pathSeparator + \"dir2\";\n-\n-        Options options = Options.parseArgs(\"--source-path\", dir1_PS_dir2);\n-        assertEquals(options.getSourceSearchPaths(), Arrays.asList(dir1, dir2));\n-\n-        options = Options.parseArgs(\"--module-path\", dir1_PS_dir2);\n-        assertEquals(options.getModuleSearchPaths(), Arrays.asList(dir1, dir2));\n-\n-        options = Options.parseArgs(\"--class-path\", dir1_PS_dir2);\n-        assertEquals(options.getClassSearchPath(), Arrays.asList(dir1, dir2));\n-    }\n-\n-    \/\/ Test -tr option\n-    static void testTranslationRules() {\n-        Class<?> cls = com.sun.tools.sjavac.CompileJavaPackages.class;\n-\n-        Options options = Options.parseArgs(\n-                \"-tr\", \".exa=\" + cls.getName(),\n-                \"-tr\", \".exb=\" + cls.getName(),\n-                \"-copy\", \".html\");\n-\n-        assertEquals(cls, options.getTranslationRules().get(\".exa\").getClass());\n-        assertEquals(cls, options.getTranslationRules().get(\".exb\").getClass());\n-        assertEquals(CopyFile.class, options.getTranslationRules().get(\".html\").getClass());\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/OptionDecoding.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -1,101 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Make sure sjavac doesn't allow overlapping source and destination\n- *          directories.\n- * @bug 8061320\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper OverlappingSrcDst\n- *\/\n-\n-import java.io.File;\n-import java.nio.file.Paths;\n-\n-import toolbox.ToolBox;\n-\n-public class OverlappingSrcDst extends SJavacTester {\n-    public static void main(String... args) {\n-        new OverlappingSrcDst().run();\n-    }\n-\n-    public void run() {\n-        String abs = ToolBox.currDir.toAbsolutePath().toString();\n-\n-        \/\/ Relative vs relative\n-        test(\"dir\", \"dir\", false);\n-        test(\"dir\", \"dir\/dst\", false);\n-        test(\"dir\/src\", \"dir\", false);\n-        test(\"src\", \"dst\", true);\n-\n-        \/\/ Absolute vs absolute\n-        test(abs + \"\/dir\", abs + \"\/dir\", false);\n-        test(abs + \"\/dir\", abs + \"\/dir\/dst\", false);\n-        test(abs + \"\/dir\/src\", abs + \"\/dir\", false);\n-        test(abs + \"\/src\", abs + \"\/dst\", true);\n-\n-        \/\/ Absolute vs relative\n-        test(abs + \"\/dir\", \"dir\", false);\n-        test(abs + \"\/dir\", \"dir\/dst\", false);\n-        test(abs + \"\/dir\/src\", \"dir\", false);\n-        test(abs + \"\/src\", \"dst\", true);\n-\n-        \/\/ Relative vs absolute\n-        test(\"dir\", abs + \"\/dir\", false);\n-        test(\"dir\", abs + \"\/dir\/dst\", false);\n-        test(\"dir\/src\", abs + \"\/dir\", false);\n-        test(\"src\", abs + \"\/dst\", true);\n-    }\n-\n-    private void test(String srcDir, String dstDir, boolean shouldSucceed) {\n-        boolean succeeded = testCompilation(srcDir, dstDir);\n-        if (shouldSucceed != succeeded) {\n-            throw new AssertionError(\n-                    String.format(\"Test failed for \"\n-                                          + \"srcDir=\\\"%s\\\", \"\n-                                          + \"dstDir=\\\"%s\\\". \"\n-                                          + \"Compilation was expected to %s but %s.\",\n-                                  srcDir,\n-                                  dstDir,\n-                                  shouldSucceed ? \"succeed\" : \"fail\",\n-                                  succeeded ? \"succeeded\" : \"failed\"));\n-        }\n-    }\n-\n-    private boolean testCompilation(String srcDir, String dstDir) {\n-        try {\n-            srcDir = srcDir.replace('\/', File.separatorChar);\n-            dstDir = dstDir.replace('\/', File.separatorChar);\n-            tb.writeFile(Paths.get(srcDir, \"pkg\", \"A.java\"), \"package pkg; class A {}\");\n-            compile(\"--state-dir=state\", \"-src\", srcDir, \"-d\", dstDir);\n-            return true;\n-        } catch (Exception e) {\n-            return false;\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/OverlappingSrcDst.java","additions":0,"deletions":101,"binary":false,"changes":101,"status":"deleted"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8059349\n- * @summary This test makes sure file paths matches package declarations\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper PackagePathMismatch\n- *\/\n-\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-\n-public class PackagePathMismatch extends SjavacBase {\n-    public static void main(String... args) throws Exception {\n-\n-        Path root = Paths.get(PackagePathMismatch.class.getSimpleName() + \"Test\");\n-        Path src = root.resolve(\"src\");\n-        Path classes = root.resolve(\"classes\");\n-\n-        toolbox.writeFile(src.resolve(\"a\/x\/c\/Test.java\"),\n-                          \"package a.b.c; class Test { }\");\n-\n-        \/\/ Compile should fail since package a.b.c does not match path a\/x\/c.\n-        int rc1 = compile(\"-d\", classes,\n-                          \"--state-dir=\" + classes,\n-                          src);\n-        if (rc1 == 0)\n-            throw new AssertionError(\"Compilation succeeded unexpectedly\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/PackagePathMismatch.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test to check that -j option works with more than one value\n- * @bug 8071629\n- * @author sogoel\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper ParallelCompilations\n- *\/\n-\n-import java.io.*;\n-import java.nio.file.*;\n-import com.sun.tools.sjavac.Main;\n-\n-class ParallelCompilations extends SJavacTester {\n-  public static void main(String[] args) throws Exception {\n-    new ParallelCompilations().run();\n-  }\n-\n-  public void run() throws Exception {\n-    \/\/ Generate 10 files\n-    for (int i = 0; i < 10; i++) {\n-      String content = \"package foo\"+ i + \";\\n\" +\n-                       \"public class Test\" + i + \"{\\n\" +\n-                       \"  public static void main(String[] args) {}\\n\" +\n-                       \"\\n}\";\n-      Path srcDir = Paths.get(\"src\");\n-      tb.writeJavaFiles(srcDir, content);\n-    }\n-    \/\/ Method will throw an exception if compilation fails\n-    compile(\"src\",\n-            \"-d\", BIN.toString(),\n-            \"--state-dir=\" + BIN,\n-            \"-j\", \"10\",\n-            \"--log=debug\");\n-  }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/ParallelCompilations.java","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test white listing of external artifacts inside the destination dir\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper PermittedArtifact\n- *\/\n-\n-import java.nio.file.Files;\n-import java.util.Map;\n-\n-public class PermittedArtifact extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        PermittedArtifact pa = new PermittedArtifact();\n-        pa.test();\n-    }\n-\n-    \/\/Verify that --permit-artifact=bin works\n-    void test() throws Exception {\n-        Files.createDirectories(BIN);\n-\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-\n-        tb.writeFile(GENSRC + \"\/alfa\/omega\/A.java\",\n-                     \"package alfa.omega; public class A { }\");\n-\n-        tb.writeFile(BIN + \"\/alfa\/omega\/AA.class\",\n-                     \"Ugh, a messy build system (tobefixed) wrote this class file, \" +\n-                     \"sjavac must not delete it.\");\n-\n-        compile(\"--log=debug\",\n-                \"--permit-artifact=\" + BIN + \"\/alfa\/omega\/AA.class\",\n-                \"-src\", GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN);\n-\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state, new_bin_state,\n-                                     BIN + \"\/alfa\/omega\/A.class\",\n-                                     BIN + \"\/alfa\/omega\/AA.class\",\n-                                     BIN + \"\/javac_state\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/PermittedArtifact.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8044131\n- * @summary Makes sure sjavac poolsize option is honored.\n- * @modules jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac.comp\n- *          jdk.compiler\/com.sun.tools.sjavac.server\n- * @build Wrapper\n- * @run main Wrapper PooledExecution\n- *\/\n-\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.atomic.AtomicInteger;\n-\n-import com.sun.tools.javac.main.Main.Result;\n-import com.sun.tools.sjavac.comp.PooledSjavac;\n-import com.sun.tools.sjavac.server.Sjavac;\n-\n-\n-public class PooledExecution {\n-\n-    public static void main(String[] args) throws InterruptedException {\n-        new PooledExecutionTest().runTest();\n-    }\n-\n-    static class PooledExecutionTest {\n-\n-        final int POOL_SIZE = 15;\n-        final int NUM_REQUESTS = 100;\n-\n-        \/\/ Number of tasks that has not yet started\n-        CountDownLatch leftToStart = new CountDownLatch(NUM_REQUESTS);\n-\n-        \/\/ Highest number of concurrently active request seen\n-        int highWaterMark = 0;\n-\n-        public void runTest() throws InterruptedException {\n-            ConcurrencyLoggingService loggingService = new ConcurrencyLoggingService();\n-            final Sjavac service = new PooledSjavac(loggingService, POOL_SIZE);\n-\n-            \/\/ Keep track of the number of finished tasks so we can make sure all\n-            \/\/ tasks finishes gracefully upon shutdown.\n-            Thread[] tasks = new Thread[NUM_REQUESTS];\n-            final AtomicInteger tasksFinished = new AtomicInteger(0);\n-\n-            for (int i = 0; i < NUM_REQUESTS; i++) {\n-                tasks[i] = new Thread() {\n-                    public void run() {\n-                        service.compile(new String[0]);\n-                        tasksFinished.incrementAndGet();\n-                    }\n-                };\n-                tasks[i].start();\n-            }\n-\n-            \/\/ Wait for all tasks to start (but not necessarily run to completion)\n-            leftToStart.await();\n-\n-            \/\/ Shutdown before all tasks are completed\n-            System.out.println(\"Shutting down!\");\n-            service.shutdown();\n-\n-            \/\/ Wait for all tasks to complete\n-            for (Thread t : tasks)\n-                t.join();\n-\n-            if (tasksFinished.get() != NUM_REQUESTS) {\n-                throw new AssertionError(tasksFinished.get() + \" out of \" +\n-                        NUM_REQUESTS + \" finished. Broken shutdown?\");\n-            }\n-\n-            if (highWaterMark > POOL_SIZE) {\n-                throw new AssertionError(\"Pool size overused: \" + highWaterMark +\n-                                         \" used out of \" + POOL_SIZE + \" allowed.\");\n-            }\n-\n-            \/\/ Assuming more than POOL_SIZE requests can be processed within 1 sek:\n-            if (highWaterMark < POOL_SIZE) {\n-                throw new AssertionError(\"Pool size underused: \" + highWaterMark +\n-                                         \" used out of \" + POOL_SIZE + \" allowed.\");\n-            }\n-        }\n-\n-\n-        private class ConcurrencyLoggingService implements Sjavac {\n-\n-            \/\/ Keeps track of currently active requests\n-            AtomicInteger activeRequests = new AtomicInteger(0);\n-\n-            @Override\n-            public Result compile(String[] args) {\n-                leftToStart.countDown();\n-                int numActiveRequests = activeRequests.incrementAndGet();\n-                System.out.printf(\"Left to start: %2d \/ Currently active: %2d%n\",\n-                                  leftToStart.getCount(),\n-                                  numActiveRequests);\n-                highWaterMark = Math.max(highWaterMark, numActiveRequests);\n-                try {\n-                    Thread.sleep(1000);\n-                } catch (InterruptedException ie) {\n-                    throw new RuntimeException(\"Interrupted\", ie);\n-                }\n-                activeRequests.decrementAndGet();\n-                System.out.println(\"Task completed\");\n-                return Result.OK;\n-            }\n-\n-            @Override\n-            public void shutdown() {\n-            }\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/PooledExecution.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,109 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/*\n- * @test\n- * @bug 8241312 8246774\n- * @summary test for com.sun.tools.sjavac.comp.PubAPIs and com.sun.tools.sjavac.comp.PubapiVisitor\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.util\n- *          jdk.compiler\/com.sun.tools.sjavac.comp\n- *          jdk.compiler\/com.sun.tools.sjavac.pubapi\n- *\/\n-import com.sun.source.util.JavacTask;\n-import com.sun.tools.javac.util.Context;\n-import java.io.IOException;\n-import com.sun.tools.sjavac.comp.PubAPIs;\n-import com.sun.tools.sjavac.pubapi.PubApi;\n-import java.net.URI;\n-import static java.util.Arrays.asList;\n-import static java.util.Collections.emptySet;\n-import java.util.List;\n-import javax.tools.JavaFileObject;\n-import javax.tools.SimpleJavaFileObject;\n-import javax.tools.ToolProvider;\n-\n-public class PubApisTest {\n-\n-    public static void main(String[] args) throws Throwable {\n-        javax.tools.JavaCompiler c = ToolProvider.getSystemJavaCompiler();\n-        JavacTask t = (JavacTask) c.getTask(null, null, null, null, null,\n-                List.of(new SimpleJavaFileObject(URI.create(\"TestClass.java\"), JavaFileObject.Kind.SOURCE) {\n-            @Override\n-            public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n-                return String.join(\"\\n\",\n-                        \"import java.util.*;\",\n-                        \"public final class TestClass {\",\n-                        \"    private String s1 = \\\"str 1\\\";\",\n-                        \"    public String s2 = \\\"str 2\\\";\",\n-                        \"    protected final String s3 = \\\"str 3\\\";\",\n-                        \"    static String s4 = \\\"str 4\\\";\",\n-                        \"    protected TestClass(int i) {}\",\n-                        \"    protected void m1() {}\",\n-                        \"    public static Map<Integer, List<String>> m2() {\",\n-                        \"        return null;\",\n-                        \"    }\",\n-                        \"    final void m3(Set<Map<Integer, Map<String, String>>> s) {}\",\n-                        \"    static class DummyInner1 implements Runnable {\",\n-                        \"        protected int field;\",\n-                        \"        public void run() {}\",\n-                        \"    }\",\n-                        \"    final class DummyInner2 { }\",\n-                        \"    public record Record3(int f1, String f2) {}\",\n-                        \"}\");\n-            }\n-        }));\n-        PubAPIs apis = PubAPIs.instance(new Context());\n-        t.analyze().forEach(apis::visitPubapi);\n-        PubApi actualApi = (PubApi) apis.getPubapis(emptySet(), false).get(\":\");\n-        PubApi expectedApi = new PubApi();\n-        asList( \"TYPE final public TestClass\",\n-                \"  VAR public java.lang.String s2\",\n-                \"  VAR final protected java.lang.String s3 = \\\"\\\\u0073\\\\u0074\\\\u0072\\\\u0020\\\\u0033\\\"\",\n-                \"  VAR static java.lang.String s4\",\n-                \"  METHOD protected void m1()\",\n-                \"  METHOD public static java.util.Map m2()\",\n-                \"  METHOD final void m3(java.util.Set)\",\n-                \"  METHOD protected void <init>(int)\",\n-                \"  TYPE static TestClass$DummyInner1\",\n-                \"    VAR protected int field\",\n-                \"    METHOD public void run()\",\n-                \"    METHOD void <init>()\",\n-                \"  TYPE final TestClass$DummyInner2\",\n-                \"    METHOD void <init>()\",\n-                \"  TYPE final public static TestClass$Record3\",\n-                \"    METHOD final public boolean equals(java.lang.Object)\",\n-                \"    METHOD final public int hashCode()\",\n-                \"    METHOD public int f1()\",\n-                \"    METHOD public java.lang.String f2()\",\n-                \"    METHOD final public java.lang.String toString()\",\n-                \"    METHOD public void <init>(int,java.lang.String)\"\n-        ).forEach(expectedApi::appendItem);\n-        if (!expectedApi.equals(actualApi)) {\n-            List<String> diffs = expectedApi.diff(actualApi);\n-            System.out.println(diffs.size() + \" differences found.\");\n-            diffs.forEach(System.out::println);\n-            throw new AssertionError(\"Actual API differs from expected API.\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/PubApisTest.java","additions":0,"deletions":109,"binary":false,"changes":109,"status":"deleted"},{"patch":"@@ -1,241 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.util.*;\n-import java.io.*;\n-import java.nio.file.*;\n-import java.nio.file.attribute.*;\n-\n-import com.sun.tools.sjavac.Main;\n-\n-import toolbox.ToolBox;\n-\n-public class SJavacTester {\n-\n-    final ToolBox tb = new ToolBox();\n-    final Path TEST_ROOT = Paths.get(getClass().getSimpleName());\n-\n-    \/\/ Generated sources that will test aspects of sjavac\n-    final Path GENSRC = TEST_ROOT.resolve(\"gensrc\");\n-    \/\/ Gensrc dirs used to test merging of serveral source roots.\n-    final Path GENSRC2 = TEST_ROOT.resolve(\"gensrc2\");\n-    final Path GENSRC3 = TEST_ROOT.resolve(\"gensrc3\");\n-\n-    \/\/ Dir for compiled classes.\n-    final Path BIN = TEST_ROOT.resolve(\"bin\");\n-    \/\/ Dir for c-header files.\n-    final Path HEADERS = TEST_ROOT.resolve(\"headers\");\n-\n-    \/\/ Remember the previous bin and headers state here.\n-    Map<String,Long> previous_bin_state;\n-    Map<String,Long> previous_headers_state;\n-\n-    void initialCompile() throws Exception {\n-        System.out.println(\"\\nInitial compile of gensrc.\");\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/AINT.java\"),\n-                     \"package alfa.omega; public interface AINT { void aint(); }\");\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A implements AINT { \"+\n-                     \"public final static int DEFINITION = 17; public void aint() { } }\");\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/AA.java\"),\n-            \"package alfa.omega;\"+\n-            \"\/\/ A package private class, not contributing to the public api.\\n\"+\n-            \"class AA {\"+\n-            \"   \/\/ A properly nested static inner class.\\n\"+\n-            \"    static class AAA { }\\n\"+\n-            \"    \/\/ A properly nested inner class.\\n\"+\n-            \"    class AAAA { }\\n\"+\n-            \"    Runnable foo() {\\n\"+\n-            \"        \/\/ A proper anonymous class.\\n\"+\n-            \"        return new Runnable() { public void run() { } };\\n\"+\n-            \"    }\\n\"+\n-            \"    AAA aaa;\\n\"+\n-            \"    AAAA aaaa;\\n\"+\n-            \"    AAAAA aaaaa;\\n\"+\n-            \"}\\n\"+\n-            \"class AAAAA {\\n\"+\n-            \"    \/\/ A bad auxiliary class, but no one is referencing it\\n\"+\n-            \"    \/\/ from outside of this source file, therefore it is ok.\\n\"+\n-            \"}\\n\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/BINT.java\"),\n-                     \"package beta;public interface BINT { void foo(); }\");\n-        tb.writeFile(GENSRC.resolve(\"beta\/B.java\"),\n-                     \"package beta; import alfa.omega.A; public class B {\"+\n-                     \"private int b() { return A.DEFINITION; } native void foo(); }\");\n-\n-        compile(GENSRC.toString(),\n-                \"-d\", BIN.toString(),\n-                \"--state-dir=\" + BIN,\n-                \"-h\", HEADERS.toString(),\n-                \"-j\", \"1\",\n-                \"--log=debug\");\n-    }\n-\n-    void removeFrom(Path dir, String... args) throws IOException {\n-        for (String filename : args) {\n-            Path p = dir.resolve(filename);\n-            Files.delete(p);\n-        }\n-    }\n-\n-    void compile(String... args) throws Exception {\n-        int rc = Main.go(args);\n-        if (rc != 0) throw new Exception(\"Error during compile!\");\n-\n-        \/\/ Wait a second, to get around the (temporary) problem with\n-        \/\/ second resolution in the Java file api. But do not do this\n-        \/\/ on windows where the timestamps work.\n-        long in_a_sec = System.currentTimeMillis()+1000;\n-        while (in_a_sec > System.currentTimeMillis()) {\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException e) {\n-            }\n-        }\n-    }\n-\n-    void compileExpectFailure(String... args) throws Exception {\n-        int rc = Main.go(args);\n-        if (rc == 0) throw new Exception(\"Expected error during compile! Did not fail!\");\n-    }\n-\n-    Map<String,Long> collectState(Path dir) throws IOException {\n-        final Map<String,Long> files = new HashMap<>();\n-        Files.walkFileTree(dir, new SimpleFileVisitor<Path>() {\n-                 @Override\n-                 public FileVisitResult visitFile(Path file, BasicFileAttributes attrs)\n-                   throws IOException\n-                 {\n-                     files.put(file.toString(),new Long(Files.getLastModifiedTime(file).toMillis()));\n-                     return FileVisitResult.CONTINUE;\n-                 }\n-            });\n-        return files;\n-    }\n-\n-    void verifyThatFilesHaveBeenRemoved(Map<String,Long> from,\n-                                        Map<String,Long> to,\n-                                        String... args) throws Exception {\n-\n-        Set<String> froms = from.keySet();\n-        Set<String> tos = to.keySet();\n-\n-        if (froms.equals(tos)) {\n-            throw new Exception(\"Expected new state to have fewer files than previous state!\");\n-        }\n-\n-        for (String t : tos) {\n-            if (!froms.contains(t)) {\n-                throw new Exception(\"Expected \"+t+\" to exist in previous state!\");\n-            }\n-        }\n-\n-        for (String f : args) {\n-            f = f.replace(\"\/\", File.separator);\n-            if (!froms.contains(f)) {\n-                throw new Exception(\"Expected \"+f+\" to exist in previous state!\");\n-            }\n-            if (tos.contains(f)) {\n-                throw new Exception(\"Expected \"+f+\" to have been removed from the new state!\");\n-            }\n-        }\n-\n-        if (froms.size() - args.length != tos.size()) {\n-            throw new Exception(\"There are more removed files than the expected list!\");\n-        }\n-    }\n-\n-    void verifyThatFilesHaveBeenAdded(Map<String,Long> from,\n-                                      Map<String,Long> to,\n-                                      String... args) throws Exception {\n-\n-        Set<String> froms = from.keySet();\n-        Set<String> tos = to.keySet();\n-\n-        if (froms.equals(tos)) {\n-            throw new Exception(\"Expected new state to have more files than previous state!\");\n-        }\n-\n-        for (String t : froms) {\n-            if (!tos.contains(t)) {\n-                throw new Exception(\"Expected \"+t+\" to exist in new state!\");\n-            }\n-        }\n-\n-        for (String f : args) {\n-            f = f.replace(\"\/\", File.separator);\n-            if (!tos.contains(f)) {\n-                throw new Exception(\"Expected \"+f+\" to have been added to new state!\");\n-            }\n-            if (froms.contains(f)) {\n-                throw new Exception(\"Expected \"+f+\" to not exist in previous state!\");\n-            }\n-        }\n-\n-        if (froms.size() + args.length != tos.size()) {\n-            throw new Exception(\"There are more added files than the expected list!\");\n-        }\n-    }\n-\n-    void verifyNewerFiles(Map<String,Long> from,\n-                          Map<String,Long> to,\n-                          String... args) throws Exception {\n-        if (!from.keySet().equals(to.keySet())) {\n-            throw new Exception(\"Expected the set of files to be identical!\");\n-        }\n-        Set<String> files = new HashSet<String>();\n-        for (String s : args) {\n-            files.add(s.replace(\"\/\", File.separator));\n-        }\n-        for (String fn : from.keySet()) {\n-            long f = from.get(fn);\n-            long t = to.get(fn);\n-            if (files.contains(fn)) {\n-                if (t <= f) {\n-                    throw new Exception(\"Expected \"+fn+\" to have a more recent timestamp!\");\n-                }\n-            } else {\n-                if (t != f) {\n-                    throw new Exception(\"Expected \"+fn+\" to have the same timestamp!\");\n-                }\n-            }\n-        }\n-    }\n-\n-    String print(Map<String,Long> m) {\n-        StringBuilder b = new StringBuilder();\n-        Set<String> keys = m.keySet();\n-        for (String k : keys) {\n-            b.append(k+\" \"+m.get(k)+\"\\n\");\n-        }\n-        return b.toString();\n-    }\n-\n-    void verifyEqual(Map<String,Long> from, Map<String,Long> to) throws Exception {\n-        if (!from.equals(to)) {\n-            System.out.println(\"FROM---\"+print(from));\n-            System.out.println(\"TO-----\"+print(to));\n-            throw new Exception(\"The dir should not differ! But it does!\");\n-        }\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/SJavacTester.java","additions":0,"deletions":241,"binary":false,"changes":241,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8035063\n- *\n- * @summary Tests serialization of options. The options needs to be serialized\n- *          and saved in the state file since the files need to be recompiled\n- *          if new options are provided.\n- *\n- * @modules jdk.compiler\/com.sun.tools.sjavac\n- *          jdk.compiler\/com.sun.tools.sjavac.options\n- * @build Wrapper\n- * @run main Wrapper Serialization\n- *\/\n-\n-import static util.OptionTestUtil.assertEquals;\n-\n-import java.io.IOException;\n-import java.util.Map;\n-\n-import com.sun.tools.sjavac.CompileJavaPackages;\n-import com.sun.tools.sjavac.Transformer;\n-import com.sun.tools.sjavac.options.Option;\n-import com.sun.tools.sjavac.options.Options;\n-import com.sun.tools.sjavac.options.SourceLocation;\n-\n-\n-public class Serialization {\n-\n-    public static void main(String[] args) throws IOException {\n-\n-        \/\/ Create reference options\n-        Options options1 = Options.parseArgs(\n-                Option.H.arg, \"headers\",\n-                Option.S.arg, \"gensrc\",\n-                Option.D.arg, \"dest\",\n-                Option.I.arg, \"pkg\/*\",\n-                Option.X.arg, \"pkg\/pkg\/*\",\n-                Option.SRC.arg, \"root\",\n-                Option.SOURCEPATH.arg, \"sourcepath\",\n-                Option.CLASSPATH.arg, \"classpath\",\n-                Option.MODULE_PATH.arg, \"modulepath\",\n-                Option.PERMIT_SOURCES_WITHOUT_PACKAGE.arg,\n-                Option.PERMIT_UNIDENTIFIED_ARTIFACTS.arg,\n-                Option.TR.arg, \".prop=\" + CompileJavaPackages.class.getName(),\n-                Option.J.arg, \"999\",\n-                \"-someJavacArg\",\n-                \"-someOtherJavacArg\");\n-\n-        \/\/ Serialize\n-        String serialized = options1.getStateArgsString();\n-\n-        \/\/ Deserialize\n-        Options options2 = Options.parseArgs(serialized.split(\" \"));\n-\n-        \/\/ Make sure we got the same result\n-        assertEquals(options1.getHeaderDir(), options2.getHeaderDir());\n-        assertEquals(options1.getGenSrcDir(), options2.getGenSrcDir());\n-        assertEquals(options1.getDestDir(), options2.getDestDir());\n-\n-        SourceLocation sl1 = options1.getSources().get(0);\n-        SourceLocation sl2 = options2.getSources().get(0);\n-        assertEquals(sl1.getPath(), sl2.getPath());\n-        assertEquals(sl1.getIncludes(), sl2.getIncludes());\n-        assertEquals(sl1.getExcludes(), sl2.getExcludes());\n-\n-        assertEquals(options1.getClassSearchPath(), options2.getClassSearchPath());\n-        assertEquals(options1.getSourceSearchPaths(), options2.getSourceSearchPaths());\n-        assertEquals(options1.getModuleSearchPaths(), options2.getModuleSearchPaths());\n-\n-        Map<String, Transformer> trRules1 = options1.getTranslationRules();\n-        Map<String, Transformer> trRules2 = options2.getTranslationRules();\n-        assertEquals(trRules1.keySet(), trRules2.keySet());\n-        assertEquals(trRules1.values().iterator().next().getClass(),\n-                     trRules2.values().iterator().next().getClass());\n-        assertEquals(options1.getJavacArgs(), options2.getJavacArgs());\n-\n-        assertEquals(999, options1.getNumCores());\n-        if (options2.getNumCores() == 999)\n-            throw new AssertionError(\"Num cores should not be part of serialization\");\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/sjavac\/Serialization.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"},{"patch":"@@ -1,49 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Method;\n-import java.util.Arrays;\n-\n-import toolbox.ToolBox;\n-\n-public class SjavacBase {\n-\n-    protected final static ToolBox toolbox = new ToolBox();\n-\n-    \/**\n-     * Utility method for invoking sjavac. Method accepts Objects as arguments\n-     * (which are turned into Strings through Object::toString) to allow clients\n-     * to pass for instance Path objects.\n-     *\/\n-    public static int compile(Object... args) throws ReflectiveOperationException {\n-        \/\/ Use reflection to avoid a compile-time dependency on sjavac Main\n-        System.out.println(\"compile: \" + Arrays.toString(args));\n-        Class<?> c = Class.forName(\"com.sun.tools.sjavac.Main\");\n-        Method m = c.getDeclaredMethod(\"go\", String[].class);\n-        String[] strArgs = new String[args.length];\n-        for (int i = 0; i < args.length; i++)\n-            strArgs[i] = args[i].toString();\n-        int rc = (Integer) m.invoke(null, (Object) strArgs);\n-        return rc;\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/SjavacBase.java","additions":0,"deletions":49,"binary":false,"changes":49,"status":"deleted"},{"patch":"@@ -1,69 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @summary Verify that --state-dir=bar works\n- * @bug 8054689\n- * @author Fredrik O\n- * @author sogoel (rewrite)\n- * @library \/tools\/lib\n- * @modules jdk.compiler\/com.sun.tools.javac.api\n- *          jdk.compiler\/com.sun.tools.javac.main\n- *          jdk.compiler\/com.sun.tools.sjavac\n- * @build Wrapper toolbox.ToolBox\n- * @run main Wrapper StateDir\n- *\/\n-\n-import java.util.*;\n-import java.nio.file.*;\n-\n-public class StateDir extends SJavacTester {\n-    public static void main(String... args) throws Exception {\n-        StateDir sd = new StateDir();\n-        sd.test();\n-    }\n-\n-    void test() throws Exception {\n-        Path BAR = TEST_ROOT.resolve(\"bar\");\n-        Files.createDirectories(BAR);\n-        Files.createDirectories(BIN);\n-\n-        Map<String,Long> previous_bin_state = collectState(BIN);\n-        Map<String,Long> previous_bar_state = collectState(BAR);\n-\n-        tb.writeFile(GENSRC.resolve(\"alfa\/omega\/A.java\"),\n-                     \"package alfa.omega; public class A { }\");\n-\n-        compile(\"--state-dir=\" + BAR,\n-                \"-src\", GENSRC.toString(),\n-                \"-d\", BIN.toString());\n-\n-        Map<String,Long> new_bin_state = collectState(BIN);\n-        verifyThatFilesHaveBeenAdded(previous_bin_state, new_bin_state,\n-                                     BIN + \"\/alfa\/omega\/A.class\");\n-        Map<String,Long> new_bar_state = collectState(BAR);\n-        verifyThatFilesHaveBeenAdded(previous_bar_state, new_bar_state,\n-                                     BAR + \"\/javac_state\");\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/StateDir.java","additions":0,"deletions":69,"binary":false,"changes":69,"status":"deleted"},{"patch":"@@ -1,85 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-public class Wrapper {\n-    public static void main(String... args) throws Exception {\n-        if (!isSJavacOnClassPath()) {\n-            System.out.println(\"sjavac not available: pass by default\");\n-            return;\n-        }\n-\n-        String testClassName = args[0];\n-        String[] testArgs = Arrays.copyOfRange(args, 1, args.length);\n-\n-        Path srcDir = Paths.get(System.getProperty(\"test.src\"));\n-        Path clsDir = Paths.get(System.getProperty(\"test.classes\"));\n-        String clsPath = System.getProperty(\"test.class.path\");\n-        String tstMdls = System.getProperty(\"test.modules\");\n-\n-        Path src = srcDir.resolve(testClassName + \".java\");\n-        Path cls = clsDir.resolve(testClassName + \".class\");\n-\n-        if (isNewer(src, cls)) {\n-            System.err.println(\"Recompiling test class...\");\n-            List<String> javacArgs = new ArrayList<>();\n-            javacArgs.addAll(Arrays.asList(\"-d\", clsDir.toString()));\n-            javacArgs.addAll(Arrays.asList(\"-sourcepath\", srcDir.toString()));\n-            javacArgs.addAll(Arrays.asList(\"-classpath\", clsPath));\n-            Arrays.stream(tstMdls.split(\"\\\\s+\"))\n-                .filter(s -> s.contains(\"\/\"))\n-                .map(s -> \"--add-exports=\" + s + \"=ALL-UNNAMED\")\n-                .collect(Collectors.toCollection(() -> javacArgs));\n-            javacArgs.add(src.toString());\n-            System.out.println(\"javac: \" + javacArgs);\n-            int rc = com.sun.tools.javac.Main.compile(\n-                javacArgs.toArray(new String[javacArgs.size()]));\n-            if (rc != 0)\n-                throw new Exception(\"compilation failed\");\n-        }\n-\n-        Class<?> sjavac = Class.forName(testClassName);\n-        Method main = sjavac.getMethod(\"main\", String[].class);\n-        main.invoke(null, new Object[] { testArgs });\n-    }\n-\n-    private static boolean isNewer(Path a, Path b) throws IOException {\n-        if (Files.notExists(b))\n-            return true;\n-        return Files.getLastModifiedTime(a).compareTo(Files.getLastModifiedTime(b)) > 0;\n-    }\n-\n-    private static boolean isSJavacOnClassPath() {\n-        String cls = \"com\/sun\/tools\/sjavac\/Main.class\";\n-        return Wrapper.class.getClassLoader().getResource(cls) != null;\n-    }\n-}\n","filename":"test\/langtools\/tools\/sjavac\/Wrapper.java","additions":0,"deletions":85,"binary":false,"changes":85,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package util;\n-\n-import java.nio.file.Path;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-\n-import com.sun.tools.sjavac.options.SourceLocation;\n-\n-\n-public class OptionTestUtil {\n-\n-    public static void checkFilesFound(Collection<String> found, Path... expected) {\n-\n-        Collection<String> expectedStrs = new HashSet<String>();\n-        for (Path p : expected)\n-            expectedStrs.add(p.toString());\n-\n-        if (!expectedStrs.containsAll(found))\n-            throw new AssertionError(\"Expected (\" + expectedStrs + \") does not \" +\n-                                     \"contain all actual (\" + found + \")\");\n-\n-        if (!found.containsAll(expectedStrs))\n-            throw new AssertionError(\"Actual (\" + found + \") does not \" +\n-                                     \"contain all expected (\" + expectedStrs + \")\");\n-    }\n-\n-    public static void assertEquals(List<SourceLocation> expected, List<SourceLocation> actual) {\n-        if (expected.size() != actual.size())\n-            throw new AssertionError(\"Expected locs of length \" + expected.size() + \" but got something of size \" + actual.size());\n-\n-        Iterator<SourceLocation> iter1 = expected.iterator();\n-        Iterator<SourceLocation> iter2 = actual.iterator();\n-\n-        while (iter1.hasNext()) {\n-            SourceLocation sl1 = iter1.next();\n-            SourceLocation sl2 = iter2.next();\n-\n-            if (!sl1.getPath().equals(sl2.getPath()) ||\n-                    !sl1.getIncludes().equals(sl2.getIncludes()) ||\n-                    !sl1.getExcludes().equals(sl2.getExcludes()))\n-                throw new AssertionError(\"Expected \" + sl1 + \" but got \" + sl2);\n-        }\n-    }\n-\n-    public static void assertEquals(Object expected, Object actual) {\n-        if (!expected.equals(actual))\n-            throw new AssertionError(\"Expected \" + expected + \" but got \" + actual);\n-    }\n-\n-}\n","filename":"test\/langtools\/tools\/sjavac\/util\/OptionTestUtil.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"}]}