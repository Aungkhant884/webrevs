[{"commit":{"message":"Fix jcheck\n\nWhitespace"},"files":[{"filename":"src\/hotspot\/share\/classfile\/stringTable.cpp"}],"sha":"6fd81bdb0e7918f0bd4d546f8a610a5be776a85f"},{"commit":{"message":"Fix jcheck\n\nWhitespace"},"files":[{"filename":"src\/hotspot\/share\/classfile\/stringTable.cpp"}],"sha":"74c1a27a66cca7d8406e6551e1a137dccbde7fed"},{"commit":{"message":"Review comments - add dedicated is_dead function"},"files":[{"filename":"src\/hotspot\/share\/classfile\/dictionary.cpp"},{"filename":"src\/hotspot\/share\/classfile\/stringTable.cpp"},{"filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp"},{"filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp"},{"filename":"src\/hotspot\/share\/services\/finalizerService.cpp"},{"filename":"src\/hotspot\/share\/services\/threadIdTable.cpp"},{"filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp"},{"filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp"}],"sha":"cb6c1864e2831f8cf1fc191fbfe12753061ab2fc"},{"commit":{"message":"8313678 - SymbolTable can leak Symbols during cleanup\n\nThe cleanup routine of concurrentHashTable uses the lookup\nfunction for its secondary effect of checking whether any\nparticular value is dead or not. It does not actually care about\nthe main purpose of the lookup function, i.e. checking if a particular\nvalue is the desired value.\n\nThe lookup function for SymbolTable, however, has the side effect of\nincrementing the Symbol refcount when the lookup succeeds. This is\npresumably with the assumption that a successful lookup will result\nin a newly held reference. concurrentHashTable's delete_in_bucket\ncan break this assumption by completing a successful lookup without\nretaining the result (nor ever decrementing the refcount).\n\nThus, with a particular sequence of events (as shown in the new\ntest case), a newly inserted Symbol can have a refcount of 2 instead\nof 1. Even if all legitimate references to this Symbol are removed,\nit will remain live, thus leaking.\n\nThe fix allows the caller of .equals to specify if they intend to\nuse the value after the lookup, or not, allowing SymbolTable to\nonly increment the refcount when appropriate."},"files":[{"filename":"src\/hotspot\/share\/classfile\/dictionary.cpp"},{"filename":"src\/hotspot\/share\/classfile\/stringTable.cpp"},{"filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp"},{"filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp"},{"filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp"},{"filename":"src\/hotspot\/share\/services\/finalizerService.cpp"},{"filename":"src\/hotspot\/share\/services\/threadIdTable.cpp"},{"filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp"},{"filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp"},{"filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp"}],"sha":"2be4f359e57855d05d0c6f8a526a21eb47bf8b30"}]