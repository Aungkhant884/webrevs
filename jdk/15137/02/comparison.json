{"files":[{"patch":"@@ -237,0 +237,3 @@\n+  bool is_dead(DictionaryEntry** value) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  bool is_dead(WeakHandle* value) {\n+    oop val_oop = value->peek();\n+    return val_oop == nullptr;\n+  }\n@@ -226,0 +230,5 @@\n+\n+  bool is_dead(WeakHandle* value) {\n+    oop val_oop = value->peek();\n+    return val_oop == nullptr;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -394,0 +394,3 @@\n+  bool is_dead(Symbol* value) {\n+    return value->refcount() == 0;\n+  }\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -265,0 +265,4 @@\n+\n+    bool is_dead(G1CardSetHashTableValue*) {\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -144,0 +144,4 @@\n+  bool is_dead(WeakHandle* value) {\n+    oop val_oop = value->peek();\n+    return val_oop == nullptr;\n+  }\n","filename":"src\/hotspot\/share\/prims\/resolvedMethodTable.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,0 +145,3 @@\n+  bool is_dead(FinalizerEntry** value) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -197,0 +197,3 @@\n+  bool is_dead(ThreadIdTableEntry** value) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/services\/threadIdTable.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -549,3 +549,1 @@\n-    bool is_dead = false;\n-    lookup_f.equals(rem_n->value(), &is_dead);\n-    if (is_dead) {\n+    if (lookup_f.is_dead(rem_n->value())) {\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -128,0 +128,14 @@\n+\n+TEST_VM(SymbolTable, test_cleanup_leak) {\n+  \/\/ Check that dead entry cleanup doesn't increment refcount of live entry in same bucket.\n+\n+  \/\/ Create symbol and release ref, marking it available for cleanup.\n+  Symbol* entry1 = SymbolTable::new_symbol(\"hash_collision_123\");\n+  entry1->decrement_refcount();\n+\n+  \/\/ Create a new symbol in the same bucket, which will notice the dead entry and trigger cleanup.\n+  \/\/ Note: relies on SymbolTable's use of String::hashCode which collides for these two values.\n+  Symbol* entry2 = SymbolTable::new_symbol(\"hash_collision_397476851\");\n+\n+  ASSERT_EQ(entry2->refcount(), 1) << \"Symbol refcount just created is 1\";\n+}\n","filename":"test\/hotspot\/gtest\/classfile\/test_symbolTable.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -113,0 +113,3 @@\n+  bool is_dead(const uintptr_t* value) {\n+    return false;\n+  }\n@@ -567,0 +570,3 @@\n+  bool is_dead(const uintptr_t* value) {\n+    return false;\n+  }\n","filename":"test\/hotspot\/gtest\/utilities\/test_concurrentHashtable.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"}]}