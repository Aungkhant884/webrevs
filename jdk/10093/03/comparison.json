{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import java.nio.file.*;\n+import java.nio.file.FileStore;\n+import java.nio.file.WatchService;\n@@ -30,1 +31,5 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -32,0 +37,1 @@\n+import static sun.nio.fs.UnixConstants.*;\n@@ -124,2 +130,0 @@\n-\n-\n@@ -130,0 +134,48 @@\n+\n+    \/\/ --- file copying ---\n+\n+    @Override\n+    void bufferedCopy(int dst, int src, long address,\n+                      int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        super.bufferedCopy(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    @Override\n+    int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":57,"deletions":5,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    \/**\n+     * int posix_fadvise(int fd, off_t offset, off_t len, int advice);\n+     *\/\n+    static native int posix_fadvise(int fd, long offset, long len, int advice)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include <sys\/sendfile.h>\n+#include <fcntl.h>\n+\n+#include \"sun_nio_fs_LinuxFileSystem.h\"\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible,\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxFileSystem_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    \/\/ Transfer within the kernel\n+    const size_t count = cancel != NULL ?\n+        1048576 :   \/\/ 1 MB to give cancellation a chance\n+        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n+    ssize_t bytes_sent;\n+\n+    do {\n+        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n+        if (bytes_sent < 0) {\n+            if (errno == EAGAIN)\n+                return IOS_UNAVAILABLE;\n+            if (errno == EINVAL || errno == ENOSYS)\n+                return IOS_UNSUPPORTED_CASE;\n+            throwUnixException(env, errno);\n+            return IOS_THROWN;\n+        }\n+        if (cancel != NULL && *cancel != 0) {\n+            throwUnixException(env, ECANCELED);\n+            return IOS_THROWN;\n+        }\n+    } while (bytes_sent > 0);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxFileSystem.c","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include <fcntl.h>\n@@ -142,1 +143,1 @@\n-    \/* FIXME - man page doesn't explain how errors are returned *\/\n+    \/\/ The endmntent() function always returns 1.\n@@ -145,0 +146,7 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_posix_1fadvise(JNIEnv* env, jclass this,\n+    jint fd, jlong offset, jlong len, jint advice)\n+{\n+    return posix_fadvise64((int)fd, (off64_t)offset, (off64_t)len, (int)advice);\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.file.*;\n@@ -30,1 +29,2 @@\n-import java.util.*;\n+import java.nio.file.FileStore;\n+import java.nio.file.WatchService;\n@@ -32,0 +32,4 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -107,0 +111,15 @@\n+\n+    \/\/ --- file copying ---\n+\n+    @Override\n+    int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include <copyfile.h>\n+#include \"sun_nio_fs_BsdFileSystem.h\"\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n+    const char* src, const char* dst, void* cancel)\n+{\n+    if (what == COPYFILE_COPY_DATA) {\n+        if (stage == COPYFILE_ERR\n+                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n+            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n+            \/\/ or to the appropriate error number if there is an error,\n+            \/\/ but in either case we need to quit.\n+            return COPYFILE_QUIT;\n+        }\n+    }\n+    return COPYFILE_CONTINUE;\n+}\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdFileSystem_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    copyfile_state_t state;\n+    if (cancel != NULL) {\n+        state = copyfile_state_alloc();\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n+    } else {\n+        state = NULL;\n+    }\n+    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n+        int errno_fcopyfile = errno;\n+        if (state != NULL)\n+            copyfile_state_free(state);\n+        throwUnixException(env, errno_fcopyfile);\n+        return IOS_THROWN;\n+    }\n+    if (state != NULL)\n+        copyfile_state_free(state);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileSystem.c","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -146,1 +146,0 @@\n-    \/\/ flags used with setattrlist\n@@ -148,0 +147,1 @@\n+    \/\/ flags used with setattrlist\n@@ -159,0 +159,7 @@\n+\n+#ifdef __linux__\n+    \/\/ advice flags used with posix_fadvise(2)\n+    static final int PREFIX_POSIX_FADV_SEQUENTIAL = POSIX_FADV_SEQUENTIAL;\n+    static final int PREFIX_POSIX_FADV_NOREUSE    = POSIX_FADV_NOREUSE;\n+    static final int PREFIX_POSIX_FADV_WILLNEED   = POSIX_FADV_WILLNEED;\n+#endif\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1,743 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.fs;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.AtomicMoveNotSupportedException;\n-import java.nio.file.CopyOption;\n-import java.nio.file.DirectoryNotEmptyException;\n-import java.nio.file.FileAlreadyExistsException;\n-import java.nio.file.LinkOption;\n-import java.nio.file.LinkPermission;\n-import java.nio.file.StandardCopyOption;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import jdk.internal.misc.Blocker;\n-import sun.nio.ch.DirectBuffer;\n-import sun.nio.ch.IOStatus;\n-import sun.nio.ch.Util;\n-import static sun.nio.fs.UnixNativeDispatcher.*;\n-import static sun.nio.fs.UnixConstants.*;\n-\n-\/**\n- * Unix implementation of Path#copyTo and Path#moveTo methods.\n- *\/\n-\n-class UnixCopyFile {\n-    \/\/ minimum size of a temporary direct buffer\n-    private static final int MIN_BUFFER_SIZE = 16384;\n-\n-    private UnixCopyFile() {  }\n-\n-    \/\/ The flags that control how a file is copied or moved\n-    private static class Flags {\n-        boolean replaceExisting;\n-        boolean atomicMove;\n-        boolean followLinks;\n-        boolean interruptible;\n-\n-        \/\/ the attributes to copy\n-        boolean copyBasicAttributes;\n-        boolean copyPosixAttributes;\n-        boolean copyNonPosixAttributes;\n-\n-        \/\/ flags that indicate if we should fail if attributes cannot be copied\n-        boolean failIfUnableToCopyBasic;\n-        boolean failIfUnableToCopyPosix;\n-        boolean failIfUnableToCopyNonPosix;\n-\n-        static Flags fromCopyOptions(CopyOption... options) {\n-            Flags flags = new Flags();\n-            flags.followLinks = true;\n-            for (CopyOption option: options) {\n-                if (option == StandardCopyOption.REPLACE_EXISTING) {\n-                    flags.replaceExisting = true;\n-                    continue;\n-                }\n-                if (option == LinkOption.NOFOLLOW_LINKS) {\n-                    flags.followLinks = false;\n-                    continue;\n-                }\n-                if (option == StandardCopyOption.COPY_ATTRIBUTES) {\n-                    \/\/ copy all attributes but only fail if basic attributes\n-                    \/\/ cannot be copied\n-                    flags.copyBasicAttributes = true;\n-                    flags.copyPosixAttributes = true;\n-                    flags.copyNonPosixAttributes = true;\n-                    flags.failIfUnableToCopyBasic = true;\n-                    continue;\n-                }\n-                if (ExtendedOptions.INTERRUPTIBLE.matches(option)) {\n-                    flags.interruptible = true;\n-                    continue;\n-                }\n-                if (option == null)\n-                    throw new NullPointerException();\n-                throw new UnsupportedOperationException(\"Unsupported copy option\");\n-            }\n-            return flags;\n-        }\n-\n-        static Flags fromMoveOptions(CopyOption... options) {\n-            Flags flags = new Flags();\n-            for (CopyOption option: options) {\n-                if (option == StandardCopyOption.ATOMIC_MOVE) {\n-                    flags.atomicMove = true;\n-                    continue;\n-                }\n-                if (option == StandardCopyOption.REPLACE_EXISTING) {\n-                    flags.replaceExisting = true;\n-                    continue;\n-                }\n-                if (option == LinkOption.NOFOLLOW_LINKS) {\n-                    \/\/ ignore\n-                    continue;\n-                }\n-                if (option == null)\n-                    throw new NullPointerException();\n-                throw new UnsupportedOperationException(\"Unsupported copy option\");\n-            }\n-\n-            \/\/ a move requires that all attributes be copied but only fail if\n-            \/\/ the basic attributes cannot be copied\n-            flags.copyBasicAttributes = true;\n-            flags.copyPosixAttributes = true;\n-            flags.copyNonPosixAttributes = true;\n-            flags.failIfUnableToCopyBasic = true;\n-            return flags;\n-        }\n-    }\n-\n-    \/\/ copy directory from source to target\n-    private static void copyDirectory(UnixPath source,\n-                                      UnixFileAttributes attrs,\n-                                      UnixPath target,\n-                                      Flags flags)\n-        throws IOException\n-    {\n-        try {\n-            mkdir(target, attrs.mode());\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(target);\n-        }\n-\n-        \/\/ no attributes to copy\n-        if (!flags.copyBasicAttributes &&\n-            !flags.copyPosixAttributes &&\n-            !flags.copyNonPosixAttributes) return;\n-\n-        \/\/ open target directory if possible (this can fail when copying a\n-        \/\/ directory for which we don't have read access).\n-        int dfd = -1;\n-        try {\n-            dfd = open(target, O_RDONLY, 0);\n-        } catch (UnixException x) {\n-            \/\/ access to target directory required to copy named attributes\n-            if (flags.copyNonPosixAttributes && flags.failIfUnableToCopyNonPosix) {\n-                try { rmdir(target); } catch (UnixException ignore) { }\n-                x.rethrowAsIOException(target);\n-            }\n-        }\n-\n-        boolean done = false;\n-        try {\n-            \/\/ copy owner\/group\/permissions\n-            if (flags.copyPosixAttributes){\n-                try {\n-                    if (dfd >= 0) {\n-                        fchown(dfd, attrs.uid(), attrs.gid());\n-                        fchmod(dfd, attrs.mode());\n-                    } else {\n-                        chown(target, attrs.uid(), attrs.gid());\n-                        chmod(target, attrs.mode());\n-                    }\n-                } catch (UnixException x) {\n-                    \/\/ unable to set owner\/group\n-                    if (flags.failIfUnableToCopyPosix)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            \/\/ copy other attributes\n-            if (flags.copyNonPosixAttributes && (dfd >= 0)) {\n-                int sfd = -1;\n-                try {\n-                    sfd = open(source, O_RDONLY, 0);\n-                } catch (UnixException x) {\n-                    if (flags.failIfUnableToCopyNonPosix)\n-                        x.rethrowAsIOException(source);\n-                }\n-                if (sfd >= 0) {\n-                    source.getFileSystem().copyNonPosixAttributes(sfd, dfd);\n-                    close(sfd, e -> null);\n-                }\n-            }\n-            \/\/ copy time stamps last\n-            if (flags.copyBasicAttributes) {\n-                try {\n-                    if (dfd >= 0 && futimesSupported()) {\n-                        futimes(dfd,\n-                                attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                    } else {\n-                        utimes(target,\n-                               attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                               attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                    }\n-                } catch (UnixException x) {\n-                    \/\/ unable to set times\n-                    if (flags.failIfUnableToCopyBasic)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            done = true;\n-        } finally {\n-            if (dfd >= 0)\n-                close(dfd, e -> null);\n-            if (!done) {\n-                \/\/ rollback\n-                try { rmdir(target); } catch (UnixException ignore) { }\n-            }\n-        }\n-    }\n-\n-    \/\/ calculate the least common multiple of two values;\n-    \/\/ the parameters in general will be powers of two likely in the\n-    \/\/ range [4096, 65536] so this algorithm is expected to converge\n-    \/\/ when it is rarely called\n-    private static long lcm(long x, long y) {\n-        assert x > 0 && y > 0 : \"Non-positive parameter\";\n-\n-        long u = x;\n-        long v = y;\n-\n-        while (u != v) {\n-            if (u < v)\n-                u += x;\n-            else \/\/ u > v\n-                v += y;\n-        }\n-\n-        return u;\n-    }\n-\n-    \/\/ calculate temporary direct buffer size\n-    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n-        int bufferSize = MIN_BUFFER_SIZE;\n-        try {\n-            long bss = UnixFileStoreAttributes.get(source).blockSize();\n-            long bst = UnixFileStoreAttributes.get(target).blockSize();\n-            if (bss > 0 && bst > 0) {\n-                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n-            }\n-            if (bufferSize < MIN_BUFFER_SIZE) {\n-                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n-                bufferSize *= factor;\n-            }\n-        } catch (UnixException ignored) {\n-        }\n-        return bufferSize;\n-    }\n-\n-    \/\/ whether direct copying is supported on this platform\n-    private static volatile boolean directCopyNotSupported;\n-\n-    \/\/ copy regular file from source to target\n-    private static void copyFile(UnixPath source,\n-                                 UnixFileAttributes attrs,\n-                                 UnixPath  target,\n-                                 Flags flags,\n-                                 long addressToPollForCancel)\n-        throws IOException\n-    {\n-        int fi = -1;\n-        try {\n-            fi = open(source, O_RDONLY, 0);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        try {\n-            \/\/ open new file\n-            int fo = -1;\n-            try {\n-                fo = open(target,\n-                           (O_WRONLY |\n-                            O_CREAT |\n-                            O_EXCL),\n-                           attrs.mode());\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(target);\n-            }\n-\n-            \/\/ set to true when file and attributes copied\n-            boolean complete = false;\n-            try {\n-                boolean copied = false;\n-                if (!directCopyNotSupported) {\n-                    \/\/ copy bytes to target using platform function\n-                    long comp = Blocker.begin();\n-                    try {\n-                        int res = directCopy0(fo, fi, addressToPollForCancel);\n-                        if (res == 0) {\n-                            copied = true;\n-                        } else if (res == IOStatus.UNSUPPORTED) {\n-                            directCopyNotSupported = true;\n-                        }\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(source, target);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n-                }\n-\n-                if (!copied) {\n-                    \/\/ copy bytes to target via a temporary direct buffer\n-                    int bufferSize = temporaryBufferSize(source, target);\n-                    ByteBuffer buf = Util.getTemporaryDirectBuffer(bufferSize);\n-                    try {\n-                        long comp = Blocker.begin();\n-                        try {\n-                            bufferedCopy0(fo, fi, ((DirectBuffer)buf).address(),\n-                                          bufferSize, addressToPollForCancel);\n-                        } catch (UnixException x) {\n-                            x.rethrowAsIOException(source, target);\n-                        } finally {\n-                            Blocker.end(comp);\n-                        }\n-                    } finally {\n-                        Util.releaseTemporaryDirectBuffer(buf);\n-                    }\n-                }\n-\n-                \/\/ copy owner\/permissions\n-                if (flags.copyPosixAttributes) {\n-                    try {\n-                        fchown(fo, attrs.uid(), attrs.gid());\n-                        fchmod(fo, attrs.mode());\n-                    } catch (UnixException x) {\n-                        if (flags.failIfUnableToCopyPosix)\n-                            x.rethrowAsIOException(target);\n-                    }\n-                }\n-                \/\/ copy non POSIX attributes (depends on file system)\n-                if (flags.copyNonPosixAttributes) {\n-                    source.getFileSystem().copyNonPosixAttributes(fi, fo);\n-                }\n-                \/\/ copy time attributes\n-                if (flags.copyBasicAttributes) {\n-                    try {\n-                        if (futimesSupported()) {\n-                            futimes(fo,\n-                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        } else {\n-                            utimes(target,\n-                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        }\n-                    } catch (UnixException x) {\n-                        if (flags.failIfUnableToCopyBasic)\n-                            x.rethrowAsIOException(target);\n-                    }\n-                }\n-                complete = true;\n-            } finally {\n-                close(fo, e -> null);\n-\n-                \/\/ copy of file or attributes failed so rollback\n-                if (!complete) {\n-                    try {\n-                        unlink(target);\n-                    } catch (UnixException ignore) { }\n-                }\n-            }\n-        } finally {\n-            close(fi, e -> null);\n-        }\n-    }\n-\n-    \/\/ copy symbolic link from source to target\n-    private static void copyLink(UnixPath source,\n-                                 UnixFileAttributes attrs,\n-                                 UnixPath  target,\n-                                 Flags flags)\n-        throws IOException\n-    {\n-        byte[] linktarget = null;\n-        try {\n-            linktarget = readlink(source);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-        try {\n-            symlink(linktarget, target);\n-\n-            if (flags.copyPosixAttributes) {\n-                try {\n-                    lchown(target, attrs.uid(), attrs.gid());\n-                } catch (UnixException x) {\n-                    \/\/ ignore since link attributes not required to be copied\n-                }\n-            }\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(target);\n-        }\n-    }\n-\n-    \/\/ copy special file from source to target\n-    private static void copySpecial(UnixPath source,\n-                                    UnixFileAttributes attrs,\n-                                    UnixPath  target,\n-                                    Flags flags)\n-        throws IOException\n-    {\n-        try {\n-            mknod(target, attrs.mode(), attrs.rdev());\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(target);\n-        }\n-        boolean done = false;\n-        try {\n-            if (flags.copyPosixAttributes) {\n-                try {\n-                    chown(target, attrs.uid(), attrs.gid());\n-                    chmod(target, attrs.mode());\n-                } catch (UnixException x) {\n-                    if (flags.failIfUnableToCopyPosix)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            if (flags.copyBasicAttributes) {\n-                try {\n-                    utimes(target,\n-                           attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                           attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                } catch (UnixException x) {\n-                    if (flags.failIfUnableToCopyBasic)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            done = true;\n-        } finally {\n-            if (!done) {\n-                try { unlink(target); } catch (UnixException ignore) { }\n-            }\n-        }\n-    }\n-\n-    \/\/ throw a DirectoryNotEmpty exception if appropriate\n-    static void ensureEmptyDir(UnixPath dir) throws IOException {\n-        try {\n-            long ptr = opendir(dir);\n-            try (UnixDirectoryStream stream =\n-                new UnixDirectoryStream(dir, ptr, e -> true)) {\n-                if (stream.iterator().hasNext()) {\n-                    throw new DirectoryNotEmptyException(\n-                        dir.getPathForExceptionMessage());\n-                }\n-            }\n-        } catch (UnixException e) {\n-            e.rethrowAsIOException(dir);\n-        }\n-    }\n-\n-    \/\/ move file from source to target\n-    static void move(UnixPath source, UnixPath target, CopyOption... options)\n-        throws IOException\n-    {\n-        \/\/ permission check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            source.checkWrite();\n-            target.checkWrite();\n-        }\n-\n-        \/\/ translate options into flags\n-        Flags flags = Flags.fromMoveOptions(options);\n-\n-        \/\/ handle atomic rename case\n-        if (flags.atomicMove) {\n-            try {\n-                rename(source, target);\n-            } catch (UnixException x) {\n-                if (x.errno() == EXDEV) {\n-                    throw new AtomicMoveNotSupportedException(\n-                        source.getPathForExceptionMessage(),\n-                        target.getPathForExceptionMessage(),\n-                        x.errorString());\n-                }\n-                x.rethrowAsIOException(source, target);\n-            }\n-            return;\n-        }\n-\n-        \/\/ move using rename or copy+delete\n-        UnixFileAttributes sourceAttrs = null;\n-        UnixFileAttributes targetAttrs = null;\n-\n-        \/\/ get attributes of source file (don't follow links)\n-        try {\n-            sourceAttrs = UnixFileAttributes.get(source, false);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        \/\/ get attributes of target file (don't follow links)\n-        try {\n-            targetAttrs = UnixFileAttributes.get(target, false);\n-        } catch (UnixException x) {\n-            \/\/ ignore\n-        }\n-        boolean targetExists = (targetAttrs != null);\n-\n-        \/\/ if the target exists:\n-        \/\/ 1. check if source and target are the same file\n-        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n-        \/\/ 3. delete target if REPLACE_EXISTING option set\n-        if (targetExists) {\n-            if (sourceAttrs.isSameFile(targetAttrs))\n-                return;  \/\/ nothing to do as files are identical\n-            if (!flags.replaceExisting) {\n-                throw new FileAlreadyExistsException(\n-                    target.getPathForExceptionMessage());\n-            }\n-\n-            \/\/ attempt to delete target\n-            try {\n-                if (targetAttrs.isDirectory()) {\n-                    rmdir(target);\n-                } else {\n-                    unlink(target);\n-                }\n-            } catch (UnixException x) {\n-                \/\/ target is non-empty directory that can't be replaced.\n-                if (targetAttrs.isDirectory() &&\n-                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n-                {\n-                    throw new DirectoryNotEmptyException(\n-                        target.getPathForExceptionMessage());\n-                }\n-                x.rethrowAsIOException(target);\n-            }\n-        }\n-\n-        \/\/ first try rename\n-        try {\n-            rename(source, target);\n-            return;\n-        } catch (UnixException x) {\n-            if (x.errno() != EXDEV && x.errno() != EISDIR) {\n-                x.rethrowAsIOException(source, target);\n-            }\n-        }\n-\n-        \/\/ copy source to target\n-        if (sourceAttrs.isDirectory()) {\n-            ensureEmptyDir(source);\n-            copyDirectory(source, sourceAttrs, target, flags);\n-        } else {\n-            if (sourceAttrs.isSymbolicLink()) {\n-                copyLink(source, sourceAttrs, target, flags);\n-            } else {\n-                if (sourceAttrs.isDevice()) {\n-                    copySpecial(source, sourceAttrs, target, flags);\n-                } else {\n-                    copyFile(source, sourceAttrs, target, flags, 0L);\n-                }\n-            }\n-        }\n-\n-        \/\/ delete source\n-        try {\n-            if (sourceAttrs.isDirectory()) {\n-                rmdir(source);\n-            } else {\n-                unlink(source);\n-            }\n-        } catch (UnixException x) {\n-            \/\/ file was copied but unable to unlink the source file so attempt\n-            \/\/ to remove the target and throw a reasonable exception\n-            try {\n-                if (sourceAttrs.isDirectory()) {\n-                    rmdir(target);\n-                } else {\n-                    unlink(target);\n-                }\n-            } catch (UnixException ignore) { }\n-\n-            if (sourceAttrs.isDirectory() &&\n-                (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n-            {\n-                throw new DirectoryNotEmptyException(\n-                    source.getPathForExceptionMessage());\n-            }\n-            x.rethrowAsIOException(source);\n-        }\n-    }\n-\n-    \/\/ copy file from source to target\n-    static void copy(final UnixPath source,\n-                     final UnixPath target,\n-                     CopyOption... options) throws IOException\n-    {\n-        \/\/ permission checks\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            source.checkRead();\n-            target.checkWrite();\n-        }\n-\n-        \/\/ translate options into flags\n-        final Flags flags = Flags.fromCopyOptions(options);\n-\n-        UnixFileAttributes sourceAttrs = null;\n-        UnixFileAttributes targetAttrs = null;\n-\n-        \/\/ get attributes of source file\n-        try {\n-            sourceAttrs = UnixFileAttributes.get(source, flags.followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        \/\/ if source file is symbolic link then we must check LinkPermission\n-        if (sm != null && sourceAttrs.isSymbolicLink()) {\n-            sm.checkPermission(new LinkPermission(\"symbolic\"));\n-        }\n-\n-        \/\/ get attributes of target file (don't follow links)\n-        try {\n-            targetAttrs = UnixFileAttributes.get(target, false);\n-        } catch (UnixException x) {\n-            \/\/ ignore\n-        }\n-        boolean targetExists = (targetAttrs != null);\n-\n-        \/\/ if the target exists:\n-        \/\/ 1. check if source and target are the same file\n-        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n-        \/\/ 3. try to unlink the target\n-        if (targetExists) {\n-            if (sourceAttrs.isSameFile(targetAttrs))\n-                return;  \/\/ nothing to do as files are identical\n-            if (!flags.replaceExisting)\n-                throw new FileAlreadyExistsException(\n-                    target.getPathForExceptionMessage());\n-            try {\n-                if (targetAttrs.isDirectory()) {\n-                    rmdir(target);\n-                } else {\n-                    unlink(target);\n-                }\n-            } catch (UnixException x) {\n-                \/\/ target is non-empty directory that can't be replaced.\n-                if (targetAttrs.isDirectory() &&\n-                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n-                {\n-                    throw new DirectoryNotEmptyException(\n-                        target.getPathForExceptionMessage());\n-                }\n-                x.rethrowAsIOException(target);\n-            }\n-        }\n-\n-        \/\/ do the copy\n-        if (sourceAttrs.isDirectory()) {\n-            copyDirectory(source, sourceAttrs, target, flags);\n-            return;\n-        }\n-        if (sourceAttrs.isSymbolicLink()) {\n-            copyLink(source, sourceAttrs, target, flags);\n-            return;\n-        }\n-        if (!flags.interruptible) {\n-            \/\/ non-interruptible file copy\n-            copyFile(source, sourceAttrs, target, flags, 0L);\n-            return;\n-        }\n-\n-        \/\/ interruptible file copy\n-        final UnixFileAttributes attrsToCopy = sourceAttrs;\n-        Cancellable copyTask = new Cancellable() {\n-            @Override public void implRun() throws IOException {\n-                copyFile(source, attrsToCopy, target, flags,\n-                    addressToPollForCancel());\n-            }\n-        };\n-        try {\n-            Cancellable.runInterruptibly(copyTask);\n-        } catch (ExecutionException e) {\n-            Throwable t = e.getCause();\n-            if (t instanceof IOException)\n-                throw (IOException)t;\n-            throw new IOException(t);\n-        }\n-    }\n-\n-    \/\/ -- native methods --\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * a platform-specific function or system call possibly having kernel\n-     * support.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n-     *\/\n-    private static native int directCopy0(int dst, int src,\n-                                          long addressToPollForCancel)\n-        throws UnixException;\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * an intermediate temporary direct buffer.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param address the address of the temporary direct buffer's array\n-     * @param size the size of the temporary direct buffer's array\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\/\n-    private static native void bufferedCopy0(int dst, int src, long address,\n-                                             int size, long addressToPollForCancel)\n-        throws UnixException;\n-\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n-    }\n-\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":0,"deletions":743,"binary":false,"changes":743,"status":"deleted"},{"patch":"@@ -28,2 +28,15 @@\n-import java.nio.file.*;\n-import java.nio.file.attribute.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.AtomicMoveNotSupportedException;\n+import java.nio.file.CopyOption;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.LinkOption;\n+import java.nio.file.LinkPermission;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n@@ -32,1 +45,8 @@\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +54,3 @@\n+import jdk.internal.misc.Blocker;\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.IOStatus;\n@@ -35,0 +58,2 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n@@ -43,0 +68,6 @@\n+    \/\/ minimum size of a temporary direct buffer\n+    private static final int MIN_BUFFER_SIZE = 16384;\n+\n+    \/\/ whether direct copying is supported on this platform\n+    private static volatile boolean directCopyNotSupported;\n+\n@@ -358,0 +389,693 @@\n+\n+    \/\/  Unix implementation of Files#copy and Files#move methods.\n+\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        assert x > 0 && y > 0 : \"Non-positive parameter\";\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ calculate temporary direct buffer size\n+    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n+        int bufferSize = MIN_BUFFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (bufferSize < MIN_BUFFER_SIZE) {\n+                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n+                bufferSize *= factor;\n+            }\n+        } catch (UnixException ignored) {\n+        }\n+        return bufferSize;\n+    }\n+\n+    \/\/ The flags that control how a file is copied or moved\n+    private static class Flags {\n+        boolean replaceExisting;\n+        boolean atomicMove;\n+        boolean followLinks;\n+        boolean interruptible;\n+\n+        \/\/ the attributes to copy\n+        boolean copyBasicAttributes;\n+        boolean copyPosixAttributes;\n+        boolean copyNonPosixAttributes;\n+\n+        \/\/ flags that indicate if we should fail if attributes cannot be copied\n+        boolean failIfUnableToCopyBasic;\n+        boolean failIfUnableToCopyPosix;\n+        boolean failIfUnableToCopyNonPosix;\n+\n+        static Flags fromCopyOptions(CopyOption... options) {\n+            Flags flags = new Flags();\n+            flags.followLinks = true;\n+            for (CopyOption option: options) {\n+                if (option == StandardCopyOption.REPLACE_EXISTING) {\n+                    flags.replaceExisting = true;\n+                    continue;\n+                }\n+                if (option == LinkOption.NOFOLLOW_LINKS) {\n+                    flags.followLinks = false;\n+                    continue;\n+                }\n+                if (option == StandardCopyOption.COPY_ATTRIBUTES) {\n+                    \/\/ copy all attributes but only fail if basic attributes\n+                    \/\/ cannot be copied\n+                    flags.copyBasicAttributes = true;\n+                    flags.copyPosixAttributes = true;\n+                    flags.copyNonPosixAttributes = true;\n+                    flags.failIfUnableToCopyBasic = true;\n+                    continue;\n+                }\n+                if (ExtendedOptions.INTERRUPTIBLE.matches(option)) {\n+                    flags.interruptible = true;\n+                    continue;\n+                }\n+                if (option == null)\n+                    throw new NullPointerException();\n+                throw new UnsupportedOperationException(\"Unsupported copy option\");\n+            }\n+            return flags;\n+        }\n+\n+        static Flags fromMoveOptions(CopyOption... options) {\n+            Flags flags = new Flags();\n+            for (CopyOption option: options) {\n+                if (option == StandardCopyOption.ATOMIC_MOVE) {\n+                    flags.atomicMove = true;\n+                    continue;\n+                }\n+                if (option == StandardCopyOption.REPLACE_EXISTING) {\n+                    flags.replaceExisting = true;\n+                    continue;\n+                }\n+                if (option == LinkOption.NOFOLLOW_LINKS) {\n+                    \/\/ ignore\n+                    continue;\n+                }\n+                if (option == null)\n+                    throw new NullPointerException();\n+                throw new UnsupportedOperationException(\"Unsupported copy option\");\n+            }\n+\n+            \/\/ a move requires that all attributes be copied but only fail if\n+            \/\/ the basic attributes cannot be copied\n+            flags.copyBasicAttributes = true;\n+            flags.copyPosixAttributes = true;\n+            flags.copyNonPosixAttributes = true;\n+            flags.failIfUnableToCopyBasic = true;\n+            return flags;\n+        }\n+    }\n+\n+    \/\/ copy directory from source to target\n+    private void copyDirectory(UnixPath source,\n+                               UnixFileAttributes attrs,\n+                               UnixPath target,\n+                               Flags flags)\n+        throws IOException\n+    {\n+        try {\n+            mkdir(target, attrs.mode());\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(target);\n+        }\n+\n+        \/\/ no attributes to copy\n+        if (!flags.copyBasicAttributes &&\n+            !flags.copyPosixAttributes &&\n+            !flags.copyNonPosixAttributes) return;\n+\n+        \/\/ open target directory if possible (this can fail when copying a\n+        \/\/ directory for which we don't have read access).\n+        int dfd = -1;\n+        try {\n+            dfd = open(target, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            \/\/ access to target directory required to copy named attributes\n+            if (flags.copyNonPosixAttributes && flags.failIfUnableToCopyNonPosix) {\n+                try { rmdir(target); } catch (UnixException ignore) { }\n+                x.rethrowAsIOException(target);\n+            }\n+        }\n+\n+        boolean done = false;\n+        try {\n+            \/\/ copy owner\/group\/permissions\n+            if (flags.copyPosixAttributes){\n+                try {\n+                    if (dfd >= 0) {\n+                        fchown(dfd, attrs.uid(), attrs.gid());\n+                        fchmod(dfd, attrs.mode());\n+                    } else {\n+                        chown(target, attrs.uid(), attrs.gid());\n+                        chmod(target, attrs.mode());\n+                    }\n+                } catch (UnixException x) {\n+                    \/\/ unable to set owner\/group\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            \/\/ copy other attributes\n+            if (flags.copyNonPosixAttributes && (dfd >= 0)) {\n+                int sfd = -1;\n+                try {\n+                    sfd = open(source, O_RDONLY, 0);\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyNonPosix)\n+                        x.rethrowAsIOException(source);\n+                }\n+                if (sfd >= 0) {\n+                    source.getFileSystem().copyNonPosixAttributes(sfd, dfd);\n+                    UnixNativeDispatcher.close(sfd, e -> null);\n+                }\n+            }\n+            \/\/ copy time stamps last\n+            if (flags.copyBasicAttributes) {\n+                try {\n+                    if (dfd >= 0 && futimesSupported()) {\n+                        futimes(dfd,\n+                                attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                    } else {\n+                        utimes(target,\n+                               attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                               attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                    }\n+                } catch (UnixException x) {\n+                    \/\/ unable to set times\n+                    if (flags.failIfUnableToCopyBasic)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            done = true;\n+        } finally {\n+            if (dfd >= 0)\n+                UnixNativeDispatcher.close(dfd, e -> null);\n+            if (!done) {\n+                \/\/ rollback\n+                try { rmdir(target); } catch (UnixException ignore) { }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n+     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n+     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n+     *         direct copying is not supported on this platform\n+     *\/\n+    int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * an intermediate temporary direct buffer.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param address the address of the temporary direct buffer's array\n+     * @param size the size of the temporary direct buffer's array\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\/\n+    void bufferedCopy(int dst, int src, long address,\n+                      int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        bufferedCopy0(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    \/\/ copy regular file from source to target\n+    void copyFile(UnixPath source,\n+                  UnixFileAttributes attrs,\n+                  UnixPath  target,\n+                  Flags flags,\n+                  long addressToPollForCancel)\n+        throws IOException\n+    {\n+        int fi = -1;\n+        try {\n+            fi = open(source, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        try {\n+            \/\/ open new file\n+            int fo = -1;\n+            try {\n+                fo = open(target,\n+                           (O_WRONLY |\n+                            O_CREAT |\n+                            O_EXCL),\n+                           attrs.mode());\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(target);\n+            }\n+\n+            \/\/ set to true when file and attributes copied\n+            boolean complete = false;\n+            try {\n+                boolean copied = false;\n+                if (!directCopyNotSupported) {\n+                    \/\/ copy bytes to target using platform function\n+                    long comp = Blocker.begin();\n+                    try {\n+                        int res = directCopy(fo, fi, addressToPollForCancel);\n+                        if (res == 0) {\n+                            copied = true;\n+                        } else if (res == IOStatus.UNSUPPORTED) {\n+                            directCopyNotSupported = true;\n+                        }\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n+                    } finally {\n+                        Blocker.end(comp);\n+                    }\n+                }\n+\n+                if (!copied) {\n+                    \/\/ copy bytes to target via a temporary direct buffer\n+                    int bufferSize = temporaryBufferSize(source, target);\n+                    ByteBuffer buf =\n+                        sun.nio.ch.Util.getTemporaryDirectBuffer(bufferSize);\n+                    try {\n+                        long comp = Blocker.begin();\n+                        try {\n+                            bufferedCopy(fo, fi, ((DirectBuffer)buf).address(),\n+                                          bufferSize, addressToPollForCancel);\n+                        } catch (UnixException x) {\n+                            x.rethrowAsIOException(source, target);\n+                        } finally {\n+                            Blocker.end(comp);\n+                        }\n+                    } finally {\n+                        sun.nio.ch.Util.releaseTemporaryDirectBuffer(buf);\n+                    }\n+                }\n+\n+                \/\/ copy owner\/permissions\n+                if (flags.copyPosixAttributes) {\n+                    try {\n+                        fchown(fo, attrs.uid(), attrs.gid());\n+                        fchmod(fo, attrs.mode());\n+                    } catch (UnixException x) {\n+                        if (flags.failIfUnableToCopyPosix)\n+                            x.rethrowAsIOException(target);\n+                    }\n+                }\n+                \/\/ copy non POSIX attributes (depends on file system)\n+                if (flags.copyNonPosixAttributes) {\n+                    source.getFileSystem().copyNonPosixAttributes(fi, fo);\n+                }\n+                \/\/ copy time attributes\n+                if (flags.copyBasicAttributes) {\n+                    try {\n+                        if (futimesSupported()) {\n+                            futimes(fo,\n+                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        } else {\n+                            utimes(target,\n+                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        }\n+                    } catch (UnixException x) {\n+                        if (flags.failIfUnableToCopyBasic)\n+                            x.rethrowAsIOException(target);\n+                    }\n+                }\n+                complete = true;\n+            } finally {\n+                UnixNativeDispatcher.close(fo, e -> null);\n+\n+                \/\/ copy of file or attributes failed so rollback\n+                if (!complete) {\n+                    try {\n+                        unlink(target);\n+                    } catch (UnixException ignore) { }\n+                }\n+            }\n+        } finally {\n+            UnixNativeDispatcher.close(fi, e -> null);\n+        }\n+    }\n+\n+    \/\/ copy symbolic link from source to target\n+    private void copyLink(UnixPath source,\n+                          UnixFileAttributes attrs,\n+                          UnixPath  target,\n+                          Flags flags)\n+        throws IOException\n+    {\n+        byte[] linktarget = null;\n+        try {\n+            linktarget = readlink(source);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+        try {\n+            symlink(linktarget, target);\n+\n+            if (flags.copyPosixAttributes) {\n+                try {\n+                    lchown(target, attrs.uid(), attrs.gid());\n+                } catch (UnixException x) {\n+                    \/\/ ignore since link attributes not required to be copied\n+                }\n+            }\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(target);\n+        }\n+    }\n+\n+    \/\/ copy special file from source to target\n+    private void copySpecial(UnixPath source,\n+                             UnixFileAttributes attrs,\n+                             UnixPath  target,\n+                             Flags flags)\n+        throws IOException\n+    {\n+        try {\n+            mknod(target, attrs.mode(), attrs.rdev());\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(target);\n+        }\n+        boolean done = false;\n+        try {\n+            if (flags.copyPosixAttributes) {\n+                try {\n+                    chown(target, attrs.uid(), attrs.gid());\n+                    chmod(target, attrs.mode());\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            if (flags.copyBasicAttributes) {\n+                try {\n+                    utimes(target,\n+                           attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                           attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyBasic)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            done = true;\n+        } finally {\n+            if (!done) {\n+                try { unlink(target); } catch (UnixException ignore) { }\n+            }\n+        }\n+    }\n+\n+    \/\/ throw a DirectoryNotEmpty exception if appropriate\n+    static void ensureEmptyDir(UnixPath dir) throws IOException {\n+        try {\n+            long ptr = opendir(dir);\n+            try (UnixDirectoryStream stream =\n+                new UnixDirectoryStream(dir, ptr, e -> true)) {\n+                if (stream.iterator().hasNext()) {\n+                    throw new DirectoryNotEmptyException(\n+                        dir.getPathForExceptionMessage());\n+                }\n+            }\n+        } catch (UnixException e) {\n+            e.rethrowAsIOException(dir);\n+        }\n+    }\n+\n+    \/\/ move file from source to target\n+    void move(UnixPath source, UnixPath target, CopyOption... options)\n+        throws IOException\n+    {\n+        \/\/ permission check\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            source.checkWrite();\n+            target.checkWrite();\n+        }\n+\n+        \/\/ translate options into flags\n+        Flags flags = Flags.fromMoveOptions(options);\n+\n+        \/\/ handle atomic rename case\n+        if (flags.atomicMove) {\n+            try {\n+                rename(source, target);\n+            } catch (UnixException x) {\n+                if (x.errno() == EXDEV) {\n+                    throw new AtomicMoveNotSupportedException(\n+                        source.getPathForExceptionMessage(),\n+                        target.getPathForExceptionMessage(),\n+                        x.errorString());\n+                }\n+                x.rethrowAsIOException(source, target);\n+            }\n+            return;\n+        }\n+\n+        \/\/ move using rename or copy+delete\n+        UnixFileAttributes sourceAttrs = null;\n+        UnixFileAttributes targetAttrs = null;\n+\n+        \/\/ get attributes of source file (don't follow links)\n+        try {\n+            sourceAttrs = UnixFileAttributes.get(source, false);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        \/\/ get attributes of target file (don't follow links)\n+        try {\n+            targetAttrs = UnixFileAttributes.get(target, false);\n+        } catch (UnixException x) {\n+            \/\/ ignore\n+        }\n+        boolean targetExists = (targetAttrs != null);\n+\n+        \/\/ if the target exists:\n+        \/\/ 1. check if source and target are the same file\n+        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n+        \/\/ 3. delete target if REPLACE_EXISTING option set\n+        if (targetExists) {\n+            if (sourceAttrs.isSameFile(targetAttrs))\n+                return;  \/\/ nothing to do as files are identical\n+            if (!flags.replaceExisting) {\n+                throw new FileAlreadyExistsException(\n+                    target.getPathForExceptionMessage());\n+            }\n+\n+            \/\/ attempt to delete target\n+            try {\n+                if (targetAttrs.isDirectory()) {\n+                    rmdir(target);\n+                } else {\n+                    unlink(target);\n+                }\n+            } catch (UnixException x) {\n+                \/\/ target is non-empty directory that can't be replaced.\n+                if (targetAttrs.isDirectory() &&\n+                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n+                {\n+                    throw new DirectoryNotEmptyException(\n+                        target.getPathForExceptionMessage());\n+                }\n+                x.rethrowAsIOException(target);\n+            }\n+        }\n+\n+        \/\/ first try rename\n+        try {\n+            rename(source, target);\n+            return;\n+        } catch (UnixException x) {\n+            if (x.errno() != EXDEV && x.errno() != EISDIR) {\n+                x.rethrowAsIOException(source, target);\n+            }\n+        }\n+\n+        \/\/ copy source to target\n+        if (sourceAttrs.isDirectory()) {\n+            ensureEmptyDir(source);\n+            copyDirectory(source, sourceAttrs, target, flags);\n+        } else {\n+            if (sourceAttrs.isSymbolicLink()) {\n+                copyLink(source, sourceAttrs, target, flags);\n+            } else {\n+                if (sourceAttrs.isDevice()) {\n+                    copySpecial(source, sourceAttrs, target, flags);\n+                } else {\n+                    copyFile(source, sourceAttrs, target, flags, 0L);\n+                }\n+            }\n+        }\n+\n+        \/\/ delete source\n+        try {\n+            if (sourceAttrs.isDirectory()) {\n+                rmdir(source);\n+            } else {\n+                unlink(source);\n+            }\n+        } catch (UnixException x) {\n+            \/\/ file was copied but unable to unlink the source file so attempt\n+            \/\/ to remove the target and throw a reasonable exception\n+            try {\n+                if (sourceAttrs.isDirectory()) {\n+                    rmdir(target);\n+                } else {\n+                    unlink(target);\n+                }\n+            } catch (UnixException ignore) { }\n+\n+            if (sourceAttrs.isDirectory() &&\n+                (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n+            {\n+                throw new DirectoryNotEmptyException(\n+                    source.getPathForExceptionMessage());\n+            }\n+            x.rethrowAsIOException(source);\n+        }\n+    }\n+\n+    \/\/ copy file from source to target\n+    void copy(final UnixPath source,\n+              final UnixPath target,\n+              CopyOption... options) throws IOException\n+    {\n+        \/\/ permission checks\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            source.checkRead();\n+            target.checkWrite();\n+        }\n+\n+        \/\/ translate options into flags\n+        final Flags flags = Flags.fromCopyOptions(options);\n+\n+        UnixFileAttributes sourceAttrs = null;\n+        UnixFileAttributes targetAttrs = null;\n+\n+        \/\/ get attributes of source file\n+        try {\n+            sourceAttrs = UnixFileAttributes.get(source, flags.followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        \/\/ if source file is symbolic link then we must check LinkPermission\n+        if (sm != null && sourceAttrs.isSymbolicLink()) {\n+            sm.checkPermission(new LinkPermission(\"symbolic\"));\n+        }\n+\n+        \/\/ get attributes of target file (don't follow links)\n+        try {\n+            targetAttrs = UnixFileAttributes.get(target, false);\n+        } catch (UnixException x) {\n+            \/\/ ignore\n+        }\n+        boolean targetExists = (targetAttrs != null);\n+\n+        \/\/ if the target exists:\n+        \/\/ 1. check if source and target are the same file\n+        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n+        \/\/ 3. try to unlink the target\n+        if (targetExists) {\n+            if (sourceAttrs.isSameFile(targetAttrs))\n+                return;  \/\/ nothing to do as files are identical\n+            if (!flags.replaceExisting)\n+                throw new FileAlreadyExistsException(\n+                    target.getPathForExceptionMessage());\n+            try {\n+                if (targetAttrs.isDirectory()) {\n+                    rmdir(target);\n+                } else {\n+                    unlink(target);\n+                }\n+            } catch (UnixException x) {\n+                \/\/ target is non-empty directory that can't be replaced.\n+                if (targetAttrs.isDirectory() &&\n+                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n+                {\n+                    throw new DirectoryNotEmptyException(\n+                        target.getPathForExceptionMessage());\n+                }\n+                x.rethrowAsIOException(target);\n+            }\n+        }\n+\n+        \/\/ do the copy\n+        if (sourceAttrs.isDirectory()) {\n+            copyDirectory(source, sourceAttrs, target, flags);\n+            return;\n+        }\n+        if (sourceAttrs.isSymbolicLink()) {\n+            copyLink(source, sourceAttrs, target, flags);\n+            return;\n+        }\n+        if (!flags.interruptible) {\n+            \/\/ non-interruptible file copy\n+            copyFile(source, sourceAttrs, target, flags, 0L);\n+            return;\n+        }\n+\n+        \/\/ interruptible file copy\n+        final UnixFileAttributes attrsToCopy = sourceAttrs;\n+        Cancellable copyTask = new Cancellable() {\n+            @Override public void implRun() throws IOException {\n+                copyFile(source, attrsToCopy, target,\n+                         flags, addressToPollForCancel());\n+            }\n+        };\n+        try {\n+            Cancellable.runInterruptibly(copyTask);\n+        } catch (ExecutionException e) {\n+            Throwable t = e.getCause();\n+            if (t instanceof IOException)\n+                throw (IOException)t;\n+            throw new IOException(t);\n+        }\n+    }\n+\n+\n+    \/\/ -- native methods --\n+\n+    private static native void bufferedCopy0(int dst, int src, long address,\n+                                             int size, long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":727,"deletions":3,"binary":false,"changes":730,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import java.nio.file.*;\n-import java.nio.file.attribute.*;\n-import java.nio.file.spi.FileTypeDetector;\n-import java.nio.channels.*;\n-import java.net.URI;\n-import java.util.concurrent.ExecutorService;\n@@ -36,1 +30,30 @@\n-import java.util.*;\n+import java.net.URI;\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.AccessMode;\n+import java.nio.file.CopyOption;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystemAlreadyExistsException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.LinkPermission;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.NotLinkException;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.BasicFileAttributeView;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileAttributeView;\n+import java.nio.file.attribute.FileOwnerAttributeView;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.nio.file.attribute.PosixFileAttributeView;\n+import java.nio.file.spi.FileTypeDetector;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n@@ -277,3 +300,3 @@\n-        UnixCopyFile.copy(UnixPath.toUnixPath(source),\n-                          UnixPath.toUnixPath(target),\n-                          options);\n+        theFileSystem.copy(UnixPath.toUnixPath(source),\n+                           UnixPath.toUnixPath(target),\n+                           options);\n@@ -286,3 +309,3 @@\n-        UnixCopyFile.move(UnixPath.toUnixPath(source),\n-                          UnixPath.toUnixPath(target),\n-                          options);\n+        theFileSystem.move(UnixPath.toUnixPath(source),\n+                           UnixPath.toUnixPath(target),\n+                           options);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1,184 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"jni.h\"\n-#include \"jni_util.h\"\n-#include \"jlong.h\"\n-\n-#include \"nio.h\"\n-\n-#include <stdlib.h>\n-#include <unistd.h>\n-#include <errno.h>\n-\n-#if defined(__linux__)\n-#include <sys\/sendfile.h>\n-#include <fcntl.h>\n-#elif defined(_ALLBSD_SOURCE)\n-#include <copyfile.h>\n-#endif\n-#include \"sun_nio_fs_UnixCopyFile.h\"\n-\n-#define RESTARTABLE(_cmd, _result) do { \\\n-  do { \\\n-    _result = _cmd; \\\n-  } while((_result == -1) && (errno == EINTR)); \\\n-} while(0)\n-\n-static void throwUnixException(JNIEnv* env, int errnum) {\n-    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n-        \"(I)V\", errnum);\n-    if (x != NULL) {\n-        (*env)->Throw(env, x);\n-    }\n-}\n-\n-#if defined(_ALLBSD_SOURCE)\n-int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n-    const char* src, const char* dst, void* cancel)\n-{\n-    if (what == COPYFILE_COPY_DATA) {\n-        if (stage == COPYFILE_ERR\n-                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n-            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n-            \/\/ or to the appropriate error number if there is an error,\n-            \/\/ but in either case we need to quit.\n-            return COPYFILE_QUIT;\n-        }\n-    }\n-    return COPYFILE_CONTINUE;\n-}\n-#endif\n-\n-\/\/ Copy via an intermediate temporary direct buffer\n-JNIEXPORT void JNICALL\n-Java_sun_nio_fs_UnixCopyFile_bufferedCopy0\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n-    jint transferSize, jlong cancelAddress)\n-{\n-    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n-\n-    char* buf = (char*)jlong_to_ptr(address);\n-\n-#if defined(__linux__)\n-    int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n-                 POSIX_FADV_NOREUSE    | \/\/ will access only once\n-                 POSIX_FADV_WILLNEED;    \/\/ will access in near future\n-\n-    \/\/ ignore the return value hence any failure\n-    posix_fadvise(src, 0, 0, advice);\n-#endif\n-\n-    for (;;) {\n-        ssize_t n, pos, len;\n-        RESTARTABLE(read((int)src, buf, transferSize), n);\n-        if (n <= 0) {\n-            if (n < 0)\n-                throwUnixException(env, errno);\n-            return;\n-        }\n-        if (cancel != NULL && *cancel != 0) {\n-            throwUnixException(env, ECANCELED);\n-            return;\n-        }\n-        pos = 0;\n-        len = n;\n-        do {\n-            char* bufp = buf;\n-            bufp += pos;\n-            RESTARTABLE(write((int)dst, bufp, len), n);\n-            if (n == -1) {\n-                throwUnixException(env, errno);\n-                return;\n-            }\n-            pos += n;\n-            len -= n;\n-        } while (len > 0);\n-    }\n-}\n-\n-\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n-\/\/ and return zero, otherwise return the appropriate status code.\n-\/\/\n-\/\/ Return value\n-\/\/   0 on success\n-\/\/   IOS_UNAVAILABLE if the platform function would block\n-\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n-\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n-\/\/   IOS_THROWN if a Java exception is thrown\n-\/\/\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_UnixCopyFile_directCopy0\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n-{\n-    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n-\n-#if defined(__linux__)\n-    \/\/ Transfer within the kernel\n-    const size_t count = cancel != NULL ?\n-        1048576 :   \/\/ 1 MB to give cancellation a chance\n-        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n-    ssize_t bytes_sent;\n-    do {\n-        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n-        if (bytes_sent < 0) {\n-            if (errno == EAGAIN)\n-                return IOS_UNAVAILABLE;\n-            if (errno == EINVAL || errno == ENOSYS)\n-                return IOS_UNSUPPORTED_CASE;\n-            throwUnixException(env, errno);\n-            return IOS_THROWN;\n-        }\n-        if (cancel != NULL && *cancel != 0) {\n-            throwUnixException(env, ECANCELED);\n-            return IOS_THROWN;\n-        }\n-    } while (bytes_sent > 0);\n-\n-    return 0;\n-#elif defined(_ALLBSD_SOURCE)\n-    copyfile_state_t state;\n-    if (cancel != NULL) {\n-        state = copyfile_state_alloc();\n-        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n-        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n-    } else {\n-        state = NULL;\n-    }\n-    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n-        int errno_fcopyfile = errno;\n-        if (state != NULL)\n-            copyfile_state_free(state);\n-        throwUnixException(env, errno_fcopyfile);\n-        return IOS_THROWN;\n-    }\n-    if (state != NULL)\n-        copyfile_state_free(state);\n-\n-    return 0;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":0,"deletions":184,"binary":false,"changes":184,"status":"deleted"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include \"sun_nio_fs_UnixFileSystem.h\"\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+\/\/ Copy via an intermediate temporary direct buffer\n+JNIEXPORT void JNICALL\n+Java_sun_nio_fs_UnixFileSystem_bufferedCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong address,\n+     jint transferSize, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    char* buf = (char*)jlong_to_ptr(address);\n+\n+    for (;;) {\n+        ssize_t n, pos, len;\n+        RESTARTABLE(read((int)src, buf, transferSize), n);\n+        if (n <= 0) {\n+            if (n < 0)\n+                throwUnixException(env, errno);\n+            return;\n+        }\n+        if (cancel != NULL && *cancel != 0) {\n+            throwUnixException(env, ECANCELED);\n+            return;\n+        }\n+        pos = 0;\n+        len = n;\n+        do {\n+            char* bufp = buf;\n+            bufp += pos;\n+            RESTARTABLE(write((int)dst, bufp, len), n);\n+            if (n == -1) {\n+                throwUnixException(env, errno);\n+                return;\n+            }\n+            pos += n;\n+            len -= n;\n+        } while (len > 0);\n+    }\n+}\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixFileSystem.c","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}