{"files":[{"patch":"@@ -1,88 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.fs;\n-\n-import java.nio.file.*;\n-import java.io.IOException;\n-import java.util.*;\n-import static sun.nio.fs.LinuxNativeDispatcher.*;\n-import static sun.nio.fs.UnixConstants.*;\n-\n-\/**\n- * Linux implementation of UnixCopyFile\n- *\/\n-\n-class LinuxCopyFile extends UnixCopyFile {\n-    LinuxCopyFile() {\n-        super();\n-    }\n-\n-    @Override\n-    protected void bufferedCopy(int dst, int src, long address,\n-                                int size, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n-                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n-                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n-        posix_fadvise(src, 0, 0, advice);\n-\n-        super.bufferedCopy(dst, src, address, size, addressToPollForCancel);\n-    }\n-\n-    @Override\n-    protected int directCopy(int dst, int src, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n-                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n-                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n-        posix_fadvise(src, 0, 0, advice);\n-\n-        return directCopy0(dst, src, addressToPollForCancel);\n-    }\n-\n-    \/\/ -- native methods --\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * a platform-specific function or system call possibly having kernel\n-     * support.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n-     *\/\n-    private static native int directCopy0(int dst, int src,\n-                                          long addressToPollForCancel)\n-        throws UnixException;\n-}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxCopyFile.java","additions":0,"deletions":88,"binary":false,"changes":88,"status":"deleted"},{"patch":"@@ -37,0 +37,1 @@\n+import static sun.nio.fs.UnixConstants.*;\n@@ -44,1 +45,1 @@\n-        super(provider, dir, new LinuxCopyFile());\n+        super(provider, dir);\n@@ -133,0 +134,48 @@\n+\n+    \/\/ --- file copying ---\n+\n+    @Override\n+    protected void bufferedCopy(int dst, int src, long address,\n+                                int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        super.bufferedCopy(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":50,"deletions":1,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-#include \"sun_nio_fs_LinuxCopyFile.h\"\n+#include \"sun_nio_fs_LinuxFileSystem.h\"\n@@ -66,1 +66,1 @@\n-Java_sun_nio_fs_LinuxCopyFile_directCopy0\n+Java_sun_nio_fs_LinuxFileSystem_directCopy0\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxFileSystem.c","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxCopyFile.c","status":"renamed"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.fs;\n-\n-\/**\n- * Bsd implementation of UnixCopyFile\n- *\/\n-\n-class BsdCopyFile extends UnixCopyFile {\n-\n-    BsdCopyFile() {\n-        super();\n-    }\n-\n-    @Override\n-    protected int directCopy(int dst, int src, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        return directCopy0(dst, src, addressToPollForCancel);\n-    }\n-\n-    \/\/ -- native methods --\n-\n-    private static native int directCopy0(int dst, int src,\n-                                          long addressToPollForCancel)\n-        throws UnixException;\n-}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdCopyFile.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -45,1 +45,1 @@\n-        super(provider, dir, new BsdCopyFile());\n+        super(provider, dir);\n@@ -111,0 +111,15 @@\n+\n+    \/\/ --- file copying ---\n+\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"sun_nio_fs_BsdCopyFile.h\"\n+#include \"sun_nio_fs_BsdFileSystem.h\"\n@@ -79,1 +79,1 @@\n-Java_sun_nio_fs_BsdCopyFile_directCopy0\n+Java_sun_nio_fs_BsdFileSystem_directCopy0\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdFileSystem.c","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdCopyFile.c","status":"renamed"},{"patch":"@@ -1,748 +0,0 @@\n-\/*\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.nio.fs;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-import java.nio.file.AtomicMoveNotSupportedException;\n-import java.nio.file.CopyOption;\n-import java.nio.file.DirectoryNotEmptyException;\n-import java.nio.file.FileAlreadyExistsException;\n-import java.nio.file.LinkOption;\n-import java.nio.file.LinkPermission;\n-import java.nio.file.StandardCopyOption;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import jdk.internal.misc.Blocker;\n-import sun.nio.ch.DirectBuffer;\n-import sun.nio.ch.IOStatus;\n-import static sun.nio.fs.UnixNativeDispatcher.*;\n-import static sun.nio.fs.UnixConstants.*;\n-\n-\/**\n- * Unix implementation of Files#copy and Files#move methods.\n- *\/\n-\n-class UnixCopyFile {\n-    \/\/ minimum size of a temporary direct buffer\n-    private static final int MIN_BUFFER_SIZE = 16384;\n-\n-    \/\/ calculate the least common multiple of two values;\n-    \/\/ the parameters in general will be powers of two likely in the\n-    \/\/ range [4096, 65536] so this algorithm is expected to converge\n-    \/\/ when it is rarely called\n-    private static long lcm(long x, long y) {\n-        assert x > 0 && y > 0 : \"Non-positive parameter\";\n-\n-        long u = x;\n-        long v = y;\n-\n-        while (u != v) {\n-            if (u < v)\n-                u += x;\n-            else \/\/ u > v\n-                v += y;\n-        }\n-\n-        return u;\n-    }\n-\n-    \/\/ calculate temporary direct buffer size\n-    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n-        int bufferSize = MIN_BUFFER_SIZE;\n-        try {\n-            long bss = UnixFileStoreAttributes.get(source).blockSize();\n-            long bst = UnixFileStoreAttributes.get(target).blockSize();\n-            if (bss > 0 && bst > 0) {\n-                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n-            }\n-            if (bufferSize < MIN_BUFFER_SIZE) {\n-                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n-                bufferSize *= factor;\n-            }\n-        } catch (UnixException ignored) {\n-        }\n-        return bufferSize;\n-    }\n-\n-    \/\/ whether direct copying is supported on this platform\n-    private static volatile boolean directCopyNotSupported;\n-\n-    protected UnixCopyFile() {  }\n-\n-    \/\/ The flags that control how a file is copied or moved\n-    private static class Flags {\n-        boolean replaceExisting;\n-        boolean atomicMove;\n-        boolean followLinks;\n-        boolean interruptible;\n-\n-        \/\/ the attributes to copy\n-        boolean copyBasicAttributes;\n-        boolean copyPosixAttributes;\n-        boolean copyNonPosixAttributes;\n-\n-        \/\/ flags that indicate if we should fail if attributes cannot be copied\n-        boolean failIfUnableToCopyBasic;\n-        boolean failIfUnableToCopyPosix;\n-        boolean failIfUnableToCopyNonPosix;\n-\n-        static Flags fromCopyOptions(CopyOption... options) {\n-            Flags flags = new Flags();\n-            flags.followLinks = true;\n-            for (CopyOption option: options) {\n-                if (option == StandardCopyOption.REPLACE_EXISTING) {\n-                    flags.replaceExisting = true;\n-                    continue;\n-                }\n-                if (option == LinkOption.NOFOLLOW_LINKS) {\n-                    flags.followLinks = false;\n-                    continue;\n-                }\n-                if (option == StandardCopyOption.COPY_ATTRIBUTES) {\n-                    \/\/ copy all attributes but only fail if basic attributes\n-                    \/\/ cannot be copied\n-                    flags.copyBasicAttributes = true;\n-                    flags.copyPosixAttributes = true;\n-                    flags.copyNonPosixAttributes = true;\n-                    flags.failIfUnableToCopyBasic = true;\n-                    continue;\n-                }\n-                if (ExtendedOptions.INTERRUPTIBLE.matches(option)) {\n-                    flags.interruptible = true;\n-                    continue;\n-                }\n-                if (option == null)\n-                    throw new NullPointerException();\n-                throw new UnsupportedOperationException(\"Unsupported copy option\");\n-            }\n-            return flags;\n-        }\n-\n-        static Flags fromMoveOptions(CopyOption... options) {\n-            Flags flags = new Flags();\n-            for (CopyOption option: options) {\n-                if (option == StandardCopyOption.ATOMIC_MOVE) {\n-                    flags.atomicMove = true;\n-                    continue;\n-                }\n-                if (option == StandardCopyOption.REPLACE_EXISTING) {\n-                    flags.replaceExisting = true;\n-                    continue;\n-                }\n-                if (option == LinkOption.NOFOLLOW_LINKS) {\n-                    \/\/ ignore\n-                    continue;\n-                }\n-                if (option == null)\n-                    throw new NullPointerException();\n-                throw new UnsupportedOperationException(\"Unsupported copy option\");\n-            }\n-\n-            \/\/ a move requires that all attributes be copied but only fail if\n-            \/\/ the basic attributes cannot be copied\n-            flags.copyBasicAttributes = true;\n-            flags.copyPosixAttributes = true;\n-            flags.copyNonPosixAttributes = true;\n-            flags.failIfUnableToCopyBasic = true;\n-            return flags;\n-        }\n-    }\n-\n-    \/\/ copy directory from source to target\n-    private void copyDirectory(UnixPath source,\n-                               UnixFileAttributes attrs,\n-                               UnixPath target,\n-                               Flags flags)\n-        throws IOException\n-    {\n-        try {\n-            mkdir(target, attrs.mode());\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(target);\n-        }\n-\n-        \/\/ no attributes to copy\n-        if (!flags.copyBasicAttributes &&\n-            !flags.copyPosixAttributes &&\n-            !flags.copyNonPosixAttributes) return;\n-\n-        \/\/ open target directory if possible (this can fail when copying a\n-        \/\/ directory for which we don't have read access).\n-        int dfd = -1;\n-        try {\n-            dfd = open(target, O_RDONLY, 0);\n-        } catch (UnixException x) {\n-            \/\/ access to target directory required to copy named attributes\n-            if (flags.copyNonPosixAttributes && flags.failIfUnableToCopyNonPosix) {\n-                try { rmdir(target); } catch (UnixException ignore) { }\n-                x.rethrowAsIOException(target);\n-            }\n-        }\n-\n-        boolean done = false;\n-        try {\n-            \/\/ copy owner\/group\/permissions\n-            if (flags.copyPosixAttributes){\n-                try {\n-                    if (dfd >= 0) {\n-                        fchown(dfd, attrs.uid(), attrs.gid());\n-                        fchmod(dfd, attrs.mode());\n-                    } else {\n-                        chown(target, attrs.uid(), attrs.gid());\n-                        chmod(target, attrs.mode());\n-                    }\n-                } catch (UnixException x) {\n-                    \/\/ unable to set owner\/group\n-                    if (flags.failIfUnableToCopyPosix)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            \/\/ copy other attributes\n-            if (flags.copyNonPosixAttributes && (dfd >= 0)) {\n-                int sfd = -1;\n-                try {\n-                    sfd = open(source, O_RDONLY, 0);\n-                } catch (UnixException x) {\n-                    if (flags.failIfUnableToCopyNonPosix)\n-                        x.rethrowAsIOException(source);\n-                }\n-                if (sfd >= 0) {\n-                    source.getFileSystem().copyNonPosixAttributes(sfd, dfd);\n-                    close(sfd, e -> null);\n-                }\n-            }\n-            \/\/ copy time stamps last\n-            if (flags.copyBasicAttributes) {\n-                try {\n-                    if (dfd >= 0 && futimesSupported()) {\n-                        futimes(dfd,\n-                                attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                    } else {\n-                        utimes(target,\n-                               attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                               attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                    }\n-                } catch (UnixException x) {\n-                    \/\/ unable to set times\n-                    if (flags.failIfUnableToCopyBasic)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            done = true;\n-        } finally {\n-            if (dfd >= 0)\n-                close(dfd, e -> null);\n-            if (!done) {\n-                \/\/ rollback\n-                try { rmdir(target); } catch (UnixException ignore) { }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * a platform-specific function or system call possibly having kernel\n-     * support.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\n-     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n-     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n-     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n-     *         direct copying is not supported on this platform\n-     *\/\n-    protected int directCopy(int dst, int src, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        return IOStatus.UNSUPPORTED;\n-    }\n-\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * an intermediate temporary direct buffer.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param address the address of the temporary direct buffer's array\n-     * @param size the size of the temporary direct buffer's array\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\/\n-    protected void bufferedCopy(int dst, int src, long address,\n-                                int size, long addressToPollForCancel)\n-        throws UnixException\n-    {\n-        bufferedCopy0(dst, src, address, size, addressToPollForCancel);\n-    }\n-\n-    \/\/ copy regular file from source to target\n-    protected void copyFile(UnixPath source,\n-                            UnixFileAttributes attrs,\n-                            UnixPath  target,\n-                            UnixCopyFile.Flags flags,\n-                            long addressToPollForCancel)\n-        throws IOException\n-    {\n-        int fi = -1;\n-        try {\n-            fi = open(source, O_RDONLY, 0);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        try {\n-            \/\/ open new file\n-            int fo = -1;\n-            try {\n-                fo = open(target,\n-                           (O_WRONLY |\n-                            O_CREAT |\n-                            O_EXCL),\n-                           attrs.mode());\n-            } catch (UnixException x) {\n-                x.rethrowAsIOException(target);\n-            }\n-\n-            \/\/ set to true when file and attributes copied\n-            boolean complete = false;\n-            try {\n-                boolean copied = false;\n-                if (!directCopyNotSupported) {\n-                    \/\/ copy bytes to target using platform function\n-                    long comp = Blocker.begin();\n-                    try {\n-                        int res = directCopy(fo, fi, addressToPollForCancel);\n-                        if (res == 0) {\n-                            copied = true;\n-                        } else if (res == IOStatus.UNSUPPORTED) {\n-                            directCopyNotSupported = true;\n-                        }\n-                    } catch (UnixException x) {\n-                        x.rethrowAsIOException(source, target);\n-                    } finally {\n-                        Blocker.end(comp);\n-                    }\n-                }\n-\n-                if (!copied) {\n-                    \/\/ copy bytes to target via a temporary direct buffer\n-                    int bufferSize = temporaryBufferSize(source, target);\n-                    ByteBuffer buf =\n-                        sun.nio.ch.Util.getTemporaryDirectBuffer(bufferSize);\n-                    try {\n-                        long comp = Blocker.begin();\n-                        try {\n-                            bufferedCopy(fo, fi, ((DirectBuffer)buf).address(),\n-                                          bufferSize, addressToPollForCancel);\n-                        } catch (UnixException x) {\n-                            x.rethrowAsIOException(source, target);\n-                        } finally {\n-                            Blocker.end(comp);\n-                        }\n-                    } finally {\n-                        sun.nio.ch.Util.releaseTemporaryDirectBuffer(buf);\n-                    }\n-                }\n-\n-                \/\/ copy owner\/permissions\n-                if (flags.copyPosixAttributes) {\n-                    try {\n-                        fchown(fo, attrs.uid(), attrs.gid());\n-                        fchmod(fo, attrs.mode());\n-                    } catch (UnixException x) {\n-                        if (flags.failIfUnableToCopyPosix)\n-                            x.rethrowAsIOException(target);\n-                    }\n-                }\n-                \/\/ copy non POSIX attributes (depends on file system)\n-                if (flags.copyNonPosixAttributes) {\n-                    source.getFileSystem().copyNonPosixAttributes(fi, fo);\n-                }\n-                \/\/ copy time attributes\n-                if (flags.copyBasicAttributes) {\n-                    try {\n-                        if (futimesSupported()) {\n-                            futimes(fo,\n-                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        } else {\n-                            utimes(target,\n-                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                        }\n-                    } catch (UnixException x) {\n-                        if (flags.failIfUnableToCopyBasic)\n-                            x.rethrowAsIOException(target);\n-                    }\n-                }\n-                complete = true;\n-            } finally {\n-                close(fo, e -> null);\n-\n-                \/\/ copy of file or attributes failed so rollback\n-                if (!complete) {\n-                    try {\n-                        unlink(target);\n-                    } catch (UnixException ignore) { }\n-                }\n-            }\n-        } finally {\n-            close(fi, e -> null);\n-        }\n-    }\n-\n-    \/\/ copy symbolic link from source to target\n-    private void copyLink(UnixPath source,\n-                          UnixFileAttributes attrs,\n-                          UnixPath  target,\n-                          Flags flags)\n-        throws IOException\n-    {\n-        byte[] linktarget = null;\n-        try {\n-            linktarget = readlink(source);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-        try {\n-            symlink(linktarget, target);\n-\n-            if (flags.copyPosixAttributes) {\n-                try {\n-                    lchown(target, attrs.uid(), attrs.gid());\n-                } catch (UnixException x) {\n-                    \/\/ ignore since link attributes not required to be copied\n-                }\n-            }\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(target);\n-        }\n-    }\n-\n-    \/\/ copy special file from source to target\n-    private void copySpecial(UnixPath source,\n-                             UnixFileAttributes attrs,\n-                             UnixPath  target,\n-                             Flags flags)\n-        throws IOException\n-    {\n-        try {\n-            mknod(target, attrs.mode(), attrs.rdev());\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(target);\n-        }\n-        boolean done = false;\n-        try {\n-            if (flags.copyPosixAttributes) {\n-                try {\n-                    chown(target, attrs.uid(), attrs.gid());\n-                    chmod(target, attrs.mode());\n-                } catch (UnixException x) {\n-                    if (flags.failIfUnableToCopyPosix)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            if (flags.copyBasicAttributes) {\n-                try {\n-                    utimes(target,\n-                           attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n-                           attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n-                } catch (UnixException x) {\n-                    if (flags.failIfUnableToCopyBasic)\n-                        x.rethrowAsIOException(target);\n-                }\n-            }\n-            done = true;\n-        } finally {\n-            if (!done) {\n-                try { unlink(target); } catch (UnixException ignore) { }\n-            }\n-        }\n-    }\n-\n-    \/\/ throw a DirectoryNotEmpty exception if appropriate\n-    static void ensureEmptyDir(UnixPath dir) throws IOException {\n-        try {\n-            long ptr = opendir(dir);\n-            try (UnixDirectoryStream stream =\n-                new UnixDirectoryStream(dir, ptr, e -> true)) {\n-                if (stream.iterator().hasNext()) {\n-                    throw new DirectoryNotEmptyException(\n-                        dir.getPathForExceptionMessage());\n-                }\n-            }\n-        } catch (UnixException e) {\n-            e.rethrowAsIOException(dir);\n-        }\n-    }\n-\n-    \/\/ move file from source to target\n-    void move(UnixPath source, UnixPath target, CopyOption... options)\n-        throws IOException\n-    {\n-        \/\/ permission check\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            source.checkWrite();\n-            target.checkWrite();\n-        }\n-\n-        \/\/ translate options into flags\n-        Flags flags = Flags.fromMoveOptions(options);\n-\n-        \/\/ handle atomic rename case\n-        if (flags.atomicMove) {\n-            try {\n-                rename(source, target);\n-            } catch (UnixException x) {\n-                if (x.errno() == EXDEV) {\n-                    throw new AtomicMoveNotSupportedException(\n-                        source.getPathForExceptionMessage(),\n-                        target.getPathForExceptionMessage(),\n-                        x.errorString());\n-                }\n-                x.rethrowAsIOException(source, target);\n-            }\n-            return;\n-        }\n-\n-        \/\/ move using rename or copy+delete\n-        UnixFileAttributes sourceAttrs = null;\n-        UnixFileAttributes targetAttrs = null;\n-\n-        \/\/ get attributes of source file (don't follow links)\n-        try {\n-            sourceAttrs = UnixFileAttributes.get(source, false);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        \/\/ get attributes of target file (don't follow links)\n-        try {\n-            targetAttrs = UnixFileAttributes.get(target, false);\n-        } catch (UnixException x) {\n-            \/\/ ignore\n-        }\n-        boolean targetExists = (targetAttrs != null);\n-\n-        \/\/ if the target exists:\n-        \/\/ 1. check if source and target are the same file\n-        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n-        \/\/ 3. delete target if REPLACE_EXISTING option set\n-        if (targetExists) {\n-            if (sourceAttrs.isSameFile(targetAttrs))\n-                return;  \/\/ nothing to do as files are identical\n-            if (!flags.replaceExisting) {\n-                throw new FileAlreadyExistsException(\n-                    target.getPathForExceptionMessage());\n-            }\n-\n-            \/\/ attempt to delete target\n-            try {\n-                if (targetAttrs.isDirectory()) {\n-                    rmdir(target);\n-                } else {\n-                    unlink(target);\n-                }\n-            } catch (UnixException x) {\n-                \/\/ target is non-empty directory that can't be replaced.\n-                if (targetAttrs.isDirectory() &&\n-                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n-                {\n-                    throw new DirectoryNotEmptyException(\n-                        target.getPathForExceptionMessage());\n-                }\n-                x.rethrowAsIOException(target);\n-            }\n-        }\n-\n-        \/\/ first try rename\n-        try {\n-            rename(source, target);\n-            return;\n-        } catch (UnixException x) {\n-            if (x.errno() != EXDEV && x.errno() != EISDIR) {\n-                x.rethrowAsIOException(source, target);\n-            }\n-        }\n-\n-        \/\/ copy source to target\n-        if (sourceAttrs.isDirectory()) {\n-            ensureEmptyDir(source);\n-            copyDirectory(source, sourceAttrs, target, flags);\n-        } else {\n-            if (sourceAttrs.isSymbolicLink()) {\n-                copyLink(source, sourceAttrs, target, flags);\n-            } else {\n-                if (sourceAttrs.isDevice()) {\n-                    copySpecial(source, sourceAttrs, target, flags);\n-                } else {\n-                    copyFile(source, sourceAttrs, target, flags, 0L);\n-                }\n-            }\n-        }\n-\n-        \/\/ delete source\n-        try {\n-            if (sourceAttrs.isDirectory()) {\n-                rmdir(source);\n-            } else {\n-                unlink(source);\n-            }\n-        } catch (UnixException x) {\n-            \/\/ file was copied but unable to unlink the source file so attempt\n-            \/\/ to remove the target and throw a reasonable exception\n-            try {\n-                if (sourceAttrs.isDirectory()) {\n-                    rmdir(target);\n-                } else {\n-                    unlink(target);\n-                }\n-            } catch (UnixException ignore) { }\n-\n-            if (sourceAttrs.isDirectory() &&\n-                (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n-            {\n-                throw new DirectoryNotEmptyException(\n-                    source.getPathForExceptionMessage());\n-            }\n-            x.rethrowAsIOException(source);\n-        }\n-    }\n-\n-    \/\/ copy file from source to target\n-    void copy(final UnixPath source,\n-              final UnixPath target,\n-              CopyOption... options) throws IOException\n-    {\n-        \/\/ permission checks\n-        @SuppressWarnings(\"removal\")\n-        SecurityManager sm = System.getSecurityManager();\n-        if (sm != null) {\n-            source.checkRead();\n-            target.checkWrite();\n-        }\n-\n-        \/\/ translate options into flags\n-        final Flags flags = Flags.fromCopyOptions(options);\n-\n-        UnixFileAttributes sourceAttrs = null;\n-        UnixFileAttributes targetAttrs = null;\n-\n-        \/\/ get attributes of source file\n-        try {\n-            sourceAttrs = UnixFileAttributes.get(source, flags.followLinks);\n-        } catch (UnixException x) {\n-            x.rethrowAsIOException(source);\n-        }\n-\n-        \/\/ if source file is symbolic link then we must check LinkPermission\n-        if (sm != null && sourceAttrs.isSymbolicLink()) {\n-            sm.checkPermission(new LinkPermission(\"symbolic\"));\n-        }\n-\n-        \/\/ get attributes of target file (don't follow links)\n-        try {\n-            targetAttrs = UnixFileAttributes.get(target, false);\n-        } catch (UnixException x) {\n-            \/\/ ignore\n-        }\n-        boolean targetExists = (targetAttrs != null);\n-\n-        \/\/ if the target exists:\n-        \/\/ 1. check if source and target are the same file\n-        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n-        \/\/ 3. try to unlink the target\n-        if (targetExists) {\n-            if (sourceAttrs.isSameFile(targetAttrs))\n-                return;  \/\/ nothing to do as files are identical\n-            if (!flags.replaceExisting)\n-                throw new FileAlreadyExistsException(\n-                    target.getPathForExceptionMessage());\n-            try {\n-                if (targetAttrs.isDirectory()) {\n-                    rmdir(target);\n-                } else {\n-                    unlink(target);\n-                }\n-            } catch (UnixException x) {\n-                \/\/ target is non-empty directory that can't be replaced.\n-                if (targetAttrs.isDirectory() &&\n-                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n-                {\n-                    throw new DirectoryNotEmptyException(\n-                        target.getPathForExceptionMessage());\n-                }\n-                x.rethrowAsIOException(target);\n-            }\n-        }\n-\n-        \/\/ do the copy\n-        if (sourceAttrs.isDirectory()) {\n-            copyDirectory(source, sourceAttrs, target, flags);\n-            return;\n-        }\n-        if (sourceAttrs.isSymbolicLink()) {\n-            copyLink(source, sourceAttrs, target, flags);\n-            return;\n-        }\n-        if (!flags.interruptible) {\n-            \/\/ non-interruptible file copy\n-            copyFile(source, sourceAttrs, target, flags, 0L);\n-            return;\n-        }\n-\n-        \/\/ interruptible file copy\n-        final UnixFileAttributes attrsToCopy = sourceAttrs;\n-        Cancellable copyTask = new Cancellable() {\n-            @Override public void implRun() throws IOException {\n-                copyFile(source, attrsToCopy, target,\n-                         flags, addressToPollForCancel());\n-            }\n-        };\n-        try {\n-            Cancellable.runInterruptibly(copyTask);\n-        } catch (ExecutionException e) {\n-            Throwable t = e.getCause();\n-            if (t instanceof IOException)\n-                throw (IOException)t;\n-            throw new IOException(t);\n-        }\n-    }\n-\n-\n-    \/\/ -- native methods --\n-\n-    private static native void bufferedCopy0(int dst, int src, long address,\n-                                             int size, long addressToPollForCancel)\n-        throws UnixException;\n-}\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":0,"deletions":748,"binary":false,"changes":748,"status":"deleted"},{"patch":"@@ -29,0 +29,1 @@\n+import java.nio.file.AtomicMoveNotSupportedException;\n@@ -30,0 +31,2 @@\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.FileAlreadyExistsException;\n@@ -32,0 +35,2 @@\n+import java.nio.file.LinkOption;\n+import java.nio.file.LinkPermission;\n@@ -34,0 +39,1 @@\n+import java.nio.file.StandardCopyOption;\n@@ -45,0 +51,1 @@\n+import java.util.concurrent.ExecutionException;\n@@ -65,1 +72,0 @@\n-    private final UnixCopyFile copier;\n@@ -67,2 +73,2 @@\n-    protected UnixFileSystem(UnixFileSystemProvider provider, String dir,\n-                             UnixCopyFile copier) {\n+    \/\/ package-private\n+    UnixFileSystem(UnixFileSystemProvider provider, String dir) {\n@@ -99,8 +105,0 @@\n-\n-        \/\/ the copy and move implementation\n-        this.copier = copier != null ? copier : new UnixCopyFile();\n-    }\n-\n-    \/\/ package-private\n-    UnixFileSystem(UnixFileSystemProvider provider, String dir) {\n-        this(provider, dir, new UnixCopyFile());\n@@ -151,14 +149,0 @@\n-    \/\/ copy file from source to target\n-    void copy(UnixPath source, UnixPath target, CopyOption... options)\n-        throws IOException\n-    {\n-        copier.copy(source, target, options);\n-    }\n-\n-    \/\/ move file from source to target\n-    void move(UnixPath source, UnixPath target, CopyOption... options)\n-        throws IOException\n-    {\n-        copier.move(source, target, options);\n-    }\n-\n@@ -399,0 +383,699 @@\n+\n+    \/\/  Unix implementation of Files#copy and Files#move methods.\n+\n+    \/\/ minimum size of a temporary direct buffer\n+    private static final int MIN_BUFFER_SIZE = 16384;\n+\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        assert x > 0 && y > 0 : \"Non-positive parameter\";\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ calculate temporary direct buffer size\n+    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n+        int bufferSize = MIN_BUFFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (bufferSize < MIN_BUFFER_SIZE) {\n+                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n+                bufferSize *= factor;\n+            }\n+        } catch (UnixException ignored) {\n+        }\n+        return bufferSize;\n+    }\n+\n+    \/\/ whether direct copying is supported on this platform\n+    private static volatile boolean directCopyNotSupported;\n+\n+    \/\/ The flags that control how a file is copied or moved\n+    private static class Flags {\n+        boolean replaceExisting;\n+        boolean atomicMove;\n+        boolean followLinks;\n+        boolean interruptible;\n+\n+        \/\/ the attributes to copy\n+        boolean copyBasicAttributes;\n+        boolean copyPosixAttributes;\n+        boolean copyNonPosixAttributes;\n+\n+        \/\/ flags that indicate if we should fail if attributes cannot be copied\n+        boolean failIfUnableToCopyBasic;\n+        boolean failIfUnableToCopyPosix;\n+        boolean failIfUnableToCopyNonPosix;\n+\n+        static Flags fromCopyOptions(CopyOption... options) {\n+            Flags flags = new Flags();\n+            flags.followLinks = true;\n+            for (CopyOption option: options) {\n+                if (option == StandardCopyOption.REPLACE_EXISTING) {\n+                    flags.replaceExisting = true;\n+                    continue;\n+                }\n+                if (option == LinkOption.NOFOLLOW_LINKS) {\n+                    flags.followLinks = false;\n+                    continue;\n+                }\n+                if (option == StandardCopyOption.COPY_ATTRIBUTES) {\n+                    \/\/ copy all attributes but only fail if basic attributes\n+                    \/\/ cannot be copied\n+                    flags.copyBasicAttributes = true;\n+                    flags.copyPosixAttributes = true;\n+                    flags.copyNonPosixAttributes = true;\n+                    flags.failIfUnableToCopyBasic = true;\n+                    continue;\n+                }\n+                if (ExtendedOptions.INTERRUPTIBLE.matches(option)) {\n+                    flags.interruptible = true;\n+                    continue;\n+                }\n+                if (option == null)\n+                    throw new NullPointerException();\n+                throw new UnsupportedOperationException(\"Unsupported copy option\");\n+            }\n+            return flags;\n+        }\n+\n+        static Flags fromMoveOptions(CopyOption... options) {\n+            Flags flags = new Flags();\n+            for (CopyOption option: options) {\n+                if (option == StandardCopyOption.ATOMIC_MOVE) {\n+                    flags.atomicMove = true;\n+                    continue;\n+                }\n+                if (option == StandardCopyOption.REPLACE_EXISTING) {\n+                    flags.replaceExisting = true;\n+                    continue;\n+                }\n+                if (option == LinkOption.NOFOLLOW_LINKS) {\n+                    \/\/ ignore\n+                    continue;\n+                }\n+                if (option == null)\n+                    throw new NullPointerException();\n+                throw new UnsupportedOperationException(\"Unsupported copy option\");\n+            }\n+\n+            \/\/ a move requires that all attributes be copied but only fail if\n+            \/\/ the basic attributes cannot be copied\n+            flags.copyBasicAttributes = true;\n+            flags.copyPosixAttributes = true;\n+            flags.copyNonPosixAttributes = true;\n+            flags.failIfUnableToCopyBasic = true;\n+            return flags;\n+        }\n+    }\n+\n+    \/\/ copy directory from source to target\n+    private void copyDirectory(UnixPath source,\n+                               UnixFileAttributes attrs,\n+                               UnixPath target,\n+                               Flags flags)\n+        throws IOException\n+    {\n+        try {\n+            mkdir(target, attrs.mode());\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(target);\n+        }\n+\n+        \/\/ no attributes to copy\n+        if (!flags.copyBasicAttributes &&\n+            !flags.copyPosixAttributes &&\n+            !flags.copyNonPosixAttributes) return;\n+\n+        \/\/ open target directory if possible (this can fail when copying a\n+        \/\/ directory for which we don't have read access).\n+        int dfd = -1;\n+        try {\n+            dfd = open(target, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            \/\/ access to target directory required to copy named attributes\n+            if (flags.copyNonPosixAttributes && flags.failIfUnableToCopyNonPosix) {\n+                try { rmdir(target); } catch (UnixException ignore) { }\n+                x.rethrowAsIOException(target);\n+            }\n+        }\n+\n+        boolean done = false;\n+        try {\n+            \/\/ copy owner\/group\/permissions\n+            if (flags.copyPosixAttributes){\n+                try {\n+                    if (dfd >= 0) {\n+                        fchown(dfd, attrs.uid(), attrs.gid());\n+                        fchmod(dfd, attrs.mode());\n+                    } else {\n+                        chown(target, attrs.uid(), attrs.gid());\n+                        chmod(target, attrs.mode());\n+                    }\n+                } catch (UnixException x) {\n+                    \/\/ unable to set owner\/group\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            \/\/ copy other attributes\n+            if (flags.copyNonPosixAttributes && (dfd >= 0)) {\n+                int sfd = -1;\n+                try {\n+                    sfd = open(source, O_RDONLY, 0);\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyNonPosix)\n+                        x.rethrowAsIOException(source);\n+                }\n+                if (sfd >= 0) {\n+                    source.getFileSystem().copyNonPosixAttributes(sfd, dfd);\n+                    UnixNativeDispatcher.close(sfd, e -> null);\n+                }\n+            }\n+            \/\/ copy time stamps last\n+            if (flags.copyBasicAttributes) {\n+                try {\n+                    if (dfd >= 0 && futimesSupported()) {\n+                        futimes(dfd,\n+                                attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                    } else {\n+                        utimes(target,\n+                               attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                               attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                    }\n+                } catch (UnixException x) {\n+                    \/\/ unable to set times\n+                    if (flags.failIfUnableToCopyBasic)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            done = true;\n+        } finally {\n+            if (dfd >= 0)\n+                UnixNativeDispatcher.close(dfd, e -> null);\n+            if (!done) {\n+                \/\/ rollback\n+                try { rmdir(target); } catch (UnixException ignore) { }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n+     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n+     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n+     *         direct copying is not supported on this platform\n+     *\/\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return IOStatus.UNSUPPORTED;\n+    }\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * an intermediate temporary direct buffer.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param address the address of the temporary direct buffer's array\n+     * @param size the size of the temporary direct buffer's array\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\/\n+    protected void bufferedCopy(int dst, int src, long address,\n+                                int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        bufferedCopy0(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    \/\/ copy regular file from source to target\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath  target,\n+                            Flags flags,\n+                            long addressToPollForCancel)\n+        throws IOException\n+    {\n+        int fi = -1;\n+        try {\n+            fi = open(source, O_RDONLY, 0);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        try {\n+            \/\/ open new file\n+            int fo = -1;\n+            try {\n+                fo = open(target,\n+                           (O_WRONLY |\n+                            O_CREAT |\n+                            O_EXCL),\n+                           attrs.mode());\n+            } catch (UnixException x) {\n+                x.rethrowAsIOException(target);\n+            }\n+\n+            \/\/ set to true when file and attributes copied\n+            boolean complete = false;\n+            try {\n+                boolean copied = false;\n+                if (!directCopyNotSupported) {\n+                    \/\/ copy bytes to target using platform function\n+                    long comp = Blocker.begin();\n+                    try {\n+                        int res = directCopy(fo, fi, addressToPollForCancel);\n+                        if (res == 0) {\n+                            copied = true;\n+                        } else if (res == IOStatus.UNSUPPORTED) {\n+                            directCopyNotSupported = true;\n+                        }\n+                    } catch (UnixException x) {\n+                        x.rethrowAsIOException(source, target);\n+                    } finally {\n+                        Blocker.end(comp);\n+                    }\n+                }\n+\n+                if (!copied) {\n+                    \/\/ copy bytes to target via a temporary direct buffer\n+                    int bufferSize = temporaryBufferSize(source, target);\n+                    ByteBuffer buf =\n+                        sun.nio.ch.Util.getTemporaryDirectBuffer(bufferSize);\n+                    try {\n+                        long comp = Blocker.begin();\n+                        try {\n+                            bufferedCopy(fo, fi, ((DirectBuffer)buf).address(),\n+                                          bufferSize, addressToPollForCancel);\n+                        } catch (UnixException x) {\n+                            x.rethrowAsIOException(source, target);\n+                        } finally {\n+                            Blocker.end(comp);\n+                        }\n+                    } finally {\n+                        sun.nio.ch.Util.releaseTemporaryDirectBuffer(buf);\n+                    }\n+                }\n+\n+                \/\/ copy owner\/permissions\n+                if (flags.copyPosixAttributes) {\n+                    try {\n+                        fchown(fo, attrs.uid(), attrs.gid());\n+                        fchmod(fo, attrs.mode());\n+                    } catch (UnixException x) {\n+                        if (flags.failIfUnableToCopyPosix)\n+                            x.rethrowAsIOException(target);\n+                    }\n+                }\n+                \/\/ copy non POSIX attributes (depends on file system)\n+                if (flags.copyNonPosixAttributes) {\n+                    source.getFileSystem().copyNonPosixAttributes(fi, fo);\n+                }\n+                \/\/ copy time attributes\n+                if (flags.copyBasicAttributes) {\n+                    try {\n+                        if (futimesSupported()) {\n+                            futimes(fo,\n+                                    attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                    attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        } else {\n+                            utimes(target,\n+                                   attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                                   attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                        }\n+                    } catch (UnixException x) {\n+                        if (flags.failIfUnableToCopyBasic)\n+                            x.rethrowAsIOException(target);\n+                    }\n+                }\n+                complete = true;\n+            } finally {\n+                UnixNativeDispatcher.close(fo, e -> null);\n+\n+                \/\/ copy of file or attributes failed so rollback\n+                if (!complete) {\n+                    try {\n+                        unlink(target);\n+                    } catch (UnixException ignore) { }\n+                }\n+            }\n+        } finally {\n+            UnixNativeDispatcher.close(fi, e -> null);\n+        }\n+    }\n+\n+    \/\/ copy symbolic link from source to target\n+    private void copyLink(UnixPath source,\n+                          UnixFileAttributes attrs,\n+                          UnixPath  target,\n+                          Flags flags)\n+        throws IOException\n+    {\n+        byte[] linktarget = null;\n+        try {\n+            linktarget = readlink(source);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+        try {\n+            symlink(linktarget, target);\n+\n+            if (flags.copyPosixAttributes) {\n+                try {\n+                    lchown(target, attrs.uid(), attrs.gid());\n+                } catch (UnixException x) {\n+                    \/\/ ignore since link attributes not required to be copied\n+                }\n+            }\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(target);\n+        }\n+    }\n+\n+    \/\/ copy special file from source to target\n+    private void copySpecial(UnixPath source,\n+                             UnixFileAttributes attrs,\n+                             UnixPath  target,\n+                             Flags flags)\n+        throws IOException\n+    {\n+        try {\n+            mknod(target, attrs.mode(), attrs.rdev());\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(target);\n+        }\n+        boolean done = false;\n+        try {\n+            if (flags.copyPosixAttributes) {\n+                try {\n+                    chown(target, attrs.uid(), attrs.gid());\n+                    chmod(target, attrs.mode());\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyPosix)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            if (flags.copyBasicAttributes) {\n+                try {\n+                    utimes(target,\n+                           attrs.lastAccessTime().to(TimeUnit.MICROSECONDS),\n+                           attrs.lastModifiedTime().to(TimeUnit.MICROSECONDS));\n+                } catch (UnixException x) {\n+                    if (flags.failIfUnableToCopyBasic)\n+                        x.rethrowAsIOException(target);\n+                }\n+            }\n+            done = true;\n+        } finally {\n+            if (!done) {\n+                try { unlink(target); } catch (UnixException ignore) { }\n+            }\n+        }\n+    }\n+\n+    \/\/ throw a DirectoryNotEmpty exception if appropriate\n+    static void ensureEmptyDir(UnixPath dir) throws IOException {\n+        try {\n+            long ptr = opendir(dir);\n+            try (UnixDirectoryStream stream =\n+                new UnixDirectoryStream(dir, ptr, e -> true)) {\n+                if (stream.iterator().hasNext()) {\n+                    throw new DirectoryNotEmptyException(\n+                        dir.getPathForExceptionMessage());\n+                }\n+            }\n+        } catch (UnixException e) {\n+            e.rethrowAsIOException(dir);\n+        }\n+    }\n+\n+    \/\/ move file from source to target\n+    void move(UnixPath source, UnixPath target, CopyOption... options)\n+        throws IOException\n+    {\n+        \/\/ permission check\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            source.checkWrite();\n+            target.checkWrite();\n+        }\n+\n+        \/\/ translate options into flags\n+        Flags flags = Flags.fromMoveOptions(options);\n+\n+        \/\/ handle atomic rename case\n+        if (flags.atomicMove) {\n+            try {\n+                rename(source, target);\n+            } catch (UnixException x) {\n+                if (x.errno() == EXDEV) {\n+                    throw new AtomicMoveNotSupportedException(\n+                        source.getPathForExceptionMessage(),\n+                        target.getPathForExceptionMessage(),\n+                        x.errorString());\n+                }\n+                x.rethrowAsIOException(source, target);\n+            }\n+            return;\n+        }\n+\n+        \/\/ move using rename or copy+delete\n+        UnixFileAttributes sourceAttrs = null;\n+        UnixFileAttributes targetAttrs = null;\n+\n+        \/\/ get attributes of source file (don't follow links)\n+        try {\n+            sourceAttrs = UnixFileAttributes.get(source, false);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        \/\/ get attributes of target file (don't follow links)\n+        try {\n+            targetAttrs = UnixFileAttributes.get(target, false);\n+        } catch (UnixException x) {\n+            \/\/ ignore\n+        }\n+        boolean targetExists = (targetAttrs != null);\n+\n+        \/\/ if the target exists:\n+        \/\/ 1. check if source and target are the same file\n+        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n+        \/\/ 3. delete target if REPLACE_EXISTING option set\n+        if (targetExists) {\n+            if (sourceAttrs.isSameFile(targetAttrs))\n+                return;  \/\/ nothing to do as files are identical\n+            if (!flags.replaceExisting) {\n+                throw new FileAlreadyExistsException(\n+                    target.getPathForExceptionMessage());\n+            }\n+\n+            \/\/ attempt to delete target\n+            try {\n+                if (targetAttrs.isDirectory()) {\n+                    rmdir(target);\n+                } else {\n+                    unlink(target);\n+                }\n+            } catch (UnixException x) {\n+                \/\/ target is non-empty directory that can't be replaced.\n+                if (targetAttrs.isDirectory() &&\n+                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n+                {\n+                    throw new DirectoryNotEmptyException(\n+                        target.getPathForExceptionMessage());\n+                }\n+                x.rethrowAsIOException(target);\n+            }\n+        }\n+\n+        \/\/ first try rename\n+        try {\n+            rename(source, target);\n+            return;\n+        } catch (UnixException x) {\n+            if (x.errno() != EXDEV && x.errno() != EISDIR) {\n+                x.rethrowAsIOException(source, target);\n+            }\n+        }\n+\n+        \/\/ copy source to target\n+        if (sourceAttrs.isDirectory()) {\n+            ensureEmptyDir(source);\n+            copyDirectory(source, sourceAttrs, target, flags);\n+        } else {\n+            if (sourceAttrs.isSymbolicLink()) {\n+                copyLink(source, sourceAttrs, target, flags);\n+            } else {\n+                if (sourceAttrs.isDevice()) {\n+                    copySpecial(source, sourceAttrs, target, flags);\n+                } else {\n+                    copyFile(source, sourceAttrs, target, flags, 0L);\n+                }\n+            }\n+        }\n+\n+        \/\/ delete source\n+        try {\n+            if (sourceAttrs.isDirectory()) {\n+                rmdir(source);\n+            } else {\n+                unlink(source);\n+            }\n+        } catch (UnixException x) {\n+            \/\/ file was copied but unable to unlink the source file so attempt\n+            \/\/ to remove the target and throw a reasonable exception\n+            try {\n+                if (sourceAttrs.isDirectory()) {\n+                    rmdir(target);\n+                } else {\n+                    unlink(target);\n+                }\n+            } catch (UnixException ignore) { }\n+\n+            if (sourceAttrs.isDirectory() &&\n+                (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n+            {\n+                throw new DirectoryNotEmptyException(\n+                    source.getPathForExceptionMessage());\n+            }\n+            x.rethrowAsIOException(source);\n+        }\n+    }\n+\n+    \/\/ copy file from source to target\n+    void copy(final UnixPath source,\n+              final UnixPath target,\n+              CopyOption... options) throws IOException\n+    {\n+        \/\/ permission checks\n+        @SuppressWarnings(\"removal\")\n+        SecurityManager sm = System.getSecurityManager();\n+        if (sm != null) {\n+            source.checkRead();\n+            target.checkWrite();\n+        }\n+\n+        \/\/ translate options into flags\n+        final Flags flags = Flags.fromCopyOptions(options);\n+\n+        UnixFileAttributes sourceAttrs = null;\n+        UnixFileAttributes targetAttrs = null;\n+\n+        \/\/ get attributes of source file\n+        try {\n+            sourceAttrs = UnixFileAttributes.get(source, flags.followLinks);\n+        } catch (UnixException x) {\n+            x.rethrowAsIOException(source);\n+        }\n+\n+        \/\/ if source file is symbolic link then we must check LinkPermission\n+        if (sm != null && sourceAttrs.isSymbolicLink()) {\n+            sm.checkPermission(new LinkPermission(\"symbolic\"));\n+        }\n+\n+        \/\/ get attributes of target file (don't follow links)\n+        try {\n+            targetAttrs = UnixFileAttributes.get(target, false);\n+        } catch (UnixException x) {\n+            \/\/ ignore\n+        }\n+        boolean targetExists = (targetAttrs != null);\n+\n+        \/\/ if the target exists:\n+        \/\/ 1. check if source and target are the same file\n+        \/\/ 2. throw exception if REPLACE_EXISTING option is not set\n+        \/\/ 3. try to unlink the target\n+        if (targetExists) {\n+            if (sourceAttrs.isSameFile(targetAttrs))\n+                return;  \/\/ nothing to do as files are identical\n+            if (!flags.replaceExisting)\n+                throw new FileAlreadyExistsException(\n+                    target.getPathForExceptionMessage());\n+            try {\n+                if (targetAttrs.isDirectory()) {\n+                    rmdir(target);\n+                } else {\n+                    unlink(target);\n+                }\n+            } catch (UnixException x) {\n+                \/\/ target is non-empty directory that can't be replaced.\n+                if (targetAttrs.isDirectory() &&\n+                   (x.errno() == EEXIST || x.errno() == ENOTEMPTY))\n+                {\n+                    throw new DirectoryNotEmptyException(\n+                        target.getPathForExceptionMessage());\n+                }\n+                x.rethrowAsIOException(target);\n+            }\n+        }\n+\n+        \/\/ do the copy\n+        if (sourceAttrs.isDirectory()) {\n+            copyDirectory(source, sourceAttrs, target, flags);\n+            return;\n+        }\n+        if (sourceAttrs.isSymbolicLink()) {\n+            copyLink(source, sourceAttrs, target, flags);\n+            return;\n+        }\n+        if (!flags.interruptible) {\n+            \/\/ non-interruptible file copy\n+            copyFile(source, sourceAttrs, target, flags, 0L);\n+            return;\n+        }\n+\n+        \/\/ interruptible file copy\n+        final UnixFileAttributes attrsToCopy = sourceAttrs;\n+        Cancellable copyTask = new Cancellable() {\n+            @Override public void implRun() throws IOException {\n+                copyFile(source, attrsToCopy, target,\n+                         flags, addressToPollForCancel());\n+            }\n+        };\n+        try {\n+            Cancellable.runInterruptibly(copyTask);\n+        } catch (ExecutionException e) {\n+            Throwable t = e.getCause();\n+            if (t instanceof IOException)\n+                throw (IOException)t;\n+            throw new IOException(t);\n+        }\n+    }\n+\n+\n+    \/\/ -- native methods --\n+\n+    private static native void bufferedCopy0(int dst, int src, long address,\n+                                             int size, long addressToPollForCancel)\n+        throws UnixException;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":708,"deletions":25,"binary":false,"changes":733,"status":"modified"}]}