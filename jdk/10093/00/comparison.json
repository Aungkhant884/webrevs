{"files":[{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+import java.nio.file.*;\n+import java.io.IOException;\n+import java.util.*;\n+import static sun.nio.fs.LinuxNativeDispatcher.*;\n+import static sun.nio.fs.UnixConstants.*;\n+\n+\/**\n+ * Linux implementation of UnixCopyFile\n+ *\/\n+\n+class LinuxCopyFile extends UnixCopyFile {\n+    LinuxCopyFile() {\n+        super();\n+    }\n+\n+    @Override\n+    protected void bufferedCopy(int dst, int src, long address,\n+                                int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        super.bufferedCopy(dst, src, address, size, addressToPollForCancel);\n+    }\n+\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n+                     POSIX_FADV_NOREUSE    | \/\/ will access only once\n+                     POSIX_FADV_WILLNEED;    \/\/ will access in near future\n+        posix_fadvise(src, 0, 0, advice);\n+\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, UNAVAILABLE if the platform function would block,\n+     *         UNSUPPORTED_CASE if the call does not work with the given\n+     *         parameters, or UNSUPPORTED if direct copying is not supported\n+     *         on this platform\n+     *\/\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n+}\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxCopyFile.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,2 @@\n-import java.nio.file.*;\n+import java.nio.file.FileStore;\n+import java.nio.file.WatchService;\n@@ -30,1 +31,5 @@\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n@@ -39,1 +44,1 @@\n-        super(provider, dir);\n+        super(provider, dir, new LinuxCopyFile());\n@@ -124,2 +129,0 @@\n-\n-\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxFileSystem.java","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -65,0 +65,6 @@\n+    \/**\n+     * int posix_fadvise(int fd, off_t offset, off_t len, int advice);\n+     *\/\n+    static native int posix_fadvise(int fd, long offset, long len, int advice)\n+        throws UnixException;\n+\n","filename":"src\/java.base\/linux\/classes\/sun\/nio\/fs\/LinuxNativeDispatcher.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include <sys\/sendfile.h>\n+#include <fcntl.h>\n+\n+#include \"sun_nio_fs_LinuxCopyFile.h\"\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible,\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxCopyFile_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    \/\/ Transfer within the kernel\n+    const size_t count = cancel != NULL ?\n+        1048576 :   \/\/ 1 MB to give cancellation a chance\n+        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n+    ssize_t bytes_sent;\n+\n+    do {\n+        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n+        if (bytes_sent < 0) {\n+            if (errno == EAGAIN)\n+                return IOS_UNAVAILABLE;\n+            if (errno == EINVAL || errno == ENOSYS)\n+                return IOS_UNSUPPORTED_CASE;\n+            throwUnixException(env, errno);\n+            return IOS_THROWN;\n+        }\n+        if (cancel != NULL && *cancel != 0) {\n+            throwUnixException(env, ECANCELED);\n+            return IOS_THROWN;\n+        }\n+    } while (bytes_sent > 0);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxCopyFile.c","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include <fcntl.h>\n@@ -142,1 +143,1 @@\n-    \/* FIXME - man page doesn't explain how errors are returned *\/\n+    \/\/ The endmntent() function always returns 1.\n@@ -145,0 +146,7 @@\n+\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_LinuxNativeDispatcher_posix_1fadvise(JNIEnv* env, jclass this,\n+    jint fd, jlong offset, jlong len, jint advice)\n+{\n+    return posix_fadvise((int)fd, (off_t)offset, (off_t)len, (int)advice);\n+}\n","filename":"src\/java.base\/linux\/native\/libnio\/fs\/LinuxNativeDispatcher.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.nio.fs;\n+\n+\/**\n+ * Bsd implementation of UnixCopyFile\n+ *\/\n+\n+class BsdCopyFile extends UnixCopyFile {\n+\n+    BsdCopyFile() {\n+        super();\n+    }\n+\n+    @Override\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return directCopy0(dst, src, addressToPollForCancel);\n+    }\n+\n+    \/\/ -- native methods --\n+\n+    private static native int directCopy0(int dst, int src,\n+                                          long addressToPollForCancel)\n+        throws UnixException;\n+}\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdCopyFile.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.nio.file.*;\n@@ -30,1 +29,2 @@\n-import java.util.*;\n+import java.nio.file.FileStore;\n+import java.nio.file.WatchService;\n@@ -32,0 +32,4 @@\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n@@ -41,1 +45,1 @@\n-        super(provider, dir);\n+        super(provider, dir, new BsdCopyFile());\n","filename":"src\/java.base\/macosx\/classes\/sun\/nio\/fs\/BsdFileSystem.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+#include \"jni_util.h\"\n+#include \"jlong.h\"\n+\n+#include \"nio.h\"\n+\n+#include <stdlib.h>\n+#include <unistd.h>\n+#include <errno.h>\n+\n+#include <copyfile.h>\n+#include \"sun_nio_fs_BsdCopyFile.h\"\n+\n+#define RESTARTABLE(_cmd, _result) do { \\\n+  do { \\\n+    _result = _cmd; \\\n+  } while((_result == -1) && (errno == EINTR)); \\\n+} while(0)\n+\n+static void throwUnixException(JNIEnv* env, int errnum) {\n+    jobject x = JNU_NewObjectByName(env, \"sun\/nio\/fs\/UnixException\",\n+        \"(I)V\", errnum);\n+    if (x != NULL) {\n+        (*env)->Throw(env, x);\n+    }\n+}\n+\n+int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n+    const char* src, const char* dst, void* cancel)\n+{\n+    if (what == COPYFILE_COPY_DATA) {\n+        if (stage == COPYFILE_ERR\n+                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n+            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n+            \/\/ or to the appropriate error number if there is an error,\n+            \/\/ but in either case we need to quit.\n+            return COPYFILE_QUIT;\n+        }\n+    }\n+    return COPYFILE_CONTINUE;\n+}\n+\n+\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n+\/\/ and return zero, otherwise return the appropriate status code.\n+\/\/\n+\/\/ Return value\n+\/\/   0 on success\n+\/\/   IOS_UNAVAILABLE if the platform function would block\n+\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n+\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n+\/\/   IOS_THROWN if a Java exception is thrown\n+\/\/\n+JNIEXPORT jint JNICALL\n+Java_sun_nio_fs_BsdCopyFile_directCopy0\n+    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n+{\n+    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n+\n+    copyfile_state_t state;\n+    if (cancel != NULL) {\n+        state = copyfile_state_alloc();\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n+        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n+    } else {\n+        state = NULL;\n+    }\n+    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n+        int errno_fcopyfile = errno;\n+        if (state != NULL)\n+            copyfile_state_free(state);\n+        throwUnixException(env, errno_fcopyfile);\n+        return IOS_THROWN;\n+    }\n+    if (state != NULL)\n+        copyfile_state_free(state);\n+\n+    return 0;\n+}\n","filename":"src\/java.base\/macosx\/native\/libnio\/fs\/BsdCopyFile.c","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -146,1 +146,0 @@\n-    \/\/ flags used with setattrlist\n@@ -148,0 +147,1 @@\n+    \/\/ flags used with setattrlist\n@@ -159,0 +159,7 @@\n+\n+#ifdef __linux__\n+    \/\/ advice flags used with posix_fadvise(2)\n+    static final int PREFIX_POSIX_FADV_SEQUENTIAL = POSIX_FADV_SEQUENTIAL;\n+    static final int PREFIX_POSIX_FADV_NOREUSE    = POSIX_FADV_NOREUSE;\n+    static final int PREFIX_POSIX_FADV_WILLNEED   = POSIX_FADV_WILLNEED;\n+#endif\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixConstants.java.template","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import sun.nio.ch.Util;\n@@ -47,1 +46,1 @@\n- * Unix implementation of Path#copyTo and Path#moveTo methods.\n+ * Unix implementation of Files#copy and Files#move methods.\n@@ -54,1 +53,42 @@\n-    private UnixCopyFile() {  }\n+    \/\/ calculate the least common multiple of two values;\n+    \/\/ the parameters in general will be powers of two likely in the\n+    \/\/ range [4096, 65536] so this algorithm is expected to converge\n+    \/\/ when it is rarely called\n+    private static long lcm(long x, long y) {\n+        assert x > 0 && y > 0 : \"Non-positive parameter\";\n+\n+        long u = x;\n+        long v = y;\n+\n+        while (u != v) {\n+            if (u < v)\n+                u += x;\n+            else \/\/ u > v\n+                v += y;\n+        }\n+\n+        return u;\n+    }\n+\n+    \/\/ calculate temporary direct buffer size\n+    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n+        int bufferSize = MIN_BUFFER_SIZE;\n+        try {\n+            long bss = UnixFileStoreAttributes.get(source).blockSize();\n+            long bst = UnixFileStoreAttributes.get(target).blockSize();\n+            if (bss > 0 && bst > 0) {\n+                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n+            }\n+            if (bufferSize < MIN_BUFFER_SIZE) {\n+                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n+                bufferSize *= factor;\n+            }\n+        } catch (UnixException ignored) {\n+        }\n+        return bufferSize;\n+    }\n+\n+    \/\/ whether direct copying is supported on this platform\n+    private static volatile boolean directCopyNotSupported;\n+\n+    protected UnixCopyFile() {  }\n@@ -136,4 +176,4 @@\n-    private static void copyDirectory(UnixPath source,\n-                                      UnixFileAttributes attrs,\n-                                      UnixPath target,\n-                                      Flags flags)\n+    private void copyDirectory(UnixPath source,\n+                               UnixFileAttributes attrs,\n+                               UnixPath target,\n+                               Flags flags)\n@@ -227,18 +267,19 @@\n-    \/\/ calculate the least common multiple of two values;\n-    \/\/ the parameters in general will be powers of two likely in the\n-    \/\/ range [4096, 65536] so this algorithm is expected to converge\n-    \/\/ when it is rarely called\n-    private static long lcm(long x, long y) {\n-        assert x > 0 && y > 0 : \"Non-positive parameter\";\n-\n-        long u = x;\n-        long v = y;\n-\n-        while (u != v) {\n-            if (u < v)\n-                u += x;\n-            else \/\/ u > v\n-                v += y;\n-        }\n-\n-        return u;\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * a platform-specific function or system call possibly having kernel\n+     * support.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\n+     * @return 0 on success, IOStatus.UNAVAILABLE if the platform function\n+     *         would block, IOStatus.UNSUPPORTED_CASE if the call does not\n+     *         work with the given parameters, or IOStatus.UNSUPPORTED if\n+     *         direct copying is not supported on this platform\n+     *\/\n+    protected int directCopy(int dst, int src, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        return IOStatus.UNSUPPORTED;\n@@ -247,16 +288,16 @@\n-    \/\/ calculate temporary direct buffer size\n-    private static int temporaryBufferSize(UnixPath source, UnixPath target) {\n-        int bufferSize = MIN_BUFFER_SIZE;\n-        try {\n-            long bss = UnixFileStoreAttributes.get(source).blockSize();\n-            long bst = UnixFileStoreAttributes.get(target).blockSize();\n-            if (bss > 0 && bst > 0) {\n-                bufferSize = (int)(bss == bst ? bss : lcm(bss, bst));\n-            }\n-            if (bufferSize < MIN_BUFFER_SIZE) {\n-                int factor = (MIN_BUFFER_SIZE + bufferSize - 1)\/bufferSize;\n-                bufferSize *= factor;\n-            }\n-        } catch (UnixException ignored) {\n-        }\n-        return bufferSize;\n+    \/**\n+     * Copies data between file descriptors {@code src} and {@code dst} using\n+     * an intermediate temporary direct buffer.\n+     *\n+     * @param dst destination file descriptor\n+     * @param src source file descriptor\n+     * @param address the address of the temporary direct buffer's array\n+     * @param size the size of the temporary direct buffer's array\n+     * @param addressToPollForCancel address to check for cancellation\n+     *        (a non-zero value written to this address indicates cancel)\n+     *\/\n+    protected void bufferedCopy(int dst, int src, long address,\n+                                int size, long addressToPollForCancel)\n+        throws UnixException\n+    {\n+        bufferedCopy0(dst, src, address, size, addressToPollForCancel);\n@@ -265,3 +306,0 @@\n-    \/\/ whether direct copying is supported on this platform\n-    private static volatile boolean directCopyNotSupported;\n-\n@@ -269,5 +307,5 @@\n-    private static void copyFile(UnixPath source,\n-                                 UnixFileAttributes attrs,\n-                                 UnixPath  target,\n-                                 Flags flags,\n-                                 long addressToPollForCancel)\n+    protected void copyFile(UnixPath source,\n+                            UnixFileAttributes attrs,\n+                            UnixPath  target,\n+                            UnixCopyFile.Flags flags,\n+                            long addressToPollForCancel)\n@@ -304,1 +342,1 @@\n-                        int res = directCopy0(fo, fi, addressToPollForCancel);\n+                        int res = directCopy(fo, fi, addressToPollForCancel);\n@@ -320,1 +358,2 @@\n-                    ByteBuffer buf = Util.getTemporaryDirectBuffer(bufferSize);\n+                    ByteBuffer buf =\n+                        sun.nio.ch.Util.getTemporaryDirectBuffer(bufferSize);\n@@ -324,1 +363,1 @@\n-                            bufferedCopy0(fo, fi, ((DirectBuffer)buf).address(),\n+                            bufferedCopy(fo, fi, ((DirectBuffer)buf).address(),\n@@ -332,1 +371,1 @@\n-                        Util.releaseTemporaryDirectBuffer(buf);\n+                        sun.nio.ch.Util.releaseTemporaryDirectBuffer(buf);\n@@ -384,4 +423,4 @@\n-    private static void copyLink(UnixPath source,\n-                                 UnixFileAttributes attrs,\n-                                 UnixPath  target,\n-                                 Flags flags)\n+    private void copyLink(UnixPath source,\n+                          UnixFileAttributes attrs,\n+                          UnixPath  target,\n+                          Flags flags)\n@@ -412,4 +451,4 @@\n-    private static void copySpecial(UnixPath source,\n-                                    UnixFileAttributes attrs,\n-                                    UnixPath  target,\n-                                    Flags flags)\n+    private void copySpecial(UnixPath source,\n+                             UnixFileAttributes attrs,\n+                             UnixPath  target,\n+                             Flags flags)\n@@ -469,1 +508,1 @@\n-    static void move(UnixPath source, UnixPath target, CopyOption... options)\n+    void move(UnixPath source, UnixPath target, CopyOption... options)\n@@ -604,3 +643,3 @@\n-    static void copy(final UnixPath source,\n-                     final UnixPath target,\n-                     CopyOption... options) throws IOException\n+    void copy(final UnixPath source,\n+              final UnixPath target,\n+              CopyOption... options) throws IOException\n@@ -689,2 +728,2 @@\n-                copyFile(source, attrsToCopy, target, flags,\n-                    addressToPollForCancel());\n+                copyFile(source, attrsToCopy, target,\n+                         flags, addressToPollForCancel());\n@@ -703,1 +742,0 @@\n-    \/\/ -- native methods --\n@@ -705,18 +743,1 @@\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * a platform-specific function or system call possibly having kernel\n-     * support.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\n-     * @return 0 on success, UNAVAILABLE if the platform function would block,\n-     *         UNSUPPORTED_CASE if the call does not work with the given\n-     *         parameters, or UNSUPPORTED if direct copying is not supported\n-     *         on this platform\n-     *\/\n-    private static native int directCopy0(int dst, int src,\n-                                          long addressToPollForCancel)\n-        throws UnixException;\n+    \/\/ -- native methods --\n@@ -724,11 +745,0 @@\n-    \/**\n-     * Copies data between file descriptors {@code src} and {@code dst} using\n-     * an intermediate temporary direct buffer.\n-     *\n-     * @param dst destination file descriptor\n-     * @param src source file descriptor\n-     * @param address the address of the temporary direct buffer's array\n-     * @param size the size of the temporary direct buffer's array\n-     * @param addressToPollForCancel address to check for cancellation\n-     *        (a non-zero value written to this address indicates cancel)\n-     *\/\n@@ -738,5 +748,0 @@\n-\n-    static {\n-        jdk.internal.loader.BootLoader.loadLibrary(\"nio\");\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixCopyFile.java","additions":107,"deletions":102,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -28,2 +28,9 @@\n-import java.nio.file.*;\n-import java.nio.file.attribute.*;\n+import java.nio.ByteBuffer;\n+import java.nio.file.CopyOption;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.Path;\n+import java.nio.file.PathMatcher;\n+import java.nio.file.attribute.GroupPrincipal;\n+import java.nio.file.attribute.UserPrincipal;\n+import java.nio.file.attribute.UserPrincipalLookupService;\n@@ -32,1 +39,7 @@\n-import java.util.*;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +47,3 @@\n+import jdk.internal.misc.Blocker;\n+import sun.nio.ch.DirectBuffer;\n+import sun.nio.ch.IOStatus;\n@@ -35,0 +51,2 @@\n+import static sun.nio.fs.UnixConstants.*;\n+import static sun.nio.fs.UnixNativeDispatcher.*;\n@@ -47,0 +65,1 @@\n+    private final UnixCopyFile copier;\n@@ -48,2 +67,2 @@\n-    \/\/ package-private\n-    UnixFileSystem(UnixFileSystemProvider provider, String dir) {\n+    protected UnixFileSystem(UnixFileSystemProvider provider, String dir,\n+                             UnixCopyFile copier) {\n@@ -80,0 +99,8 @@\n+\n+        \/\/ the copy and move implementation\n+        this.copier = copier != null ? copier : new UnixCopyFile();\n+    }\n+\n+    \/\/ package-private\n+    UnixFileSystem(UnixFileSystemProvider provider, String dir) {\n+        this(provider, dir, new UnixCopyFile());\n@@ -124,0 +151,14 @@\n+    \/\/ copy file from source to target\n+    void copy(UnixPath source, UnixPath target, CopyOption... options)\n+        throws IOException\n+    {\n+        copier.copy(source, target, options);\n+    }\n+\n+    \/\/ move file from source to target\n+    void move(UnixPath source, UnixPath target, CopyOption... options)\n+        throws IOException\n+    {\n+        copier.move(source, target, options);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystem.java","additions":46,"deletions":5,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -28,6 +28,0 @@\n-import java.nio.file.*;\n-import java.nio.file.attribute.*;\n-import java.nio.file.spi.FileTypeDetector;\n-import java.nio.channels.*;\n-import java.net.URI;\n-import java.util.concurrent.ExecutorService;\n@@ -36,1 +30,30 @@\n-import java.util.*;\n+import java.net.URI;\n+import java.nio.channels.AsynchronousFileChannel;\n+import java.nio.channels.FileChannel;\n+import java.nio.channels.SeekableByteChannel;\n+import java.nio.file.AccessMode;\n+import java.nio.file.CopyOption;\n+import java.nio.file.DirectoryNotEmptyException;\n+import java.nio.file.DirectoryStream;\n+import java.nio.file.FileAlreadyExistsException;\n+import java.nio.file.FileStore;\n+import java.nio.file.FileSystem;\n+import java.nio.file.FileSystemAlreadyExistsException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.LinkPermission;\n+import java.nio.file.NotDirectoryException;\n+import java.nio.file.NotLinkException;\n+import java.nio.file.OpenOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.BasicFileAttributeView;\n+import java.nio.file.attribute.FileAttribute;\n+import java.nio.file.attribute.FileAttributeView;\n+import java.nio.file.attribute.FileOwnerAttributeView;\n+import java.nio.file.attribute.PosixFileAttributes;\n+import java.nio.file.attribute.PosixFileAttributeView;\n+import java.nio.file.spi.FileTypeDetector;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ExecutorService;\n@@ -277,3 +300,3 @@\n-        UnixCopyFile.copy(UnixPath.toUnixPath(source),\n-                          UnixPath.toUnixPath(target),\n-                          options);\n+        theFileSystem.copy(UnixPath.toUnixPath(source),\n+                           UnixPath.toUnixPath(target),\n+                           options);\n@@ -286,3 +309,3 @@\n-        UnixCopyFile.move(UnixPath.toUnixPath(source),\n-                          UnixPath.toUnixPath(target),\n-                          options);\n+        theFileSystem.move(UnixPath.toUnixPath(source),\n+                           UnixPath.toUnixPath(target),\n+                           options);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixFileSystemProvider.java","additions":36,"deletions":13,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -36,8 +36,0 @@\n-#if defined(__linux__)\n-#include <sys\/sendfile.h>\n-#include <fcntl.h>\n-#elif defined(_ALLBSD_SOURCE)\n-#include <copyfile.h>\n-#endif\n-#include \"sun_nio_fs_UnixCopyFile.h\"\n-\n@@ -58,17 +50,0 @@\n-#if defined(_ALLBSD_SOURCE)\n-int fcopyfile_callback(int what, int stage, copyfile_state_t state,\n-    const char* src, const char* dst, void* cancel)\n-{\n-    if (what == COPYFILE_COPY_DATA) {\n-        if (stage == COPYFILE_ERR\n-                || (stage == COPYFILE_PROGRESS && *((int*)cancel) != 0)) {\n-            \/\/ errno will be set to ECANCELED if the operation is cancelled,\n-            \/\/ or to the appropriate error number if there is an error,\n-            \/\/ but in either case we need to quit.\n-            return COPYFILE_QUIT;\n-        }\n-    }\n-    return COPYFILE_CONTINUE;\n-}\n-#endif\n-\n@@ -79,1 +54,1 @@\n-    jint transferSize, jlong cancelAddress)\n+     jint transferSize, jlong cancelAddress)\n@@ -85,9 +60,0 @@\n-#if defined(__linux__)\n-    int advice = POSIX_FADV_SEQUENTIAL | \/\/ sequential data access\n-                 POSIX_FADV_NOREUSE    | \/\/ will access only once\n-                 POSIX_FADV_WILLNEED;    \/\/ will access in near future\n-\n-    \/\/ ignore the return value hence any failure\n-    posix_fadvise(src, 0, 0, advice);\n-#endif\n-\n@@ -121,64 +87,0 @@\n-\n-\/\/ Copy all bytes from src to dst, within the kernel if possible (Linux),\n-\/\/ and return zero, otherwise return the appropriate status code.\n-\/\/\n-\/\/ Return value\n-\/\/   0 on success\n-\/\/   IOS_UNAVAILABLE if the platform function would block\n-\/\/   IOS_UNSUPPORTED_CASE if the call does not work with the given parameters\n-\/\/   IOS_UNSUPPORTED if direct copying is not supported on this platform\n-\/\/   IOS_THROWN if a Java exception is thrown\n-\/\/\n-JNIEXPORT jint JNICALL\n-Java_sun_nio_fs_UnixCopyFile_directCopy0\n-    (JNIEnv* env, jclass this, jint dst, jint src, jlong cancelAddress)\n-{\n-    volatile jint* cancel = (jint*)jlong_to_ptr(cancelAddress);\n-\n-#if defined(__linux__)\n-    \/\/ Transfer within the kernel\n-    const size_t count = cancel != NULL ?\n-        1048576 :   \/\/ 1 MB to give cancellation a chance\n-        0x7ffff000; \/\/ maximum number of bytes that sendfile() can transfer\n-    ssize_t bytes_sent;\n-    do {\n-        RESTARTABLE(sendfile64(dst, src, NULL, count), bytes_sent);\n-        if (bytes_sent < 0) {\n-            if (errno == EAGAIN)\n-                return IOS_UNAVAILABLE;\n-            if (errno == EINVAL || errno == ENOSYS)\n-                return IOS_UNSUPPORTED_CASE;\n-            throwUnixException(env, errno);\n-            return IOS_THROWN;\n-        }\n-        if (cancel != NULL && *cancel != 0) {\n-            throwUnixException(env, ECANCELED);\n-            return IOS_THROWN;\n-        }\n-    } while (bytes_sent > 0);\n-\n-    return 0;\n-#elif defined(_ALLBSD_SOURCE)\n-    copyfile_state_t state;\n-    if (cancel != NULL) {\n-        state = copyfile_state_alloc();\n-        copyfile_state_set(state, COPYFILE_STATE_STATUS_CB, fcopyfile_callback);\n-        copyfile_state_set(state, COPYFILE_STATE_STATUS_CTX, (void*)cancel);\n-    } else {\n-        state = NULL;\n-    }\n-    if (fcopyfile(src, dst, state, COPYFILE_DATA) < 0) {\n-        int errno_fcopyfile = errno;\n-        if (state != NULL)\n-            copyfile_state_free(state);\n-        throwUnixException(env, errno_fcopyfile);\n-        return IOS_THROWN;\n-    }\n-    if (state != NULL)\n-        copyfile_state_free(state);\n-\n-    return 0;\n-#else\n-    return IOS_UNSUPPORTED;\n-#endif\n-}\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixCopyFile.c","additions":1,"deletions":99,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8267820\n+ * @bug 4313887 6838333 6917021 7006126 6950237 8006645 8201407 8293121 8267820\n@@ -43,0 +43,2 @@\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n@@ -47,0 +49,5 @@\n+    \/\/ File system types that support copy-on-write (CoW)\n+    \/\/ for testing cloning \/ reflink on Linux\n+    private static final Set<String> COW_TYPES =\n+        Set.of(\"bcachefs\", \"btrfs\", \"ocfs2\", \"xfs\");\n+\n@@ -48,1 +55,0 @@\n-    static boolean heads() { return rand.nextBoolean(); }\n@@ -51,0 +57,44 @@\n+    static boolean heads() { return rand.nextBoolean(); }\n+\n+    \/**\n+     * Returns the secondary test directory as a path name string.\n+     * If the system property \"test.dir\" is definied it is returned.\n+     * Otherwise, if the platform is not Linux, the current directory\n+     * \".\" is returned. If the platform is Linux, then the first\n+     * located top level directory which supports CoW is returned. If\n+     * there is no such directory then \".\" is returned.\n+     *\n+     * @return the path string of the secondary test directory\n+     *\/\n+    private static final String getTestDir() {\n+        final String dot = \".\";\n+        if (!Platform.isLinux()) {\n+            return System.getProperty(\"test.dir\", dot);\n+        }\n+\n+        String testDir = System.getProperty(\"test.dir\");\n+        if (testDir != null) {\n+            return testDir;\n+        }\n+\n+        final Path dotPath = Path.of(dot);\n+        try {\n+            if (COW_TYPES.contains(getFileStore(dotPath).type().toLowerCase())) {\n+                return dot;\n+            }\n+        } catch (IOException ignored) {\n+        }\n+\n+        Spliterator<FileStore> spfs =\n+            FileSystems.getDefault().getFileStores().spliterator();\n+        Stream<FileStore> sfs = StreamSupport.stream(spfs, false);\n+        return sfs.filter(fs -> !fs.isReadOnly() &&\n+                                COW_TYPES.contains(fs.type().toLowerCase()))\n+                  .map(fs -> fs.toString().split(\" \")[0])\n+                  .map(s -> Path.of(s))\n+                  .filter(d -> Files.exists(d) && Files.isDirectory(d))\n+                  .findFirst()\n+                  .orElse(dotPath)\n+                  .toString();\n+    }\n+\n@@ -62,3 +112,3 @@\n-            \/\/ Different directories. Use test.dir if possible as it might be\n-            \/\/ a different volume\/file system and so improve test coverage.\n-            String testDir = System.getProperty(\"test.dir\", \".\");\n+            \/\/ Use test.dir to define second directory if possible as it might\n+            \/\/ be a different volume\/file system and so improve test coverage.\n+            String testDir = getTestDir();\n@@ -66,0 +116,16 @@\n+            FileStore fileStore2 = getFileStore(dir2);\n+\n+            \/\/ If different type (format) from dir1, re-do same directory tests\n+            if (!fileStore1.type().equals(fileStore2.type())) {\n+                try {\n+                    printDirInfo(\"dir2\", dir2, fileStore2);\n+                    testPosixAttributes =\n+                        fileStore2.supportsFileAttributeView(\"posix\");\n+                    testCopyFileToFile(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                    testMove(dir2, dir2, TestUtil.supportsLinks(dir2));\n+                } finally {\n+                    TestUtil.removeAll(dir2);\n+                }\n+            }\n+\n+            \/\/ Different directories.\n@@ -67,0 +133,4 @@\n+                \/\/ Recreate dir2 if it was removed above\n+                if (notExists(dir2)) {\n+                    dir2 = TestUtil.createTemporaryDirectory(testDir);\n+                }\n@@ -69,1 +139,0 @@\n-                FileStore fileStore2 = getFileStore(dir2);\n","filename":"test\/jdk\/java\/nio\/file\/Files\/CopyAndMove.java","additions":75,"deletions":6,"binary":false,"changes":81,"status":"modified"}]}