{"files":[{"patch":"@@ -1865,2 +1865,1 @@\n-     * Test Thread::getStackTrace on thread that has been started but\n-     * has not run.\n+     * Test Thread::getStackTrace on thread that has been started but has not run.\n@@ -1872,34 +1871,5 @@\n-        List<Thread> threads = new ArrayList<>();\n-        AtomicBoolean done = new AtomicBoolean();\n-        try {\n-            Thread target = null;\n-\n-            \/\/ start virtual threads that are CPU bound until we find a thread\n-            \/\/ that does not run. This is done while holding a monitor to\n-            \/\/ allow this test run in the context of a virtual thread.\n-            synchronized (this) {\n-                while (target == null) {\n-                    CountDownLatch latch = new CountDownLatch(1);\n-                    Thread vthread = Thread.ofVirtual().start(() -> {\n-                        latch.countDown();\n-                        while (!done.get()) { }\n-                    });\n-                    threads.add(vthread);\n-                    if (!latch.await(3, TimeUnit.SECONDS)) {\n-                        \/\/ thread did not run\n-                        target = vthread;\n-                    }\n-                }\n-            }\n-\n-            \/\/ stack trace should be empty\n-            StackTraceElement[] stack = target.getStackTrace();\n-            assertTrue(stack.length == 0);\n-        } finally {\n-            done.set(true);\n-\n-            \/\/ wait for threads to terminate\n-            for (Thread thread : threads) {\n-                thread.join();\n-            }\n-        }\n+        Executor scheduler = task -> { };\n+        Thread.Builder builder = ThreadBuilders.virtualThreadBuilder(scheduler);\n+        Thread thread = builder.start(() -> { });\n+        StackTraceElement[] stack = thread.getStackTrace();\n+        assertTrue(stack.length == 0);\n","filename":"test\/jdk\/java\/lang\/Thread\/virtual\/ThreadAPI.java","additions":6,"deletions":36,"binary":false,"changes":42,"status":"modified"}]}