{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import java.util.StringJoiner;\n@@ -96,0 +97,6 @@\n+    private static final boolean generateStableLambdaNames;\n+    private static final char paddingCharacter = '#';\n+\n+    \/\/ Length of a single hash contained in the stable lambda name\n+    private static final int stableLambdaNameHashLength;\n+\n@@ -107,0 +114,5 @@\n+        final String generateStableLambdaNameKey = \"jdk.internal.lambda.generateStableLambdaNames\";\n+        generateStableLambdaNames = GetBooleanAction.privilegedGetProperty(generateStableLambdaNameKey);\n+\n+        stableLambdaNameHashLength = hashValueString(Long.MAX_VALUE).length();\n+\n@@ -182,1 +194,1 @@\n-        lambdaClassName = lambdaClassName(targetClass);\n+        lambdaClassName = generateStableLambdaNames ? stableLambdaClassName(targetClass) : lambdaClassName(targetClass);\n@@ -207,0 +219,4 @@\n+        return createNameFromTargetClass(targetClass) + counter.incrementAndGet();\n+    }\n+\n+    private static String createNameFromTargetClass(Class<?> targetClass) {\n@@ -212,1 +228,76 @@\n-        return name.replace('.', '\/') + \"$$Lambda$\" + counter.incrementAndGet();\n+        return name.replace('.', '\/') + \"$$Lambda$\";\n+    }\n+\n+    private static String hashValueString(long hashValue) {\n+        return Long.toString(hashValue, Character.MAX_RADIX);\n+    }\n+    \/**\n+     * Calculate hash value of the given String in the same manner as the\n+     * java.lang.StringUTF16#hashCode does, except that hash value\n+     * is long instead of int.\n+     *\n+     * @param name String for which method calculates hash value for\n+     *\n+     * @return a hash value for the given String\n+     * *\/\n+    private String fixedSizeStringHash(String name) {\n+        long h = 0;\n+        int length = name.length();\n+        for (int i = 0; i < length; i++) {\n+            h = 31 * h + name.charAt(i);\n+        }\n+\n+        StringBuilder hash = new StringBuilder(hashValueString(Math.abs(h)));\n+        int hashLength = hash.length();\n+\n+        \/\/ As all the hashes contained in the stable lambda names should\n+        \/\/ be of the same length, we pad some of them with the special\n+        \/\/ character '#' which is never part of the hash value.\n+        while (hashLength != stableLambdaNameHashLength) {\n+            hash.append(paddingCharacter);\n+            hashLength++;\n+        }\n+\n+        return hash.toString();\n+    }\n+\n+    \/**\n+     * Creating stable name for lambda class.\n+     * Parameters that are used to create stable name\n+     * are a superset of the parameters that are used in\n+     * {@link java.lang.invoke.LambdaProxyClassArchive#addToArchive}\n+     * to store lambdas.\n+     *\n+     * @return a stable name for the created lambda class.\n+     *\/\n+    private String stableLambdaClassName(Class<?> targetClass) {\n+        String name = createNameFromTargetClass(targetClass);\n+\n+        StringBuilder hashData = new StringBuilder().append(interfaceMethodName);\n+        hashData.append(getQualifiedSignature(factoryType));\n+        hashData.append(getQualifiedSignature(interfaceMethodType));\n+        hashData.append(implementation.internalMemberName().toString());\n+        hashData.append(getQualifiedSignature(dynamicMethodType));\n+        hashData.append(isSerializable ? \"true\" : \"false\");\n+\n+        for (Class<?> clazz : altInterfaces) {\n+            hashData.append(clazz.getName());\n+        }\n+\n+        for (MethodType method : altMethods) {\n+            hashData.append(getQualifiedSignature(method));\n+        }\n+\n+        name += fixedSizeStringHash(hashData.toString());\n+\n+        return name;\n+    }\n+\n+    private String getQualifiedSignature(MethodType type) {\n+        StringJoiner sj = new StringJoiner(\",\", \"(\",\n+                \")\" + type.returnType().getName());\n+        Class<?>[] ptypes = type.ptypes();\n+        for (int i = 0; i < ptypes.length; i++) {\n+            sj.add(ptypes[i].getName());\n+        }\n+        return sj.toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":93,"deletions":2,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test if the names of the lambda classes are stable when {@code -Djdk.internal.lambda.generateStableLambdaNames}\n+ *          flag is set to true. This test directly calls java.lang.invoke.LambdaMetafactory#altMetafactory\n+ *          method to create multilple lambda instances and then checks their names stability. We created a\n+ *          multidimensional space of possible values for each parameter that\n+ *          {@link java.lang.invoke.LambdaMetafactory#altMetafactory} takes and then search that space by combining\n+ *          different values of those parameters. There is a rule we have to follow:\n+ *          Alternative methods of the specific method must have the same signature with difference in parameter types\n+ *          as long as the parameter of the alternative method is the superclass type of the type of corresponding parameter in\n+ *          original method\n+ * @run main\/othervm -Djdk.internal.lambda.generateStableLambdaNames=true TestStableLambdaNames\n+ *\/\n+\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.rmi.Remote;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+public class TestStableLambdaNames {\n+    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+    \/**\n+     * Different types of lambda classes based on value of flags parameter in the\n+     * {@link java.lang.invoke.LambdaMetafactory#altMetafactory}.\n+     * {@link java.lang.invoke.LambdaMetafactory#altMetafactory} uses bitwise and with this\n+     * parameter and predefined values to determine if lambda is serializable, has\n+     * altMethods and altInterfaces etc.\n+     *\/\n+    private enum lambdaType {\n+        NOT_SERIALIZABLE_NO_ALT_METHODS_NO_ALT_INTERFACES (0),\n+        SERIALIZABLE_ONLY (1),\n+        NOT_SERIALIZABLE_HAS_ALT_INTERFACES(2),\n+        SERIALIZABLE_HAS_ALT_INTERFACES(3),\n+        NOT_SERIALIZABLE_HAS_ALT_METHODS(4),\n+        SERIALIZABLE_HAS_ALT_METHODS(5),\n+        NOT_SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES(6),\n+        SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES(7);\n+\n+        private final int index;\n+        lambdaType(int i) {\n+            index = i;\n+        }\n+    }\n+\n+    private static final String[] interfaceMethods = {\"accept\", \"consume\", \"apply\", \"supply\", \"get\", \"test\", \"getAsBoolean\"};\n+    private static final Class<?>[] interfaces = {Consumer.class, Function.class, Predicate.class, Supplier.class, BooleanSupplier.class};\n+    \/** List of method types for defined methods *\/\n+    private static final MethodType[] methodTypes = {MethodType.methodType(String.class, Integer.class), MethodType.methodType(Throwable.class, AssertionError.class)};\n+    private static final Class<?>[] altInterfaces = {Cloneable.class, Remote.class};\n+    \/** Alternative methods that corresponds to method1 *\/\n+    private static final MethodType[] altMethodsMethod1 = {MethodType.methodType(String.class, Number.class)};\n+    \/** Alternative methods that corresponds to method2 *\/\n+    private static final MethodType[] altMethodsMethod2 = {MethodType.methodType(Throwable.class, Error.class), MethodType.methodType(Throwable.class, Throwable.class)};\n+\n+    private static String method1(Number number) {\n+        return String.valueOf(number);\n+    }\n+\n+    private static String method1(Integer number) { return String.valueOf(number); }\n+\n+    private static Throwable method2(AssertionError error) {\n+        return error;\n+    }\n+\n+    private static Throwable method2(Error error) {\n+        return error;\n+    }\n+\n+    private static Throwable method2(Throwable throwable) {\n+        return throwable;\n+    }\n+\n+    private static String removeHashFromLambdaName(String name) {\n+        return name.substring(0, name.indexOf(\"\/0x0\"));\n+    }\n+\n+    private static void createPlainLambdas(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                for (int i = 0; i < methodTypes.length; i++) {\n+                    Object lambda = LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                            methodTypes[i], methodHandles[i], methodTypes[i], flags).getTarget().invoke();\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Object lambdaWithOneAltInterface(String interfaceMethod, Class<?> interfaceClass, MethodType methodType, MethodHandle methodHandle, int flags, Class<?> altInterface) throws Throwable {\n+        int numOfAltInterfaces = 1;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltInterfaces, altInterface).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithMultipleAltInterfaces(String interfaceMethod, Class<?> interfaceClass,  MethodType methodType, MethodHandle methodHandle, int flags) throws Throwable {\n+        int numOfAltInterfaces = 2;\n+        int altInterfacesIndex = 0;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltInterfaces, altInterfaces[altInterfacesIndex++], altInterfaces[altInterfacesIndex]).getTarget().invoke();\n+    }\n+\n+    private static void createLambdasWithAltInterfaces(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        Object lambda;\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                for (int i = 0; i < methodTypes.length; i++) {\n+                    for (Class<?> altInterface : altInterfaces) {\n+                        lambda = lambdaWithOneAltInterface(interfaceMethod, interfaceClass, methodTypes[i], methodHandles[i], flags, altInterface);\n+                        lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                    }\n+\n+                    lambda = lambdaWithMultipleAltInterfaces(interfaceMethod, interfaceClass, methodTypes[i], methodHandles[i], flags);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Object lambdaWithOneAltMethod(String interfaceMethod, Class<?> interfaceClass,  MethodType methodType, MethodHandle methodHandle,\n+                                                 int flags, MethodType altMethod, MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltMethods = 1;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltMethods, altMethod).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithMultipleAltMethods(String interfaceMethod, Class<?> interfaceClass, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltMethods = 2;\n+        int indexOfAltMethod = 0;\n+        MethodType methodTypeMethod2 = methodTypes[1];\n+        MethodHandle methodHandleMethod2 = methodHandles[1];\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodTypeMethod2, methodHandleMethod2, methodTypeMethod2, flags, numOfAltMethods, altMethodsMethod2[indexOfAltMethod++],\n+                altMethodsMethod2[indexOfAltMethod]).getTarget().invoke();\n+    }\n+\n+    private static void createLambdasWithAltMethods(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int indexOfMethodWithOneAltMethod = 0;\n+        int indexOfMethodWithTwoAltMethods = 1;\n+        int altMethodIndex = 0;\n+        Object lambda;\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                lambda = lambdaWithOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithOneAltMethod], methodHandles[indexOfMethodWithOneAltMethod],\n+                        flags, altMethodsMethod1[altMethodIndex], methodHandles);\n+                lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+\n+                for (MethodType altMethod : altMethodsMethod2) {\n+                    lambda = lambdaWithOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithTwoAltMethods], methodHandles[indexOfMethodWithTwoAltMethods],\n+                            flags, altMethod, methodHandles);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                }\n+\n+                lambda = lambdaWithMultipleAltMethods(interfaceMethod, interfaceClass, flags, methodHandles);\n+            }\n+        }\n+    }\n+\n+    private static Object lambdaWithOneAltInterfaceAndOneAltMethod(String interfaceMethod, Class<?> interfaceClass, MethodType methodType, MethodHandle methodHandle, int flags,\n+                                                                   Class<?> altInterface, MethodType altMethod) throws Throwable {\n+        int numOfAltInterfaces = 1;\n+        int numOfAltMethods = 1;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltInterfaces, altInterface, numOfAltMethods, altMethod).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithOneAltInterfaceAndMultipleAltMethods(String interfaceMethod, Class<?> interfaceClass, int flags, Class<?> altInterface,\n+                                                                         MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltInterfaces = 1;\n+        int numOfAltMethods = 2;\n+        int indexOfAltMethod = 0;\n+        MethodType methodTypeMethod2 = methodTypes[1];\n+        MethodHandle methodHandleMethod2 = methodHandles[1];\n+\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodTypeMethod2, methodHandleMethod2, methodTypeMethod2, flags, numOfAltInterfaces, altInterface, numOfAltMethods, altMethodsMethod2[indexOfAltMethod++],\n+                altMethodsMethod2[indexOfAltMethod]).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithMultipleAltInterfaceAndMultipleAltMethods(String interfaceMethod, Class<?> interfaceClass, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltInterfaces = 2;\n+        int numOfAltMethods = 2;\n+        int indexOfAltInterface = 0;\n+        int indexOfAltMethod = 0;\n+        MethodType methodTypeMethod2 = methodTypes[1];\n+        MethodHandle methodHandleMethod2 = methodHandles[1];\n+\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass), methodTypeMethod2, methodHandleMethod2, methodTypeMethod2,\n+                flags, numOfAltInterfaces, altInterfaces[indexOfAltInterface++], altInterfaces[indexOfAltInterface], numOfAltMethods, altMethodsMethod2[indexOfAltMethod++],\n+                altMethodsMethod2[indexOfAltMethod]).getTarget().invoke();\n+    }\n+    private static void createLambdasWithAltInterfacesAndAltMethods(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int indexOfMethodWithOneAltMethod = 0;\n+        int indexOfMethodWithTwoAltMethods = 1;\n+        int altMethodIndex = 0;\n+        Object lambda;\n+\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                for (Class<?> altInterface : altInterfaces) {\n+                    lambda = lambdaWithOneAltInterfaceAndOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithOneAltMethod], methodHandles[indexOfMethodWithOneAltMethod], flags,\n+                            altInterface, altMethodsMethod1[altMethodIndex]);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                    lambda = lambdaWithOneAltInterfaceAndMultipleAltMethods(interfaceMethod, interfaceClass, flags, altInterface, methodHandles);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+\n+                    for (MethodType altMethod : altMethodsMethod2) {\n+                        lambda = lambdaWithOneAltInterfaceAndOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithTwoAltMethods], methodHandles[indexOfMethodWithTwoAltMethods], flags,\n+                                altInterface, altMethod);\n+                        lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                    }\n+                }\n+                lambda = lambdaWithMultipleAltInterfaceAndMultipleAltMethods(interfaceMethod, interfaceClass, flags, methodHandles);\n+                lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+            }\n+        }\n+    }\n+\n+    private static void createLambdasWithDifferentParameters(Set<String> lambdaNames, MethodHandle[] methodHandles) throws Throwable {\n+        \/\/ All lambdas with flags 0\n+        createPlainLambdas(lambdaNames, lambdaType.NOT_SERIALIZABLE_NO_ALT_METHODS_NO_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 1\n+        createPlainLambdas(lambdaNames, lambdaType.SERIALIZABLE_ONLY.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 2\n+        createLambdasWithAltInterfaces(lambdaNames, lambdaType.NOT_SERIALIZABLE_HAS_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 3\n+        createLambdasWithAltInterfaces(lambdaNames, lambdaType.SERIALIZABLE_HAS_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 4\n+        createLambdasWithAltMethods(lambdaNames, lambdaType.NOT_SERIALIZABLE_HAS_ALT_METHODS.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 5\n+        createLambdasWithAltMethods(lambdaNames, lambdaType.SERIALIZABLE_HAS_ALT_METHODS.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 6\n+        createLambdasWithAltInterfacesAndAltMethods(lambdaNames, lambdaType.NOT_SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 7\n+        createLambdasWithAltInterfacesAndAltMethods(lambdaNames, lambdaType.SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES.index, methodHandles);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        MethodType methodTypeForMethod1 = methodTypes[0];\n+        MethodType methodTypeForMethod2 = methodTypes[1];\n+        MethodHandle[] methodHandles = {lookup.findStatic(TestStableLambdaNames.class, \"method1\", methodTypeForMethod1),\n+                lookup.findStatic(TestStableLambdaNames.class, \"method2\", methodTypeForMethod2)};\n+\n+        Set<String> lambdaClassStableNames = new HashSet<>();\n+        createLambdasWithDifferentParameters(lambdaClassStableNames, methodHandles);\n+        System.err.println(lambdaClassStableNames.size());\n+\n+        Set<String> lambdaClassStableNamesTest = new HashSet<>();\n+        createLambdasWithDifferentParameters(lambdaClassStableNamesTest, methodHandles);\n+\n+        if (lambdaClassStableNames.size() != lambdaClassStableNamesTest.size()) {\n+            throw new RuntimeException(lambdaClassStableNames.size() + \" names was created during name creation run, but \" + lambdaClassStableNamesTest.size() + \" names were created during test run. \" +\n+                    \"Number of created names must be the same.\");\n+        }\n+\n+        if (!lambdaClassStableNamesTest.containsAll(lambdaClassStableNames)) {\n+            throw new RuntimeException(\"Different names for lambda classes were created during name creation run and test run. All the created names in both runs must be the same.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/TestStableLambdaNames.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"}]}