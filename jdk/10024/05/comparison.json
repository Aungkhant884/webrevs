{"files":[{"patch":"@@ -46,0 +46,1 @@\n+import java.util.StringJoiner;\n@@ -53,0 +54,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.CRC32;\n+\n@@ -96,0 +100,5 @@\n+    private static final boolean generateStableLambdaNames;\n+\n+    private static final int mask1 = 0b10101010;\n+    private static final int mask2 = 0b01010101;\n+\n@@ -107,0 +116,3 @@\n+        final String generateStableLambdaNamesKey = \"jdk.internal.lambda.generateStableLambdaNames\";\n+        generateStableLambdaNames = GetBooleanAction.privilegedGetProperty(generateStableLambdaNamesKey);\n+\n@@ -182,1 +194,1 @@\n-        lambdaClassName = lambdaClassName(targetClass);\n+        lambdaClassName = generateStableLambdaNames ? stableLambdaClassName(targetClass) : lambdaClassName(targetClass);\n@@ -207,0 +219,4 @@\n+        return createNameFromTargetClass(targetClass) + counter.incrementAndGet();\n+    }\n+\n+    private static String createNameFromTargetClass(Class<?> targetClass) {\n@@ -212,1 +228,73 @@\n-        return name.replace('.', '\/') + \"$$Lambda$\" + counter.incrementAndGet();\n+        return name.replace('.', '\/') + \"$$Lambda$\";\n+    }\n+\n+    \/**\n+     * Create a stable name for the lambda class.\n+     * When the CDS archiving is enabled, lambda classes\n+     * are stored in the archive using some parameters from\n+     * the InnerClassLambdaMetafactory. To distinguish between\n+     * two lambdas, even when CDS archiving is disabled,\n+     * use a superset of those parameters to create a stable name.\n+     *\n+     * Concatenate all the parameters chosen for the stable name,\n+     * and hash them into 64-bit hash value.\n+     * Any additional changes to this method will result in unstable\n+     * hash values across different versions. Thus, every change\n+     * to this method should be regarded as a backward incompatible change.\n+     *\n+     * No matter what hash function we use, there is a possibility of\n+     * collisions in names. We expect a relatively low number of lambdas\n+     * per class. Thus, we don't expect to have collisions using the described\n+     * hash function. Every tool that uses this feature should handle potential\n+     * collisions on its own. There is no guarantee that names will be unique,\n+     * only that they will be stable (identical in every run).\n+     *\n+     * @return a stable name for the created lambda class.\n+     *\/\n+    private String stableLambdaClassName(Class<?> targetClass) {\n+        String name = createNameFromTargetClass(targetClass);\n+\n+        StringBuilder hashData1 = new StringBuilder(), hashData2 = new StringBuilder();\n+        appendData(hashData1, hashData2, interfaceMethodName);\n+        appendData(hashData1, hashData2, getQualifiedSignature(factoryType));\n+        appendData(hashData1, hashData2, getQualifiedSignature(interfaceMethodType));\n+        appendData(hashData1, hashData2, implementation.internalMemberName().toString());\n+        appendData(hashData1, hashData2, getQualifiedSignature(dynamicMethodType));\n+\n+        for (Class<?> clazz : altInterfaces) {\n+            appendData(hashData1, hashData2, clazz.getName());\n+        }\n+\n+        for (MethodType method : altMethods) {\n+            appendData(hashData1, hashData2, getQualifiedSignature(method));\n+        }\n+\n+        return name + hashToHexString(hashData1.toString(), hashData2.toString());\n+    }\n+\n+    private void appendData(StringBuilder hashData1, StringBuilder hashData2, String data) {\n+        for (int i = 0; i < data.length(); i++) {\n+            hashData1.append((char)(data.charAt(i) & mask1));\n+            hashData2.append((char)(data.charAt(i) & mask2));\n+        }\n+    }\n+\n+    private long hashStringToLong(String hashData) {\n+        CRC32 crc32 = new CRC32();\n+        crc32.update(hashData.getBytes(StandardCharsets.UTF_8));\n+        return crc32.getValue();\n+    }\n+\n+    private String hashToHexString(String hashData1, String hashData2) {\n+        long hashValueData1 = hashStringToLong(hashData1);\n+        long hashValueData2 = hashStringToLong(hashData2);\n+        return Long.toHexString(hashValueData1 | (hashValueData2 << 32));\n+    }\n+\n+    private String getQualifiedSignature(MethodType type) {\n+        StringJoiner sj = new StringJoiner(\",\", \"(\", \")\" + type.returnType().getName());\n+        Class<?>[] ptypes = type.ptypes();\n+        for (int i = 0; i < ptypes.length; i++) {\n+            sj.add(ptypes[i].getName());\n+        }\n+        return sj.toString();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":90,"deletions":2,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Test if the names of the lambda classes are stable when {@code -Djdk.internal.lambda.generateStableLambdaNames}\n+ *          flag is set to true. This test directly calls java.lang.invoke.LambdaMetafactory#altMetafactory\n+ *          method to create multilple lambda instances and then checks their names stability. We created a\n+ *          multidimensional space of possible values for each parameter that\n+ *          {@link java.lang.invoke.LambdaMetafactory#altMetafactory} takes and then search that space by combining\n+ *          different values of those parameters. There is a rule we have to follow:\n+ *          Alternative methods of the specific method must have the same signature with difference in parameter types\n+ *          as long as the parameter of the alternative method is the superclass type of the type of corresponding parameter in\n+ *          original method\n+ * @run main\/othervm -Djdk.internal.lambda.generateStableLambdaNames=true TestStableLambdaNames\n+ *\/\n+\n+import java.lang.invoke.LambdaMetafactory;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.rmi.Remote;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.BooleanSupplier;\n+import java.util.function.Supplier;\n+\n+public class TestStableLambdaNames {\n+    private static final MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+    \/**\n+     * Different types of lambda classes based on value of flags parameter in the\n+     * {@link java.lang.invoke.LambdaMetafactory#altMetafactory}.\n+     * {@link java.lang.invoke.LambdaMetafactory#altMetafactory} uses bitwise and with this\n+     * parameter and predefined values to determine if lambda is serializable, has\n+     * altMethods and altInterfaces etc.\n+     *\/\n+    private enum lambdaType {\n+        NOT_SERIALIZABLE_NO_ALT_METHODS_NO_ALT_INTERFACES (0),\n+        SERIALIZABLE_ONLY (1),\n+        NOT_SERIALIZABLE_HAS_ALT_INTERFACES(2),\n+        SERIALIZABLE_HAS_ALT_INTERFACES(3),\n+        NOT_SERIALIZABLE_HAS_ALT_METHODS(4),\n+        SERIALIZABLE_HAS_ALT_METHODS(5),\n+        NOT_SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES(6),\n+        SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES(7);\n+\n+        private final int index;\n+        lambdaType(int i) {\n+            index = i;\n+        }\n+    }\n+\n+    private static final String[] interfaceMethods = {\"accept\", \"consume\", \"apply\", \"supply\", \"get\", \"test\", \"getAsBoolean\"};\n+    private static final Class<?>[] interfaces = {Consumer.class, Function.class, Predicate.class, Supplier.class, BooleanSupplier.class};\n+    \/** List of method types for defined methods *\/\n+    private static final MethodType[] methodTypes = {MethodType.methodType(String.class, Integer.class), MethodType.methodType(Throwable.class, AssertionError.class)};\n+    private static final Class<?>[] altInterfaces = {Cloneable.class, Remote.class};\n+    \/** Alternative methods that corresponds to method1 *\/\n+    private static final MethodType[] altMethodsMethod1 = {MethodType.methodType(String.class, Number.class)};\n+    \/** Alternative methods that corresponds to method2 *\/\n+    private static final MethodType[] altMethodsMethod2 = {MethodType.methodType(Throwable.class, Error.class), MethodType.methodType(Throwable.class, Throwable.class)};\n+\n+    private static String method1(Number number) {\n+        return String.valueOf(number);\n+    }\n+\n+    private static String method1(Integer number) { return String.valueOf(number); }\n+\n+    private static Throwable method2(AssertionError error) {\n+        return error;\n+    }\n+\n+    private static Throwable method2(Error error) {\n+        return error;\n+    }\n+\n+    private static Throwable method2(Throwable throwable) {\n+        return throwable;\n+    }\n+\n+    private static String removeHashFromLambdaName(String name) {\n+        return name.substring(0, name.indexOf(\"\/0x0\"));\n+    }\n+\n+    private static void createPlainLambdas(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                for (int i = 0; i < methodTypes.length; i++) {\n+                    Object lambda = LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                            methodTypes[i], methodHandles[i], methodTypes[i], flags).getTarget().invoke();\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Object lambdaWithOneAltInterface(String interfaceMethod, Class<?> interfaceClass, MethodType methodType, MethodHandle methodHandle, int flags, Class<?> altInterface) throws Throwable {\n+        int numOfAltInterfaces = 1;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltInterfaces, altInterface).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithMultipleAltInterfaces(String interfaceMethod, Class<?> interfaceClass,  MethodType methodType, MethodHandle methodHandle, int flags) throws Throwable {\n+        int numOfAltInterfaces = 2;\n+        int altInterfacesIndex = 0;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltInterfaces, altInterfaces[altInterfacesIndex++], altInterfaces[altInterfacesIndex]).getTarget().invoke();\n+    }\n+\n+    private static void createLambdasWithAltInterfaces(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        Object lambda;\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                for (int i = 0; i < methodTypes.length; i++) {\n+                    for (Class<?> altInterface : altInterfaces) {\n+                        lambda = lambdaWithOneAltInterface(interfaceMethod, interfaceClass, methodTypes[i], methodHandles[i], flags, altInterface);\n+                        lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                    }\n+\n+                    lambda = lambdaWithMultipleAltInterfaces(interfaceMethod, interfaceClass, methodTypes[i], methodHandles[i], flags);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                }\n+            }\n+        }\n+    }\n+\n+    private static Object lambdaWithOneAltMethod(String interfaceMethod, Class<?> interfaceClass,  MethodType methodType, MethodHandle methodHandle,\n+                                                 int flags, MethodType altMethod, MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltMethods = 1;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltMethods, altMethod).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithMultipleAltMethods(String interfaceMethod, Class<?> interfaceClass, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltMethods = 2;\n+        int indexOfAltMethod = 0;\n+        MethodType methodTypeMethod2 = methodTypes[1];\n+        MethodHandle methodHandleMethod2 = methodHandles[1];\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodTypeMethod2, methodHandleMethod2, methodTypeMethod2, flags, numOfAltMethods, altMethodsMethod2[indexOfAltMethod++],\n+                altMethodsMethod2[indexOfAltMethod]).getTarget().invoke();\n+    }\n+\n+    private static void createLambdasWithAltMethods(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int indexOfMethodWithOneAltMethod = 0;\n+        int indexOfMethodWithTwoAltMethods = 1;\n+        int altMethodIndex = 0;\n+        Object lambda;\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                lambda = lambdaWithOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithOneAltMethod], methodHandles[indexOfMethodWithOneAltMethod],\n+                        flags, altMethodsMethod1[altMethodIndex], methodHandles);\n+                lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+\n+                for (MethodType altMethod : altMethodsMethod2) {\n+                    lambda = lambdaWithOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithTwoAltMethods], methodHandles[indexOfMethodWithTwoAltMethods],\n+                            flags, altMethod, methodHandles);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                }\n+\n+                lambda = lambdaWithMultipleAltMethods(interfaceMethod, interfaceClass, flags, methodHandles);\n+            }\n+        }\n+    }\n+\n+    private static Object lambdaWithOneAltInterfaceAndOneAltMethod(String interfaceMethod, Class<?> interfaceClass, MethodType methodType, MethodHandle methodHandle, int flags,\n+                                                                   Class<?> altInterface, MethodType altMethod) throws Throwable {\n+        int numOfAltInterfaces = 1;\n+        int numOfAltMethods = 1;\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodType, methodHandle, methodType, flags, numOfAltInterfaces, altInterface, numOfAltMethods, altMethod).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithOneAltInterfaceAndMultipleAltMethods(String interfaceMethod, Class<?> interfaceClass, int flags, Class<?> altInterface,\n+                                                                         MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltInterfaces = 1;\n+        int numOfAltMethods = 2;\n+        int indexOfAltMethod = 0;\n+        MethodType methodTypeMethod2 = methodTypes[1];\n+        MethodHandle methodHandleMethod2 = methodHandles[1];\n+\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass),\n+                methodTypeMethod2, methodHandleMethod2, methodTypeMethod2, flags, numOfAltInterfaces, altInterface, numOfAltMethods, altMethodsMethod2[indexOfAltMethod++],\n+                altMethodsMethod2[indexOfAltMethod]).getTarget().invoke();\n+    }\n+\n+    private static Object lambdaWithMultipleAltInterfaceAndMultipleAltMethods(String interfaceMethod, Class<?> interfaceClass, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int numOfAltInterfaces = 2;\n+        int numOfAltMethods = 2;\n+        int indexOfAltInterface = 0;\n+        int indexOfAltMethod = 0;\n+        MethodType methodTypeMethod2 = methodTypes[1];\n+        MethodHandle methodHandleMethod2 = methodHandles[1];\n+\n+        return LambdaMetafactory.altMetafactory(lookup, interfaceMethod, MethodType.methodType(interfaceClass), methodTypeMethod2, methodHandleMethod2, methodTypeMethod2,\n+                flags, numOfAltInterfaces, altInterfaces[indexOfAltInterface++], altInterfaces[indexOfAltInterface], numOfAltMethods, altMethodsMethod2[indexOfAltMethod++],\n+                altMethodsMethod2[indexOfAltMethod]).getTarget().invoke();\n+    }\n+    private static void createLambdasWithAltInterfacesAndAltMethods(Set<String> lambdaNames, int flags, MethodHandle[] methodHandles) throws Throwable {\n+        int indexOfMethodWithOneAltMethod = 0;\n+        int indexOfMethodWithTwoAltMethods = 1;\n+        int altMethodIndex = 0;\n+        Object lambda;\n+\n+        for (String interfaceMethod : interfaceMethods) {\n+            for (Class<?> interfaceClass : interfaces) {\n+                for (Class<?> altInterface : altInterfaces) {\n+                    lambda = lambdaWithOneAltInterfaceAndOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithOneAltMethod], methodHandles[indexOfMethodWithOneAltMethod], flags,\n+                            altInterface, altMethodsMethod1[altMethodIndex]);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                    lambda = lambdaWithOneAltInterfaceAndMultipleAltMethods(interfaceMethod, interfaceClass, flags, altInterface, methodHandles);\n+                    lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+\n+                    for (MethodType altMethod : altMethodsMethod2) {\n+                        lambda = lambdaWithOneAltInterfaceAndOneAltMethod(interfaceMethod, interfaceClass, methodTypes[indexOfMethodWithTwoAltMethods], methodHandles[indexOfMethodWithTwoAltMethods], flags,\n+                                altInterface, altMethod);\n+                        lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+                    }\n+                }\n+                lambda = lambdaWithMultipleAltInterfaceAndMultipleAltMethods(interfaceMethod, interfaceClass, flags, methodHandles);\n+                lambdaNames.add(removeHashFromLambdaName(lambda.getClass().getName()));\n+            }\n+        }\n+    }\n+\n+    private static void createLambdasWithDifferentParameters(Set<String> lambdaNames, MethodHandle[] methodHandles) throws Throwable {\n+        \/\/ All lambdas with flags 0\n+        createPlainLambdas(lambdaNames, lambdaType.NOT_SERIALIZABLE_NO_ALT_METHODS_NO_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 1\n+        createPlainLambdas(lambdaNames, lambdaType.SERIALIZABLE_ONLY.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 2\n+        createLambdasWithAltInterfaces(lambdaNames, lambdaType.NOT_SERIALIZABLE_HAS_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 3\n+        createLambdasWithAltInterfaces(lambdaNames, lambdaType.SERIALIZABLE_HAS_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 4\n+        createLambdasWithAltMethods(lambdaNames, lambdaType.NOT_SERIALIZABLE_HAS_ALT_METHODS.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 5\n+        createLambdasWithAltMethods(lambdaNames, lambdaType.SERIALIZABLE_HAS_ALT_METHODS.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 6\n+        createLambdasWithAltInterfacesAndAltMethods(lambdaNames, lambdaType.NOT_SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES.index, methodHandles);\n+\n+        \/\/ All lambdas with flags 7\n+        createLambdasWithAltInterfacesAndAltMethods(lambdaNames, lambdaType.SERIALIZABLE_HAS_ALT_METHODS_HAS_ALT_INTERFACES.index, methodHandles);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        MethodType methodTypeForMethod1 = methodTypes[0];\n+        MethodType methodTypeForMethod2 = methodTypes[1];\n+        MethodHandle[] methodHandles = {lookup.findStatic(TestStableLambdaNames.class, \"method1\", methodTypeForMethod1),\n+                lookup.findStatic(TestStableLambdaNames.class, \"method2\", methodTypeForMethod2)};\n+\n+        Set<String> lambdaClassStableNames = new HashSet<>();\n+        createLambdasWithDifferentParameters(lambdaClassStableNames, methodHandles);\n+        System.err.println(lambdaClassStableNames.size());\n+\n+        Set<String> lambdaClassStableNamesTest = new HashSet<>();\n+        createLambdasWithDifferentParameters(lambdaClassStableNamesTest, methodHandles);\n+\n+        if (lambdaClassStableNames.size() != lambdaClassStableNamesTest.size()) {\n+            throw new RuntimeException(lambdaClassStableNames.size() + \" names was created during name creation run, but \" + lambdaClassStableNamesTest.size() + \" names were created during test run. \" +\n+                    \"Number of created names must be the same.\");\n+        }\n+\n+        if (!lambdaClassStableNamesTest.containsAll(lambdaClassStableNames)) {\n+            throw new RuntimeException(\"Different names for lambda classes were created during name creation run and test run. All the created names in both runs must be the same.\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/TestStableLambdaNames.java","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"}]}