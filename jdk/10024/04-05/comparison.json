{"files":[{"patch":"@@ -54,0 +54,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.util.zip.CRC32;\n+\n@@ -98,1 +101,0 @@\n-    private static final char paddingCharacter = '#';\n@@ -100,2 +102,2 @@\n-    \/\/ Length of a single hash contained in the stable lambda name\n-    private static final int stableLambdaNameHashLength;\n+    private static final int mask1 = 0b10101010;\n+    private static final int mask2 = 0b01010101;\n@@ -114,4 +116,2 @@\n-        final String generateStableLambdaNameKey = \"jdk.internal.lambda.generateStableLambdaNames\";\n-        generateStableLambdaNames = GetBooleanAction.privilegedGetProperty(generateStableLambdaNameKey);\n-\n-        stableLambdaNameHashLength = hashValueString(Long.MAX_VALUE).length();\n+        final String generateStableLambdaNamesKey = \"jdk.internal.lambda.generateStableLambdaNames\";\n+        generateStableLambdaNames = GetBooleanAction.privilegedGetProperty(generateStableLambdaNamesKey);\n@@ -231,3 +231,0 @@\n-    private static String hashValueString(long hashValue) {\n-        return Long.toString(hashValue, Character.MAX_RADIX);\n-    }\n@@ -235,3 +232,6 @@\n-     * Calculate hash value of the given String in the same manner as the\n-     * java.lang.StringUTF16#hashCode does, except that hash value\n-     * is long instead of int.\n+     * Create a stable name for the lambda class.\n+     * When the CDS archiving is enabled, lambda classes\n+     * are stored in the archive using some parameters from\n+     * the InnerClassLambdaMetafactory. To distinguish between\n+     * two lambdas, even when CDS archiving is disabled,\n+     * use a superset of those parameters to create a stable name.\n@@ -239,1 +239,5 @@\n-     * @param name String for which method calculates hash value for\n+     * Concatenate all the parameters chosen for the stable name,\n+     * and hash them into 64-bit hash value.\n+     * Any additional changes to this method will result in unstable\n+     * hash values across different versions. Thus, every change\n+     * to this method should be regarded as a backward incompatible change.\n@@ -241,29 +245,6 @@\n-     * @return a hash value for the given String\n-     * *\/\n-    private String fixedSizeStringHash(String name) {\n-        long h = 0;\n-        int length = name.length();\n-        for (int i = 0; i < length; i++) {\n-            h = 31 * h + name.charAt(i);\n-        }\n-\n-        StringBuilder hash = new StringBuilder(hashValueString(Math.abs(h)));\n-        int hashLength = hash.length();\n-\n-        \/\/ As all the hashes contained in the stable lambda names should\n-        \/\/ be of the same length, we pad some of them with the special\n-        \/\/ character '#' which is never part of the hash value.\n-        while (hashLength != stableLambdaNameHashLength) {\n-            hash.append(paddingCharacter);\n-            hashLength++;\n-        }\n-\n-        return hash.toString();\n-    }\n-\n-    \/**\n-     * Creating stable name for lambda class.\n-     * Parameters that are used to create stable name\n-     * are a superset of the parameters that are used in\n-     * {@link java.lang.invoke.LambdaProxyClassArchive#addToArchive}\n-     * to store lambdas.\n+     * No matter what hash function we use, there is a possibility of\n+     * collisions in names. We expect a relatively low number of lambdas\n+     * per class. Thus, we don't expect to have collisions using the described\n+     * hash function. Every tool that uses this feature should handle potential\n+     * collisions on its own. There is no guarantee that names will be unique,\n+     * only that they will be stable (identical in every run).\n@@ -276,6 +257,6 @@\n-        StringBuilder hashData = new StringBuilder().append(interfaceMethodName);\n-        hashData.append(getQualifiedSignature(factoryType));\n-        hashData.append(getQualifiedSignature(interfaceMethodType));\n-        hashData.append(implementation.internalMemberName().toString());\n-        hashData.append(getQualifiedSignature(dynamicMethodType));\n-        hashData.append(isSerializable ? \"true\" : \"false\");\n+        StringBuilder hashData1 = new StringBuilder(), hashData2 = new StringBuilder();\n+        appendData(hashData1, hashData2, interfaceMethodName);\n+        appendData(hashData1, hashData2, getQualifiedSignature(factoryType));\n+        appendData(hashData1, hashData2, getQualifiedSignature(interfaceMethodType));\n+        appendData(hashData1, hashData2, implementation.internalMemberName().toString());\n+        appendData(hashData1, hashData2, getQualifiedSignature(dynamicMethodType));\n@@ -284,1 +265,1 @@\n-            hashData.append(clazz.getName());\n+            appendData(hashData1, hashData2, clazz.getName());\n@@ -288,1 +269,10 @@\n-            hashData.append(getQualifiedSignature(method));\n+            appendData(hashData1, hashData2, getQualifiedSignature(method));\n+        }\n+\n+        return name + hashToHexString(hashData1.toString(), hashData2.toString());\n+    }\n+\n+    private void appendData(StringBuilder hashData1, StringBuilder hashData2, String data) {\n+        for (int i = 0; i < data.length(); i++) {\n+            hashData1.append((char)(data.charAt(i) & mask1));\n+            hashData2.append((char)(data.charAt(i) & mask2));\n@@ -290,0 +280,1 @@\n+    }\n@@ -291,1 +282,5 @@\n-        name += fixedSizeStringHash(hashData.toString());\n+    private long hashStringToLong(String hashData) {\n+        CRC32 crc32 = new CRC32();\n+        crc32.update(hashData.getBytes(StandardCharsets.UTF_8));\n+        return crc32.getValue();\n+    }\n@@ -293,1 +288,4 @@\n-        return name;\n+    private String hashToHexString(String hashData1, String hashData2) {\n+        long hashValueData1 = hashStringToLong(hashData1);\n+        long hashValueData2 = hashStringToLong(hashData2);\n+        return Long.toHexString(hashValueData1 | (hashValueData2 << 32));\n@@ -297,2 +295,1 @@\n-        StringJoiner sj = new StringJoiner(\",\", \"(\",\n-                \")\" + type.returnType().getName());\n+        StringJoiner sj = new StringJoiner(\",\", \"(\", \")\" + type.returnType().getName());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":52,"deletions":55,"binary":false,"changes":107,"status":"modified"}]}