{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -36,1 +37,2 @@\n-  u2 index = _entries.length();\n+  \/\/ We check for constant pool overflow later.\n+  u2 index = static_cast<u2>(_entries.length());\n@@ -44,1 +46,1 @@\n-  return index + _orig->length();\n+  return static_cast<u2>(index + _orig->length());\n@@ -52,0 +54,5 @@\n+  int new_size = _orig->length() + _entries.length();\n+  if (new_size > USHRT_MAX) {\n+    THROW_MSG_NULL(vmSymbols::java_lang_InternalError(), \"default methods constant pool overflowed\");\n+  }\n+\n@@ -54,1 +61,1 @@\n-      _orig->length() + _entries.length(), CHECK_NULL);\n+      new_size, CHECK_NULL);\n@@ -117,9 +124,0 @@\n-void BytecodeAssembler::xload(u4 index, u1 onebyteop, u1 twobyteop) {\n-  if (index < 4) {\n-    _code->append(onebyteop + index);\n-  } else {\n-    _code->append(twobyteop);\n-    _code->append((u2)index);\n-  }\n-}\n-\n@@ -139,1 +137,1 @@\n-    ldc(cpool_index);\n+    ldc((u1)cpool_index);\n@@ -159,49 +157,0 @@\n-void BytecodeAssembler::iload(u4 index) {\n-  xload(index, Bytecodes::_iload_0, Bytecodes::_iload);\n-}\n-\n-void BytecodeAssembler::lload(u4 index) {\n-  xload(index, Bytecodes::_lload_0, Bytecodes::_lload);\n-}\n-\n-void BytecodeAssembler::fload(u4 index) {\n-  xload(index, Bytecodes::_fload_0, Bytecodes::_fload);\n-}\n-\n-void BytecodeAssembler::dload(u4 index) {\n-  xload(index, Bytecodes::_dload_0, Bytecodes::_dload);\n-}\n-\n-void BytecodeAssembler::aload(u4 index) {\n-  xload(index, Bytecodes::_aload_0, Bytecodes::_aload);\n-}\n-\n-void BytecodeAssembler::load(BasicType bt, u4 index) {\n-  switch (bt) {\n-    case T_BOOLEAN:\n-    case T_CHAR:\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:     iload(index); break;\n-    case T_FLOAT:   fload(index); break;\n-    case T_DOUBLE:  dload(index); break;\n-    case T_LONG:    lload(index); break;\n-    default:\n-      if (is_reference_type(bt)) {\n-                    aload(index);\n-                    break;\n-      }\n-      ShouldNotReachHere();\n-  }\n-}\n-\n-void BytecodeAssembler::checkcast(Symbol* sym) {\n-  u2 cpool_index = _cp->klass(sym);\n-  _code->append(Bytecodes::_checkcast);\n-  append(cpool_index);\n-}\n-\n-void BytecodeAssembler::invokespecial(Method* method) {\n-  invokespecial(method->klass_name(), method->name(), method->signature());\n-}\n-\n@@ -214,21 +163,4 @@\n-void BytecodeAssembler::invokevirtual(Method* method) {\n-  invokevirtual(method->klass_name(), method->name(), method->signature());\n-}\n-\n-void BytecodeAssembler::invokevirtual(Symbol* klss, Symbol* name, Symbol* sig) {\n-  u2 methodref_index = _cp->methodref(klss, name, sig);\n-  _code->append(Bytecodes::_invokevirtual);\n-  append(methodref_index);\n-}\n-\n-void BytecodeAssembler::ireturn() {\n-  _code->append(Bytecodes::_ireturn);\n-}\n-\n-void BytecodeAssembler::lreturn() {\n-  _code->append(Bytecodes::_lreturn);\n-}\n-\n-void BytecodeAssembler::freturn() {\n-  _code->append(Bytecodes::_freturn);\n-}\n+int BytecodeAssembler::assemble_method_error(BytecodeConstantPool* cp,\n+                                             BytecodeBuffer* buffer,\n+                                             Symbol* errorName,\n+                                             Symbol* message) {\n@@ -236,3 +168,2 @@\n-void BytecodeAssembler::dreturn() {\n-  _code->append(Bytecodes::_dreturn);\n-}\n+  Symbol* init = vmSymbols::object_initializer_name();\n+  Symbol* sig = vmSymbols::string_void_signature();\n@@ -240,3 +171,1 @@\n-void BytecodeAssembler::areturn() {\n-  _code->append(Bytecodes::_areturn);\n-}\n+  BytecodeAssembler assem(buffer, cp);\n@@ -244,3 +173,5 @@\n-void BytecodeAssembler::_return() {\n-  _code->append(Bytecodes::_return);\n-}\n+  assem._new(errorName);\n+  assem.dup();\n+  assem.load_string(message);\n+  assem.invokespecial(errorName, init, sig);\n+  assem.athrow();\n@@ -248,18 +179,1 @@\n-void BytecodeAssembler::_return(BasicType bt) {\n-  switch (bt) {\n-    case T_BOOLEAN:\n-    case T_CHAR:\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:     ireturn(); break;\n-    case T_FLOAT:   freturn(); break;\n-    case T_DOUBLE:  dreturn(); break;\n-    case T_LONG:    lreturn(); break;\n-    case T_VOID:    _return(); break;\n-    default:\n-      if (is_reference_type(bt)) {\n-                    areturn();\n-                    break;\n-      }\n-      ShouldNotReachHere();\n-  }\n+  return 3; \/\/ max stack size: [ exception, exception, string ]\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.cpp","additions":25,"deletions":111,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,8 +182,0 @@\n-  void xload(u4 index, u1 quick, u1 twobyte);\n-\n- public:\n-  BytecodeAssembler(BytecodeBuffer* buffer, BytecodeConstantPool* cp)\n-    : _code(buffer), _cp(cp) {}\n-\n-  void aload(u4 index);\n-  void areturn();\n@@ -191,3 +183,0 @@\n-  void checkcast(Symbol* sym);\n-  void dload(u4 index);\n-  void dreturn();\n@@ -195,4 +184,0 @@\n-  void fload(u4 index);\n-  void freturn();\n-  void iload(u4 index);\n-  void invokespecial(Method* method);\n@@ -200,3 +185,0 @@\n-  void invokevirtual(Method* method);\n-  void invokevirtual(Symbol* cls, Symbol* name, Symbol* sig);\n-  void ireturn();\n@@ -205,2 +187,0 @@\n-  void lload(u4 index);\n-  void lreturn();\n@@ -208,2 +188,0 @@\n-  void _return();\n-\n@@ -211,2 +189,9 @@\n-  void load(BasicType bt, u4 index);\n-  void _return(BasicType bt);\n+\n+ public:\n+  BytecodeAssembler(BytecodeBuffer* buffer, BytecodeConstantPool* cp)\n+    : _code(buffer), _cp(cp) {}\n+\n+  static int assemble_method_error(BytecodeConstantPool* cp,\n+                                   BytecodeBuffer* buffer,\n+                                   Symbol* errorName,\n+                                   Symbol* message);\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":10,"deletions":25,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -868,17 +868,0 @@\n-static int assemble_method_error(\n-    BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message) {\n-\n-  Symbol* init = vmSymbols::object_initializer_name();\n-  Symbol* sig = vmSymbols::string_void_signature();\n-\n-  BytecodeAssembler assem(buffer, cp);\n-\n-  assem._new(errorName);\n-  assem.dup();\n-  assem.load_string(message);\n-  assem.invokespecial(errorName, init, sig);\n-  assem.athrow();\n-\n-  return 3; \/\/ max stack size: [ exception, exception, string ]\n-}\n-\n@@ -992,1 +975,1 @@\n-        int max_stack = assemble_method_error(&bpool, buffer,\n+        int max_stack = BytecodeAssembler::assemble_method_error(&bpool, buffer,\n@@ -1076,1 +1059,5 @@\n-  int new_size = klass->methods()->length() + new_methods->length();\n+  int new_methods_length = klass->methods()->length() + new_methods->length();\n+  assert(new_methods_length <= USHRT_MAX,\n+         \"error methods for default method processing caused too many methods in class %s\",\n+         klass->external_name());\n+  u2 new_size = static_cast<u2>(new_methods_length);\n@@ -1094,1 +1081,1 @@\n-  for (int i = 0; i < new_size; ++i) {\n+  for (u2 i = 0; i < new_size; ++i) {\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":7,"deletions":20,"binary":false,"changes":27,"status":"modified"}]}