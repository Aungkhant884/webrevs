{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -34,1 +35,1 @@\n-u2 BytecodeConstantPool::find_or_add(BytecodeCPEntry const& bcpe) {\n+u2 BytecodeConstantPool::find_or_add(BytecodeCPEntry const& bcpe, TRAPS) {\n@@ -36,1 +37,7 @@\n-  u2 index = _entries.length();\n+  \/\/ Check for overflow\n+  int new_size = _orig->length() + _entries.length();\n+  if (new_size > USHRT_MAX) {\n+    THROW_MSG_0(vmSymbols::java_lang_InternalError(), \"default methods constant pool overflowed\");\n+  }\n+\n+  u2 index = static_cast<u2>(_entries.length());\n@@ -44,1 +51,1 @@\n-  return index + _orig->length();\n+  return static_cast<u2>(index + _orig->length());\n@@ -52,0 +59,1 @@\n+  int new_size = _orig->length() + _entries.length();\n@@ -54,1 +62,1 @@\n-      _orig->length() + _entries.length(), CHECK_NULL);\n+      new_size, CHECK_NULL);\n@@ -117,9 +125,0 @@\n-void BytecodeAssembler::xload(u4 index, u1 onebyteop, u1 twobyteop) {\n-  if (index < 4) {\n-    _code->append(onebyteop + index);\n-  } else {\n-    _code->append(twobyteop);\n-    _code->append((u2)index);\n-  }\n-}\n-\n@@ -130,2 +129,2 @@\n-void BytecodeAssembler::_new(Symbol* sym) {\n-  u2 cpool_index = _cp->klass(sym);\n+void BytecodeAssembler::_new(Symbol* sym, TRAPS) {\n+  u2 cpool_index = _cp->klass(sym, CHECK);\n@@ -136,2 +135,2 @@\n-void BytecodeAssembler::load_string(Symbol* sym) {\n-  u2 cpool_index = _cp->string(sym);\n+void BytecodeAssembler::load_string(Symbol* sym, TRAPS) {\n+  u2 cpool_index = _cp->string(sym, CHECK);\n@@ -139,1 +138,1 @@\n-    ldc(cpool_index);\n+    ldc((u1)cpool_index);\n@@ -159,51 +158,2 @@\n-void BytecodeAssembler::iload(u4 index) {\n-  xload(index, Bytecodes::_iload_0, Bytecodes::_iload);\n-}\n-\n-void BytecodeAssembler::lload(u4 index) {\n-  xload(index, Bytecodes::_lload_0, Bytecodes::_lload);\n-}\n-\n-void BytecodeAssembler::fload(u4 index) {\n-  xload(index, Bytecodes::_fload_0, Bytecodes::_fload);\n-}\n-\n-void BytecodeAssembler::dload(u4 index) {\n-  xload(index, Bytecodes::_dload_0, Bytecodes::_dload);\n-}\n-\n-void BytecodeAssembler::aload(u4 index) {\n-  xload(index, Bytecodes::_aload_0, Bytecodes::_aload);\n-}\n-\n-void BytecodeAssembler::load(BasicType bt, u4 index) {\n-  switch (bt) {\n-    case T_BOOLEAN:\n-    case T_CHAR:\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:     iload(index); break;\n-    case T_FLOAT:   fload(index); break;\n-    case T_DOUBLE:  dload(index); break;\n-    case T_LONG:    lload(index); break;\n-    default:\n-      if (is_reference_type(bt)) {\n-                    aload(index);\n-                    break;\n-      }\n-      ShouldNotReachHere();\n-  }\n-}\n-\n-void BytecodeAssembler::checkcast(Symbol* sym) {\n-  u2 cpool_index = _cp->klass(sym);\n-  _code->append(Bytecodes::_checkcast);\n-  append(cpool_index);\n-}\n-\n-void BytecodeAssembler::invokespecial(Method* method) {\n-  invokespecial(method->klass_name(), method->name(), method->signature());\n-}\n-\n-void BytecodeAssembler::invokespecial(Symbol* klss, Symbol* name, Symbol* sig) {\n-  u2 methodref_index = _cp->methodref(klss, name, sig);\n+void BytecodeAssembler::invokespecial(Symbol* klss, Symbol* name, Symbol* sig, TRAPS) {\n+  u2 methodref_index = _cp->methodref(klss, name, sig, CHECK);\n@@ -214,3 +164,4 @@\n-void BytecodeAssembler::invokevirtual(Method* method) {\n-  invokevirtual(method->klass_name(), method->name(), method->signature());\n-}\n+int BytecodeAssembler::assemble_method_error(BytecodeConstantPool* cp,\n+                                             BytecodeBuffer* buffer,\n+                                             Symbol* errorName,\n+                                             Symbol* message, TRAPS) {\n@@ -218,5 +169,2 @@\n-void BytecodeAssembler::invokevirtual(Symbol* klss, Symbol* name, Symbol* sig) {\n-  u2 methodref_index = _cp->methodref(klss, name, sig);\n-  _code->append(Bytecodes::_invokevirtual);\n-  append(methodref_index);\n-}\n+  Symbol* init = vmSymbols::object_initializer_name();\n+  Symbol* sig = vmSymbols::string_void_signature();\n@@ -224,3 +172,1 @@\n-void BytecodeAssembler::ireturn() {\n-  _code->append(Bytecodes::_ireturn);\n-}\n+  BytecodeAssembler assem(buffer, cp);\n@@ -228,3 +174,5 @@\n-void BytecodeAssembler::lreturn() {\n-  _code->append(Bytecodes::_lreturn);\n-}\n+  assem._new(errorName, CHECK_0);\n+  assem.dup();\n+  assem.load_string(message, CHECK_0);\n+  assem.invokespecial(errorName, init, sig, CHECK_0);\n+  assem.athrow();\n@@ -232,34 +180,1 @@\n-void BytecodeAssembler::freturn() {\n-  _code->append(Bytecodes::_freturn);\n-}\n-\n-void BytecodeAssembler::dreturn() {\n-  _code->append(Bytecodes::_dreturn);\n-}\n-\n-void BytecodeAssembler::areturn() {\n-  _code->append(Bytecodes::_areturn);\n-}\n-\n-void BytecodeAssembler::_return() {\n-  _code->append(Bytecodes::_return);\n-}\n-\n-void BytecodeAssembler::_return(BasicType bt) {\n-  switch (bt) {\n-    case T_BOOLEAN:\n-    case T_CHAR:\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:     ireturn(); break;\n-    case T_FLOAT:   freturn(); break;\n-    case T_DOUBLE:  dreturn(); break;\n-    case T_LONG:    lreturn(); break;\n-    case T_VOID:    _return(); break;\n-    default:\n-      if (is_reference_type(bt)) {\n-                    areturn();\n-                    break;\n-      }\n-      ShouldNotReachHere();\n-  }\n+  return 3; \/\/ max stack size: [ exception, exception, string ]\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.cpp","additions":33,"deletions":118,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,1 +135,1 @@\n-  u2 find_or_add(BytecodeCPEntry const& bcpe);\n+  u2 find_or_add(BytecodeCPEntry const& bcpe, TRAPS);\n@@ -147,2 +147,2 @@\n-  u2 utf8(Symbol* sym) {\n-    return find_or_add(BytecodeCPEntry::utf8(sym));\n+  u2 utf8(Symbol* sym, TRAPS) {\n+    return find_or_add(BytecodeCPEntry::utf8(sym), THREAD);\n@@ -151,2 +151,3 @@\n-  u2 klass(Symbol* class_name) {\n-    return find_or_add(BytecodeCPEntry::klass(utf8(class_name)));\n+  u2 klass(Symbol* class_name, TRAPS) {\n+    u2 utf8_entry = utf8(class_name, CHECK_0);\n+    return find_or_add(BytecodeCPEntry::klass(utf8_entry), THREAD);\n@@ -155,2 +156,3 @@\n-  u2 string(Symbol* str) {\n-    return find_or_add(BytecodeCPEntry::string(utf8(str)));\n+  u2 string(Symbol* str, TRAPS) {\n+    u2 utf8_entry = utf8(str, CHECK_0);\n+    return find_or_add(BytecodeCPEntry::string(utf8_entry), THREAD);\n@@ -159,2 +161,4 @@\n-  u2 name_and_type(Symbol* name, Symbol* sig) {\n-    return find_or_add(BytecodeCPEntry::name_and_type(utf8(name), utf8(sig)));\n+  u2 name_and_type(Symbol* name, Symbol* sig, TRAPS) {\n+    u2 utf8_name = utf8(name, CHECK_0);\n+    u2 utf8_sig  = utf8(sig, CHECK_0);\n+    return find_or_add(BytecodeCPEntry::name_and_type(utf8_name, utf8_sig), THREAD);\n@@ -163,3 +167,4 @@\n-  u2 methodref(Symbol* class_name, Symbol* name, Symbol* sig) {\n-    return find_or_add(BytecodeCPEntry::methodref(\n-        klass(class_name), name_and_type(name, sig)));\n+  u2 methodref(Symbol* class_name, Symbol* name, Symbol* sig, TRAPS) {\n+    u2 klass_entry = klass(class_name, CHECK_0);\n+    u2 type_entry = name_and_type(name, sig, CHECK_0);\n+    return find_or_add(BytecodeCPEntry::methodref(klass_entry, type_entry), THREAD);\n@@ -182,1 +187,7 @@\n-  void xload(u4 index, u1 quick, u1 twobyte);\n+  void athrow();\n+  void dup();\n+  void invokespecial(Symbol* cls, Symbol* name, Symbol* sig, TRAPS);\n+  void ldc(u1 index);\n+  void ldc_w(u2 index);\n+  void _new(Symbol* sym, TRAPS);\n+  void load_string(Symbol* sym, TRAPS);\n@@ -188,25 +199,4 @@\n-  void aload(u4 index);\n-  void areturn();\n-  void athrow();\n-  void checkcast(Symbol* sym);\n-  void dload(u4 index);\n-  void dreturn();\n-  void dup();\n-  void fload(u4 index);\n-  void freturn();\n-  void iload(u4 index);\n-  void invokespecial(Method* method);\n-  void invokespecial(Symbol* cls, Symbol* name, Symbol* sig);\n-  void invokevirtual(Method* method);\n-  void invokevirtual(Symbol* cls, Symbol* name, Symbol* sig);\n-  void ireturn();\n-  void ldc(u1 index);\n-  void ldc_w(u2 index);\n-  void lload(u4 index);\n-  void lreturn();\n-  void _new(Symbol* sym);\n-  void _return();\n-\n-  void load_string(Symbol* sym);\n-  void load(BasicType bt, u4 index);\n-  void _return(BasicType bt);\n+  static int assemble_method_error(BytecodeConstantPool* cp,\n+                                   BytecodeBuffer* buffer,\n+                                   Symbol* errorName,\n+                                   Symbol* message, TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/bytecodeAssembler.hpp","additions":29,"deletions":39,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -868,17 +868,0 @@\n-static int assemble_method_error(\n-    BytecodeConstantPool* cp, BytecodeBuffer* buffer, Symbol* errorName, Symbol* message) {\n-\n-  Symbol* init = vmSymbols::object_initializer_name();\n-  Symbol* sig = vmSymbols::string_void_signature();\n-\n-  BytecodeAssembler assem(buffer, cp);\n-\n-  assem._new(errorName);\n-  assem.dup();\n-  assem.load_string(message);\n-  assem.invokespecial(errorName, init, sig);\n-  assem.athrow();\n-\n-  return 3; \/\/ max stack size: [ exception, exception, string ]\n-}\n-\n@@ -904,2 +887,4 @@\n-  m->set_name_index(cp->utf8(name));\n-  m->set_signature_index(cp->utf8(sig));\n+  u2 name_index = cp->utf8(name, CHECK_NULL);\n+  m->set_name_index(name_index);\n+  u2 sig_index = cp->utf8(sig, CHECK_NULL);\n+  m->set_signature_index(sig_index);\n@@ -992,2 +977,2 @@\n-        int max_stack = assemble_method_error(&bpool, buffer,\n-           method->get_exception_name(), method->get_exception_message());\n+        int max_stack = BytecodeAssembler::assemble_method_error(&bpool, buffer,\n+           method->get_exception_name(), method->get_exception_message(), CHECK);\n@@ -1076,1 +1061,5 @@\n-  int new_size = klass->methods()->length() + new_methods->length();\n+  int new_methods_length = klass->methods()->length() + new_methods->length();\n+  assert(new_methods_length <= USHRT_MAX,\n+         \"error methods for default method processing caused too many methods in class %s\",\n+         klass->external_name());\n+  u2 new_size = static_cast<u2>(new_methods_length);\n@@ -1094,1 +1083,1 @@\n-  for (int i = 0; i < new_size; ++i) {\n+  for (u2 i = 0; i < new_size; ++i) {\n","filename":"src\/hotspot\/share\/classfile\/defaultMethods.cpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"}]}