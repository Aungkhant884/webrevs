{"files":[{"patch":"@@ -73,2 +73,8 @@\n-                                certs.add(X509CertImpl.getFingerprint(HASH, cert));\n-                                certIssuers.add(cert.getSubjectX500Principal());\n+                                String fp =\n+                                    X509CertImpl.getFingerprint(HASH, cert, debug);\n+                                \/\/ only add trust anchor if fingerprint can\n+                                \/\/ be calculated\n+                                if (fp != null) {\n+                                    certs.add(fp);\n+                                    certIssuers.add(cert.getSubjectX500Principal());\n+                                }\n@@ -96,2 +102,2 @@\n-        String key = X509CertImpl.getFingerprint(HASH, cert);\n-        boolean result = certs.contains(key);\n+        String key = X509CertImpl.getFingerprint(HASH, cert, debug);\n+        boolean result = (key == null ? false : certs.contains(key));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/AnchorCertificates.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.security.cert.CertificateException;\n@@ -83,11 +82,3 @@\n-        String key;\n-        if (cert instanceof X509CertImpl) {\n-            key = ((X509CertImpl)cert).getFingerprint(algorithm);\n-        } else {\n-            try {\n-                key = new X509CertImpl(cert.getEncoded()).getFingerprint(algorithm);\n-            } catch (CertificateException cee) {\n-                return false;\n-            }\n-        }\n-        return props.containsKey(key);\n+        \/\/ if fingerprint cannot be calculated, also treat it as untrusted\n+        String key = X509CertImpl.getFingerprint(algorithm, cert, debug);\n+        return (key == null || props.containsKey(key));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/UntrustedCertificates.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import sun.security.util.Debug;\n@@ -43,0 +44,2 @@\n+    private static final Debug debug = Debug.getInstance(\"certpath\");\n+\n@@ -157,1 +160,6 @@\n-        if (FINGERPRINTS.contains(fingerprint(anchor))) {\n+        String fp = fingerprint(anchor);\n+        if (fp == null) {\n+            throw new ValidatorException(\"Cannot generate fingerprint for \"\n+                + \"trust anchor of TLS server certificate\");\n+        }\n+        if (FINGERPRINTS.contains(fp)) {\n@@ -164,1 +172,6 @@\n-                LocalDate distrustDate = EXEMPT_SUBCAS.get(fingerprint(subCA));\n+                fp = fingerprint(subCA);\n+                if (fp == null) {\n+                    throw new ValidatorException(\"Cannot generate fingerprint \"\n+                        + \"for intermediate CA of TLS server certificate\");\n+                }\n+                LocalDate distrustDate = EXEMPT_SUBCAS.get(fp);\n@@ -177,3 +190,1 @@\n-        return (cert instanceof X509CertImpl)\n-               ? ((X509CertImpl)cert).getFingerprint(\"SHA-256\")\n-               : X509CertImpl.getFingerprint(\"SHA-256\", cert);\n+        return X509CertImpl.getFingerprint(\"SHA-256\", cert, debug);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/SymantecTLSPolicy.java","additions":17,"deletions":6,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1920,1 +1920,1 @@\n-    public String getFingerprint(String algorithm) {\n+    private String getFingerprint(String algorithm, Debug debug) {\n@@ -1922,1 +1922,25 @@\n-            x -> getFingerprint(x, this));\n+            x -> {\n+                try {\n+                    return getFingerprintInternal(x, getEncodedInternal(), debug);\n+                } catch (CertificateEncodingException e) {\n+                    if (debug != null) {\n+                        debug.println(\"Cannot encode certificate: \" + e);\n+                    }\n+                    return null;\n+                }\n+            });\n+    }\n+\n+    private static String getFingerprintInternal(String algorithm,\n+            byte[] encodedCert, Debug debug) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(algorithm);\n+            byte[] digest = md.digest(encodedCert);\n+            return HexFormat.of().withUpperCase().formatHex(digest);\n+        } catch (NoSuchAlgorithmException e) {\n+            if (debug != null) {\n+                debug.println(\"Cannot create \" + algorithm\n+                    + \" MessageDigest: \" + e);\n+            }\n+            return null;\n+        }\n@@ -1926,1 +1950,1 @@\n-     * Gets the requested finger print of the certificate. The result\n+     * Gets the requested fingerprint of the certificate. The result\n@@ -1928,0 +1952,5 @@\n+     *\n+     * @param algorithm the MessageDigest algorithm\n+     * @param cert the X509Certificate\n+     * @return the fingerprint, or null if it cannot be calculated because\n+     *     of an exception\n@@ -1930,8 +1959,12 @@\n-            X509Certificate cert) {\n-        try {\n-            byte[] encCertInfo = cert.getEncoded();\n-            MessageDigest md = MessageDigest.getInstance(algorithm);\n-            byte[] digest = md.digest(encCertInfo);\n-            return HexFormat.of().withUpperCase().formatHex(digest);\n-        } catch (NoSuchAlgorithmException | CertificateEncodingException e) {\n-            \/\/ ignored\n+            X509Certificate cert, Debug debug) {\n+        if (cert instanceof X509CertImpl) {\n+            return ((X509CertImpl)cert).getFingerprint(algorithm, debug);\n+        } else {\n+            try {\n+                return getFingerprintInternal(algorithm, cert.getEncoded(), debug);\n+            } catch (CertificateEncodingException e) {\n+                if (debug != null) {\n+                    debug.println(\"Cannot encode certificate: \" + e);\n+                }\n+                return null;\n+            }\n@@ -1939,1 +1972,0 @@\n-        return \"\";\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":45,"deletions":13,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8270946\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.x509\n+ *          java.base\/sun.security.util\n+ * @summary Check that X509CertImpl.getFingerprint does not return null when\n+ *          there are errors calculating the fingerprint\n+ *\/\n+\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.X509Certificate;\n+import sun.security.x509.X509CertImpl;\n+import sun.security.util.Debug;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.CertUtils;\n+\n+public class GetFingerprintError {\n+\n+    private static final Debug dbg = Debug.getInstance(\"certpath\");\n+\n+    public static void main(String[] args) throws Exception {\n+        X509Certificate cert = CertUtils.getCertFromString(CertUtils.RSA_CERT);\n+\n+        \/\/ test invalid MessageDigest algorithm\n+        Asserts.assertNull(X509CertImpl.getFingerprint(\"NoSuchAlg\", cert, dbg));\n+\n+        \/\/ test cert with bad encoding\n+        X509Certificate fcert = new X509CertificateWithBadEncoding(cert);\n+        Asserts.assertNull(X509CertImpl.getFingerprint(\"SHA-256\", fcert, dbg));\n+    }\n+\n+    private static class X509CertificateWithBadEncoding\n+            extends CertUtils.ForwardingX509Certificate {\n+        private X509CertificateWithBadEncoding(X509Certificate cert) {\n+            super(cert);\n+        }\n+        @Override\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            throw new CertificateEncodingException();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/x509\/X509CertImpl\/GetFingerprintError.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,0 +38,1 @@\n+import java.math.BigInteger;\n@@ -41,0 +42,1 @@\n+import java.security.InvalidKeyException;\n@@ -43,0 +45,2 @@\n+import java.security.NoSuchProviderException;\n+import java.security.Principal;\n@@ -44,0 +48,2 @@\n+import java.security.PublicKey;\n+import java.security.SignatureException;\n@@ -49,0 +55,1 @@\n+import java.security.cert.CertificateEncodingException;\n@@ -50,0 +57,1 @@\n+import java.security.cert.CertificateExpiredException;\n@@ -51,0 +59,1 @@\n+import java.security.cert.CertificateNotYetValidException;\n@@ -62,0 +71,1 @@\n+import java.util.Date;\n@@ -633,0 +643,63 @@\n+\n+    \/**\n+     * This class is useful for overriding one or more methods of an\n+     * X509Certificate for testing purposes.\n+     *\/\n+    public static class ForwardingX509Certificate extends X509Certificate {\n+        private final X509Certificate cert;\n+        public ForwardingX509Certificate(X509Certificate cert) {\n+            this.cert = cert;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+           return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() throws CertificateExpiredException,\n+            CertificateNotYetValidException { \/* always pass *\/ }\n+        public void checkValidity(Date date) throws CertificateExpiredException,\n+            CertificateNotYetValidException { \/* always pass *\/ }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return cert.getNotBefore(); }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+            InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n","filename":"test\/lib\/jdk\/test\/lib\/security\/CertUtils.java","additions":74,"deletions":1,"binary":false,"changes":75,"status":"modified"}]}