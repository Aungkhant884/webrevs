{"files":[{"patch":"@@ -3387,1 +3387,1 @@\n-    if (_method->has_option_value(\"CompileThresholdScaling\", scale)) {\n+    if (_method->has_option_value(CompileCommand::CompileThresholdScaling, scale)) {\n@@ -3428,1 +3428,1 @@\n-  if (_method->has_option_value(\"CompileThresholdScaling\", scale)) {\n+  if (_method->has_option_value(CompileCommand::CompileThresholdScaling, scale)) {\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1096,1 +1096,1 @@\n-bool ciMethod::has_option(const char* option) {\n+bool ciMethod::has_option(enum CompileCommand option) {\n@@ -1100,1 +1100,1 @@\n-  return CompilerOracle::has_option_string(mh, option);\n+  return CompilerOracle::has_option(mh, option);\n@@ -1106,1 +1106,1 @@\n-bool ciMethod::has_option_value(const char* option, double& value) {\n+bool ciMethod::has_option_value(enum CompileCommand option, double& value) {\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,2 +301,2 @@\n-  bool has_option(const char *option);\n-  bool has_option_value(const char* option, double& value);\n+  bool has_option(enum CompileCommand option);\n+  bool has_option_value(enum CompileCommand option, double& value);\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -969,1 +969,1 @@\n-    if (printmethod || PrintDebugInfo || CompilerOracle::has_option_string(mh, \"PrintDebugInfo\")) {\n+    if (printmethod || PrintDebugInfo || CompilerOracle::has_option(mh, CompileCommand::PrintDebugInfo)) {\n@@ -973,1 +973,1 @@\n-    if (printmethod || PrintRelocations || CompilerOracle::has_option_string(mh, \"PrintRelocations\")) {\n+    if (printmethod || PrintRelocations || CompilerOracle::has_option(mh, CompileCommand::PrintRelocations)) {\n@@ -977,1 +977,1 @@\n-    if (printmethod || PrintDependencies || CompilerOracle::has_option_string(mh, \"PrintDependencies\")) {\n+    if (printmethod || PrintDependencies || CompilerOracle::has_option(mh, CompileCommand::PrintDependencies)) {\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1588,2 +1588,2 @@\n-  if (excluded || (CompilerOracle::has_option_value(method, \"CompileThresholdScaling\", scale) && scale == 0)) {\n-    bool quietly = CompilerOracle::should_exclude_quietly();\n+  if (excluded || (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, scale) && scale == 0)) {\n+    bool quietly = CompilerOracle::be_quiet();\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -143,1 +143,1 @@\n-  BasicMatcher* bm = BasicMatcher::parse_method_pattern(str, error_msg);\n+  BasicMatcher* bm = BasicMatcher::parse_method_pattern(str, error_msg, false);\n@@ -329,1 +329,1 @@\n-  if (!CompilerDirectivesIgnoreCompileCommandsOption && CompilerOracle::has_any_option()) {\n+  if (!CompilerDirectivesIgnoreCompileCommandsOption && CompilerOracle::has_any_command_set()) {\n@@ -362,2 +362,1 @@\n-    \/\/ ignore flags whose cc_flags are X\n-#define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] && CompilerOracle::has_option_value(method, #cc_flag, v) && v != this->name##Option) { set.cloned()->name##Option = v; } }\n+#define init_default_cc(name, type, dvalue, cc_flag) { type v; if (!_modified[name##Index] && CompilerOracle::has_option_value(method, CompileCommand::cc_flag, v) && v != this->name##Option) { set.cloned()->name##Option = v; } }\n@@ -373,1 +372,1 @@\n-        CompilerOracle::has_option_value(method, \"ControlIntrinsic\", option_value)) {\n+        CompilerOracle::has_option_value(method, CompileCommand::ControlIntrinsic, option_value)) {\n@@ -393,1 +392,1 @@\n-        CompilerOracle::has_option_value(method, \"DisableIntrinsic\", option_value)) {\n+        CompilerOracle::has_option_value(method, CompileCommand::DisableIntrinsic, option_value)) {\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    cflags(Enable,                  bool, false, X) \\\n-    cflags(Exclude,                 bool, false, X) \\\n+    cflags(Enable,                  bool, false, Unknown) \\\n+    cflags(Exclude,                 bool, false, Exclude) \\\n@@ -41,1 +41,1 @@\n-    cflags(Log,                     bool, LogCompilation, X) \\\n+    cflags(Log,                     bool, LogCompilation, Unknown) \\\n@@ -49,1 +49,1 @@\n-    cflags(CompilerDirectivesIgnoreCompileCommands, bool, CompilerDirectivesIgnoreCompileCommands, X) \\\n+    cflags(CompilerDirectivesIgnoreCompileCommands, bool, CompilerDirectivesIgnoreCompileCommands, Unknown) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,7 +41,4 @@\n-enum OptionType {\n-  IntxType,\n-  UintxType,\n-  BoolType,\n-  CcstrType,\n-  DoubleType,\n-  UnknownType\n+static const char* optiontype_names[] = {\n+#define enum_of_types(type, name) name,\n+        OPTION_TYPES(enum_of_types)\n+#undef enum_of_types\n@@ -50,0 +47,24 @@\n+const char* optiontype2name(enum OptionType type) {\n+  return optiontype_names[static_cast<int>(type)];\n+}\n+\n+static enum OptionType option_types[] = {\n+#define enum_of_options(option, name, ctype) OptionType::ctype,\n+        COMPILECOMMAND_OPTIONS(enum_of_options)\n+#undef enum_of_options\n+};\n+\n+enum OptionType option2type(enum CompileCommand option) {\n+  return option_types[static_cast<int>(option)];\n+}\n+\n+static const char* option_names[] = {\n+#define enum_of_options(option, name, ctype) name,\n+        COMPILECOMMAND_OPTIONS(enum_of_options)\n+#undef enum_of_options\n+};\n+\n+const char* option2name(enum CompileCommand option) {\n+  return option_names[static_cast<int>(option)];\n+}\n+\n@@ -53,1 +74,1 @@\n-  return UnknownType;\n+  return OptionType::Unknown;\n@@ -57,1 +78,1 @@\n-  return IntxType;\n+  return OptionType::Intx;\n@@ -61,1 +82,1 @@\n-  return UintxType;\n+  return OptionType::Uintx;\n@@ -65,1 +86,1 @@\n-  return BoolType;\n+  return OptionType::Bool;\n@@ -69,1 +90,1 @@\n-  return CcstrType;\n+  return OptionType::Ccstr;\n@@ -73,33 +94,2 @@\n-  return DoubleType;\n-}\n-\n-\/\/ this must parallel the command_names below\n-enum OracleCommand {\n-  UnknownCommand = -1,\n-  OracleFirstCommand = 0,\n-  BreakCommand = OracleFirstCommand,\n-  PrintCommand,\n-  ExcludeCommand,\n-  InlineCommand,\n-  DontInlineCommand,\n-  CompileOnlyCommand,\n-  LogCommand,\n-  OptionCommand,\n-  QuietCommand,\n-  HelpCommand,\n-  OracleCommandCount\n-};\n-\n-\/\/ this must parallel the enum OracleCommand\n-static const char * command_names[] = {\n-  \"break\",\n-  \"print\",\n-  \"exclude\",\n-  \"inline\",\n-  \"dontinline\",\n-  \"compileonly\",\n-  \"log\",\n-  \"option\",\n-  \"quiet\",\n-  \"help\"\n-};\n+  return OptionType::Double;\n+}\n@@ -110,1 +100,0 @@\n-static BasicMatcher* lists[OracleCommandCount] = { 0, };\n@@ -117,1 +106,1 @@\n-  const char*   _option;\n+  enum CompileCommand _option;\n@@ -131,2 +120,2 @@\n-    _type(UnknownType) {\n-      _option = NULL;\n+    _option(CompileCommand::Unknown),\n+    _type(OptionType::Unknown) {\n@@ -136,2 +125,2 @@\n-  static TypedMethodOptionMatcher* parse_method_pattern(char*& line, const char*& error_msg);\n-  TypedMethodOptionMatcher* match(const methodHandle& method, const char* opt, OptionType type);\n+  static TypedMethodOptionMatcher* parse_method_pattern(char*& line, char* errorbuf, const int buf_size);\n+  TypedMethodOptionMatcher* match(const methodHandle &method, enum CompileCommand option, OptionType type);\n@@ -139,1 +128,1 @@\n-  void init(const char* opt, OptionType type, TypedMethodOptionMatcher* next) {\n+  void init(enum CompileCommand option, OptionType type, TypedMethodOptionMatcher* next) {\n@@ -142,1 +131,7 @@\n-    _option = os::strdup_check_oom(opt);\n+    _option = option;\n+  }\n+\n+  void init_matcher(Symbol* class_name, Mode class_mode,\n+                    Symbol* method_name, Mode method_mode,\n+                    Symbol* signature) {\n+    MethodMatcher::init(class_name, class_mode, method_name, method_mode, signature);\n@@ -148,0 +143,1 @@\n+  enum CompileCommand option() { return _option; }\n@@ -153,1 +149,0 @@\n-  ~TypedMethodOptionMatcher();\n@@ -200,0 +195,1 @@\n+  const char* name = option2name(_option);\n@@ -201,2 +197,2 @@\n-  case IntxType:\n-    tty->print_cr(\" intx %s = \" INTX_FORMAT, _option, value<intx>());\n+  case OptionType::Intx:\n+    tty->print_cr(\" intx %s = \" INTX_FORMAT, name, value<intx>());\n@@ -204,2 +200,2 @@\n-  case UintxType:\n-    tty->print_cr(\" uintx %s = \" UINTX_FORMAT, _option, value<uintx>());\n+    case OptionType::Uintx:\n+    tty->print_cr(\" uintx %s = \" UINTX_FORMAT, name, value<uintx>());\n@@ -207,2 +203,2 @@\n-  case BoolType:\n-    tty->print_cr(\" bool %s = %s\", _option, value<bool>() ? \"true\" : \"false\");\n+    case OptionType::Bool:\n+    tty->print_cr(\" bool %s = %s\", name, value<bool>() ? \"true\" : \"false\");\n@@ -210,2 +206,2 @@\n-  case DoubleType:\n-    tty->print_cr(\" double %s = %f\", _option, value<double>());\n+    case OptionType::Double:\n+    tty->print_cr(\" double %s = %f\", name, value<double>());\n@@ -213,2 +209,2 @@\n-  case CcstrType:\n-    tty->print_cr(\" const char* %s = '%s'\", _option, value<ccstr>());\n+    case OptionType::Ccstr:\n+    tty->print_cr(\" const char* %s = '%s'\", name, value<ccstr>());\n@@ -249,8 +245,3 @@\n-TypedMethodOptionMatcher::~TypedMethodOptionMatcher() {\n-  if (_option != NULL) {\n-    os::free((void*)_option);\n-  }\n-}\n-\n-TypedMethodOptionMatcher* TypedMethodOptionMatcher::parse_method_pattern(char*& line, const char*& error_msg) {\n-  assert(error_msg == NULL, \"Dont call here with error_msg already set\");\n+TypedMethodOptionMatcher* TypedMethodOptionMatcher::parse_method_pattern(char*& line, char* errorbuf, const int buf_size) {\n+  assert(*errorbuf == '\\0', \"Dont call here with error_msg already set\");\n+  const char* error_msg = NULL;\n@@ -260,0 +251,1 @@\n+    jio_snprintf(errorbuf, buf_size, error_msg);\n@@ -266,1 +258,1 @@\n-TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, const char* opt, OptionType type) {\n+TypedMethodOptionMatcher* TypedMethodOptionMatcher::match(const methodHandle& method, enum CompileCommand option, OptionType type) {\n@@ -269,6 +261,3 @@\n-    \/\/ Fastest compare first.\n-    if (current->type() == type) {\n-      if (strcmp(current->_option, opt) == 0) {\n-        if (current->matches(method)) {\n-          return current;\n-        }\n+    if (current->_option == option) {\n+      if (current->matches(method)) {\n+        return current;\n@@ -283,3 +272,3 @@\n-static void add_option_string(TypedMethodOptionMatcher* matcher,\n-                                        const char* option,\n-                                        T value) {\n+static void register_command(TypedMethodOptionMatcher* matcher,\n+                             enum CompileCommand option,\n+                             T value) {\n@@ -287,1 +276,10 @@\n-  matcher->init(option, get_type_for<T>(), option_list);\n+  if (option == CompileCommand::Log && !LogCompilation) {\n+    tty->print_cr(\"Warning:  +LogCompilation must be enabled in order for individual methods to be logged with \");\n+    tty->print_cr(\"          CompileCommand=log,<method pattern>\");\n+  }\n+  enum OptionType type = option2type(option);\n+  if (type == OptionType::Ccstrlist) {\n+    type = OptionType::Ccstr; \/\/ ccstrlists are stores as ccstr\n+  }\n+  assert(type == get_type_for<T>(), \"sanity\");\n+  matcher->init(option, type, option_list);\n@@ -290,18 +288,3 @@\n-  any_set = true;\n-  return;\n-}\n-\n-static bool check_predicate(OracleCommand command, const methodHandle& method) {\n-  return ((lists[command] != NULL) &&\n-          !method.is_null() &&\n-          lists[command]->match(method));\n-}\n-\n-static void add_predicate(OracleCommand command, BasicMatcher* bm) {\n-  assert(command != OptionCommand, \"must use add_option_string\");\n-  if (command == LogCommand && !LogCompilation && lists[LogCommand] == NULL) {\n-    tty->print_cr(\"Warning:  +LogCompilation must be enabled in order for individual methods to be logged.\");\n-  }\n-  bm->set_next(lists[command]);\n-  lists[command] = bm;\n-  if ((command != DontInlineCommand) && (command != InlineCommand)) {\n+  if ((option != CompileCommand::DontInline) &&\n+      (option != CompileCommand::Inline) &&\n+      (option != CompileCommand::Log)) {\n@@ -310,0 +293,6 @@\n+  if (!CompilerOracle::be_quiet()) {\n+    \/\/ Print out the succesful registration of a comile command\n+    ttyLocker ttyl;\n+    tty->print(\"CompileCommand: %s \", option2name(option));\n+    matcher->print();\n+  }\n@@ -314,1 +303,18 @@\n-bool CompilerOracle::has_option_value(const methodHandle& method, const char* option, T& value) {\n+bool CompilerOracle::has_option_value(const methodHandle& method, enum CompileCommand option, T& value, bool verify_type) {\n+  enum OptionType type = option2type(option);\n+  if (type == OptionType::Unknown) {\n+    return false; \/\/ Can't query options with type Unknown.\n+  }\n+  if (type == OptionType::Ccstrlist) {\n+    type = OptionType::Ccstr; \/\/ CCstrList type options are stored as Ccstr\n+  }\n+  if (verify_type) {\n+    if (type != get_type_for<T>()) {\n+      \/\/ Whitebox API expects false if option and type doesn't match\n+      return false;\n+    }\n+  } else {\n+    assert(type == get_type_for<T>(), \"Value type (%s) must match option %s (%s)\",\n+            optiontype2name(get_type_for<T>()),\n+           option2name(option), optiontype2name(option2type(option)));\n+  }\n@@ -316,1 +322,1 @@\n-    TypedMethodOptionMatcher* m = option_list->match(method, option, get_type_for<T>());\n+    TypedMethodOptionMatcher* m = option_list->match(method, option, type);\n@@ -325,1 +331,21 @@\n-bool CompilerOracle::has_any_option() {\n+static bool check_predicate(enum CompileCommand option, const methodHandle& method) {\n+  bool value = false;\n+  if (CompilerOracle::has_option_value(method, option, value)) {\n+    return value;\n+  }\n+  return false;\n+}\n+\n+static bool has_command(enum CompileCommand option) {\n+  TypedMethodOptionMatcher* m = option_list;\n+  while (m != NULL) {\n+    if (m->option() == option) {\n+      return true;\n+    } else {\n+      m = m->next();\n+    }\n+  }\n+  return false;\n+}\n+\n+bool CompilerOracle::has_any_command_set() {\n@@ -330,5 +356,5 @@\n-template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, const char* option, intx& value);\n-template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, const char* option, uintx& value);\n-template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, const char* option, bool& value);\n-template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, const char* option, ccstr& value);\n-template bool CompilerOracle::has_option_value<double>(const methodHandle& method, const char* option, double& value);\n+template bool CompilerOracle::has_option_value<intx>(const methodHandle& method, enum CompileCommand option, intx& value, bool verify_type);\n+template bool CompilerOracle::has_option_value<uintx>(const methodHandle& method, enum CompileCommand option, uintx& value, bool verify_type);\n+template bool CompilerOracle::has_option_value<bool>(const methodHandle& method, enum CompileCommand option, bool& value, bool verify_type);\n+template bool CompilerOracle::has_option_value<ccstr>(const methodHandle& method, enum CompileCommand option, ccstr& value, bool verify_type);\n+template bool CompilerOracle::has_option_value<double>(const methodHandle& method, enum CompileCommand option, double& value, bool verify_type);\n@@ -336,1 +362,1 @@\n-bool CompilerOracle::has_option_string(const methodHandle& method, const char* option) {\n+bool CompilerOracle::has_option(const methodHandle& method, enum CompileCommand option) {\n@@ -343,1 +369,1 @@\n-  if (check_predicate(ExcludeCommand, method)) {\n+  if (check_predicate(CompileCommand::Exclude, method)) {\n@@ -346,2 +372,2 @@\n-  if (lists[CompileOnlyCommand] != NULL) {\n-    return !lists[CompileOnlyCommand]->match(method);\n+  if (has_command(CompileCommand::CompileOnly)) {\n+    return !check_predicate(CompileCommand::CompileOnly, method);\n@@ -353,1 +379,1 @@\n-  return (check_predicate(InlineCommand, method));\n+  return (check_predicate(CompileCommand::Inline, method));\n@@ -357,1 +383,1 @@\n-  return check_predicate(DontInlineCommand, method) || check_predicate(ExcludeCommand, method);\n+  return check_predicate(CompileCommand::DontInline, method) || check_predicate(CompileCommand::Exclude, method);\n@@ -361,1 +387,1 @@\n-  return check_predicate(PrintCommand, method);\n+  return check_predicate(CompileCommand::Print, method);\n@@ -365,1 +391,1 @@\n-  return lists[PrintCommand] != NULL;\n+  return has_command(CompileCommand::Print);\n@@ -369,3 +395,5 @@\n-  if (!LogCompilation)            return false;\n-  if (lists[LogCommand] == NULL)  return true;  \/\/ by default, log all\n-  return (check_predicate(LogCommand, method));\n+  if (!LogCompilation) return false;\n+  if (!has_command(CompileCommand::Log)) {\n+    return true;  \/\/ by default, log all\n+  }\n+  return (check_predicate(CompileCommand::Log, method));\n@@ -375,1 +403,1 @@\n-  return check_predicate(BreakCommand, method);\n+  return check_predicate(CompileCommand::Break, method);\n@@ -378,3 +406,2 @@\n-static OracleCommand parse_command_name(const char * line, int* bytes_read) {\n-  assert(ARRAY_SIZE(command_names) == OracleCommandCount,\n-         \"command_names size mismatch\");\n+static enum CompileCommand parse_option_name(const char* line, int* bytes_read, char* errorbuf, int bufsize) {\n+  assert(ARRAY_SIZE(option_names) == static_cast<int>(CompileCommand::Count), \"option_names size mismatch\");\n@@ -383,2 +410,2 @@\n-  char command[33];\n-  int matches = sscanf(line, \"%32[a-z]%n\", command, bytes_read);\n+  char option_buf[256];\n+  int matches = sscanf(line, \"%255[a-zA-Z0-9]%n\", option_buf, bytes_read);\n@@ -386,3 +413,3 @@\n-    for (uint i = 0; i < ARRAY_SIZE(command_names); i++) {\n-      if (strcmp(command, command_names[i]) == 0) {\n-        return (OracleCommand)i;\n+    for (uint i = 0; i < ARRAY_SIZE(option_names); i++) {\n+      if (strcasecmp(option_buf, option_names[i]) == 0) {\n+        return static_cast<enum CompileCommand>(i);\n@@ -392,1 +419,25 @@\n-  return UnknownCommand;\n+  jio_snprintf(errorbuf, bufsize, \"Unrecognized option '%s'\", option_buf);\n+  return CompileCommand::Unknown;\n+}\n+\n+void print_tip() { \/\/ CMH Update info\n+  tty->cr();\n+  tty->print_cr(\"Usage: '-XX:CompileCommand=<option>,<method pattern>' - to set boolean option to true\");\n+  tty->print_cr(\"Usage: '-XX:CompileCommand=<option>,<method pattern>,<value>'\");\n+  tty->print_cr(\"Use:   '-XX:CompileCommand=help' for more information and to list all option.\");\n+  tty->cr();\n+}\n+\n+void print_option(enum CompileCommand option, const char* name, enum OptionType type) {\n+  if (type != OptionType::Unknown) {\n+    tty->print_cr(\"    %s (%s)\", name, optiontype2name(type));\n+  }\n+}\n+\n+void print_commands() {\n+  tty->cr();\n+  tty->print_cr(\"All available options:\");\n+#define enum_of_options(option, name, ctype) print_option(CompileCommand::option, name, OptionType::ctype);\n+  COMPILECOMMAND_OPTIONS(enum_of_options)\n+#undef enum_of_options\n+  tty->cr();\n@@ -398,3 +449,6 @@\n-  tty->print_cr(\"behavior of the dynamic compilers. Many commands require a pattern that defines\");\n-  tty->print_cr(\"the set of methods the command shall be applied to. The CompileCommand\");\n-  tty->print_cr(\"option provides the following commands:\");\n+  tty->print_cr(\"behavior of the dynamic compilers.\");\n+  tty->cr();\n+  tty->print_cr(\"Compile commands has this general form:\");\n+  tty->print_cr(\"-XX:CompileCommand=<option><method pattern><value>\");\n+  tty->print_cr(\"    Sets <option> to the specified value for methods matching <method pattern>\");\n+  tty->print_cr(\"    All options are typed\");\n@@ -402,13 +456,3 @@\n-  tty->print_cr(\"  break,<pattern>       - debug breakpoint in compiler and in generated code\");\n-  tty->print_cr(\"  print,<pattern>       - print assembly\");\n-  tty->print_cr(\"  exclude,<pattern>     - don't compile or inline\");\n-  tty->print_cr(\"  inline,<pattern>      - always inline\");\n-  tty->print_cr(\"  dontinline,<pattern>  - don't inline\");\n-  tty->print_cr(\"  compileonly,<pattern> - compile only\");\n-  tty->print_cr(\"  log,<pattern>         - log compilation\");\n-  tty->print_cr(\"  option,<pattern>,<option type>,<option name>,<value>\");\n-  tty->print_cr(\"                        - set value of custom option\");\n-  tty->print_cr(\"  option,<pattern>,<bool option name>\");\n-  tty->print_cr(\"                        - shorthand for setting boolean flag\");\n-  tty->print_cr(\"  quiet                 - silence the compile command output\");\n-  tty->print_cr(\"  help                  - print this text\");\n+  tty->print_cr(\"-XX:CompileCommand=<option><method pattern>\");\n+  tty->print_cr(\"    Sets <option> to true for methods matching <method pattern>\");\n+  tty->print_cr(\"    Only applies to boolean options.\");\n@@ -416,1 +460,9 @@\n-  tty->print_cr(\"The preferred format for the method matching pattern is:\");\n+  tty->print_cr(\"-XX:CompileCommand=quiet\");\n+  tty->print_cr(\"    Silence the compile command output\");\n+  tty->cr();\n+  tty->print_cr(\"-XX:CompileCommand=help\");\n+  tty->print_cr(\"    Prints this help text\");\n+  tty->cr();\n+  print_commands();\n+  tty->cr();\n+    tty->print_cr(\"Method patterns has the format:\");\n@@ -426,1 +478,1 @@\n-  tty->print_cr(\"trailing *'s for a small amount of wildcarding:\");\n+  tty->print_cr(\"trailing *'s for wildcard matching:\");\n@@ -445,9 +497,7 @@\n-\/\/ Scan next flag and value in line, return MethodMatcher object on success, NULL on failure.\n-\/\/ On failure, error_msg contains description for the first error.\n-\/\/ For future extensions: set error_msg on first error.\n-static void scan_flag_and_value(const char* type, const char* line, int& total_bytes_read,\n-                                            TypedMethodOptionMatcher* matcher,\n-                                            char* errorbuf, const int buf_size) {\n-  total_bytes_read = 0;\n-  int bytes_read = 0;\n-  char flag[256];\n+int skip_whitespace(char* &line) {\n+  \/\/ Skip any leading spaces\n+  int whitespace_read = 0;\n+  sscanf(line, \"%*[ \\t]%n\", &whitespace_read);\n+  line += whitespace_read;\n+  return whitespace_read;\n+}\n@@ -455,4 +505,6 @@\n-  \/\/ Read flag name.\n-  if (sscanf(line, \"%*[ \\t]%255[a-zA-Z0-9]%n\", flag, &bytes_read) == 1) {\n-    line += bytes_read;\n-    total_bytes_read += bytes_read;\n+void skip_comma(char* &line) {\n+  \/\/ Skip any leading spaces\n+  if (*line == ',') {\n+    line++;\n+  }\n+}\n@@ -460,23 +512,49 @@\n-    \/\/ Read value.\n-    if (strcmp(type, \"intx\") == 0) {\n-      intx value;\n-      if (sscanf(line, \"%*[ \\t]\" INTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n-        total_bytes_read += bytes_read;\n-        add_option_string(matcher, flag, value);\n-        return;\n-      } else {\n-        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s \", flag, type);\n-      }\n-    } else if (strcmp(type, \"uintx\") == 0) {\n-      uintx value;\n-      if (sscanf(line, \"%*[ \\t]\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n-        total_bytes_read += bytes_read;\n-        add_option_string(matcher, flag, value);\n-        return;\n-      } else {\n-        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n-      }\n-    } else if (strcmp(type, \"ccstr\") == 0) {\n-      ResourceMark rm;\n-      char* value = NEW_RESOURCE_ARRAY(char, strlen(line) + 1);\n-      if (sscanf(line, \"%*[ \\t]%255[_a-zA-Z0-9]%n\", value, &bytes_read) == 1) {\n+static void scan_value(enum OptionType type, char* line, int& total_bytes_read,\n+        TypedMethodOptionMatcher* matcher, enum CompileCommand option, char* errorbuf, const int buf_size) {\n+  int bytes_read = 0;\n+  const char* ccname = option2name(option);\n+  const char* type_str = optiontype2name(type);\n+  int skipped = skip_whitespace(line);\n+  total_bytes_read += skipped;\n+  if (type == OptionType::Intx) {\n+    intx value;\n+    if (sscanf(line, \"\" INTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n+      total_bytes_read += bytes_read;\n+      line += bytes_read;\n+      register_command(matcher, option, value);\n+      return;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n+    }\n+  } else if (type == OptionType::Uintx) {\n+    uintx value;\n+    if (sscanf(line, \"\" UINTX_FORMAT \"%n\", &value, &bytes_read) == 1) {\n+      total_bytes_read += bytes_read;\n+      line += bytes_read;\n+      register_command(matcher, option, value);\n+      return;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n+    }\n+  } else if (type == OptionType::Ccstr) {\n+    ResourceMark rm;\n+    char* value = NEW_RESOURCE_ARRAY(char, strlen(line) + 1);\n+    if (sscanf(line, \"%255[_a-zA-Z0-9]%n\", value, &bytes_read) == 1) {\n+      total_bytes_read += bytes_read;\n+      line += bytes_read;\n+      register_command(matcher, option, (ccstr) value);\n+      return;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n+    }\n+  } else if (type == OptionType::Ccstrlist) {\n+    \/\/ Accumulates several strings into one. The internal type is ccstr.\n+    ResourceMark rm;\n+    char* value = NEW_RESOURCE_ARRAY(char, strlen(line) + 1);\n+    char* next_value = value;\n+    if (sscanf(line, \"%255[_a-zA-Z0-9+\\\\-]%n\", next_value, &bytes_read) == 1) {\n+      total_bytes_read += bytes_read;\n+      line += bytes_read;\n+      next_value += bytes_read + 1;\n+      char* end_value = next_value - 1;\n+      while (sscanf(line, \"%*[ \\t]%255[_a-zA-Z0-9+\\\\-]%n\", next_value, &bytes_read) == 1) {\n@@ -484,4 +562,4 @@\n-        add_option_string(matcher, flag, (ccstr)value);\n-        return;\n-      } else {\n-        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n+        line += bytes_read;\n+        *end_value = ' '; \/\/ override '\\0'\n+        next_value += bytes_read;\n+        end_value = next_value-1;\n@@ -489,6 +567,15 @@\n-    } else if (strcmp(type, \"ccstrlist\") == 0) {\n-      \/\/ Accumulates several strings into one. The internal type is ccstr.\n-      ResourceMark rm;\n-      char* value = NEW_RESOURCE_ARRAY(char, strlen(line) + 1);\n-      char* next_value = value;\n-      if (sscanf(line, \"%*[ \\t]%255[_a-zA-Z0-9+\\\\-]%n\", next_value, &bytes_read) == 1) {\n+      register_command(matcher, option, (ccstr) value);\n+      return;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n+    }\n+  } else if (type == OptionType::Bool) {\n+    char value[256];\n+    if (*line == '\\0') {\n+      \/\/ Short version of a CompileCommand sets a boolean Option to true\n+      \/\/ -XXCompileCommand=<Option>,<method pattern>\n+      register_command(matcher, option, true);\n+      return;\n+    }\n+    if (sscanf(line, \"%255[a-zA-Z]%n\", value, &bytes_read) == 1) {\n+      if (strcasecmp(value, \"true\") == 0) {\n@@ -497,10 +584,1 @@\n-        next_value += bytes_read;\n-        char* end_value = next_value-1;\n-        while (sscanf(line, \"%*[ \\t]%255[_a-zA-Z0-9+\\\\-]%n\", next_value, &bytes_read) == 1) {\n-          total_bytes_read += bytes_read;\n-          line += bytes_read;\n-          *end_value = ' '; \/\/ override '\\0'\n-          next_value += bytes_read;\n-          end_value = next_value-1;\n-        }\n-        add_option_string(matcher, flag, (ccstr)value);\n+        register_command(matcher, option, true);\n@@ -508,27 +586,1 @@\n-      } else {\n-        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n-      }\n-    } else if (strcmp(type, \"bool\") == 0) {\n-      char value[256];\n-      if (sscanf(line, \"%*[ \\t]%255[a-zA-Z]%n\", value, &bytes_read) == 1) {\n-        if (strcmp(value, \"true\") == 0) {\n-          total_bytes_read += bytes_read;\n-          add_option_string(matcher, flag, true);\n-          return;\n-        } else if (strcmp(value, \"false\") == 0) {\n-          total_bytes_read += bytes_read;\n-          add_option_string(matcher, flag, false);\n-          return;\n-        } else {\n-          jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n-        }\n-      } else {\n-        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n-      }\n-    } else if (strcmp(type, \"double\") == 0) {\n-      char buffer[2][256];\n-      \/\/ Decimal separator '.' has been replaced with ' ' or '\/' earlier,\n-      \/\/ so read integer and fraction part of double value separately.\n-      if (sscanf(line, \"%*[ \\t]%255[0-9]%*[ \/\\t]%255[0-9]%n\", buffer[0], buffer[1], &bytes_read) == 2) {\n-        char value[512] = \"\";\n-        jio_snprintf(value, sizeof(value), \"%s.%s\", buffer[0], buffer[1]);\n+      } else if (strcasecmp(value, \"false\") == 0) {\n@@ -536,1 +588,2 @@\n-        add_option_string(matcher, flag, atof(value));\n+        line += bytes_read;\n+        register_command(matcher, option, false);\n@@ -539,1 +592,1 @@\n-        jio_snprintf(errorbuf, buf_size, \"  Value cannot be read for flag %s of type %s\", flag, type);\n+        jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n@@ -542,1 +595,15 @@\n-      jio_snprintf(errorbuf, buf_size, \"  Type %s not supported \", type);\n+      jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n+    }\n+  } else if (type == OptionType::Double) {\n+    char buffer[2][256];\n+    \/\/ Decimal separator '.' has been replaced with ' ' or '\/' earlier,\n+    \/\/ so read integer and fraction part of double value separately.\n+    if (sscanf(line, \"%255[0-9]%*[ \/\\t]%255[0-9]%n\", buffer[0], buffer[1], &bytes_read) == 2) {\n+      char value[512] = \"\";\n+      jio_snprintf(value, sizeof(value), \"%s.%s\", buffer[0], buffer[1]);\n+      total_bytes_read += bytes_read;\n+      line += bytes_read;\n+      register_command(matcher, option, atof(value));\n+      return;\n+    } else {\n+      jio_snprintf(errorbuf, buf_size, \"Value cannot be read for option '%s' of type '%s'\", ccname, type_str);\n@@ -545,1 +612,1 @@\n-    jio_snprintf(errorbuf, buf_size, \"  Flag name for type %s should be alphanumeric \", type);\n+    jio_snprintf(errorbuf, buf_size, \"Type '%s' not supported \", type_str);\n@@ -547,1 +614,0 @@\n-  return;\n@@ -550,6 +616,9 @@\n-int skip_whitespace(char* line) {\n-  \/\/ Skip any leading spaces\n-  int whitespace_read = 0;\n-  sscanf(line, \"%*[ \\t]%n\", &whitespace_read);\n-  return whitespace_read;\n-}\n+\/\/ Scan next option and value in line, return MethodMatcher object on success, NULL on failure.\n+\/\/ On failure, error_msg contains description for the first error.\n+\/\/ For future extensions: set error_msg on first error.\n+static void scan_option_and_value(enum OptionType type, char* line, int& total_bytes_read,\n+                                TypedMethodOptionMatcher* matcher,\n+                                char* errorbuf, const int buf_size) {\n+  total_bytes_read = 0;\n+  int bytes_read = 0;\n+  char option_buf[256];\n@@ -557,2 +626,25 @@\n-void CompilerOracle::print_parse_error(const char*&  error_msg, char* original_line) {\n-  assert(error_msg != NULL, \"Must have error_message\");\n+  \/\/ Read option name.\n+  if (sscanf(line, \"%*[ \\t]%255[a-zA-Z0-9]%n\", option_buf, &bytes_read) == 1) {\n+    line += bytes_read;\n+    total_bytes_read += bytes_read;\n+    int bytes_read2 = 0;\n+    total_bytes_read += skip_whitespace(line);\n+    enum CompileCommand option = parse_option_name(option_buf, &bytes_read2, errorbuf, buf_size);\n+    if (option == CompileCommand::Unknown) {\n+      assert(*errorbuf != '\\0', \"error must have been set\");\n+      return;\n+    }\n+    enum OptionType optiontype = option2type(option);\n+    if (option2type(option) != type) {\n+      const char* optiontype_name = optiontype2name(optiontype);\n+      const char* type_name = optiontype2name(type);\n+      jio_snprintf(errorbuf, buf_size, \"Option '%s' with type '%s' doesn't match supplied type '%s'\", option_buf, optiontype_name, type_name);\n+      return;\n+    }\n+    scan_value(type, line, total_bytes_read, matcher, option, errorbuf, buf_size);\n+  } else {\n+    const char* type_str = optiontype2name(type);\n+    jio_snprintf(errorbuf, buf_size, \"Option name for type '%s' should be alphanumeric \", type_str);\n+  }\n+  return;\n+}\n@@ -560,0 +652,2 @@\n+void CompilerOracle::print_parse_error(char* error_msg, char* original_line) {\n+  assert(*error_msg != '\\0', \"Must have error_message\");\n@@ -562,1 +656,0 @@\n-  tty->print_cr(\"Line: %s\", original_line);\n@@ -564,1 +657,2 @@\n-  CompilerOracle::print_tip();\n+  tty->print_cr(\"Line: '%s'\", original_line);\n+  print_tip();\n@@ -567,0 +661,23 @@\n+enum OptionType parse_option_type(const char* type_str) {\n+  for (uint i = 0; i < ARRAY_SIZE(optiontype_names); i++) {\n+    if (strcasecmp(type_str, optiontype_names[i]) == 0) {\n+      return static_cast<enum OptionType>(i);\n+    }\n+  }\n+  return OptionType::Unknown;\n+}\n+\n+class LineCopy : StackObj {\n+  const char* _copy;\n+public:\n+    LineCopy(char* line) {\n+      _copy = os::strdup(line, mtInternal);\n+    }\n+    ~LineCopy() {\n+      os::free((void*)_copy);\n+    }\n+    char* get() {\n+      return (char*)_copy;\n+    }\n+};\n+\n@@ -571,1 +688,1 @@\n-  char* original_line = line;\n+  LineCopy original(line);\n@@ -573,1 +690,3 @@\n-  OracleCommand command = parse_command_name(line, &bytes_read);\n+  char error_buf[1024] = {0};\n+\n+  enum CompileCommand option = parse_option_name(line, &bytes_read, error_buf, sizeof(error_buf));\n@@ -577,5 +696,2 @@\n-  if (command == UnknownCommand) {\n-    ttyLocker ttyl;\n-    tty->print_cr(\"CompileCommand: unrecognized command\");\n-    tty->print_cr(\"  \\\"%s\\\"\", original_line);\n-    CompilerOracle::print_tip();\n+  if (option == CompileCommand::Unknown) {\n+    print_parse_error(error_buf, original.get());\n@@ -585,1 +701,1 @@\n-  if (command == QuietCommand) {\n+  if (option == CompileCommand::Quiet) {\n@@ -590,1 +706,1 @@\n-  if (command == HelpCommand) {\n+  if (option == CompileCommand::Help) {\n@@ -595,2 +711,1 @@\n-  const char* error_msg = NULL;\n-  if (command == OptionCommand) {\n+  if (option == CompileCommand::Option) {\n@@ -602,2 +717,2 @@\n-    \/\/ (1) CompileCommand=option,Klass::method,flag\n-    \/\/ (2) CompileCommand=option,Klass::method,type,flag,value\n+    \/\/ (1) CompileCommand=option,Klass::method,option\n+    \/\/ (2) CompileCommand=option,Klass::method,type,option,value\n@@ -605,1 +720,1 @@\n-    \/\/ Type (1) is used to enable a boolean flag for a method.\n+    \/\/ Type (1) is used to enable a boolean option for a method.\n@@ -609,2 +724,0 @@\n-    \/\/\n-    \/\/ For future extensions: extend scan_flag_and_value()\n@@ -612,3 +725,3 @@\n-    char option[256]; \/\/ stores flag for Type (1) and type of Type (2)\n-    line++; \/\/ skip the ','\n-    TypedMethodOptionMatcher* archetype = TypedMethodOptionMatcher::parse_method_pattern(line, error_msg);\n+    char option_type[256]; \/\/ stores option for Type (1) and type of Type (2)\n+    skip_comma(line);\n+    TypedMethodOptionMatcher* archetype = TypedMethodOptionMatcher::parse_method_pattern(line, error_buf, sizeof(error_buf));\n@@ -616,2 +729,1 @@\n-      assert(error_msg != NULL, \"Must have error_message\");\n-      print_parse_error(error_msg, original_line);\n+      print_parse_error(error_buf, original.get());\n@@ -621,1 +733,1 @@\n-    line += skip_whitespace(line);\n+    skip_whitespace(line);\n@@ -624,1 +736,1 @@\n-    while (sscanf(line, \"%255[a-zA-Z0-9]%n\", option, &bytes_read) == 1) {\n+    while (sscanf(line, \"%255[a-zA-Z0-9]%n\", option_type, &bytes_read) == 1) {\n@@ -629,13 +741,6 @@\n-      if (strcmp(option, \"intx\") == 0\n-          || strcmp(option, \"uintx\") == 0\n-          || strcmp(option, \"bool\") == 0\n-          || strcmp(option, \"ccstr\") == 0\n-          || strcmp(option, \"ccstrlist\") == 0\n-          || strcmp(option, \"double\") == 0\n-          ) {\n-        char errorbuf[1024] = {0};\n-        \/\/ Type (2) option: parse flag name and value.\n-        scan_flag_and_value(option, line, bytes_read, typed_matcher, errorbuf, sizeof(errorbuf));\n-        if (*errorbuf != '\\0') {\n-          error_msg = errorbuf;\n-          print_parse_error(error_msg, original_line);\n+      enum OptionType type = parse_option_type(option_type);\n+      if (type != OptionType::Unknown) {\n+        \/\/ Type (2) option: parse option name and value.\n+        scan_option_and_value(type, line, bytes_read, typed_matcher, error_buf, sizeof(error_buf));\n+        if (*error_buf != '\\0') {\n+          print_parse_error(error_buf, original.get());\n@@ -646,9 +751,8 @@\n-        \/\/ Type (1) option\n-        add_option_string(typed_matcher, option, true);\n-      }\n-      if (typed_matcher != NULL && !_quiet) {\n-        \/\/ Print out the last match added\n-        assert(error_msg == NULL, \"No error here\");\n-        ttyLocker ttyl;\n-        tty->print(\"CompileCommand: %s \", command_names[command]);\n-        typed_matcher->print();\n+        \/\/ Type (1) option - option_type contains the option name -> bool value = true is implied\n+        int bytes_read;\n+        enum CompileCommand option = parse_option_name(option_type, &bytes_read, error_buf, sizeof(error_buf));\n+        if (option == CompileCommand::Unknown) {\n+          print_parse_error(error_buf, original.get());\n+          return;\n+        }\n+        register_command(typed_matcher, option, true);\n@@ -656,1 +760,3 @@\n-      line += skip_whitespace(line);\n+      assert(typed_matcher != NULL, \"sanity\");\n+      assert(*error_buf == '\\0', \"No error here\");\n+      skip_whitespace(line);\n@@ -659,7 +765,11 @@\n-  } else {  \/\/ not an OptionCommand)\n-    assert(error_msg == NULL, \"Don't call here with error_msg already set\");\n-\n-    BasicMatcher* matcher = BasicMatcher::parse_method_pattern(line, error_msg);\n-    if (error_msg != NULL) {\n-      assert(matcher == NULL, \"consistency\");\n-      print_parse_error(error_msg, original_line);\n+  } else {  \/\/ not an OptionCommand\n+    \/\/ Command has the following form:\n+    \/\/ CompileCommand=<option>,<method pattern><value>\n+    \/\/ CompileCommand=<option>,<method pattern>     (implies option is bool and value is true)\n+    assert(*error_buf == '\\0', \"Don't call here with error_buf already set\");\n+    enum OptionType type = option2type(option);\n+    int bytes_read = 0;\n+    skip_comma(line);\n+    TypedMethodOptionMatcher* matcher = TypedMethodOptionMatcher::parse_method_pattern(line, error_buf, sizeof(error_buf));\n+    if (matcher == NULL) {\n+      print_parse_error(error_buf, original.get());\n@@ -668,7 +778,11 @@\n-\n-    add_predicate(command, matcher);\n-    if (!_quiet) {\n-      ttyLocker ttyl;\n-      tty->print(\"CompileCommand: %s \", command_names[command]);\n-      matcher->print(tty);\n-      tty->cr();\n+    skip_whitespace(line);\n+    if (*line == '\\0') {\n+      \/\/ if this is a bool option this implies true\n+      if (option2type(option) == OptionType::Bool) {\n+        register_command(matcher, option, true);\n+        return;\n+      } else {\n+        jio_snprintf(error_buf, sizeof(error_buf), \"  Option '%s' is not followed by a value\", option2name(option));\n+        print_parse_error(error_buf, original.get());\n+        return;\n+      }\n@@ -676,0 +790,6 @@\n+    scan_value(type, line, bytes_read, matcher, option, error_buf, sizeof(error_buf));\n+    if (*error_buf != '\\0') {\n+      print_parse_error(error_buf, original.get());\n+      return;\n+    }\n+    assert(matcher != NULL, \"consistency\");\n@@ -679,7 +799,0 @@\n-void CompilerOracle::print_tip() {\n-  tty->cr();\n-  tty->print_cr(\"Usage: '-XX:CompileCommand=command,\\\"package\/Class.method()\\\"'\");\n-  tty->print_cr(\"Use:   '-XX:CompileCommand=help' for more information.\");\n-  tty->cr();\n-}\n-\n@@ -758,1 +871,1 @@\n-  if (lists[PrintCommand] != NULL) {\n+  if (has_command(CompileCommand::Print)) {\n@@ -768,2 +881,1 @@\n-\n-void CompilerOracle::parse_compile_only(char * line) {\n+void CompilerOracle::parse_compile_only(char* line) {\n@@ -839,3 +951,3 @@\n-      BasicMatcher* bm = new BasicMatcher();\n-      bm->init(c_name, c_match, m_name, m_match, signature);\n-      add_predicate(CompileOnlyCommand, bm);\n+      TypedMethodOptionMatcher* tom = new TypedMethodOptionMatcher();\n+      tom->init_matcher(c_name, c_match, m_name, m_match, signature);\n+      register_command(tom, CompileCommand::CompileOnly, true);\n@@ -844,1 +956,1 @@\n-        lists[CompileOnlyCommand]->print_all(tty);\n+        tom->print();\n@@ -854,0 +966,6 @@\n+\n+enum CompileCommand CompilerOracle::string_to_option(const char* name) {\n+  int bytes_read = 0;\n+  char errorbuf[1024] = {0};\n+  return parse_option_name(name, &bytes_read, errorbuf, sizeof(errorbuf));\n+}\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":438,"deletions":320,"binary":false,"changes":758,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+\n@@ -36,0 +37,74 @@\n+\/\/       OPTION_TYPES: type, name\n+#define OPTION_TYPES(type) \\\n+  type(Intx, \"intx\") \\\n+  type(Uintx, \"uintx\") \\\n+  type(Bool, \"bool\") \\\n+  type(Ccstr, \"ccstr\") \\\n+  type(Ccstrlist, \"ccstrlist\") \\\n+  type(Double, \"double\")\n+\n+\/\/       COMPILECOMMAND_OPTIONS: option, name, variant, type\n+#define COMPILECOMMAND_OPTIONS(option) \\\n+  option(Help,  \"help\",  Unknown) \\\n+  option(Quiet, \"quiet\", Unknown) \\\n+  option(Log, \"log\", Bool) \\\n+  option(Print, \"print\", Bool) \\\n+  option(Inline,  \"inline\", Bool) \\\n+  option(DontInline,  \"dontinline\", Bool) \\\n+  option(CompileOnly, \"compileonly\", Bool)\\\n+  option(Exclude, \"exclude\", Bool) \\\n+  option(Break, \"break\", Bool) \\\n+  option(BreakAtExecute, \"BreakAtExecute\", Bool) \\\n+  option(BreakAtCompile, \"BreakAtCompile\", Bool) \\\n+  option(PrintAssembly, \"PrintAssembly\", Bool) \\\n+  option(PrintInlining, \"PrintInlining\", Bool) \\\n+  option(PrintIntrinsics, \"PrintIntrinsics\", Bool) \\\n+  option(PrintNMethods, \"PrintNMethods\", Bool)   \\\n+  option(PrintOptoAssembly, \"PrintOptoAssembly\", Bool) \\\n+  option(PrintDebugInfo,    \"PrintDebugInfo\",    Bool) \\\n+  option(PrintRelocations,  \"PrintRelocations\",  Bool) \\\n+  option(PrintDependencies, \"PrintDependencies\", Bool) \\\n+  option(BackgroundCompilation, \"BackgroundCompilation\", Bool) \\\n+  option(RepeatCompilation, \"RepeatCompilation\", Intx) \\\n+  option(ReplayInline,   \"ReplayInline\", Bool) \\\n+  option(DumpReplay,     \"DumpReplay\", Bool) \\\n+  option(DumpInline,     \"DumpInline\", Bool) \\\n+  option(CompileThresholdScaling, \"CompileThresholdScaling\", Double) \\\n+  option(ControlIntrinsic,  \"ControlIntrinsic\",  Ccstrlist) \\\n+  option(DisableIntrinsic,  \"DisableIntrinsic\",  Ccstrlist) \\\n+  option(NoRTMLockEliding,  \"NoRTMLockEliding\",  Bool) \\\n+  option(UseRTMLockEliding, \"UseRTMLockEliding\", Bool) \\\n+  option(BlockLayoutByFrequency, \"BlockLayoutByFrequency\", Bool) \\\n+  option(TraceOptoPipelining, \"TraceOptoPipelining\", Bool) \\\n+  option(TraceOptoOutput, \"TraceOptoOutput\", Bool) \\\n+  option(TraceSpilling, \"TraceSpilling\", Bool) \\\n+  option(PrintIdeal, \"PrintIdeal\", Bool) \\\n+  option(IGVPrintLevel, \"IGVPrintLevel\", Intx) \\\n+  option(Vectorize, \"Vectorize\", Bool) \\\n+  option(VectorizeDebug, \"VectorizeDebug\", Uintx) \\\n+  option(CloneMapDebug, \"CloneMapDebug\", Bool) \\\n+  option(MaxNodeLimit, \"MaxNodeLimit\", Intx)  \\\n+NOT_PRODUCT(option(TestOptionInt,    \"TestOptionInt\",    Intx)) \\\n+NOT_PRODUCT(option(TestOptionUint,   \"TestOptionUint\",   Uintx)) \\\n+NOT_PRODUCT(option(TestOptionBool,   \"TestOptionBool\",   Bool)) \\\n+NOT_PRODUCT(option(TestOptionBool2,  \"TestOptionBool2\",  Bool)) \\\n+NOT_PRODUCT(option(TestOptionStr,    \"TestOptionStr\",    Ccstr)) \\\n+NOT_PRODUCT(option(TestOptionList,   \"TestOptionList\",   Ccstrlist)) \\\n+NOT_PRODUCT(option(TestOptionDouble, \"TestOptionDouble\", Double)) \\\n+  option(Option, \"option\", Unknown) \\\n+  option(Unknown, \"unknown\", Unknown)\n+\n+enum class CompileCommand {\n+  #define enum_of_options(option, name, ctype) option,\n+    COMPILECOMMAND_OPTIONS(enum_of_options)\n+  #undef enum_of_options\n+  Count\n+};\n+\n+enum class OptionType {\n+#define enum_of_types(type, name) type,\n+    OPTION_TYPES(enum_of_types)\n+#undef enum_of_types\n+    Unknown\n+};\n+\n@@ -39,2 +114,2 @@\n-  static void print_tip();\n-  static void print_parse_error(const char*&  error_msg, char* original_line);\n+  static void print_parse_error(char* error_msg, char* original_line);\n+  static void print_command(enum CompileCommand option, const char* name, enum OptionType type);\n@@ -43,1 +118,0 @@\n-\n@@ -52,1 +126,1 @@\n-  static bool should_exclude_quietly() { return _quiet; }\n+  static bool be_quiet() { return _quiet; }\n@@ -69,2 +143,5 @@\n-  \/\/ Check to see if this method has option set for it\n-  static bool has_option_string(const methodHandle& method, const char * option);\n+  \/\/ Tells whether there are any methods to print for print_method_statistics()\n+  static bool should_print_methods();\n+\n+  \/\/ A wrapper for checking bool options\n+  static bool has_option(const methodHandle& method, enum CompileCommand option);\n@@ -75,4 +152,1 @@\n-  static bool has_option_value(const methodHandle& method, const char* option, T& value);\n-\n-  \/\/ Fast check if there is any option available that compile control needs to know about\n-  static bool has_any_option();\n+  static bool has_option_value(const methodHandle& method, enum CompileCommand option, T& value, bool verfiy_type = false);\n@@ -81,2 +155,1 @@\n-  static void parse_from_string(const char* command_string, void (*parser)(char*));\n-\n+  static void parse_from_string(const char* option_string, void (*parser)(char*));\n@@ -84,1 +157,1 @@\n-  static void parse_compile_only(char * line);\n+  static void parse_compile_only(char* line);\n@@ -86,2 +159,6 @@\n-  \/\/ Tells whether there are any methods to print for print_method_statistics()\n-  static bool should_print_methods();\n+  \/\/ Fast check if there is any option set that compile control needs to know about\n+  static bool has_any_command_set();\n+\n+  \/\/ convert a string to a proper compilecommand option - used from whitebox.\n+  \/\/ returns CompileCommand::Unknown on names not matching an option.\n+  static enum CompileCommand string_to_option(const char* name);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":92,"deletions":15,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -262,0 +262,4 @@\n+  if (*line == '\\0') {\n+    error_msg = \"Method pattern missing from command\";\n+    return;\n+  }\n@@ -355,1 +359,1 @@\n-BasicMatcher* BasicMatcher::parse_method_pattern(char* line, const char*& error_msg) {\n+BasicMatcher* BasicMatcher::parse_method_pattern(char* line, const char*& error_msg, bool expect_trailing_chars) {\n@@ -357,1 +361,1 @@\n-  BasicMatcher* bm = new BasicMatcher();\n+  BasicMatcher *bm = new BasicMatcher();\n@@ -363,8 +367,9 @@\n-\n-  \/\/ check for bad trailing characters\n-  int bytes_read = 0;\n-  sscanf(line, \"%*[ \\t]%n\", &bytes_read);\n-  if (line[bytes_read] != '\\0') {\n-    error_msg = \"Unrecognized trailing text after method pattern\";\n-    delete bm;\n-    return NULL;\n+  if (!expect_trailing_chars) {\n+    \/\/ check for bad trailing characters\n+    int bytes_read = 0;\n+    sscanf(line, \"%*[ \\t]%n\", &bytes_read);\n+    if (line[bytes_read] != '\\0') {\n+      error_msg = \"Unrecognized trailing text after method pattern\";\n+      delete bm;\n+      return NULL;\n+    }\n@@ -429,2 +434,1 @@\n-   int bytes_read = 0;\n-   assert(error_msg== NULL, \"error_msg must not be set yet\");\n+   assert(error_msg == NULL, \"error_msg must not be set yet\");\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.cpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-  static BasicMatcher* parse_method_pattern(char* line, const char*& error_msg);\n+  static BasicMatcher* parse_method_pattern(char* line, const char*& error_msg, bool expect_trailing_chars);\n","filename":"src\/hotspot\/share\/compiler\/methodMatcher.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  if (CompilerOracle::has_option_value(method, \"CompileThresholdScaling\", threshold_scaling)) {\n+  if (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, threshold_scaling)) {\n@@ -81,1 +81,1 @@\n-  if (CompilerOracle::has_option_value(method, \"CompileThresholdScaling\", threshold_scaling)) {\n+  if (CompilerOracle::has_option_value(method, CompileCommand::CompileThresholdScaling, threshold_scaling)) {\n","filename":"src\/hotspot\/share\/compiler\/tieredThresholdPolicy.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-    CompilerOracle::has_option_value(mh, \"CompileThresholdScaling\", scale);\n+    CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n","filename":"src\/hotspot\/share\/oops\/methodCounters.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1292,1 +1292,1 @@\n-  CompilerOracle::has_option_value(mh, \"CompileThresholdScaling\", scale);\n+  CompilerOracle::has_option_value(mh, CompileCommand::CompileThresholdScaling, scale);\n@@ -1309,2 +1309,2 @@\n-      !CompilerOracle::has_option_string(mh, \"NoRTMLockEliding\")) {\n-    if (CompilerOracle::has_option_string(mh, \"UseRTMLockEliding\") || !UseRTMDeopt) {\n+      !CompilerOracle::has_option(mh, CompileCommand::NoRTMLockEliding)) {\n+    if (CompilerOracle::has_option(mh, CompileCommand::UseRTMLockEliding) || !UseRTMDeopt) {\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -954,1 +954,1 @@\n-    if (method_has_option(\"NoRTMLockEliding\") || ((rtm_state & NoRTM) != 0)) {\n+    if (method_has_option(CompileCommand::NoRTMLockEliding) || ((rtm_state & NoRTM) != 0)) {\n@@ -957,1 +957,1 @@\n-    } else if (method_has_option(\"UseRTMLockEliding\") || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n+    } else if (method_has_option(CompileCommand::UseRTMLockEliding) || ((rtm_state & UseRTM) != 0) || !UseRTMDeopt) {\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -596,1 +596,1 @@\n-  bool          method_has_option(const char * option) {\n+  bool          method_has_option(enum CompileCommand option) {\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1051,1 +1051,1 @@\n-  BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);\n+  BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg, false);\n@@ -1805,1 +1805,1 @@\n-  bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);\n+  enum CompileCommand option = CompilerOracle::string_to_option(flag_name);\n@@ -1807,1 +1807,4 @@\n-  return result;\n+  if (option == CompileCommand::Unknown) {\n+    return false;\n+  }\n+  return CompilerOracle::has_option_value(mh, option, *value, true \/* verify type*\/);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ * @requires vm.debug == true\n@@ -46,2 +47,2 @@\n-    \/\/ (1) CompileCommand=option,Klass::method,flag\n-    \/\/ (2) CompileCommand=option,Klass::method,type,flag,value\n+    \/\/ (1) CompileCommand=option,Klass::method,option\n+    \/\/ (2) CompileCommand=option,Klass::method,type,option,value\n@@ -49,1 +50,1 @@\n-    \/\/ Type (1) is used to enable a boolean flag for a method.\n+    \/\/ Type (1) is used to enable a boolean option for a method.\n@@ -51,1 +52,1 @@\n-    \/\/ Type (2) is used to support flags with a value. Values can\n+    \/\/ Type (2) is used to support options with a value. Values can\n@@ -68,14 +69,14 @@\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption1 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption2 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption3 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption5 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption6 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption7 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption8 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption9 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption10 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption11 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption13 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption14 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption15 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test(I) bool MyBoolOption16 = true\"\n+            \"com\/oracle\/Test.test1 bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test2 bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test3 bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test4 bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test4 bool TestOptionBool2 = true\",\n+            \"com\/oracle\/Test.test5 bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test5 bool TestOptionBool2 = true\",\n+            \"com\/oracle\/Test.test6(I) bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test7(I) bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test8(I) bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test9(I) bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test9(I) bool TestOptionBool2 = true\",\n+            \"com\/oracle\/Test.test10(I) bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test10(I) bool TestOptionBool2 = true\"\n@@ -84,7 +85,7 @@\n-            \"CompileCommand: option Test.test const char* MyListOption = '_foo _bar'\",\n-            \"CompileCommand: option Test.test const char* MyStrOption = '_foo'\",\n-            \"CompileCommand: option Test.test bool MyBoolOption = false\",\n-            \"CompileCommand: option Test.test intx MyIntxOption = -1\",\n-            \"CompileCommand: option Test.test uintx MyUintxOption = 1\",\n-            \"CompileCommand: option Test.test bool MyFlag = true\",\n-            \"CompileCommand: option Test.test double MyDoubleOption = 1.123000\"\n+            \"Test.test const char* TestOptionList = '_foo _bar'\",\n+            \"Test.test const char* TestOptionStr = '_foo'\",\n+            \"Test.test bool TestOptionBool = false\",\n+            \"Test.test intx TestOptionInt = -1\",\n+            \"Test.test uintx TestOptionUint = 1\",\n+            \"Test.test bool TestOptionBool2 = true\",\n+            \"Test.test double TestOptionDouble = 1.123000\"\n@@ -96,5 +97,3 @@\n-            \"-XX:CompileCommand=option,com\/oracle\/Test.test,MyBoolOption1\",\n-            \"-XX:CompileCommand=option,com\/oracle\/Test,test,MyBoolOption2\",\n-            \"-XX:CompileCommand=option,com.oracle.Test::test,MyBoolOption3\",\n-            \"-XX:CompileCommand=option,com\/oracle\/Test.test,MyBoolOption5,MyBoolOption6\",\n-            \"-XX:CompileCommand=option,com\/oracle\/Test,test,MyBoolOption7,MyBoolOption8\",\n+            \"-XX:CompileCommand=option,com\/oracle\/Test.test,TestOptionBool\",\n+            \"-XX:CompileCommand=option,com\/oracle\/Test,test,TestOptionBool2\",\n+            \"-XX:CompileCommand=option,com\/oracle\/Test.test2,TestOptionBool2,TestOptionBool\",\n@@ -107,7 +106,4 @@\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption1 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption2 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption3 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption5 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption6 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption7 = true\",\n-            \"CompileCommand: option com\/oracle\/Test.test bool MyBoolOption8 = true\"\n+            \"com\/oracle\/Test.test bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test bool TestOptionBool2 = true\",\n+            \"com\/oracle\/Test.test2 bool TestOptionBool = true\",\n+            \"com\/oracle\/Test.test2 bool TestOptionBool2 = true\",\n@@ -119,9 +115,8 @@\n-            \"-XX:CompileCommand=option,Test::test,ccstrlist,MyListOption,_foo,_bar\",\n-            \"-XX:CompileCommand=option,Test::test,ccstr,MyStrOption,_foo\",\n-            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOption,false\",\n-            \"-XX:CompileCommand=option,Test::test,intx,MyIntxOption,-1\",\n-            \"-XX:CompileCommand=option,Test::test,uintx,MyUintxOption,1\",\n-            \"-XX:CompileCommand=option,Test::test,MyFlag\",\n-            \"-XX:CompileCommand=option,Test::test,double,MyDoubleOption1,1.123\",\n-            \"-XX:CompileCommand=option,Test.test,double,MyDoubleOption2,1.123\",\n-            \"-XX:CompileCommand=option,Test::test,bool,MyBoolOptionX,false,intx,MyIntxOptionX,-1,uintx,MyUintxOptionX,1,MyFlagX,double,MyDoubleOptionX,1.123\",\n+            \"-XX:CompileCommand=option,Test::test,ccstrlist,TestOptionList,_foo,_bar\",\n+            \"-XX:CompileCommand=option,Test::test,ccstr,TestOptionStr,_foo\",\n+            \"-XX:CompileCommand=option,Test::test,bool,TestOptionBool,false\",\n+            \"-XX:CompileCommand=option,Test::test,intx,TestOptionInt,-1\",\n+            \"-XX:CompileCommand=option,Test::test,uintx,TestOptionUint,1\",\n+            \"-XX:CompileCommand=option,Test::test,TestOptionBool2\",\n+            \"-XX:CompileCommand=option,Test::test,double,TestOptionDouble,1.123\",\n+            \"-XX:CompileCommand=option,Test.test2,double,TestOptionDouble,1.123\",\n@@ -134,13 +129,79 @@\n-            \"CompileCommand: option Test.test const char* MyListOption = '_foo _bar'\",\n-            \"CompileCommand: option Test.test const char* MyStrOption = '_foo'\",\n-            \"CompileCommand: option Test.test bool MyBoolOption = false\",\n-            \"CompileCommand: option Test.test intx MyIntxOption = -1\",\n-            \"CompileCommand: option Test.test uintx MyUintxOption = 1\",\n-            \"CompileCommand: option Test.test bool MyFlag = true\",\n-            \"CompileCommand: option Test.test double MyDoubleOption1 = 1.123000\",\n-            \"CompileCommand: option Test.test double MyDoubleOption2 = 1.123000\",\n-            \"CompileCommand: option Test.test bool MyBoolOptionX = false\",\n-            \"CompileCommand: option Test.test intx MyIntxOptionX = -1\",\n-            \"CompileCommand: option Test.test uintx MyUintxOptionX = 1\",\n-            \"CompileCommand: option Test.test bool MyFlagX = true\",\n-            \"CompileCommand: option Test.test double MyDoubleOptionX = 1.123000\",\n+            \"Test.test const char* TestOptionList = '_foo _bar'\",\n+            \"Test.test const char* TestOptionStr = '_foo'\",\n+            \"Test.test bool TestOptionBool = false\",\n+            \"Test.test intx TestOptionInt = -1\",\n+            \"Test.test uintx TestOptionUint = 1\",\n+            \"Test.test bool TestOptionBool2 = true\",\n+            \"Test.test double TestOptionDouble = 1.123000\",\n+            \"Test.test2 double TestOptionDouble = 1.123000\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_3_ARGUMENTS = {\n+        {\n+            \"-XX:CompileCommand=option,Test::test,bool,TestOptionBool,false,intx,TestOptionInt,-1,uintx,TestOptionUint,1,TestOptionBool2,double,TestOptionDouble,1.123\",\n+            \"-version\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_3_EXPECTED_OUTPUTS = {\n+        {\n+            \"Test.test bool TestOptionBool = false\",\n+            \"Test.test intx TestOptionInt = -1\",\n+            \"Test.test uintx TestOptionUint = 1\",\n+            \"Test.test bool TestOptionBool2 = true\",\n+            \"Test.test double TestOptionDouble = 1.123000\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_4_ARGUMENTS = {\n+        {\n+            \"-XX:CompileCommand=TestOptionList,Test::test,_foo,_bar\",\n+            \"-XX:CompileCommand=TestOptionStr,Test::test,_foo\",\n+            \"-XX:CompileCommand=TestOptionBool,Test::test,false\",\n+            \"-XX:CompileCommand=TestOptionInt,Test::test,-1\",\n+            \"-XX:CompileCommand=TestOptionUint,Test::test,1\",\n+            \"-XX:CompileCommand=TestOptionBool2,Test::test\",\n+            \"-XX:CompileCommand=TestOptionDouble,Test::test,1.123\",\n+            \"-XX:CompileCommand=TestOptionDouble,Test.test2,1.123\",\n+            \"-version\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_4_EXPECTED_OUTPUTS = {\n+        {\n+            \"CompileCommand: TestOptionList Test.test const char* TestOptionList = '_foo _bar'\",\n+            \"CompileCommand: TestOptionStr Test.test const char* TestOptionStr = '_foo'\",\n+            \"CompileCommand: TestOptionBool Test.test bool TestOptionBool = false\",\n+            \"CompileCommand: TestOptionInt Test.test intx TestOptionInt = -1\",\n+            \"CompileCommand: TestOptionUint Test.test uintx TestOptionUint = 1\",\n+            \"CompileCommand: TestOptionBool2 Test.test bool TestOptionBool2 = true\",\n+            \"CompileCommand: TestOptionDouble Test.test double TestOptionDouble = 1.123000\",\n+            \"CompileCommand: TestOptionDouble Test.test2 double TestOptionDouble = 1.123000\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_4_INVALID_ARGUMENTS = {\n+        {\n+            \"-XX:CompileCommand=InvalidOption,Test::test,_foo,_bar\",\n+            \"-XX:CompileCommand=TestOptionInt,Test::test,_foo\",\n+            \"-XX:CompileCommand=TestOptionBool,Test::test,1\",\n+            \"-XX:CompileCommand=TestOptionDouble,Test::test,-1\",\n+            \"-XX:CompileCommand=TestOptionUint,Test::test\",\n+            \"-XX:CompileCommand=TestOptionBool2,Test::test,falsee\",\n+            \"-XX:CompileCommand=TestOptionDouble,Test::test,true\",\n+            \"-XX:CompileCommand=TestOptionDouble,Test.test2,1.f\",\n+            \"-version\"\n+        }\n+    };\n+\n+    private static final String[][] TYPE_4_INVALID_OUTPUTS = {\n+        {\n+            \"Unrecognized option 'InvalidOption'\",\n+            \"Value cannot be read for option 'TestOptionInt' of type 'intx'\",\n+            \"Value cannot be read for option 'TestOptionBool' of type 'bool'\",\n+            \"Value cannot be read for option 'TestOptionDouble' of type 'double'\",\n+            \"Option 'TestOptionUint' is not followed by a value\",\n+            \"Value cannot be read for option 'TestOptionBool2' of type 'bool'\",\n+            \"Value cannot be read for option 'TestOptionDouble' of type 'double'\",\n+            \"Value cannot be read for option 'TestOptionDouble' of type 'double'\"\n@@ -214,0 +275,17 @@\n+    private static void verifyInvalidOption(String[] arguments, String[] expected_outputs) throws Exception {\n+        ProcessBuilder pb;\n+        OutputAnalyzer out;\n+\n+        pb = ProcessTools.createJavaProcessBuilder(arguments);\n+        out = new OutputAnalyzer(pb.start());\n+\n+        for (String expected_output : expected_outputs) {\n+            out.shouldContain(expected_output);\n+        }\n+\n+        out.shouldContain(\"CompileCommand: An error occurred during parsing\");\n+        out.shouldHaveExitValue(0);\n+\n+    }\n+\n+\n@@ -224,0 +302,8 @@\n+        if (TYPE_3_ARGUMENTS.length != TYPE_3_EXPECTED_OUTPUTS.length) {\n+            throw new RuntimeException(\"Test is set up incorrectly: length of arguments and expected outputs for type (3) options does not match.\");\n+        }\n+\n+        if (TYPE_4_ARGUMENTS.length != TYPE_4_EXPECTED_OUTPUTS.length) {\n+            throw new RuntimeException(\"Test is set up incorrectly: length of arguments and expected outputs for type (4) options does not match.\");\n+        }\n+\n@@ -234,0 +320,10 @@\n+        \/\/ Check if type (3) options are parsed correctly\n+        for (int i = 0; i < TYPE_3_ARGUMENTS.length; i++) {\n+            verifyValidOption(TYPE_3_ARGUMENTS[i], TYPE_3_EXPECTED_OUTPUTS[i]);\n+        }\n+\n+        \/\/ Check if type (4) options are parsed correctly\n+        for (int i = 0; i < TYPE_4_ARGUMENTS.length; i++) {\n+            verifyValidOption(TYPE_4_ARGUMENTS[i], TYPE_4_EXPECTED_OUTPUTS[i]);\n+        }\n+\n@@ -240,0 +336,6 @@\n+        \/\/ Check if error is reported for invalid type (2) options\n+        \/\/ (flags with type information specified)\n+        for (int i = 0; i < TYPE_4_INVALID_ARGUMENTS.length; i++) {\n+            verifyInvalidOption(TYPE_4_INVALID_ARGUMENTS[i], TYPE_4_INVALID_OUTPUTS[i]);\n+        }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/CheckCompileCommandOption.java","additions":161,"deletions":59,"binary":false,"changes":220,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+ * @requires vm.debug == true\n@@ -32,9 +33,21 @@\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,ccstrlist,MyListOption,_foo,_bar\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,ccstr,MyStrOption,_foo\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,bool,MyBoolOption,false\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,intx,MyIntxOption,-1\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,uintx,MyUintxOption,1\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,MyFlag\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,double,MyDoubleOption1,1.123\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,double,MyDoubleOption2,1.123\n- *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,bool,MyBoolOptionX,false,intx,MyIntxOptionX,-1,uintx,MyUintxOptionX,1,MyFlagX,double,MyDoubleOptionX,1.123\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,ccstrlist,TestOptionList,_foo,_bar\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,ccstr,TestOptionStr,_foo\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,bool,TestOptionBool,false\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,intx,TestOptionInt,-1\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,uintx,TestOptionUint,1\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,TestOptionBool2\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,double,TestOptionDouble,1.123\n+ *                   compiler.oracle.GetMethodOptionTest\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=option,compiler.oracle.GetMethodOptionTest::test,bool,TestOptionBool,false,intx,TestOptionInt,-1,uintx,TestOptionUint,1,bool,TestOptionBool2,true,ccstr,TestOptionStr,_foo,double,TestOptionDouble,1.123,ccstrlist,TestOptionList,_foo,_bar\n+ *                   compiler.oracle.GetMethodOptionTest\n+ *\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+ *                   -XX:CompileCommand=TestOptionList,compiler.oracle.GetMethodOptionTest::test,_foo,_bar\n+ *                   -XX:CompileCommand=TestOptionStr,compiler.oracle.GetMethodOptionTest::test,_foo\n+ *                   -XX:CompileCommand=TestOptionBool,compiler.oracle.GetMethodOptionTest::test,false\n+                     -XX:CompileCommand=TestOptionBool2,compiler.oracle.GetMethodOptionTest::test\n+ *                   -XX:CompileCommand=TestOptionInt,compiler.oracle.GetMethodOptionTest::test,-1\n+ *                   -XX:CompileCommand=TestOptionUint,compiler.oracle.GetMethodOptionTest::test,1\n+ *                   -XX:CompileCommand=TestOptionDouble,compiler.oracle.GetMethodOptionTest::test,1.123\n@@ -75,13 +88,7 @@\n-        MyListOption(\"_foo _bar\", WB::getMethodStringOption),\n-        MyStrOption(\"_foo\", WB::getMethodStringOption),\n-        MyBoolOption(false, WB::getMethodBooleanOption),\n-        MyIntxOption(-1L, WB::getMethodIntxOption),\n-        MyUintxOption(1L, WB::getMethodUintxOption),\n-        MyFlag(true, WB::getMethodBooleanOption),\n-        MyDoubleOption1(1.123d, WB::getMethodDoubleOption),\n-        MyDoubleOption2(1.123d, WB::getMethodDoubleOption),\n-        MyBoolOptionX(false, WB::getMethodBooleanOption),\n-        MyIntxOptionX(-1L, WB::getMethodIntxOption),\n-        MyUintxOptionX(1L, WB::getMethodUintxOption),\n-        MyFlagX(true, WB::getMethodBooleanOption),\n-        MyDoubleOptionX(1.123d, WB::getMethodDoubleOption);\n+        TestOptionBool(false, WB::getMethodBooleanOption),\n+        TestOptionStr(\"_foo\", WB::getMethodStringOption),\n+        TestOptionInt(-1L, WB::getMethodIntxOption),\n+        TestOptionUint(1L, WB::getMethodUintxOption),\n+        TestOptionBool2(true, WB::getMethodBooleanOption),\n+        TestOptionDouble(1.123d, WB::getMethodDoubleOption),\n+        TestOptionList(\"_foo _bar\", WB::getMethodStringOption);\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/GetMethodOptionTest.java","additions":29,"deletions":22,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,10 +1,10 @@\n-option,com\/oracle\/Test.test,MyBoolOption1\n-option,com\/oracle\/Test,test,MyBoolOption2\n-option,com.oracle.Test::test,MyBoolOption3\n-option,com\/oracle\/Test.test,MyBoolOption5,MyBoolOption6\n-option,com\/oracle\/Test,test,MyBoolOption7,MyBoolOption8\n-option,com\/oracle\/Test.test(I),MyBoolOption9\n-option,com\/oracle\/Test,test,(I),MyBoolOption10\n-option,com.oracle.Test::test(I),MyBoolOption11\n-option,com\/oracle\/Test.test(I),MyBoolOption13,MyBoolOption14\n-option,com\/oracle\/Test,test(I),MyBoolOption15,MyBoolOption16\n+option,com\/oracle\/Test.test1,TestOptionBool\n+option,com\/oracle\/Test,test2,TestOptionBool\n+option,com.oracle.Test::test3,TestOptionBool\n+option,com\/oracle\/Test.test4,TestOptionBool,TestOptionBool2\n+option,com\/oracle\/Test,test5,TestOptionBool,TestOptionBool2\n+option,com\/oracle\/Test.test6(I),TestOptionBool\n+option,com\/oracle\/Test,test7,(I),TestOptionBool\n+option,com.oracle.Test::test8(I),TestOptionBool\n+option,com\/oracle\/Test.test9(I),TestOptionBool,TestOptionBool2\n+option,com\/oracle\/Test,test10(I),TestOptionBool,TestOptionBool2\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/command1.txt","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,7 +1,7 @@\n-option,Test::test,ccstrlist,MyListOption,_foo,_bar\n-option,Test::test,ccstr,MyStrOption,_foo\n-option,Test::test,bool,MyBoolOption,false\n-option,Test::test,intx,MyIntxOption,-1\n-option,Test::test,uintx,MyUintxOption,1\n-option,Test::test,MyFlag\n-option,Test::test,double,MyDoubleOption,1.123\n+option,Test::test,ccstrlist,TestOptionList,_foo,_bar\n+option,Test::test,ccstr,TestOptionStr,_foo\n+option,Test::test,bool,TestOptionBool,false\n+option,Test::test,intx,TestOptionInt,-1\n+option,Test::test,uintx,TestOptionUint,1\n+option,Test::test,TestOptionBool2\n+option,Test::test,double,TestOptionDouble,1.123\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/command2.txt","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -51,1 +51,2 @@\n-        output.shouldContain(\"CompileCommand: unrecognized command\");\n+        output.shouldContain(\"An error occurred during parsing\");\n+        output.shouldContain(\"Unrecognized option 'aaa'\");\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/CompilerConfigFileWarning.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}