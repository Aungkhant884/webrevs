{"files":[{"patch":"@@ -1680,1 +1680,1 @@\n-  guarantee((max_regions() - 1) <= max_region_idx, \"too many regions\");\n+  guarantee((max_reserved_regions() - 1) <= max_region_idx, \"too many regions\");\n@@ -1687,1 +1687,1 @@\n-  _rem_set->initialize(max_regions());\n+  _rem_set->initialize(max_reserved_regions());\n@@ -1694,1 +1694,1 @@\n-  FreeRegionList::set_unrealistically_long_length(max_expandable_regions() + 1);\n+  FreeRegionList::set_unrealistically_long_length(max_regions() + 1);\n@@ -1716,1 +1716,1 @@\n-  \/\/ (Must do this late, so that \"max_regions\" is defined.)\n+  \/\/ (Must do this late, so that \"max_[reserved_]regions\" is defined.)\n@@ -1768,1 +1768,1 @@\n-  _collection_set.initialize(max_regions());\n+  _collection_set.initialize(max_reserved_regions());\n@@ -2394,1 +2394,1 @@\n-  return _hrm->max_expandable_length() * HeapRegion::GrainBytes;\n+  return max_regions() * HeapRegion::GrainBytes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_regions() )\n+typedef int RegionIdx_t;   \/\/ needs to hold [ 0..max_reserved_regions() )\n@@ -1064,2 +1064,3 @@\n-  \/\/ The max number of regions in the heap.\n-  uint max_regions() const { return _hrm->max_length(); }\n+  \/\/ The max number of regions reserved for the heap. Except for static array\n+  \/\/ sizing purposes you probably want to use max_regions().\n+  uint max_reserved_regions() const { return _hrm->reserved_length(); }\n@@ -1067,2 +1068,2 @@\n-  \/\/ Max number of regions that can be comitted.\n-  uint max_expandable_regions() const { return _hrm->max_expandable_length(); }\n+  \/\/ Max number of regions that can be committed.\n+  uint max_regions() const { return _hrm->max_length(); }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -408,2 +408,2 @@\n-  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_regions(), mtGC)),\n-  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_regions(), mtGC))\n+  _region_mark_stats(NEW_C_HEAP_ARRAY(G1RegionMarkStats, _g1h->max_reserved_regions(), mtGC)),\n+  _top_at_rebuild_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC))\n@@ -465,2 +465,2 @@\n-  uint max_regions = _g1h->max_regions();\n-  for (uint i = 0; i < max_regions; i++) {\n+  uint max_reserved_regions = _g1h->max_reserved_regions();\n+  for (uint i = 0; i < max_reserved_regions; i++) {\n@@ -521,2 +521,2 @@\n-    uint max_regions = _g1h->max_regions();\n-    for (uint i = 0; i < max_regions; i++) {\n+    uint max_reserved_regions = _g1h->max_reserved_regions();\n+    for (uint i = 0; i < max_reserved_regions; i++) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  assert(region < _g1h->max_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n@@ -191,1 +191,1 @@\n-  assert(region < _g1h->max_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-uint        G1FromCardCache::_max_regions = 0;\n+uint        G1FromCardCache::_max_reserved_regions = 0;\n@@ -38,2 +38,2 @@\n-void G1FromCardCache::initialize(uint num_par_rem_sets, uint max_num_regions) {\n-  guarantee(max_num_regions > 0, \"Heap size must be valid\");\n+void G1FromCardCache::initialize(uint num_par_rem_sets, uint max_reserved_regions) {\n+  guarantee(max_reserved_regions > 0, \"Heap size must be valid\");\n@@ -42,1 +42,1 @@\n-  _max_regions = max_num_regions;\n+  _max_reserved_regions = max_reserved_regions;\n@@ -46,1 +46,1 @@\n-  _cache = Padded2DArray<uintptr_t, mtGC>::create_unfreeable(_max_regions,\n+  _cache = Padded2DArray<uintptr_t, mtGC>::create_unfreeable(_max_reserved_regions,\n@@ -51,1 +51,1 @@\n-    invalidate(0, _max_regions);\n+    invalidate(0, _max_reserved_regions);\n@@ -60,1 +60,1 @@\n-  assert(end_idx <= _max_regions, \"Must be within max.\");\n+  assert(end_idx <= _max_reserved_regions, \"Must be within max.\");\n@@ -72,1 +72,1 @@\n-    for (uint j = 0; j < _max_regions; j++) {\n+    for (uint j = 0; j < _max_reserved_regions; j++) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-  static uint _max_regions;\n+  static uint _max_reserved_regions;\n@@ -48,1 +48,1 @@\n-    assert(region_idx < _max_regions, \"Region_idx %u is larger than maximum %u\", region_idx, _max_regions);\n+    assert(region_idx < _max_reserved_regions, \"Region_idx %u is larger than maximum %u\", region_idx, _max_reserved_regions);\n@@ -82,1 +82,1 @@\n-  static void initialize(uint num_par_rem_sets, uint max_num_regions);\n+  static void initialize(uint num_par_rem_sets, uint max_reserved_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FromCardCache.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-  _young_gen_sizer->adjust_max_new_size(_g1h->max_expandable_regions());\n+  _young_gen_sizer->adjust_max_new_size(_g1h->max_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,1 @@\n-  size_t _max_regions;\n+  size_t _max_reserved_regions;\n@@ -144,1 +144,1 @@\n-    size_t _max_regions;\n+    size_t _max_reserved_regions;\n@@ -149,2 +149,2 @@\n-    G1DirtyRegions(size_t max_regions) :\n-      _buffer(NEW_C_HEAP_ARRAY(uint, max_regions, mtGC)),\n+    G1DirtyRegions(size_t max_reserved_regions) :\n+      _buffer(NEW_C_HEAP_ARRAY(uint, max_reserved_regions, mtGC)),\n@@ -152,2 +152,2 @@\n-      _max_regions(max_regions),\n-      _contains(NEW_C_HEAP_ARRAY(bool, max_regions, mtGC)) {\n+      _max_reserved_regions(max_reserved_regions),\n+      _contains(NEW_C_HEAP_ARRAY(bool, max_reserved_regions, mtGC)) {\n@@ -167,1 +167,1 @@\n-      ::memset(_contains, false, _max_regions * sizeof(bool));\n+      ::memset(_contains, false, _max_reserved_regions * sizeof(bool));\n@@ -276,1 +276,1 @@\n-    _max_regions(0),\n+    _max_reserved_regions(0),\n@@ -296,1 +296,1 @@\n-  void initialize(size_t max_regions) {\n+  void initialize(size_t max_reserved_regions) {\n@@ -298,4 +298,4 @@\n-    _max_regions = max_regions;\n-    _collection_set_iter_state = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_regions, mtGC);\n-    _card_table_scan_state = NEW_C_HEAP_ARRAY(uint, max_regions, mtGC);\n-    _num_total_scan_chunks = max_regions * _scan_chunks_per_region;\n+    _max_reserved_regions = max_reserved_regions;\n+    _collection_set_iter_state = NEW_C_HEAP_ARRAY(G1RemsetIterState, max_reserved_regions, mtGC);\n+    _card_table_scan_state = NEW_C_HEAP_ARRAY(uint, max_reserved_regions, mtGC);\n+    _num_total_scan_chunks = max_reserved_regions * _scan_chunks_per_region;\n@@ -305,1 +305,1 @@\n-    _scan_top = NEW_C_HEAP_ARRAY(HeapWord*, max_regions, mtGC);\n+    _scan_top = NEW_C_HEAP_ARRAY(HeapWord*, max_reserved_regions, mtGC);\n@@ -313,1 +313,1 @@\n-    for (size_t i = 0; i < _max_regions; i++) {\n+    for (size_t i = 0; i < _max_reserved_regions; i++) {\n@@ -318,2 +318,2 @@\n-    _all_dirty_regions = new G1DirtyRegions(_max_regions);\n-    _next_dirty_regions = new G1DirtyRegions(_max_regions);\n+    _all_dirty_regions = new G1DirtyRegions(_max_reserved_regions);\n+    _next_dirty_regions = new G1DirtyRegions(_max_reserved_regions);\n@@ -326,1 +326,1 @@\n-    for (size_t i = 0; i < _max_regions; i++) {\n+    for (size_t i = 0; i < _max_reserved_regions; i++) {\n@@ -419,1 +419,1 @@\n-    assert(region < _max_regions, \"Tried to access invalid region %u\", region);\n+    assert(region < _max_reserved_regions, \"Tried to access invalid region %u\", region);\n@@ -427,1 +427,1 @@\n-    assert(region < _max_regions, \"Tried to access invalid region %u\", region);\n+    assert(region < _max_reserved_regions, \"Tried to access invalid region %u\", region);\n@@ -432,1 +432,1 @@\n-    assert(region < _max_regions, \"Tried to access invalid region %u\", region);\n+    assert(region < _max_reserved_regions, \"Tried to access invalid region %u\", region);\n@@ -488,3 +488,3 @@\n-void G1RemSet::initialize(uint max_regions) {\n-  G1FromCardCache::initialize(num_par_rem_sets(), max_regions);\n-  _scan_state->initialize(max_regions);\n+void G1RemSet::initialize(uint max_reserved_regions) {\n+  G1FromCardCache::initialize(num_par_rem_sets(), max_reserved_regions);\n+  _scan_state->initialize(max_reserved_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  void initialize(uint max_regions);\n+  void initialize(uint max_reserved_regions);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,5 +88,5 @@\n-                               G1RegionToSpaceMapper* prev_bitmap,\n-                               G1RegionToSpaceMapper* next_bitmap,\n-                               G1RegionToSpaceMapper* bot,\n-                               G1RegionToSpaceMapper* cardtable,\n-                               G1RegionToSpaceMapper* card_counts) {\n+                                   G1RegionToSpaceMapper* prev_bitmap,\n+                                   G1RegionToSpaceMapper* next_bitmap,\n+                                   G1RegionToSpaceMapper* bot,\n+                                   G1RegionToSpaceMapper* cardtable,\n+                                   G1RegionToSpaceMapper* card_counts) {\n@@ -187,1 +187,2 @@\n-  guarantee(_num_committed + num_regions <= max_length(), \"Cannot commit more than the maximum amount of regions\");\n+  guarantee(num_regions <= available(),\n+            \"Cannot commit more than the maximum amount of regions\");\n@@ -324,10 +325,13 @@\n-  for (uint i = 0; i < max_length(); i++) {\n-    if (is_available(i)) {\n-      \/\/ Already in use continue\n-      continue;\n-    }\n-    \/\/ Always save the candidate so we can expand later on.\n-    expand_candidate = i;\n-    if (is_on_preferred_index(expand_candidate, preferred_index)) {\n-      \/\/ We have found a candidate on the preffered node, break.\n-      break;\n+\n+  if (available() >= 1) {\n+    for (uint i = 0; i < reserved_length(); i++) {\n+      if (is_available(i)) {\n+        \/\/ Already in use continue\n+        continue;\n+      }\n+      \/\/ Always save the candidate so we can expand later on.\n+      expand_candidate = i;\n+      if (is_on_preferred_index(expand_candidate, preferred_index)) {\n+        \/\/ We have found a candidate on the preferred node, break.\n+        break;\n+      }\n@@ -400,1 +404,1 @@\n-  } while (candidate == G1_NO_HRM_INDEX && range_end < max_length());\n+  } while (candidate == G1_NO_HRM_INDEX && range_end < reserved_length());\n@@ -406,0 +410,4 @@\n+  \/\/ Check if we can actually satisfy the allocation.\n+  if (num_regions > available()) {\n+    return G1_NO_HRM_INDEX;\n+  }\n@@ -407,1 +415,1 @@\n-  return find_contiguous_in_range(0, max_length(), num_regions);\n+  return find_contiguous_in_range(0, reserved_length(), num_regions);\n@@ -423,1 +431,1 @@\n-  uint len = max_length();\n+  uint len = reserved_length();\n@@ -439,1 +447,1 @@\n-  guarantee(index <= max_length(), \"checking\");\n+  guarantee(index <= reserved_length(), \"checking\");\n@@ -445,1 +453,1 @@\n-    return HeapRegionRange(max_length(), max_length());\n+    return HeapRegionRange(reserved_length(), reserved_length());\n@@ -455,0 +463,2 @@\n+  \/\/ Shrink returned range to number of regions left to commit if necessary.\n+  end = MIN2(start + available(), end);\n@@ -462,1 +472,1 @@\n-  uint curr = max_length() - 1;\n+  uint curr = reserved_length() - 1;\n@@ -614,1 +624,1 @@\n-  guarantee(_allocated_heapregions_length <= max_length(),\n+  guarantee(_allocated_heapregions_length <= reserved_length(),\n@@ -616,1 +626,4 @@\n-            _allocated_heapregions_length, max_length());\n+            _allocated_heapregions_length, reserved_length());\n+  guarantee(_num_committed <= max_length(),\n+            \"invariant: _num_committed: %u max_regions: %u\",\n+            _num_committed, max_length());\n@@ -643,1 +656,1 @@\n-  for (uint i = _allocated_heapregions_length; i < max_length(); i++) {\n+  for (uint i = _allocated_heapregions_length; i < reserved_length(); i++) {\n@@ -696,1 +709,1 @@\n-      _worker_chunk_size((_hrm->max_length() + num_workers - 1) \/ num_workers),\n+      _worker_chunk_size((_hrm->reserved_length() + num_workers - 1) \/ num_workers),\n@@ -721,1 +734,1 @@\n-    uint end = MIN2(start + _worker_chunk_size, _hrm->max_length());\n+    uint end = MIN2(start + _worker_chunk_size, _hrm->reserved_length());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.cpp","additions":40,"deletions":27,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-\/\/ We keep track of three lengths:\n+\/\/ We keep track of four lengths:\n@@ -82,1 +82,2 @@\n-\/\/ * max_length() returns the maximum number of regions the heap can have.\n+\/\/ * max_length() returns the maximum number of regions the heap may commit.\n+\/\/ * max_reserved_length() returns the maximum number of regions the heap has reserved.\n@@ -97,1 +98,1 @@\n-   \/\/ The number of regions committed in the heap.\n+  \/\/ The number of regions committed in the heap.\n@@ -127,1 +128,1 @@\n-  \/\/ the returned range is equal to max_regions().\n+  \/\/ the returned range is equal to max_reserved_length().\n@@ -243,1 +244,1 @@\n-  \/\/ Return the number of available (uncommitted) regions.\n+  \/\/ Return the number of regions available (uncommitted) regions.\n@@ -249,2 +250,2 @@\n-  \/\/ Return the maximum number of regions in the heap.\n-  uint max_length() const { return (uint)_regions.length(); }\n+  \/\/ The number of regions reserved for the heap.\n+  uint reserved_length() const { return (uint)_regions.length(); }\n@@ -253,1 +254,1 @@\n-  virtual uint max_expandable_length() const { return (uint)_regions.length(); }\n+  virtual uint max_length() const { return reserved_length(); }\n@@ -270,1 +271,1 @@\n-  \/\/ Try to expand on the given node index.\n+  \/\/ Try to expand on the given node index, returning the index of the new region.\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-  if (index < max_length() && is_available(index) && at(index)->is_continues_humongous()) {\n+  if (index < reserved_length() && is_available(index) && at(index)->is_continues_humongous()) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionManager.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -270,1 +270,1 @@\n-    _coarse_map.reinitialize(G1CollectedHeap::heap()->max_regions());\n+    _coarse_map.reinitialize(G1CollectedHeap::heap()->max_reserved_regions());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  uint num_regions_possible = total_regions_committed() >= max_expandable_length() ? 0 : max_expandable_length() - total_regions_committed();\n+  uint num_regions_possible = total_regions_committed() >= max_length() ? 0 : max_length() - total_regions_committed();\n@@ -74,1 +74,1 @@\n-  uint target_num_regions = MIN2(num_regions, max_expandable_length() - total_regions_committed());\n+  uint target_num_regions = MIN2(num_regions, max_length() - total_regions_committed());\n@@ -78,1 +78,1 @@\n-  assert(total_regions_committed() <= max_expandable_length(), \"must be\");\n+  assert(total_regions_committed() <= max_length(), \"must be\");\n@@ -143,1 +143,1 @@\n-uint HeterogeneousHeapRegionManager::max_expandable_length() const {\n+uint HeterogeneousHeapRegionManager::max_length() const {\n@@ -149,1 +149,1 @@\n-  guarantee(start_idx <= (max_length() + 1), \"checking\");\n+  guarantee(start_idx <= (reserved_length() + 1), \"checking\");\n@@ -235,2 +235,2 @@\n-  guarantee(start_idx < max_length(), \"checking\");\n-  guarantee(end_idx < max_length(), \"checking\");\n+  guarantee(start_idx < reserved_length(), \"checking\");\n+  guarantee(end_idx < reserved_length(), \"checking\");\n@@ -388,1 +388,1 @@\n-    if (!empty_only && length_unavailable > (max_expandable_length() - total_regions_committed())) {\n+    if (!empty_only && length_unavailable > (max_length() - total_regions_committed())) {\n","filename":"src\/hotspot\/share\/gc\/g1\/heterogeneousHeapRegionManager.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  uint max_expandable_length() const;\n+  uint max_length() const;\n","filename":"src\/hotspot\/share\/gc\/g1\/heterogeneousHeapRegionManager.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}