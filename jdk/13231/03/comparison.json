{"files":[{"patch":"@@ -277,10 +277,7 @@\n-        return toMatchResult(text.toString());\n-    }\n-\n-    private MatchResult toMatchResult(String text) {\n-        return new ImmutableMatchResult(this.first,\n-                                        this.last,\n-                                        groupCount(),\n-                                        this.groups.clone(),\n-                                        text,\n-                                        namedGroups());\n+        String capturedText = hasMatch()\n+                ? text.subSequence(first, last).toString()\n+                : null;\n+        return new ImmutableMatchResult(first, last, groupCount(),\n+                groups.clone(), capturedText,\n+                namedGroups()\n+        );\n@@ -292,1 +289,0 @@\n-        private final int[] groups;\n@@ -294,0 +290,1 @@\n+        private final int[] groups;\n@@ -299,2 +296,1 @@\n-                             Map<String, Integer> namedGroups)\n-        {\n+                             Map<String, Integer> namedGroups) {\n@@ -352,1 +348,1 @@\n-            return text.subSequence(groups[group * 2], groups[group * 2 + 1]).toString();\n+            return text.substring(groups[group * 2] - first, groups[group * 2 + 1] - first);\n@@ -373,1 +369,0 @@\n-\n@@ -1321,3 +1316,0 @@\n-            \/\/ The input sequence as a string, set once only after first find\n-            \/\/ Avoids repeated conversion from CharSequence for each match\n-            String textAsString;\n@@ -1334,1 +1326,1 @@\n-                return toMatchResult(textAsString);\n+                return toMatchResult();\n@@ -1349,3 +1341,0 @@\n-                \/\/ Capture the input sequence as a string on first find\n-                if (found && state < 0)\n-                    textAsString = text.toString();\n@@ -1374,3 +1363,0 @@\n-                \/\/ Capture the input sequence as a string on first find\n-                textAsString = text.toString();\n-\n@@ -1379,1 +1365,1 @@\n-                    action.accept(toMatchResult(textAsString));\n+                    action.accept(toMatchResult());\n","filename":"src\/java.base\/share\/classes\/java\/util\/regex\/Matcher.java","additions":12,"deletions":26,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.RandomFactory;\n+import org.junit.jupiter.api.Test;\n+\n+import java.nio.CharBuffer;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.regex.MatchResult;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+\/*\n+ * @test\n+ * @bug 8132995\n+ * @key randomness\n+ *\n+ * @summary Tests to exercise the optimization described in the bug report.\n+ * @library \/test\/lib\n+ * @run junit ImmutableMatchResultTest\n+ *\/\n+\n+public class ImmutableMatchResultTest {\n+\n+    private static final int prefixLen;\n+    private static final int infixLen;\n+    private static final int suffixLen;\n+    private static final String group1 = \"abc\";\n+    private static final String group2 = \"wxyz\";\n+    private static final String group0;\n+    private static final String in;\n+    private static final String groupResults = \"(([a-z]+)([0-9]*))\";\n+    private static final String inResults;\n+    private static final String letters1 = \"abcd\";\n+    private static final String digits1 = \"12\";\n+    private static final String letters2 = \"pqr\";\n+    private static final String digits2 = \"\";\n+\n+    static {\n+        Random rnd = RandomFactory.getRandom();\n+        prefixLen = rnd.nextInt(10);\n+        infixLen = rnd.nextInt(10);\n+        suffixLen = rnd.nextInt(10);\n+        group0 = group1 + \"-\".repeat(infixLen) + group2;\n+        in = \"-\".repeat(prefixLen) + group0 + \"-\".repeat(suffixLen);\n+        inResults = \" \".repeat(prefixLen) + letters1 + digits1 + \" \".repeat(infixLen) + letters2 + digits2 + \" \".repeat(suffixLen);\n+    }\n+\n+    private static void test(CharSequence cs) {\n+        Matcher m = Pattern.compile(\"(\" + group1 + \")-*(\" + group2 + \")\").matcher(cs);\n+        assertTrue(m.find());\n+\n+        assertEquals(prefixLen, m.start());\n+        assertEquals(prefixLen + group0.length(), m.end());\n+        assertEquals(group0, m.toMatchResult().group());\n+\n+        assertEquals(prefixLen, m.start(1));\n+        assertEquals(prefixLen + group1.length(), m.end(1));\n+        assertEquals(group1, m.toMatchResult().group(1));\n+\n+        assertEquals(prefixLen + group1.length() + infixLen, m.start(2));\n+        assertEquals(prefixLen + group1.length() + infixLen + group2.length(), m.end(2));\n+        assertEquals(group2, m.toMatchResult().group(2));\n+    }\n+\n+    @Test\n+    void testString() {\n+        test(in);\n+    }\n+\n+    @Test\n+    void testStringBuilder() {\n+        test(new StringBuilder(in));\n+    }\n+\n+    @Test\n+    void testStringBuffer() {\n+        test(new StringBuffer(in));\n+    }\n+\n+    @Test\n+    void testCharBuffer() {\n+        test(CharBuffer.wrap(in));\n+    }\n+\n+    private static void testResultsStream(CharSequence cs) {\n+        Matcher m = Pattern.compile(groupResults).matcher(cs);\n+        List<MatchResult> results = m.results().toList();\n+        assertEquals(2, results.size());\n+\n+        int startLetters1 = prefixLen;\n+        int endLetters1 = startLetters1 + letters1.length();\n+        int startDigits1 = endLetters1;\n+        int endDigits1 = startDigits1 + digits1.length();\n+\n+        assertEquals(startLetters1, results.get(0).start());\n+        assertEquals(startLetters1, results.get(0).start(0));\n+        assertEquals(startLetters1, results.get(0).start(1));\n+        assertEquals(startLetters1, results.get(0).start(2));\n+        assertEquals(startDigits1, results.get(0).start(3));\n+\n+        assertEquals(endDigits1, results.get(0).end());\n+        assertEquals(endDigits1, results.get(0).end(0));\n+        assertEquals(endDigits1, results.get(0).end(1));\n+        assertEquals(endLetters1, results.get(0).end(2));\n+        assertEquals(endDigits1, results.get(0).end(3));\n+\n+        assertEquals(letters1 + digits1, results.get(0).group());\n+        assertEquals(letters1 + digits1, results.get(0).group(0));\n+        assertEquals(letters1 + digits1, results.get(0).group(1));\n+        assertEquals(letters1, results.get(0).group(2));\n+        assertEquals(digits1, results.get(0).group(3));\n+\n+        int startLetters2 = endDigits1 + infixLen;\n+        int endLetters2 = startLetters2 + letters2.length();\n+        int startDigits2 = endLetters2;\n+        int endDigits2 = startDigits2 + digits2.length();\n+\n+        assertEquals(startLetters2, results.get(1).start());\n+        assertEquals(startLetters2, results.get(1).start(0));\n+        assertEquals(startLetters2, results.get(1).start(1));\n+        assertEquals(startLetters2, results.get(1).start(2));\n+        assertEquals(startDigits2, results.get(1).start(3));\n+\n+        assertEquals(endDigits2, results.get(1).end());\n+        assertEquals(endDigits2, results.get(1).end(0));\n+        assertEquals(endDigits2, results.get(1).end(1));\n+        assertEquals(endLetters2, results.get(1).end(2));\n+        assertEquals(endDigits2, results.get(1).end(3));\n+\n+        assertEquals(letters2 + digits2, results.get(1).group());\n+        assertEquals(letters2 + digits2, results.get(1).group(0));\n+        assertEquals(letters2 + digits2, results.get(1).group(1));\n+        assertEquals(letters2, results.get(1).group(2));\n+        assertEquals(digits2, results.get(1).group(3));\n+    }\n+\n+    @Test\n+    void testResultsStreamString() {\n+        testResultsStream(inResults);\n+    }\n+\n+    @Test\n+    void testResultsStreamStringBuilder() {\n+        testResultsStream(new StringBuilder(inResults));\n+    }\n+\n+    @Test\n+    void testResultsStreamStringBuffer() {\n+        testResultsStream(new StringBuffer(inResults));\n+    }\n+\n+    @Test\n+    void testResultsStreamCharBuffer() {\n+        testResultsStream(CharBuffer.wrap(inResults));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/regex\/ImmutableMatchResultTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"}]}