{"files":[{"patch":"@@ -872,0 +872,5 @@\n+                case NEW_ARRAY:\n+                    \/\/ component type argument needs to be constant\n+                    if (!(name.arguments[0] instanceof Class<?>)) break;\n+                    emitNewArray(name);\n+                    continue;\n@@ -932,0 +937,16 @@\n+    void emitNewArray(Name name) {\n+        \/\/ call to Array.newInstance. Get the component type, which should be constant for this intrinsic\n+        Class<?> rtype = name.function.methodType().returnType();\n+        Class<?> arrayElementType = (Class<?>) name.arguments[0];\n+        \/\/ push array length\n+        emitPushArgument(name, 1);\n+        if (!arrayElementType.isPrimitive()) {\n+            mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));\n+        } else {\n+            byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));\n+            mv.visitIntInsn(Opcodes.NEWARRAY, tc);\n+        }\n+        \/\/ the array is left on the stack\n+        assertStaticType(rtype, name);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1230,0 +1230,1 @@\n+        NEW_ARRAY,\n@@ -1277,2 +1278,2 @@\n-                MethodHandle collector = MethodHandleImpl.makeCollector(arrayType, arrayLength);\n-                return collector.asType(resultType);\n+                MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);\n+                return newArray.asType(resultType);\n@@ -1342,5 +1343,0 @@\n-    \/\/ Array identity function (used as getConstantHandle(MH_arrayIdentity)).\n-    static <T> T[] identity(T[] x) {\n-        return x;\n-    }\n-\n@@ -1887,2 +1883,2 @@\n-        MethodHandle newArray = MethodHandles.arrayConstructor(arrayType);\n-        MethodHandle storeFunc = ArrayAccessor.getAccessor(arrayType, ArrayAccess.SET);\n+        MethodHandle storeFunc = makeArrayElementAccessor(arrayType, ArrayAccess.SET);\n+        LambdaForm form = makeCollectorForm(type.basicType(), arrayType.componentType(), storeFunc);\n@@ -1890,11 +1886,1 @@\n-        LambdaForm form = makeCollectorForm(type.basicType(), storeFunc);\n-\n-        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n-        BoundMethodHandle mh;\n-        try {\n-            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) newArray);\n-        } catch (Throwable ex) {\n-            throw uncaughtException(ex);\n-        }\n-        assert(mh.type() == type);\n-        return mh;\n+        return SimpleMethodHandle.make(type, form);\n@@ -1903,1 +1889,1 @@\n-    private static LambdaForm makeCollectorForm(MethodType basicType, MethodHandle storeFunc) {\n+    private static LambdaForm makeCollectorForm(MethodType basicType, Class<?> componentType, MethodHandle storeFunc) {\n@@ -1907,2 +1893,7 @@\n-        final int THIS_MH      = 0;  \/\/ the BMH_L\n-        final int ARG_BASE     = 1;  \/\/ start of incoming arguments\n+        \/\/ It might be possible to share this lambda form for all reference types - since they\n+        \/\/ use the same underlying store function - by injecting an array creation handle as a\n+        \/\/ field of the receiver handle.\n+        \/\/ This is left as a followup enhancement, as it needs to be investigated if this causes\n+        \/\/ profile pollution.\n+\n+        final int ARG_BASE     = 1;  \/\/ start of incoming arguments (skipped receiver handle)\n@@ -1912,1 +1903,0 @@\n-        final int GET_NEW_ARRAY       = nameCursor++;\n@@ -1920,3 +1910,2 @@\n-        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n-        names[THIS_MH]          = names[THIS_MH].withConstraint(data);\n-        names[GET_NEW_ARRAY]    = new Name(data.getterFunction(0), names[THIS_MH]);\n+        NamedFunction newArray = new NamedFunction(getConstantHandle(MH_Array_newInstance), Intrinsic.NEW_ARRAY);\n+        names[CALL_NEW_ARRAY] = new Name(newArray, componentType, parameterCount);\n@@ -1924,2 +1913,0 @@\n-        MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(Object.class, int.class));\n-        names[CALL_NEW_ARRAY] = new Name(new NamedFunction(invokeBasic), names[GET_NEW_ARRAY], parameterCount);\n@@ -1932,1 +1919,1 @@\n-            names[storeNameCursor] = new Name(new NamedFunction(storeFunc),\n+            names[storeNameCursor] = new Name(new NamedFunction(storeFunc, Intrinsic.ARRAY_STORE),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":17,"deletions":30,"binary":false,"changes":47,"status":"modified"}]}