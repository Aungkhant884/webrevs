{"files":[{"patch":"@@ -872,7 +872,0 @@\n-                case NEW_ARRAY:\n-                    Class<?> rtype = name.function.methodType().returnType();\n-                    if (isStaticallyNameable(rtype)) {\n-                        emitNewArray(name);\n-                        continue;\n-                    }\n-                    break;\n@@ -1115,37 +1108,0 @@\n-    void emitNewArray(Name name) throws InternalError {\n-        Class<?> rtype = name.function.methodType().returnType();\n-        if (name.arguments.length == 0) {\n-            \/\/ The array will be a constant.\n-            Object emptyArray;\n-            try {\n-                emptyArray = name.function.resolvedHandle().invoke();\n-            } catch (Throwable ex) {\n-                throw uncaughtException(ex);\n-            }\n-            assert(java.lang.reflect.Array.getLength(emptyArray) == 0);\n-            assert(emptyArray.getClass() == rtype);  \/\/ exact typing\n-            mv.visitFieldInsn(Opcodes.GETSTATIC, className, classData(emptyArray), \"Ljava\/lang\/Object;\");\n-            emitReferenceCast(rtype, emptyArray);\n-            return;\n-        }\n-        Class<?> arrayElementType = rtype.getComponentType();\n-        assert(arrayElementType != null);\n-        emitIconstInsn(name.arguments.length);\n-        int xas = Opcodes.AASTORE;\n-        if (!arrayElementType.isPrimitive()) {\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));\n-        } else {\n-            byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));\n-            xas = arrayInsnOpcode(tc, xas);\n-            mv.visitIntInsn(Opcodes.NEWARRAY, tc);\n-        }\n-        \/\/ store arguments\n-        for (int i = 0; i < name.arguments.length; i++) {\n-            mv.visitInsn(Opcodes.DUP);\n-            emitIconstInsn(i);\n-            emitPushArgument(name, i);\n-            mv.visitInsn(xas);\n-        }\n-        \/\/ the array is left on the stack\n-        assertStaticType(rtype, name);\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -318,0 +318,1 @@\n+        COLLECTOR(\"collector\"),\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -651,51 +651,0 @@\n-    LambdaForm collectArgumentArrayForm(int pos, MethodHandle arrayCollector) {\n-        MethodType collectorType = arrayCollector.type();\n-        int collectorArity = collectorType.parameterCount();\n-        assert(arrayCollector.intrinsicName() == Intrinsic.NEW_ARRAY);\n-        Class<?> arrayType = collectorType.returnType();\n-        Class<?> elementType = arrayType.getComponentType();\n-        BasicType argType = basicType(elementType);\n-        int argTypeKey = argType.ordinal();\n-        if (argType.basicTypeClass() != elementType) {\n-            \/\/ return null if it requires more metadata (like String[].class)\n-            if (!elementType.isPrimitive())\n-                return null;\n-            argTypeKey = TYPE_LIMIT + Wrapper.forPrimitiveType(elementType).ordinal();\n-        }\n-        assert(collectorType.parameterList().equals(Collections.nCopies(collectorArity, elementType)));\n-        byte kind = COLLECT_ARGS_TO_ARRAY;\n-        TransformKey key = TransformKey.of(kind, pos, collectorArity, argTypeKey);\n-        LambdaForm form = getInCache(key);\n-        if (form != null) {\n-            assert(form.arity == lambdaForm.arity - 1 + collectorArity);\n-            return form;\n-        }\n-        LambdaFormBuffer buf = buffer();\n-        buf.startEdit();\n-\n-        assert(pos + 1 <= lambdaForm.arity);\n-        assert(pos > 0);  \/\/ cannot filter the MH arg itself\n-\n-        Name[] newParams = new Name[collectorArity];\n-        for (int i = 0; i < collectorArity; i++) {\n-            newParams[i] = new Name(pos + i, argType);\n-        }\n-        Name callCombiner = new Name(new NamedFunction(arrayCollector, Intrinsic.NEW_ARRAY),\n-                                        (Object[]) \/*...*\/ newParams);\n-\n-        \/\/ insert the new expression\n-        int exprPos = lambdaForm.arity();\n-        buf.insertExpression(exprPos, callCombiner);\n-\n-        \/\/ insert new arguments\n-        int argPos = pos + 1;  \/\/ skip result parameter\n-        for (Name newParam : newParams) {\n-            buf.insertParameter(argPos++, newParam);\n-        }\n-        assert(buf.lastIndexOf(callCombiner) == exprPos+newParams.length);\n-        buf.replaceParameterByCopy(pos, exprPos+newParams.length);\n-\n-        form = buf.endEdit();\n-        return putInCache(key, form);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaFormEditor.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1247,7 +1247,3 @@\n-        MethodHandle newArray = MethodHandleImpl.varargsArray(arrayType, arrayLength);\n-        LambdaForm lform = mh.editor().collectArgumentArrayForm(1 + collectArgPos, newArray);\n-        if (lform != null) {\n-            return mh.copyWith(resultType, lform);\n-        }\n-        lform = mh.editor().collectArgumentsForm(1 + collectArgPos, newArray.type().basicType());\n-        return mh.copyWithExtendL(resultType, lform, newArray);\n+        MethodHandle collector = MethodHandleImpl.varargsArray(arrayType, arrayLength);\n+        LambdaForm lform = mh.editor().collectArgumentsForm(1 + collectArgPos, collector.type().basicType());\n+        return mh.copyWithExtendL(resultType, lform, collector);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1230,1 +1230,0 @@\n-        NEW_ARRAY,\n@@ -1295,46 +1294,0 @@\n-    \/\/\/ Collection of multiple arguments.\n-\n-    private static MethodHandle findCollector(String name, int nargs, Class<?> rtype, Class<?>... ptypes) {\n-        MethodType type = MethodType.genericMethodType(nargs)\n-                .changeReturnType(rtype)\n-                .insertParameterTypes(0, ptypes);\n-        try {\n-            return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, name, type);\n-        } catch (ReflectiveOperationException ex) {\n-            return null;\n-        }\n-    }\n-\n-    private static final Object[] NO_ARGS_ARRAY = {};\n-    private static Object[] makeArray(Object... args) { return args; }\n-    private static Object[] array() { return NO_ARGS_ARRAY; }\n-    private static Object[] array(Object a0)\n-                { return makeArray(a0); }\n-    private static Object[] array(Object a0, Object a1)\n-                { return makeArray(a0, a1); }\n-    private static Object[] array(Object a0, Object a1, Object a2)\n-                { return makeArray(a0, a1, a2); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3)\n-                { return makeArray(a0, a1, a2, a3); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4)\n-                { return makeArray(a0, a1, a2, a3, a4); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5)\n-                { return makeArray(a0, a1, a2, a3, a4, a5); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8); }\n-    private static Object[] array(Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8, Object a9)\n-                { return makeArray(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }\n-\n-    private static final int ARRAYS_COUNT = 11;\n@@ -1343,66 +1296,0 @@\n-    \/\/ filling versions of the above:\n-    \/\/ using Integer len instead of int len and no varargs to avoid bootstrapping problems\n-    private static Object[] fillNewArray(Integer len, Object[] \/*not ...*\/ args) {\n-        Object[] a = new Object[len];\n-        fillWithArguments(a, 0, args);\n-        return a;\n-    }\n-    private static Object[] fillNewTypedArray(Object[] example, Integer len, Object[] \/*not ...*\/ args) {\n-        Object[] a = Arrays.copyOf(example, len);\n-        assert(a.getClass() != Object[].class);\n-        fillWithArguments(a, 0, args);\n-        return a;\n-    }\n-    private static void fillWithArguments(Object[] a, int pos, Object... args) {\n-        System.arraycopy(args, 0, a, pos, args.length);\n-    }\n-    \/\/ using Integer pos instead of int pos to avoid bootstrapping problems\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0)\n-                { fillWithArguments(a, pos, a0); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1)\n-                { fillWithArguments(a, pos, a0, a1); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2)\n-                { fillWithArguments(a, pos, a0, a1, a2); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8); return a; }\n-    private static Object[] fillArray(Integer pos, Object[] a, Object a0, Object a1, Object a2, Object a3,\n-                                  Object a4, Object a5, Object a6, Object a7,\n-                                  Object a8, Object a9)\n-                { fillWithArguments(a, pos, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); return a; }\n-\n-    private static final int FILL_ARRAYS_COUNT = 11; \/\/ current number of fillArray methods\n-    private static final @Stable MethodHandle[] FILL_ARRAYS = new MethodHandle[FILL_ARRAYS_COUNT];\n-\n-    private static MethodHandle getFillArray(int count) {\n-        assert (count > 0 && count < FILL_ARRAYS_COUNT);\n-        MethodHandle mh = FILL_ARRAYS[count];\n-        if (mh != null) {\n-            return mh;\n-        }\n-        mh = findCollector(\"fillArray\", count, Object[].class, Integer.class, Object[].class);\n-        FILL_ARRAYS[count] = mh;\n-        return mh;\n-    }\n-\n-    private static Object copyAsPrimitiveArray(Wrapper w, Object... boxes) {\n-        Object a = w.makeArray(boxes.length);\n-        w.copyArrayUnboxing(boxes, 0, a, 0, boxes.length);\n-        return a;\n-    }\n-\n@@ -1417,6 +1304,1 @@\n-        if (nargs < ARRAYS_COUNT) {\n-            mh = findCollector(\"array\", nargs, Object[].class);\n-        } else {\n-            mh = buildVarargsArray(getConstantHandle(MH_fillNewArray),\n-                    getConstantHandle(MH_arrayIdentity), nargs);\n-        }\n+        mh = makeCollector(Object[].class, nargs);\n@@ -1424,1 +1306,0 @@\n-        mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);\n@@ -1428,80 +1309,0 @@\n-    private static boolean assertCorrectArity(MethodHandle mh, int arity) {\n-        assert(mh.type().parameterCount() == arity) : \"arity != \"+arity+\": \"+mh;\n-        return true;\n-    }\n-\n-    \/\/ Array identity function (used as getConstantHandle(MH_arrayIdentity)).\n-    static <T> T[] identity(T[] x) {\n-        return x;\n-    }\n-\n-    private static MethodHandle buildVarargsArray(MethodHandle newArray, MethodHandle finisher, int nargs) {\n-        \/\/ Build up the result mh as a sequence of fills like this:\n-        \/\/   finisher(fill(fill(newArrayWA(23,x1..x10),10,x11..x20),20,x21..x23))\n-        \/\/ The various fill(_,10*I,___*[J]) are reusable.\n-        int leftLen = Math.min(nargs, LEFT_ARGS);  \/\/ absorb some arguments immediately\n-        int rightLen = nargs - leftLen;\n-        MethodHandle leftCollector = newArray.bindTo(nargs);\n-        leftCollector = leftCollector.asCollector(Object[].class, leftLen);\n-        MethodHandle mh = finisher;\n-        if (rightLen > 0) {\n-            MethodHandle rightFiller = fillToRight(LEFT_ARGS + rightLen);\n-            if (mh.equals(getConstantHandle(MH_arrayIdentity)))\n-                mh = rightFiller;\n-            else\n-                mh = MethodHandles.collectArguments(mh, 0, rightFiller);\n-        }\n-        if (mh.equals(getConstantHandle(MH_arrayIdentity)))\n-            mh = leftCollector;\n-        else\n-            mh = MethodHandles.collectArguments(mh, 0, leftCollector);\n-        return mh;\n-    }\n-\n-    private static final int LEFT_ARGS = FILL_ARRAYS_COUNT - 1;\n-    private static final @Stable MethodHandle[] FILL_ARRAY_TO_RIGHT = new MethodHandle[MAX_ARITY + 1];\n-    \/** fill_array_to_right(N).invoke(a, argL..arg[N-1])\n-     *  fills a[L]..a[N-1] with corresponding arguments,\n-     *  and then returns a.  The value L is a global constant (LEFT_ARGS).\n-     *\/\n-    private static MethodHandle fillToRight(int nargs) {\n-        MethodHandle filler = FILL_ARRAY_TO_RIGHT[nargs];\n-        if (filler != null)  return filler;\n-        filler = buildFiller(nargs);\n-        assert(assertCorrectArity(filler, nargs - LEFT_ARGS + 1));\n-        return FILL_ARRAY_TO_RIGHT[nargs] = filler;\n-    }\n-    private static MethodHandle buildFiller(int nargs) {\n-        if (nargs <= LEFT_ARGS)\n-            return getConstantHandle(MH_arrayIdentity);  \/\/ no args to fill; return the array unchanged\n-        \/\/ we need room for both mh and a in mh.invoke(a, arg*[nargs])\n-        final int CHUNK = LEFT_ARGS;\n-        int rightLen = nargs % CHUNK;\n-        int midLen = nargs - rightLen;\n-        if (rightLen == 0) {\n-            midLen = nargs - (rightLen = CHUNK);\n-            if (FILL_ARRAY_TO_RIGHT[midLen] == null) {\n-                \/\/ build some precursors from left to right\n-                for (int j = LEFT_ARGS % CHUNK; j < midLen; j += CHUNK)\n-                    if (j > LEFT_ARGS)  fillToRight(j);\n-            }\n-        }\n-        if (midLen < LEFT_ARGS) rightLen = nargs - (midLen = LEFT_ARGS);\n-        assert(rightLen > 0);\n-        MethodHandle midFill = fillToRight(midLen);  \/\/ recursive fill\n-        MethodHandle rightFill = getFillArray(rightLen).bindTo(midLen);  \/\/ [midLen..nargs-1]\n-        assert(midFill.type().parameterCount()   == 1 + midLen - LEFT_ARGS);\n-        assert(rightFill.type().parameterCount() == 1 + rightLen);\n-\n-        \/\/ Combine the two fills:\n-        \/\/   right(mid(a, x10..x19), x20..x23)\n-        \/\/ The final product will look like this:\n-        \/\/   right(mid(newArrayLeft(24, x0..x9), x10..x19), x20..x23)\n-        if (midLen == LEFT_ARGS)\n-            return rightFill;\n-        else\n-            return MethodHandles.collectArguments(rightFill, 0, midFill);\n-    }\n-\n-    static final int MAX_JVM_ARITY = 255;  \/\/ limit imposed by the JVM\n-\n@@ -1515,1 +1316,0 @@\n-        \/\/ FIXME: Need more special casing and caching here.\n@@ -1530,16 +1330,1 @@\n-        if (nargs == 0) {\n-            Object example = java.lang.reflect.Array.newInstance(arrayType.getComponentType(), 0);\n-            mh = MethodHandles.constant(arrayType, example);\n-        } else if (elemType.isPrimitive()) {\n-            MethodHandle builder = getConstantHandle(MH_fillNewArray);\n-            MethodHandle producer = buildArrayProducer(arrayType);\n-            mh = buildVarargsArray(builder, producer, nargs);\n-        } else {\n-            Class<? extends Object[]> objArrayType = arrayType.asSubclass(Object[].class);\n-            Object[] example = Arrays.copyOf(NO_ARGS_ARRAY, 0, objArrayType);\n-            MethodHandle builder = getConstantHandle(MH_fillNewTypedArray).bindTo(example);\n-            MethodHandle producer = getConstantHandle(MH_arrayIdentity); \/\/ must be weakly typed\n-            mh = buildVarargsArray(builder, producer, nargs);\n-        }\n-        mh = mh.asType(MethodType.methodType(arrayType, Collections.<Class<?>>nCopies(nargs, elemType)));\n-        mh = makeIntrinsic(mh, Intrinsic.NEW_ARRAY);\n+        mh = makeCollector(arrayType, nargs);\n@@ -1552,4 +1337,3 @@\n-    private static MethodHandle buildArrayProducer(Class<?> arrayType) {\n-        Class<?> elemType = arrayType.getComponentType();\n-        assert(elemType.isPrimitive());\n-        return getConstantHandle(MH_copyAsPrimitiveArray).bindTo(Wrapper.forPrimitiveType(elemType));\n+    private static boolean assertCorrectArity(MethodHandle mh, int arity) {\n+        assert(mh.type().parameterCount() == arity) : \"arity != \"+arity+\": \"+mh;\n+        return true;\n@@ -1558,0 +1342,2 @@\n+    static final int MAX_JVM_ARITY = 255;  \/\/ limit imposed by the JVM\n+\n@@ -2092,0 +1878,77 @@\n+    \/\/ see varargsArray method for chaching\/package-private version of this\n+    private static MethodHandle makeCollector(Class<?> arrayType, int parameterCount) {\n+        MethodType type = MethodType.methodType(arrayType, Collections.nCopies(parameterCount, arrayType.componentType()));\n+        MethodHandle newArray = MethodHandles.arrayConstructor(arrayType);\n+\n+        LambdaForm form = makeCollectorForm(type.basicType(), arrayType);\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n+        BoundMethodHandle mh;\n+        try {\n+            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) newArray);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+        assert(mh.type() == type);\n+        return mh;\n+    }\n+\n+    private static LambdaForm makeCollectorForm(MethodType basicType, Class<?> arrayType) {\n+        MethodType lambdaType = basicType.invokerType();\n+        int parameterCount = basicType.parameterCount();\n+\n+        \/\/ Only share the lambda form for empty arrays and reference types.\n+        \/\/ Sharing based on the basic type alone doesn't work because\n+        \/\/ we need a separate lambda form for byte\/short\/char\/int which\n+        \/\/ are all erased to int otherwise.\n+        \/\/ Other caching for primitive types happens at the MethodHandle level (see varargsArray).\n+        boolean isReferenceType = !arrayType.componentType().isPrimitive();\n+        boolean isSharedLambdaForm = parameterCount == 0 || isReferenceType;\n+        if (isSharedLambdaForm) {\n+            LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_COLLECTOR);\n+            if (lform != null) {\n+                return lform;\n+            }\n+        }\n+\n+        \/\/ use erased accessor for reference types\n+        MethodHandle storeFunc = isReferenceType\n+                ? ArrayAccessor.OBJECT_ARRAY_SETTER\n+                : makeArrayElementAccessor(arrayType, ArrayAccess.SET);\n+\n+        final int THIS_MH      = 0;  \/\/ the BMH_L\n+        final int ARG_BASE     = 1;  \/\/ start of incoming arguments\n+        final int ARG_LIMIT    = ARG_BASE + parameterCount;\n+\n+        int nameCursor = ARG_LIMIT;\n+        final int GET_NEW_ARRAY       = nameCursor++;\n+        final int CALL_NEW_ARRAY      = nameCursor++;\n+        final int STORE_ELEMENT_BASE  = nameCursor;\n+        final int STORE_ELEMENT_LIMIT = STORE_ELEMENT_BASE + parameterCount;\n+        nameCursor = STORE_ELEMENT_LIMIT;\n+\n+        Name[] names = arguments(nameCursor - ARG_LIMIT, lambdaType);\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n+        names[THIS_MH]          = names[THIS_MH].withConstraint(data);\n+        names[GET_NEW_ARRAY]    = new Name(data.getterFunction(0), names[THIS_MH]);\n+\n+        MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(Object.class, int.class));\n+        names[CALL_NEW_ARRAY] = new Name(new NamedFunction(invokeBasic), names[GET_NEW_ARRAY], parameterCount);\n+        for (int storeIndex = 0,\n+             storeNameCursor = STORE_ELEMENT_BASE,\n+             argCursor = ARG_BASE;\n+             storeNameCursor < STORE_ELEMENT_LIMIT;\n+             storeIndex++, storeNameCursor++, argCursor++){\n+\n+            names[storeNameCursor] = new Name(new NamedFunction(storeFunc, Intrinsic.ARRAY_STORE),\n+                    names[CALL_NEW_ARRAY], storeIndex, names[argCursor]);\n+        }\n+\n+        LambdaForm lform = new LambdaForm(lambdaType.parameterCount(), names, CALL_NEW_ARRAY, Kind.COLLECTOR);\n+        if (isSharedLambdaForm) {\n+            lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_COLLECTOR, lform);\n+        }\n+        return lform;\n+    }\n+\n@@ -2094,13 +1957,9 @@\n-            MH_cast                  =  0,\n-            MH_selectAlternative     =  1,\n-            MH_copyAsPrimitiveArray  =  2,\n-            MH_fillNewTypedArray     =  3,\n-            MH_fillNewArray          =  4,\n-            MH_arrayIdentity         =  5,\n-            MH_countedLoopPred       =  6,\n-            MH_countedLoopStep       =  7,\n-            MH_initIterator          =  8,\n-            MH_iteratePred           =  9,\n-            MH_iterateNext           = 10,\n-            MH_Array_newInstance     = 11,\n-            MH_LIMIT                 = 12;\n+            MH_cast                  = 0,\n+            MH_selectAlternative     = 1,\n+            MH_countedLoopPred       = 2,\n+            MH_countedLoopStep       = 3,\n+            MH_initIterator          = 4,\n+            MH_iteratePred           = 5,\n+            MH_iterateNext           = 6,\n+            MH_Array_newInstance     = 7,\n+            MH_LIMIT                 = 8;\n@@ -2135,12 +1994,0 @@\n-                case MH_copyAsPrimitiveArray:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"copyAsPrimitiveArray\",\n-                            MethodType.methodType(Object.class, Wrapper.class, Object[].class));\n-                case MH_arrayIdentity:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"identity\",\n-                            MethodType.methodType(Object[].class, Object[].class));\n-                case MH_fillNewArray:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"fillNewArray\",\n-                            MethodType.methodType(Object[].class, Integer.class, Object[].class));\n-                case MH_fillNewTypedArray:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"fillNewTypedArray\",\n-                            MethodType.methodType(Object[].class, Object[].class, Integer.class, Object[].class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":93,"deletions":246,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -5734,8 +5734,1 @@\n-        LambdaForm lform;\n-        if (collectorType.returnType().isArray() && filter.intrinsicName() == Intrinsic.NEW_ARRAY) {\n-            lform = result.editor().collectArgumentArrayForm(1 + pos, filter);\n-            if (lform != null) {\n-                return result.copyWith(newType, lform);\n-            }\n-        }\n-        lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());\n+        LambdaForm lform = result.editor().collectArgumentsForm(1 + pos, collectorType.basicType());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-            LF_LIMIT                   = 25;\n+            LF_COLLECTOR               = 25,  \/\/ collector handle\n+            LF_LIMIT                   = 26;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-           Assert.fail(\"Unexpected WrongMethodTypeException thrown\");\n+           throw new AssertionError(\"Unexpected WrongMethodTypeException thrown\", wmte);\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandlesArityLimitsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+    private static class CustomClass {}\n+\n@@ -83,0 +85,1 @@\n+        testTypedVarargsArray(CustomClass[].class);\n@@ -174,0 +177,2 @@\n+                if (elemType  == CustomClass.class)\n+                    arg = new CustomClass();\n","filename":"test\/jdk\/java\/lang\/invoke\/VarargsArrayTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang.invoke;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(3)\n+public class TypedAsCollector {\n+\n+    static final MethodHandle MH_COLLECT_OBJECT = MethodHandles.identity(Object[].class).asCollector(Object[].class, 3);\n+    static final MethodHandle MH_COLLECT_STRING = MethodHandles.identity(String[].class).asCollector(String[].class, 3);\n+    static final MethodHandle MH_COLLECT_INT = MethodHandles.identity(int[].class).asCollector(int[].class, 3);\n+\n+    \/\/ uses a different code path to construct the collector\n+    static final MethodHandle MH_COLLECT_OBJECT_HA = MethodHandles.identity(Object[].class).asCollector(Object[].class, 12);\n+    static final MethodHandle MH_COLLECT_STRING_HA = MethodHandles.identity(String[].class).asCollector(String[].class, 12);\n+    static final MethodHandle MH_COLLECT_INT_HA = MethodHandles.identity(int[].class).asCollector(int[].class, 12);\n+\n+    @Benchmark\n+    public Object[] testObjectCollect() throws Throwable {\n+        return (Object[]) MH_COLLECT_OBJECT.invokeExact((Object) \"A\", (Object) \"B\", (Object) \"C\");\n+    }\n+\n+    @Benchmark\n+    public Object[] testStringCollect() throws Throwable {\n+        return (String[]) MH_COLLECT_STRING.invokeExact(\"A\", \"B\", \"C\");\n+    }\n+\n+    @Benchmark\n+    public int[] testIntCollect() throws Throwable {\n+        return (int[]) MH_COLLECT_INT.invokeExact(1, 2, 3);\n+    }\n+\n+    @Benchmark\n+    public Object[] testObjectCollectHighArity() throws Throwable {\n+        return (Object[]) MH_COLLECT_OBJECT_HA.invokeExact(\n+                (Object) \"A\", (Object) \"B\", (Object) \"C\", (Object) \"D\", (Object) \"E\", (Object) \"F\",\n+                (Object) \"G\", (Object) \"H\", (Object) \"I\", (Object) \"J\", (Object) \"K\", (Object) \"L\");\n+    }\n+\n+    @Benchmark\n+    public Object[] testStringCollectHighArity() throws Throwable {\n+        return (String[]) MH_COLLECT_STRING_HA.invokeExact(\n+                 \"A\",  \"B\",  \"C\",  \"D\",  \"E\",  \"F\",\n+                 \"G\",  \"H\",  \"I\",  \"J\",  \"K\",  \"L\");\n+    }\n+\n+    @Benchmark\n+    public int[] testIntCollectHighArity() throws Throwable {\n+        return (int[]) MH_COLLECT_INT_HA.invokeExact(\n+                1, 2, 3, 4, 5, 6,\n+                7, 8, 9, 10, 11, 12);\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/TypedAsCollector.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}