{"files":[{"patch":"@@ -872,5 +872,0 @@\n-                case NEW_ARRAY:\n-                    \/\/ component type argument needs to be constant\n-                    if (!(name.arguments[0] instanceof Class<?>)) break;\n-                    emitNewArray(name);\n-                    continue;\n@@ -937,16 +932,0 @@\n-    void emitNewArray(Name name) {\n-        \/\/ call to Array.newInstance. Get the component type, which should be constant for this intrinsic\n-        Class<?> rtype = name.function.methodType().returnType();\n-        Class<?> arrayElementType = (Class<?>) name.arguments[0];\n-        \/\/ push array length\n-        emitPushArgument(name, 1);\n-        if (!arrayElementType.isPrimitive()) {\n-            mv.visitTypeInsn(Opcodes.ANEWARRAY, getInternalName(arrayElementType));\n-        } else {\n-            byte tc = arrayTypeCode(Wrapper.forPrimitiveType(arrayElementType));\n-            mv.visitIntInsn(Opcodes.NEWARRAY, tc);\n-        }\n-        \/\/ the array is left on the stack\n-        assertStaticType(rtype, name);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1230,1 +1230,0 @@\n-        NEW_ARRAY,\n@@ -1883,2 +1882,2 @@\n-        MethodHandle storeFunc = makeArrayElementAccessor(arrayType, ArrayAccess.SET);\n-        LambdaForm form = makeCollectorForm(type.basicType(), arrayType.componentType(), storeFunc);\n+        MethodHandle newArray = MethodHandles.arrayConstructor(arrayType);\n+        MethodHandle storeFunc = ArrayAccessor.getAccessor(arrayType, ArrayAccess.SET);\n@@ -1886,1 +1885,11 @@\n-        return SimpleMethodHandle.make(type, form);\n+        LambdaForm form = makeCollectorForm(type.basicType(), storeFunc);\n+\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n+        BoundMethodHandle mh;\n+        try {\n+            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) newArray);\n+        } catch (Throwable ex) {\n+            throw uncaughtException(ex);\n+        }\n+        assert(mh.type() == type);\n+        return mh;\n@@ -1889,1 +1898,1 @@\n-    private static LambdaForm makeCollectorForm(MethodType basicType, Class<?> componentType, MethodHandle storeFunc) {\n+    private static LambdaForm makeCollectorForm(MethodType basicType, MethodHandle storeFunc) {\n@@ -1893,5 +1902,12 @@\n-        \/\/ It might be possible to share this lambda form for all reference types - since they\n-        \/\/ use the same underlying store function - by injecting an array creation handle as a\n-        \/\/ field of the receiver handle.\n-        \/\/ This is left as a followup enhancement, as it needs to be investigated if this causes\n-        \/\/ profile pollution.\n+        \/\/ Only share the lambda form for empty arrays and reference types.\n+        \/\/ Sharing based on the basic type alone doesn't work because\n+        \/\/ we need a separate lambda form for byte\/short\/char\/int which\n+        \/\/ are all erased to int otherwise.\n+        \/\/ Other caching for primitive types happens at the MethodHandle level (see varargsArray).\n+        boolean isSharedLambdaForm = parameterCount == 0 || basicType.parameterType(0) == Object.class;\n+        if (isSharedLambdaForm) {\n+            LambdaForm lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_COLLECTOR);\n+            if (lform != null) {\n+                return lform;\n+            }\n+        }\n@@ -1899,1 +1915,2 @@\n-        final int ARG_BASE     = 1;  \/\/ start of incoming arguments (skipped receiver handle)\n+        final int THIS_MH      = 0;  \/\/ the BMH_L\n+        final int ARG_BASE     = 1;  \/\/ start of incoming arguments\n@@ -1903,0 +1920,1 @@\n+        final int GET_NEW_ARRAY       = nameCursor++;\n@@ -1910,2 +1928,3 @@\n-        NamedFunction newArray = new NamedFunction(getConstantHandle(MH_Array_newInstance), Intrinsic.NEW_ARRAY);\n-        names[CALL_NEW_ARRAY] = new Name(newArray, componentType, parameterCount);\n+        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_L();\n+        names[THIS_MH]          = names[THIS_MH].withConstraint(data);\n+        names[GET_NEW_ARRAY]    = new Name(data.getterFunction(0), names[THIS_MH]);\n@@ -1913,0 +1932,2 @@\n+        MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(Object.class, int.class));\n+        names[CALL_NEW_ARRAY] = new Name(new NamedFunction(invokeBasic), names[GET_NEW_ARRAY], parameterCount);\n@@ -1923,1 +1944,5 @@\n-        return new LambdaForm(lambdaType.parameterCount(), names, CALL_NEW_ARRAY, Kind.COLLECTOR);\n+        LambdaForm lform = new LambdaForm(lambdaType.parameterCount(), names, CALL_NEW_ARRAY, Kind.COLLECTOR);\n+        if (isSharedLambdaForm) {\n+            lform = basicType.form().setCachedLambdaForm(MethodTypeForm.LF_COLLECTOR, lform);\n+        }\n+        return lform;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -93,1 +93,2 @@\n-            LF_LIMIT                   = 25;\n+            LF_COLLECTOR               = 25,  \/\/ collector handle\n+            LF_LIMIT                   = 26;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -79,0 +79,2 @@\n+    private static class CustomClass {}\n+\n@@ -83,0 +85,1 @@\n+        testTypedVarargsArray(CustomClass[].class);\n@@ -174,0 +177,2 @@\n+                if (elemType  == CustomClass.class)\n+                    arg = new CustomClass();\n","filename":"test\/jdk\/java\/lang\/invoke\/VarargsArrayTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}