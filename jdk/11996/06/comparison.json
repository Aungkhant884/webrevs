{"files":[{"patch":"@@ -231,1 +231,1 @@\n-    guarantee (chk == -1 || chk == 0, \"Field too big for insn\");\n+    guarantee (chk == -1 || chk == 0, \"Field too big for insn at \" INTPTR_FORMAT, p2i(a));\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -39,0 +40,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -45,1 +49,1 @@\n-\/\/ This is the offset of the entry barrier from where the frame is completed.\n+\/\/ This is the offset of the entry barrier relative to where the frame is completed.\n@@ -65,2 +69,10 @@\n-class NativeNMethodBarrier: public NativeInstruction {\n-  address instruction_address() const { return addr_at(0); }\n+class NativeNMethodBarrier {\n+  address  _instruction_address;\n+  int*     _guard_addr;\n+  nmethod* _nm;\n+\n+  address instruction_address() const { return _instruction_address; }\n+\n+  int *guard_addr() {\n+    return _guard_addr;\n+  }\n@@ -73,9 +85,27 @@\n-  int *guard_addr(nmethod* nm) {\n-    if (nm->is_compiled_by_c2()) {\n-      \/\/ With c2 compiled code, the guard is out-of-line in a stub\n-      \/\/ We find it using the RelocIterator.\n-      RelocIterator iter(nm);\n-      while (iter.next()) {\n-        if (iter.type() == relocInfo::entry_guard_type) {\n-          entry_guard_Relocation* const reloc = iter.entry_guard_reloc();\n-          return reinterpret_cast<int*>(reloc->addr());\n+public:\n+  NativeNMethodBarrier(nmethod* nm): _nm(nm) {\n+#if INCLUDE_JVMCI\n+    if (nm->is_compiled_by_jvmci()) {\n+      address pc = nm->code_begin() + nm->jvmci_nmethod_data()->nmethod_entry_patch_offset();\n+      RelocIterator iter(nm, pc, pc + 4);\n+      guarantee(iter.next(), \"missing relocs\");\n+      guarantee(iter.type() == relocInfo::section_word_type, \"unexpected reloc\");\n+\n+      _guard_addr = (int*) iter.section_word_reloc()->target();\n+      _instruction_address = pc;\n+    } else\n+#endif\n+      {\n+        _instruction_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n+        if (nm->is_compiled_by_c2()) {\n+          \/\/ With c2 compiled code, the guard is out-of-line in a stub\n+          \/\/ We find it using the RelocIterator.\n+          RelocIterator iter(nm);\n+          while (iter.next()) {\n+            if (iter.type() == relocInfo::entry_guard_type) {\n+              entry_guard_Relocation* const reloc = iter.entry_guard_reloc();\n+              _guard_addr = reinterpret_cast<int*>(reloc->addr());\n+              return;\n+            }\n+          }\n+          ShouldNotReachHere();\n@@ -83,0 +113,1 @@\n+        _guard_addr =  reinterpret_cast<int*>(instruction_address() + local_guard_offset(nm));\n@@ -84,3 +115,0 @@\n-      ShouldNotReachHere();\n-    }\n-    return reinterpret_cast<int*>(instruction_address() + local_guard_offset(nm));\n@@ -89,3 +117,2 @@\n-public:\n-  int get_value(nmethod* nm) {\n-    return Atomic::load_acquire(guard_addr(nm));\n+  int get_value() {\n+    return Atomic::load_acquire(guard_addr());\n@@ -94,2 +121,2 @@\n-  void set_value(nmethod* nm, int value) {\n-    Atomic::release_store(guard_addr(nm), value);\n+  void set_value(int value) {\n+    Atomic::release_store(guard_addr(), value);\n@@ -98,1 +125,5 @@\n-  void verify() const;\n+  bool check_barrier(FormatBuffer<>& msg) const;\n+  void verify() const {\n+    FormatBuffer<> msg(\"%s\", \"\");\n+    assert(check_barrier(msg), \"%s\", msg.buffer());\n+  }\n@@ -110,1 +141,1 @@\n-void NativeNMethodBarrier::verify() const {\n+bool NativeNMethodBarrier::check_barrier(FormatBuffer<>& msg) const {\n@@ -114,2 +145,2 @@\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", (intptr_t)addr, inst);\n-    fatal(\"not an ldr (literal) instruction.\");\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x not an ldr\", p2i(addr), inst);\n+    return false;\n@@ -117,0 +148,1 @@\n+  return true;\n@@ -159,7 +191,0 @@\n-static NativeNMethodBarrier* native_nmethod_barrier(nmethod* nm) {\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n-  NativeNMethodBarrier* barrier = reinterpret_cast<NativeNMethodBarrier*>(barrier_address);\n-  debug_only(barrier->verify());\n-  return barrier;\n-}\n-\n@@ -182,2 +207,2 @@\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  barrier->set_value(nm, value);\n+  NativeNMethodBarrier barrier(nm);\n+  barrier.set_value(value);\n@@ -191,2 +216,8 @@\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  return barrier->get_value(nm);\n+  NativeNMethodBarrier barrier(nm);\n+  return barrier.get_value();\n+}\n+\n+#if INCLUDE_JVMCI\n+bool BarrierSetNMethod::verify_barrier(nmethod* nm, FormatBuffer<>& msg) {\n+  NativeNMethodBarrier barrier(nm);\n+  return barrier.check_barrier(msg);\n@@ -194,0 +225,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetNMethod_aarch64.cpp","additions":67,"deletions":35,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+  NativeCall* call = NULL;\n@@ -127,1 +128,1 @@\n-      break;\n+      return;\n@@ -131,1 +132,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -138,1 +139,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -145,1 +146,1 @@\n-      NativeCall* call = nativeCall_at(_instructions->start() + pc_offset);\n+      call = nativeCall_at(_instructions->start() + pc_offset);\n@@ -154,0 +155,9 @@\n+  if (Continuations::enabled()) {\n+    \/\/ Check for proper post_call_nop\n+    NativePostCallNop* nop = nativePostCallNop_at(call->next_instruction_address());\n+    if (nop == NULL) {\n+      JVMCI_ERROR(\"missing post call nop at offset %d\", pc_offset);\n+    } else {\n+      _instructions->relocate(call->next_instruction_address(), relocInfo::post_call_nop_type);\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/jvmciCodeInstaller_aarch64.cpp","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -62,2 +62,0 @@\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-\n","filename":"src\/hotspot\/cpu\/ppc\/globalDefinitions_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -60,2 +63,10 @@\n-class NativeNMethodBarrier: public NativeInstruction {\n-  address instruction_address() const { return addr_at(0); }\n+class NativeNMethodBarrier {\n+  address  _instruction_address;\n+  int*     _guard_addr;\n+  nmethod* _nm;\n+\n+  address instruction_address() const { return _instruction_address; }\n+\n+  int *guard_addr() {\n+    return _guard_addr;\n+  }\n@@ -68,9 +79,27 @@\n-  int *guard_addr(nmethod* nm) {\n-    if (nm->is_compiled_by_c2()) {\n-      \/\/ With c2 compiled code, the guard is out-of-line in a stub\n-      \/\/ We find it using the RelocIterator.\n-      RelocIterator iter(nm);\n-      while (iter.next()) {\n-        if (iter.type() == relocInfo::entry_guard_type) {\n-          entry_guard_Relocation* const reloc = iter.entry_guard_reloc();\n-          return reinterpret_cast<int*>(reloc->addr());\n+public:\n+  NativeNMethodBarrier(nmethod* nm): _nm(nm) {\n+#if INCLUDE_JVMCI\n+    if (nm->is_compiled_by_jvmci()) {\n+      address pc = nm->code_begin() + nm->jvmci_nmethod_data()->nmethod_entry_patch_offset();\n+      RelocIterator iter(nm, pc, pc + 4);\n+      guarantee(iter.next(), \"missing relocs\");\n+      guarantee(iter.type() == relocInfo::section_word_type, \"unexpected reloc\");\n+\n+      _guard_addr = (int*) iter.section_word_reloc()->target();\n+      _instruction_address = pc;\n+    } else\n+#endif\n+      {\n+        _instruction_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n+        if (nm->is_compiled_by_c2()) {\n+          \/\/ With c2 compiled code, the guard is out-of-line in a stub\n+          \/\/ We find it using the RelocIterator.\n+          RelocIterator iter(nm);\n+          while (iter.next()) {\n+            if (iter.type() == relocInfo::entry_guard_type) {\n+              entry_guard_Relocation* const reloc = iter.entry_guard_reloc();\n+              _guard_addr = reinterpret_cast<int*>(reloc->addr());\n+              return;\n+            }\n+          }\n+          ShouldNotReachHere();\n@@ -78,0 +107,1 @@\n+        _guard_addr = reinterpret_cast<int*>(instruction_address() + local_guard_offset(nm));\n@@ -79,3 +109,0 @@\n-      ShouldNotReachHere();\n-    }\n-    return reinterpret_cast<int*>(instruction_address() + local_guard_offset(nm));\n@@ -84,3 +111,2 @@\n-public:\n-  int get_value(nmethod* nm) {\n-    return Atomic::load_acquire(guard_addr(nm));\n+  int get_value() {\n+    return Atomic::load_acquire(guard_addr());\n@@ -89,2 +115,2 @@\n-  void set_value(nmethod* nm, int value) {\n-    Atomic::release_store(guard_addr(nm), value);\n+  void set_value(int value) {\n+    Atomic::release_store(guard_addr(), value);\n@@ -93,1 +119,5 @@\n-  void verify() const;\n+  bool check_barrier(FormatBuffer<>& msg) const;\n+  void verify() const {\n+    FormatBuffer<> msg(\"%s\", \"\");\n+    assert(check_barrier(msg), \"%s\", msg.buffer());\n+  }\n@@ -115,1 +145,1 @@\n-void NativeNMethodBarrier::verify() const {\n+bool NativeNMethodBarrier::check_barrier(FormatBuffer<>& msg) const {\n@@ -120,2 +150,2 @@\n-      tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", addr, inst);\n-      fatal(\"not an %s instruction.\", barrierInsn[i].name);\n+      msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x not an %s instruction\", addr, inst, barrierInsn[i].name);\n+      return false;\n@@ -125,0 +155,1 @@\n+  return true;\n@@ -167,7 +198,0 @@\n-static NativeNMethodBarrier* native_nmethod_barrier(nmethod* nm) {\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n-  NativeNMethodBarrier* barrier = reinterpret_cast<NativeNMethodBarrier*>(barrier_address);\n-  debug_only(barrier->verify());\n-  return barrier;\n-}\n-\n@@ -190,2 +214,2 @@\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  barrier->set_value(nm, value);\n+  NativeNMethodBarrier barrier(nm);\n+  barrier.set_value(value);\n@@ -199,2 +223,8 @@\n-  NativeNMethodBarrier* barrier = native_nmethod_barrier(nm);\n-  return barrier->get_value(nm);\n+  NativeNMethodBarrier barrier(nm);\n+  return barrier.get_value();\n+}\n+\n+#if INCLUDE_JVMCI\n+bool BarrierSetNMethod::verify_barrier(nmethod* nm, FormatBuffer<>& msg) {\n+  NativeNMethodBarrier barrier(nm);\n+  return barrier.check_barrier(msg);\n@@ -202,0 +232,1 @@\n+#endif\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetNMethod_riscv.cpp","additions":65,"deletions":34,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -50,2 +50,0 @@\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-\n","filename":"src\/hotspot\/cpu\/s390\/globalDefinitions_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/formatBuffer.hpp\"\n@@ -36,0 +37,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -61,1 +65,5 @@\n-  void verify() const;\n+  bool check_barrier(FormatBuffer<>& msg) const;\n+  void verify() const {\n+    FormatBuffer<> msg(\"%s\", \"\");\n+    assert(check_barrier(msg), \"%s\", msg.buffer());\n+  }\n@@ -65,1 +73,2 @@\n-void NativeNMethodCmpBarrier::verify() const {\n+bool NativeNMethodCmpBarrier::check_barrier(FormatBuffer<>& msg) const {\n+  \/\/ Only require 4 byte alignment\n@@ -67,1 +76,2 @@\n-    fatal(\"Not properly aligned\");\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" not properly aligned\", p2i(instruction_address()));\n+    return false;\n@@ -72,3 +82,2 @@\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Prefix: 0x%x\", p2i(instruction_address()),\n-        prefix);\n-    fatal(\"not a cmp barrier\");\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x expected 0x%x\", p2i(instruction_address()), prefix, instruction_rex_prefix);\n+    return false;\n@@ -79,3 +88,2 @@\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", p2i(instruction_address()),\n-        inst);\n-    fatal(\"not a cmp barrier\");\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x expected 0x%x\", p2i(instruction_address()), inst, instruction_code);\n+    return false;\n@@ -86,3 +94,2 @@\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" mod\/rm: 0x%x\", p2i(instruction_address()),\n-        modrm);\n-    fatal(\"not a cmp barrier\");\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x expected mod\/rm 0x%x\", p2i(instruction_address()), modrm, instruction_modrm);\n+    return false;\n@@ -90,0 +97,1 @@\n+  return true;\n@@ -92,1 +100,1 @@\n-void NativeNMethodCmpBarrier::verify() const {\n+bool NativeNMethodCmpBarrier::check_barrier(FormatBuffer<>& msg) const {\n@@ -94,1 +102,2 @@\n-    fatal(\"Not properly aligned\");\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" not properly aligned\", p2i(instruction_address()));\n+    return false;\n@@ -99,1 +108,1 @@\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", p2i(instruction_address()),\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" Code: 0x%x\", p2i(instruction_address()),\n@@ -101,1 +110,1 @@\n-    fatal(\"not a cmp barrier\");\n+    return false;\n@@ -106,1 +115,1 @@\n-    tty->print_cr(\"Addr: \" INTPTR_FORMAT \" mod\/rm: 0x%x\", p2i(instruction_address()),\n+    msg.print(\"Addr: \" INTPTR_FORMAT \" mod\/rm: 0x%x\", p2i(instruction_address()),\n@@ -108,1 +117,1 @@\n-    fatal(\"not a cmp barrier\");\n+    return false;\n@@ -110,0 +119,1 @@\n+  return true;\n@@ -173,1 +183,10 @@\n-  address barrier_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n+  address barrier_address;\n+#if INCLUDE_JVMCI\n+  if (nm->is_compiled_by_jvmci()) {\n+    barrier_address = nm->code_begin() + nm->jvmci_nmethod_data()->nmethod_entry_patch_offset();\n+  } else\n+#endif\n+    {\n+      barrier_address = nm->code_begin() + nm->frame_complete_offset() + entry_barrier_offset(nm);\n+    }\n+\n@@ -175,1 +194,1 @@\n-  debug_only(barrier->verify());\n+  barrier->verify();\n@@ -196,0 +215,8 @@\n+\n+\n+#if INCLUDE_JVMCI\n+bool BarrierSetNMethod::verify_barrier(nmethod* nm, FormatBuffer<>& msg) {\n+  NativeNMethodCmpBarrier* barrier = native_nmethod_barrier(nm);\n+  return barrier->check_barrier(msg);\n+}\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetNMethod_x86.cpp","additions":47,"deletions":20,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -74,6 +74,0 @@\n-#if INCLUDE_JVMCI\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS EnableJVMCI\n-#else\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-#endif\n-\n","filename":"src\/hotspot\/cpu\/x86\/globalDefinitions_x86.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -188,0 +188,9 @@\n+  if (Continuations::enabled()) {\n+    \/\/ Check for proper post_call_nop\n+    NativePostCallNop* nop = nativePostCallNop_at(call->next_instruction_address());\n+    if (nop == NULL) {\n+      JVMCI_ERROR(\"missing post call nop at offset %d\", pc_offset);\n+    } else {\n+      _instructions->relocate(call->next_instruction_address(), relocInfo::post_call_nop_type);\n+    }\n+  }\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,2 +45,0 @@\n-#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false\n-\n","filename":"src\/hotspot\/cpu\/zero\/globalDefinitions_zero.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -553,3 +553,1 @@\n-  int nmethod_mirror_index,\n-  const char* nmethod_mirror_name,\n-  FailedSpeculation** failed_speculations\n+  JVMCINMethodData* jvmci_data\n@@ -564,1 +562,1 @@\n-  int jvmci_data_size = !compiler->is_jvmci() ? 0 : JVMCINMethodData::compute_size(nmethod_mirror_name);\n+  int jvmci_data_size = compiler->is_jvmci() ? jvmci_data->size() : 0;\n@@ -591,1 +589,1 @@\n-            jvmci_data_size\n+            jvmci_data\n@@ -596,6 +594,0 @@\n-#if INCLUDE_JVMCI\n-      if (compiler->is_jvmci()) {\n-        \/\/ Initialize the JVMCINMethodData object inlined into nm\n-        nm->jvmci_nmethod_data()->initialize(nmethod_mirror_index, nmethod_mirror_name, failed_speculations);\n-      }\n-#endif\n@@ -789,1 +781,1 @@\n-  int jvmci_data_size\n+  JVMCINMethodData* jvmci_data\n@@ -869,0 +861,1 @@\n+    int jvmci_data_size = compiler->is_jvmci() ? jvmci_data->size() : 0;\n@@ -888,0 +881,7 @@\n+#if INCLUDE_JVMCI\n+    if (compiler->is_jvmci()) {\n+      \/\/ Initialize the JVMCINMethodData object inlined into nm\n+      jvmci_nmethod_data()->copy(jvmci_data);\n+    }\n+#endif\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -295,3 +295,3 @@\n-          , char* speculations,\n-          int speculations_len,\n-          int jvmci_data_size\n+          , char* speculations = nullptr,\n+          int speculations_len = 0,\n+          JVMCINMethodData* jvmci_data = nullptr\n@@ -348,3 +348,1 @@\n-                              int nmethod_mirror_index = -1,\n-                              const char* nmethod_mirror_name = nullptr,\n-                              FailedSpeculation** failed_speculations = nullptr\n+                              JVMCINMethodData* jvmci_data = nullptr\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -42,0 +42,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmciRuntime.hpp\"\n+#endif\n@@ -65,2 +68,7 @@\n-  if (!nm->is_native_method() && !nm->is_compiled_by_c2() && !nm->is_compiled_by_c1()) {\n-    return false;\n+  if (nm->is_native_method() || nm->is_compiled_by_c2() || nm->is_compiled_by_c1()) {\n+    return true;\n+  }\n+\n+#if INCLUDE_JVMCI\n+  if (nm->is_compiled_by_jvmci() && nm->jvmci_nmethod_data()->has_entry_barrier()) {\n+    return true;\n@@ -68,0 +76,1 @@\n+#endif\n@@ -69,1 +78,1 @@\n-  return true;\n+  return false;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,0 +31,3 @@\n+#if INCLUDE_JVMCI\n+#include \"utilities\/formatBuffer.hpp\"\n+#endif\n@@ -58,0 +61,4 @@\n+\n+#if INCLUDE_JVMCI\n+  bool verify_barrier(nmethod* nm, FormatBuffer<>& msg);\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -382,1 +383,1 @@\n-    oopDesc::verify(obj);\n+    guarantee(oopDesc::is_oop_or_null(obj), \"invalid oop: \" INTPTR_FORMAT, p2i((oopDesc*) obj));\n@@ -730,0 +731,8 @@\n+    \/\/ We would like to be strict about the nmethod entry barrier but there are various test\n+    \/\/ configurations which generate assembly without being a full compiler. So for now we enforce\n+    \/\/ that JIT compiled methods must have an nmethod barrier.\n+    bool install_default = JVMCIENV->get_HotSpotNmethod_isDefault(installed_code) != 0;\n+    if (_nmethod_entry_patch_offset == -1 && install_default) {\n+      JVMCI_THROW_MSG_(IllegalArgumentException, \"nmethod entry barrier is missing\", JVMCI::ok);\n+    }\n+\n@@ -754,1 +763,2 @@\n-                                        speculations_len);\n+                                        speculations_len,\n+                                        _nmethod_entry_patch_offset);\n@@ -763,0 +773,11 @@\n+\n+      if (nm != nullptr) {\n+        if (_nmethod_entry_patch_offset != -1) {\n+          FormatBuffer<> msg(\"%s\", \"\");\n+          BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+\n+          if (!bs_nm->verify_barrier(nm, msg)) {\n+            JVMCI_THROW_MSG_(IllegalArgumentException, err_msg(\"nmethod entry barrier is malformed: %s\", msg.buffer()), JVMCI::ok);\n+          }\n+        }\n+      }\n@@ -807,0 +828,1 @@\n+  _has_monitors = false;\n@@ -808,0 +830,1 @@\n+  _nmethod_entry_patch_offset = -1;\n@@ -1259,0 +1282,3 @@\n+    case ENTRY_BARRIER_PATCH:\n+      _nmethod_entry_patch_offset = pc_offset;\n+      break;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.cpp","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -155,0 +155,1 @@\n+    ENTRY_BARRIER_PATCH,\n@@ -274,0 +275,1 @@\n+  int           _nmethod_entry_patch_offset;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCodeInstaller.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"oops\/objArrayKlass.inline.hpp\"\n@@ -386,1 +387,0 @@\n-  JVMCIKlassHandle klass(THREAD);\n@@ -388,2 +388,7 @@\n-  jlong base_address = 0;\n-  if (base_object.is_non_null() && offset == oopDesc::klass_offset_in_bytes()) {\n+  if (base_object.is_null()) {\n+    JVMCI_THROW_MSG_NULL(NullPointerException, \"base object is null\");\n+  }\n+\n+  const char* base_desc = nullptr;\n+  JVMCIKlassHandle klass(THREAD);\n+  if (offset == oopDesc::klass_offset_in_bytes()) {\n@@ -394,1 +399,1 @@\n-      assert(false, \"What types are we actually expecting here?\");\n+      goto unexpected;\n@@ -397,11 +402,38 @@\n-    if (base_object.is_non_null()) {\n-      if (JVMCIENV->isa_HotSpotResolvedJavaMethodImpl(base_object)) {\n-        base_address = (intptr_t) JVMCIENV->asMethod(base_object);\n-      } else if (JVMCIENV->isa_HotSpotConstantPool(base_object)) {\n-        base_address = (intptr_t) JVMCIENV->asConstantPool(base_object);\n-      } else if (JVMCIENV->isa_HotSpotResolvedObjectTypeImpl(base_object)) {\n-        base_address = (intptr_t) JVMCIENV->asKlass(base_object);\n-      } else if (JVMCIENV->isa_HotSpotObjectConstantImpl(base_object)) {\n-        Handle base_oop = JVMCIENV->asConstant(base_object, JVMCI_CHECK_NULL);\n-        if (base_oop->is_a(vmClasses::Class_klass())) {\n-          base_address = cast_from_oop<jlong>(base_oop());\n+    if (JVMCIENV->isa_HotSpotConstantPool(base_object)) {\n+      ConstantPool* cp = JVMCIENV->asConstantPool(base_object);\n+      if (offset == ConstantPool::pool_holder_offset_in_bytes()) {\n+        klass = cp->pool_holder();\n+      } else {\n+        base_desc = FormatBufferResource(\"[constant pool for %s]\", cp->pool_holder()->signature_name());\n+        goto unexpected;\n+      }\n+    } else if (JVMCIENV->isa_HotSpotResolvedObjectTypeImpl(base_object)) {\n+      Klass* base_klass = JVMCIENV->asKlass(base_object);\n+      if (offset == in_bytes(Klass::subklass_offset())) {\n+        klass = base_klass->subklass();\n+      } else if (offset == in_bytes(Klass::super_offset())) {\n+        klass = base_klass->super();\n+      } else if (offset == in_bytes(Klass::next_sibling_offset())) {\n+        klass = base_klass->next_sibling();\n+      } else if (offset == in_bytes(ObjArrayKlass::element_klass_offset()) && base_klass->is_objArray_klass()) {\n+        klass = ObjArrayKlass::cast(base_klass)->element_klass();\n+      } else if (offset >= in_bytes(Klass::primary_supers_offset()) &&\n+                 offset < in_bytes(Klass::primary_supers_offset()) + (int) (sizeof(Klass*) * Klass::primary_super_limit()) &&\n+                 offset % sizeof(Klass*) == 0) {\n+        \/\/ Offset is within the primary supers array\n+        int index = (int) ((offset - in_bytes(Klass::primary_supers_offset())) \/ sizeof(Klass*));\n+        klass = base_klass->primary_super_of_depth(index);\n+      } else {\n+        base_desc = FormatBufferResource(\"[%s]\", base_klass->signature_name());\n+        goto unexpected;\n+      }\n+    } else if (JVMCIENV->isa_HotSpotObjectConstantImpl(base_object)) {\n+      Handle base_oop = JVMCIENV->asConstant(base_object, JVMCI_CHECK_NULL);\n+      if (base_oop->is_a(vmClasses::Class_klass())) {\n+        if (offset == java_lang_Class::klass_offset()) {\n+          klass = java_lang_Class::as_Klass(base_oop());\n+        } else if (offset == java_lang_Class::array_klass_offset()) {\n+          klass = java_lang_Class::array_klass_acquire(base_oop());\n+        } else {\n+          base_desc = FormatBufferResource(\"[Class=%s]\", java_lang_Class::as_Klass(base_oop())->signature_name());\n+          goto unexpected;\n@@ -409,0 +441,5 @@\n+      } else {\n+        if (!base_oop.is_null()) {\n+          base_desc = FormatBufferResource(\"[%s]\", base_oop()->klass()->signature_name());\n+        }\n+        goto unexpected;\n@@ -410,3 +447,6 @@\n-      if (base_address == 0) {\n-        JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-                    err_msg(\"Unexpected arguments: %s \" JLONG_FORMAT \" %s\", JVMCIENV->klass_name(base_object), offset, compressed ? \"true\" : \"false\"));\n+    } else if (JVMCIENV->isa_HotSpotMethodData(base_object)) {\n+      jlong base_address = (intptr_t) JVMCIENV->asMethodData(base_object);\n+      klass = *((Klass**) (intptr_t) (base_address + offset));\n+      if (klass == nullptr || !klass->is_loader_alive()) {\n+        \/\/ Klasses in methodData might be concurrently unloading so return null in that case.\n+        return nullptr;\n@@ -414,0 +454,2 @@\n+    } else {\n+      goto unexpected;\n@@ -415,1 +457,0 @@\n-    klass = *((Klass**) (intptr_t) (base_address + offset));\n@@ -417,4 +458,1 @@\n-    JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n-                err_msg(\"Unexpected arguments: %s \" JLONG_FORMAT \" %s\",\n-                        base_object.is_non_null() ? JVMCIENV->klass_name(base_object) : \"null\",\n-                        offset, compressed ? \"true\" : \"false\"));\n+    goto unexpected;\n@@ -422,3 +460,14 @@\n-  assert (klass == nullptr || klass->is_klass(), \"invalid read\");\n-  JVMCIObject result = JVMCIENV->get_jvmci_type(klass, JVMCI_CHECK_NULL);\n-  return JVMCIENV->get_jobject(result);\n+\n+  {\n+    if (klass == nullptr) {\n+      return nullptr;\n+    }\n+    JVMCIObject result = JVMCIENV->get_jvmci_type(klass, JVMCI_CHECK_NULL);\n+    return JVMCIENV->get_jobject(result);\n+  }\n+\n+unexpected:\n+  JVMCI_THROW_MSG_NULL(IllegalArgumentException,\n+                       err_msg(\"Unexpected arguments: %s%s \" JLONG_FORMAT \" %s\",\n+                               JVMCIENV->klass_name(base_object), base_desc == nullptr ? \"\" : base_desc,\n+                               offset, compressed ? \"true\" : \"false\"));\n@@ -1715,0 +1764,7 @@\n+  \/\/ Java code should never directly access the extra data section\n+  JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(\"Invalid profile data position %d\", position));\n+C2V_END\n+\n+C2V_VMENTRY_0(jint, methodDataExceptionSeen, (JNIEnv* env, jobject, jlong method_data_pointer, jint bci))\n+  MethodData* mdo = (MethodData*) method_data_pointer;\n+  MutexLocker mu(mdo->extra_data_lock());\n@@ -1716,1 +1772,1 @@\n-  DataLayout* end   = mdo->extra_data_limit();\n+  DataLayout* end   = mdo->args_data_limit();\n@@ -1719,3 +1775,17 @@\n-    profile_data = data->data_in();\n-    if (mdo->dp_to_di(profile_data->dp()) == position) {\n-      return profile_data->size_in_bytes();\n+    int tag = data->tag();\n+    switch(tag) {\n+      case DataLayout::bit_data_tag: {\n+        BitData* bit_data = (BitData*) data->data_in();\n+        if (bit_data->bci() == bci) {\n+          return bit_data->exception_seen() ? 1 : 0;\n+        }\n+        break;\n+      }\n+    case DataLayout::no_tag:\n+      \/\/ There is a free slot so return false since a BitData would have been allocated to record\n+      \/\/ true if it had been seen.\n+      return 0;\n+    case DataLayout::arg_info_data_tag:\n+      \/\/ The bci wasn't found and there are no free slots to record a trap for this location, so always\n+      \/\/ return unknown.\n+      return -1;\n@@ -1724,1 +1794,2 @@\n-  JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(\"Invalid profile data position %d\", position));\n+  ShouldNotReachHere();\n+  return -1;\n@@ -3020,0 +3091,1 @@\n+  {CC \"methodDataExceptionSeen\",                      CC \"(JI)I\",                                                                           FN_PTR(methodDataExceptionSeen)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":103,"deletions":31,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -51,0 +52,20 @@\n+    static address SharedRuntime_polling_page_return_handler;\n+\n+    static address nmethod_entry_barrier;\n+    static int thread_disarmed_guard_value_offset;\n+    static int thread_address_bad_mask_offset;\n+#ifdef AARCH64\n+    static int BarrierSetAssembler_nmethod_patching_type;\n+    static address BarrierSetAssembler_patching_epoch_addr;\n+#endif\n+\n+    static address ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded;\n+    static address ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded;\n+    static address ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded;\n+    static address ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded;\n+    static address ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded;\n+    static address ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded;\n+    static address ZBarrierSetRuntime_load_barrier_on_oop_array;\n+    static address ZBarrierSetRuntime_clone;\n+\n+    static bool continuations_enabled;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -33,0 +34,3 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n+#include \"gc\/z\/zThreadLocalData.hpp\"\n+#include \"gc\/z\/zBarrierSetRuntime.hpp\"\n@@ -55,0 +59,21 @@\n+address CompilerToVM::Data::SharedRuntime_polling_page_return_handler;\n+\n+address CompilerToVM::Data::nmethod_entry_barrier;\n+int CompilerToVM::Data::thread_disarmed_guard_value_offset;\n+int CompilerToVM::Data::thread_address_bad_mask_offset;\n+\n+address CompilerToVM::Data::ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded;\n+address CompilerToVM::Data::ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded;\n+address CompilerToVM::Data::ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded;\n+address CompilerToVM::Data::ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded;\n+address CompilerToVM::Data::ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded;\n+address CompilerToVM::Data::ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded;\n+address CompilerToVM::Data::ZBarrierSetRuntime_load_barrier_on_oop_array;\n+address CompilerToVM::Data::ZBarrierSetRuntime_clone;\n+\n+bool CompilerToVM::Data::continuations_enabled;\n+\n+#ifdef AARCH64\n+int CompilerToVM::Data::BarrierSetAssembler_nmethod_patching_type;\n+address CompilerToVM::Data::BarrierSetAssembler_patching_epoch_addr;\n+#endif\n@@ -111,0 +136,25 @@\n+  SharedRuntime_polling_page_return_handler = SharedRuntime::polling_page_return_handler_blob()->entry_point();\n+\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm != nullptr) {\n+    thread_disarmed_guard_value_offset = in_bytes(bs_nm->thread_disarmed_guard_value_offset());\n+    AMD64_ONLY(nmethod_entry_barrier = StubRoutines::x86::method_entry_barrier());\n+    AARCH64_ONLY(nmethod_entry_barrier = StubRoutines::aarch64::method_entry_barrier());\n+    BarrierSetAssembler* bs_asm = BarrierSet::barrier_set()->barrier_set_assembler();\n+    AARCH64_ONLY(BarrierSetAssembler_nmethod_patching_type = (int) bs_asm->nmethod_patching_type());\n+    AARCH64_ONLY(BarrierSetAssembler_patching_epoch_addr = bs_asm->patching_epoch_addr());\n+  }\n+\n+  if (UseZGC) {\n+    thread_address_bad_mask_offset = in_bytes(ZThreadLocalData::address_bad_mask_offset());\n+    ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded =                     ZBarrierSetRuntime::load_barrier_on_oop_field_preloaded_addr();\n+    ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded =                ZBarrierSetRuntime::load_barrier_on_weak_oop_field_preloaded_addr();\n+    ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded =             ZBarrierSetRuntime::load_barrier_on_phantom_oop_field_preloaded_addr();\n+    ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded =                ZBarrierSetRuntime::weak_load_barrier_on_oop_field_preloaded_addr();\n+    ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded =           ZBarrierSetRuntime::weak_load_barrier_on_weak_oop_field_preloaded_addr();\n+    ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded =        ZBarrierSetRuntime::weak_load_barrier_on_phantom_oop_field_preloaded_addr();\n+    ZBarrierSetRuntime_load_barrier_on_oop_array =                               ZBarrierSetRuntime::load_barrier_on_oop_array_addr();\n+    ZBarrierSetRuntime_clone =                                                   ZBarrierSetRuntime::clone_addr();\n+  }\n+\n+  continuations_enabled = Continuations::enabled();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -1166,0 +1166,3 @@\n+  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current()); \/\/ For exception macros.\n+  JVMCIKlassHandle holder_klass(THREAD, method->method_holder());\n+  JVMCIObject holder = get_jvmci_type(holder_klass, JVMCI_CHECK_(JVMCIObject()));\n@@ -1169,1 +1172,0 @@\n-  JavaThread* THREAD = JVMCI::compilation_tick(JavaThread::current()); \/\/ For exception macros.\n@@ -1176,0 +1178,1 @@\n+    args.push_oop(Handle(THREAD, HotSpotJVMCI::resolve(holder)));\n@@ -1188,1 +1191,1 @@\n-                                                                  (jlong) handle));\n+                                                                 (jlong) handle, holder.as_jobject()));\n@@ -1211,0 +1214,3 @@\n+  guarantee(klass->is_klass(), \"must be valid klass\");\n+  guarantee(klass->is_loader_alive(), \"klass must be alive\");\n+\n@@ -1509,1 +1515,1 @@\n-  oop obj = *((oopDesc**) oopHandle);\n+  oop obj = NativeAccess<>::oop_load(reinterpret_cast<oop*>(oopHandle));\n@@ -1511,1 +1517,1 @@\n-    oopDesc::verify(obj);\n+    guarantee(oopDesc::is_oop_or_null(obj), \"invalid oop: \" INTPTR_FORMAT, p2i((oopDesc*) obj));\n@@ -1647,0 +1653,3 @@\n+MethodData* JVMCIEnv::asMethodData(JVMCIObject obj) {\n+  return (MethodData*) get_HotSpotMethodData_methodDataPointer(obj);\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/klass.inline.hpp\"\n@@ -378,0 +379,3 @@\n+  \/\/ Unpack an instance of HotSpotMethodData into the original MethodData*\n+  MethodData* asMethodData(JVMCIObject jvmci_method_data);\n+\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,0 +90,3 @@\n+  start_class(HotSpotMethodData, jdk_vm_ci_hotspot_HotSpotMethodData)                                         \\\n+    long_field(HotSpotMethodData, methodDataPointer)                                                          \\\n+  end_class                                                                                                   \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -261,0 +261,6 @@\n+\n+  \/\/ The frame we rethrow the exception to might not have been processed by the GC yet.\n+  \/\/ The stack watermark barrier takes care of detecting that and ensuring the frame\n+  \/\/ has updated oops.\n+  StackWatermarkSet::after_unwind(current);\n+\n@@ -756,4 +762,4 @@\n-void JVMCINMethodData::initialize(\n-  int nmethod_mirror_index,\n-  const char* name,\n-  FailedSpeculation** failed_speculations)\n+void JVMCINMethodData::initialize(int nmethod_mirror_index,\n+                                  int nmethod_entry_patch_offset,\n+                                  const char* nmethod_mirror_name,\n+                                  FailedSpeculation** failed_speculations)\n@@ -763,1 +769,2 @@\n-  if (name != nullptr) {\n+  _nmethod_entry_patch_offset = nmethod_entry_patch_offset;\n+  if (nmethod_mirror_name != nullptr) {\n@@ -765,2 +772,2 @@\n-    char* dest = (char*) this->name();\n-    strcpy(dest, name);\n+    char* dest = (char*) name();\n+    strcpy(dest, nmethod_mirror_name);\n@@ -772,0 +779,4 @@\n+void JVMCINMethodData::copy(JVMCINMethodData* data) {\n+  initialize(data->_nmethod_mirror_index, data->_nmethod_entry_patch_offset, data->name(), data->_failed_speculations);\n+}\n+\n@@ -855,1 +866,1 @@\n-  return (jlong) ptr;\n+  return reinterpret_cast<jlong>(ptr);\n@@ -936,1 +947,2 @@\n-    int to_release = next - num_alive;\n+    if (next != num_alive) {\n+      int to_release = next - num_alive;\n@@ -938,2 +950,2 @@\n-    \/\/ `next` is now the index of the first null handle\n-    \/\/ Example: to_release: 2\n+      \/\/ `next` is now the index of the first null handle\n+      \/\/ Example: to_release: 2\n@@ -941,2 +953,1 @@\n-    \/\/ Bulk release the handles with a null referent\n-    if (to_release != 0) {\n+      \/\/ Bulk release the handles with a null referent\n@@ -944,1 +955,0 @@\n-    }\n@@ -946,4 +956,4 @@\n-    \/\/ Truncate oop handles to only those with a non-null referent\n-    JVMCI_event_1(\"compacted oop handles in JVMCI runtime %d from %d to %d\", _id, _oop_handles.length(), num_alive);\n-    _oop_handles.trunc_to(num_alive);\n-    \/\/ Example: HHH\n+      \/\/ Truncate oop handles to only those with a non-null referent\n+      JVMCI_event_1(\"compacted oop handles in JVMCI runtime %d from %d to %d\", _id, _oop_handles.length(), num_alive);\n+      _oop_handles.trunc_to(num_alive);\n+      \/\/ Example: HHH\n@@ -951,1 +961,2 @@\n-    return to_release;\n+      return to_release;\n+    }\n@@ -2080,1 +2091,2 @@\n-                                                       int speculations_len) {\n+                                                       int speculations_len,\n+                                                       int nmethod_entry_patch_offset) {\n@@ -2148,0 +2160,4 @@\n+      JVMCINMethodData* data = JVMCINMethodData::create(nmethod_mirror_index,\n+                                                        nmethod_entry_patch_offset,\n+                                                        nmethod_mirror_name,\n+                                                        failed_speculations);\n@@ -2157,2 +2173,1 @@\n-                                 speculations, speculations_len,\n-                                 nmethod_mirror_index, nmethod_mirror_name, failed_speculations);\n+                                 speculations, speculations_len, data);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":37,"deletions":22,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -43,4 +43,4 @@\n-\/\/ Encapsulates the JVMCI metadata for an nmethod.\n-\/\/ JVMCINMethodData objects are inlined into nmethods\n-\/\/ at nmethod::_jvmci_data_offset.\n-class JVMCINMethodData {\n+\/\/ Encapsulates the JVMCI metadata for an nmethod.  JVMCINMethodData objects are normally inlined\n+\/\/ into nmethods at nmethod::_jvmci_data_offset but during construction of the nmethod they are\n+\/\/ resource allocated so they can be passed into the nmethod constructor.\n+class JVMCINMethodData : public ResourceObj {\n@@ -48,3 +48,0 @@\n-  \/\/ Index for the HotSpotNmethod mirror in the nmethod's oops table.\n-  \/\/ This is -1 if there is no mirror in the oops table.\n-  int _nmethod_mirror_index;\n@@ -56,0 +53,10 @@\n+  \/\/ Index for the HotSpotNmethod mirror in the nmethod's oops table.\n+  \/\/ This is -1 if there is no mirror in the oops table.\n+  int _nmethod_mirror_index;\n+\n+  \/\/ This is the offset of the patchable part of the nmethod entry barrier sequence.  The meaning is\n+  \/\/ somewhat platform dependent as the way patching is done varies by architecture.  Older JVMCI\n+  \/\/ based compilers didn't emit the entry barrier so having a positive value for this offset\n+  \/\/ confirms that the installed code supports the entry barrier.\n+  int _nmethod_entry_patch_offset;\n+\n@@ -68,0 +75,12 @@\n+  \/\/ Allocate a temporary data object for use during installation\n+  void initialize(int nmethod_mirror_index,\n+                   int nmethod_entry_patch_offset,\n+                   const char* nmethod_mirror_name,\n+                   FailedSpeculation** failed_speculations);\n+\n+  void* operator new(size_t size, const char* nmethod_mirror_name) {\n+    assert(size == sizeof(JVMCINMethodData), \"must agree\");\n+    size_t total_size = compute_size(nmethod_mirror_name);\n+    return (address)resource_allocate_bytes(total_size);\n+  }\n+\n@@ -69,0 +88,12 @@\n+  static JVMCINMethodData* create(int nmethod_mirror_index,\n+                                  int nmethod_entry_patch_offset,\n+                                  const char* nmethod_mirror_name,\n+                                  FailedSpeculation** failed_speculations) {\n+    JVMCINMethodData* result = new (nmethod_mirror_name) JVMCINMethodData();\n+    result->initialize(nmethod_mirror_index,\n+                       nmethod_entry_patch_offset,\n+                       nmethod_mirror_name,\n+                       failed_speculations);\n+    return result;\n+  }\n+\n@@ -78,3 +109,6 @@\n-  void initialize(int nmethod_mirror_index,\n-             const char* name,\n-             FailedSpeculation** failed_speculations);\n+  int size() {\n+    return compute_size(name());\n+  }\n+\n+  \/\/ Copy the contents of this object into data which is normally the storage allocated in the nmethod.\n+  void copy(JVMCINMethodData* data);\n@@ -97,0 +131,9 @@\n+\n+  bool has_entry_barrier() {\n+    return _nmethod_entry_patch_offset != -1;\n+  }\n+\n+  int nmethod_entry_patch_offset() {\n+    guarantee(_nmethod_entry_patch_offset != -1, \"missing entry barrier\");\n+    return _nmethod_entry_patch_offset;\n+  }\n@@ -417,1 +460,2 @@\n-                                           int                       speculations_len);\n+                                           int                       speculations_len,\n+                                           int                       nmethod_entry_patch_offset);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":55,"deletions":11,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  return UseSerialGC || UseParallelGC || UseG1GC;\n+  return UseSerialGC || UseParallelGC || UseG1GC || UseZGC;\n","filename":"src\/hotspot\/share\/jvmci\/jvmci_globals.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -59,0 +59,18 @@\n+  static_field(CompilerToVM::Data,             SharedRuntime_polling_page_return_handler,                                            \\\n+                                                                                       address)                                      \\\n+                                                                                                                                     \\\n+  static_field(CompilerToVM::Data,             nmethod_entry_barrier, address)                                                       \\\n+  static_field(CompilerToVM::Data,             thread_disarmed_guard_value_offset, int)                                              \\\n+  static_field(CompilerToVM::Data,             thread_address_bad_mask_offset, int)                                                  \\\n+  AARCH64_ONLY(static_field(CompilerToVM::Data, BarrierSetAssembler_nmethod_patching_type, int))                                     \\\n+                                                                                                                                     \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_load_barrier_on_oop_field_preloaded, address)                      \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_load_barrier_on_weak_oop_field_preloaded, address)                 \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_load_barrier_on_phantom_oop_field_preloaded, address)              \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_weak_load_barrier_on_oop_field_preloaded, address)                 \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_weak_load_barrier_on_weak_oop_field_preloaded, address)            \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_weak_load_barrier_on_phantom_oop_field_preloaded, address)         \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_load_barrier_on_oop_array, address)                                \\\n+  static_field(CompilerToVM::Data,             ZBarrierSetRuntime_clone, address)                                                    \\\n+                                                                                                                                     \\\n+  static_field(CompilerToVM::Data,             continuations_enabled, bool)                                                          \\\n@@ -187,0 +205,1 @@\n+  nonstatic_field(JavaThread,                  _saved_exception_pc,                           address)                               \\\n@@ -478,0 +497,1 @@\n+  declare_constant(CodeInstaller::ENTRY_BARRIER_PATCH)                    \\\n@@ -697,0 +717,4 @@\n+  AARCH64_ONLY(declare_constant(NMethodPatchingType::stw_instruction_and_data_patch))  \\\n+  AARCH64_ONLY(declare_constant(NMethodPatchingType::conc_instruction_and_data_patch)) \\\n+  AARCH64_ONLY(declare_constant(NMethodPatchingType::conc_data_patch))                 \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  template(jdk_vm_ci_hotspot_HotSpotMethodData,                   \"jdk\/vm\/ci\/hotspot\/HotSpotMethodData\")                                  \\\n@@ -84,1 +85,1 @@\n-  template(method_fromMetaspace_signature,                        \"(J)Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethod;\")                     \\\n+  template(method_fromMetaspace_signature,                        \"(JLjdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl;)Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethod;\") \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -397,0 +397,4 @@\n+#if INCLUDE_JVMCI\n+  static ByteSize subklass_offset()              { return in_ByteSize(offset_of(Klass, _subklass)); }\n+  static ByteSize next_sibling_offset()          { return in_ByteSize(offset_of(Klass, _next_sibling)); }\n+#endif\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1479,3 +1479,0 @@\n-      if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n-        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-      }\n@@ -1499,16 +1496,9 @@\n-  if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS && !UseCompressedOops) {\n-    if (UseCompressedClassPointers) {\n-      warning(\"UseCompressedClassPointers requires UseCompressedOops\");\n-    }\n-    FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-  } else {\n-    \/\/ Turn on UseCompressedClassPointers too\n-    if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {\n-      FLAG_SET_ERGO(UseCompressedClassPointers, true);\n-    }\n-    \/\/ Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.\n-    if (UseCompressedClassPointers) {\n-      if (CompressedClassSpaceSize > KlassEncodingMetaspaceMax) {\n-        warning(\"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n-        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n-      }\n+  \/\/ Turn on UseCompressedClassPointers too\n+  if (FLAG_IS_DEFAULT(UseCompressedClassPointers)) {\n+    FLAG_SET_ERGO(UseCompressedClassPointers, true);\n+  }\n+  \/\/ Check the CompressedClassSpaceSize to make sure we use compressed klass ptrs.\n+  if (UseCompressedClassPointers) {\n+    if (CompressedClassSpaceSize > KlassEncodingMetaspaceMax) {\n+      warning(\"CompressedClassSpaceSize is too large for UseCompressedClassPointers\");\n+      FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n@@ -1679,3 +1669,0 @@\n-          if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n-            FLAG_SET_ERGO(UseCompressedClassPointers, false);\n-          }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":9,"deletions":22,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -887,10 +887,11 @@\n-     * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This\n-     * method does no checking that the memory location actually contains a valid pointer and may\n-     * crash the VM if an invalid location is provided. If the {@code base} is null then\n-     * {@code displacement} is used by itself. If {@code base} is a\n-     * {@link HotSpotResolvedJavaMethodImpl}, {@link HotSpotConstantPool} or\n-     * {@link HotSpotResolvedObjectTypeImpl} then the metaspace pointer is fetched from that object\n-     * and added to {@code displacement}. Any other non-null object type causes an\n-     * {@link IllegalArgumentException} to be thrown.\n-     *\n-     * @param base an object to read from or null\n+     * {@code displacement} and return the {@link HotSpotResolvedObjectTypeImpl} wrapping it. This method\n+     * only performs the read if the memory location is known to contain a valid Klass*.  If\n+     * {@code base} is a {@link HotSpotConstantPool}, {@link HotSpotMethodData}, {@link HotSpotObjectConstantImpl},\n+     * or {@link HotSpotResolvedObjectTypeImpl} then the field\n+     * corresopnding to {@code displacement} is fetched using the appropriate HotSpot accessor. Any\n+     * other object type or an unexpected displacement causes an {@link IllegalArgumentException} to\n+     * be thrown.  The set of fields which can be read in this fashion corresponds to the {@link VMField}\n+     * with type {@code Klass*} that are described in the {@link HotSpotVMConfigStore#getFields()}.\n+     * Additionally several injected fields in {@link Class} are also handled.\n+     *\n+     * @param base an object to read from\n@@ -900,0 +901,1 @@\n+     * @throws NullPointerException if {@code base == null}\n@@ -903,1 +905,9 @@\n-    HotSpotResolvedObjectTypeImpl getResolvedJavaType(MetaspaceObject base, long displacement, boolean compressed) {\n+    HotSpotResolvedObjectTypeImpl getResolvedJavaType(HotSpotConstantPool base, long displacement) {\n+        return getResolvedJavaType0(base, displacement, false);\n+    }\n+\n+    HotSpotResolvedObjectTypeImpl getResolvedJavaType(HotSpotMethodData base, long displacement) {\n+        return getResolvedJavaType0(base, displacement, false);\n+    }\n+\n+    HotSpotResolvedObjectTypeImpl getResolvedJavaType(HotSpotResolvedObjectTypeImpl base, long displacement, boolean compressed) {\n@@ -935,0 +945,3 @@\n+\n+    native int methodDataExceptionSeen(long metaspaceMethodData, int bci);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -241,1 +241,1 @@\n-            holder = compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset, false);\n+            holder = compilerToVM().getResolvedJavaType(this, config().constantPoolHolderOffset);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-final class HotSpotMethodData {\n+final class HotSpotMethodData implements MetaspaceObject {\n@@ -177,0 +177,5 @@\n+    @Override\n+    public long getMetaspacePointer() {\n+        return methodDataPointer;\n+    }\n+\n@@ -200,0 +205,3 @@\n+    \/**\n+     * Return true if there is an extra data section and the first tag is non-zero.\n+     *\/\n@@ -201,1 +209,1 @@\n-        return extraDataSize() > 0;\n+        return extraDataSize() > 0 && HotSpotMethodDataAccessor.readTag(state.config, this, getExtraDataBeginOffset()) != 0;\n@@ -204,1 +212,1 @@\n-    public int getExtraDataBeginOffset() {\n+    private int getExtraDataBeginOffset() {\n@@ -209,1 +217,1 @@\n-        return position >= 0 && position < normalDataSize() + extraDataSize();\n+        return position >= 0 && position < normalDataSize();\n@@ -244,11 +252,0 @@\n-    public HotSpotMethodDataAccessor getExtraData(int position) {\n-        if (position >= normalDataSize() + extraDataSize()) {\n-            return null;\n-        }\n-        HotSpotMethodDataAccessor data = getData(position);\n-        if (data != null) {\n-            return data;\n-        }\n-        return data;\n-    }\n-\n@@ -311,1 +308,1 @@\n-        return compilerToVM().getResolvedJavaType(methodDataPointer + fullOffsetInBytes);\n+        return compilerToVM().getResolvedJavaType(this, fullOffsetInBytes);\n@@ -347,14 +344,0 @@\n-        if (hasExtraData()) {\n-            int pos = getExtraDataBeginOffset();\n-            HotSpotMethodDataAccessor data;\n-            while ((data = getExtraData(pos)) != null) {\n-                if (pos == getExtraDataBeginOffset()) {\n-                    sb.append(nl).append(\"--- Extra data:\");\n-                }\n-                int bci = data.getBCI(this, pos);\n-                sb.append(String.format(\"%n%-6d bci: %-6d%-20s\", pos, bci, data.getClass().getSimpleName()));\n-                sb.append(data.appendTo(new StringBuilder(), this, pos).toString().replace(nl, nlIndent));\n-                pos = pos + data.getSize(this, pos);\n-            }\n-\n-        }\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotMethodData.java","additions":13,"deletions":30,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -25,0 +25,2 @@\n+import static jdk.vm.ci.hotspot.CompilerToVM.compilerToVM;\n+\n@@ -80,1 +82,1 @@\n-        findBCI(bci, false);\n+        findBCI(bci);\n@@ -89,1 +91,1 @@\n-        findBCI(bci, false);\n+        findBCI(bci);\n@@ -98,1 +100,1 @@\n-        findBCI(bci, false);\n+        findBCI(bci);\n@@ -107,1 +109,1 @@\n-        findBCI(bci, false);\n+        findBCI(bci);\n@@ -113,1 +115,9 @@\n-        findBCI(bci, true);\n+        if (!findBCI(bci)) {\n+            \/\/ There might data in the extra data section but all accesses to that memory must be\n+            \/\/ under a lock so go into VM to get the data.\n+            int exceptionSeen = compilerToVM().methodDataExceptionSeen(methodData.methodDataPointer, bci);\n+            if (exceptionSeen == -1) {\n+                return TriState.UNKNOWN;\n+            }\n+            return TriState.get(exceptionSeen != 0);\n+        }\n@@ -119,1 +129,1 @@\n-        findBCI(bci, false);\n+        findBCI(bci);\n@@ -128,1 +138,1 @@\n-        findBCI(bci, false);\n+        findBCI(bci);\n@@ -144,1 +154,1 @@\n-    private void findBCI(int targetBCI, boolean searchExtraData) {\n+    private boolean findBCI(int targetBCI) {\n@@ -154,1 +164,1 @@\n-                    return;\n+                    return true;\n@@ -161,20 +171,2 @@\n-\n-        boolean exceptionPossiblyNotRecorded = false;\n-        if (searchExtraData && methodData.hasExtraData()) {\n-            int currentPosition = methodData.getExtraDataBeginOffset();\n-            HotSpotMethodDataAccessor currentAccessor;\n-            while ((currentAccessor = methodData.getExtraData(currentPosition)) != null) {\n-                int currentBCI = currentAccessor.getBCI(methodData, currentPosition);\n-                if (currentBCI == targetBCI) {\n-                    extraDataFound(currentAccessor, currentPosition);\n-                    return;\n-                }\n-                currentPosition = currentPosition + currentAccessor.getSize(methodData, currentPosition);\n-            }\n-\n-            if (!methodData.isWithin(currentPosition)) {\n-                exceptionPossiblyNotRecorded = true;\n-            }\n-        }\n-\n-        noDataFound(exceptionPossiblyNotRecorded);\n+        noDataFound(false);\n+        return false;\n@@ -189,4 +181,0 @@\n-    private void extraDataFound(HotSpotMethodDataAccessor data, int pos) {\n-        setCurrentData(data, pos);\n-    }\n-\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotProfilingInfo.java","additions":21,"deletions":33,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -88,16 +88,0 @@\n-    \/**\n-     * Gets the holder of a HotSpot metaspace method native object.\n-     *\n-     * @param metaspaceHandle a handle to a metaspace Method object\n-     * @return the {@link ResolvedJavaType} corresponding to the holder of the\n-     *         {@code metaspaceMethod}\n-     *\/\n-    private static HotSpotResolvedObjectTypeImpl getHolder(long metaspaceHandle) {\n-        HotSpotVMConfig config = config();\n-        long methodPointer = UNSAFE.getLong(metaspaceHandle);\n-        assert methodPointer != 0 : metaspaceHandle;\n-        final long constMethodPointer = UNSAFE.getAddress(methodPointer + config.methodConstMethodOffset);\n-        final long constantPoolPointer = UNSAFE.getAddress(constMethodPointer + config.constMethodConstantsOffset);\n-        return Objects.requireNonNull(compilerToVM().getResolvedJavaType(constantPoolPointer + config.constantPoolHolderOffset));\n-    }\n-\n@@ -116,2 +100,1 @@\n-    private static HotSpotResolvedJavaMethod fromMetaspace(long metaspaceHandle) {\n-        HotSpotResolvedObjectTypeImpl holder = getHolder(metaspaceHandle);\n+    private static HotSpotResolvedJavaMethod fromMetaspace(long metaspaceHandle, HotSpotResolvedObjectTypeImpl holder) {\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaMethodImpl.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -233,1 +233,4 @@\n-                if (subklass == null || UNSAFE.getAddress(subklass.getKlassPointer() + config.nextSiblingOffset) != 0) {\n+                if (subklass == null) {\n+                    return null;\n+                }\n+                if (compilerToVM().getResolvedJavaType(subklass, config.nextSiblingOffset, false) != null) {\n@@ -265,1 +268,1 @@\n-        return UNSAFE.getLong(this.getKlassPointer() + config().subklassOffset) == 0;\n+        return compilerToVM().getResolvedJavaType(this, config().subklassOffset, false) == null;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -307,5 +307,0 @@\n-    public static HotSpotResolvedObjectType getResolvedJavaType(MetaspaceObject base,\n-            long displacement, boolean compressed) {\n-        return CTVM.getResolvedJavaType(base, displacement, compressed);\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/CompilerToVMHelper.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-                        finishedDataPatches, false, frameSize, deoptRescue, method, 0, id, 0L, false);\n+                        finishedDataPatches, false, frameSize, deoptRescue, method, -1, id, 0L, false);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/TestAssembler.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * These tests are explicitly testing the profiling behavior of the\n+ * interpreter. C1-based profiling differs slightly and when -Xcomp\n+ * is present, profiles will be created by C1 compiled code, not the\n+ * interpreter.\n+ *\n+ * @test\n+ * @requires vm.jvmci\n+ * @requires vm.compMode != \"Xcomp\"\n+ * @modules jdk.internal.vm.ci\/jdk.vm.ci.meta\n+ *          jdk.internal.vm.ci\/jdk.vm.ci.runtime\n+ * @run junit\/othervm -XX:+UnlockExperimentalVMOptions -XX:+EnableJVMCI -XX:-UseJVMCICompiler -Xbootclasspath\/a:. compiler.jvmci.meta.ProfilingInfoTest\n+ *\/\n+package compiler.jvmci.meta;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Executable;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Test;\n+\n+import jdk.vm.ci.meta.JavaTypeProfile;\n+import jdk.vm.ci.meta.MetaAccessProvider;\n+import jdk.vm.ci.meta.ProfilingInfo;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+import jdk.vm.ci.meta.TriState;\n+import jdk.vm.ci.runtime.JVMCI;\n+\n+\/**\n+ * Tests profiling information provided by the runtime.\n+ * <p>\n+ * NOTE: These tests are actually not very robust. The problem is that only partial profiling\n+ * information may be gathered for any given method. For example, HotSpot's advanced compilation\n+ * policy can decide to only gather partial profiles in a first level compilation (see\n+ * AdvancedThresholdPolicy::common(...) in advancedThresholdPolicy.cpp). Because of this,\n+ * occasionally tests for {@link ProfilingInfo#getNullSeen(int)} can fail since HotSpot only sets\n+ * the null_seen bit when doing full profiling.\n+ *\/\n+public class ProfilingInfoTest {\n+\n+    private static final int N = 10;\n+    private static final double DELTA = 1d \/ Integer.MAX_VALUE;\n+\n+    @Test\n+    public void testBranchTakenProbability() {\n+        ProfilingInfo info = profile(\"branchProbabilitySnippet\", 0);\n+        Assert.assertEquals(0.0, info.getBranchTakenProbability(1), DELTA);\n+        Assert.assertEquals(N, info.getExecutionCount(1));\n+        Assert.assertEquals(-1.0, info.getBranchTakenProbability(8), DELTA);\n+        Assert.assertEquals(0, info.getExecutionCount(8));\n+\n+        info = profile(\"branchProbabilitySnippet\", 1);\n+        Assert.assertEquals(1.0, info.getBranchTakenProbability(1), DELTA);\n+        Assert.assertEquals(N, info.getExecutionCount(1));\n+        Assert.assertEquals(0.0, info.getBranchTakenProbability(8), DELTA);\n+        Assert.assertEquals(N, info.getExecutionCount(8));\n+\n+        info = profile(\"branchProbabilitySnippet\", 2);\n+        Assert.assertEquals(1.0, info.getBranchTakenProbability(1), DELTA);\n+        Assert.assertEquals(N, info.getExecutionCount(1));\n+        Assert.assertEquals(1.0, info.getBranchTakenProbability(8), DELTA);\n+        Assert.assertEquals(N, info.getExecutionCount(8));\n+\n+        continueProfiling(3 * N, \"branchProbabilitySnippet\", 0);\n+        Assert.assertEquals(0.25, info.getBranchTakenProbability(1), DELTA);\n+        Assert.assertEquals(4 * N, info.getExecutionCount(1));\n+        Assert.assertEquals(1.0, info.getBranchTakenProbability(8), DELTA);\n+        Assert.assertEquals(N, info.getExecutionCount(8));\n+\n+        resetProfile(\"branchProbabilitySnippet\");\n+        Assert.assertEquals(-1.0, info.getBranchTakenProbability(1), DELTA);\n+        Assert.assertEquals(0, info.getExecutionCount(1));\n+        Assert.assertEquals(-1.0, info.getBranchTakenProbability(8), DELTA);\n+        Assert.assertEquals(0, info.getExecutionCount(8));\n+    }\n+\n+    public static int branchProbabilitySnippet(int value) {\n+        if (value == 0) {\n+            return -1;\n+        } else if (value == 1) {\n+            return -2;\n+        } else {\n+            return -3;\n+        }\n+    }\n+\n+    @Test\n+    public void testSwitchProbabilities() {\n+        ProfilingInfo info = profile(\"switchProbabilitySnippet\", 0);\n+        Assert.assertArrayEquals(new double[]{1.0, 0.0, 0.0}, info.getSwitchProbabilities(1), DELTA);\n+\n+        info = profile(\"switchProbabilitySnippet\", 1);\n+        Assert.assertArrayEquals(new double[]{0.0, 1.0, 0.0}, info.getSwitchProbabilities(1), DELTA);\n+\n+        info = profile(\"switchProbabilitySnippet\", 2);\n+        Assert.assertArrayEquals(new double[]{0.0, 0.0, 1.0}, info.getSwitchProbabilities(1), DELTA);\n+\n+        resetProfile(\"switchProbabilitySnippet\");\n+        Assert.assertNull(info.getSwitchProbabilities(1));\n+    }\n+\n+    public static int switchProbabilitySnippet(int value) {\n+        switch (value) {\n+            case 0:\n+                return -1;\n+            case 1:\n+                return -2;\n+            default:\n+                return -3;\n+        }\n+    }\n+\n+    @Test\n+    public void testProfileInvokeVirtual() {\n+        testTypeProfile(\"invokeVirtualSnippet\", 1);\n+    }\n+\n+    public static int invokeVirtualSnippet(Object obj) {\n+        return obj.hashCode();\n+    }\n+\n+    @Test\n+    public void testTypeProfileInvokeInterface() {\n+        testTypeProfile(\"invokeInterfaceSnippet\", 1);\n+    }\n+\n+    public static int invokeInterfaceSnippet(CharSequence a) {\n+        return a.length();\n+    }\n+\n+    @Test\n+    public void testTypeProfileCheckCast() {\n+        testTypeProfile(\"checkCastSnippet\", 1);\n+    }\n+\n+    public static Serializable checkCastSnippet(Object obj) {\n+        try {\n+            return (Serializable) obj;\n+        } catch (ClassCastException e) {\n+            return null;\n+        }\n+    }\n+\n+    @Test\n+    public void testTypeProfileInstanceOf() {\n+        testTypeProfile(\"instanceOfSnippet\", 1);\n+    }\n+\n+    public static boolean instanceOfSnippet(Object obj) {\n+        return obj instanceof Serializable;\n+    }\n+\n+    private void testTypeProfile(String testSnippet, int bci) {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaType stringType = metaAccess.lookupJavaType(String.class);\n+        ResolvedJavaType stringBuilderType = metaAccess.lookupJavaType(StringBuilder.class);\n+\n+        ProfilingInfo info = profile(testSnippet, \"ABC\");\n+        JavaTypeProfile typeProfile = info.getTypeProfile(bci);\n+        Assert.assertEquals(0.0, typeProfile.getNotRecordedProbability(), DELTA);\n+        Assert.assertEquals(1, typeProfile.getTypes().length);\n+        Assert.assertEquals(stringType, typeProfile.getTypes()[0].getType());\n+        Assert.assertEquals(1.0, typeProfile.getTypes()[0].getProbability(), DELTA);\n+\n+        continueProfiling(testSnippet, new StringBuilder());\n+        typeProfile = info.getTypeProfile(bci);\n+        Assert.assertEquals(0.0, typeProfile.getNotRecordedProbability(), DELTA);\n+        Assert.assertEquals(2, typeProfile.getTypes().length);\n+        Assert.assertEquals(stringType, typeProfile.getTypes()[0].getType());\n+        Assert.assertEquals(stringBuilderType, typeProfile.getTypes()[1].getType());\n+        Assert.assertEquals(0.5, typeProfile.getTypes()[0].getProbability(), DELTA);\n+        Assert.assertEquals(0.5, typeProfile.getTypes()[1].getProbability(), DELTA);\n+\n+        resetProfile(testSnippet);\n+        typeProfile = info.getTypeProfile(bci);\n+        Assert.assertNull(typeProfile);\n+    }\n+\n+    public ProfilingInfoTest() {\n+    }\n+\n+    @Test\n+    public void testExceptionSeen() {\n+        \/\/ NullPointerException\n+        ProfilingInfo info = profile(\"nullPointerExceptionSnippet\", 5);\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(1));\n+\n+        info = profile(\"nullPointerExceptionSnippet\", (Object) null);\n+        Assert.assertEquals(TriState.TRUE, info.getExceptionSeen(1));\n+\n+        resetProfile(\"nullPointerExceptionSnippet\");\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(1));\n+\n+        \/\/ ArrayOutOfBoundsException\n+        info = profile(\"arrayIndexOutOfBoundsExceptionSnippet\", new int[1]);\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(2));\n+\n+        info = profile(\"arrayIndexOutOfBoundsExceptionSnippet\", new int[0]);\n+        Assert.assertEquals(TriState.TRUE, info.getExceptionSeen(2));\n+\n+        resetProfile(\"arrayIndexOutOfBoundsExceptionSnippet\");\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(2));\n+\n+        \/\/ CheckCastException\n+        info = profile(\"checkCastExceptionSnippet\", \"ABC\");\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(1));\n+\n+        info = profile(\"checkCastExceptionSnippet\", 5);\n+        Assert.assertEquals(TriState.TRUE, info.getExceptionSeen(1));\n+\n+        resetProfile(\"checkCastExceptionSnippet\");\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(1));\n+\n+        \/\/ Invoke with exception\n+        info = profile(\"invokeWithExceptionSnippet\", false);\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(1));\n+\n+        info = profile(\"invokeWithExceptionSnippet\", true);\n+        Assert.assertEquals(TriState.TRUE, info.getExceptionSeen(1));\n+\n+        resetProfile(\"invokeWithExceptionSnippet\");\n+        Assert.assertEquals(TriState.FALSE, info.getExceptionSeen(1));\n+    }\n+\n+    public static int nullPointerExceptionSnippet(Object obj) {\n+        try {\n+            return obj.hashCode();\n+        } catch (NullPointerException e) {\n+            return 1;\n+        }\n+    }\n+\n+    public static int arrayIndexOutOfBoundsExceptionSnippet(int[] array) {\n+        try {\n+            return array[0];\n+        } catch (ArrayIndexOutOfBoundsException e) {\n+            return 1;\n+        }\n+    }\n+\n+    public static int checkCastExceptionSnippet(Object obj) {\n+        try {\n+            return ((String) obj).length();\n+        } catch (ClassCastException e) {\n+            return 1;\n+        }\n+    }\n+\n+    public static int invokeWithExceptionSnippet(boolean doThrow) {\n+        try {\n+            return throwException(doThrow);\n+        } catch (IllegalArgumentException e) {\n+            return 1;\n+        }\n+    }\n+\n+    private static int throwException(boolean doThrow) {\n+        if (doThrow) {\n+            throw new IllegalArgumentException();\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    @Test\n+    public void testNullSeen() {\n+        testNullSeen(\"instanceOfSnippet\");\n+        testNullSeen(\"checkCastSnippet\");\n+    }\n+\n+    private void testNullSeen(String snippet) {\n+        ProfilingInfo info = profile(snippet, 1);\n+        Assert.assertEquals(TriState.FALSE, info.getNullSeen(1));\n+\n+        continueProfiling(snippet, \"ABC\");\n+        Assert.assertEquals(TriState.FALSE, info.getNullSeen(1));\n+\n+        continueProfiling(snippet, new Object());\n+        Assert.assertEquals(TriState.FALSE, info.getNullSeen(1));\n+\n+        if (TriState.TRUE == info.getNullSeen(1)) {\n+            \/\/ See the javadoc comment for ProfilingInfoTest.\n+            continueProfiling(snippet, (Object) null);\n+            Assert.assertEquals(TriState.TRUE, info.getNullSeen(1));\n+\n+            continueProfiling(snippet, 0.0);\n+            Assert.assertEquals(TriState.TRUE, info.getNullSeen(1));\n+\n+            continueProfiling(snippet, new Object());\n+            Assert.assertEquals(TriState.TRUE, info.getNullSeen(1));\n+        }\n+\n+        resetProfile(snippet);\n+        Assert.assertEquals(TriState.FALSE, info.getNullSeen(1));\n+    }\n+\n+    private ProfilingInfo profile(String methodName, Object... args) {\n+        return profile(true, N, methodName, args);\n+    }\n+\n+    private void continueProfiling(String methodName, Object... args) {\n+        profile(false, N, methodName, args);\n+    }\n+\n+    private void continueProfiling(int executions, String methodName, Object... args) {\n+        profile(false, executions, methodName, args);\n+    }\n+\n+    private ProfilingInfo profile(boolean resetProfile, int executions, String methodName, Object... args) {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        Method method = getMethod(methodName);\n+        ResolvedJavaMethod javaMethod = metaAccess.lookupJavaMethod(method);\n+        Assert.assertTrue(javaMethod.isStatic());\n+        if (resetProfile) {\n+            javaMethod.reprofile();\n+        }\n+\n+        for (int i = 0; i < executions; ++i) {\n+            try {\n+                method.invoke(null, args);\n+            } catch (Throwable e) {\n+                Assert.fail(\"method should not throw an exception: \" + e.toString());\n+            }\n+        }\n+\n+        ProfilingInfo info = javaMethod.getProfilingInfo();\n+        \/\/ The execution counts are low so force maturity\n+        info.setMature();\n+        return info;\n+    }\n+\n+    static Method getMethod(String methodName) {\n+        for (Method method : ProfilingInfoTest.class.getDeclaredMethods()) {\n+            if (method.getName().equals(methodName)) {\n+                return method;\n+            }\n+        }\n+        throw new IllegalArgumentException();\n+    }\n+\n+    private void resetProfile(String methodName) {\n+        MetaAccessProvider metaAccess = JVMCI.getRuntime().getHostJVMCIBackend().getMetaAccess();\n+        ResolvedJavaMethod javaMethod = metaAccess.lookupJavaMethod(getMethod(methodName));\n+        javaMethod.reprofile();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/meta\/ProfilingInfoTest.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"}]}