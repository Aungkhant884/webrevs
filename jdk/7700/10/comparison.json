{"files":[{"patch":"@@ -2965,0 +2965,284 @@\n+int C2_MacroAssembler::arrays_hashcode_elsize(BasicType eltype) {\n+  switch (eltype) {\n+  case T_BYTE:  return sizeof(jbyte);\n+  case T_SHORT: return sizeof(jshort);\n+  case T_CHAR:  return sizeof(jchar);\n+  case T_INT:   return sizeof(jint);\n+  case T_FLOAT: return sizeof(jfloat);\n+  default:\n+    ShouldNotReachHere();\n+    return -1;\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elload(Register dst, Address src, BasicType eltype) {\n+  switch (eltype) {\n+  case T_BYTE:\n+    movzbl(dst, src);\n+    break;\n+  case T_SHORT:\n+  case T_CHAR:\n+    movzwl(dst, src);\n+    break;\n+  case T_INT:\n+  case T_FLOAT:\n+    movl(dst, src);\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype) {\n+  load_vector(dst, src, arrays_hashcode_elsize(eltype) * 8);\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype) {\n+  switch (eltype) {\n+  case T_BYTE:\n+    vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_BYTE, T_INT);\n+    break;\n+  case T_SHORT:\n+  case T_CHAR:\n+    vector_unsigned_cast(dst, dst, Assembler::AVX_256bit, T_SHORT, T_INT);\n+    break;\n+  case T_INT:\n+  case T_FLOAT:\n+    \/\/ do nothing\n+    break;\n+  default:\n+    ShouldNotReachHere();\n+  }\n+}\n+\n+void C2_MacroAssembler::arrays_hashcode(Register ary1, Register cnt1, Register result,\n+                                        Register i, Register coef, Register tmp, XMMRegister vnext,\n+                                        XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                                        XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                                        XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                                        BasicType eltype, bool is_string_hashcode) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseAVX >= 2, \"AVX2 intrinsics are required\");\n+\n+  Label SHORT, SHORT_UNROLLED_LOOP_BEGIN, SHORT_UNROLLED_LOOP_END, SHORT_SCALAR_LOOP_BEGIN, SHORT_SCALAR_LOOP_END,\n+        LONG, LONG_INIT, LONG_SCALAR_LOOP_BEGIN, LONG_SCALAR_LOOP_END, LONG_VECTOR_LOOP_BEGIN, LONG_VECTOR_LOOP_END,\n+        NONNULL, END;\n+\n+  \/\/ For \"renaming\" for readibility of the code\n+  Register bound;\n+\n+  XMMRegister vcoef[] = { vcoef0, vcoef1, vcoef2, vcoef3 },\n+              vresult[] = { vresult0, vresult1, vresult2, vresult3 },\n+              vtmp[] = { vtmp0, vtmp1, vtmp2, vtmp3 };\n+\n+  const int elsize = arrays_hashcode_elsize(eltype);\n+\n+  int length_offset  = arrayOopDesc::length_offset_in_bytes();\n+  int base_offset    = arrayOopDesc::base_offset_in_bytes(eltype);\n+\n+  if (!is_string_hashcode) {\n+    testptr(ary1, ary1);\n+    jcc(Assembler::notZero, NONNULL);\n+    movl(result, 0);\n+    jmp(END);\n+    bind(NONNULL);\n+    movl(cnt1, Address(ary1, length_offset));\n+    lea(ary1, Address(ary1, base_offset));\n+  }\n+\n+  \/\/ int result = 0|1;\n+  movl(result, is_string_hashcode ? 0 : 1);\n+\n+  \/\/ if (cnt1 == 0) {\n+  cmpl(cnt1, 0);\n+  jcc(Assembler::equal, END);\n+\n+  \/\/ cnt1 \/= elsize\n+  shrl(cnt1, Address::times(elsize));\n+\n+  \/\/ } else if (cnt1 < 32) {\n+  bind(SHORT);\n+  cmpl(cnt1, 32);\n+  jcc(Assembler::greaterEqual, LONG);\n+\n+  \/\/ int i = 0;\n+  movl(i, 0);\n+  \/\/ int bound = cnt1 & ~(4 - 1);\n+  bound = coef;\n+  movl(bound, cnt1);\n+  andl(bound, ~(4-1));\n+\n+  \/\/ for (; i < bound; i += 4) {\n+  bind(SHORT_UNROLLED_LOOP_BEGIN);\n+  \/\/ i < bound;\n+  cmpl(i, bound);\n+  jcc(Assembler::greaterEqual, SHORT_UNROLLED_LOOP_END);\n+  for (int idx = 0; idx < 4; idx++) {\n+    \/\/ h = h << 5 - 31;\n+    movl(tmp, result);\n+    shll(result, 5);\n+    subl(result, tmp);\n+    \/\/ h += ary1[i];\n+    arrays_hashcode_elload(tmp, Address(ary1, i, Address::times(elsize), idx*elsize), eltype);\n+    addl(result, tmp);\n+  }\n+  addl(i, 4);\n+  jmp(SHORT_UNROLLED_LOOP_BEGIN);\n+  bind(SHORT_UNROLLED_LOOP_END);\n+  \/\/ }\n+\n+  \/\/ for (; i < cnt1; i += 1) {\n+  bind(SHORT_SCALAR_LOOP_BEGIN);\n+  \/\/ i < cnt1;\n+  cmpl(i, cnt1);\n+  jcc(Assembler::greaterEqual, SHORT_SCALAR_LOOP_END);\n+  \/\/ h = h << 5 - 31;\n+  movl(tmp, result);\n+  shll(result, 5);\n+  subl(result, tmp);\n+  \/\/ h += ary1[i];\n+  arrays_hashcode_elload(tmp, Address(ary1, i, Address::times(elsize)), eltype);\n+  addl(result, tmp);\n+  \/\/ i += 1;\n+  addl(i, 1);\n+  jmp(SHORT_SCALAR_LOOP_BEGIN);\n+  bind(SHORT_SCALAR_LOOP_END);\n+  \/\/ }\n+\n+  jmp(END);\n+\n+  \/\/ } else { \/\/ cnt1 >= 32\n+  bind(LONG);\n+\n+  jmp(LONG_INIT);\n+  address power_of_31_backwards = pc();\n+  emit_int32( 2111290369);\n+  emit_int32(-2010103841);\n+  emit_int32(  350799937);\n+  emit_int32(   11316127);\n+  emit_int32(  693101697);\n+  emit_int32( -254736545);\n+  emit_int32(  961614017);\n+  emit_int32(   31019807);\n+  emit_int32(-2077209343);\n+  emit_int32(  -67006753);\n+  emit_int32( 1244764481);\n+  emit_int32(-2038056289);\n+  emit_int32(  211350913);\n+  emit_int32( -408824225);\n+  emit_int32( -844471871);\n+  emit_int32( -997072353);\n+  emit_int32( 1353309697);\n+  emit_int32( -510534177);\n+  emit_int32( 1507551809);\n+  emit_int32( -505558625);\n+  emit_int32( -293403007);\n+  emit_int32(  129082719);\n+  emit_int32(-1796951359);\n+  emit_int32( -196513505);\n+  emit_int32(-1807454463);\n+  emit_int32( 1742810335);\n+  emit_int32(  887503681);\n+  emit_int32(   28629151);\n+  emit_int32(     923521);\n+  emit_int32(      29791);\n+  emit_int32(        961);\n+  emit_int32(         31);\n+  emit_int32(          1);\n+  bind(LONG_INIT);\n+\n+  \/\/ int coef = 1;\n+  movl(coef, 1);\n+  \/\/ int i = cnt1 - 1;\n+  movl(i, cnt1);\n+  subl(i, 1);\n+  \/\/ bound = cnt1 - (cnt1 & (32-1));\n+  bound = cnt1;\n+  movl(tmp, cnt1);\n+  andl(tmp, 32-1);\n+  subl(bound, tmp);\n+\n+  \/\/ for (; i >= bound; i -= 1) {\n+  bind(LONG_SCALAR_LOOP_BEGIN);\n+  \/\/ i >= bound;\n+  cmpl(i, bound);\n+  jcc(Assembler::less, LONG_SCALAR_LOOP_END);\n+  \/\/ result += coef * ary1[i];\n+  arrays_hashcode_elload(tmp, Address(ary1, i, Address::times(elsize)), eltype);\n+  imull(tmp, coef);\n+  addl(result, tmp);\n+  \/\/ coef *= 31;\n+  movl(tmp, 31);\n+  imull(coef, tmp);\n+  \/\/ i -= 1;\n+  subl(i, 1);\n+  jmp(LONG_SCALAR_LOOP_BEGIN);\n+  bind(LONG_SCALAR_LOOP_END);\n+  \/\/ }\n+\n+  movl(tmp, 0);\n+  for (int idx = 0; idx < 4; idx++) {\n+    \/\/ vresult = IntVector.zero(I256);\n+    movdl(vresult[idx], tmp);\n+    vpbroadcastd(vresult[idx], vresult[idx], Assembler::AVX_256bit);\n+  }\n+  \/\/ vnext = IntVector.broadcast(I256, power_of_31_backwards[0]);\n+  lea(tmp, InternalAddress(power_of_31_backwards+(0*sizeof(jint))));\n+  movdl(vnext, tmp);\n+  vpbroadcastd(vnext, vnext, Assembler::AVX_256bit);\n+  \/\/ vcoef = IntVector.fromArray(I256, power_of_31_backwards, 1);\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vcoef[idx], InternalAddress(power_of_31_backwards+((8*idx+1)*sizeof(jint))), T_INT);\n+  }\n+  \/\/ vcoef *= coef\n+  movdl(vtmp0, coef);\n+  vpbroadcastd(vtmp0, vtmp0, Assembler::AVX_256bit);\n+  for (int idx = 0; idx < 4; idx++) {\n+    vpmulld(vcoef[idx], vcoef[idx], vtmp0, Assembler::AVX_256bit);\n+  }\n+\n+  \/\/ for (i &= ~(32-1); i >= 0; i -= 32) {\n+  \/\/ i &= ~(32-1);\n+  andl(i, ~(32-1));\n+  bind(LONG_VECTOR_LOOP_BEGIN);\n+  \/\/ i >= 0;\n+  cmpl(i, 0);\n+  jcc(Assembler::less, LONG_VECTOR_LOOP_END);\n+  \/\/ loop fission to upfront the cost of fetching from memory, OOO execution\n+  \/\/ can then hopefully do a better job of prefetching\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvload(vtmp[idx], Address(ary1, i, Address::times(elsize), 8*idx*elsize), eltype);\n+  }\n+  \/\/ vresult += vcoef * ary1[i+8*idx:i+8*idx+7]; vcoef *= vnext;\n+  for (int idx = 0; idx < 4; idx++) {\n+    arrays_hashcode_elvcast(vtmp[idx], eltype);\n+    vpmulld(vtmp[idx], vtmp[idx], vcoef[idx], Assembler::AVX_256bit);\n+    vpaddd(vresult[idx], vresult[idx], vtmp[idx], Assembler::AVX_256bit);\n+    vpmulld(vcoef[idx], vcoef[idx], vnext, Assembler::AVX_256bit);\n+  }\n+  \/\/ i -= 32;\n+  subl(i, 32);\n+  jmp(LONG_VECTOR_LOOP_BEGIN);\n+  bind(LONG_VECTOR_LOOP_END);\n+  \/\/ }\n+\n+  if (!is_string_hashcode) {\n+    \/\/ result = vcoef0[0];\n+    movdl(result, vcoef0);\n+  }\n+\n+  \/\/ result += vresult.reduceLanes(ADD);\n+  for (int idx = 0; idx < 4; idx++) {\n+    reduceI(Op_AddReductionVI, 256\/(sizeof(jint)*8), result, result, vresult[idx], vtmp[(idx*2+0)%4], vtmp[(idx*2+1)%4]);\n+  }\n+\n+  \/\/ }\n+\n+  bind(END);\n+\n+} \/\/ arrays_hashcode\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":284,"deletions":0,"binary":false,"changes":284,"status":"modified"},{"patch":"@@ -279,0 +279,14 @@\n+  void arrays_hashcode(Register str1, Register cnt1, Register result,\n+                       Register i, Register coef, Register tmp, XMMRegister vnext,\n+                       XMMRegister vcoef0, XMMRegister vcoef1, XMMRegister vcoef2, XMMRegister vcoef3,\n+                       XMMRegister vresult0, XMMRegister vresult1, XMMRegister vresult2, XMMRegister vresult3,\n+                       XMMRegister vtmp0, XMMRegister vtmp1, XMMRegister vtmp2, XMMRegister vtmp3,\n+                       BasicType eltype, bool is_string_hashcode);\n+\n+  \/\/ helper functions for arrays_hashcode\n+  int arrays_hashcode_elsize(BasicType eltype);\n+  void arrays_hashcode_elload(Register dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, Address src, BasicType eltype);\n+  void arrays_hashcode_elvload(XMMRegister dst, AddressLiteral src, BasicType eltype);\n+  void arrays_hashcode_elvcast(XMMRegister dst, BasicType eltype);\n+\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1505,0 +1505,5 @@\n+    case Op_StrHashCode:\n+      if (!UseSSE42Intrinsics) {\n+        return false;\n+      }\n+      break;\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -308,1 +308,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDX int register\n@@ -311,1 +311,1 @@\n-\/\/ Singleton class for RCX int register\n+\/\/ Singleton class for RDI int register\n@@ -314,0 +314,3 @@\n+\/\/ Singleton class for RSI int register\n+reg_class int_rsi_reg(RSI);\n+\n@@ -3496,0 +3499,10 @@\n+operand rsi_RegI()\n+%{\n+  constraint(ALLOC_IN_RC(int_rsi_reg));\n+  match(RegI);\n+  match(rRegI);\n+\n+  format %{ \"RSI\" %}\n+  interface(REG_INTER);\n+%}\n+\n@@ -11753,0 +11766,53 @@\n+\/\/ fast string hashCode\n+instruct string_hashcodeL(rdi_RegP str1, rsi_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3,\n+                          rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((StrHashCodeNode*)n)->encoding() == StrIntrinsicNode::LL));\n+  match(Set result (StrHashCode (Binary str1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL str1, USE_KILL cnt1, KILL cr);\n+\n+  format %{ \"String HashCode byte[] $str1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($str1$$Register, $cnt1$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                      $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                      $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                      $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                      $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                      $tmp_vec13$$XMMRegister, T_BYTE, true);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct string_hashcodeU(rdi_RegP str1, rsi_RegI cnt1, rbx_RegI result,\n+                          legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                          legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                          legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                          legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3,\n+                          rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((StrHashCodeNode*)n)->encoding() == StrIntrinsicNode::UU));\n+  match(Set result (StrHashCode (Binary str1 cnt1)));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL str1, USE_KILL cnt1, KILL cr);\n+\n+  format %{ \"String HashCode char[] $str1,$cnt1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($str1$$Register, $cnt1$$Register, $result$$Register,\n+                      $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                      $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                      $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                      $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                      $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                      $tmp_vec13$$XMMRegister, T_CHAR, true);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n@@ -11818,0 +11884,130 @@\n+instruct array_hashcodeI(rdi_RegP ary1, rax_RegI result,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rRegI tmp4,\n+                         rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((AryHashCodeNode*)n)->type() == T_INT));\n+  match(Set result (AryHashCode ary1));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL ary1, KILL cr);\n+\n+  format %{ \"Array HashCode int[] $ary1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $tmp4$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, T_INT, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_hashcodeS(rdi_RegP ary1, rax_RegI result,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rRegI tmp4,\n+                         rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((AryHashCodeNode*)n)->type() == T_SHORT));\n+  match(Set result (AryHashCode ary1));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL ary1, KILL cr);\n+\n+  format %{ \"Array HashCode short[] $ary1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $tmp4$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, T_SHORT, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_hashcodeC(rdi_RegP ary1, rax_RegI result,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rRegI tmp4,\n+                         rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((AryHashCodeNode*)n)->type() == T_CHAR));\n+  match(Set result (AryHashCode ary1));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL ary1, KILL cr);\n+\n+  format %{ \"Array HashCode char[] $ary1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $tmp4$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, T_CHAR, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_hashcodeB(rdi_RegP ary1, rax_RegI result,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rRegI tmp4,\n+                         rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((AryHashCodeNode*)n)->type() == T_BYTE));\n+  match(Set result (AryHashCode ary1));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL ary1, KILL cr);\n+\n+  format %{ \"Array HashCode byte[] $ary1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $tmp4$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, T_BYTE, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n+instruct array_hashcodeF(rdi_RegP ary1, rax_RegI result,\n+                         legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, legRegD tmp_vec4,\n+                         legRegD tmp_vec5, legRegD tmp_vec6, legRegD tmp_vec7, legRegD tmp_vec8,\n+                         legRegD tmp_vec9, legRegD tmp_vec10, legRegD tmp_vec11, legRegD tmp_vec12,\n+                         legRegD tmp_vec13, rRegI tmp1, rRegI tmp2, rRegI tmp3, rRegI tmp4,\n+                         rFlagsReg cr)\n+%{\n+  predicate(UseAVX >= 2 && (((AryHashCodeNode*)n)->type() == T_FLOAT));\n+  match(Set result (AryHashCode ary1));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, TEMP tmp_vec4, TEMP tmp_vec5, TEMP tmp_vec6,\n+         TEMP tmp_vec7, TEMP tmp_vec8, TEMP tmp_vec9, TEMP tmp_vec10, TEMP tmp_vec11, TEMP tmp_vec12,\n+         TEMP tmp_vec13, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, USE_KILL ary1, KILL cr);\n+\n+  format %{ \"Array HashCode float[] $ary1 -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ arrays_hashcode($ary1$$Register, $tmp4$$Register, $result$$Register,\n+                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,\n+                       $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister,\n+                       $tmp_vec4$$XMMRegister, $tmp_vec5$$XMMRegister, $tmp_vec6$$XMMRegister,\n+                       $tmp_vec7$$XMMRegister, $tmp_vec8$$XMMRegister, $tmp_vec9$$XMMRegister,\n+                       $tmp_vec10$$XMMRegister, $tmp_vec11$$XMMRegister, $tmp_vec12$$XMMRegister,\n+                       $tmp_vec13$$XMMRegister, T_FLOAT, false);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":198,"deletions":2,"binary":false,"changes":200,"status":"modified"},{"patch":"@@ -608,2 +608,2 @@\n-  \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals use many memorys edges,\n-  \/\/ but writes none\n+  \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.(equals\/hashCode)\n+  \/\/ use many memorys edges, but writes none\n@@ -613,0 +613,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"StrHashCode\")==0 ||\n@@ -616,1 +617,2 @@\n-        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ))\n+        strcmp(_matrule->_rChild->_opType,\"AryEq\"      )==0 ||\n+        strcmp(_matrule->_rChild->_opType,\"AryHashCode\")==0 ))\n@@ -899,0 +901,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"AryHashCode\")==0 ||\n@@ -901,0 +904,1 @@\n+        strcmp(_matrule->_rChild->_opType,\"StrHashCode\")==0 ||\n@@ -907,1 +911,1 @@\n-        \/\/ String.(compareTo\/equals\/indexOf) and Arrays.equals\n+        \/\/ String.(compareTo\/equals\/indexOf\/hashCode) and Arrays.equals\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -218,0 +218,7 @@\n+    case vmIntrinsics::_hashCodeL:\n+    case vmIntrinsics::_hashCodeU:\n+    case vmIntrinsics::_hashCodeI:\n+    case vmIntrinsics::_hashCodeS:\n+    case vmIntrinsics::_hashCodeC:\n+    case vmIntrinsics::_hashCodeB:\n+    case vmIntrinsics::_hashCodeF:\n@@ -512,0 +519,4 @@\n+  case vmIntrinsics::_hashCodeL:\n+  case vmIntrinsics::_hashCodeU:\n+    if (!SpecialStringHashCode) return true;\n+    break;\n@@ -516,0 +527,7 @@\n+  case vmIntrinsics::_hashCodeI:\n+  case vmIntrinsics::_hashCodeS:\n+  case vmIntrinsics::_hashCodeC:\n+  case vmIntrinsics::_hashCodeB:\n+  case vmIntrinsics::_hashCodeF:\n+    if (!SpecialArraysHashCode) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -303,0 +303,11 @@\n+  do_intrinsic(_hashCodeI,                  java_util_Arrays,     hashCode_name,  hashCodeI_signature,           F_S)   \\\n+   do_signature(hashCodeI_signature,                             \"([I)I\")                                               \\\n+  do_intrinsic(_hashCodeS,                  java_util_Arrays,     hashCode_name,  hashCodeS_signature,           F_S)   \\\n+   do_signature(hashCodeS_signature,                             \"([S)I\")                                               \\\n+  do_intrinsic(_hashCodeC,                  java_util_Arrays,     hashCode_name,  hashCodeC_signature,           F_S)   \\\n+   do_signature(hashCodeC_signature,                             \"([C)I\")                                               \\\n+  do_intrinsic(_hashCodeB,                  java_util_Arrays,     hashCode_name,  hashCodeB_signature,           F_S)   \\\n+   do_signature(hashCodeB_signature,                             \"([B)I\")                                               \\\n+  do_intrinsic(_hashCodeF,                  java_util_Arrays,     hashCode_name,  hashCodeF_signature,           F_S)   \\\n+   do_signature(hashCodeF_signature,                             \"([F)I\")                                               \\\n+                                                                                                                        \\\n@@ -344,0 +355,2 @@\n+  do_intrinsic(_hashCodeL,                java_lang_StringLatin1,hashCode_name, hashCodeB_signature,             F_S)   \\\n+  do_intrinsic(_hashCodeU,                java_lang_StringUTF16, hashCode_name, hashCodeB_signature,             F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -568,0 +568,2 @@\n+        \/\/ Op_StrHashCode,\n+        \/\/ { { 2, ShenandoahLoad },                  { 3, ShenandoahLoad } }, \/\/FIXME: what variables are these\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -555,0 +555,3 @@\n+  product(bool, SpecialStringHashCode, true, DIAGNOSTIC,                    \\\n+          \"special version of string hashCode\")                             \\\n+                                                                            \\\n@@ -558,0 +561,3 @@\n+  product(bool, SpecialArraysHashCode, false, DIAGNOSTIC,                    \\\n+          \"special version of Arrays.hashCode\")                             \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -223,0 +223,4 @@\n+  case vmIntrinsics::_hashCodeL:\n+  case vmIntrinsics::_hashCodeU:\n+    if (!Matcher::match_rule_supported(Op_StrHashCode)) return false;\n+    break;\n@@ -227,0 +231,7 @@\n+  case vmIntrinsics::_hashCodeI:\n+  case vmIntrinsics::_hashCodeS:\n+  case vmIntrinsics::_hashCodeC:\n+  case vmIntrinsics::_hashCodeB:\n+  case vmIntrinsics::_hashCodeF:\n+    if (!Matcher::match_rule_supported(Op_AryHashCode)) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+macro(AryHashCode)\n@@ -333,0 +334,1 @@\n+macro(StrHashCode)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -638,0 +638,1 @@\n+    \/\/ case Op_AryHashCode:\n@@ -641,0 +642,1 @@\n+    \/\/ case Op_StrHashCode:\n@@ -776,0 +778,1 @@\n+    \/\/ case Op_AryHashCode:\n@@ -779,0 +782,1 @@\n+    \/\/ case Op_StrHashCode:\n@@ -3347,2 +3351,2 @@\n-              op == Op_FastLock || op == Op_AryEq || op == Op_StrComp ||\n-              op == Op_CountPositives ||\n+              op == Op_FastLock || op == Op_AryEq || \/*op == Op_AryHashCode ||*\/\n+              op == Op_StrComp || op == Op_CountPositives ||\n@@ -3350,1 +3354,2 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n+              op == Op_StrEquals || \/*op == Op_StrHashCode ||*\/\n+              op == Op_StrIndexOf || op == Op_StrIndexOfChar ||\n@@ -3479,1 +3484,1 @@\n-              op == Op_AryEq || op == Op_StrComp || op == Op_CountPositives ||\n+              op == Op_AryEq || \/*op == Op_AryHashCode ||*\/ op == Op_StrComp || op == Op_CountPositives ||\n@@ -3481,1 +3486,1 @@\n-              op == Op_StrEquals || op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {\n+              op == Op_StrEquals || \/*op == Op_StrHashCode ||*\/ op == Op_StrIndexOf || op == Op_StrIndexOfChar)) {\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -81,0 +81,14 @@\n+uint AryHashCodeNode::match_edge(uint idx) const {\n+  return idx == 2; \/\/ AryHashCode ary1\n+}\n+\n+Node* AryHashCodeNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  return remove_dead_region(phase, can_reshape) ? this : NULL;\n+}\n+\n+const Type* AryHashCodeNode::Value(PhaseGVN* phase) const {\n+  if (in(0) && phase->type(in(0)) == Type::TOP) return Type::TOP;\n+  return bottom_type();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -106,0 +106,10 @@\n+\/\/------------------------------StrHashCode-------------------------------------\n+class StrHashCodeNode: public StrIntrinsicNode {\n+ public:\n+  StrHashCodeNode(Node* control, Node* char_array_mem,\n+                  Node* s1, Node* c1, ArgEncoding encoding):\n+  StrIntrinsicNode(control, char_array_mem, s1, c1, encoding) {};\n+  virtual int Opcode() const;\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+};\n+\n@@ -169,0 +179,16 @@\n+\/\/------------------------------AryHashCode---------------------------------------\n+class AryHashCodeNode: public Node {\n+  BasicType _type;\n+ public:\n+  AryHashCodeNode(Node* control, Node* ary_mem, Node* s1, BasicType type)\n+    : Node(control, ary_mem, s1), _type(type) {};\n+  BasicType type() const { return _type; }\n+  virtual int Opcode() const;\n+  virtual bool depends_only_on_test() const { return false; }\n+  virtual const Type* bottom_type() const { return TypeInt::INT; }\n+  virtual const TypePtr* adr_type() const { return TypeAryPtr::get_array_body_type(_type); }\n+  virtual uint match_edge(uint idx) const;\n+  virtual uint ideal_reg() const { return Op_RegI; }\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n+  virtual const Type* Value(PhaseGVN* phase) const;\n+};\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -200,0 +200,1 @@\n+    \/\/ case Op_StrHashCode:\n@@ -203,0 +204,1 @@\n+    case Op_AryHashCode:\n","filename":"src\/hotspot\/share\/opto\/lcm.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -314,0 +314,3 @@\n+  case vmIntrinsics::_hashCodeL:                 return inline_string_hashCode(StrIntrinsicNode::LL);\n+  case vmIntrinsics::_hashCodeU:                 return inline_string_hashCode(StrIntrinsicNode::UU);\n+\n@@ -494,0 +497,5 @@\n+  case vmIntrinsics::_hashCodeI:                return inline_array_hashcode(T_INT);\n+  case vmIntrinsics::_hashCodeS:                return inline_array_hashcode(T_SHORT);\n+  case vmIntrinsics::_hashCodeC:                return inline_array_hashcode(T_CHAR);\n+  case vmIntrinsics::_hashCodeB:                return inline_array_hashcode(T_BYTE);\n+  case vmIntrinsics::_hashCodeF:                return inline_array_hashcode(T_FLOAT);\n@@ -955,0 +963,20 @@\n+\n+\/\/------------------------------inline_string_hashCode------------------------\n+bool LibraryCallKit::inline_string_hashCode(StrIntrinsicNode::ArgEnc ae) {\n+  Node* arg1 = argument(0);\n+\n+  arg1 = must_be_not_null(arg1, true);\n+\n+  \/\/ Get start addr and length of first argument\n+  Node* arg1_start  = array_element_address(arg1, intcon(0), T_BYTE);\n+  Node* arg1_cnt    = load_array_length(arg1);\n+\n+  Node* result = new StrHashCodeNode(control(), memory(TypeAryPtr::BYTES),\n+                                     arg1_start, arg1_cnt, ae);\n+\n+  clear_upper_avx();\n+\n+  set_result(_gvn.transform(result));\n+  return true;\n+}\n+\n@@ -1016,0 +1044,12 @@\n+\/\/------------------------------inline_array_hashcode----------------------------\n+bool LibraryCallKit::inline_array_hashcode(BasicType type) {\n+  assert(type == T_INT || type == T_SHORT || type == T_CHAR || type == T_BYTE || type == T_FLOAT, \"unsupported array types\");\n+  Node* arg1 = argument(0);\n+\n+  const TypeAryPtr* mtype = TypeAryPtr::get_array_body_type(type);\n+  set_result(_gvn.transform(new AryHashCodeNode(control(), memory(mtype), arg1, type)));\n+  clear_upper_avx();\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  bool inline_string_hashCode(StrIntrinsicNode::ArgEnc ae);\n@@ -246,0 +247,1 @@\n+  bool inline_array_hashcode(BasicType type);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -827,0 +827,1 @@\n+      case Op_StrHashCode:\n@@ -831,0 +832,1 @@\n+      case Op_AryHashCode:\n@@ -984,0 +986,1 @@\n+      case Op_StrHashCode:\n@@ -988,0 +991,1 @@\n+      case Op_AryHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5784,0 +5784,1 @@\n+    case Op_StrHashCode:\n@@ -5787,0 +5788,1 @@\n+    case Op_AryHashCode:\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1066,0 +1066,1 @@\n+    case Op_StrHashCode:\n@@ -1069,0 +1070,1 @@\n+    case Op_AryHashCode:\n@@ -1714,0 +1716,2 @@\n+    fprintf(stderr, \"x = %d, _LAST_MACH_OPER = %d\\n\", x, _LAST_MACH_OPER);\n+    fprintf(stderr, \"dump n\\n\");\n@@ -1715,0 +1719,1 @@\n+    fprintf(stderr, \"dump svec\\n\");\n@@ -2252,0 +2257,1 @@\n+    case Op_StrHashCode:\n@@ -2255,0 +2261,1 @@\n+    case Op_AryHashCode:\n@@ -2419,0 +2426,7 @@\n+    case Op_StrHashCode: {\n+      Node* pair1 = new BinaryNode(n->in(2), n->in(3));\n+      n->set_req(2, pair1);\n+      \/\/ n->set_req(3, n->in(4));\n+      n->del_req(3);\n+      break;\n+    }\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -191,0 +191,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -414,0 +414,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4297,0 +4297,1 @@\n+    @IntrinsicCandidate\n@@ -4324,0 +4325,1 @@\n+    @IntrinsicCandidate\n@@ -4351,0 +4353,1 @@\n+    @IntrinsicCandidate\n@@ -4378,0 +4381,1 @@\n+    @IntrinsicCandidate\n@@ -4432,0 +4436,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/java\/util\/Arrays.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021, Datadog, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @summary Basic hashCode functionality\n+ * @run main\/othervm -XX:+CompactStrings HashCode\n+ * @run main\/othervm -XX:-CompactStrings HashCode\n+ *\/\n+\n+public class HashCode {\n+    private static String [] tests = { \"\", \" \", \"a\",\n+                                       \"It was the best of times, it was the worst of times, it was the age of wisdom, it was the age of foolishness, it was the epoch of belief, it was the epoch of incredulity, it was the season of Light, it was the season of Darkness, it was the spring of hope, it was the winter of despair, we had everything before us, we had nothing before us, we were all going direct to Heaven, we were all going direct the other way- in short, the period was so far like the present period, that some of its noisiest authorities insisted on its being received, for good or for evil, in the superlative degree of comparison only.  -- Charles Dickens, Tale of Two Cities\",\n+                                       \"C'était le meilleur des temps, c'était le pire des temps, c'était l'âge de la sagesse, c'était l'âge de la folie, c'était l'époque de la croyance, c'était l'époque de l'incrédulité, c'était la saison de la Lumière, c'était C'était la saison des Ténèbres, c'était le printemps de l'espoir, c'était l'hiver du désespoir, nous avions tout devant nous, nous n'avions rien devant nous, nous allions tous directement au Ciel, nous allions tous directement dans l'autre sens bref, la période ressemblait tellement à la période actuelle, que certaines de ses autorités les plus bruyantes ont insisté pour qu'elle soit reçue, pour le bien ou pour le mal, au degré superlatif de la comparaison seulement. -- Charles Dickens, Tale of Two Cities (in French)\",\n+                                       \"禅道修行を志した雲水は、一般に参禅のしきたりを踏んだうえで一人の師につき、各地にある専門道場と呼ばれる養成寺院に入門し、与えられた公案に取り組むことになる。公案は、師家（老師）から雲水が悟りの境地へと進んで行くために手助けとして課す問題であり、悟りの境地に達していない人には容易に理解し難い難問だが、屁理屈や詭弁が述べられているわけではなく、頓知や謎かけとも異なる。\"\n+    };\n+\n+    private static int [] expected = { 0, 32, 97, 1094896285, -331808333, 349367663 };\n+\n+    public static void main(String [] args) {\n+        for (int i = 0; i < tests.length; i++) {\n+            String s = tests[i];\n+            int e = expected[i];\n+            int hashCode = s.hashCode();\n+\n+            if (hashCode != e)\n+                throw new RuntimeException(\"String \\\"\" + s + \"\\\": \"\n+                                           + \" e = \" + e\n+                                           + \", hashCode = \" + hashCode);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/HashCode.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+import org.openjdk.jmh.annotations.Fork;\n@@ -29,0 +30,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -33,0 +35,1 @@\n+import java.util.Random;\n@@ -34,0 +37,4 @@\n+import java.io.UnsupportedEncodingException;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.reflect.Method;\n@@ -80,0 +87,365 @@\n+\n+    @BenchmarkMode(Mode.AverageTime)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    @State(Scope.Thread)\n+    @Fork(jvmArgsAppend = {\"--add-exports\", \"java.base\/java.lang=ALL-UNNAMED\", \"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\"})\n+    public static class Algorithm {\n+\n+        private final static String alphabet = \"abcdefghijklmnopqrstuvwxyz\";\n+\n+        private final static MethodHandle defaultLatin1HashCodeMH;\n+        private final static MethodHandle defaultUTF16HashCodeMH;\n+\n+        static {\n+            try {\n+                Class<?> stringLatin1 = Class.forName(\"java.lang.StringLatin1\");\n+                Method stringLatin1HashCode = stringLatin1.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringLatin1HashCode.setAccessible(true);\n+\n+                defaultLatin1HashCodeMH = MethodHandles.lookup().unreflect(stringLatin1HashCode);\n+\n+                Class<?> stringUTF16 = Class.forName(\"java.lang.StringUTF16\");\n+                Method stringUTF16HashCode = stringUTF16.getDeclaredMethod(\"hashCode\", byte[].class);\n+                stringUTF16HashCode.setAccessible(true);\n+\n+                defaultUTF16HashCodeMH = MethodHandles.lookup().unreflect(stringUTF16HashCode);\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        @Param({\"0\", \"1\", \"10\", \"100\", \"1000\", \"10000\"})\n+        private int size;\n+\n+        private byte[] latin1;\n+        private byte[] utf16;\n+\n+        @Setup\n+        public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n+            Random rnd = new Random(42);\n+\n+            char[] str = new char[size];\n+            for (int i = 0; i < size; i++) {\n+                str[i] = alphabet.charAt(rnd.nextInt(alphabet.length()));\n+            }\n+            latin1 = new String(str).getBytes(\"US-ASCII\");\n+            utf16 = new String(str).getBytes(\"UTF-16\");\n+        }\n+\n+        @Benchmark\n+        public int defaultLatin1() throws Throwable {\n+            return (int)defaultLatin1HashCodeMH.invokeExact(latin1);\n+        }\n+\n+        @Benchmark\n+        public int scalarLatin1() {\n+            int h = 0;\n+            int i = 0, len = latin1.length;\n+            for (; i < len; i++) {\n+                h = 31 * h + (latin1[i] & 0xff);\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int scalarLatin1Unrolled8() {\n+            int h = 0;\n+            int i = 0, len = latin1.length;\n+            for (; i < (len & ~(8 - 1)); i += 8) {\n+                h = -1807454463 * h                   +\n+                     1742810335 * (latin1[i+0] & 0xff) +\n+                      887503681 * (latin1[i+1] & 0xff) +\n+                       28629151 * (latin1[i+2] & 0xff) +\n+                         923521 * (latin1[i+3] & 0xff) +\n+                          29791 * (latin1[i+4] & 0xff) +\n+                            961 * (latin1[i+5] & 0xff) +\n+                             31 * (latin1[i+6] & 0xff) +\n+                              1 * (latin1[i+7] & 0xff);\n+            }\n+            for (; i < len; i++) {\n+                h = 31 * h + (latin1[i] & 0xff);\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int scalarLatin1Inverted() {\n+            int h = 0;\n+            int len = latin1.length, i = len - 1;\n+            int coef = 1;\n+            for (; i >= 0; i -= 1) {\n+                h = h + coef * (latin1[i] & 0xff);\n+                coef = coef * 31;\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int scalarLatin1InvertedUnrolled8() {\n+            int h = 0;\n+            int len = latin1.length, i = len - 1;\n+            int coef = 1;\n+            for (int bound = len - (len % (8*(1-0))); i >= bound \/* align on 8 elements *\/; i -= 1) {\n+                h = h + coef * (latin1[i] & 0xff);\n+                coef = coef * 31;\n+            }\n+            if (i-(8*(1-0)-1) >= 0) {\n+                int h0 = 0;\n+                int h1 = 0;\n+                int h2 = 0;\n+                int h3 = 0;\n+                int h4 = 0;\n+                int h5 = 0;\n+                int h6 = 0;\n+                int h7 = 0;\n+                int coef0 = 31*31*31*31*31*31*31*coef;\n+                int coef1 = 31*31*31*31*31*31*coef;\n+                int coef2 = 31*31*31*31*31*coef;\n+                int coef3 = 31*31*31*31*coef;\n+                int coef4 = 31*31*31*coef;\n+                int coef5 = 31*31*coef;\n+                int coef6 = 31*coef;\n+                int coef7 = coef;\n+                for (; i-(8-1) >= 0; i -= 8) {\n+                    h0 += coef0 * (latin1[i-(8-1)+0] & 0xff);\n+                    h1 += coef1 * (latin1[i-(8-1)+1] & 0xff);\n+                    h2 += coef2 * (latin1[i-(8-1)+2] & 0xff);\n+                    h3 += coef3 * (latin1[i-(8-1)+3] & 0xff);\n+                    h4 += coef4 * (latin1[i-(8-1)+4] & 0xff);\n+                    h5 += coef5 * (latin1[i-(8-1)+5] & 0xff);\n+                    h6 += coef6 * (latin1[i-(8-1)+6] & 0xff);\n+                    h7 += coef7 * (latin1[i-(8-1)+7] & 0xff);\n+                    coef0 = 31*31*31*31*31*31*31*31 * coef0;\n+                    coef1 = 31*31*31*31*31*31*31*31 * coef1;\n+                    coef2 = 31*31*31*31*31*31*31*31 * coef2;\n+                    coef3 = 31*31*31*31*31*31*31*31 * coef3;\n+                    coef4 = 31*31*31*31*31*31*31*31 * coef4;\n+                    coef5 = 31*31*31*31*31*31*31*31 * coef5;\n+                    coef6 = 31*31*31*31*31*31*31*31 * coef6;\n+                    coef7 = 31*31*31*31*31*31*31*31 * coef7;\n+                }\n+                h += h0 + h1 + h2 + h3 + h4 + h5 + h6 + h7;\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int scalarLatin1InvertedUnrolled32() {\n+            int h = 0;\n+            int len = latin1.length, i = len - 1;\n+            int coef = 1;\n+            for (int bound = len - (len % 32); i >= bound \/* align on 32 elements *\/; i -= 1) {\n+                h = h + coef * (latin1[i] & 0xff);\n+                coef = coef * 31;\n+            }\n+            if (i-(32-1) >= 0) {\n+                int h0  = 0;\n+                int h1  = 0;\n+                int h2  = 0;\n+                int h3  = 0;\n+                int h4  = 0;\n+                int h5  = 0;\n+                int h6  = 0;\n+                int h7  = 0;\n+                int h8  = 0;\n+                int h9  = 0;\n+                int h10 = 0;\n+                int h11 = 0;\n+                int h12 = 0;\n+                int h13 = 0;\n+                int h14 = 0;\n+                int h15 = 0;\n+                int h16 = 0;\n+                int h17 = 0;\n+                int h18 = 0;\n+                int h19 = 0;\n+                int h20 = 0;\n+                int h21 = 0;\n+                int h22 = 0;\n+                int h23 = 0;\n+                int h24 = 0;\n+                int h25 = 0;\n+                int h26 = 0;\n+                int h27 = 0;\n+                int h28 = 0;\n+                int h29 = 0;\n+                int h30 = 0;\n+                int h31 = 0;\n+                int coef0  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef1  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef2  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef3  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef4  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef5  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef6  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef7  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef8  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef9  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef10 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef11 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef12 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef13 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef14 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef15 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef16 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef17 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef18 = 31*31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef19 = 31*31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef20 = 31*31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef21 = 31*31*31*31*31*31*31*31*31*31*coef;\n+                int coef22 = 31*31*31*31*31*31*31*31*31*coef;\n+                int coef23 = 31*31*31*31*31*31*31*31*coef;\n+                int coef24 = 31*31*31*31*31*31*31*coef;\n+                int coef25 = 31*31*31*31*31*31*coef;\n+                int coef26 = 31*31*31*31*31*coef;\n+                int coef27 = 31*31*31*31*coef;\n+                int coef28 = 31*31*31*coef;\n+                int coef29 = 31*31*coef;\n+                int coef30 = 31*coef;\n+                int coef31 = coef;\n+                for (; i-(32-1) >= 0; i -= 32) {\n+                    h0  += coef0  * (latin1[i-(32-1)+0] & 0xff);\n+                    h1  += coef1  * (latin1[i-(32-1)+1] & 0xff);\n+                    h2  += coef2  * (latin1[i-(32-1)+2] & 0xff);\n+                    h3  += coef3  * (latin1[i-(32-1)+3] & 0xff);\n+                    h4  += coef4  * (latin1[i-(32-1)+4] & 0xff);\n+                    h5  += coef5  * (latin1[i-(32-1)+5] & 0xff);\n+                    h6  += coef6  * (latin1[i-(32-1)+6] & 0xff);\n+                    h7  += coef7  * (latin1[i-(32-1)+7] & 0xff);\n+                    h8  += coef8  * (latin1[i-(32-1)+8] & 0xff);\n+                    h9  += coef9  * (latin1[i-(32-1)+9] & 0xff);\n+                    h10 += coef10 * (latin1[i-(32-1)+10] & 0xff);\n+                    h11 += coef11 * (latin1[i-(32-1)+11] & 0xff);\n+                    h12 += coef12 * (latin1[i-(32-1)+12] & 0xff);\n+                    h13 += coef13 * (latin1[i-(32-1)+13] & 0xff);\n+                    h14 += coef14 * (latin1[i-(32-1)+14] & 0xff);\n+                    h15 += coef15 * (latin1[i-(32-1)+15] & 0xff);\n+                    h16 += coef16 * (latin1[i-(32-1)+16] & 0xff);\n+                    h17 += coef17 * (latin1[i-(32-1)+17] & 0xff);\n+                    h18 += coef18 * (latin1[i-(32-1)+18] & 0xff);\n+                    h19 += coef19 * (latin1[i-(32-1)+19] & 0xff);\n+                    h20 += coef20 * (latin1[i-(32-1)+20] & 0xff);\n+                    h21 += coef21 * (latin1[i-(32-1)+21] & 0xff);\n+                    h22 += coef22 * (latin1[i-(32-1)+22] & 0xff);\n+                    h23 += coef23 * (latin1[i-(32-1)+23] & 0xff);\n+                    h24 += coef24 * (latin1[i-(32-1)+24] & 0xff);\n+                    h25 += coef25 * (latin1[i-(32-1)+25] & 0xff);\n+                    h26 += coef26 * (latin1[i-(32-1)+26] & 0xff);\n+                    h27 += coef27 * (latin1[i-(32-1)+27] & 0xff);\n+                    h28 += coef28 * (latin1[i-(32-1)+28] & 0xff);\n+                    h29 += coef29 * (latin1[i-(32-1)+29] & 0xff);\n+                    h30 += coef30 * (latin1[i-(32-1)+30] & 0xff);\n+                    h31 += coef31 * (latin1[i-(32-1)+31] & 0xff);\n+                    coef0  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef0;\n+                    coef1  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef1;\n+                    coef2  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef2;\n+                    coef3  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef3;\n+                    coef4  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef4;\n+                    coef5  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef5;\n+                    coef6  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef6;\n+                    coef7  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef7;\n+                    coef8  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef8;\n+                    coef9  = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef9;\n+                    coef10 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef10;\n+                    coef11 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef11;\n+                    coef12 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef12;\n+                    coef13 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef13;\n+                    coef14 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef14;\n+                    coef15 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef15;\n+                    coef16 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef16;\n+                    coef17 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef17;\n+                    coef18 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef18;\n+                    coef19 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef19;\n+                    coef20 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef20;\n+                    coef21 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef21;\n+                    coef22 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef22;\n+                    coef23 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef23;\n+                    coef24 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef24;\n+                    coef25 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef25;\n+                    coef26 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef26;\n+                    coef27 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef27;\n+                    coef28 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef28;\n+                    coef29 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef29;\n+                    coef30 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef30;\n+                    coef31 = 31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31*31 * coef31;\n+                }\n+                h += h0  + h1  + h2  + h3  + h4  + h5  + h6  + h7\n+                  +  h8  + h9  + h10 + h11 + h12 + h13 + h14 + h15\n+                  +  h16 + h17 + h18 + h19 + h20 + h21 + h22 + h23\n+                  +  h24 + h25 + h26 + h27 + h28 + h29 + h30 + h31;\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int defaultUTF16() throws Throwable {\n+            return (int)defaultUTF16HashCodeMH.invokeExact(utf16);\n+        }\n+\n+        char getCharUTF16(byte[] value, int index) {\n+            index <<= 1;\n+            \/\/ assuming little endian\n+            return (char)(((value[index++] & 0xff) << 0) |\n+                          ((value[index]   & 0xff) << 8));\n+        }\n+\n+        @Benchmark\n+        public int scalarUTF16() {\n+            int h = 0;\n+            int i = 0, len = utf16.length \/ 2;\n+            for (; i < len; i++) {\n+                h = 31 * h + getCharUTF16(utf16, i);\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int scalarUTF16Unrolled8() {\n+            int h = 0;\n+            int i = 0, len = utf16.length \/ 2;\n+            for (; i < (len & ~(8 - 1)); i += 8) {\n+                h = -1807454463 * h                   +\n+                     1742810335 * getCharUTF16(utf16, i+0) +\n+                      887503681 * getCharUTF16(utf16, i+1) +\n+                       28629151 * getCharUTF16(utf16, i+2) +\n+                         923521 * getCharUTF16(utf16, i+3) +\n+                          29791 * getCharUTF16(utf16, i+4) +\n+                            961 * getCharUTF16(utf16, i+5) +\n+                             31 * getCharUTF16(utf16, i+6) +\n+                              1 * getCharUTF16(utf16, i+7);\n+            }\n+            for (; i < len; i++) {\n+                h = 31 * h + getCharUTF16(utf16, i);\n+            }\n+            return h;\n+        }\n+\n+        @Benchmark\n+        public int scalarUTF16Unrolled16() {\n+            int h = 0;\n+            int i = 0, len = utf16.length \/ 2;\n+            for (; i < (len & ~(16 - 1)); i += 16) {\n+                h =  1353309697 * h                    +\n+                     -510534177 * getCharUTF16(utf16, i+0) +\n+                     1507551809 * getCharUTF16(utf16, i+1) +\n+                     -505558625 * getCharUTF16(utf16, i+2) +\n+                     -293403007 * getCharUTF16(utf16, i+3) +\n+                      129082719 * getCharUTF16(utf16, i+4) +\n+                    -1796951359 * getCharUTF16(utf16, i+5) +\n+                     -196513505 * getCharUTF16(utf16, i+6) +\n+                    -1807454463 * getCharUTF16(utf16, i+7) +\n+                     1742810335 * getCharUTF16(utf16, i+8) +\n+                      887503681 * getCharUTF16(utf16, i+9) +\n+                       28629151 * getCharUTF16(utf16, i+10) +\n+                         923521 * getCharUTF16(utf16, i+11) +\n+                          29791 * getCharUTF16(utf16, i+12) +\n+                            961 * getCharUTF16(utf16, i+13) +\n+                             31 * getCharUTF16(utf16, i+14) +\n+                              1 * getCharUTF16(utf16, i+15);\n+            }\n+            for (; i < len; i++) {\n+                h = 31 * h + getCharUTF16(utf16, i);\n+            }\n+            return h;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java","additions":372,"deletions":0,"binary":false,"changes":372,"status":"modified"}]}