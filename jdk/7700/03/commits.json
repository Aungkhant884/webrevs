[{"commit":{"message":"Leave Java method unchanged"},"files":[{"filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java"},{"filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java"}],"sha":"79e0a826cebeb09d7333f4f7bf6c2dafd45c3ccd"},{"commit":{"message":"Add first pass at vectorized intrinsic for StringLatin1.hashCode\n\nNext is to generalize it for Arrays.hashCode and StringUTF16.hashCode and make it cheap on shorter strings"},"files":[{"filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp"},{"filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp"},{"filename":"src\/hotspot\/cpu\/x86\/x86.ad"},{"filename":"src\/hotspot\/cpu\/x86\/x86_64.ad"},{"filename":"src\/hotspot\/share\/adlc\/formssel.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp"},{"filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp"},{"filename":"src\/hotspot\/share\/gc\/shenandoah\/c2\/shenandoahSupport.cpp"},{"filename":"src\/hotspot\/share\/opto\/c2_globals.hpp"},{"filename":"src\/hotspot\/share\/opto\/c2compiler.cpp"},{"filename":"src\/hotspot\/share\/opto\/classes.hpp"},{"filename":"src\/hotspot\/share\/opto\/escape.cpp"},{"filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp"},{"filename":"src\/hotspot\/share\/opto\/lcm.cpp"},{"filename":"src\/hotspot\/share\/opto\/library_call.cpp"},{"filename":"src\/hotspot\/share\/opto\/library_call.hpp"},{"filename":"src\/hotspot\/share\/opto\/loopTransform.cpp"},{"filename":"src\/hotspot\/share\/opto\/loopnode.cpp"},{"filename":"src\/hotspot\/share\/opto\/matcher.cpp"},{"filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java"},{"filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java"},{"filename":"test\/jdk\/java\/lang\/String\/HashCode.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java"}],"sha":"5febe14dc41495bde14af81f60b4e2891dd4cbb1"},{"commit":{"message":"Add UTF-16 benchmarks"},"files":[{"filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java"}],"sha":"8e2e59bb0ad5e9e52e1070b9bb274fe7322fd68d"},{"commit":{"message":"8282664: Unroll by hand StringUTF16 and StringLatin1 polynomial hash loops\n\nDespite the hash value being cached for Strings, computing the hash still represents a significant CPU usage for applications handling lots of text.\n\nEven though it would be generally better to do it through an enhancement to the autovectorizer, the complexity of doing it by hand is trivial and the gain is sizable (2x speedup) even without the Vector API. The algorithm has been proposed by Richard Startin and Paul Sandoz [1].\n\nAt Datadog, we handle a great amount of text (through logs management for example), and hashing String represents a large part of our CPU usage. It's very unlikely that we are the only one as String.hashCode is such a core feature of the JVM-based languages with its use in HashMap for example. Having even only a 2x speedup would allow us to save thousands of CPU cores per month and improve correspondingly the energy\/carbon impact.\n\n[1] https:\/\/static.rainfocus.com\/oracle\/oow18\/sess\/1525822677955001tLqU\/PF\/codeone18-vector-API-DEV5081_1540354883936001Q3Sv.pdf"},"files":[{"filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java"},{"filename":"src\/java.base\/share\/classes\/java\/lang\/StringUTF16.java"},{"filename":"test\/jdk\/java\/lang\/String\/HashCode.java"},{"filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringHashCode.java"}],"sha":"f7dda1d9007b69c082924c6b1c60d8872af7e25b"}]