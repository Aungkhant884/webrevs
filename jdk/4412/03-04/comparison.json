{"files":[{"patch":"@@ -35,1 +35,0 @@\n-import java.awt.EventQueue;\n@@ -131,1 +130,1 @@\n-                value = EventQueue.isDispatchThread() ? callable.call() : LWCToolkit.invokeAndWait(callable, c);\n+                value = LWCToolkit.invokeAndWait(callable, c);\n@@ -667,47 +666,50 @@\n-                ArrayList<Object> childrenAndRoles = new ArrayList<Object>();\n-                _addChildren(a, whichChildren, allowIgnored, childrenAndRoles);\n-\n-                \/* In the case of fetching a selection, need to check to see if\n-                 * the active descendant is at the beginning of the list.  If it\n-                 * is not it needs to be moved to the beginning of the list so\n-                 * VoiceOver will annouce it correctly.  The list returned\n-                 * from Java is always in order from top to bottom, but when shift\n-                 * selecting downward (extending the list) or multi-selecting using\n-                 * the VO keys control+option+command+return the active descendant\n-                 * is not at the top of the list in the shift select down case and\n-                 * may not be in the multi select case.\n-                 *\/\n-                if (whichChildren == JAVA_AX_SELECTED_CHILDREN) {\n-                    if (!childrenAndRoles.isEmpty()) {\n-                        AccessibleContext activeDescendantAC =\n-                            CAccessible.getActiveDescendant(a);\n-                        if (activeDescendantAC != null) {\n-                            String activeDescendantName =\n-                                activeDescendantAC.getAccessibleName();\n-                            AccessibleRole activeDescendantRole =\n-                                activeDescendantAC.getAccessibleRole();\n-                            \/\/ Move active descendant to front of list.\n-                            \/\/ List contains pairs of each selected item's\n-                            \/\/ Accessible and AccessibleRole.\n-                            ArrayList<Object> newArray  = new ArrayList<Object>();\n-                            int count = childrenAndRoles.size();\n-                            Accessible currentAccessible = null;\n-                            AccessibleContext currentAC = null;\n-                            String currentName = null;\n-                            AccessibleRole currentRole = null;\n-                            for (int i = 0; i < count; i+=2) {\n-                                \/\/ Is this the active descendant?\n-                                currentAccessible = (Accessible)childrenAndRoles.get(i);\n-                                currentAC = currentAccessible.getAccessibleContext();\n-                                currentName = currentAC.getAccessibleName();\n-                                currentRole = (AccessibleRole)childrenAndRoles.get(i+1);\n-                                if (currentName != null && currentName.equals(activeDescendantName) &&\n-                                     currentRole.equals(activeDescendantRole) ) {\n-                                    newArray.add(0, currentAccessible);\n-                                    newArray.add(1, currentRole);\n-                                } else {\n-                                    newArray.add(currentAccessible);\n-                                    newArray.add(currentRole);\n-                                }\n-                            }\n-                            childrenAndRoles = newArray;\n+                return getChildrenAndRolesImpl(a, c, whichChildren, allowIgnored);\n+            }\n+        }, c);\n+    }\n+\n+    private static Object[] getChildrenAndRolesImpl(final Accessible a, final Component c, final int whichChildren, final boolean allowIgnored) {\n+        if (a == null) return null;\n+\n+        ArrayList<Object> childrenAndRoles = new ArrayList<Object>();\n+        _addChildren(a, whichChildren, allowIgnored, childrenAndRoles);\n+\n+        \/* In case of fetching a selection, we need to check if\n+* the active descendant is at the beginning of the list, or\n+* otherwise move it, so that VoiceOver announces it correctly.\n+                * The java list is always in order from top to bottom, but when\n+                * (1) shift-selecting downward (extending the list) or (2) multi-selecting with\n+                * the VO keys (CTRL+ALT+CMD+RETURN) the active descendant\n+                * is not at the top of the list in the 1st case and may not be in the 2nd.\n+                *\/\n+        if (whichChildren == JAVA_AX_SELECTED_CHILDREN) {\n+            if (!childrenAndRoles.isEmpty()) {\n+                AccessibleContext activeDescendantAC =\n+                        CAccessible.getActiveDescendant(a);\n+                if (activeDescendantAC != null) {\n+                    String activeDescendantName =\n+                            activeDescendantAC.getAccessibleName();\n+                    AccessibleRole activeDescendantRole =\n+                            activeDescendantAC.getAccessibleRole();\n+                    \/\/ Move active descendant to front of list.\n+                    \/\/ List contains pairs of each selected item's\n+                    \/\/ Accessible and AccessibleRole.\n+                    ArrayList<Object> newArray = new ArrayList<Object>();\n+                    int count = childrenAndRoles.size();\n+                    Accessible currentAccessible = null;\n+                    AccessibleContext currentAC = null;\n+                    String currentName = null;\n+                    AccessibleRole currentRole = null;\n+                    for (int i = 0; i < count; i += 2) {\n+                        \/\/ Is this the active descendant?\n+                        currentAccessible = (Accessible) childrenAndRoles.get(i);\n+                        currentAC = currentAccessible.getAccessibleContext();\n+                        currentName = currentAC.getAccessibleName();\n+                        currentRole = (AccessibleRole) childrenAndRoles.get(i + 1);\n+                        if (currentName != null && currentName.equals(activeDescendantName) &&\n+                                currentRole.equals(activeDescendantRole)) {\n+                            newArray.add(0, currentAccessible);\n+                            newArray.add(1, currentRole);\n+                        } else {\n+                            newArray.add(currentAccessible);\n+                            newArray.add(currentRole);\n@@ -716,0 +718,1 @@\n+                    childrenAndRoles = newArray;\n@@ -717,0 +720,2 @@\n+            }\n+        }\n@@ -718,3 +723,3 @@\n-                if ((whichChildren < 0) || (whichChildren * 2 >= childrenAndRoles.size())) {\n-                    return childrenAndRoles.toArray();\n-                }\n+        if ((whichChildren < 0) || (whichChildren * 2 >= childrenAndRoles.size())) {\n+            return childrenAndRoles.toArray();\n+        }\n@@ -722,3 +727,1 @@\n-                return new Object[] { childrenAndRoles.get(whichChildren * 2), childrenAndRoles.get((whichChildren * 2) + 1) };\n-            }\n-        }, c);\n+        return new Object[]{childrenAndRoles.get(whichChildren * 2), childrenAndRoles.get((whichChildren * 2) + 1)};\n@@ -734,1 +737,0 @@\n-                currentLevelChildren.addAll(Arrays.asList(getChildrenAndRoles(a, c, JAVA_AX_ALL_CHILDREN, allowIgnored)));\n@@ -736,3 +738,36 @@\n-                for (int i = 0; i < currentLevelChildren.size(); i += 2) {\n-                    if ((((Accessible) currentLevelChildren.get(i)).getAccessibleContext().getAccessibleStateSet().contains(AccessibleState.SELECTED) && (whichChildren == JAVA_AX_SELECTED_CHILDREN)) ||\n-                            (((Accessible) currentLevelChildren.get(i)).getAccessibleContext().getAccessibleStateSet().contains(AccessibleState.VISIBLE) && (whichChildren == JAVA_AX_VISIBLE_CHILDREN)) ||\n+                ArrayList<Accessible> parentStack = new ArrayList<Accessible>();\n+                parentStack.add(a);\n+                ArrayList<Integer> indexses = new ArrayList<Integer>();\n+                Integer index = 0;\n+                int currentLevel = level;\n+                while (!parentStack.isEmpty()) {\n+                    Accessible p = parentStack.get(parentStack.size() - 1);\n+\n+                    currentLevelChildren.addAll(Arrays.asList(getChildrenAndRolesImpl(p, c, JAVA_AX_ALL_CHILDREN, allowIgnored)));\n+                    if ((currentLevelChildren.size() == 0) || (index >= currentLevelChildren.size())) {\n+                        if (!parentStack.isEmpty()) parentStack.remove(parentStack.size() - 1);\n+                        if (!indexses.isEmpty()) index = indexses.remove(indexses.size() - 1);\n+                        currentLevel -= 1;\n+                        currentLevelChildren.clear();\n+                        continue;\n+                    }\n+\n+                    Accessible ca = null;\n+                    Object obj = currentLevelChildren.get(index);\n+                    if (!(obj instanceof Accessible)) {\n+                        index += 2;\n+                        currentLevelChildren.clear();\n+                        continue;\n+                    }\n+                    ca = (Accessible) obj;\n+                    Object role = currentLevelChildren.get(index + 1);\n+                    currentLevelChildren.clear();\n+\n+                    AccessibleContext cac = ca.getAccessibleContext();\n+                    if (cac == null) {\n+                        index += 2;\n+                        continue;\n+                    }\n+\n+                    if ((cac.getAccessibleStateSet().contains(AccessibleState.SELECTED) && (whichChildren == JAVA_AX_SELECTED_CHILDREN)) ||\n+                            (cac.getAccessibleStateSet().contains(AccessibleState.VISIBLE) && (whichChildren == JAVA_AX_VISIBLE_CHILDREN)) ||\n@@ -740,3 +775,3 @@\n-                        allChildren.add(currentLevelChildren.get(i));\n-                        allChildren.add(currentLevelChildren.get(i + 1));\n-                        allChildren.add(String.valueOf(level));\n+                        allChildren.add(ca);\n+                        allChildren.add(role);\n+                        allChildren.add(String.valueOf(currentLevel));\n@@ -744,2 +779,9 @@\n-                    if (getAccessibleStateSet(((Accessible) currentLevelChildren.get(i)).getAccessibleContext(), c).contains(AccessibleState.EXPANDED)) {\n-                        allChildren.addAll(Arrays.asList(getChildrenAndRolesRecursive(((Accessible) currentLevelChildren.get(i)), c, whichChildren, allowIgnored, level + 1)));\n+\n+                    index += 2;\n+\n+                    if (cac.getAccessibleStateSet().contains(AccessibleState.EXPANDED)) {\n+                        parentStack.add(ca);\n+                        indexses.add(index);\n+                        index = 0;\n+                        currentLevel += 1;\n+                        continue;\n@@ -747,0 +789,1 @@\n+\n@@ -748,0 +791,1 @@\n+\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":108,"deletions":64,"binary":false,"changes":172,"status":"modified"}]}