{"files":[{"patch":"@@ -69,2 +69,5 @@\n-  HSDIS_TOOLCHAIN_LDFLAGS := -L\/usr\/lib\/gcc\/$(MINGW_BASE)\/9.2.0  -L\/usr\/$(MINGW_BASE)\/sys-root\/mingw\/lib\n-  HSDIS_TOOLCHAIN_LIBS := \/usr\/$(MINGW_BASE)\/sys-root\/mingw\/lib\/dllcrt2.o -lmingw32 -lgcc -lgcc_eh -lmoldname -lmingwex -lmsvcrt -lpthread -ladvapi32 -lshell32 -luser32 -lkernel32\n+  HSDIS_TOOLCHAIN_LDFLAGS := -L\/usr\/lib\/gcc\/$(MINGW_BASE)\/9.2.0 \\\n+      -L\/usr\/$(MINGW_BASE)\/sys-root\/mingw\/lib\n+  MINGW_DLLCRT := \/usr\/$(MINGW_BASE)\/sys-root\/mingw\/lib\/dllcrt2.o\n+  HSDIS_TOOLCHAIN_LIBS := $(MINGW_DLLCRT) -lmingw32 -lgcc -lgcc_eh -lmoldname \\\n+      -lmingwex -lmsvcrt -lpthread -ladvapi32 -lshell32 -luser32 -lkernel32\n","filename":"make\/Hsdis.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -803,1 +803,1 @@\n-  elif test \"x$with_hsdis\" = xnone || test \"x$with_hsdis\" = x; then\n+  elif test \"x$with_hsdis\" = xnone || test \"x$with_hsdis\" = xno || test \"x$with_hsdis\" = x; then\n","filename":"make\/autoconf\/jdk-options.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -24,1 +24,1 @@\n-tzdata2021c\n+tzdata2021a\n","filename":"make\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+# A reliable and entertaining source about time zones is\n+# Derek Howse, Greenwich time and longitude, Philip Wilson Publishers (1997).\n+#\n@@ -176,1 +179,0 @@\n-Link Africa\/Abidjan Africa\/Accra\t# Ghana\n@@ -178,1 +180,1 @@\n-Link Africa\/Abidjan Africa\/Banjul\t# The Gambia\n+Link Africa\/Abidjan Africa\/Banjul\t# Gambia\n@@ -405,1 +407,3 @@\n-# The Gambia\n+# Gambia\n+# See Africa\/Abidjan.\n+\n@@ -407,0 +411,83 @@\n+\n+# From P Chan (2020-11-20):\n+# Interpretation Amendment Ordinance, 1915 (No.24 of 1915) [1915-11-02]\n+# Ordinances of the Gold Coast, Ashanti, Northern Territories 1915, p 69-71\n+# https:\/\/books.google.com\/books?id=ErA-AQAAIAAJ&pg=PA70\n+# This Ordinance added \"'Time' shall mean Greenwich Mean Time\" to the\n+# Interpretation Ordinance, 1876.\n+#\n+# Determination of the Time Ordinance, 1919 (No. 18 of 1919) [1919-11-24]\n+# Ordinances of the Gold Coast, Ashanti, Northern Territories 1919, p 75-76\n+# https:\/\/books.google.com\/books?id=MbA-AQAAIAAJ&pg=PA75\n+# This Ordinance removed the previous definition of time and introduced DST.\n+#\n+# Time Determination Ordinance (Cap. 214)\n+# The Laws of the Gold Coast (including Togoland Under British Mandate)\n+# Vol. II (1937), p 2328\n+# https:\/\/books.google.com\/books?id=Z7M-AQAAIAAJ&pg=PA2328\n+# Revised edition of the 1919 Ordinance.\n+#\n+# Time Determination (Amendment) Ordinance, 1940 (No. 9 of 1940) [1940-04-06]\n+# Annual Volume of the Laws of the Gold Coast:\n+# Containing All Legislation Enacted During Year 1940, p 22\n+# https:\/\/books.google.com\/books?id=1ao-AQAAIAAJ&pg=PA22\n+# This Ordinance changed the forward transition from September to May.\n+#\n+# Defence (Time Determination Ordinance Amendment) Regulations, 1942\n+# (Regulations No. 6 of 1942) [1942-01-31, commenced on 1942-02-08]\n+# Annual Volume of the Laws of the Gold Coast:\n+# Containing All Legislation Enacted During Year 1942, p 48\n+# https:\/\/books.google.com\/books?id=Das-AQAAIAAJ&pg=PA48\n+# These regulations advanced the [standard] time by thirty minutes.\n+#\n+# Defence (Time Determination Ordinance Amendment (No.2)) Regulations,\n+# 1942 (Regulations No. 28 of 1942) [1942-04-25]\n+# Annual Volume of the Laws of the Gold Coast:\n+# Containing All Legislation Enacted During Year 1942, p 87\n+# https:\/\/books.google.com\/books?id=Das-AQAAIAAJ&pg=PA87\n+# These regulations abolished DST and changed the time to GMT+0:30.\n+#\n+# Defence (Revocation) (No.4) Regulations, 1945 (Regulations No. 45 of\n+# 1945) [1945-10-24, commenced on 1946-01-06]\n+# Annual Volume of the Laws of the Gold Coast:\n+# Containing All Legislation Enacted During Year 1945, p 256\n+# https:\/\/books.google.com\/books?id=9as-AQAAIAAJ&pg=PA256\n+# These regulations revoked the previous two sets of Regulations.\n+#\n+# Time Determination (Amendment) Ordinance, 1945 (No. 18 of 1945) [1946-01-06]\n+# Annual Volume of the Laws of the Gold Coast:\n+# Containing All Legislation Enacted During Year 1945, p 69\n+# https:\/\/books.google.com\/books?id=9as-AQAAIAAJ&pg=PA69\n+# This Ordinance abolished DST.\n+#\n+# Time Determination (Amendment) Ordinance, 1950 (No. 26 of 1950) [1950-07-22]\n+# Annual Volume of the Laws of the Gold Coast:\n+# Containing All Legislation Enacted During Year 1950, p 35\n+# https:\/\/books.google.com\/books?id=e60-AQAAIAAJ&pg=PA35\n+# This Ordinance restored DST but with thirty minutes offset.\n+#\n+# Time Determination Ordinance (Cap. 264)\n+# The Laws of the Gold Coast, Vol. V (1954), p 380\n+# https:\/\/books.google.com\/books?id=Mqc-AQAAIAAJ&pg=PA380\n+# Revised edition of the Time Determination Ordinance.\n+#\n+# Time Determination (Amendment) Ordinance, 1956 (No. 21 of 1956) [1956-08-29]\n+# Annual Volume of the Ordinances of the Gold Coast Enacted During the\n+# Year 1956, p 83\n+# https:\/\/books.google.com\/books?id=VLE-AQAAIAAJ&pg=PA83\n+# This Ordinance abolished DST.\n+\n+# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n+Rule\tGhana\t1919\tonly\t-\tNov\t24\t0:00\t0:20\t+0020\n+Rule\tGhana\t1920\t1942\t-\tJan\t 1\t2:00\t0\tGMT\n+Rule\tGhana\t1920\t1939\t-\tSep\t 1\t2:00\t0:20\t+0020\n+Rule\tGhana\t1940\t1941\t-\tMay\t 1\t2:00\t0:20\t+0020\n+Rule\tGhana\t1950\t1955\t-\tSep\t 1\t2:00\t0:30\t+0030\n+Rule\tGhana\t1951\t1956\t-\tJan\t 1\t2:00\t0\tGMT\n+\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone\tAfrica\/Accra\t-0:00:52 -\tLMT\t1915 Nov  2\n+\t\t\t 0:00\tGhana\t%s\t1942 Feb  8\n+\t\t\t 0:30\t-\t+0030\t1946 Jan  6\n+\t\t\t 0:00\tGhana\t%s\n+\n@@ -671,1 +758,1 @@\n-# See Africa\/Ceuta for Spanish Morocco.\n+# See the 'europe' file for Spanish Morocco (Africa\/Ceuta).\n@@ -1321,9 +1408,9 @@\n-Link Africa\/Lagos Africa\/Bangui\t\t# Central African Republic\n-Link Africa\/Lagos Africa\/Brazzaville\t# Rep. of the Congo\n-Link Africa\/Lagos Africa\/Douala\t\t# Cameroon\n-Link Africa\/Lagos Africa\/Kinshasa\t# Dem. Rep. of the Congo (west)\n-Link Africa\/Lagos Africa\/Libreville\t# Gabon\n-Link Africa\/Lagos Africa\/Luanda\t\t# Angola\n-Link Africa\/Lagos Africa\/Malabo\t\t# Equatorial Guinea\n-Link Africa\/Lagos Africa\/Niamey\t\t# Niger\n-Link Africa\/Lagos Africa\/Porto-Novo\t# Benin\n+Link Africa\/Lagos Africa\/Bangui\t     # Central African Republic\n+Link Africa\/Lagos Africa\/Brazzaville # Rep. of the Congo\n+Link Africa\/Lagos Africa\/Douala\t     # Cameroon\n+Link Africa\/Lagos Africa\/Kinshasa    # Dem. Rep. of the Congo (west)\n+Link Africa\/Lagos Africa\/Libreville  # Gabon\n+Link Africa\/Lagos Africa\/Luanda\t     # Angola\n+Link Africa\/Lagos Africa\/Malabo\t     # Equatorial Guinea\n+Link Africa\/Lagos Africa\/Niamey\t     # Niger\n+Link Africa\/Lagos Africa\/Porto-Novo  # Benin\n@@ -1336,0 +1423,2 @@\n+# Crozet Islands also observes Réunion time; see the 'antarctica' file.\n+#\n@@ -1427,2 +1516,2 @@\n-Link Africa\/Johannesburg Africa\/Maseru\t# Lesotho\n-Link Africa\/Johannesburg Africa\/Mbabane\t# Eswatini\n+Link Africa\/Johannesburg Africa\/Maseru\t   # Lesotho\n+Link Africa\/Johannesburg Africa\/Mbabane    # Eswatini\n@@ -1464,2 +1553,0 @@\n-# South Sudan\n-\n@@ -1471,0 +1558,1 @@\n+# South Sudan\n@@ -1575,1 +1663,1 @@\n-# See Europe\/Paris commentary for PMT-related transitions.\n+# See Europe\/Paris for PMT-related transitions.\n","filename":"make\/data\/tzdata\/africa","additions":106,"deletions":18,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-#\tsee Asia\/Dubai.\n+#\tsee Indian\/Reunion.\n@@ -188,1 +188,11 @@\n-# Dumont d'Urville - see Pacific\/Port_Moresby.\n+# Dumont d'Urville, Île des Pétrels, -6640+14001, since 1956-11\n+# <https:\/\/en.wikipedia.org\/wiki\/Dumont_d'Urville_Station> (2005-12-05)\n+#\n+# Another base at Port-Martin, 50km east, began operation in 1947.\n+# It was destroyed by fire on 1952-01-14.\n+#\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone Antarctica\/DumontDUrville 0 -\t-00\t1947\n+\t\t\t10:00\t-\t+10\t1952 Jan 14\n+\t\t\t0\t-\t-00\t1956 Nov\n+\t\t\t10:00\t-\t+10\n@@ -204,1 +214,14 @@\n-# See Asia\/Riyadh.\n+# Syowa (also known as Showa), -690022+0393524, since 1957\n+#\n+# From Hideyuki Suzuki (1999-02-06):\n+# In all Japanese stations, +0300 is used as the standard time.\n+#\n+# Syowa station, which is the first antarctic station of Japan,\n+# was established on 1957-01-29.  Since Syowa station is still the main\n+# station of Japan, it's appropriate for the principal location.\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone Antarctica\/Syowa\t0\t-\t-00\t1957 Jan 29\n+\t\t\t3:00\t-\t+03\n+# See:\n+# NIPR Antarctic Research Activities (1999-08-17)\n+# http:\/\/www.nipr.ac.jp\/english\/ara01.html\n","filename":"make\/data\/tzdata\/antarctica","additions":26,"deletions":3,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -60,0 +60,3 @@\n+# A reliable and entertaining source about time zones is\n+# Derek Howse, Greenwich time and longitude, Philip Wilson Publishers (1997).\n+#\n@@ -2257,8 +2260,0 @@\n-# From Steffen Thorsen (2021-09-24):\n-# The Jordanian Government announced yesterday that they will start DST\n-# in February instead of March:\n-# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=37683&lang=en&name=en_news (English)\n-# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=189969&lang=ar&name=news (Arabic)\n-# From the Arabic version, it seems to say it would be at midnight\n-# (assume 24:00) on the last Thursday in February, starting from 2022.\n-\n@@ -2295,1 +2290,1 @@\n-Rule\tJordan\t2014\t2021\t-\tMar\tlastThu\t24:00\t1:00\tS\n+Rule\tJordan\t2014\tmax\t-\tMar\tlastThu\t24:00\t1:00\tS\n@@ -2297,1 +2292,0 @@\n-Rule\tJordan\t2022\tmax\t-\tFeb\tlastThu\t24:00\t1:00\tS\n@@ -2772,2 +2766,1 @@\n-# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n-# This agrees with Singapore since 1905-06-01.\n+# http:\/\/www.math.nus.edu.sg\/aslaksen\/teaching\/timezone.html\n@@ -3533,6 +3526,0 @@\n-# From P Chan (2021-05-10):\n-# Here's a fairly comprehensive article in Japanese:\n-# https:\/\/wiki.suikawiki.org\/n\/Philippine%20Time\n-# From Paul Eggert (2021-05-10):\n-# The info in the Japanese table has not been absorbed (yet) below.\n-\n@@ -3605,1 +3592,0 @@\n-Link Asia\/Riyadh Antarctica\/Syowa\n@@ -3611,1 +3597,1 @@\n-# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n+# http:\/\/www.math.nus.edu.sg\/aslaksen\/teaching\/timezone.html\n","filename":"make\/data\/tzdata\/asia","additions":6,"deletions":20,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-Zone Pacific\/Kanton\t  0\t-\t-00\t1937 Aug 31\n+Zone Pacific\/Enderbury\t-11:24:20 -\tLMT\t1901\n@@ -623,33 +623,1 @@\n-#\n-# From Alexander Krivenyshev (2021-03-24):\n-# In 1899 the Cook Islands celebrated Christmas twice to correct the calendar.\n-# According to the old books, missionaries were unaware of\n-# the International Date line, when they came from Sydney.\n-# Thus the Cook Islands were one day ahead....\n-# http:\/\/nzetc.victoria.ac.nz\/tm\/scholarly\/tei-KloDisc-t1-body-d18.html\n-# ... Appendix to the Journals of the House of Representatives, 1900\n-# https:\/\/atojs.natlib.govt.nz\/cgi-bin\/atojs?a=d&d=AJHR1900-I.2.1.2.3\n-# (page 20)\n-#\n-# From Michael Deckers (2021-03-24):\n-# ... in the Cook Island Act of 1915-10-11, online at\n-# http:\/\/www.paclii.org\/ck\/legis\/ck-nz_act\/cia1915132\/\n-# \"651. The hour of the day shall in each of the islands included in the\n-#  Cook Islands be determined in accordance with the meridian of that island.\"\n-# so that local (mean?) time was still used in Rarotonga (and Niue) in 1915.\n-# This was changed in the Cook Island Amendment Act of 1952-10-16 ...\n-# http:\/\/www.paclii.org\/ck\/legis\/ck-nz_act\/ciaa1952212\/\n-# \"651 (1) The hour of the day in each of the islands included in the Cook\n-#  Islands, other than Niue, shall be determined as if each island were\n-#  situated on the meridian one hundred and fifty-seven degrees thirty minutes\n-#  West of Greenwich.  (2) The hour of the day in the Island of Niue shall be\n-#  determined as if that island were situated on the meridian one hundred and\n-#  seventy degrees West of Greenwich.\"\n-# This act does not state when it takes effect, so one has to assume it\n-# applies since 1952-10-16.  But there is the possibility that the act just\n-# legalized prior existing practice, as we had seen with the Guernsey law of\n-# 1913-06-18 for the switch in 1909-04-19.\n-#\n-# From Paul Eggert (2021-03-24):\n-# Transitions after 1952 are from Shanks & Pottenger.\n-#\n+# From Shanks & Pottenger:\n@@ -661,2 +629,1 @@\n-Zone Pacific\/Rarotonga\t13:20:56 -\tLMT\t1899 Dec 26 # Avarua\n-\t\t\t-10:39:04 -\tLMT\t1952 Oct 16\n+Zone Pacific\/Rarotonga\t-10:39:04 -\tLMT\t1901        # Avarua\n@@ -670,9 +637,0 @@\n-# See Pacific\/Raratonga comments for 1952 transition.\n-#\n-# From Tim Parenti (2021-09-13):\n-# Consecutive contemporaneous editions of The Air Almanac listed -11:20 for\n-# Niue as of Apr 1964 but -11 as of Aug 1964:\n-#   Apr 1964: https:\/\/books.google.com\/books?id=_1So677Y5vUC&pg=SL1-PA23\n-#   Aug 1964: https:\/\/books.google.com\/books?id=MbJloqd-zyUC&pg=SL1-PA23\n-# Without greater specificity, guess 1964-07-01 for this transition.\n-\n@@ -680,2 +638,3 @@\n-Zone\tPacific\/Niue\t-11:19:40 -\tLMT\t1952 Oct 16\t# Alofi\n-\t\t\t-11:20\t-\t-1120\t1964 Jul\n+Zone\tPacific\/Niue\t-11:19:40 -\tLMT\t1901        # Alofi\n+\t\t\t-11:20\t-\t-1120\t1951\n+\t\t\t-11:30\t-\t-1130\t1978 Oct  1\n@@ -705,1 +664,0 @@\n-Link Pacific\/Port_Moresby Antarctica\/DumontDUrville\n@@ -810,4 +768,0 @@\n-#\n-# From Geoffrey D. Bennett (2021-09-20):\n-# https:\/\/www.mcil.gov.ws\/storage\/2021\/09\/MCIL-Scan_20210920_120553.pdf\n-# DST has been cancelled for this year.\n@@ -819,2 +773,2 @@\n-Rule\tWS\t2012\t2021\t-\tApr\tSun>=1\t4:00\t0\t-\n-Rule\tWS\t2012\t2020\t-\tSep\tlastSun\t3:00\t1\t-\n+Rule\tWS\t2012\tmax\t-\tApr\tSun>=1\t4:00\t0\t-\n+Rule\tWS\t2012\tmax\t-\tSep\tlastSun\t3:00\t1\t-\n@@ -867,2 +821,2 @@\n-Zone Pacific\/Tongatapu\t12:19:12 -\tLMT\t1945 Sep 10\n-\t\t\t12:20\t-\t+1220\t1961\n+Zone Pacific\/Tongatapu\t12:19:20 -\tLMT\t1901\n+\t\t\t12:20\t-\t+1220\t1941\n@@ -1810,17 +1764,0 @@\n-# Kanton\n-\n-# From Paul Eggert (2021-05-27):\n-# Kiribati's +13 timezone is represented by Kanton, its only populated\n-# island.  (It was formerly spelled \"Canton\", but Gilbertese lacks \"C\".)\n-# Kanton was settled on 1937-08-31 by two British radio operators\n-# <https:\/\/history.state.gov\/historicaldocuments\/frus1937v02\/d94>;\n-# Americans came the next year and built an airfield, partly to\n-# establish airline service and perhaps partly anticipating the\n-# next war.  Aside from the war, the airfield was used by commercial\n-# airlines until long-range jets became standard; although currently\n-# for emergency use only, China says it is considering rebuilding the\n-# airfield for high-end niche tourism.  Kanton has about two dozen\n-# people, caretakers who rotate in from the rest of Kiribati in 2-5\n-# year shifts, and who use some of the leftover structures\n-# <http:\/\/pipa.neaq.org\/2012\/06\/images-of-kanton-island.html>.\n-\n@@ -2110,11 +2047,0 @@\n-# From Paul Eggert (2021-03-04):\n-# In 1943 \"The standard time kept is 12 hrs. 19 min. 12 sec. fast\n-# on Greenwich mean time.\" according to the Admiralty's Hydrographic\n-# Dept., Pacific Islands Pilot, Vol. II, 7th ed., 1943, p 360.\n-\n-# From Michael Deckers (2021-03-03):\n-# [Ian R Bartky: \"One Time Fits All: The Campaigns for Global Uniformity\".\n-# Stanford University Press. 2007. p. 255]:\n-# On 10 September 1945 Tonga adopted a standard time 12 hours,\n-# 20 minutes in advance of Greenwich.\n-\n@@ -2149,20 +2075,3 @@\n-#\n-# From Tim Parenti (2021-09-13), per Paul Eggert (2006-03-22) and Michael\n-# Deckers (2021-03-03):\n-# Mundell places the transition from +12:20 to +13 in 1941, while Shanks &\n-# Pottenger say the transition was on 1968-10-01.\n-#\n-# The Air Almanac published contemporaneous tables of standard times,\n-# which listed +12:20 as of Nov 1960 and +13 as of Mar 1961:\n-#   Nov 1960: https:\/\/books.google.com\/books?id=bVgtWM6kPZUC&pg=SL1-PA19\n-#   Mar 1961: https:\/\/books.google.com\/books?id=W2nItAul4g0C&pg=SL1-PA19\n-# (Thanks to P Chan for pointing us toward these sources.)\n-# This agrees with Bartky, who writes that \"since 1961 [Tonga's] official time\n-# has been thirteen hours in advance of Greenwich time\" (p. 202) and further\n-# writes in an endnote that this was because \"the legislation was amended\" on\n-# 1960-10-19. (p. 255)\n-#\n-# Without greater specificity, presume that Bartky and the Air Almanac point to\n-# a 1961-01-01 transition, as Tāufaʻāhau Tupou IV was still Crown Prince in\n-# 1961 and this still jives with the gist of Mundell's telling, and go with\n-# this over Shanks & Pottenger.\n+\n+# From Paul Eggert (2006-03-22):\n+# Shanks & Pottenger say the transition was on 1968-10-01; go with Mundell.\n","filename":"make\/data\/tzdata\/australasia","additions":13,"deletions":104,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -29,4 +29,2 @@\n-# This file provides links from old or merged timezone names to current ones.\n-# Many names changed in late 1993.  Several of these names are\n-# also present in the file 'backzone', which has data important only\n-# for pre-1970 timestamps and so is out of scope for tzdb proper.\n+# This file provides links between current names for timezones\n+# and their old names.  Many names changed in late 1993.\n@@ -41,1 +39,1 @@\n-Link\tAmerica\/Panama\t\tAmerica\/Coral_Harbour\n+Link\tAmerica\/Atikokan\tAmerica\/Coral_Harbour\n@@ -56,1 +54,1 @@\n-Link\tAmerica\/Puerto_Rico\tAmerica\/Virgin\n+Link\tAmerica\/Port_of_Spain\tAmerica\/Virgin\n@@ -131,1 +129,0 @@\n-Link\tPacific\/Kanton\t\tPacific\/Enderbury\n","filename":"make\/data\/tzdata\/backward","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+#        0:19:32.13 AMT* NST*       Amsterdam, Netherlands Summer (1835-1937)\n@@ -1825,4 +1826,0 @@\n-# Kosovo\n-# See Europe\/Belgrade.\n-\n-\n@@ -2179,4 +2176,0 @@\n-# From Paul Eggert (2021-05-09):\n-# I invented the abbreviations AMT for Amsterdam Mean Time and NST for\n-# Netherlands Summer Time, used in the Netherlands from 1835 to 1937.\n-\n@@ -2409,1 +2402,3 @@\n-# Whitman says DST was not observed in 1950; go with Shanks & Pottenger.\n+Rule\tPort\t1947\t1949\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n+Rule\tPort\t1947\t1949\t-\tOct\tSun>=1\t 2:00s\t0\t-\n+# Shanks & Pottenger say DST was observed in 1950; go with Whitman.\n@@ -2411,2 +2406,2 @@\n-Rule\tPort\t1947\t1965\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n-Rule\tPort\t1947\t1965\t-\tOct\tSun>=1\t 2:00s\t0\t-\n+Rule\tPort\t1951\t1965\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n+Rule\tPort\t1951\t1965\t-\tOct\tSun>=1\t 2:00s\t0\t-\n@@ -3714,3 +3709,0 @@\n-# An extra-special abbreviation style is SET for Swedish Time (svensk\n-# normaltid) 1879-1899, 3° west of the Stockholm Observatory.\n-\n","filename":"make\/data\/tzdata\/europe","additions":6,"deletions":14,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2022\tJun\t28\t00:00:00\n+#Expires 2021\tDec\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1656374400 (2022-06-28 00:00:00 UTC)\n+#expires 1640649600 (2021-12-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C62\n-#\tFile expires on:  28 June 2022\n+#\tUpdated through IERS Bulletin C61\n+#\tFile expires on:  28 December 2021\n","filename":"make\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -755,5 +755,1 @@\n-# The following switches don't make our 1970 cutoff.\n-#\n-# Kiska observed Tokyo date and time during Japanese occupation from\n-# 1942-06-06 to 1943-07-29, and similarly for Attu from 1942-06-07 to\n-# 1943-05-29 (all dates American).  Both islands are now uninhabited.\n+# The following switches don't quite make our 1970 cutoff.\n@@ -855,2 +851,0 @@\n-Link America\/Phoenix America\/Creston\n-\n@@ -1625,1 +1619,18 @@\n-# See America\/Puerto_Rico for east of Natashquan.\n+#\n+# Matthews and Vincent (1998) also write that Quebec east of the -63\n+# meridian is supposed to observe AST, but residents as far east as\n+# Natashquan use EST\/EDT, and residents east of Natashquan use AST.\n+# The Quebec department of justice writes in\n+# \"The situation in Minganie and Basse-Côte-Nord\"\n+# https:\/\/www.justice.gouv.qc.ca\/en\/department\/ministre\/functions-and-responsabilities\/legal-time-in-quebec\/the-situation-in-minganie-and-basse-cote-nord\/\n+# that the coastal strip from just east of Natashquan to Blanc-Sablon\n+# observes Atlantic standard time all year round.\n+# This common practice was codified into law as of 2007; see Legal Time Act,\n+# CQLR c T-5.1 <http:\/\/legisquebec.gouv.qc.ca\/en\/ShowDoc\/cs\/T-5.1>.\n+# For lack of better info, guess this practice began around 1970, contra to\n+# Shanks & Pottenger who have this region observing AST\/ADT.\n+\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone America\/Blanc-Sablon -3:48:28 -\tLMT\t1884\n+\t\t\t-4:00\tCanada\tA%sT\t1970\n+\t\t\t-4:00\t-\tAST\n@@ -1664,0 +1675,48 @@\n+# From Paul Eggert (1997-10-17):\n+# Mark Brader writes that an article in the 1997-10-14 Toronto Star\n+# says that Atikokan, Ontario currently does not observe DST,\n+# but will vote on 11-10 whether to use EST\/EDT.\n+# He also writes that the Ontario Time Act (1990, Chapter T.9)\n+# http:\/\/www.gov.on.ca\/MBS\/english\/publications\/statregs\/conttext.html\n+# says that Ontario east of 90W uses EST\/EDT, and west of 90W uses CST\/CDT.\n+# Officially Atikokan is therefore on CST\/CDT, and most likely this report\n+# concerns a non-official time observed as a matter of local practice.\n+#\n+# From Paul Eggert (2000-10-02):\n+# Matthews and Vincent (1998) write that Atikokan, Pickle Lake, and\n+# New Osnaburgh observe CST all year, that Big Trout Lake observes\n+# CST\/CDT, and that Upsala and Shebandowan observe EST\/EDT, all in\n+# violation of the official Ontario rules.\n+#\n+# From Paul Eggert (2006-07-09):\n+# Chris Walton (2006-07-06) mentioned an article by Stephanie MacLellan in the\n+# 2005-07-21 Chronicle-Journal, which said:\n+#\n+#\tThe clocks in Atikokan stay set on standard time year-round.\n+#\tThis means they spend about half the time on central time and\n+#\tthe other half on eastern time.\n+#\n+#\tFor the most part, the system works, Mayor Dennis Brown said.\n+#\n+#\t\"The majority of businesses in Atikokan deal more with Eastern\n+#\tCanada, but there are some that deal with Western Canada,\" he\n+#\tsaid.  \"I don't see any changes happening here.\"\n+#\n+# Walton also writes \"Supposedly Pickle Lake and Mishkeegogamang\n+# [New Osnaburgh] follow the same practice.\"\n+\n+# From Garry McKinnon (2006-07-14) via Chris Walton:\n+# I chatted with a member of my board who has an outstanding memory\n+# and a long history in Atikokan (and in the telecom industry) and he\n+# can say for certain that Atikokan has been practicing the current\n+# time keeping since 1952, at least.\n+\n+# From Paul Eggert (2006-07-17):\n+# Shanks & Pottenger say that Atikokan has agreed with Rainy River\n+# ever since standard time was introduced, but the information from\n+# McKinnon sounds more authoritative.  For now, assume that Atikokan\n+# switched to EST immediately after WWII era daylight saving time\n+# ended.  This matches the old (less-populous) America\/Coral_Harbour\n+# entry since our cutoff date of 1970, so we can move\n+# America\/Coral_Harbour to the 'backward' file.\n+\n@@ -1794,1 +1853,0 @@\n-Link America\/Toronto America\/Nassau\n@@ -1810,1 +1868,5 @@\n-# For Atikokan see America\/Panama.\n+Zone America\/Atikokan\t-6:06:28 -\tLMT\t1895\n+\t\t\t-6:00\tCanada\tC%sT\t1940 Sep 29\n+\t\t\t-6:00\t1:00\tCDT\t1942 Feb  9  2:00s\n+\t\t\t-6:00\tCanada\tC%sT\t1945 Sep 30  2:00\n+\t\t\t-5:00\t-\tEST\n@@ -2001,0 +2063,54 @@\n+# Matthews and Vincent (1998) write that Creston is like Dawson Creek.\n+\n+# It seems though that (re: Creston) is not entirely correct:\n+\n+# From Chris Walton (2011-12-01):\n+# There are two areas within the Canadian province of British Columbia\n+# that do not currently observe daylight saving:\n+# a) The Creston Valley (includes the town of Creston and surrounding area)\n+# b) The eastern half of the Peace River Regional District\n+# (includes the cities of Dawson Creek and Fort St. John)\n+\n+# Earlier this year I stumbled across a detailed article about the time\n+# keeping history of Creston; it was written by Tammy Hardwick who is the\n+# manager of the Creston & District Museum. The article was written in May 2009.\n+# http:\/\/www.ilovecreston.com\/?p=articles&t=spec&ar=260\n+# According to the article, Creston has not changed its clocks since June 1918.\n+# i.e. Creston has been stuck on UT-7 for 93 years.\n+# Dawson Creek, on the other hand, changed its clocks as recently as April 1972.\n+\n+# Unfortunately the exact date for the time change in June 1918 remains\n+# unknown and will be difficult to ascertain.  I e-mailed Tammy a few months\n+# ago to ask if Sunday June 2 was a reasonable guess.  She said it was just\n+# as plausible as any other date (in June).  She also said that after writing\n+# the article she had discovered another time change in 1916; this is the\n+# subject of another article which she wrote in October 2010.\n+# http:\/\/www.creston.museum.bc.ca\/index.php?module=comments&uop=view_comment&cm+id=56\n+\n+# Here is a summary of the three clock change events in Creston's history:\n+# 1. 1884 or 1885: adoption of Mountain Standard Time (GMT-7)\n+# Exact date unknown\n+# 2. Oct 1916: switch to Pacific Standard Time (GMT-8)\n+# Exact date in October unknown; Sunday October 1 is a reasonable guess.\n+# 3. June 1918: switch to Pacific Daylight Time (GMT-7)\n+# Exact date in June unknown; Sunday June 2 is a reasonable guess.\n+# note 1:\n+# On Oct 27\/1918 when daylight saving ended in the rest of Canada,\n+# Creston did not change its clocks.\n+# note 2:\n+# During WWII when the Federal Government legislated a mandatory clock change,\n+# Creston did not oblige.\n+# note 3:\n+# There is no guarantee that Creston will remain on Mountain Standard Time\n+# (UTC-7) forever.\n+# The subject was debated at least once this year by the town Council.\n+# http:\/\/www.bclocalnews.com\/kootenay_rockies\/crestonvalleyadvance\/news\/116760809.html\n+\n+# During a period WWII, summer time (Daylight saying) was mandatory in Canada.\n+# In Creston, that was handled by shifting the area to PST (-8:00) then applying\n+# summer time to cause the offset to be -7:00, the same as it had been before\n+# the change.  It can be argued that the timezone abbreviation during this\n+# period should be PDT rather than MST, but that doesn't seem important enough\n+# (to anyone) to further complicate the rules.\n+\n+# The transition dates (and times) are guesses.\n@@ -2054,1 +2170,4 @@\n-# For Creston see America\/Phoenix.\n+Zone America\/Creston\t-7:46:04 -\tLMT\t1884\n+\t\t\t-7:00\t-\tMST\t1916 Oct 1\n+\t\t\t-8:00\t-\tPST\t1918 Jun 2\n+\t\t\t-7:00\t-\tMST\n@@ -2836,1 +2955,1 @@\n-# See America\/Puerto_Rico.\n+# See America\/Port_of_Spain.\n@@ -2838,2 +2957,29 @@\n-# The Bahamas\n-# See America\/Toronto.\n+# Bahamas\n+#\n+# For 1899 Milne gives -5:09:29.5; round that.\n+#\n+# From P Chan (2020-11-27, corrected on 2020-12-02):\n+# There were two periods of DST observed in 1942-1945: 1942-05-01\n+# midnight to 1944-12-31 midnight and 1945-02-01 to 1945-10-17 midnight.\n+# \"midnight\" should mean 24:00 from the context.\n+#\n+# War Time Order 1942 [1942-05-01] and War Time (No. 2) Order 1942  [1942-09-29]\n+# Appendix to the Statutes of 7 George VI. and the Year 1942. p 34, 43\n+# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA3-PA34\n+# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA3-PA43\n+#\n+# War Time Order 1943 [1943-03-31] and War Time Order 1944 [1943-12-29]\n+# Appendix to the Statutes of 8 George VI. and the Year 1943. p 9-10, 28-29\n+# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA4-PA9\n+# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA4-PA28\n+#\n+# War Time Order 1945 [1945-01-31] and the Order which revoke War Time Order\n+# 1945 [1945-10-16] Appendix to the Statutes of 9 George VI. and the Year\n+# 1945. p 160, 247-248\n+# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA6-PA160\n+# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA6-PA247\n+#\n+# From Sue Williams (2006-12-07):\n+# The Bahamas announced about a month ago that they plan to change their DST\n+# rules to sync with the U.S. starting in 2007....\n+# http:\/\/www.jonesbahamas.com\/?c=45&a=10412\n@@ -2841,0 +2987,12 @@\n+# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n+Rule\tBahamas\t1942\tonly\t-\tMay\t 1\t24:00\t1:00\tW\n+Rule\tBahamas\t1944\tonly\t-\tDec\t31\t24:00\t0\tS\n+Rule\tBahamas\t1945\tonly\t-\tFeb\t 1\t0:00\t1:00\tW\n+Rule\tBahamas\t1945\tonly\t-\tAug\t14\t23:00u\t1:00\tP # Peace\n+Rule\tBahamas\t1945\tonly\t-\tOct\t17\t24:00\t0\tS\n+Rule\tBahamas\t1964\t1975\t-\tOct\tlastSun\t2:00\t0\tS\n+Rule\tBahamas\t1964\t1975\t-\tApr\tlastSun\t2:00\t1:00\tD\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone\tAmerica\/Nassau\t-5:09:30 -\tLMT\t1912 Mar 2\n+\t\t\t-5:00\tBahamas\tE%sT\t1976\n+\t\t\t-5:00\tUS\tE%sT\n@@ -2846,29 +3004,0 @@\n-# From P Chan (2020-12-09 and 2020-12-11):\n-# Standard time of GMT-4 was adopted in 1911.\n-# Definition of Time Act, 1911 (1911-7) [1911-08-28]\n-# 1912, Laws of Barbados (5 v.), OCLC Number: 919801291, Vol. 4, Image No. 522\n-# 1944, Laws of Barbados (5 v.), OCLC Number: 84548697, Vol. 4, Image No. 122\n-# http:\/\/llmc.com\/browse.aspx?type=2&coll=85&div=297\n-#\n-# DST was observed in 1942-44.\n-# Defence (Daylight Saving) Regulations, 1942, 1942-04-13\n-# Defence (Daylight Saving) (Repeal) Regulations, 1942, 1942-08-22\n-# Defence (Daylight Saving) Regulations, 1943, 1943-04-16\n-# Defence (Daylight Saving) (Repeal) Regulations, 1943, 1943-09-01\n-# Defence (Daylight Saving) Regulations, 1944, 1944-03-21\n-# [Defence (Daylight Saving) (Amendment) Regulations 1944, 1944-03-28]\n-# Defence (Daylight Saving) (Repeal) Regulations, 1944, 1944-08-30\n-#\n-# 1914-, Subsidiary Legis., Annual Vols. OCLC Number: 226290591\n-# 1942: Image Nos. 527-528, 555-556\n-# 1943: Image Nos. 178-179, 198\n-# 1944: Image Nos. 113-115, 129\n-# http:\/\/llmc.com\/titledescfull.aspx?type=2&coll=85&div=297&set=98437\n-#\n-# From Tim Parenti (2021-02-20):\n-# The transitions below are derived from P Chan's sources, except that the 1977\n-# through 1980 transitions are from Shanks & Pottenger since we have no better\n-# data there.  Of particular note, the 1944 DST regulation only advanced the\n-# time to \"exactly three and a half hours later than Greenwich mean time\", as\n-# opposed to \"three hours\" in the 1942 and 1943 regulations.\n-\n@@ -2876,6 +3005,0 @@\n-Rule\tBarb\t1942\tonly\t-\tApr\t19\t5:00u\t1:00\tD\n-Rule\tBarb\t1942\tonly\t-\tAug\t31\t6:00u\t0\tS\n-Rule\tBarb\t1943\tonly\t-\tMay\t 2\t5:00u\t1:00\tD\n-Rule\tBarb\t1943\tonly\t-\tSep\t 5\t6:00u\t0\tS\n-Rule\tBarb\t1944\tonly\t-\tApr\t10\t5:00u\t0:30\t-\n-Rule\tBarb\t1944\tonly\t-\tSep\t10\t6:00u\t0\tS\n@@ -2888,3 +3011,2 @@\n-Zone America\/Barbados\t-3:58:29 -\tLMT\t1911 Aug 28 # Bridgetown\n-\t\t\t-4:00\tBarb\tA%sT\t1944\n-\t\t\t-4:00\tBarb\tAST\/-0330 1945\n+Zone America\/Barbados\t-3:58:29 -\tLMT\t1924 # Bridgetown\n+\t\t\t-3:58:29 -\tBMT\t1932 # Bridgetown Mean Time\n@@ -3052,3 +3174,0 @@\n-# Caribbean Netherlands\n-# See America\/Puerto_Rico.\n-\n@@ -3283,1 +3402,1 @@\n-# See America\/Puerto_Rico.\n+# See America\/Port_of_Spain.\n@@ -3335,1 +3454,1 @@\n-# See America\/Puerto_Rico.\n+# See America\/Port_of_Spain.\n@@ -3522,1 +3641,1 @@\n-# See America\/Puerto_Rico.\n+# See America\/Port_of_Spain.\n@@ -3594,1 +3713,0 @@\n-Link America\/Panama America\/Atikokan\n@@ -3604,19 +3722,0 @@\n-Link America\/Puerto_Rico America\/Anguilla\n-Link America\/Puerto_Rico America\/Antigua\n-Link America\/Puerto_Rico America\/Aruba\n-Link America\/Puerto_Rico America\/Curacao\n-Link America\/Puerto_Rico America\/Blanc-Sablon\t# Quebec (Lower North Shore)\n-Link America\/Puerto_Rico America\/Dominica\n-Link America\/Puerto_Rico America\/Grenada\n-Link America\/Puerto_Rico America\/Guadeloupe\n-Link America\/Puerto_Rico America\/Kralendijk\t# Caribbean Netherlands\n-Link America\/Puerto_Rico America\/Lower_Princes\t# Sint Maarten\n-Link America\/Puerto_Rico America\/Marigot\t# St Martin (French part)\n-Link America\/Puerto_Rico America\/Montserrat\n-Link America\/Puerto_Rico America\/Port_of_Spain\t# Trinidad & Tobago\n-Link America\/Puerto_Rico America\/St_Barthelemy\t# St Barthélemy\n-Link America\/Puerto_Rico America\/St_Kitts\t# St Kitts & Nevis\n-Link America\/Puerto_Rico America\/St_Lucia\n-Link America\/Puerto_Rico America\/St_Thomas\t# Virgin Islands (US)\n-Link America\/Puerto_Rico America\/St_Vincent\n-Link America\/Puerto_Rico America\/Tortola\t# Virgin Islands (UK)\n@@ -3626,1 +3725,1 @@\n-# See America\/Puerto_Rico.\n+# See America\/Port_of_Spain.\n@@ -3637,4 +3736,1 @@\n-# See America\/Puerto_Rico.\n-\n-# Sint Maarten\n-# See America\/Puerto_Rico.\n+# See America\/Port_of_Spain.\n@@ -3711,2 +3807,2 @@\n-# US Virgin Is\n-# See America\/Puerto_Rico.\n+# Virgin Is\n+# See America\/Port_of_Spain.\n","filename":"make\/data\/tzdata\/northamerica","additions":181,"deletions":85,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-# See America\/Puerto_Rico.\n+Link America\/Curacao America\/Aruba\n@@ -1395,1 +1395,16 @@\n-# See America\/Puerto_Rico.\n+\n+# Milne gives 4:35:46.9 for Curaçao mean time; round to nearest.\n+#\n+# From Paul Eggert (2006-03-22):\n+# Shanks & Pottenger say that The Bottom and Philipsburg have been at\n+# -4:00 since standard time was introduced on 1912-03-02; and that\n+# Kralendijk and Rincon used Kralendijk Mean Time (-4:33:08) from\n+# 1912-02-02 to 1965-01-01.  The former is dubious, since S&P also say\n+# Saba Island has been like Curaçao.\n+# This all predates our 1970 cutoff, though.\n+#\n+# By July 2007 Curaçao and St Maarten are planned to become\n+# associated states within the Netherlands, much like Aruba;\n+# Bonaire, Saba and St Eustatius would become directly part of the\n+# Netherlands as Kingdom Islands.  This won't affect their time zones\n+# though, as far as we know.\n@@ -1397,0 +1412,5 @@\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone\tAmerica\/Curacao\t-4:35:47 -\tLMT\t1912 Feb 12 # Willemstad\n+\t\t\t-4:30\t-\t-0430\t1965\n+\t\t\t-4:00\t-\tAST\n+\n@@ -1400,3 +1420,4 @@\n-# and contains an apostrophe; use \"Lower_Princes\"....\n-# From Paul Eggert (2021-09-29):\n-# These backward-compatibility links now are in the 'northamerica' file.\n+# and contains an apostrophe; use \"Lower_Princes\" below.\n+\n+Link\tAmerica\/Curacao\tAmerica\/Lower_Princes\t# Sint Maarten\n+Link\tAmerica\/Curacao\tAmerica\/Kralendijk\t# Caribbean Netherlands\n@@ -1545,29 +1566,0 @@\n-\n-# From P Chan (2020-11-27):\n-# https:\/\/books.google.com\/books?id=5-5CAQAAMAAJ&pg=SA1-PA547\n-# The Official Gazette of British Guiana. (New Series.) Vol. XL. July to\n-# December, 1915, p 1547, lists as several notes:\n-# \"Local Mean Time 3 hours 52 mins. 39 secs. slow of Greenwich Mean Time\n-# (Georgetown.) From 1st August, 1911, British Guiana Standard Mean Time 4\n-# hours slow of Greenwich Mean Time, by notice in Official Gazette on 1st July,\n-# 1911.  From 1st March, 1915, British Guiana Standard Mean Time 3 hours 45\n-# mins. 0 secs. slow of Greenwich Mean Time, by notice in Official Gazette on\n-# 23rd January, 1915.\"\n-#\n-# https:\/\/parliament.gov.gy\/documents\/acts\/10923-act_no._27_of_1975_-_interpretation_and_general_clauses_(amendment)_act_1975.pdf\n-# Interpretation and general clauses (Amendment) Act 1975 (Act No. 27 of 1975)\n-# [dated 1975-07-31]\n-# \"This Act...shall come into operation on 1st August, 1975.\"\n-# \"...where any expression of time occurs...the time referred to shall signify\n-# the standard time of Guyana which shall be three hours behind Greenwich Mean\n-# Time.\"\n-#\n-# Circular No. 10\/1992 dated 1992-03-20\n-# https:\/\/dps.gov.gy\/wp-content\/uploads\/2018\/12\/1992-03-20-Circular-010.pdf\n-# \"...cabinet has decided that with effect from Sunday 29th March, 1992, Guyana\n-# Standard Time would be re-established at 01:00 hours by adjusting the hands\n-# of the clock back to 24:00 hours.\"\n-# Legislated in the Interpretation and general clauses (Amendment) Act 1992\n-# (Act No. 6 of 1992) [passed 1992-03-27, published 1992-04-18]\n-# https:\/\/parliament.gov.gy\/documents\/acts\/5885-6_of_1992_interpretation_and_general_clauses_(amendment)_act_1992.pdf\n-\n@@ -1575,4 +1567,4 @@\n-Zone\tAmerica\/Guyana\t-3:52:39 -\tLMT\t1911 Aug  1 # Georgetown\n-\t\t\t-4:00\t-\t-04\t1915 Mar  1\n-\t\t\t-3:45\t-\t-0345\t1975 Aug  1\n-\t\t\t-3:00\t-\t-03\t1992 Mar 29  1:00\n+Zone\tAmerica\/Guyana\t-3:52:40 -\tLMT\t1915 Mar    # Georgetown\n+\t\t\t-3:45\t-\t-0345\t1975 Jul 31\n+\t\t\t-3:00\t-\t-03\t1991\n+# IATA SSIM (1996-06) says -4:00.  Assume a 1991 switch.\n@@ -1719,1 +1711,18 @@\n-# See America\/Puerto_Rico.\n+# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n+Zone America\/Port_of_Spain -4:06:04 -\tLMT\t1912 Mar 2\n+\t\t\t-4:00\t-\tAST\n+\n+# These all agree with Trinidad and Tobago since 1970.\n+Link America\/Port_of_Spain America\/Anguilla\n+Link America\/Port_of_Spain America\/Antigua\n+Link America\/Port_of_Spain America\/Dominica\n+Link America\/Port_of_Spain America\/Grenada\n+Link America\/Port_of_Spain America\/Guadeloupe\n+Link America\/Port_of_Spain America\/Marigot\t# St Martin (French part)\n+Link America\/Port_of_Spain America\/Montserrat\n+Link America\/Port_of_Spain America\/St_Barthelemy # St Barthélemy\n+Link America\/Port_of_Spain America\/St_Kitts\t# St Kitts & Nevis\n+Link America\/Port_of_Spain America\/St_Lucia\n+Link America\/Port_of_Spain America\/St_Thomas\t# Virgin Islands (US)\n+Link America\/Port_of_Spain America\/St_Vincent\n+Link America\/Port_of_Spain America\/Tortola\t# Virgin Islands (UK)\n","filename":"make\/data\/tzdata\/southamerica","additions":48,"deletions":39,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-# From Paul Eggert (2021-09-20):\n+# From Paul Eggert (2018-06-27):\n@@ -42,3 +42,0 @@\n-# Unlike zone1970.tab, a row's third column can be a Link from\n-# 'backward' instead of a Zone.\n-#\n@@ -257,1 +254,1 @@\n-KI\t-0247-17143\tPacific\/Kanton\tPhoenix Islands\n+KI\t-0308-17105\tPacific\/Enderbury\tPhoenix Islands\n@@ -420,1 +417,1 @@\n-TO\t-210800-1751200\tPacific\/Tongatapu\n+TO\t-2110-17510\tPacific\/Tongatapu\n","filename":"make\/data\/tzdata\/zone.tab","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-        undef stringop-overflow, \\\n+        undef, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10896,0 +10896,1 @@\n+  match(Set dst (MulI src1 (SubI zero src2)));\n@@ -10947,0 +10948,1 @@\n+  match(Set dst (MulL src1 (SubL zero src2)));\n@@ -10996,0 +10998,1 @@\n+  match(Set dst (MulL (ConvI2L src1) (SubL zero (ConvI2L src2))));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,2 +40,0 @@\n-extern aarch64_atomic_stub_t aarch64_atomic_fetch_add_4_relaxed_impl;\n-extern aarch64_atomic_stub_t aarch64_atomic_fetch_add_8_relaxed_impl;\n","filename":"src\/hotspot\/cpu\/aarch64\/atomic_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4842,0 +4842,12 @@\n+  \/\/ code for comparing 16 bytes of strings with same encoding\n+  void compare_string_16_bytes_same(Label &DIFF1, Label &DIFF2) {\n+    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, tmp1 = r10, tmp2 = r11;\n+    __ ldr(rscratch1, Address(__ post(str1, 8)));\n+    __ eor(rscratch2, tmp1, tmp2);\n+    __ ldr(cnt1, Address(__ post(str2, 8)));\n+    __ cbnz(rscratch2, DIFF1);\n+    __ ldr(tmp1, Address(__ post(str1, 8)));\n+    __ eor(rscratch2, rscratch1, cnt1);\n+    __ ldr(tmp2, Address(__ post(str2, 8)));\n+    __ cbnz(rscratch2, DIFF2);\n+  }\n@@ -5048,4 +5060,4 @@\n-        tmp1 = r10, tmp2 = r11, tmp1h = rscratch1, tmp2h = rscratch2;\n-\n-    Label LARGE_LOOP_PREFETCH, LOOP_COMPARE16, DIFF, LESS16, LESS8, CAL_DIFFERENCE, LENGTH_DIFF;\n-\n+        tmp1 = r10, tmp2 = r11;\n+    Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,\n+        LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,\n+        DIFF_LAST_POSITION, DIFF_LAST_POSITION2;\n@@ -5055,5 +5067,2 @@\n-\n-    \/\/ before jumping to stub, pre-load 8 bytes already, so do comparison directly\n-    __ eor(rscratch2, tmp1, tmp2);\n-    __ cbnz(rscratch2, CAL_DIFFERENCE);\n-\n+    \/\/ cnt1\/cnt2 contains amount of characters to compare. cnt1 can be re-used\n+    \/\/ update cnt2 counter with already loaded 8 bytes\n@@ -5068,9 +5077,2 @@\n-\n-        __ align(OptoLoopAlignment);\n-        for (int i = 0; i < 4; i++) {\n-          __ ldp(tmp1, tmp1h, Address(str1, i * 16));\n-          __ ldp(tmp2, tmp2h, Address(str2, i * 16));\n-          __ cmp(tmp1, tmp2);\n-          __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n-          __ br(Assembler::NE, DIFF);\n-        }\n+        compare_string_16_bytes_same(DIFF, DIFF2);\n+        compare_string_16_bytes_same(DIFF, DIFF2);\n@@ -5078,2 +5080,1 @@\n-        __ add(str1, str1, 64);\n-        __ add(str2, str2, 64);\n+        compare_string_16_bytes_same(DIFF, DIFF2);\n@@ -5081,2 +5082,3 @@\n-        __ br(Assembler::GE, LARGE_LOOP_PREFETCH);\n-        __ cbz(cnt2, LENGTH_DIFF); \/\/ no more chars left?\n+        compare_string_16_bytes_same(DIFF, DIFF2);\n+        __ br(__ GT, LARGE_LOOP_PREFETCH);\n+        __ cbz(cnt2, LAST_CHECK_AND_LENGTH_DIFF); \/\/ no more chars left?\n@@ -5084,3 +5086,3 @@\n-\n-    __ subs(rscratch1, cnt2, isLL ? 16 : 8);\n-    __ br(Assembler::LE, LESS16);\n+    \/\/ less than 16 bytes left?\n+    __ subs(cnt2, cnt2, isLL ? 16 : 8);\n+    __ br(__ LT, TAIL);\n@@ -5088,22 +5090,7 @@\n-    __ bind(LOOP_COMPARE16);\n-      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n-      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n-      __ cmp(tmp1, tmp2);\n-      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n-      __ br(Assembler::NE, DIFF);\n-      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n-      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n-      __ br(Assembler::LT, LESS16);\n-\n-      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n-      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n-      __ cmp(tmp1, tmp2);\n-      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n-      __ br(Assembler::NE, DIFF);\n-      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n-      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n-      __ br(Assembler::GE, LOOP_COMPARE16);\n-      __ cbz(cnt2, LENGTH_DIFF);\n-\n-    __ bind(LESS16);\n-      \/\/ each 8 compare\n+    __ bind(SMALL_LOOP);\n+      compare_string_16_bytes_same(DIFF, DIFF2);\n+      __ subs(cnt2, cnt2, isLL ? 16 : 8);\n+      __ br(__ GE, SMALL_LOOP);\n+    __ bind(TAIL);\n+      __ adds(cnt2, cnt2, isLL ? 16 : 8);\n+      __ br(__ EQ, LAST_CHECK_AND_LENGTH_DIFF);\n@@ -5111,1 +5098,3 @@\n-      __ br(Assembler::LE, LESS8);\n+      __ br(__ LE, CHECK_LAST);\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbnz(rscratch2, DIFF);\n@@ -5114,2 +5103,0 @@\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, CAL_DIFFERENCE);\n@@ -5117,2 +5104,1 @@\n-\n-    __ bind(LESS8); \/\/ directly load last 8 bytes\n+    __ bind(CHECK_LAST);\n@@ -5120,1 +5106,1 @@\n-        __ add(cnt2, cnt2, cnt2);\n+        __ add(cnt2, cnt2, cnt2); \/\/ now in bytes\n@@ -5122,2 +5108,0 @@\n-      __ ldr(tmp1, Address(str1, cnt2));\n-      __ ldr(tmp2, Address(str2, cnt2));\n@@ -5125,0 +5109,4 @@\n+      __ cbnz(rscratch2, DIFF);\n+      __ ldr(rscratch1, Address(str1, cnt2));\n+      __ ldr(cnt1, Address(str2, cnt2));\n+      __ eor(rscratch2, rscratch1, cnt1);\n@@ -5126,2 +5114,18 @@\n-      __ b(CAL_DIFFERENCE);\n-\n+      \/\/ Find the first different characters in the longwords and\n+      \/\/ compute their difference.\n+    __ bind(DIFF2);\n+      __ rev(rscratch2, rscratch2);\n+      __ clz(rscratch2, rscratch2);\n+      __ andr(rscratch2, rscratch2, isLL ? -8 : -16);\n+      __ lsrv(rscratch1, rscratch1, rscratch2);\n+      if (isLL) {\n+        __ lsrv(cnt1, cnt1, rscratch2);\n+        __ uxtbw(rscratch1, rscratch1);\n+        __ uxtbw(cnt1, cnt1);\n+      } else {\n+        __ lsrv(cnt1, cnt1, rscratch2);\n+        __ uxthw(rscratch1, rscratch1);\n+        __ uxthw(cnt1, cnt1);\n+      }\n+      __ subw(result, rscratch1, cnt1);\n+      __ b(LENGTH_DIFF);\n@@ -5129,7 +5133,0 @@\n-      __ cmp(tmp1, tmp2);\n-      __ csel(tmp1, tmp1, tmp1h, Assembler::NE);\n-      __ csel(tmp2, tmp2, tmp2h, Assembler::NE);\n-      \/\/ reuse rscratch2 register for the result of eor instruction\n-      __ eor(rscratch2, tmp1, tmp2);\n-\n-    __ bind(CAL_DIFFERENCE);\n@@ -5140,1 +5137,0 @@\n-      __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5142,0 +5138,1 @@\n+        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5145,0 +5142,1 @@\n+        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5149,1 +5147,4 @@\n-\n+      __ b(LENGTH_DIFF);\n+    __ bind(LAST_CHECK_AND_LENGTH_DIFF);\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbnz(rscratch2, DIFF);\n@@ -6212,1 +6213,1 @@\n-  void gen_ldadd_entry(Assembler::operand_size size, atomic_memory_order order) {\n+  void gen_ldaddal_entry(Assembler::operand_size size) {\n@@ -6214,8 +6215,2 @@\n-    \/\/ If not relaxed, then default to conservative.  Relaxed is the only\n-    \/\/ case we use enough to be worth specializing.\n-    if (order == memory_order_relaxed) {\n-      __ ldadd(size, incr, prev, addr);\n-    } else {\n-      __ ldaddal(size, incr, prev, addr);\n-      __ membar(Assembler::StoreStore|Assembler::StoreLoad);\n-    }\n+    __ ldaddal(size, incr, prev, addr);\n+    __ membar(Assembler::StoreStore|Assembler::StoreLoad);\n@@ -6251,1 +6246,1 @@\n-    \/\/ ADD, memory_order_conservative\n+    \/\/ All memory_order_conservative\n@@ -6253,1 +6248,1 @@\n-    gen_ldadd_entry(Assembler::word, memory_order_conservative);\n+    gen_ldaddal_entry(Assembler::word);\n@@ -6255,9 +6250,1 @@\n-    gen_ldadd_entry(Assembler::xword, memory_order_conservative);\n-\n-    \/\/ ADD, memory_order_relaxed\n-    AtomicStubMark mark_fetch_add_4_relaxed\n-      (_masm, &aarch64_atomic_fetch_add_4_relaxed_impl);\n-    gen_ldadd_entry(MacroAssembler::word, memory_order_relaxed);\n-    AtomicStubMark mark_fetch_add_8_relaxed\n-      (_masm, &aarch64_atomic_fetch_add_8_relaxed_impl);\n-    gen_ldadd_entry(MacroAssembler::xword, memory_order_relaxed);\n+    gen_ldaddal_entry(Assembler::xword);\n@@ -6265,1 +6252,0 @@\n-    \/\/ XCHG, memory_order_conservative\n@@ -7465,2 +7451,0 @@\n-DEFAULT_ATOMIC_OP(fetch_add, 4, _relaxed)\n-DEFAULT_ATOMIC_OP(fetch_add, 8, _relaxed)\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":73,"deletions":89,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -49,1 +49,2 @@\n-  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\");\n+  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\",\n+                                  Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,1 +48,2 @@\n-  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\");\n+  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\",\n+                                  Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,1 +43,2 @@\n-  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\");\n+  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\",\n+                                  Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1861,5 +1861,1 @@\n-      if (build_number >= 22000) {\n-        st->print(\"11\");\n-      } else {\n-        st->print(\"10\");\n-      }\n+      st->print(\"10\");\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,22 +50,0 @@\n-        .global aarch64_atomic_fetch_add_8_relaxed_default_impl\n-        .align 5\n-aarch64_atomic_fetch_add_8_relaxed_default_impl:\n-        prfm    pstl1strm, [x0]\n-0:      ldxr    x2, [x0]\n-        add     x8, x2, x1\n-        stxr    w9, x8, [x0]\n-        cbnz    w9, 0b\n-        mov     x0, x2\n-        ret\n-\n-        .global aarch64_atomic_fetch_add_4_relaxed_default_impl\n-        .align 5\n-aarch64_atomic_fetch_add_4_relaxed_default_impl:\n-        prfm    pstl1strm, [x0]\n-0:      ldxr    w2, [x0]\n-        add     w8, w2, w1\n-        stxr    w9, w8, [x0]\n-        cbnz    w9, 0b\n-        mov     w0, w2\n-        ret\n-\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.S","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,8 +90,3 @@\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_fetch_add_4_relaxed_impl; break;\n-  default:\n-    stub = aarch64_atomic_fetch_add_4_impl; break;\n-  }\n-  return atomic_fastcall(stub, dest, add_value);\n+  D old_value\n+    = atomic_fastcall(aarch64_atomic_fetch_add_4_impl, dest, add_value);\n+  return old_value;\n@@ -106,8 +101,3 @@\n-  aarch64_atomic_stub_t stub;\n-  switch (order) {\n-  case memory_order_relaxed:\n-    stub = aarch64_atomic_fetch_add_8_relaxed_impl; break;\n-  default:\n-    stub = aarch64_atomic_fetch_add_8_impl; break;\n-  }\n-  return atomic_fastcall(stub, dest, add_value);\n+  D old_value\n+    = atomic_fastcall(aarch64_atomic_fetch_add_8_impl, dest, add_value);\n+  return old_value;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.hpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1131,0 +1131,4 @@\n+  if (mapinfo->header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    mapinfo->set_header_base_archive_name_size(strlen(Arguments::GetSharedArchivePath()) + 1);\n+    mapinfo->set_header_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,11 +34,9 @@\n-  { \"GenericCDSFileMapHeader::_magic\",                     offset_of(GenericCDSFileMapHeader, _magic)          },\n-  { \"GenericCDSFileMapHeader::_crc\",                       offset_of(GenericCDSFileMapHeader, _crc)            },\n-  { \"GenericCDSFileMapHeader::_version\",                   offset_of(GenericCDSFileMapHeader, _version)        },\n-  { \"GenericCDSFileMapHeader::_header_size\",               offset_of(GenericCDSFileMapHeader, _header_size)    },\n-  { \"GenericCDSFileMapHeader::_base_archive_path_offset\",  offset_of(GenericCDSFileMapHeader, _base_archive_path_offset) },\n-  { \"GenericCDSFileMapHeader::_base_archive_name_size\",    offset_of(GenericCDSFileMapHeader, _base_archive_name_size)   },\n-  { \"CDSFileMapHeaderBase::_space[0]\",                     offset_of(CDSFileMapHeaderBase, _space)             },\n-  { \"FileMapHeader::_jvm_ident\",                           offset_of(FileMapHeader, _jvm_ident)                },\n-  { \"CDSFileMapRegion::_crc\",                              offset_of(CDSFileMapRegion, _crc)                   },\n-  { \"CDSFileMapRegion::_used\",                             offset_of(CDSFileMapRegion, _used)                  },\n-  { \"DynamicArchiveHeader::_base_region_crc\",              offset_of(DynamicArchiveHeader, _base_region_crc)   }\n+  { \"CDSFileMapHeaderBase::_magic\",           offset_of(CDSFileMapHeaderBase, _magic)           },\n+  { \"CDSFileMapHeaderBase::_crc\",             offset_of(CDSFileMapHeaderBase, _crc)             },\n+  { \"CDSFileMapHeaderBase::_version\",         offset_of(CDSFileMapHeaderBase, _version)         },\n+  { \"CDSFileMapHeaderBase::_space[0]\",        offset_of(CDSFileMapHeaderBase, _space)           },\n+  { \"FileMapHeader::_jvm_ident\",              offset_of(FileMapHeader, _jvm_ident)              },\n+  { \"FileMapHeader::_base_archive_name_size\", offset_of(FileMapHeader, _base_archive_name_size) },\n+  { \"CDSFileMapRegion::_crc\",                 offset_of(CDSFileMapRegion, _crc)                 },\n+  { \"CDSFileMapRegion::_used\",                offset_of(CDSFileMapRegion, _used)                },\n+  { \"DynamicArchiveHeader::_base_region_crc\", offset_of(DynamicArchiveHeader, _base_region_crc) }\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,3 +183,0 @@\n-  FileMapInfo* base_info = FileMapInfo::current_info();\n-  \/\/ header only be available after populate_header\n-  mapinfo->populate_header(base_info->core_region_alignment());\n@@ -188,0 +185,1 @@\n+  FileMapInfo* base_info = FileMapInfo::current_info();\n@@ -192,0 +190,1 @@\n+  _header->populate(base_info, base_info->core_region_alignment());\n@@ -329,1 +328,1 @@\n-                         \" [\" UINT32_FORMAT \" bytes header, \" SIZE_FORMAT \" bytes total]\",\n+                         \" [\" SIZE_FORMAT \" bytes header, \" SIZE_FORMAT \" bytes total]\",\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-#include \"runtime\/globals_extension.hpp\"\n@@ -173,1 +172,2 @@\n-  if (_is_static) {\n+  size_t header_size;\n+  if (is_static) {\n@@ -176,0 +176,1 @@\n+    header_size = sizeof(FileMapHeader);\n@@ -179,0 +180,1 @@\n+    header_size = sizeof(DynamicArchiveHeader);\n@@ -180,0 +182,5 @@\n+  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n+  memset((void*)_header, 0, header_size);\n+  _header->set_header_size(header_size);\n+  _header->set_version(INVALID_CDS_ARCHIVE_VERSION);\n+  _header->set_has_platform_or_app_classes(true);\n@@ -195,8 +202,6 @@\n-  assert(_header == NULL, \"Sanity check\");\n-  size_t c_header_size;\n-  size_t header_size;\n-  size_t base_archive_name_size = 0;\n-  size_t base_archive_path_offset = 0;\n-  if (is_static()) {\n-    c_header_size = sizeof(FileMapHeader);\n-    header_size = c_header_size;\n+  header()->populate(this, core_region_alignment);\n+}\n+\n+void FileMapHeader::populate(FileMapInfo* mapinfo, size_t core_region_alignment) {\n+  if (DynamicDumpSharedSpaces) {\n+    _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;\n@@ -204,33 +209,1 @@\n-    \/\/ dynamic header including base archive name for non-default base archive\n-    c_header_size = sizeof(DynamicArchiveHeader);\n-    header_size = c_header_size;\n-    if (!FLAG_IS_DEFAULT(SharedArchiveFile)) {\n-      base_archive_name_size = strlen(Arguments::GetSharedArchivePath()) + 1;\n-      header_size += base_archive_name_size;\n-      base_archive_path_offset = c_header_size;\n-    }\n-  }\n-  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n-  memset((void*)_header, 0, header_size);\n-  _header->populate(this,\n-                    core_region_alignment,\n-                    header_size,\n-                    base_archive_name_size,\n-                    base_archive_path_offset);\n-}\n-\n-void FileMapHeader::populate(FileMapInfo *info, size_t core_region_alignment,\n-                             size_t header_size, size_t base_archive_name_size,\n-                             size_t base_archive_path_offset) {\n-  \/\/ 1. We require _generic_header._magic to be at the beginning of the file\n-  \/\/ 2. FileMapHeader also assumes that _generic_header is at the beginning of the file\n-  assert(offset_of(FileMapHeader, _generic_header) == 0, \"must be\");\n-  set_header_size((unsigned int)header_size);\n-  set_base_archive_path_offset((unsigned int)base_archive_path_offset);\n-  set_base_archive_name_size((unsigned int)base_archive_name_size);\n-  set_magic(DynamicDumpSharedSpaces ? CDS_DYNAMIC_ARCHIVE_MAGIC : CDS_ARCHIVE_MAGIC);\n-  set_version(CURRENT_CDS_ARCHIVE_VERSION);\n-\n-  if (!info->is_static() && base_archive_name_size != 0) {\n-    \/\/ copy base archive name\n-    copy_base_archive_name(Arguments::GetSharedArchivePath());\n+    _magic = CDS_ARCHIVE_MAGIC;\n@@ -238,0 +211,1 @@\n+  _version = CURRENT_CDS_ARCHIVE_VERSION;\n@@ -274,0 +248,3 @@\n+  \/\/ the following 2 fields will be set in write_header for dynamic archive header\n+  _base_archive_name_size = 0;\n+  _base_archive_is_default = false;\n@@ -276,1 +253,1 @@\n-    set_shared_path_table(info->_shared_path_table);\n+    set_shared_path_table(mapinfo->_shared_path_table);\n@@ -281,7 +258,0 @@\n-void FileMapHeader::copy_base_archive_name(const char* archive) {\n-  assert(base_archive_name_size() != 0, \"_base_archive_name_size not set\");\n-  assert(base_archive_path_offset() != 0, \"_base_archive_path_offset not set\");\n-  assert(header_size() > sizeof(*this), \"_base_archive_name_size not included in header size?\");\n-  memcpy((char*)this + base_archive_path_offset(), archive, base_archive_name_size());\n-}\n-\n@@ -291,6 +261,3 @@\n-  st->print_cr(\"- magic:                          0x%08x\", magic());\n-  st->print_cr(\"- crc:                            0x%08x\", crc());\n-  st->print_cr(\"- version:                        %d\", version());\n-  st->print_cr(\"- header_size:                    \" UINT32_FORMAT, header_size());\n-  st->print_cr(\"- base_archive_path_offset:       \" UINT32_FORMAT, base_archive_path_offset());\n-  st->print_cr(\"- base_archive_name_size:         \" UINT32_FORMAT, base_archive_name_size());\n+  st->print_cr(\"- magic:                          0x%08x\", _magic);\n+  st->print_cr(\"- crc:                            0x%08x\", _crc);\n+  st->print_cr(\"- version:                        %d\", _version);\n@@ -304,0 +271,1 @@\n+  st->print_cr(\"- header_size:                    \" SIZE_FORMAT, _header_size);\n@@ -318,0 +286,1 @@\n+  st->print_cr(\"- base_archive_is_default:        %d\", _base_archive_is_default);\n@@ -319,0 +288,1 @@\n+  st->print_cr(\"- base_archive_name_size:         \" SIZE_FORMAT, _base_archive_name_size);\n@@ -1045,62 +1015,0 @@\n-\/\/ a utility class for checking file header\n-class FileHeaderHelper {\n-  int _fd;\n-  GenericCDSFileMapHeader _header;\n-\n-public:\n-  FileHeaderHelper() {\n-    _fd = -1;\n-  }\n-\n-  ~FileHeaderHelper() {\n-    if (_fd != -1) {\n-      os::close(_fd);\n-    }\n-  }\n-\n-  bool initialize(const char* archive_name) {\n-    _fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-    if (_fd < 0) {\n-      return false;\n-    }\n-    return initialize(_fd);\n-  }\n-\n-  \/\/ for an already opened file, do not set _fd\n-  bool initialize(int fd) {\n-    assert(fd != -1, \"Archive should be opened\");\n-    size_t size = sizeof(GenericCDSFileMapHeader);\n-    lseek(fd, 0, SEEK_SET);\n-    size_t n = os::read(fd, (void*)&_header, (unsigned int)size);\n-    if (n != size) {\n-      vm_exit_during_initialization(\"Unable to read generic CDS file map header from shared archive\");\n-      return false;\n-    }\n-    return true;\n-  }\n-\n-  GenericCDSFileMapHeader* get_generic_file_header() {\n-    return &_header;\n-  }\n-\n-  bool read_base_archive_name(char** target) {\n-    assert(_fd != -1, \"Archive should be open\");\n-    size_t name_size = (size_t)_header._base_archive_name_size;\n-    assert(name_size != 0, \"For non-default base archive, name size should be non-zero!\");\n-    *target = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n-    lseek(_fd, _header._base_archive_path_offset, SEEK_SET); \/\/ position to correct offset.\n-    size_t n = os::read(_fd, *target, (unsigned int)name_size);\n-    if (n != name_size) {\n-      log_info(cds)(\"Unable to read base archive name from archive\");\n-      FREE_C_HEAP_ARRAY(char, *target);\n-      return false;\n-    }\n-    if (!os::file_exists(*target)) {\n-      log_info(cds)(\"Base archive %s does not exist\", *target);\n-      FREE_C_HEAP_ARRAY(char, *target);\n-      return false;\n-    }\n-    return true;\n-  }\n-};\n-\n@@ -1108,2 +1016,2 @@\n-  FileHeaderHelper file_helper;\n-  if (!file_helper.initialize(archive_name)) {\n+  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+  if (fd < 0) {\n@@ -1116,1 +1024,10 @@\n-  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n+  size_t sz = is_static ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n+  void* header = os::malloc(sz, mtInternal);\n+  memset(header, 0, sz);\n+  size_t n = os::read(fd, header, (unsigned int)sz);\n+  if (n != sz) {\n+    os::free(header);\n+    os::close(fd);\n+    vm_exit_during_initialization(\"Unable to read header from shared archive\", archive_name);\n+    return false;\n+  }\n@@ -1118,1 +1035,4 @@\n-    if (header->_magic != CDS_ARCHIVE_MAGIC) {\n+    FileMapHeader* static_header = (FileMapHeader*)header;\n+    if (static_header->magic() != CDS_ARCHIVE_MAGIC) {\n+      os::free(header);\n+      os::close(fd);\n@@ -1122,5 +1042,0 @@\n-    if (header->_base_archive_path_offset != 0) {\n-      log_info(cds)(\"_base_archive_path_offset should be 0\");\n-      log_info(cds)(\"_base_archive_path_offset = \" UINT32_FORMAT, header->_base_archive_path_offset);\n-      return false;\n-    }\n@@ -1128,1 +1043,4 @@\n-    if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)header;\n+    if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+      os::free(header);\n+      os::close(fd);\n@@ -1132,15 +1050,0 @@\n-    unsigned int name_size = header->_base_archive_name_size;\n-    unsigned int path_offset = header->_base_archive_path_offset;\n-    unsigned int header_size = header->_header_size;\n-    if (path_offset + name_size != header_size) {\n-      log_info(cds)(\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\");\n-      log_info(cds)(\"  _base_archive_name_size   = \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"  _base_archive_path_offset = \" UINT32_FORMAT, path_offset);\n-      log_info(cds)(\"  _header_size              = \" UINT32_FORMAT, header_size);\n-      return false;\n-    }\n-    char* base_name = NULL;\n-    if (!file_helper.read_base_archive_name(&base_name)) {\n-      return false;\n-    }\n-    FREE_C_HEAP_ARRAY(char, base_name);\n@@ -1148,0 +1051,2 @@\n+  os::free(header);\n+  os::close(fd);\n@@ -1152,3 +1057,4 @@\n-                                                    char** base_archive_name) {\n-  FileHeaderHelper file_helper;\n-  if (!file_helper.initialize(archive_name)) {\n+                                                    int* size, char** base_archive_name) {\n+  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+  if (fd < 0) {\n+    *size = 0;\n@@ -1157,3 +1063,9 @@\n-  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n-  if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    \/\/ Not a dynamic header, no need to proceed further.\n+\n+  \/\/ read the header as a dynamic archive header\n+  size_t sz = sizeof(DynamicArchiveHeader);\n+  DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)os::malloc(sz, mtInternal);\n+  size_t n = os::read(fd, dynamic_header, (unsigned int)sz);\n+  if (n != sz) {\n+    fail_continue(\"Unable to read the file header.\");\n+    os::free(dynamic_header);\n+    os::close(fd);\n@@ -1162,4 +1074,5 @@\n-\n-  if ((header->_base_archive_name_size == 0 && header->_base_archive_path_offset != 0) ||\n-      (header->_base_archive_name_size != 0 && header->_base_archive_path_offset == 0)) {\n-    fail_continue(\"Default base archive not set correct\");\n+  if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    \/\/ Not a dynamic header, no need to proceed further.\n+    *size = 0;\n+    os::free(dynamic_header);\n+    os::close(fd);\n@@ -1168,2 +1081,1 @@\n-  if (header->_base_archive_name_size == 0 &&\n-      header->_base_archive_path_offset == 0) {\n+  if (dynamic_header->base_archive_is_default()) {\n@@ -1173,1 +1085,11 @@\n-    if (!file_helper.read_base_archive_name(base_archive_name)) {\n+    size_t name_size = dynamic_header->base_archive_name_size();\n+    if (name_size == 0) {\n+      os::free(dynamic_header);\n+      os::close(fd);\n+      return false;\n+    }\n+    *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n+    n = os::read(fd, *base_archive_name, (unsigned int)name_size);\n+    if (n != name_size) {\n+      fail_continue(\"Unable to read the base archive name from the header.\");\n+      FREE_C_HEAP_ARRAY(char, *base_archive_name);\n@@ -1175,0 +1097,2 @@\n+      os::free(dynamic_header);\n+      os::close(fd);\n@@ -1178,0 +1102,3 @@\n+\n+  os::free(dynamic_header);\n+  os::close(fd);\n@@ -1184,2 +1111,3 @@\n-  FileHeaderHelper file_helper;\n-  if (!file_helper.initialize(fd)) {\n+  size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n+  size_t n = os::read(fd, header(), (unsigned int)sz);\n+  if (n != sz) {\n@@ -1189,1 +1117,0 @@\n-  GenericCDSFileMapHeader* gen_header = file_helper.get_generic_file_header();\n@@ -1191,5 +1118,2 @@\n-  unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;\n-  if (gen_header->_magic != expected_magic) {\n-    log_info(cds)(\"_magic expected: 0x%08x\", expected_magic);\n-    log_info(cds)(\"         actual: 0x%08x\", gen_header->_magic);\n-    FileMapInfo::fail_continue(\"The shared archive file has a bad magic number.\");\n+  if (!Arguments::has_jimage()) {\n+    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n@@ -1199,6 +1123,5 @@\n-  _header = (FileMapHeader*)os::malloc(gen_header->_header_size, mtInternal);\n-  lseek(fd, 0, SEEK_SET); \/\/ reset to begin of the archive\n-  size_t size = gen_header->_header_size;\n-  size_t n = os::read(fd, (void*)_header, (unsigned int)size);\n-  if (n != size) {\n-    fail_continue(\"Failed to read file header from the top archive file\\n\");\n+  unsigned int expected_magic = is_static() ? CDS_ARCHIVE_MAGIC : CDS_DYNAMIC_ARCHIVE_MAGIC;\n+  if (header()->magic() != expected_magic) {\n+    log_info(cds)(\"_magic expected: 0x%08x\", expected_magic);\n+    log_info(cds)(\"         actual: 0x%08x\", header()->magic());\n+    FileMapInfo::fail_continue(\"The shared archive file has a bad magic number.\");\n@@ -1215,11 +1138,5 @@\n-  unsigned int base_offset = header()->base_archive_path_offset();\n-  unsigned int name_size = header()->base_archive_name_size();\n-  unsigned int header_size = header()->header_size();\n-  if (base_offset != 0 && name_size != 0) {\n-    if (header_size != base_offset + name_size) {\n-      log_info(cds)(\"_header_size: \" UINT32_FORMAT, header_size);\n-      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n-      log_info(cds)(\"base_archive_path_offset: \" UINT32_FORMAT, base_offset);\n-      FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n-      return false;\n-    }\n+  if (header()->header_size() != sz) {\n+    log_info(cds)(\"_header_size expected: \" SIZE_FORMAT, sz);\n+    log_info(cds)(\"               actual: \" SIZE_FORMAT, header()->header_size());\n+    FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n+    return false;\n@@ -1255,1 +1172,1 @@\n-  _file_offset = header()->header_size(); \/\/ accounts for the size of _base_archive_name\n+  _file_offset = n + header()->base_archive_name_size(); \/\/ accounts for the size of _base_archive_name\n@@ -1339,0 +1256,3 @@\n+  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    header_bytes += strlen(Arguments::GetSharedArchivePath()) + 1;\n+  }\n@@ -1345,0 +1265,1 @@\n+\n@@ -1352,0 +1273,7 @@\n+\n+  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    char* base_archive_name = (char*)Arguments::GetSharedArchivePath();\n+    if (base_archive_name != NULL) {\n+      write_bytes(base_archive_name, header()->base_archive_name_size());\n+    }\n+  }\n@@ -2295,5 +2223,0 @@\n-  if (!Arguments::has_jimage()) {\n-    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n-    return false;\n-  }\n-\n@@ -2338,3 +2261,3 @@\n-  \/\/ start computing from the field after _crc to end of base archive name.\n-  char* buf = (char*)&(_generic_header._crc) + sizeof(_generic_header._crc);\n-  size_t sz = header_size() - (buf - start);\n+  \/\/ start computing from the field after _crc\n+  char* buf = (char*)&_crc + sizeof(_crc);\n+  size_t sz = _header_size - (buf - start);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":114,"deletions":191,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -187,0 +187,2 @@\n+  size_t _header_size;\n+\n@@ -204,0 +206,1 @@\n+  bool _base_archive_is_default;    \/\/ indicates if the base archive is the system default one\n@@ -210,0 +213,2 @@\n+  \/\/ size of the base archive name including NULL terminator\n+  size_t _base_archive_name_size;\n@@ -241,14 +246,9 @@\n-  \/\/ Accessors -- fields declared in GenericCDSFileMapHeader\n-  unsigned int magic()                    const { return _generic_header._magic;    }\n-  int crc()                               const { return _generic_header._crc;      }\n-  int version()                           const { return _generic_header._version;  }\n-  unsigned int header_size()              const { return _generic_header._header_size;              }\n-  unsigned int base_archive_path_offset() const { return _generic_header._base_archive_path_offset; }\n-  unsigned int base_archive_name_size()   const { return _generic_header._base_archive_name_size;   }\n-\n-  void set_magic(unsigned int m)                    { _generic_header._magic = m;       }\n-  void set_crc(int crc_value)                       { _generic_header._crc = crc_value; }\n-  void set_version(int v)                           { _generic_header._version = v;     }\n-  void set_header_size(unsigned int s)              { _generic_header._header_size = s;              }\n-  void set_base_archive_path_offset(unsigned int s) { _generic_header._base_archive_path_offset = s; }\n-  void set_base_archive_name_size(unsigned int s)   { _generic_header._base_archive_name_size = s;   }\n+  \/\/ Accessors -- fields declared in CDSFileMapHeaderBase\n+  unsigned int magic()                    const { return _magic; }\n+  int crc()                               const { return _crc; }\n+  int version()                           const { return _version; }\n+\n+  void set_crc(int crc_value)                   { _crc = crc_value; }\n+  void set_version(int v)                       { _version = v; }\n+\n+  \/\/ Accessors -- fields declared in FileMapHeader\n@@ -256,0 +256,1 @@\n+  size_t header_size()                     const { return _header_size; }\n@@ -269,0 +270,1 @@\n+  bool base_archive_is_default()           const { return _base_archive_is_default; }\n@@ -270,0 +272,1 @@\n+  size_t base_archive_name_size()          const { return _base_archive_name_size; }\n@@ -287,0 +290,3 @@\n+  void set_base_archive_name_size(size_t s)      { _base_archive_name_size = s; }\n+  void set_base_archive_is_default(bool b)       { _base_archive_is_default = b; }\n+  void set_header_size(size_t s)                 { _header_size = s; }\n@@ -290,1 +296,0 @@\n-  void copy_base_archive_name(const char* name);\n@@ -315,2 +320,2 @@\n-  void populate(FileMapInfo *info, size_t core_region_alignment, size_t header_size,\n-                size_t base_archive_name_size, size_t base_archive_path_offset);\n+  void populate(FileMapInfo* info, size_t core_region_alignment);\n+\n@@ -361,1 +366,1 @@\n-                                                char** base_archive_name);\n+                                                int* size, char** base_archive_name);\n@@ -396,0 +401,3 @@\n+  void   set_header_base_archive_name_size(size_t size)      { header()->set_base_archive_name_size(size); }\n+  void   set_header_base_archive_is_default(bool is_default) { header()->set_base_archive_is_default(is_default); }\n+\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":26,"deletions":18,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-  GrowableArray<OopHandle> _loaded_cld_handles; \/\/ keep the CLDs alive\n+  GrowableArray<Handle> _loaded_cld_handles; \/\/ keep the CLDs alive\n@@ -592,2 +592,2 @@\n-    for (int i = 0; i < _loaded_cld_handles.length(); i++) {\n-      _loaded_cld_handles.at(i).release(Universe::vm_global());\n+    for (int i = 0; i < _loaded_cld.length(); i++) {\n+      ClassLoaderData* cld = _loaded_cld.at(i);\n@@ -597,3 +597,4 @@\n-    assert(cld->is_alive(), \"must be\");\n-    _loaded_cld.append(cld);\n-    _loaded_cld_handles.append(OopHandle(Universe::vm_global(), cld->holder_phantom()));\n+    if (!cld->is_unloading()) {\n+      _loaded_cld.append(cld);\n+      _loaded_cld_handles.append(Handle(_current_thread, cld->holder_phantom()));\n+    }\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -137,1 +136,2 @@\n-  _metaspace_lock(new Mutex(Mutex::nosafepoint-2, \"MetaspaceAllocation_lock\")),\n+  _metaspace_lock(new Mutex(Mutex::nosafepoint-2, \"MetaspaceAllocation_lock\",\n+                            Mutex::_safepoint_check_never)),\n@@ -888,2 +888,0 @@\n-      \/\/ But still have to remove it from the dumptime_table.\n-      SystemDictionaryShared::handle_class_unloading(ik);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,0 +429,15 @@\n+\/\/ Walk classes in the loaded class dictionaries in various forms.\n+\/\/ Only walks the classes defined in this class loader.\n+void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*)) {\n+  FOR_ALL_DICTIONARY(cld) {\n+    cld->dictionary()->classes_do(f);\n+  }\n+}\n+\n+\/\/ Only walks the classes defined in this class loader.\n+void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {\n+  FOR_ALL_DICTIONARY(cld) {\n+    cld->dictionary()->classes_do(f, CHECK);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -99,0 +99,7 @@\n+  \/\/ dictionary do\n+  \/\/ Iterate over all klasses in dictionary, but\n+  \/\/ just the classes from defining class loaders.\n+  static void dictionary_classes_do(void f(InstanceKlass*));\n+  \/\/ Added for initialize_itable_for_klass to handle exceptions.\n+  static void dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS);\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4223,2 +4223,2 @@\n-  nmethodBucket* volatile* vmdeps_addr = call_site->field_addr<nmethodBucket* volatile>(_vmdependencies_offset);\n-  volatile uint64_t* last_cleanup_addr = call_site->field_addr<volatile uint64_t>(_last_cleanup_offset);\n+  nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site->field_addr(_vmdependencies_offset);\n+  volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site->field_addr(_last_cleanup_offset);\n@@ -4282,1 +4282,1 @@\n-  return Atomic::load_acquire(loader->field_addr<ClassLoaderData*>(_loader_data_offset));\n+  return HeapAccess<MO_ACQUIRE>::load_at(loader, _loader_data_offset);\n@@ -4288,1 +4288,1 @@\n-  return *loader->field_addr<ClassLoaderData*>(_loader_data_offset);\n+  return HeapAccess<>::load_at(loader, _loader_data_offset);\n@@ -4294,1 +4294,1 @@\n-  Atomic::release_store(loader->field_addr<ClassLoaderData*>(_loader_data_offset), new_data);\n+  HeapAccess<MO_RELEASE>::store_at(loader, _loader_data_offset, new_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  return java_string->field_addr<uint8_t>(_flags_offset);\n+  return java_string->obj_field_addr<uint8_t>(_flags_offset);\n@@ -149,1 +149,1 @@\n-  return ref->field_addr<HeapWord>(_referent_offset);\n+  return ref->obj_field_addr<HeapWord>(_referent_offset);\n@@ -165,1 +165,1 @@\n-  return ref->field_addr<HeapWord>(_next_offset);\n+  return ref->obj_field_addr<HeapWord>(_next_offset);\n@@ -181,1 +181,1 @@\n-  return ref->field_addr<HeapWord>(_discovered_offset);\n+  return ref->obj_field_addr<HeapWord>(_discovered_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -656,6 +656,1 @@\n-    if (verbose && st == tty) {\n-      \/\/ verbose is only ever true when called from findpc in debug.cpp\n-      nm->print_nmethod(true);\n-    } else {\n-      nm->print(st);\n-    }\n+    nm->print_nmethod(verbose);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -927,1 +926,1 @@\n-      CompileTask::print(st, this, msg, \/*short_form:*\/ false, \/* cr *\/ true, \/* timestamp *\/ false);\n+      CompileTask::print(st, this, msg, \/*short_form:*\/ false);\n@@ -2532,1 +2531,1 @@\n-  print_on(st, NULL);\n+  print_on(tty, NULL);\n@@ -2883,3 +2882,0 @@\n-  \/\/ Decoding an nmethod can write to a PcDescCache (see PcDescCache::add_pc_desc)\n-  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n-\n@@ -2895,1 +2891,0 @@\n-    st->print_cr(\"[Disassembly]\");\n@@ -2897,2 +2892,0 @@\n-    st->bol();\n-    st->print_cr(\"[\/Disassembly]\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                             const char* msg, bool short_form, bool cr, bool timestamp,\n+                             const char* msg, bool short_form, bool cr,\n@@ -242,4 +242,2 @@\n-    if (timestamp) {\n-      \/\/ Print current time\n-      st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n-    }\n+    \/\/ Print current time\n+    st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    _lock = new Monitor(Mutex::safepoint, \"CompileTask_lock\");\n+    _lock = new Monitor(Mutex::nonleaf, \"CompileTask_lock\", Mutex::_safepoint_check_always);\n@@ -190,1 +190,1 @@\n-                                      const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true,\n+                                      const char* msg = NULL, bool short_form = false, bool cr = true,\n@@ -196,1 +196,1 @@\n-  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true) {\n+  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {\n@@ -199,1 +199,1 @@\n-                           msg, short_form, cr, timestamp);\n+                           msg, short_form, cr);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-    ((nmethod*)cb)->decode2(st);\n+    decode((nmethod*)cb, st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,0 +478,1 @@\n+      _summary_bytes_used += fill_size * HeapWordSize;\n@@ -497,0 +498,1 @@\n+  _summary_bytes_used += word_size * HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,0 +226,3 @@\n+  \/\/ The number of bytes used in the current range.\n+  size_t _summary_bytes_used;\n+\n@@ -243,0 +246,1 @@\n+    _summary_bytes_used(0),\n@@ -260,0 +264,13 @@\n+\n+  \/\/ The number of bytes allocated by this allocator.\n+  size_t used() {\n+    return _summary_bytes_used;\n+  }\n+\n+  \/\/ Clear the count of bytes allocated in prior G1 regions. This\n+  \/\/ must be done when recalculate_use is used to reset the counter\n+  \/\/ for the generic allocator, since it counts bytes in all G1\n+  \/\/ regions, including those still associated with this allocator.\n+  void clear_used() {\n+    _summary_bytes_used = 0;\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -501,2 +501,3 @@\n-  assert(_archive_allocator == nullptr, \"should not be initialized\");\n-  _archive_allocator = G1ArchiveAllocator::create_allocator(this, open);\n+  if (_archive_allocator == NULL) {\n+    _archive_allocator = G1ArchiveAllocator::create_allocator(this, open);\n+  }\n@@ -514,1 +515,1 @@\n-  assert(_archive_allocator != nullptr, \"_archive_allocator not initialized\");\n+  assert(_archive_allocator != NULL, \"_archive_allocator not initialized\");\n@@ -516,1 +517,1 @@\n-    return nullptr;\n+    return NULL;\n@@ -524,1 +525,1 @@\n-  assert(_archive_allocator != nullptr, \"_archive_allocator not initialized\");\n+  assert(_archive_allocator != NULL, \"_archive_allocator not initialized\");\n@@ -530,1 +531,1 @@\n-  _archive_allocator = nullptr;\n+  _archive_allocator = NULL;\n@@ -1451,1 +1452,1 @@\n-  _archive_allocator(nullptr),\n+  _archive_allocator(NULL),\n@@ -1863,1 +1864,3 @@\n-  assert(_archive_allocator == nullptr, \"must be, should not contribute to used\");\n+  if (_archive_allocator != NULL) {\n+    result += _archive_allocator->used();\n+  }\n@@ -3197,1 +3200,3 @@\n-    assert(_archive_allocator == nullptr, \"must be, should not contribute to used\");\n+    if (_archive_allocator != NULL) {\n+      _archive_allocator->clear_used();\n+    }\n@@ -3391,1 +3396,3 @@\n-    assert(_archive_allocator == nullptr, \"must be, should not contribute to used\");\n+    if (_archive_allocator != NULL) {\n+      _archive_allocator->clear_used();\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":17,"deletions":10,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  bool in_mixed_phase() const { return !_in_young_only_phase && !_in_full_gc; }\n+  bool in_mixed_phase() const { return !in_young_only_phase() && !_in_full_gc; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectorState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-    _lock(Mutex::service-3, \"G1Mapper_lock\") {\n+    _lock(Mutex::service-3, \"G1Mapper_lock\", Mutex::_safepoint_check_never) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,3 @@\n-    _monitor(Mutex::nosafepoint, \"G1ServiceThread_lock\"),\n+    _monitor(Mutex::nosafepoint,\n+             \"G1ServiceThread_lock\",\n+             Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\"),\n+  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\", Mutex::_safepoint_check_never),\n@@ -614,0 +614,2 @@\n+          LogStream ls(log.error());\n+          to->rem_set()->print_info(&ls, p);\n@@ -618,1 +620,0 @@\n-          LogStream ls(log.error());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  _m(Mutex::service - 1, FormatBuffer<128>(\"HeapRegionRemSet#%u_lock\", hr->hrm_index())),\n+  _m(Mutex::service - 1, FormatBuffer<128>(\"HeapRegionRemSet#%u_lock\", hr->hrm_index()), Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-  _shadow_region_monitor = new Monitor(Mutex::nosafepoint, \"CompactionManager_lock\");\n+  _shadow_region_monitor = new Monitor(Mutex::nosafepoint, \"CompactionManager_lock\",\n+                                       Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-                    \"GCLogPrecious Lock\");\n+                    \"GCLogPrecious Lock\",\n+                    Mutex::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-                                    Mutex::Rank rank) {\n+                                    int rank) {\n@@ -817,1 +817,1 @@\n-  return new PaddedMutex(rank, name);\n+  return new PaddedMutex(rank, name, Mutex::_safepoint_check_never);\n@@ -847,0 +847,4 @@\n+  assert(_active_mutex->_safepoint_check_required == Mutex::_safepoint_check_never,\n+         \"%s: active mutex requires never safepoint check\", _name);\n+  assert(_allocation_mutex->_safepoint_check_required == Mutex::_safepoint_check_never,\n+         \"%s: allocation mutex requires never safepoint check\", _name);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -776,1 +776,2 @@\n-  _par_alloc_lock(Mutex::safepoint, \"OffsetTableContigSpaceParAlloc_lock\", true)\n+  _par_alloc_lock(Mutex::nonleaf, \"OffsetTableContigSpaceParAlloc_lock\",\n+                  Mutex::_safepoint_check_always, true)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  _blocker(Mutex::nosafepoint, \"TaskTerminator_lock\"),\n+  _blocker(Mutex::nosafepoint, \"TaskTerminator_lock\", Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/gc\/shared\/taskTerminator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,1 +248,2 @@\n-  : _monitor(Mutex::nosafepoint, \"WorkGangBarrierSync_lock\"),\n+  : _monitor(Mutex::nosafepoint, \"WorkGangBarrierSync_lock\",\n+             Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,2 +53,0 @@\n-private:\n-  const GCCause::Cause _cause;\n@@ -56,5 +54,2 @@\n-  ShenandoahBreakpointGCScope(GCCause::Cause cause) : _cause(cause) {\n-    if (cause == GCCause::_wb_breakpoint) {\n-      ShenandoahBreakpoint::start_gc();\n-      ShenandoahBreakpoint::at_before_gc();\n-    }\n+  ShenandoahBreakpointGCScope() {\n+    ShenandoahBreakpoint::at_before_gc();\n@@ -64,3 +59,1 @@\n-    if (_cause == GCCause::_wb_breakpoint) {\n-      ShenandoahBreakpoint::at_after_gc();\n-    }\n+    ShenandoahBreakpoint::at_after_gc();\n@@ -71,2 +64,0 @@\n-private:\n-  const GCCause::Cause _cause;\n@@ -74,4 +65,2 @@\n-  ShenandoahBreakpointMarkScope(GCCause::Cause cause) : _cause(cause) {\n-    if (_cause == GCCause::_wb_breakpoint) {\n-      ShenandoahBreakpoint::at_after_marking_started();\n-    }\n+  ShenandoahBreakpointMarkScope() {\n+    ShenandoahBreakpoint::at_after_marking_started();\n@@ -81,3 +70,1 @@\n-    if (_cause == GCCause::_wb_breakpoint) {\n-      ShenandoahBreakpoint::at_before_marking_completed();\n-    }\n+    ShenandoahBreakpoint::at_before_marking_completed();\n@@ -102,1 +89,4 @@\n-  ShenandoahBreakpointGCScope breakpoint_gc_scope(cause);\n+  if (cause == GCCause::_wb_breakpoint) {\n+    ShenandoahBreakpoint::start_gc();\n+  }\n+  ShenandoahBreakpointGCScope breakpoint_gc_scope;\n@@ -111,1 +101,1 @@\n-    ShenandoahBreakpointMarkScope breakpoint_mark_scope(cause);\n+    ShenandoahBreakpointMarkScope breakpoint_mark_scope;\n@@ -670,3 +660,1 @@\n-  if (heap->gc_cause() == GCCause::_wb_breakpoint) {\n-    ShenandoahBreakpoint::at_after_reference_processing_started();\n-  }\n+  ShenandoahBreakpoint::at_after_reference_processing_started();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  _alloc_failure_waiters_lock(Mutex::safepoint-1, \"ShenandoahAllocFailureGC_lock\", true),\n-  _gc_waiters_lock(Mutex::safepoint-1, \"ShenandoahRequestedGC_lock\", true),\n+  _alloc_failure_waiters_lock(Mutex::nonleaf, \"ShenandoahAllocFailureGC_lock\", Monitor::_safepoint_check_always, true),\n+  _gc_waiters_lock(Mutex::nonleaf, \"ShenandoahRequestedGC_lock\", Monitor::_safepoint_check_always, true),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-          _wait_monitor(new Monitor(Mutex::safepoint-1, \"ShenandoahWaitMonitor_lock\", true)),\n+          _wait_monitor(new Monitor(Mutex::nonleaf-1, \"ShenandoahWaitMonitor_lock\", Monitor::_safepoint_check_always, true)),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,3 @@\n-    _monitor(Monitor::nosafepoint, \"ZMessagePort_lock\"),\n+    _monitor(Monitor::nosafepoint,\n+             \"ZMessagePort_lock\",\n+             Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/gc\/z\/zMessagePort.inline.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    _monitor(Monitor::nosafepoint, \"ZMetronome_lock\"),\n+    _monitor(Monitor::nosafepoint, \"ZMetronome_lock\", Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/gc\/z\/zMetronome.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,2 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 12\n+#define CURRENT_CDS_ARCHIVE_VERSION 11\n+#define INVALID_CDS_ARCHIVE_VERSION -1\n@@ -43,1 +44,1 @@\n-typedef struct CDSFileMapRegion {\n+struct CDSFileMapRegion {\n@@ -60,1 +61,1 @@\n-} CDSFileMapRegion;\n+};\n@@ -62,21 +63,6 @@\n-\/\/ This portion of the archive file header must remain unchanged for _version >= 12.\n-\/\/ This makes it possible to read important information from a CDS archive created by\n-\/\/ a different version of HotSpot, so that we can automatically regenerate the archive as necessary.\n-typedef struct GenericCDSFileMapHeader {\n-  unsigned int _magic;                    \/\/ identification of file type\n-  int          _crc;                      \/\/ header crc checksum\n-  int          _version;                  \/\/ CURRENT_CDS_ARCHIVE_VERSION of the jdk that dumped the this archive\n-  unsigned int _header_size;              \/\/ total size of the header, in bytes\n-  unsigned int _base_archive_path_offset; \/\/ offset where the base archive name is stored\n-                                          \/\/   static archive:  0\n-                                          \/\/   dynamic archive:\n-                                          \/\/     0 for default base archive\n-                                          \/\/     non-zero for non-default base archive\n-                                          \/\/       (char*)this + _base_archive_path_offset\n-                                          \/\/       points to a 0-terminated string for the base archive name\n-  unsigned int _base_archive_name_size;   \/\/ size of base archive name including ending '\\0'\n-                                          \/\/   static:  0\n-                                          \/\/   dynamic:\n-                                          \/\/     0 for default base archive\n-                                          \/\/     non-zero for non-default base archive\n-} GenericCDSFileMapHeader;\n+struct CDSFileMapHeaderBase {\n+  unsigned int _magic;           \/\/ identify file type\n+  int          _crc;             \/\/ header crc checksum\n+  int          _version;         \/\/ must be CURRENT_CDS_ARCHIVE_VERSION\n+  struct CDSFileMapRegion _space[NUM_CDS_REGIONS];\n+};\n@@ -84,8 +70,1 @@\n-\/\/ This type is used by the Serviceability Agent to access the contents of\n-\/\/ a memory-mapped CDS archive.\n-typedef struct CDSFileMapHeaderBase {\n-  \/\/ We cannot inherit from GenericCDSFileMapHeader as this type may be used\n-  \/\/ by both C and C++ code.\n-  GenericCDSFileMapHeader _generic_header;\n-  CDSFileMapRegion _space[NUM_CDS_REGIONS];\n-} CDSFileMapHeaderBase;\n+typedef struct CDSFileMapHeaderBase CDSFileMapHeaderBase;\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":11,"deletions":32,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-      return *base->field_addr<jtypename>(className::_##name##_offset);                                                   \\\n+      return HeapAccess<>::load_at(base, className::_##name##_offset);                                                    \\\n@@ -240,1 +240,1 @@\n-      *base->field_addr<jtypename>(className::_##name##_offset) = x;                                                      \\\n+      HeapAccess<>::store_at(base, _##name##_offset, x);                                                                  \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-      _mutex(Mutex::nosafepoint, \"ParHeapInspectTask_lock\") {}\n+      _mutex(Mutex::nosafepoint, \"ParHeapInspectTask_lock\", Mutex::_safepoint_check_never) {}\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  Mutex* lock = new Mutex(Monitor::nosafepoint, \"MetaspaceTestArea_lock\");\n+  Mutex* lock = new Mutex(Monitor::nosafepoint, \"MetaspaceTestArea_lock\", Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -526,1 +526,0 @@\n-static void reinitialize_itables() {\n@@ -528,8 +527,4 @@\n-  class ReinitTableClosure : public KlassClosure {\n-   public:\n-    void do_klass(Klass* k) {\n-      if (k->is_instance_klass()) {\n-         InstanceKlass::cast(k)->itable().initialize_itable();\n-      }\n-    }\n-  };\n+static void initialize_itable_for_klass(InstanceKlass* k) {\n+  k->itable().initialize_itable();\n+}\n+\n@@ -537,0 +532,1 @@\n+static void reinitialize_itables() {\n@@ -538,2 +534,1 @@\n-  ReinitTableClosure cl;\n-  ClassLoaderDataGraph::classes_do(&cl);\n+  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":11,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  T* p         = obj->field_addr<T>(map->offset());\n+  T* p         = (T*)obj->obj_field_addr<T>(map->offset());\n@@ -97,1 +97,1 @@\n-  T* const start = obj->field_addr<T>(map->offset());\n+  T* const start = (T*)obj->obj_field_addr<T>(map->offset());\n@@ -108,1 +108,1 @@\n-  T* p   = obj->field_addr<T>(map->offset());\n+  T* p   = (T*)obj->obj_field_addr<T>(map->offset());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1210,1 +1210,1 @@\n-    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n+    _extra_data_lock(Mutex::nonleaf-2, \"MDOExtraData_lock\", Mutex::_safepoint_check_always),\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,2 @@\n-address oopDesc::address_field(int offset) const                      { return *field_addr<address>(offset); }\n-address oopDesc::address_field_acquire(int offset) const              { return Atomic::load_acquire(field_addr<address>(offset)); }\n+address oopDesc::address_field(int offset) const                      { return HeapAccess<>::load_at(as_oop(), offset); }\n+address oopDesc::address_field_acquire(int offset) const              { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n@@ -185,2 +185,2 @@\n-void oopDesc::address_field_put(int offset, address value)            { *field_addr<address>(offset) = value; }\n-void oopDesc::release_address_field_put(int offset, address value)    { Atomic::release_store(field_addr<address>(offset), value); }\n+void oopDesc::address_field_put(int offset, address value)            { HeapAccess<>::store_at(as_oop(), offset, value); }\n+void oopDesc::release_address_field_put(int offset, address value)    { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -188,2 +188,2 @@\n-Metadata* oopDesc::metadata_field(int offset) const                   { return *field_addr<Metadata*>(offset); }\n-void oopDesc::metadata_field_put(int offset, Metadata* value)         { *field_addr<Metadata*>(offset) = value; }\n+Metadata* oopDesc::metadata_field(int offset) const                   { return HeapAccess<>::load_at(as_oop(), offset); }\n+void oopDesc::metadata_field_put(int offset, Metadata* value)         { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -191,2 +191,2 @@\n-Metadata* oopDesc::metadata_field_acquire(int offset) const           { return Atomic::load_acquire(field_addr<Metadata*>(offset)); }\n-void oopDesc::release_metadata_field_put(int offset, Metadata* value) { Atomic::release_store(field_addr<Metadata*>(offset), value); }\n+Metadata* oopDesc::metadata_field_acquire(int offset) const           { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_metadata_field_put(int offset, Metadata* value) { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -194,2 +194,2 @@\n-jbyte oopDesc::byte_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jbyte>(offset)); }\n-void oopDesc::release_byte_field_put(int offset, jbyte value)         { Atomic::release_store(field_addr<jbyte>(offset), value); }\n+jbyte oopDesc::byte_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_byte_field_put(int offset, jbyte value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -197,2 +197,2 @@\n-jchar oopDesc::char_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jchar>(offset)); }\n-void oopDesc::release_char_field_put(int offset, jchar value)         { Atomic::release_store(field_addr<jchar>(offset), value); }\n+jchar oopDesc::char_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_char_field_put(int offset, jchar value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -200,2 +200,2 @@\n-jboolean oopDesc::bool_field_acquire(int offset) const                { return Atomic::load_acquire(field_addr<jboolean>(offset)); }\n-void oopDesc::release_bool_field_put(int offset, jboolean value)      { Atomic::release_store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n+jboolean oopDesc::bool_field_acquire(int offset) const                { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_bool_field_put(int offset, jboolean value)      { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, jboolean(value & 1)); }\n@@ -203,2 +203,2 @@\n-jint oopDesc::int_field_acquire(int offset) const                     { return Atomic::load_acquire(field_addr<jint>(offset)); }\n-void oopDesc::release_int_field_put(int offset, jint value)           { Atomic::release_store(field_addr<jint>(offset), value); }\n+jint oopDesc::int_field_acquire(int offset) const                     { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_int_field_put(int offset, jint value)           { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -206,2 +206,2 @@\n-jshort oopDesc::short_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jshort>(offset)); }\n-void oopDesc::release_short_field_put(int offset, jshort value)       { Atomic::release_store(field_addr<jshort>(offset), value); }\n+jshort oopDesc::short_field_acquire(int offset) const                 { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_short_field_put(int offset, jshort value)       { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -209,2 +209,2 @@\n-jlong oopDesc::long_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jlong>(offset)); }\n-void oopDesc::release_long_field_put(int offset, jlong value)         { Atomic::release_store(field_addr<jlong>(offset), value); }\n+jlong oopDesc::long_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_long_field_put(int offset, jlong value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -212,2 +212,2 @@\n-jfloat oopDesc::float_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jfloat>(offset)); }\n-void oopDesc::release_float_field_put(int offset, jfloat value)       { Atomic::release_store(field_addr<jfloat>(offset), value); }\n+jfloat oopDesc::float_field_acquire(int offset) const                 { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_float_field_put(int offset, jfloat value)       { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n@@ -215,2 +215,2 @@\n-jdouble oopDesc::double_field_acquire(int offset) const               { return Atomic::load_acquire(field_addr<jdouble>(offset)); }\n-void oopDesc::release_double_field_put(int offset, jdouble value)     { Atomic::release_store(field_addr<jdouble>(offset), value); }\n+jdouble oopDesc::double_field_acquire(int offset) const               { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+void oopDesc::release_double_field_put(int offset, jdouble value)     { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -127,2 +127,5 @@\n-  template<typename T>\n-  inline T* field_addr(int offset) const;\n+  \/\/ field addresses in oop\n+  inline void* field_addr(int offset) const;\n+\n+  \/\/ Need this as public for garbage collection.\n+  template <class T> inline T* obj_field_addr(int offset) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -211,2 +211,4 @@\n-template<typename T>\n-T*       oopDesc::field_addr(int offset)     const { return reinterpret_cast<T*>(cast_from_oop<intptr_t>(as_oop()) + offset); }\n+void*    oopDesc::field_addr(int offset)     const { return reinterpret_cast<void*>(cast_from_oop<intptr_t>(as_oop()) + offset); }\n+\n+template <class T>\n+T*       oopDesc::obj_field_addr(int offset) const { return (T*) field_addr(offset); }\n@@ -223,2 +225,2 @@\n-inline jbyte oopDesc::byte_field(int offset) const                  { return *field_addr<jbyte>(offset);  }\n-inline void  oopDesc::byte_field_put(int offset, jbyte value)       { *field_addr<jbyte>(offset) = value; }\n+inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -226,2 +228,2 @@\n-inline jchar oopDesc::char_field(int offset) const                  { return *field_addr<jchar>(offset);  }\n-inline void  oopDesc::char_field_put(int offset, jchar value)       { *field_addr<jchar>(offset) = value; }\n+inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -229,6 +231,6 @@\n-inline jboolean oopDesc::bool_field(int offset) const               { return *field_addr<jboolean>(offset); }\n-inline void     oopDesc::bool_field_put(int offset, jboolean value) { *field_addr<jboolean>(offset) = jboolean(value & 1); }\n-inline jboolean oopDesc::bool_field_volatile(int offset) const      { return RawAccess<MO_SEQ_CST>::load(field_addr<jboolean>(offset)); }\n-inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { RawAccess<MO_SEQ_CST>::store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n-inline jshort oopDesc::short_field(int offset) const                { return *field_addr<jshort>(offset);   }\n-inline void   oopDesc::short_field_put(int offset, jshort value)    { *field_addr<jshort>(offset) = value;  }\n+inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess<>::load_at(as_oop(), offset); }\n+inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess<>::store_at(as_oop(), offset, jboolean(value & 1)); }\n+inline jboolean oopDesc::bool_field_volatile(int offset) const      { return HeapAccess<MO_SEQ_CST>::load_at(as_oop(), offset); }\n+inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { HeapAccess<MO_SEQ_CST>::store_at(as_oop(), offset, jboolean(value & 1)); }\n+inline jshort oopDesc::short_field(int offset) const                { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -236,2 +238,2 @@\n-inline jint oopDesc::int_field(int offset) const                    { return *field_addr<jint>(offset);     }\n-inline void oopDesc::int_field_put(int offset, jint value)          { *field_addr<jint>(offset) = value;    }\n+inline jint oopDesc::int_field(int offset) const                    { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void oopDesc::int_field_put(int offset, jint value)          { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -239,2 +241,2 @@\n-inline jlong oopDesc::long_field(int offset) const                  { return *field_addr<jlong>(offset);    }\n-inline void  oopDesc::long_field_put(int offset, jlong value)       { *field_addr<jlong>(offset) = value;   }\n+inline jlong oopDesc::long_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -242,2 +244,2 @@\n-inline jfloat oopDesc::float_field(int offset) const                { return *field_addr<jfloat>(offset);   }\n-inline void   oopDesc::float_field_put(int offset, jfloat value)    { *field_addr<jfloat>(offset) = value;  }\n+inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess<>::store_at(as_oop(), offset, value); }\n@@ -245,2 +247,2 @@\n-inline jdouble oopDesc::double_field(int offset) const              { return *field_addr<jdouble>(offset);  }\n-inline void    oopDesc::double_field_put(int offset, jdouble value) { *field_addr<jdouble>(offset) = value; }\n+inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess<>::load_at(as_oop(), offset);  }\n+inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess<>::store_at(as_oop(), offset, value); }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":22,"deletions":20,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -93,1 +93,3 @@\n-  return *byte_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jbyte>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -96,1 +98,3 @@\n-  *byte_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jbyte>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -100,1 +104,3 @@\n-  return *bool_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jboolean>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -103,1 +109,3 @@\n-  *bool_at_addr(which) = jboolean(contents & 1);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jboolean>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, jboolean(contents & 1));\n@@ -107,1 +115,3 @@\n-  return *char_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jchar>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -110,1 +120,3 @@\n-  *char_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jchar>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -114,1 +126,3 @@\n-  return *int_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jint>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -117,1 +131,3 @@\n-  *int_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jint>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -121,1 +137,3 @@\n-  return *short_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jshort>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -124,1 +142,3 @@\n-  *short_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jshort>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -128,1 +148,3 @@\n-  return *ushort_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jushort>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -130,1 +152,0 @@\n-\n@@ -132,1 +153,3 @@\n-  *ushort_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jushort>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -136,1 +159,3 @@\n-  return *long_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jlong>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -139,1 +164,3 @@\n-  *long_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jlong>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -143,1 +170,3 @@\n-  return *float_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jfloat>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -145,1 +174,0 @@\n-\n@@ -147,1 +175,3 @@\n-  *float_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jfloat>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -151,1 +181,3 @@\n-  return *double_at_addr(which);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jdouble>(which);\n+  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -153,1 +185,0 @@\n-\n@@ -155,1 +186,3 @@\n-  *double_at_addr(which) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jdouble>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -159,1 +192,3 @@\n-  return Atomic::load_acquire(byte_at_addr(which));\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jbyte>(which);\n+  return HeapAccess<MO_ACQUIRE | IS_ARRAY>::load_at(as_oop(), offset);\n@@ -162,1 +197,3 @@\n-  Atomic::release_store(byte_at_addr(which), contents);\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jbyte>(which);\n+  HeapAccess<MO_RELEASE | IS_ARRAY>::store_at(as_oop(), offset, contents);\n@@ -170,1 +207,3 @@\n-  return *reinterpret_cast<Symbol**>(long_at_addr(which));\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jlong>(which);\n+  return (Symbol*)(jlong) HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -172,1 +211,0 @@\n-\n@@ -174,1 +212,3 @@\n-  *reinterpret_cast<Symbol**>(long_at_addr(which)) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jlong>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, (jlong)contents);\n@@ -178,1 +218,3 @@\n-  return *reinterpret_cast<Symbol**>(int_at_addr(which));\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jint>(which);\n+  return (Symbol*)(jint) HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n@@ -181,1 +223,3 @@\n-  *reinterpret_cast<Symbol**>(int_at_addr(which)) = contents;\n+  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n+  ptrdiff_t offset = element_offset<jint>(which);\n+  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, (jint)contents);\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.inline.hpp","additions":72,"deletions":28,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -552,1 +552,0 @@\n-                  _ilt(NULL),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1635,2 +1635,0 @@\n-\n-  bool safe_for_if_replacement(const Node* dom) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1395,2 +1395,1 @@\n-        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom &&\n-            safe_for_if_replacement(dom)) {\n+        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom) {\n@@ -1434,19 +1433,0 @@\n-bool PhaseIdealLoop::safe_for_if_replacement(const Node* dom) const {\n-  if (!dom->is_CountedLoopEnd()) {\n-    return true;\n-  }\n-  CountedLoopEndNode* le = dom->as_CountedLoopEnd();\n-  CountedLoopNode* cl = le->loopnode();\n-  if (cl == NULL) {\n-    return true;\n-  }\n-  if (!cl->is_main_loop()) {\n-    return true;\n-  }\n-  if (cl->is_canonical_loop_entry() == NULL) {\n-    return true;\n-  }\n-  \/\/ Further unrolling is possible so loop exit condition might change\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2964,1 +2964,1 @@\n-      JavaThread::send_async_exception(receiver, java_throwable);\n+      JavaThread::send_async_exception(java_thread, java_throwable);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-  JavaThread::send_async_exception(java_thread, e);\n+  JavaThread::send_async_exception(java_thread->threadObj(), e);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  _lock(Mutex::nosafepoint, \"JvmtiTagMap_lock\"),\n+  _lock(Mutex::nosafepoint, \"JvmtiTagMap_lock\", Mutex::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      assert(p->field_addr<void>((jint)byte_offset) == ptr_plus_disp,\n+      assert(p->field_addr((jint)byte_offset) == ptr_plus_disp,\n@@ -221,2 +221,8 @@\n-    GuardUnsafeAccess guard(_thread);\n-    return normalize_for_read(*addr());\n+    if (_obj == NULL) {\n+      GuardUnsafeAccess guard(_thread);\n+      T ret = RawAccess<>::load(addr());\n+      return normalize_for_read(ret);\n+    } else {\n+      T ret = HeapAccess<>::load_at(_obj, _offset);\n+      return normalize_for_read(ret);\n+    }\n@@ -226,2 +232,6 @@\n-    GuardUnsafeAccess guard(_thread);\n-    *addr() = normalize_for_write(x);\n+    if (_obj == NULL) {\n+      GuardUnsafeAccess guard(_thread);\n+      RawAccess<>::store(addr(), normalize_for_write(x));\n+    } else {\n+      HeapAccess<>::store_at(_obj, _offset, normalize_for_write(x));\n+    }\n@@ -232,3 +242,8 @@\n-    GuardUnsafeAccess guard(_thread);\n-    volatile T ret = RawAccess<MO_SEQ_CST>::load(addr());\n-    return normalize_for_read(ret);\n+    if (_obj == NULL) {\n+      GuardUnsafeAccess guard(_thread);\n+      volatile T ret = RawAccess<MO_SEQ_CST>::load(addr());\n+      return normalize_for_read(ret);\n+    } else {\n+      T ret = HeapAccess<MO_SEQ_CST>::load_at(_obj, _offset);\n+      return normalize_for_read(ret);\n+    }\n@@ -238,2 +253,6 @@\n-    GuardUnsafeAccess guard(_thread);\n-    RawAccess<MO_SEQ_CST>::store(addr(), normalize_for_write(x));\n+    if (_obj == NULL) {\n+      GuardUnsafeAccess guard(_thread);\n+      RawAccess<MO_SEQ_CST>::store(addr(), normalize_for_write(x));\n+    } else {\n+      HeapAccess<MO_SEQ_CST>::store_at(_obj, _offset, normalize_for_write(x));\n+    }\n@@ -729,2 +748,7 @@\n-  volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n-  return Atomic::cmpxchg(addr, e, x);\n+  if (p == NULL) {\n+    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n+    return RawAccess<>::atomic_cmpxchg(addr, e, x);\n+  } else {\n+    assert_field_offset_sane(p, offset);\n+    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);\n+  }\n@@ -735,2 +759,7 @@\n-  volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n-  return Atomic::cmpxchg(addr, e, x);\n+  if (p == NULL) {\n+    volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n+    return RawAccess<>::atomic_cmpxchg(addr, e, x);\n+  } else {\n+    assert_field_offset_sane(p, offset);\n+    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);\n+  }\n@@ -750,2 +779,7 @@\n-  volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n-  return Atomic::cmpxchg(addr, e, x) == e;\n+  if (p == NULL) {\n+    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n+    return RawAccess<>::atomic_cmpxchg(addr, e, x) == e;\n+  } else {\n+    assert_field_offset_sane(p, offset);\n+    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;\n+  }\n@@ -756,2 +790,7 @@\n-  volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n-  return Atomic::cmpxchg(addr, e, x) == e;\n+  if (p == NULL) {\n+    volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n+    return RawAccess<>::atomic_cmpxchg(addr, e, x) == e;\n+  } else {\n+    assert_field_offset_sane(p, offset);\n+    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;\n+  }\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":57,"deletions":18,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3534,0 +3534,1 @@\n+        int name_size;\n@@ -3535,1 +3536,1 @@\n-          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &SharedArchivePath);\n+          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &name_size, &SharedArchivePath);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"utilities\/vmError.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1339,4 +1339,0 @@\n-  product(int, ErrorLogPrintCodeLimit, 3, DIAGNOSTIC,                       \\\n-          \"max number of compiled code units to print in error log\")        \\\n-          range(0, VMError::max_error_log_print_code)                       \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-  _lock(Monitor::nosafepoint, \"HandshakeState_lock\"),\n+  _lock(Monitor::nosafepoint, \"HandshakeState_lock\", Monitor::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"memory\/resourceArea.hpp\"\n@@ -66,6 +65,1 @@\n-  \/\/ If the lock acquisition checks for safepoint, verify that the lock was created with rank that\n-  \/\/ has safepoint checks. Technically this doesn't affect NonJavaThreads since they won't actually\n-  \/\/ check for safepoint, but let's make the rule unconditional unless there's a good reason not to.\n-  assert(_rank > nosafepoint,\n-         \"This lock should not be taken with a safepoint check: %s\", name());\n-\n+  \/\/ If the JavaThread checks for safepoint, verify that the lock wasn't created with safepoint_check_never.\n@@ -73,0 +67,4 @@\n+    assert(_safepoint_check_required != _safepoint_check_never,\n+           \"This lock should never have a safepoint check for Java threads: %s\",\n+           name());\n+\n@@ -75,0 +73,4 @@\n+  } else {\n+    \/\/ If initialized with safepoint_check_never, a NonJavaThread should never ask to safepoint check either.\n+    assert(_safepoint_check_required != _safepoint_check_never,\n+           \"NonJavaThread should not check for safepoint\");\n@@ -80,1 +82,1 @@\n-  assert(!thread->is_active_Java_thread() || _rank <= nosafepoint,\n+  assert(!thread->is_active_Java_thread() || _safepoint_check_required != _safepoint_check_always,\n@@ -168,1 +170,1 @@\n-  \/\/ Some safepoint checking locks use try_lock, so cannot check\n+  \/\/ Some safepoint_check_always locks use try_lock, so cannot check\n@@ -275,1 +277,2 @@\n-Mutex::Mutex(Rank rank, const char * name, bool allow_vm_block) : _owner(NULL) {\n+Mutex::Mutex(int Rank, const char * name, SafepointCheckRequired safepoint_check_required,\n+             bool allow_vm_block) : _owner(NULL) {\n@@ -281,1 +284,2 @@\n-  _rank            = rank;\n+  _rank            = Rank;\n+  _safepoint_check_required = safepoint_check_required;\n@@ -284,1 +288,7 @@\n-  assert(_rank >= static_cast<Rank>(0) && _rank <= safepoint, \"Bad lock rank %s: %s\", rank_name(), name);\n+  assert(_rank >= 0 && _rank <= nonleaf, \"Bad lock rank %d: %s\", _rank, name);\n+\n+  assert(_rank > nosafepoint || _safepoint_check_required == _safepoint_check_never,\n+         \"Locks below nosafepoint rank should never safepoint: %s\", name);\n+\n+  assert(_rank <= nosafepoint || _safepoint_check_required == _safepoint_check_always,\n+         \"Locks above nosafepoint rank should safepoint: %s\", name);\n@@ -288,2 +298,2 @@\n-  assert(_rank > nosafepoint || _allow_vm_block,\n-         \"Locks that don't check for safepoint should always allow the vm to block: %s\", name);\n+  assert(_safepoint_check_required == _safepoint_check_always || _allow_vm_block,\n+         \"Safepoint check never locks should always allow the vm to block: %s\", name);\n@@ -305,29 +315,0 @@\n-\/\/\n-#ifdef ASSERT\n-static Mutex::Rank _ranks[] = { Mutex::event, Mutex::service, Mutex::stackwatermark, Mutex::tty, Mutex::oopstorage,\n-                                Mutex::nosafepoint, Mutex::safepoint };\n-\n-static const char* _rank_names[] = { \"event\", \"service\", \"stackwatermark\", \"tty\", \"oopstorage\",\n-                                     \"nosafepoint\", \"safepoint\" };\n-\n-static const int _num_ranks = 7;\n-\n-static const char* rank_name_internal(Mutex::Rank r) {\n-  \/\/ Find closest rank and print out the name\n-  stringStream st;\n-  for (int i = 0; i < _num_ranks; i++) {\n-    if (r == _ranks[i]) {\n-      return _rank_names[i];\n-    } else if (r  > _ranks[i] && (i < _num_ranks-1 && r < _ranks[i+1])) {\n-      int delta = static_cast<int>(_ranks[i+1]) - static_cast<int>(r);\n-      st.print(\"%s-%d\", _rank_names[i+1], delta);\n-      return st.as_string();\n-    }\n-  }\n-  return \"fail\";\n-}\n-\n-const char* Mutex::rank_name() const {\n-  return rank_name_internal(_rank);\n-}\n-\n@@ -335,9 +316,6 @@\n-void Mutex::assert_no_overlap(Rank orig, Rank adjusted, int adjust) {\n-  int i = 0;\n-  while (_ranks[i] < orig) i++;\n-  \/\/ underflow is caught in constructor\n-  if (i != 0 && adjusted > event && adjusted <= _ranks[i-1]) {\n-    ResourceMark rm;\n-    assert(adjusted > _ranks[i-1],\n-           \"Rank %s-%d overlaps with %s\",\n-           rank_name_internal(orig), adjust, rank_name_internal(adjusted));\n+#ifndef PRODUCT\n+const char* print_safepoint_check(Mutex::SafepointCheckRequired safepoint_check) {\n+  switch (safepoint_check) {\n+  case Mutex::_safepoint_check_never:     return \"safepoint_check_never\";\n+  case Mutex::_safepoint_check_always:    return \"safepoint_check_always\";\n+  default: return \"\";\n@@ -346,1 +324,0 @@\n-#endif \/\/ ASSERT\n@@ -348,1 +325,0 @@\n-#ifndef PRODUCT\n@@ -355,1 +331,1 @@\n-  DEBUG_ONLY(st->print(\" %s\", rank_name()));\n+  st->print(\" %s\", print_safepoint_check(_safepoint_check_required));\n@@ -419,3 +395,2 @@\n-      ResourceMark rm(thread);\n-      assert(false, \"Attempting to wait on monitor %s\/%s while holding lock %s\/%s -- \"\n-             \"possible deadlock. %s\", name(), rank_name(), least->name(), least->rank_name(),\n+      assert(false, \"Attempting to wait on monitor %s\/%d while holding lock %s\/%d -- \"\n+             \"possible deadlock. %s\", name(), rank(), least->name(), least->rank(),\n@@ -437,1 +412,0 @@\n-      ResourceMark rm(thread);\n@@ -444,2 +418,2 @@\n-      assert(false, \"Attempting to acquire lock %s\/%s out of order with lock %s\/%s -- \"\n-             \"possible deadlock\", this->name(), this->rank_name(), least->name(), least->rank_name());\n+      assert(false, \"Attempting to acquire lock %s\/%d out of order with lock %s\/%d -- \"\n+             \"possible deadlock\", this->name(), this->rank(), least->name(), least->rank());\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":35,"deletions":61,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  enum class Rank {\n+  enum Rank {\n@@ -56,1 +56,2 @@\n-       safepoint      = nosafepoint    +  20\n+       nonleaf        = nosafepoint    +  20,\n+       max_nonleaf    = nonleaf\n@@ -59,25 +60,0 @@\n-  \/\/ want C++later \"using enum\" directives.\n-  static const Rank event          = Rank::event;\n-  static const Rank service        = Rank::service;\n-  static const Rank stackwatermark = Rank::stackwatermark;\n-  static const Rank tty            = Rank::tty;\n-  static const Rank oopstorage     = Rank::oopstorage;\n-  static const Rank nosafepoint    = Rank::nosafepoint;\n-  static const Rank safepoint      = Rank::safepoint;\n-\n-  static void assert_no_overlap(Rank orig, Rank adjusted, int adjust);\n-\n-  friend Rank operator-(Rank base, int adjust) {\n-    Rank result = static_cast<Rank>(static_cast<int>(base) - adjust);\n-    DEBUG_ONLY(assert_no_overlap(base, result, adjust));\n-    return result;\n-  }\n-\n-  friend constexpr bool operator<(Rank lhs, Rank rhs) {\n-    return static_cast<int>(lhs) < static_cast<int>(rhs);\n-  }\n-\n-  friend constexpr bool operator>(Rank lhs, Rank rhs)  { return rhs < lhs; }\n-  friend constexpr bool operator<=(Rank lhs, Rank rhs) { return !(lhs > rhs); }\n-  friend constexpr bool operator>=(Rank lhs, Rank rhs) { return !(lhs < rhs); }\n-\n@@ -100,1 +76,1 @@\n-  Rank    _rank;                 \/\/ rank (to avoid\/detect potential deadlocks)\n+  int     _rank;                 \/\/ rank (to avoid\/detect potential deadlocks)\n@@ -114,2 +90,1 @@\n-  Rank   rank() const          { return _rank; }\n-  const char*  rank_name() const;\n+  int    rank() const          { return _rank; }\n@@ -135,1 +110,1 @@\n-  \/\/ Java and NonJavaThreads. When the lock is initialized with rank > nosafepoint,\n+  \/\/ Java and NonJavaThreads. When the lock is initialized with _safepoint_check_always,\n@@ -138,1 +113,1 @@\n-  \/\/ rank <= nosafepoint, that means that whenever the lock is acquired by a JavaThread\n+  \/\/ _safepoint_check_never, that means that whenever the lock is acquired by a JavaThread\n@@ -156,0 +131,14 @@\n+  enum class SafepointCheckRequired {\n+    _safepoint_check_never,       \/\/ Mutexes with this value will cause errors\n+                                  \/\/ when acquired by a JavaThread with a safepoint check.\n+    _safepoint_check_always       \/\/ Mutexes with this value will cause errors\n+                                  \/\/ when acquired by a JavaThread without a safepoint check.\n+  };\n+  \/\/ Bring the enumerator names into class scope.\n+  static const SafepointCheckRequired _safepoint_check_never =\n+    SafepointCheckRequired::_safepoint_check_never;\n+  static const SafepointCheckRequired _safepoint_check_always =\n+    SafepointCheckRequired::_safepoint_check_always;\n+\n+  NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)\n+\n@@ -157,1 +146,1 @@\n-  Mutex(Rank rank, const char *name, bool allow_vm_block);\n+  Mutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block);\n@@ -159,2 +148,3 @@\n-  Mutex(Rank rank, const char *name) :\n-    Mutex(rank, name, rank > nosafepoint ? false : true) {}\n+  Mutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n+    Mutex(rank, name, safepoint_check_required,\n+          safepoint_check_required == _safepoint_check_never ? true : false) {}\n@@ -201,2 +191,2 @@\n-  Monitor(Rank rank, const char *name, bool allow_vm_block)  :\n-    Mutex(rank, name, allow_vm_block) {}\n+  Monitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block)  :\n+    Mutex(rank, name, safepoint_check_required, allow_vm_block) {}\n@@ -204,2 +194,2 @@\n-  Monitor(Rank rank, const char *name) :\n-    Mutex(rank, name) {}\n+  Monitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n+    Mutex(rank, name, safepoint_check_required) {}\n@@ -225,2 +215,4 @@\n-  PaddedMutex(Rank rank, const char *name, bool allow_vm_block) : Mutex(rank, name, allow_vm_block) {};\n-  PaddedMutex(Rank rank, const char *name) : Mutex(rank, name) {};\n+  PaddedMutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block) :\n+    Mutex(rank, name, safepoint_check_required, allow_vm_block) {};\n+  PaddedMutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n+    Mutex(rank, name, safepoint_check_required) {};\n@@ -236,2 +228,4 @@\n-  PaddedMonitor(Rank rank, const char *name, bool allow_vm_block) : Monitor(rank, name, allow_vm_block) {};\n-  PaddedMonitor(Rank rank, const char *name) : Monitor(rank, name) {};\n+  PaddedMonitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block) :\n+    Monitor(rank, name, safepoint_check_required, allow_vm_block) {};\n+  PaddedMonitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n+    Monitor(rank, name, safepoint_check_required) {};\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":37,"deletions":43,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -202,3 +202,3 @@\n-#define def(var, type, pri, vm_block) {       \\\n-  var = new type(Mutex::pri, #var, vm_block); \\\n-  add_mutex(var);                             \\\n+#define def(var, type, pri, vm_block, safepoint_check_allowed ) {             \\\n+  var = new type(Mutex::pri, #var, Mutex::safepoint_check_allowed, vm_block); \\\n+  add_mutex(var);                                                             \\\n@@ -209,3 +209,3 @@\n-#define defl(var, type, held_lock, vm_block) {         \\\n-  var = new type(held_lock->rank()-1, #var, vm_block); \\\n-  add_mutex(var);                                      \\\n+#define defl(var, type, held_lock, vm_block, safepoint_check_allowed) {                \\\n+  var = new type(held_lock->rank()-1, #var, Mutex::safepoint_check_allowed, vm_block); \\\n+  add_mutex(var); \\\n@@ -214,3 +214,3 @@\n-#define defl(var, type, held_lock, vm_block) {         \\\n-  var = new type(Mutex::safepoint, #var, vm_block);    \\\n-  add_mutex(var);                                      \\\n+#define defl(var, type, held_lock, vm_block, safepoint_check_allowed) {           \\\n+  var = new type(Mutex::nonleaf, #var, Mutex::safepoint_check_allowed, vm_block); \\\n+  add_mutex(var); \\\n@@ -222,1 +222,1 @@\n-  def(tty_lock                     , PaddedMutex  , tty,            true);      \/\/ allow to lock in VM\n+  def(tty_lock                     , PaddedMutex  , tty,         true,  _safepoint_check_never);      \/\/ allow to lock in VM\n@@ -224,1 +224,1 @@\n-  def(STS_lock                     , PaddedMonitor, nosafepoint,    true);\n+  def(STS_lock                     , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n@@ -227,1 +227,1 @@\n-    def(CGC_lock                   , PaddedMonitor, nosafepoint,    true);\n+    def(CGC_lock                   , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n@@ -229,1 +229,1 @@\n-    def(G1DetachedRefinementStats_lock, PaddedMutex, nosafepoint-2, true);\n+    def(G1DetachedRefinementStats_lock, PaddedMutex, nosafepoint-2, true, _safepoint_check_never);\n@@ -231,4 +231,4 @@\n-    def(FreeList_lock              , PaddedMutex  , service-1,      true);\n-    def(OldSets_lock               , PaddedMutex  , nosafepoint,    true);\n-    def(Uncommit_lock              , PaddedMutex  , service-2,      true);\n-    def(RootRegionScan_lock        , PaddedMonitor, nosafepoint-1,  true);\n+    def(FreeList_lock              , PaddedMutex  , service-1,   true,  _safepoint_check_never);\n+    def(OldSets_lock               , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+    def(Uncommit_lock              , PaddedMutex  , service-2,   true,  _safepoint_check_never);\n+    def(RootRegionScan_lock        , PaddedMonitor, nosafepoint-1, true,  _safepoint_check_never);\n@@ -236,2 +236,2 @@\n-    def(MarkStackFreeList_lock     , PaddedMutex  , nosafepoint,    true);\n-    def(MarkStackChunkList_lock    , PaddedMutex  , nosafepoint,    true);\n+    def(MarkStackFreeList_lock     , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+    def(MarkStackChunkList_lock    , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n@@ -239,1 +239,1 @@\n-    def(MonitoringSupport_lock     , PaddedMutex  , service-1,      true);      \/\/ used for serviceability monitoring support\n+    def(MonitoringSupport_lock     , PaddedMutex  , service-1,   true,  _safepoint_check_never);      \/\/ used for serviceability monitoring support\n@@ -241,4 +241,4 @@\n-  def(StringDedup_lock             , PaddedMonitor, nosafepoint,    true);\n-  def(StringDedupIntern_lock       , PaddedMutex  , nosafepoint,    true);\n-  def(ParGCRareEvent_lock          , PaddedMutex  , safepoint,      true);\n-  def(RawMonitor_lock              , PaddedMutex  , nosafepoint-1,  true);\n+  def(StringDedup_lock             , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n+  def(StringDedupIntern_lock       , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(ParGCRareEvent_lock          , PaddedMutex  , nonleaf,       true,  _safepoint_check_always);\n+  def(RawMonitor_lock              , PaddedMutex  , nosafepoint-1, true,  _safepoint_check_never);\n@@ -246,1 +246,1 @@\n-  def(Metaspace_lock               , PaddedMutex  , nosafepoint-3,  true);\n+  def(Metaspace_lock               , PaddedMutex  , nosafepoint-3, true,  _safepoint_check_never);\n@@ -248,3 +248,3 @@\n-  def(Patching_lock                , PaddedMutex  , nosafepoint,    true);      \/\/ used for safepointing and code patching.\n-  def(MonitorDeflation_lock        , PaddedMonitor, nosafepoint,    true);      \/\/ used for monitor deflation thread operations\n-  def(Service_lock                 , PaddedMonitor, service,        true);      \/\/ used for service thread operations\n+  def(Patching_lock                , PaddedMutex  , nosafepoint,     true,  _safepoint_check_never);      \/\/ used for safepointing and code patching.\n+  def(MonitorDeflation_lock        , PaddedMonitor, nosafepoint,     true,  _safepoint_check_never);      \/\/ used for monitor deflation thread operations\n+  def(Service_lock                 , PaddedMonitor, service,     true,  _safepoint_check_never);      \/\/ used for service thread operations\n@@ -253,1 +253,1 @@\n-    def(Notification_lock          , PaddedMonitor, service,        true);  \/\/ used for notification thread operations\n+    def(Notification_lock          , PaddedMonitor, service,     true,  _safepoint_check_never);  \/\/ used for notification thread operations\n@@ -258,1 +258,1 @@\n-  def(JmethodIdCreation_lock       , PaddedMutex  , nosafepoint-2,  true); \/\/ used for creating jmethodIDs.\n+  def(JmethodIdCreation_lock       , PaddedMutex  , nosafepoint-2,   true,  _safepoint_check_never); \/\/ used for creating jmethodIDs.\n@@ -260,6 +260,6 @@\n-  def(SharedDictionary_lock        , PaddedMutex  , safepoint,      true);\n-  def(VMStatistic_lock             , PaddedMutex  , safepoint,      false);\n-  def(JNIHandleBlockFreeList_lock  , PaddedMutex  , nosafepoint-1,  true);      \/\/ handles are used by VM thread\n-  def(SignatureHandlerLibrary_lock , PaddedMutex  , safepoint,      false);\n-  def(SymbolArena_lock             , PaddedMutex  , nosafepoint,    true);\n-  def(ExceptionCache_lock          , PaddedMutex  , safepoint,      false);\n+  def(SharedDictionary_lock        , PaddedMutex  , nonleaf,          true,  _safepoint_check_always);\n+  def(VMStatistic_lock             , PaddedMutex  , nonleaf,          false, _safepoint_check_always);\n+  def(JNIHandleBlockFreeList_lock  , PaddedMutex  , nosafepoint-1,    true,  _safepoint_check_never);      \/\/ handles are used by VM thread\n+  def(SignatureHandlerLibrary_lock , PaddedMutex  , nonleaf,          false, _safepoint_check_always);\n+  def(SymbolArena_lock             , PaddedMutex  , nosafepoint,      true,  _safepoint_check_never);\n+  def(ExceptionCache_lock          , PaddedMutex  , nonleaf,          false, _safepoint_check_always);\n@@ -267,1 +267,1 @@\n-  def(FullGCALot_lock              , PaddedMutex  , safepoint,      false); \/\/ a lock to make FullGCALot MT safe\n+  def(FullGCALot_lock              , PaddedMutex  , nonleaf,          false, _safepoint_check_always); \/\/ a lock to make FullGCALot MT safe\n@@ -269,1 +269,1 @@\n-  def(BeforeExit_lock              , PaddedMonitor, safepoint,      true);\n+  def(BeforeExit_lock              , PaddedMonitor, nonleaf,          true,  _safepoint_check_always);\n@@ -271,2 +271,2 @@\n-  def(NonJavaThreadsList_lock      , PaddedMutex,   nosafepoint-1,  true);\n-  def(NonJavaThreadsListSync_lock  , PaddedMutex,   nosafepoint,    true);\n+  def(NonJavaThreadsList_lock      , PaddedMutex,   nosafepoint-1, true,  _safepoint_check_never);\n+  def(NonJavaThreadsListSync_lock  , PaddedMutex,   nosafepoint, true,  _safepoint_check_never);\n@@ -274,5 +274,6 @@\n-  def(RetData_lock                 , PaddedMutex  , safepoint,      false);\n-  def(Terminator_lock              , PaddedMonitor, safepoint,      true);\n-  def(InitCompleted_lock           , PaddedMonitor, nosafepoint,    true);\n-  def(Notify_lock                  , PaddedMonitor, safepoint,      true);\n-  def(AdapterHandlerLibrary_lock   , PaddedMutex  , safepoint,      true);\n+  def(RetData_lock                 , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n+  def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n+  def(InitCompleted_lock           , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n+  def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n+  def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); \/\/ used for JNI critical regions\n+  def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);\n@@ -280,2 +281,2 @@\n-  def(Heap_lock                    , PaddedMonitor, safepoint,      false); \/\/ Doesn't safepoint check during termination.\n-  def(JfieldIdCreation_lock        , PaddedMutex  , safepoint,      true);  \/\/ jfieldID, Used in VM_Operation\n+  def(Heap_lock                    , PaddedMonitor, nonleaf,   false, _safepoint_check_always); \/\/ Doesn't safepoint check during termination.\n+  def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf,   true,  _safepoint_check_always); \/\/ jfieldID, Used in VM_Operation\n@@ -283,5 +284,5 @@\n-  def(CompiledIC_lock              , PaddedMutex  , nosafepoint,    true);  \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n-  def(MethodCompileQueue_lock      , PaddedMonitor, safepoint,      false);\n-  def(CompileStatistics_lock       , PaddedMutex  , safepoint,      false);\n-  def(DirectivesStack_lock         , PaddedMutex  , nosafepoint,    true);\n-  def(MultiArray_lock              , PaddedMutex  , safepoint,      false);\n+  def(CompiledIC_lock              , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);      \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n+  def(MethodCompileQueue_lock      , PaddedMonitor, nonleaf,     false, _safepoint_check_always);\n+  def(CompileStatistics_lock       , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n+  def(DirectivesStack_lock         , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(MultiArray_lock              , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n@@ -289,3 +290,3 @@\n-  def(JvmtiThreadState_lock        , PaddedMutex  , safepoint,      false); \/\/ Used by JvmtiThreadState\/JvmtiEventController\n-  def(EscapeBarrier_lock           , PaddedMonitor, nosafepoint,    true);  \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n-  def(Management_lock              , PaddedMutex  , safepoint,      false); \/\/ used for JVM management\n+  def(JvmtiThreadState_lock        , PaddedMutex  , nonleaf,     false, _safepoint_check_always); \/\/ Used by JvmtiThreadState\/JvmtiEventController\n+  def(EscapeBarrier_lock           , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);  \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n+  def(Management_lock              , PaddedMutex  , nonleaf,     false, _safepoint_check_always); \/\/ used for JVM management\n@@ -293,3 +294,3 @@\n-  def(ConcurrentGCBreakpoints_lock , PaddedMonitor, safepoint,      true);\n-  def(MethodData_lock              , PaddedMutex  , safepoint,      false);\n-  def(TouchedMethodLog_lock        , PaddedMutex  , safepoint,      false);\n+  def(ConcurrentGCBreakpoints_lock , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n+  def(MethodData_lock              , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n+  def(TouchedMethodLog_lock        , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n@@ -297,4 +298,4 @@\n-  def(CompileThread_lock           , PaddedMonitor, safepoint,      false);\n-  def(PeriodicTask_lock            , PaddedMonitor, safepoint,      true);\n-  def(RedefineClasses_lock         , PaddedMonitor, safepoint,      true);\n-  def(Verify_lock                  , PaddedMutex,   safepoint,      true);\n+  def(CompileThread_lock           , PaddedMonitor, nonleaf,     false, _safepoint_check_always);\n+  def(PeriodicTask_lock            , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n+  def(RedefineClasses_lock         , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n+  def(Verify_lock                  , PaddedMutex,   nonleaf,     true,  _safepoint_check_always);\n@@ -303,1 +304,1 @@\n-    def(Compilation_lock           , PaddedMonitor, nosafepoint,    true);\n+    def(Compilation_lock           , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n@@ -307,3 +308,3 @@\n-  def(JfrBuffer_lock               , PaddedMutex  , nosafepoint,       true);\n-  def(JfrStacktrace_lock           , PaddedMutex  , stackwatermark-1,  true);\n-  def(JfrThreadSampler_lock        , PaddedMonitor, nosafepoint,       true);\n+  def(JfrBuffer_lock               , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(JfrStacktrace_lock           , PaddedMutex  , stackwatermark-1,  true,  _safepoint_check_never);\n+  def(JfrThreadSampler_lock        , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n@@ -313,1 +314,1 @@\n-  def(UnsafeJlong_lock             , PaddedMutex  , nosafepoint,    true);\n+  def(UnsafeJlong_lock             , PaddedMutex  , nosafepoint,     true,  _safepoint_check_never);\n@@ -316,6 +317,6 @@\n-  def(CodeHeapStateAnalytics_lock  , PaddedMutex  , safepoint,      false);\n-  def(NMethodSweeperStats_lock     , PaddedMutex  , nosafepoint,    true);\n-  def(ThreadsSMRDelete_lock        , PaddedMonitor, nosafepoint-3,  true); \/\/ Holds ConcurrentHashTableResize_lock\n-  def(ThreadIdTableCreate_lock     , PaddedMutex  , safepoint,      false);\n-  def(SharedDecoder_lock           , PaddedMutex  , tty-1,          true);\n-  def(DCmdFactory_lock             , PaddedMutex  , nosafepoint,    true);\n+  def(CodeHeapStateAnalytics_lock  , PaddedMutex  , nonleaf,   false, _safepoint_check_always);\n+  def(NMethodSweeperStats_lock     , PaddedMutex  , nosafepoint,   true,  _safepoint_check_never);\n+  def(ThreadsSMRDelete_lock        , PaddedMonitor, nosafepoint-3, true,  _safepoint_check_never); \/\/ Holds ConcurrentHashTableResize_lock\n+  def(ThreadIdTableCreate_lock     , PaddedMutex  , nonleaf,       false, _safepoint_check_always);\n+  def(SharedDecoder_lock           , PaddedMutex  , tty-1,         true,  _safepoint_check_never);\n+  def(DCmdFactory_lock             , PaddedMutex  , nosafepoint,   true,  _safepoint_check_never);\n@@ -323,1 +324,1 @@\n-  def(NMTQuery_lock                , PaddedMutex  , safepoint,      false);\n+  def(NMTQuery_lock                , PaddedMutex  , nonleaf, false, _safepoint_check_always);\n@@ -327,1 +328,1 @@\n-  def(CDSClassFileStream_lock      , PaddedMutex  , safepoint,      false);\n+  def(CDSClassFileStream_lock      , PaddedMutex  , nonleaf, false, _safepoint_check_always);\n@@ -329,5 +330,5 @@\n-  def(DumpTimeTable_lock           , PaddedMutex  , nosafepoint,    true);\n-  def(CDSLambda_lock               , PaddedMutex  , nosafepoint,    true);\n-  def(DumpRegion_lock              , PaddedMutex  , nosafepoint,    true);\n-  def(ClassListFile_lock           , PaddedMutex  , nosafepoint,    true);\n-  def(LambdaFormInvokers_lock      , PaddedMutex  , safepoint,      false);\n+  def(DumpTimeTable_lock           , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(CDSLambda_lock               , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(DumpRegion_lock              , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(ClassListFile_lock           , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(LambdaFormInvokers_lock      , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n@@ -335,2 +336,2 @@\n-  def(Bootclasspath_lock           , PaddedMutex  , nosafepoint,    true);\n-  def(Zip_lock                     , PaddedMonitor, nosafepoint-1,  true); \/\/ Holds DumpTimeTable_lock\n+  def(Bootclasspath_lock           , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+  def(Zip_lock                     , PaddedMonitor, nosafepoint-1, true, _safepoint_check_never); \/\/ Holds DumpTimeTable_lock\n@@ -339,1 +340,1 @@\n-  def(JVMCI_lock                   , PaddedMonitor, safepoint,      true);\n+  def(JVMCI_lock                   , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n@@ -342,6 +343,6 @@\n-  \/\/ These locks have relative rankings, and inherit safepoint checking attributes from that rank.\n-  defl(InlineCacheBuffer_lock      , PaddedMutex  , CompiledIC_lock,  true);\n-  defl(VtableStubs_lock            , PaddedMutex  , CompiledIC_lock,  true);  \/\/ Also holds DumpTimeTable_lock\n-  defl(CodeCache_lock              , PaddedMonitor, VtableStubs_lock, true);\n-  defl(CompiledMethod_lock         , PaddedMutex  , CodeCache_lock,   true);\n-  defl(CodeSweeper_lock            , PaddedMonitor, CompiledMethod_lock, true);\n+  \/\/ These locks have safepoint_check_never and relative rankings.\n+  defl(InlineCacheBuffer_lock      , PaddedMutex  , CompiledIC_lock,  true,  _safepoint_check_never);\n+  defl(VtableStubs_lock            , PaddedMutex  , CompiledIC_lock,  true,  _safepoint_check_never);  \/\/ Also holds DumpTimeTable_lock\n+  defl(CodeCache_lock              , PaddedMonitor, VtableStubs_lock, true,  _safepoint_check_never);\n+  defl(CompiledMethod_lock         , PaddedMutex  , CodeCache_lock,   true,  _safepoint_check_never);\n+  defl(CodeSweeper_lock            , PaddedMonitor, CompiledMethod_lock, true,  _safepoint_check_never);\n@@ -349,3 +350,4 @@\n-  defl(Threads_lock                , PaddedMonitor, CompileThread_lock, true);\n-  defl(Heap_lock                   , PaddedMonitor, MultiArray_lock,    false);\n-  defl(Compile_lock                , PaddedMutex ,  MethodCompileQueue_lock, false);\n+  \/\/ These locks have safepoint_check_always and relative rankings.\n+  defl(Threads_lock                , PaddedMonitor, CompileThread_lock, true, _safepoint_check_always);\n+  defl(Heap_lock                   , PaddedMonitor, MultiArray_lock,   false, _safepoint_check_always);\n+  defl(Compile_lock                , PaddedMutex ,  MethodCompileQueue_lock, false, _safepoint_check_always);\n@@ -353,5 +355,5 @@\n-  defl(PerfDataMemAlloc_lock       , PaddedMutex  , Heap_lock,         true);\n-  defl(PerfDataManager_lock        , PaddedMutex  , Heap_lock,         true);\n-  defl(ClassLoaderDataGraph_lock   , PaddedMutex  , MultiArray_lock,   false);\n-  defl(VMOperation_lock            , PaddedMonitor, Compile_lock,      true);\n-  defl(ClassInitError_lock         , PaddedMonitor, Threads_lock,      true);\n+  defl(PerfDataMemAlloc_lock       , PaddedMutex  , Heap_lock,         true, _safepoint_check_always);\n+  defl(PerfDataManager_lock        , PaddedMutex  , Heap_lock,         true, _safepoint_check_always);\n+  defl(ClassLoaderDataGraph_lock   , PaddedMutex  , MultiArray_lock,   false, _safepoint_check_always);\n+  defl(VMOperation_lock            , PaddedMonitor, Compile_lock,      true, _safepoint_check_always);\n+  defl(ClassInitError_lock         , PaddedMonitor, Threads_lock,      true, _safepoint_check_always);\n@@ -360,1 +362,1 @@\n-    defl(G1OldGCCount_lock         , PaddedMonitor, Threads_lock,      true);\n+    defl(G1OldGCCount_lock         , PaddedMonitor, Threads_lock, true, _safepoint_check_always);\n@@ -362,6 +364,5 @@\n-  defl(CompileTaskAlloc_lock       , PaddedMutex ,  MethodCompileQueue_lock,   true);\n-  defl(ExpandHeap_lock             , PaddedMutex ,  Heap_lock,                 true);\n-  defl(OopMapCacheAlloc_lock       , PaddedMutex ,  Threads_lock,              true);\n-  defl(Module_lock                 , PaddedMutex ,  ClassLoaderDataGraph_lock, false);\n-  defl(SystemDictionary_lock       , PaddedMonitor, Module_lock,               true);\n-  defl(JNICritical_lock            , PaddedMonitor, MultiArray_lock,           true); \/\/ used for JNI critical regions\n+  defl(CompileTaskAlloc_lock       , PaddedMutex ,  MethodCompileQueue_lock,   true, _safepoint_check_always);\n+  defl(ExpandHeap_lock             , PaddedMutex ,  Heap_lock,                 true, _safepoint_check_always);\n+  defl(OopMapCacheAlloc_lock       , PaddedMutex ,  Threads_lock,              true, _safepoint_check_always);\n+  defl(Module_lock                 , PaddedMutex ,  ClassLoaderDataGraph_lock, false, _safepoint_check_always);\n+  defl(SystemDictionary_lock       , PaddedMonitor, Module_lock,               true, _safepoint_check_always);\n@@ -370,1 +371,1 @@\n-  defl(JfrMsg_lock                 , PaddedMonitor, Module_lock,               true);\n+  defl(JfrMsg_lock                 , PaddedMonitor, Module_lock,               true,  _safepoint_check_always);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":106,"deletions":105,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -134,0 +134,1 @@\n+      case _thread_in_native_trans:\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    _lock(Mutex::stackwatermark, \"StackWatermark_lock\"),\n+    _lock(Mutex::stackwatermark, \"StackWatermark_lock\", Mutex::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1004,0 +1004,1 @@\n+  _async_exception_condition(_no_async_condition),\n@@ -1005,3 +1006,0 @@\n-#ifdef ASSERT\n-  _is_unsafe_access_error(false),\n-#endif\n@@ -1577,0 +1575,3 @@\n+\/\/ Note: this function shouldn't block if it's called in\n+\/\/ _thread_in_native_trans state (such as from\n+\/\/ check_special_condition_for_native_trans()).\n@@ -1602,1 +1603,9 @@\n-  if (!clear_async_exception_condition()) {\n+  AsyncExceptionCondition condition = clear_async_exception_condition();\n+  if (condition == _no_async_condition) {\n+    \/\/ Conditions have changed since has_special_runtime_exit_condition()\n+    \/\/ was called:\n+    \/\/ - if we were here only because of an external suspend request,\n+    \/\/   then that was taken care of above (or cancelled) so we are done\n+    \/\/ - if we were here because of another async request, then it has\n+    \/\/   been cleared between the has_special_runtime_exit_condition()\n+    \/\/   and now so again we are done\n@@ -1606,0 +1615,1 @@\n+  \/\/ Check for pending async. exception\n@@ -1607,1 +1617,1 @@\n-    \/\/ Only overwrite an already pending exception if it is not a threadDeath.\n+    \/\/ Only overwrite an already pending exception, if it is not a threadDeath.\n@@ -1624,0 +1634,3 @@\n+      _pending_async_exception = NULL;\n+      \/\/ Clear condition from _suspend_flags since we have finished processing it.\n+      clear_suspend_flag(_has_async_exception);\n@@ -1625,6 +1638,1 @@\n-    \/\/ Always null out the _pending_async_exception oop here since the async condition was\n-    \/\/ already cleared above and thus considered handled.\n-    _pending_async_exception = NULL;\n-  } else {\n-    assert(_is_unsafe_access_error, \"must be\");\n-    DEBUG_ONLY(_is_unsafe_access_error = false);\n+  }\n@@ -1632,0 +1640,1 @@\n+  if (condition == _async_unsafe_access_error && !has_pending_exception()) {\n@@ -1638,3 +1647,6 @@\n-      \/\/ We might have blocked in a ThreadBlockInVM wrapper in the call above so make sure we process pending\n-      \/\/ suspend requests and object reallocation operations if any since we might be going to Java after this.\n-      SafepointMechanism::process_if_requested_with_exit_check(this, true \/* check asyncs *\/);\n+      return;\n+    }\n+    case _thread_in_native: {\n+      ThreadInVMfromNative tiv(this);\n+      JavaThread* THREAD = this;\n+      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n@@ -1653,0 +1665,2 @@\n+\n+  assert(has_pending_exception(), \"must have handled the async condition if no exception\");\n@@ -1685,1 +1699,1 @@\n-void JavaThread::send_async_exception(JavaThread* target, oop java_throwable) {\n+void JavaThread::send_async_exception(oop java_thread, oop java_throwable) {\n@@ -1687,0 +1701,1 @@\n+  JavaThread* target = java_lang_Thread::thread(java_thread);\n@@ -1835,2 +1850,0 @@\n-  thread->set_thread_state(_thread_in_vm);\n-\n@@ -1840,1 +1853,1 @@\n-  SafepointMechanism::process_if_requested_with_exit_check(thread, true \/* check asyncs *\/);\n+  SafepointMechanism::process_if_requested_with_exit_check(thread, false \/* check asyncs *\/);\n@@ -1846,0 +1859,6 @@\n+\n+  if (thread->has_async_exception_condition(false \/* check unsafe access error *\/)) {\n+    \/\/ We are in _thread_in_native_trans state, don't handle unsafe\n+    \/\/ access error since that may block.\n+    thread->check_and_handle_async_exceptions();\n+  }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":37,"deletions":18,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -805,4 +805,14 @@\n-  oop     _pending_async_exception;\n-#ifdef ASSERT\n-  bool    _is_unsafe_access_error;\n-#endif\n+  enum AsyncExceptionCondition {\n+    _no_async_condition = 0,\n+    _async_exception,\n+    _async_unsafe_access_error\n+  };\n+  AsyncExceptionCondition _async_exception_condition;\n+  oop                     _pending_async_exception;\n+\n+  void set_async_exception_condition(AsyncExceptionCondition aec) { _async_exception_condition = aec; }\n+  AsyncExceptionCondition clear_async_exception_condition() {\n+    AsyncExceptionCondition x = _async_exception_condition;\n+    _async_exception_condition = _no_async_condition;\n+    return x;\n+  }\n@@ -810,1 +820,0 @@\n-  inline bool clear_async_exception_condition();\n@@ -812,2 +821,3 @@\n-  bool has_async_exception_condition() {\n-    return (_suspend_flags & _has_async_exception) != 0;\n+  bool has_async_exception_condition(bool check_unsafe_access_error = true) {\n+    return check_unsafe_access_error ? _async_exception_condition != _no_async_condition\n+                                     : _async_exception_condition == _async_exception;\n@@ -816,3 +826,6 @@\n-  inline void set_pending_unsafe_access_error();\n-  static void send_async_exception(JavaThread* jt, oop java_throwable);\n-  void send_thread_stop(oop throwable);\n+  void set_pending_unsafe_access_error()  {\n+    \/\/ Don't overwrite an asynchronous exception sent by another thread\n+    if (_async_exception_condition == _no_async_condition) {\n+      set_async_exception_condition(_async_unsafe_access_error);\n+    }\n+  }\n@@ -820,0 +833,3 @@\n+  \/\/ Installs a pending exception to be inserted later\n+  static void send_async_exception(oop thread_oop, oop java_throwable);\n+  void send_thread_stop(oop throwable);\n@@ -1164,1 +1180,2 @@\n-    return (_suspend_flags & (_has_async_exception | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_async_exception_condition != _no_async_condition) ||\n+           (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":28,"deletions":11,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -125,6 +125,0 @@\n-inline bool JavaThread::clear_async_exception_condition() {\n-  bool ret = has_async_exception_condition();\n-  clear_suspend_flag(_has_async_exception);\n-  return ret;\n-}\n-\n@@ -133,0 +127,4 @@\n+  set_async_exception_condition(_async_exception);\n+  \/\/ Set _suspend_flags too so we save a comparison in the transition from native to Java\n+  \/\/ in the native wrappers. It will be cleared in check_and_handle_async_exceptions()\n+  \/\/ when we actually install the exception.\n@@ -136,5 +134,0 @@\n-inline void JavaThread::set_pending_unsafe_access_error() {\n-  set_suspend_flag(_has_async_exception);\n-  DEBUG_ONLY(_is_unsafe_access_error = true);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  Monitor timer(Mutex::nosafepoint, \"VM_ExitTimer_lock\");\n+  Monitor timer(Mutex::nosafepoint, \"VM_ExitTimer_lock\", Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -720,0 +720,1 @@\n+  nonstatic_field(JavaThread,                  _async_exception_condition,                    JavaThread::AsyncExceptionCondition)   \\\n@@ -1953,0 +1954,1 @@\n+  declare_integer_type(JavaThread::AsyncExceptionCondition)               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,2 @@\n-  _terminate_lock = new Monitor(Mutex::nosafepoint, \"VMThreadTerminate_lock\");\n+  _terminate_lock = new Monitor(Mutex::nosafepoint, \"VMThreadTerminate_lock\",\n+                                Monitor::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-    _lock = new (std::nothrow) PaddedMonitor(Mutex::safepoint, \"ParallelHProfWriter_lock\");\n+    _lock = new (std::nothrow) PaddedMonitor(Mutex::nonleaf, \"ParallelHProfWriter_lock\", Mutex::_safepoint_check_always);\n@@ -1817,1 +1817,2 @@\n-     _lock(new (std::nothrow) PaddedMonitor(Mutex::safepoint, \"DumperController_lock\")),\n+     _lock(new (std::nothrow) PaddedMonitor(Mutex::nonleaf, \"DumperController_lock\",\n+    Mutex::_safepoint_check_always)),\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -203,1 +203,2 @@\n-  _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"HProfCompressionBackend_lock\")) {\n+  _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"HProfCompressionBackend_lock\",\n+    Mutex::_safepoint_check_never)) {\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,1 +177,2 @@\n-  _last_gc_lock = new Mutex(Mutex::nosafepoint, \"GCMemoryManager_lock\");\n+  _last_gc_lock = new Mutex(Mutex::nosafepoint, \"GCMemoryManager_lock\",\n+                            Mutex::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/services\/memoryManager.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1017,1 +1017,2 @@\n-    new Mutex(Mutex::nosafepoint-2, \"ConcurrentHashTableResize_lock\");\n+    new Mutex(Mutex::nosafepoint-2, \"ConcurrentHashTableResize_lock\",\n+              Mutex::_safepoint_check_never);\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    _mutex(Mutex::event, name),\n+    _mutex(Mutex::event, name, Mutex::_safepoint_check_never),\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,0 @@\n-bool              VMError::_print_native_stack_used = false;\n@@ -245,102 +244,0 @@\n-\/**\n- * Adds `value` to `list` iff it's not already present and there is sufficient\n- * capacity (i.e. length(list) < `list_capacity`). The length of the list\n- * is the index of the first nullptr entry or `list_capacity` if there are\n- * no nullptr entries.\n- *\n- * @ return true if the value was added, false otherwise\n- *\/\n-static bool add_if_absent(address value, address* list, int list_capacity) {\n-  for (int i = 0; i < list_capacity; i++) {\n-    if (list[i] == value) {\n-      return false;\n-    }\n-    if (list[i] == nullptr) {\n-      list[i] = value;\n-      if (i + 1 < list_capacity) {\n-        list[i + 1] = nullptr;\n-      }\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-\/**\n- * Prints the VM generated code unit, if any, containing `pc` if it has not already\n- * been printed. If the code unit is an InterpreterCodelet or StubCodeDesc, it is\n- * only printed if `is_crash_pc` is true.\n- *\n- * @param printed array of code units that have already been printed (delimited by NULL entry)\n- * @param printed_capacity the capacity of `printed`\n- * @return true if the code unit was printed, false otherwise\n- *\/\n-static bool print_code(outputStream* st, Thread* thread, address pc, bool is_crash_pc,\n-                       address* printed, int printed_capacity) {\n-  if (Interpreter::contains(pc)) {\n-    if (is_crash_pc) {\n-      \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n-      InterpreterCodelet* codelet = Interpreter::codelet_containing(pc);\n-      if (codelet != nullptr) {\n-        if (add_if_absent((address) codelet, printed, printed_capacity)) {\n-          codelet->print_on(st);\n-          Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n-          return true;\n-        }\n-      }\n-    }\n-  } else {\n-    StubCodeDesc* desc = StubCodeDesc::desc_for(pc);\n-    if (desc != nullptr) {\n-      if (is_crash_pc) {\n-        if (add_if_absent((address) desc, printed, printed_capacity)) {\n-          desc->print_on(st);\n-          Disassembler::decode(desc->begin(), desc->end(), st);\n-          return true;\n-        }\n-      }\n-    } else if (thread != nullptr) {\n-      CodeBlob* cb = CodeCache::find_blob(pc);\n-      if (cb != nullptr && add_if_absent((address) cb, printed, printed_capacity)) {\n-        \/\/ Disassembling nmethod will incur resource memory allocation,\n-        \/\/ only do so when thread is valid.\n-        ResourceMark rm(thread);\n-        Disassembler::decode(cb, st);\n-        st->cr();\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n-\/**\n- * Gets the caller frame of `fr`.\n- *\n- * @returns an invalid frame (i.e. fr.pc() === 0) if the caller cannot be obtained\n- *\/\n-static frame next_frame(frame fr, Thread* t) {\n-  \/\/ Compiled code may use EBP register on x86 so it looks like\n-  \/\/ non-walkable C frame. Use frame.sender() for java frames.\n-  frame invalid;\n-  if (t != nullptr && t->is_Java_thread()) {\n-    \/\/ Catch very first native frame by using stack address.\n-    \/\/ For JavaThread stack_base and stack_size should be set.\n-    if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n-      return invalid;\n-    }\n-    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n-      RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n-      return fr.sender(&map);\n-    } else {\n-      \/\/ is_first_C_frame() does only simple checks for frame pointer,\n-      \/\/ it will pass if java compiled code has a pointer in EBP.\n-      if (os::is_first_C_frame(&fr)) return invalid;\n-      return os::get_sender_for_C_frame(&fr);\n-    }\n-  } else {\n-    if (os::is_first_C_frame(&fr)) return invalid;\n-    return os::get_sender_for_C_frame(&fr);\n-  }\n-}\n-\n@@ -364,3 +261,20 @@\n-      fr = next_frame(fr, t);\n-      if (fr.pc() == nullptr) {\n-        break;\n+      \/\/ Compiled code may use EBP register on x86 so it looks like\n+      \/\/ non-walkable C frame. Use frame.sender() for java frames.\n+      if (t && t->is_Java_thread()) {\n+        \/\/ Catch very first native frame by using stack address.\n+        \/\/ For JavaThread stack_base and stack_size should be set.\n+        if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n+          break;\n+        }\n+        if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n+          fr = fr.sender(&map);\n+        } else {\n+          \/\/ is_first_C_frame() does only simple checks for frame pointer,\n+          \/\/ it will pass if java compiled code has a pointer in EBP.\n+          if (os::is_first_C_frame(&fr)) break;\n+          fr = os::get_sender_for_C_frame(&fr);\n+        }\n+      } else {\n+        if (os::is_first_C_frame(&fr)) break;\n+        fr = os::get_sender_for_C_frame(&fr);\n@@ -836,1 +750,0 @@\n-       _print_native_stack_used = true;\n@@ -911,1 +824,1 @@\n-  STEP(\"printing code blobs if possible\")\n+  STEP(\"printing code blob if possible\")\n@@ -914,16 +827,8 @@\n-       const int printed_capacity = max_error_log_print_code;\n-       address printed[printed_capacity];\n-       printed[0] = nullptr;\n-       int printed_len = 0;\n-       \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n-       \/\/ during argument parsing, there's no way to prevent it\n-       \/\/ subsequently (i.e., after parsing) being set to a\n-       \/\/ value outside the range.\n-       int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n-       if (limit > 0) {\n-         \/\/ Scan the native stack\n-         if (!_print_native_stack_used) {\n-           \/\/ Only try to print code of the crashing frame since\n-           \/\/ the native stack cannot be walked with next_frame.\n-           if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n-             printed_len++;\n+       CodeBlob* cb = CodeCache::find_blob(_pc);\n+       if (cb != NULL) {\n+         if (Interpreter::contains(_pc)) {\n+           \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n+           InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);\n+           if (codelet != NULL) {\n+             codelet->print_on(st);\n+             Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n@@ -932,19 +837,10 @@\n-           frame fr = os::fetch_frame_from_context(_context);\n-           while (printed_len < limit && fr.pc() != nullptr) {\n-             if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n-               printed_len++;\n-             }\n-             fr = next_frame(fr, _thread);\n-           }\n-         }\n-\n-         \/\/ Scan the Java stack\n-         if (_thread != nullptr && _thread->is_Java_thread()) {\n-           JavaThread* jt = JavaThread::cast(_thread);\n-           if (jt->has_last_Java_frame()) {\n-             for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n-               address pc = sfs.current()->pc();\n-               if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n-                 printed_len++;\n-               }\n-             }\n+           StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);\n+           if (desc != NULL) {\n+             desc->print_on(st);\n+             Disassembler::decode(desc->begin(), desc->end(), st);\n+           } else if (_thread != NULL) {\n+             \/\/ Disassembling nmethod will incur resource memory allocation,\n+             \/\/ only do so when thread is valid.\n+             ResourceMark rm(_thread);\n+             Disassembler::decode(cb, st);\n+             st->cr();\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":39,"deletions":143,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -54,4 +54,0 @@\n-  \/\/ records if VMError::print_native_stack was used to\n-  \/\/ print the native stack instead of os::platform_print_native_stack\n-  static bool        _print_native_stack_used;\n-\n@@ -188,3 +184,0 @@\n-  \/\/ Max value for the ErrorLogPrintCodeLimit flag.\n-  static const int max_error_log_print_code = 10;\n-\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -234,0 +234,8 @@\n+    \/**\n+     * The maximum size of array to allocate (unless necessary).\n+     * Some VMs reserve some header words in an array.\n+     * Attempts to allocate larger arrays may result in\n+     * OutOfMemoryError: Requested array size exceeds VM limit\n+     *\/\n+    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n+\n@@ -239,2 +247,2 @@\n-     * {@code (SOFT_MAX_ARRAY_LENGTH >> coder)}\n-     * unless the given minimum capacity is greater than that.\n+     * {@code (MAX_ARRAY_SIZE >> coder)} unless the given minimum capacity\n+     * is greater than that.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2210,0 +2210,1 @@\n+            ru.host = child.host;\n@@ -3492,2 +3493,0 @@\n-                p = q;\n-                q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);\n@@ -3495,2 +3494,0 @@\n-                    if (input.charAt(q - 1) == '-')\n-                        fail(\"Illegal character in hostname\", q - 1);\n@@ -3498,0 +3495,6 @@\n+                    q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);\n+                    if (q > p) {\n+                        if (input.charAt(q - 1) == '-')\n+                            fail(\"Illegal character in hostname\", q - 1);\n+                        p = q;\n+                    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2517,1 +2517,0 @@\n-     * @see FileSystemProvider#checkAccess\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-                        (getManifestFromReference(), jv.manifestName);\n+                        (getManifestFromReference());\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                mev = new ManifestEntryVerifier(man, jv.manifestName);\n+                mev = new ManifestEntryVerifier(man);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-            this.mev = new ManifestEntryVerifier(man, jv.manifestName);\n+            this.mev = new ManifestEntryVerifier(man);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,3 +66,1 @@\n-\n-    private final String manifestFileName; \/\/ never null\n-    private final Manifest man;\n+    private Manifest man;\n@@ -79,1 +77,1 @@\n-    public ManifestEntryVerifier(Manifest man, String manifestFileName)\n+    public ManifestEntryVerifier(Manifest man)\n@@ -84,1 +82,0 @@\n-        this.manifestFileName = manifestFileName;\n@@ -193,0 +190,1 @@\n+     *\n@@ -214,0 +212,1 @@\n+\n@@ -255,2 +254,1 @@\n-     * or null if the signers for this entry have already been checked\n-     * or there are no signers for this entry.\n+     * or null if the signers for this entry have already been checked.\n@@ -267,1 +265,1 @@\n-        if (verifiedSigners.containsKey(manifestFileName)) {\n+        if (verifiedSigners.containsKey(JarFile.MANIFEST_NAME)) {\n@@ -273,1 +271,1 @@\n-                    verifiedSigners.get(manifestFileName));\n+                    verifiedSigners.get(JarFile.MANIFEST_NAME));\n@@ -276,3 +274,0 @@\n-            if (debug != null) {\n-                debug.println(manifestFileName + \" not present in verifiedSigners\");\n-            }\n@@ -280,1 +275,1 @@\n-            if (signers == null || verifiedSigners.containsValue(signers)) {\n+            if (verifiedSigners.containsValue(signers)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ManifestEntryVerifier.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-                    \/\/ Ideally, if JSR310 can just pass in the negative and\n+                    \/\/ Ideally, if JSR310 can just pass in the nagative and\n@@ -621,0 +621,28 @@\n+\n+                \/\/ Note: known mismatching -> Asia\/Amman\n+                \/\/ ZoneInfo :      startDayOfWeek=5     <= Thursday\n+                \/\/                 startTime=86400000   <= 24 hours\n+                \/\/ This:           startDayOfWeek=6\n+                \/\/                 startTime=0\n+                \/\/ Similar workaround needs to be applied to Africa\/Cairo and\n+                \/\/ its endDayOfWeek and endTime\n+                \/\/ Below is the workarounds, it probably slows down everyone a little\n+                if (params[2] == 6 && params[3] == 0 &&\n+                    (zoneId.equals(\"Asia\/Amman\"))) {\n+                    params[2] = 5;\n+                    params[3] = 86400000;\n+                }\n+                \/\/ Additional check for startDayOfWeek=6 and starTime=86400000\n+                \/\/ is needed for Asia\/Amman;\n+                if (params[2] == 7 && params[3] == 0 &&\n+                     (zoneId.equals(\"Asia\/Amman\"))) {\n+                    params[2] = 6;        \/\/ Friday\n+                    params[3] = 86400000; \/\/ 24h\n+                }\n+                \/\/endDayOfWeek and endTime workaround\n+                if (params[7] == 6 && params[8] == 0 &&\n+                    (zoneId.equals(\"Africa\/Cairo\"))) {\n+                    params[7] = 5;\n+                    params[8] = 86400000;\n+                }\n+\n@@ -869,1 +897,0 @@\n-    \/\/ timeEndOfDay is included in secondOfDay as \"86,400\" secs.\n@@ -875,0 +902,1 @@\n+        private final boolean timeEndOfDay;\n@@ -892,0 +920,1 @@\n+            this.timeEndOfDay = timeByte == 24;\n@@ -893,0 +922,1 @@\n+\n@@ -911,0 +941,3 @@\n+            if (timeEndOfDay) {\n+                epochDay += 1;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -474,2 +474,0 @@\n-         * Windows 11                   10              0  (VER_NT_WORKSTATION)\n-         *       where (buildNumber >= 22000)\n@@ -549,8 +547,1 @@\n-                    case  0:\n-                        \/* Windows 11 21H2 (original release) build number is 22000 *\/\n-                        if (buildNumber >= 22000) {\n-                            sprops.os_name = \"Windows 11\";\n-                        } else {\n-                            sprops.os_name = \"Windows 10\";\n-                        }\n-                        break;\n+                    case  0: sprops.os_name = \"Windows 10\";           break;\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-    private volatile long overriddenWindowHandle;\n+    private volatile long overriddenWindowHandle = 0L;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWLightweightFramePeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-    private volatile boolean isMouseOver;\n+    private volatile boolean isMouseOver = false;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWWindowPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    volatile boolean fIsIndeterminate;\n+    volatile boolean fIsIndeterminate = false;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CCheckboxMenuItem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        return \"-\".equals(label);\n+        return (label != null && label.equals(\"-\"));\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CMenuItem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    private volatile int screenX;\n-    private volatile int screenY;\n+    private volatile int screenX = 0;\n+    private volatile int screenY = 0;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformEmbeddedFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private volatile int currentIcon;\n+    private volatile int currentIcon = 0;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CWarningWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,2 +101,5 @@\n-                throw new IIOInvalidTreeException\n-                        (\"Can't get User Object\", e, node);\n+                IIOInvalidTreeException newGuy =\n+                    new IIOInvalidTreeException\n+                    (\"Can't get User Object\", node);\n+                newGuy.initCause(e);\n+                throw newGuy;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/MarkerSegment.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private static volatile Set<Integer> essentialTags;\n+    private static volatile Set<Integer> essentialTags = null;\n@@ -64,1 +64,1 @@\n-            essentialTags = Set.of(\n+            essentialTags = tags = Set.of(\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFIFD.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1711,1 +1711,1 @@\n-            return Boolean.parseBoolean(str);\n+            return Boolean.valueOf(str).booleanValue();\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/Metacity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-        protected volatile boolean flushing;\n+        protected volatile boolean flushing = false;\n@@ -367,4 +367,4 @@\n-        protected volatile boolean doIO;     \/\/ true in between start() and stop() calls\n-        protected volatile boolean stoppedWritten; \/\/ true if a write occurred in stopped state\n-        protected volatile boolean drained; \/\/ set to true when drain function returns, set to false in write()\n-        protected boolean monitoring;\n+        protected volatile boolean doIO = false;     \/\/ true in between start() and stop() calls\n+        protected volatile boolean stoppedWritten = false; \/\/ true if a write occurred in stopped state\n+        protected volatile boolean drained = false; \/\/ set to true when drain function returns, set to false in write()\n+        protected boolean monitoring = false;\n@@ -382,1 +382,1 @@\n-        protected volatile boolean noService; \/\/ do not run the nService method\n+        protected volatile boolean noService = false; \/\/ do not run the nService method\n@@ -978,1 +978,1 @@\n-        private volatile byte[] audioData;\n+        private volatile byte[] audioData = null;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DirectAudioDevice.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,2 @@\n-    private volatile boolean active;\n-    private SourceDataLine sourceDataLine;\n+    private volatile boolean active = false;\n+    private SourceDataLine sourceDataLine = null;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftAudioPusher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        public volatile long silent_samples;\n+        public volatile long silent_samples = 0;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftSynthesizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    private volatile boolean valid;\n+    private volatile boolean valid = false;\n@@ -9343,1 +9343,1 @@\n-        private transient volatile int propertyListenersCount;\n+        private transient volatile int propertyListenersCount = 0;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3864,1 +3864,1 @@\n-        private transient volatile int propertyListenersCount;\n+        private transient volatile int propertyListenersCount = 0;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Container.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    transient volatile boolean isInHide;\n+    transient volatile boolean isInHide = false;\n@@ -315,1 +315,1 @@\n-    transient volatile boolean isInDispose;\n+    transient volatile boolean isInDispose = false;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Dialog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -407,2 +407,2 @@\n-    private transient volatile int securityWarningWidth;\n-    private transient volatile int securityWarningHeight;\n+    private transient volatile int securityWarningWidth = 0;\n+    private transient volatile int securityWarningHeight = 0;\n@@ -420,1 +420,1 @@\n-        systemSyncLWRequests = \"true\".equals(s);\n+        systemSyncLWRequests = (s != null && s.equals(\"true\"));\n@@ -424,1 +424,1 @@\n-        locationByPlatformProp = \"true\".equals(s2);\n+        locationByPlatformProp = (s2 != null && s2.equals(\"true\"));\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    private volatile boolean dispatched;\n+    private volatile boolean dispatched = false;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/InvocationEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1367,1 +1367,1 @@\n-    private transient volatile int stCache;\n+    private transient volatile int stCache = 0;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,1 +410,4 @@\n-            throw new IllegalStateException(\"Can't obtain format\", e);\n+            RuntimeException ex =\n+                new IllegalStateException (\"Can't obtain format\");\n+            ex.initCause(e);\n+            throw ex;\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/IIOMetadata.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.io.IOException;\n+import java.lang.reflect.Constructor;\n@@ -31,0 +33,3 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import javax.imageio.ImageReader;\n@@ -34,0 +39,1 @@\n+import javax.imageio.stream.ImageInputStream;\n@@ -594,1 +600,4 @@\n-            throw new IllegalStateException(\"Can't obtain format\", e);\n+            RuntimeException ex =\n+                new IllegalStateException (\"Can't obtain format\");\n+            ex.initCause(e);\n+            throw ex;\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/ImageReaderWriterSpi.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,1 +331,1 @@\n-            } else if (\"outline\".equals(mode)) {\n+            } else if (mode != null && mode.equals(\"outline\")) {\n@@ -333,1 +333,1 @@\n-            } else if (\"faster\".equals(mode)\n+            } else if (mode != null && mode.equals(\"faster\")\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultDesktopManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3755,1 +3755,1 @@\n-        private transient volatile int propertyListenersCount;\n+        private transient volatile int propertyListenersCount = 0;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,1 @@\n-                    if (FRAME_CONTENT_LAYER.equals(layer))\n+                    if(layer != null && layer.equals(FRAME_CONTENT_LAYER))\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLayeredPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-            suppressDropSupport = Boolean.parseBoolean(\n+            suppressDropSupport = Boolean.valueOf(\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingUtilities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -827,1 +827,1 @@\n-            if (\"\/net\".equals(parent)) {\n+            if (parent != null && parent.equals(\"\/net\")) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/filechooser\/FileSystemView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,4 +379,3 @@\n-     * divider is contained in changes. Will create the\n-     * <code>leftButton<\/code> and <code>rightButton<\/code> if they are null\n-     * and corresponding JSplitPane supports oneTouchExpandable property.\n-     * Invalidates the corresponding JSplitPane as well.\n+     * receiver is contained in changes. Will create the\n+     * <code>leftButton<\/code> and <code>rightButton<\/code> if they\n+     * are null. invalidates the receiver as well.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -128,1 +128,2 @@\n-                useSystemFonts = Boolean.parseBoolean(systemFonts);\n+                useSystemFonts = (systemFonts != null &&\n+                               (Boolean.valueOf(systemFonts).booleanValue()));\n@@ -1400,2 +1401,2 @@\n-            \"Tree.expandedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(MetalIconFactory.DARK),\n-            \"Tree.collapsedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(MetalIconFactory.LIGHT),\n+            \"Tree.expandedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(Boolean.valueOf(MetalIconFactory.DARK)),\n+            \"Tree.collapsedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(Boolean.valueOf( MetalIconFactory.LIGHT )),\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1329,1 +1329,1 @@\n-                    if (\"pre\".equals(ws)) {\n+                    if ((ws != null) && ws.equals(\"pre\")) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLEditorKit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-    private static volatile AppContext mainAppContext;\n+    private static volatile AppContext mainAppContext = null;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        touchKeyboardAutoShowIsEnabled = Boolean.parseBoolean(\n+        touchKeyboardAutoShowIsEnabled = Boolean.valueOf(\n@@ -1770,1 +1770,2 @@\n-                useSystemAAFontSettings = Boolean.parseBoolean(systemAAFonts);\n+                useSystemAAFontSettings =\n+                    Boolean.valueOf(systemAAFonts).booleanValue();\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    private volatile int numberOfFlavorListeners;\n+    private volatile int numberOfFlavorListeners = 0;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/SunClipboard.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-                throw new IOException(cnfe);\n+                throw (IOException)new IOException().initCause(cnfe);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/TransferableProxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-    private static volatile boolean dragDropInProgress;\n-    private static volatile boolean discardingMouseEvents;\n+    private static volatile boolean dragDropInProgress = false;\n+    private static volatile boolean discardingMouseEvents = false;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/dnd\/SunDragSourceContextPeer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        Boolean.parseBoolean(java.security.AccessController.doPrivileged(\n+        Boolean.valueOf(java.security.AccessController.doPrivileged(\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/VSyncedBSManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    public static volatile boolean pollingQueue;\n+    public static volatile boolean pollingQueue = false;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import sun.awt.image.SurfaceManager.FlushableCacheData;\n@@ -76,1 +77,1 @@\n-        if (\"false\".equals(manimg)) {\n+        if (manimg != null && manimg.equals(\"false\")) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceDataProxy.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        return Boolean.parseBoolean(AccessController.doPrivileged(\n+        return Boolean.valueOf(AccessController.doPrivileged(\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-        private static volatile RendererStatsHolder SINGLETON;\n+        private static volatile RendererStatsHolder SINGLETON = null;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererStats.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1550,1 +1550,1 @@\n-        if (JobSheets.NONE.equals(js)) {\n+        if (js != null && js.equals(JobSheets.NONE)) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    private volatile long widget;\n+    private volatile long widget = 0L;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/GtkFileDialogPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    private boolean mouseDraggedOutVertically;\n-    private volatile boolean vsbVisibilityChanged;\n+    private boolean mouseDraggedOutVertically = false;\n+    private volatile boolean vsbVisibilityChanged = false;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/ListHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -431,3 +431,3 @@\n-            r = Integer.parseInt(color.substring(0, 4), 16) >> 8;\n-            g = Integer.parseInt(color.substring(4, 8), 16) >> 8;\n-            b = Integer.parseInt(color.substring(8, 12), 16) >> 8;\n+            r = Integer.valueOf(color.substring(0,4),16).intValue() >> 8;\n+            g = Integer.valueOf(color.substring(4,8),16).intValue() >> 8;\n+            b = Integer.valueOf(color.substring(8,12),16).intValue() >> 8;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/MotifColorUtilities.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    private static volatile long xicFocus;\n+    private static volatile long xicFocus = 0;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XInputMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    private volatile long overriddenWindowHandle;\n+    private volatile long overriddenWindowHandle = 0L;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XLightweightFramePeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        isUnity = \"Unity\".equals(de);\n+        isUnity = de != null && de.equals(\"Unity\");\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XTaskbarPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private volatile int currentIcon;\n+    private volatile int currentIcon = 0;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWarningWindow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        if (JobSheets.NONE.equals(js)) {\n+        if (js != null && js.equals(JobSheets.NONE)) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/UnixPrintJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,1 +189,2 @@\n-        useSystemFontSettings = systemFonts == null || Boolean.parseBoolean(systemFonts);\n+        useSystemFontSettings = (systemFonts == null ||\n+                                 Boolean.valueOf(systemFonts).booleanValue());\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLookAndFeel.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private static volatile boolean valid;\n+    private static volatile boolean valid = false;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/ThemeReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        Boolean.parseBoolean(AccessController.doPrivileged(\n+        Boolean.valueOf(AccessController.doPrivileged(\n@@ -75,1 +75,1 @@\n-        Boolean.parseBoolean(AccessController.doPrivileged(\n+        Boolean.valueOf(AccessController.doPrivileged(\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/TranslucentWindowPainter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-        if (Boolean.TRUE.equals(smoothingOn)) {\n+        if (smoothingOn != null && smoothingOn.equals(Boolean.TRUE)) {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDesktopProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    volatile Error createError;\n+    volatile Error createError = null;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WObjectPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1803,1 +1803,0 @@\n-                preFlow(c);\n@@ -5922,2 +5921,0 @@\n-            initTypeIfNeeded(that);\n-            initTypeIfNeeded(that.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-        hprofBufferedOut = new BufferedOutputStream(fos);\n+        hprofBufferedOut = fos;\n@@ -415,1 +415,1 @@\n-                hprofBufferedOut = new GZIPOutputStream(hprofBufferedOut) {\n+                hprofBufferedOut = new GZIPOutputStream(fos) {\n@@ -618,2 +618,0 @@\n-            \/\/ We must flush all data to the file before reading the current file position.\n-            out.flush();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,4 +359,3 @@\n-      size_t header_size = sizeof(CDSFileMapHeaderBase);\n-      memset(&header, 0, header_size);\n-      if ((n = read(fd, &header, header_size))\n-           != header_size) {\n+      memset(&header, 0, sizeof(CDSFileMapHeaderBase));\n+      if ((n = read(fd, &header, sizeof(CDSFileMapHeaderBase)))\n+           != sizeof(CDSFileMapHeaderBase)) {\n@@ -369,1 +368,1 @@\n-      if (header._generic_header._magic != CDS_ARCHIVE_MAGIC) {\n+      if (header._magic != CDS_ARCHIVE_MAGIC) {\n@@ -371,1 +370,1 @@\n-                    classes_jsa, header._generic_header._magic, CDS_ARCHIVE_MAGIC);\n+                    classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);\n@@ -377,1 +376,1 @@\n-      if (header._generic_header._version != CURRENT_CDS_ARCHIVE_VERSION) {\n+      if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {\n@@ -379,1 +378,1 @@\n-                     classes_jsa, header._generic_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+                     classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/ps_core_common.c","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        for (TypeElement te : utils.getAllClasses(pkg)) {\n+        for (Element te : utils.getAllClasses(pkg)) {\n@@ -160,1 +160,1 @@\n-                convertClass(te, outputdir);\n+                convertClass((TypeElement)te, outputdir);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SourceToHTMLConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,1 +236,2 @@\n-        for (VariableElement field : utils.getFieldsUnfiltered(currentTypeElement)) {\n+        for (Element e : utils.getFieldsUnfiltered(currentTypeElement)) {\n+            VariableElement field = (VariableElement)e;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,1 +115,2 @@\n-        for (TypeElement te : configuration.getIncludedTypeElements()) {\n+        for (Element e : configuration.getIncludedTypeElements()) {\n+            TypeElement te = (TypeElement)e;\n@@ -117,2 +118,2 @@\n-            if (belongsToSummary.test(te)) {\n-                switch (te.getKind()) {\n+            if (belongsToSummary.test(e)) {\n+                switch (e.getKind()) {\n@@ -121,1 +122,1 @@\n-                        eset.add(te);\n+                        eset.add(e);\n@@ -131,1 +132,1 @@\n-                        eset.add(te);\n+                        eset.add(e);\n@@ -135,1 +136,1 @@\n-                        eset.add(te);\n+                        eset.add(e);\n@@ -139,1 +140,1 @@\n-                        eset.add(te);\n+                        eset.add(e);\n@@ -143,1 +144,1 @@\n-                        eset.add(te);\n+                        eset.add(e);\n@@ -154,1 +155,1 @@\n-            if (utils.isEnum(te)) {\n+            if (utils.isEnum(e)) {\n@@ -167,1 +168,1 @@\n-            if (utils.isAnnotationType(te)) {\n+            if (utils.isAnnotationType(e)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/SummaryAPIListBuilder.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    _lock = new Mutex(Monitor::nosafepoint, \"gtest-IsMetaspaceObjTest_lock\");\n+    _lock = new Mutex(Monitor::nosafepoint, \"gtest-IsMetaspaceObjTest_lock\", Monitor::_safepoint_check_never);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_is_metaspace_obj.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTest_lock\");\n+    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTest_lock\", Monitor::_safepoint_check_never);\n@@ -742,47 +742,0 @@\n-\n-\/\/ Test that repeated allocation-deallocation cycles with the same block size\n-\/\/  do not increase metaspace usage after the initial allocation (the deallocated\n-\/\/  block should be reused by the next allocation).\n-static void test_repeatedly_allocate_and_deallocate(bool is_topmost) {\n-  if (Settings::handle_deallocations()) {\n-    \/\/ Test various sizes, including (important) the max. possible block size = 1 root chunk\n-    for (size_t blocksize = Metaspace::max_allocation_word_size(); blocksize >= 1; blocksize \/= 2) {\n-      size_t used1 = 0, used2 = 0, committed1 = 0, committed2 = 0;\n-      MetaWord* p = NULL, *p2 = NULL;\n-\n-      MetaspaceGtestContext context;\n-      MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);\n-\n-      \/\/ First allocation\n-      helper.allocate_from_arena_with_tests_expect_success(&p, blocksize);\n-      if (!is_topmost) {\n-        \/\/ another one on top, size does not matter.\n-        helper.allocate_from_arena_with_tests_expect_success(0x10);\n-      }\n-\n-      \/\/ Measure\n-      helper.usage_numbers_with_test(&used1, &committed1, NULL);\n-\n-      \/\/ Dealloc, alloc several times with the same size.\n-      for (int i = 0; i < 5; i ++) {\n-        helper.deallocate_with_tests(p, blocksize);\n-        helper.allocate_from_arena_with_tests_expect_success(&p2, blocksize);\n-        \/\/ We should get the same pointer back.\n-        EXPECT_EQ(p2, p);\n-      }\n-\n-      \/\/ Measure again\n-      helper.usage_numbers_with_test(&used2, &committed2, NULL);\n-      EXPECT_EQ(used2, used1);\n-      EXPECT_EQ(committed1, committed2);\n-    }\n-  }\n-}\n-\n-TEST_VM(metaspace, MetaspaceArena_test_repeatedly_allocate_and_deallocate_top_allocation) {\n-  test_repeatedly_allocate_and_deallocate(true);\n-}\n-\n-TEST_VM(metaspace, MetaspaceArena_test_repeatedly_allocate_and_deallocate_nontop_allocation) {\n-  test_repeatedly_allocate_and_deallocate(false);\n-}\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":1,"deletions":48,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTestBed_lock\");\n+    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTestBed_lock\", Monitor::_safepoint_check_never);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  m[i] = new Mutex(Mutex::nosafepoint, FormatBuffer<128>(\"MyLock#%u_lock\", i));\n+  m[i] = new Mutex(Mutex::nosafepoint, FormatBuffer<128>(\"MyLock#%u_lock\", i), Mutex::_safepoint_check_never);\n@@ -56,3 +56,3 @@\n-const Mutex::Rank rankA = Mutex::safepoint-5;\n-const Mutex::Rank rankAplusOne = Mutex::safepoint-4;\n-const Mutex::Rank rankAplusTwo = Mutex::safepoint-3;\n+const int rankA = Mutex::nonleaf-5;\n+const int rankAplusOne = Mutex::nonleaf-4;\n+const int rankAplusTwo = Mutex::nonleaf-3;\n@@ -64,2 +64,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n@@ -74,1 +74,1 @@\n-                   \".* Attempting to acquire lock mutex_rankA_plus_one\/safepoint-4 out of order with lock mutex_rankA\/safepoint-5 -- possible deadlock\") {\n+                   \".* Attempting to acquire lock mutex_rankA_plus_one\/.* out of order with lock mutex_rankA\/.* -- possible deadlock\") {\n@@ -78,2 +78,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n@@ -92,2 +92,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n-  Mutex* mutex_rankB = new Mutex(rankA, \"mutex_rankB\");\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankB = new Mutex(rankA, \"mutex_rankB\", Mutex::_safepoint_check_always);\n@@ -105,3 +105,3 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n-  Mutex* mutex_rankA_plus_two = new Mutex(rankAplusTwo, \"mutex_rankA_plus_two\");\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_two = new Mutex(rankAplusTwo, \"mutex_rankA_plus_two\", Mutex::_safepoint_check_always);\n@@ -122,2 +122,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n@@ -134,1 +134,1 @@\n-                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/nosafepoint out of order with lock mutex_rank_event\/event \"\n+                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/.* out of order with lock mutex_rank_event\/0 \"\n@@ -139,2 +139,2 @@\n-  Mutex* mutex_rank_event = new Mutex(Mutex::event, \"mutex_rank_event\");\n-  Mutex* mutex_rank_safepoint = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\");\n+  Mutex* mutex_rank_event = new Mutex(Mutex::event, \"mutex_rank_event\", Mutex::_safepoint_check_never);\n+  Mutex* mutex_rank_nonleaf = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\", Mutex::_safepoint_check_never);\n@@ -143,2 +143,2 @@\n-  mutex_rank_safepoint->lock_without_safepoint_check();\n-  mutex_rank_safepoint->unlock();\n+  mutex_rank_nonleaf->lock_without_safepoint_check();\n+  mutex_rank_nonleaf->unlock();\n@@ -149,1 +149,1 @@\n-                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/nosafepoint out of order with lock mutex_rank_tty\/tty \"\n+                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/.* out of order with lock mutex_rank_tty\/.*\"\n@@ -154,2 +154,2 @@\n-  Mutex* mutex_rank_tty = new Mutex(Mutex::tty, \"mutex_rank_tty\");\n-  Mutex* mutex_rank_nosafepoint = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\");\n+  Mutex* mutex_rank_tty = new Mutex(Mutex::tty, \"mutex_rank_tty\", Mutex::_safepoint_check_never);\n+  Mutex* mutex_rank_nosafepoint = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\", Mutex::_safepoint_check_never);\n@@ -167,2 +167,2 @@\n-  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\");\n-  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\");\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\", Mutex::_safepoint_check_always);\n@@ -183,2 +183,2 @@\n-  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\");\n-  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\");\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\", Mutex::_safepoint_check_always);\n@@ -199,2 +199,2 @@\n-  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\");\n-  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\");\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\", Mutex::_safepoint_check_always);\n@@ -215,3 +215,2 @@\n-  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\");\n-  Monitor* monitor_rank_nosafepoint_minus_one = new Monitor(Mutex::nosafepoint - 1,\n-                                                            \"monitor_rank_nosafepoint_minus_one\");\n+  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", Mutex::_safepoint_check_never);\n+  Monitor* monitor_rank_nosafepoint_minus_one = new Monitor(Mutex::nosafepoint - 1, \"monitor_rank_nosafepoint_minus_one\", Mutex::_safepoint_check_never);\n@@ -230,2 +229,2 @@\n-    Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\");\n-    Monitor* monitor_rank_event = new Monitor(Mutex::event, \"monitor_rank_event\");\n+    Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\", Mutex::_safepoint_check_never);\n+    Monitor* monitor_rank_event = new Monitor(Mutex::event, \"monitor_rank_event\", Mutex::_safepoint_check_never);\n@@ -242,1 +241,1 @@\n-                   \".* Attempting to wait on monitor monitor_rank_event\/event while holding lock monitor_rank_tty\/tty \"\n+                   \".* Attempting to wait on monitor monitor_rank_event\/0 while holding lock monitor_rank_tty\/.*\"\n@@ -250,1 +249,1 @@\n-                   \".* Attempting to wait on monitor monitor_rank_tty\/.* while holding lock monitor_rank_nosafepoint\/.* \"\n+                   \".* Attempting to wait on monitor monitor_rank_tty\/.* while holding lock monitor_rank_nosafepoint\/.*\"\n@@ -255,2 +254,2 @@\n-  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\");\n-  Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\");\n+  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", Mutex::_safepoint_check_never);\n+  Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\", Mutex::_safepoint_check_never);\n@@ -266,1 +265,1 @@\n-                   \".*Locks that don't check for safepoint should always allow the vm to block: monitor_rank_nosafepoint\") {\n+                   \".*Safepoint check never locks should always allow the vm to block\") {\n@@ -270,1 +269,1 @@\n-  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", false);\n+  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", Mutex::_safepoint_check_never, false);\n@@ -280,1 +279,1 @@\n-  Monitor* monitor_rank_broken = new Monitor(Mutex::safepoint-100, \"monitor_rank_broken\");\n+  Monitor* monitor_rank_broken = new Monitor(Mutex::event-1, \"monitor_rank_broken\", Mutex::_safepoint_check_never);\n@@ -285,2 +284,2 @@\n-TEST_VM_ASSERT_MSG(MutexRank, monitor_overlapping_oopstorage_rank,\n-                   \".*Rank oopstorage-4 overlaps with tty-1\") {\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_nosafepoint_rank,\n+                   \".*failed: Locks above nosafepoint rank should safepoint: monitor_rank_nonleaf\") {\n@@ -290,43 +289,3 @@\n-  Monitor* monitor_rank_broken = new Monitor(Mutex::oopstorage-4, \"monitor_rank_broken\");\n-}\n-\n-TEST_VM_ASSERT_MSG(MutexRank, monitor_overlapping_safepoint_rank,\n-                   \".*Rank safepoint-40 overlaps with service-5\") {\n-  JavaThread* THREAD = JavaThread::current();\n-  ThreadInVMfromNative invm(THREAD);\n-\n-  Monitor* monitor_rank_broken = new Monitor(Mutex::safepoint-40, \"monitor_rank_broken\");\n-}\n-\n-TEST_VM_ASSERT_MSG(MutexRank, monitor_overlapping_safepoint_rank2,\n-                   \".*Rank safepoint-1-39 overlaps with service-5\") {\n-  JavaThread* THREAD = JavaThread::current();\n-  ThreadInVMfromNative invm(THREAD);\n-\n-  Monitor* monitor_rank_ok = new Monitor(Mutex::safepoint-1, \"monitor_rank_ok\");\n-  Monitor* monitor_rank_broken = new Monitor(monitor_rank_ok->rank()-39, \"monitor_rank_broken\");\n-}\n-\n-\/\/ Test mismatched safepoint check flag on lock declaration vs. lock acquisition.\n-TEST_VM_ASSERT_MSG(MutexSafepoint, always_check,\n-    \".*This lock should always have a safepoint check for Java threads: SFPT_Test_lock\") {\n-  MutexLocker ml(new Mutex(Mutex::safepoint, \"SFPT_Test_lock\"),\n-                 Mutex::_no_safepoint_check_flag);\n-}\n-\n-TEST_VM_ASSERT_MSG(MutexSafepoint, never_check,\n-    \".*This lock should not be taken with a safepoint check: SFPT_Test_lock\") {\n-  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SFPT_Test_lock\"),\n-                 Mutex::_safepoint_check_flag);\n-}\n-\n-TEST_VM_ASSERT_MSG(MutexSafepoint, possible_safepoint_lock,\n-    \".* Possible safepoint reached by thread that does not allow it\") {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadInVMfromNative in_native(thread);\n-  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SpecialTest_lock\"),\n-                   Mutex::_no_safepoint_check_flag);\n-  thread->print_thread_state_on(tty);\n-  \/\/ If the lock above succeeds, try to safepoint to test the NSV implied with this nosafepoint lock.\n-  ThreadBlockInVM tbivm(thread);\n-  thread->print_thread_state_on(tty);\n+  Monitor* monitor_rank_nonleaf = new Monitor(Mutex::nonleaf, \"monitor_rank_nonleaf\", Mutex::_safepoint_check_never);\n+  monitor_rank_nonleaf->lock_without_safepoint_check();\n+  monitor_rank_nonleaf->unlock();\n","filename":"test\/hotspot\/gtest\/runtime\/test_mutex.cpp","additions":46,"deletions":87,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"unittest.hpp\"\n+\n+#ifdef ASSERT\n+\n+\/\/ Test mismatched safepoint check flag on lock declaration vs. lock acquisition.\n+TEST_VM_ASSERT_MSG(SafepointLockAssertTest, always_check,\n+    \".*This lock should always have a safepoint check for Java threads: SFPT_Test_lock\") {\n+  MutexLocker ml(new Mutex(Mutex::nonleaf, \"SFPT_Test_lock\", Mutex::_safepoint_check_always),\n+                 Mutex::_no_safepoint_check_flag);\n+}\n+\n+TEST_VM_ASSERT_MSG(SafepointLockAssertTest, never_check,\n+    \".*This lock should never have a safepoint check for Java threads: SFPT_Test_lock\") {\n+  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SFPT_Test_lock\", Mutex::_safepoint_check_never),\n+                 Mutex::_safepoint_check_flag);\n+}\n+\n+TEST_VM_ASSERT_MSG(SafepointLockAssertTest, nosafepoint_locks,\n+    \".*Locks below nosafepoint rank should never safepoint: SpecialTest_lock\") {\n+  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SpecialTest_lock\", Mutex::_safepoint_check_always),\n+                 Mutex::_safepoint_check_flag);\n+}\n+\n+TEST_VM_ASSERT_MSG(SafepointLockAssertTest, possible_safepoint_lock,\n+    \".* Possible safepoint reached by thread that does not allow it\") {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadInVMfromNative in_native(thread);\n+  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SpecialTest_lock\", Mutex::_safepoint_check_never),\n+                   Mutex::_no_safepoint_check_flag);\n+  thread->print_thread_state_on(tty);\n+  \/\/ If the lock above succeeds, try to safepoint to test the NSV implied with this nosafepoint lock.\n+  ThreadBlockInVM tbivm(thread);\n+  thread->print_thread_state_on(tty);\n+}\n+\n+#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_safepoint_locks.cpp","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -199,1 +199,1 @@\n-  Mutex lock(Mutex::nosafepoint, \"Test_lock\");\n+  Mutex lock(Mutex::nosafepoint, \"Test_lock\", Mutex::_safepoint_check_never);\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,3 +41,0 @@\n-\n-compiler\/vectorapi\/VectorCastShape64Test.java 8274855 generic-x64\n-compiler\/vectorapi\/VectorCastShape128Test.java 8274855 generic-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8274620 macosx-x64\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,1 +292,0 @@\n-        UNSAFE.storeFence(); \/\/ Make all new Node fields visible to concurrent readers.\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/UnsafeIntrinsicsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,126 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 8274145\n- * @summary C2: Incorrect computation after JDK-8269752\n- *\n- * @run main\/othervm -Xcomp -XX:CompileOnly=TestIfReplacedByMainLoopExit::iMeth -XX:CompileOnly=TestIfReplacedByMainLoopExit::mainTest -XX:-TieredCompilation TestIfReplacedByMainLoopExit\n- *\n- *\/\n-\n-public class TestIfReplacedByMainLoopExit {\n-\n-    public static final int N = 400;\n-\n-    public static long instanceCount=3024694135L;\n-    public static boolean bFld=true;\n-    public int iFld=-11;\n-\n-    public static long iMeth_check_sum = 0;\n-\n-    public static void vMeth(int i3, int i4, int i5) {\n-\n-        int i6=-71, i7=88, i8=217, i9=14, i10=9677, i18=-244, i19=107, iArr[]=new int[N];\n-    }\n-\n-    public static void init(int[] a, int seed) {\n-        for (int j = 0; j < a.length; j++) {\n-            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n-        }\n-    }\n-\n-    public static long checkSum(int[] a) {\n-        long sum = 0;\n-        for (int j = 0; j < a.length; j++) {\n-            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n-        }\n-        return sum;\n-    }\n-\n-    public static int iMeth(boolean b, int i2) {\n-\n-        byte by=81;\n-        int i21=-24074, i22=7, i23=-7, i24=-70, iArr2[]=new int[N];\n-        boolean b2=false;\n-        init(iArr2, -27);\n-\n-        vMeth(189, i2, i2);\n-        for (int i20 : iArr2) {\n-            by *= (byte) TestIfReplacedByMainLoopExit.instanceCount;\n-            for (i23 = 1; i23 < 4; ++i23) {\n-                i24 -= i23;\n-                TestIfReplacedByMainLoopExit.bFld = b2;\n-            }\n-        }\n-        long meth_res = (b ? 1 : 0) + i2 + by + i21 + i22 + i23 + i24 + (b2 ? 1 : 0) + checkSum(iArr2);\n-        iMeth_check_sum += meth_res;\n-        return (int)meth_res;\n-    }\n-\n-    public void mainTest(String[] strArr1) {\n-        int i, i1, i25, i26=9, i27, i28;\n-        byte by1=35;\n-        float f2;\n-\n-        for (i = 17; 310 > i; ++i) {\n-            i1 = ((iMeth(TestIfReplacedByMainLoopExit.bFld, iFld) - iFld) + by1);\n-        }\n-        i1 = 231;\n-        iFld += -13496;\n-        for (i25 = 2; i25 < 271; i25++) {\n-            i26 -= i;\n-            if (TestIfReplacedByMainLoopExit.bFld) break;\n-        }\n-        i26 = i;\n-        iFld += (int)1.338F;\n-        iFld += 30984;\n-        i27 = 1;\n-        do {\n-            iFld *= i25;\n-            for (i28 = 4; i28 < 75; ++i28) {\n-                i1 += i25;\n-            }\n-        } while (++i27 < 335);\n-        f2 = 210;\n-        do {\n-            iFld -= i25;\n-        } while (--f2 > 0);\n-\n-        System.out.println(\"iFld = \" + iFld);\n-    }\n-\n-    public static void main(String[] strArr) {\n-        TestIfReplacedByMainLoopExit _instance = new TestIfReplacedByMainLoopExit();\n-        _instance.mainTest(strArr);\n-        int iFld_sav = _instance.iFld;\n-        for (int i = 0; i < 10; i++ ) {\n-            _instance.iFld=-11;\n-            _instance.mainTest(strArr);\n-            if (_instance.iFld != iFld_sav) {\n-                throw new RuntimeException(\"incorrect execution \" + _instance.iFld + \" != \" + iFld_sav);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestIfReplacedByMainLoopExit.java","additions":0,"deletions":126,"binary":false,"changes":126,"status":"deleted"},{"patch":"@@ -1,185 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8272586\n- * @requires vm.compiler2.enabled\n- * @summary Test that abstract machine code is dumped for the top frames in a hs-err log\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.compiler\n- *          java.management\n- *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n- * @run driver MachCodeFramesInErrorFile\n- *\/\n-\n-import java.lang.annotation.Annotation;\n-import java.lang.reflect.Method;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.Paths;\n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Set;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-import java.util.regex.Pattern;\n-import java.util.regex.Matcher;\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.Asserts;\n-\n-import jdk.internal.misc.Unsafe;\n-\n-public class MachCodeFramesInErrorFile {\n-\n-    private static class Crasher {\n-        \/\/ Make Crasher.unsafe a compile-time constant so that\n-        \/\/ C2 intrinsifies calls to Unsafe intrinsics.\n-        private static final Unsafe unsafe = Unsafe.getUnsafe();\n-\n-        public static void main(String[] args) throws Exception {\n-            if (args[0].equals(\"crashInJava\")) {\n-                \/\/ This test relies on Unsafe.putLong(Object, long, long) being intrinsified\n-                if (!Stream.of(Unsafe.class.getDeclaredMethod(\"putLong\", Object.class, long.class, long.class).getAnnotations()).\n-                    anyMatch(a -> a.annotationType().getName().equals(\"jdk.internal.vm.annotation.IntrinsicCandidate\"))) {\n-                    throw new RuntimeException(\"Unsafe.putLong(Object, long, long) is not an intrinsic\");\n-                }\n-                crashInJava1(10);\n-            } else {\n-                assert args[0].equals(\"crashInVM\");\n-                crashInNative1(10);\n-            }\n-        }\n-\n-        static void crashInJava1(long address) {\n-            System.out.println(\"in crashInJava1\");\n-            crashInJava2(address);\n-        }\n-        static void crashInJava2(long address) {\n-            System.out.println(\"in crashInJava2\");\n-            crashInJava3(address);\n-        }\n-        static void crashInJava3(long address) {\n-            unsafe.putLong(null, address, 42);\n-            System.out.println(\"wrote value to 0x\" + Long.toHexString(address));\n-        }\n-\n-        static void crashInNative1(long address) {\n-            System.out.println(\"in crashInNative1\");\n-            crashInNative2(address);\n-        }\n-        static void crashInNative2(long address) {\n-            System.out.println(\"in crashInNative2\");\n-            crashInNative3(address);\n-        }\n-        static void crashInNative3(long address) {\n-            System.out.println(\"read value \" + unsafe.getLong(address) + \" from 0x\" + Long.toHexString(address));\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        run(true);\n-        run(false);\n-    }\n-\n-    \/**\n-     * Runs Crasher in Xcomp mode. The inner\n-     * most method crashes the VM with Unsafe. The resulting hs-err log is\n-     * expected to have a min number of MachCode sections.\n-     *\/\n-    private static void run(boolean crashInJava) throws Exception {\n-        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n-            \"-Xmx64m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n-            \"-XX:-CreateCoredumpOnCrash\",\n-            \"-Xcomp\",\n-            \"-XX:-TieredCompilation\",\n-            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.crashIn*\",\n-            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.crashIn*\",\n-            \"-XX:CompileCommand=dontinline,*\/Unsafe.getLong\", \/\/ ensures VM call when crashInJava == false\n-            Crasher.class.getName(),\n-            crashInJava ? \"crashInJava\" : \"crashInVM\");\n-        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-\n-        \/\/ Extract hs_err_pid file.\n-        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n-        if (hs_err_file == null) {\n-            throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\" +\n-                                       \"stderr:\\n\" + output.getStderr() + \"\\n\" +\n-                                       \"stdout:\\n\" + output.getStdout());\n-        }\n-        Path hsErrPath = Paths.get(hs_err_file);\n-        if (!Files.exists(hsErrPath)) {\n-            throw new RuntimeException(\"hs_err_pid file missing at \" + hsErrPath + \".\\n\");\n-        }\n-        String hsErr = Files.readString(hsErrPath);\n-        if (System.getenv(\"DEBUG\") != null) {\n-            System.err.println(hsErr);\n-        }\n-        Set<String> frames = new HashSet<>();\n-        extractFrames(hsErr, frames, true);\n-        if (!crashInJava) {\n-            \/\/ A crash in native will have Java frames in the hs-err log\n-            \/\/ as there is a Java frame anchor on the stack.\n-            extractFrames(hsErr, frames, false);\n-        }\n-        int compiledJavaFrames = (int) frames.stream().filter(f -> f.startsWith(\"J \")).count();\n-\n-        Matcher matcherDisasm = Pattern.compile(\"\\\\[Disassembly\\\\].*\\\\[\/Disassembly\\\\]\", Pattern.DOTALL).matcher(hsErr);\n-        if (matcherDisasm.find()) {\n-            \/\/ Real disassembly is present, no MachCode is expected.\n-            return;\n-        }\n-\n-        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s*\\\\[Verified Entry Point\\\\]\\\\s*  # \\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n-        List<String> machCodeHeaders = matcher.results().map(mr -> String.format(\"'%s' '%s' in '%s'\", mr.group(1), mr.group(2), mr.group(3))).collect(Collectors.toList());\n-        int minExpectedMachCodeSections = Math.max(1, compiledJavaFrames);\n-        if (machCodeHeaders.size() < minExpectedMachCodeSections) {\n-            Asserts.fail(machCodeHeaders.size() + \" < \" + minExpectedMachCodeSections);\n-        }\n-    }\n-\n-    \/**\n-     * Extracts the lines in {@code hsErr} below the line starting with\n-     * \"Native frames:\" or \"Java frames:\" up to the next blank line\n-     * and adds them to {@code frames}.\n-     *\/\n-    private static void extractFrames(String hsErr, Set<String> frames, boolean nativeStack) {\n-        String marker = (nativeStack ? \"Native\" : \"Java\") + \" frames: \";\n-        boolean seenMarker = false;\n-        for (String line : hsErr.split(System.lineSeparator())) {\n-            if (line.startsWith(marker)) {\n-                seenMarker = true;\n-            } else if (seenMarker) {\n-                if (line.trim().isEmpty()) {\n-                    return;\n-                }\n-                frames.add(line);\n-            }\n-        }\n-        throw new RuntimeException(\"\\\"\" + marker + \"\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":0,"deletions":185,"binary":false,"changes":185,"status":"deleted"},{"patch":"@@ -61,2 +61,0 @@\n-        \"UseSharedSpaces: Header checksum verification failed.\",\n-        \"The shared archive file has an incorrect header size.\",\n@@ -163,1 +161,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), -1);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, -1);\n@@ -175,1 +173,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n@@ -218,1 +216,0 @@\n-        \/\/ modify contents in random area\n@@ -224,11 +221,0 @@\n-\n-        \/\/ modify _base_archive_path_offet to non-zero\n-        System.out.println(\"\\n8. modify _base_archive_path_offset to non-zero\\n\");\n-        String baseArchivePathOffsetName = startNewArchive(\"base-arhive-path-offset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, baseArchivePathOffsetName);\n-        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        System.out.println(\"    baseArchivePathOffset = \" + baseArchivePathOffset);\n-        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), 1024);\n-        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        System.out.println(\"new baseArchivePathOffset = \" + baseArchivePathOffset);\n-        testAndCheck(verifyExecArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import jdk.test.lib.cds.CDSTestUtils;\n@@ -56,25 +55,0 @@\n-    static void runTwo(String base, String top,\n-                       String jarName, String mainClassName, int exitValue,\n-                       String ... checkMessages) throws Exception {\n-        CDSTestUtils.Result result = run2(base, top,\n-                \"-Xlog:cds\",\n-                \"-Xlog:cds+dynamic=debug\",\n-                \"-XX:+VerifySharedSpaces\",\n-                \"-cp\",\n-                jarName,\n-                mainClassName);\n-        if (exitValue == 0) {\n-            result.assertNormalExit( output -> {\n-                for (String s : checkMessages) {\n-                    output.shouldContain(s);\n-                }\n-            });\n-        } else {\n-            result.assertAbnormalExit( output -> {\n-                for (String s : checkMessages) {\n-                    output.shouldContain(s);\n-                }\n-            });\n-        }\n-    }\n-\n@@ -97,2 +71,1 @@\n-        \/\/ 1. Modify the CRC values in the header of the top archive.\n-        System.out.println(\"\\n1. Modify the CRC values in the header of the top archive\");\n+        \/\/ Modify the CRC values in the header of the top archive.\n@@ -103,55 +76,10 @@\n-        runTwo(baseArchiveName, modTop,\n-               appJar, mainClass, 1,\n-               new String[] {\"Header checksum verification failed\",\n-                             \"Unable to use shared archive\"});\n-\n-        \/\/ 2. Make header size larger than the archive size\n-        System.out.println(\"\\n2. Make header size larger than the archive size\");\n-        String largerHeaderSize = getNewArchiveName(\"largerHeaderSize\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, largerHeaderSize);\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetHeaderSize(),  (int)copiedJsa.length() + 1024);\n-        runTwo(baseArchiveName, largerHeaderSize,\n-               appJar, mainClass, 1,\n-               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n-                             \"Unable to use shared archive\"});\n-\n-        \/\/ 3. Make base archive path offset beyond of header size\n-        System.out.println(\"\\n3. Make base archive path offset beyond of header size.\");\n-        String wrongBaseArchivePathOffset = getNewArchiveName(\"wrongBaseArchivePathOffset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseArchivePathOffset);\n-        int fileHeaderSize = (int)CDSArchiveUtils.fileHeaderSize(copiedJsa);\n-        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), baseArchivePathOffset + 1024);\n-        runTwo(baseArchiveName, wrongBaseArchivePathOffset,\n-               appJar, mainClass, 1,\n-               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n-                             \"The shared archive file has an incorrect header size\",\n-                             \"Unable to use shared archive\"});\n-\n-        \/\/ 4. Make base archive path offset points to middle of name size\n-        System.out.println(\"\\n4. Make base archive path offset points to middle of name size\");\n-        String wrongBasePathOffset = getNewArchiveName(\"wrongBasePathOffset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBasePathOffset);\n-        int baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n-        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, baseArchivePathOffset,\n-                                             baseArchivePathOffset + baseArchiveNameSize\/2);\n-        runTwo(baseArchiveName, wrongBasePathOffset,\n-               appJar, mainClass, 1,\n-               new String[] {\"An error has occurred while processing the shared archive file.\",\n-                             \"Header checksum verification failed\",\n-                             \"Unable to use shared archive\"});\n-        \/\/ 5. Make base archive name not terminated with '\\0'\n-        System.out.println(\"\\n5. Make base archive name not terminated with '\\0'\");\n-        String wrongBaseName = getNewArchiveName(\"wrongBaseName\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseName);\n-        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n-        baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n-        long offset = baseArchivePathOffset + baseArchiveNameSize - 1;  \/\/ end of line\n-        CDSArchiveUtils.writeData(copiedJsa, offset, new byte[] {(byte)'X'});\n-\n-        runTwo(baseArchiveName, wrongBaseName,\n-               appJar, mainClass, 1,\n-               new String[] {\"Base archive \" + baseArchiveName,\n-                             \" does not exist\",\n-                             \"Header checksum verification failed\"});\n+        run2(baseArchiveName, modTop,\n+            \"-Xlog:class+load\",\n+            \"-Xlog:cds+dynamic=debug,cds=debug\",\n+            \"-XX:+VerifySharedSpaces\",\n+            \"-cp\", appJar, mainClass)\n+            .assertAbnormalExit(output -> {\n+                    output.shouldContain(\"Header checksum verification failed\")\n+                          .shouldContain(\"Unable to use shared archive\")\n+                          .shouldHaveExitValue(1);\n+                });\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":11,"deletions":83,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -55,17 +55,0 @@\n-\/**\n- * @test id=custom-cl-zgc\n- * @requires vm.cds.custom.loaders\n- * @requires vm.gc.Z\n- * @summary Test dumptime_table entries are removed with zgc eager class unloading\n- * @bug 8274935\n- * @library \/test\/lib\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n- *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\n- * @modules java.base\/jdk.internal.misc\n- *          jdk.httpserver\n- * @build sun.hotspot.WhiteBox\n- * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n- * @run main\/othervm\/timeout=180 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. DynamicLoaderConstraintsTest custom-zgc\n- *\/\n-\n@@ -103,1 +86,0 @@\n-    static boolean useZGC;\n@@ -107,1 +89,0 @@\n-        useZGC = (args.length != 0 && args[0].equals(\"custom-zgc\"));\n@@ -146,9 +127,2 @@\n-                if (useZGC) {\n-                    \/\/ Add options to force eager class unloading.\n-                    cmdLine = TestCommon.concat(cmdLine, \"-cp\", loaderJar,\n-                                                \"-XX:+UseZGC\", \"-XX:ZCollectionInterval=0.01\",\n-                                                loaderMainClass, appJar);\n-                } else {\n-                    cmdLine = TestCommon.concat(cmdLine, \"-cp\", loaderJar,\n-                                                loaderMainClass, appJar);\n-                }\n+                cmdLine = TestCommon.concat(cmdLine, \"-cp\", loaderJar,\n+                                          loaderMainClass, appJar);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/loaderConstraints\/DynamicLoaderConstraintsTest.java","additions":2,"deletions":28,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -385,3 +385,0 @@\n-jdk_editpad = \\\n-     jdk\/editpad\n-\n@@ -397,2 +394,1 @@\n-    :jdk_client_sanity \\\n-    :jdk_editpad\n+    :jdk_client_sanity\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.stream.Collectors;\n@@ -146,9 +147,0 @@\n-            @Override\n-            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n-                String dirName = dir.toString();\n-                if (dirName.endsWith(\".dSYM\")) {\n-                    return FileVisitResult.SKIP_SUBTREE;\n-                }\n-                return super.preVisitDirectory(dir, attrs);\n-            }\n-\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-  @run main\/manual DialogOrient\n+  @run main\/manual=yesno DialogOrient\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/DialogOrient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8228469 8274407\n+ *      8228469\n@@ -105,1 +105,1 @@\n-            new ZoneDescriptor(\"MIT\", 780, false), \/\/ Samoa no longer observes DST starting 2021b\n+            new ZoneDescriptor(\"MIT\", 780, true),\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @requires vm.hasJFR & vm.compiler1.enabled\n+ * @requires vm.hasJFR\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordedFrameType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n+ * @requires vm.gc != \"Z\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.event.oldobject;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.jfr.Recording;\n-import jdk.jfr.consumer.RecordedEvent;\n-import jdk.jfr.internal.test.WhiteBox;\n-import jdk.test.lib.jfr.EventNames;\n-import jdk.test.lib.jfr.Events;\n-\n-\/**\n- * @test\n- * @key jfr\n- * @requires vm.hasJFR & vm.gc.Shenandoah\n- * @summary Test leak profiler with Shenandoah\n- * @library \/test\/lib \/test\/jdk\n- * @modules jdk.jfr\/jdk.jfr.internal.test\n- * @run main\/othervm  -XX:TLABSize=2k -XX:+UseShenandoahGC jdk.jfr.event.oldobject.TestShenandoah\n- *\/\n-public class TestShenandoah {\n-\n-    static private class FindMe {\n-    }\n-\n-    public static List<FindMe[]> list = new ArrayList<>(OldObjects.MIN_SIZE);\n-\n-    public static void main(String[] args) throws Exception {\n-        WhiteBox.setWriteAllObjectSamples(true);\n-\n-        while (true) {\n-            try (Recording r = new Recording()) {\n-                r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n-                r.start();\n-                allocateFindMe();\n-                System.gc();\n-                r.stop();\n-                List<RecordedEvent> events = Events.fromRecording(r);\n-                System.out.println(events);\n-                if (OldObjects.countMatchingEvents(events, FindMe[].class, null, null, -1, \"allocateFindMe\") > 0) {\n-                    return;\n-                }\n-                System.out.println(\"Could not find leaking object, retrying...\");\n-            }\n-            list.clear();\n-        }\n-    }\n-\n-    public static void allocateFindMe() {\n-        for (int i = 0; i < OldObjects.MIN_SIZE; i++) {\n-            \/\/ Allocate array to trigger sampling code path for interpreter \/ c1\n-            list.add(new FindMe[0]);\n-        }\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestShenandoah.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import jdk.test.lib.process.OutputAnalyzer;\n-import jdk.test.lib.util.JarUtils;\n-\n-import java.nio.file.*;\n-import java.security.Security;\n-import java.util.Collections;\n-\n-\n-\/**\n- * @test\n- * @bug 8273826\n- * @summary Test for signed jar file with lowercase META-INF files\n- * @library \/test\/lib ..\/\n- * @build jdk.test.lib.util.JarUtils\n- * @run main LowerCaseManifest\n- *\/\n-public class LowerCaseManifest extends Test {\n-\n-    public static void main(String[] args) throws Throwable {\n-        new LowerCaseManifest().start();\n-    }\n-\n-    private void start() throws Throwable {\n-        \/\/ create a jar file that contains one class file\n-        Utils.createFiles(FIRST_FILE);\n-        JarUtils.createJar(UNSIGNED_JARFILE, FIRST_FILE);\n-\n-        \/\/ create key pair for jar signing\n-        createAlias(CA_KEY_ALIAS, \"-ext\", \"bc:c\");\n-        createAlias(KEY_ALIAS);\n-\n-        issueCert(KEY_ALIAS);\n-\n-        \/\/ sign jar\n-        OutputAnalyzer analyzer = jarsigner(\n-                \"-keystore\", KEYSTORE,\n-                \"-verbose\",\n-                \"-storepass\", PASSWORD,\n-                \"-keypass\", PASSWORD,\n-                \"-signedjar\", SIGNED_JARFILE,\n-                UNSIGNED_JARFILE,\n-                KEY_ALIAS);\n-\n-        checkSigning(analyzer);\n-\n-        \/\/ verify signed jar\n-        analyzer = jarsigner(\n-                \"-verify\",\n-                \"-verbose\",\n-                \"-keystore\", KEYSTORE,\n-                \"-storepass\", PASSWORD,\n-                \"-keypass\", PASSWORD,\n-                SIGNED_JARFILE,\n-                KEY_ALIAS);\n-\n-        checkVerifying(analyzer, 0, JAR_VERIFIED);\n-\n-        \/\/ verify signed jar in strict mode\n-        analyzer = jarsigner(\n-                \"-verify\",\n-                \"-verbose\",\n-                \"-strict\",\n-                \"-keystore\", KEYSTORE,\n-                \"-storepass\", PASSWORD,\n-                \"-keypass\", PASSWORD,\n-                SIGNED_JARFILE,\n-                KEY_ALIAS);\n-\n-        checkVerifying(analyzer, 0, JAR_VERIFIED);\n-\n-        \/\/ convert the META-INF\/ files to lower case\n-        FileSystem fs = FileSystems.newFileSystem(Path.of(SIGNED_JARFILE), Collections.emptyMap());\n-        for (String s : new String[]{\"ALIAS.SF\",  \"ALIAS.RSA\", \"MANIFEST.MF\"}) {\n-            Path origPath = fs.getPath(\"META-INF\/\" + s);\n-            Path lowerCase = fs.getPath(\"META-INF\/\" + s.toLowerCase());\n-            Files.write(lowerCase, Files.readAllBytes(origPath));\n-            Files.delete(origPath);\n-        }\n-        fs.close();\n-\n-        \/\/ verify signed jar in strict mode (with lower case META-INF names in place)\n-        analyzer = jarsigner(\n-                \"-verify\",\n-                \"-verbose\",\n-                \"-strict\",\n-                \"-J-Djava.security.debug=jar\",\n-                \"-keystore\", KEYSTORE,\n-                \"-storepass\", PASSWORD,\n-                \"-keypass\", PASSWORD,\n-                SIGNED_JARFILE,\n-                KEY_ALIAS);\n-\n-        checkVerifying(analyzer, 0,\n-                JAR_VERIFIED, \"!not present in verifiedSigners\");\n-        System.out.println(\"Test passed\");\n-    }\n-\n-}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/warnings\/LowerCaseManifest.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658 8246774 8274347\n+ * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658 8246774\n@@ -91,1 +91,0 @@\n-        new TestGetScopeResult().testNestedSwitchExpression();\n@@ -755,71 +754,0 @@\n-    void testNestedSwitchExpression() throws IOException {\n-        JavacTool c = JavacTool.create();\n-        try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {\n-            String code = \"\"\"\n-                          class Test {\n-                              void t(Object o1, Object o2) {\n-                                  System.err.println(switch (o1) {\n-                                    case String s -> switch (j) {\n-                                        case Integer i -> {\n-                                            int scopeHere;\n-                                            yield \"\";\n-                                        }\n-                                        default -> \"\";\n-                                    };\n-                                    default -> \"\";\n-                                  });\n-                              }\n-                          }\n-                          \"\"\";\n-            class MyFileObject extends SimpleJavaFileObject {\n-                MyFileObject() {\n-                    super(URI.create(\"myfo:\/\/\/Test.java\"), SOURCE);\n-                }\n-                @Override\n-                public String getCharContent(boolean ignoreEncodingErrors) {\n-                    return code;\n-                }\n-            }\n-            Context ctx = new Context();\n-            TestAnalyzer.preRegister(ctx);\n-            JavacTask t = (JavacTask) c.getTask(null, fm, null, null, null,\n-                                                List.of(new MyFileObject()), ctx);\n-            CompilationUnitTree cut = t.parse().iterator().next();\n-            t.analyze();\n-\n-            List<List<String>> actual = new ArrayList<>();\n-\n-            new TreePathScanner<Void, Void>() {\n-                @Override\n-                public Void visitVariable(VariableTree node, Void p) {\n-                    if (node.getName().contentEquals(\"scopeHere\")) {\n-                        Scope scope = Trees.instance(t).getScope(getCurrentPath());\n-                        actual.add(dumpScope(scope));\n-                        JCTree body = getCaseBody(scope);\n-                        if (body == null) {\n-                            throw new AssertionError(\"Unexpected null body.\");\n-                        }\n-                    }\n-                    return super.visitVariable(node, p);\n-                }\n-                JCTree getCaseBody(Scope scope) {\n-                    return ((JCCase) ((JavacScope) scope).getEnv().next.next.tree).body;\n-                }\n-            }.scan(cut, null);\n-\n-            List<List<String>> expected =\n-                    List.of(List.of(\"scopeHere:int\",\n-                                    \"i:java.lang.Integer\",\n-                                    \"s:java.lang.String\",\n-                                    \"o2:java.lang.Object\",\n-                                    \"o1:java.lang.Object\",\n-                                    \"super:java.lang.Object\",\n-                                    \"this:Test\"\n-                                ));\n-\n-            if (!expected.equals(actual)) {\n-                throw new AssertionError(\"Unexpected Scope content: \" + actual);\n-            }\n-        }\n-    }\n-\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":2,"deletions":74,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8206986 8254286 8274347\n+ * @bug 8206986 8254286\n@@ -86,10 +86,0 @@\n-    void preflow(int i, int j) {\n-        System.out.println(switch (i) {\n-            case 1 -> switch (j) {\n-                    case 1 -> \"one and one\";\n-                    default -> \"one and many\";\n-                };\n-            case 2 -> \"two\";\n-            default -> \"many\";\n-        });\n-    }\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchInfer.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,10 +49,7 @@\n-    private static int offsetMagic;                \/\/ offset of GenericCDSFileMapHeader::_magic\n-    private static int offsetCrc;                  \/\/ offset of GenericCDSFileMapHeader::_crc\n-    private static int offsetVersion;              \/\/ offset of GenericCDSFileMapHeader::_version\n-    private static int offsetHeaderSize;           \/\/ offset of GenericCDSFileMapHeader::_header_size\n-    private static int offsetBaseArchivePathOffset;\/\/ offset of GenericCDSFileMapHeader::_base_archive_path_offset\n-    private static int offsetBaseArchiveNameSize;  \/\/ offset of GenericCDSFileMapHeader::_base_archive_name_size\n-    private static int offsetJvmIdent;             \/\/ offset of FileMapHeader::_jvm_ident\n-    private static int spOffsetCrc;                \/\/ offset of CDSFileMapRegion::_crc\n-    private static int spOffset;                   \/\/ offset of CDSFileMapRegion\n-    private static int spUsedOffset;               \/\/ offset of CDSFileMapRegion::_used\n+    public static int offsetMagic;                \/\/ CDSFileMapHeaderBase::_magic\n+    public static int offsetVersion;              \/\/ CDSFileMapHeaderBase::_version\n+    public static int offsetJvmIdent;             \/\/ FileMapHeader::_jvm_ident\n+    public static int offsetBaseArchiveNameSize;  \/\/ FileMapHeader::_base_archive_name_size\n+    public static int spOffsetCrc;                \/\/ CDSFileMapRegion::_crc\n+    public static int spOffset;                   \/\/ offset of CDSFileMapRegion\n+    public static int spUsedOffset;               \/\/ offset of CDSFileMapRegion::_used\n@@ -60,8 +57,8 @@\n-    private static int staticMagic;                \/\/ static magic value defined in hotspot\n-    private static int dynamicMagic;               \/\/ dyamic magic value defined in hotspot\n-    private static int sizetSize;                  \/\/ size of size_t\n-    private static int intSize;                    \/\/ size of int\n-    private static int staticArchiveHeaderSize;    \/\/ static archive file header size\n-    private static int dynamicArchiveHeaderSize;   \/\/ dynamic archive file header size\n-    private static int cdsFileMapRegionSize;       \/\/ size of CDSFileMapRegion\n-    private static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n+    public static int staticMagic;                \/\/ static magic value defined in hotspot\n+    public static int dynamicMagic;               \/\/ dyamic magic value defined in hotspot\n+    public static int sizetSize;                  \/\/ size of size_t\n+    public static int intSize;                    \/\/ size of int\n+    public static int staticArchiveHeaderSize;    \/\/ static archive file header size\n+    public static int dynamicArchiveHeaderSize;   \/\/ dynamic archive file header size\n+    public static int cdsFileMapRegionSize;       \/\/ size of CDSFileMapRegion\n+    public static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n@@ -70,1 +67,1 @@\n-    private static String[] shared_region_name = {\n+    public static String[] shared_region_name = {\n@@ -79,1 +76,1 @@\n-    private static int num_regions = shared_region_name.length;\n+    public static int num_regions = shared_region_name.length;\n@@ -86,6 +83,2 @@\n-            offsetMagic = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_magic\");\n-            offsetCrc = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_crc\");\n-            offsetVersion = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_version\");\n-            offsetHeaderSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_header_size\");\n-            offsetBaseArchivePathOffset = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_path_offset\");\n-            offsetBaseArchiveNameSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_name_size\");\n+            offsetMagic = wb.getCDSOffsetForName(\"CDSFileMapHeaderBase::_magic\");\n+            offsetVersion = wb.getCDSOffsetForName(\"CDSFileMapHeaderBase::_version\");\n@@ -93,0 +86,1 @@\n+            offsetBaseArchiveNameSize = wb.getCDSOffsetForName(\"FileMapHeader::_base_archive_name_size\");\n@@ -99,1 +93,0 @@\n-            \/\/ following two sizes are runtime values\n@@ -106,0 +99,2 @@\n+            \/\/ file_header_size is structure size, real size aligned with alignment\n+            \/\/ so must be calculated after alignment is available\n@@ -118,23 +113,0 @@\n-    \/\/ accessors\n-    \/\/ offsets\n-    public static int offsetMagic()                 { return offsetMagic;                 }\n-    public static int offsetCrc()                   { return offsetCrc;                   }\n-    public static int offsetVersion()               { return offsetVersion;               }\n-    public static int offsetHeaderSize()            { return offsetHeaderSize;            }\n-    public static int offsetBaseArchivePathOffset() { return offsetBaseArchivePathOffset; }\n-    public static int offsetBaseArchiveNameSize()   { return offsetBaseArchiveNameSize;   }\n-    public static int offsetJvmIdent()              { return offsetJvmIdent;              }\n-    public static int spOffsetCrc()                 { return spOffsetCrc;                 }\n-    public static int spOffset()                    { return spOffset;                    }\n-    public static int spUsedOffset()                { return spUsedOffset;                }\n-    \/\/ constants\n-    public static int staticMagic()                 { return staticMagic;                 }\n-    public static int dynamicMagic()                { return dynamicMagic;                }\n-    public static int sizetSize()                   { return sizetSize;                   }\n-    public static int staticArchiveHeaderSize()     { return staticArchiveHeaderSize;     }\n-    public static int dynamicArchiveHeaderSize()    { return dynamicArchiveHeaderSize;    }\n-    public static int cdsFileMapRegionSize()        { return cdsFileMapRegionSize;        }\n-    public static long alignment()                  { return alignment;                   }\n-\n-\n-\n@@ -142,21 +114,10 @@\n-        long  headerSize = readInt(jsaFile, offsetHeaderSize, 4);\n-        return headerSize;\n-    }\n-\n-    public static long fileHeaderSizeAligned(File jsaFile) throws Exception {\n-        long size = fileHeaderSize(jsaFile);\n-        return alignUpWithAlignment(size);\n-    }\n-\n-    public static int baseArchivePathOffset(File jsaFile) throws Exception {\n-        return (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n-    }\n-\n-    public static int baseArchiveNameSize(File jsaFile) throws Exception {\n-        return (int)readInt(jsaFile, offsetBaseArchiveNameSize, 4);\n-    }\n-\n-    public static String baseArchiveName(File jsaFile) throws Exception {\n-        int size = baseArchiveNameSize(jsaFile);\n-        int baseArchivePathOffset = (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n-        return readString(jsaFile, baseArchivePathOffset, size - 1); \/\/ exclude terminating '\\0'\n+      long magicValue = readInt(jsaFile, offsetMagic, 4);\n+      if (magicValue == staticMagic) {\n+          return alignUpWithAlignment((long)staticArchiveHeaderSize);\n+      } else if (magicValue == dynamicMagic) {\n+          \/\/ dynamic archive store base archive name after header, so we count it in header size.\n+          int baseArchiveNameSize = (int)readInt(jsaFile, (long)offsetBaseArchiveNameSize, 4);\n+          return alignUpWithAlignment((long)dynamicArchiveHeaderSize + baseArchiveNameSize);\n+      } else {\n+          throw new RuntimeException(\"Wrong magic value from archive file: \" + magicValue);\n+      }\n@@ -201,1 +162,1 @@\n-        start0 = fileHeaderSizeAligned(jsaFile);\n+        start0 = fileHeaderSize(jsaFile);\n@@ -230,1 +191,1 @@\n-        start0 = fileHeaderSizeAligned(jsaFile);\n+        start0 = fileHeaderSize(jsaFile);\n@@ -267,1 +228,1 @@\n-        long regionStartOffset = fileHeaderSizeAligned(jsaFile);\n+        long regionStartOffset = fileHeaderSize(jsaFile);\n@@ -272,1 +233,1 @@\n-                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSizeAligned(jsaFile)) + \")\");\n+                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSize(jsaFile)) + \")\");\n@@ -304,4 +265,0 @@\n-    public static void modifyFileHeaderSize(File jsaFile, int newHeaderSize) throws Exception {\n-        modifyHeaderIntField(jsaFile, offsetHeaderSize, newHeaderSize);\n-    }\n-\n@@ -314,1 +271,4 @@\n-        writeData(jsaFile, offset, value);\n+        System.out.println(\"    offset \" + offset);\n+\n+        byte[] bytes = ByteBuffer.allocate(4).putInt(value).array();\n+        writeData(jsaFile, offset, bytes);\n@@ -343,1 +303,1 @@\n-    private static long readInt(File file, long offset, int nBytes) throws Exception {\n+    public static long readInt(File file, long offset, int nBytes) throws Exception {\n@@ -345,1 +305,2 @@\n-            ByteBuffer bb = ByteBuffer.allocate(nBytes).order(ByteOrder.nativeOrder());\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes);\n+            bb.order(ByteOrder.nativeOrder());\n@@ -348,1 +309,0 @@\n-            bb.rewind();\n@@ -353,14 +313,0 @@\n-    private static String readString(File file, long offset, int nBytes) throws Exception {\n-        try (FileChannel fc = getFileChannel(file, false \/*read only*\/)) {\n-            ByteBuffer bb = ByteBuffer.allocate(nBytes).order(ByteOrder.nativeOrder());\n-            fc.position(offset);\n-            fc.read(bb);\n-            byte[] arr = bb.flip().array();\n-            for (byte i : arr) {\n-                System.out.print((char)i);\n-            }\n-            System.out.println(\"\");\n-            return new String(arr);\n-        }\n-    }\n-\n@@ -375,1 +321,0 @@\n-            bbuf.order(ByteOrder.nativeOrder());\n@@ -382,4 +327,1 @@\n-            ByteBuffer bbuf = ByteBuffer.allocate(4)\n-                                        .order(ByteOrder.nativeOrder())\n-                                        .putInt(value)\n-                                        .rewind();\n+            ByteBuffer bbuf = ByteBuffer.allocate(4).putInt(value).position(0);\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":44,"deletions":102,"binary":false,"changes":146,"status":"modified"}]}