{"files":[{"patch":"@@ -24,1 +24,1 @@\n-tzdata2021a\n+tzdata2021c\n","filename":"make\/data\/tzdata\/VERSION","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,3 +56,0 @@\n-# A reliable and entertaining source about time zones is\n-# Derek Howse, Greenwich time and longitude, Philip Wilson Publishers (1997).\n-#\n@@ -179,0 +176,1 @@\n+Link Africa\/Abidjan Africa\/Accra\t# Ghana\n@@ -180,1 +178,1 @@\n-Link Africa\/Abidjan Africa\/Banjul\t# Gambia\n+Link Africa\/Abidjan Africa\/Banjul\t# The Gambia\n@@ -407,3 +405,1 @@\n-# Gambia\n-# See Africa\/Abidjan.\n-\n+# The Gambia\n@@ -411,83 +407,0 @@\n-\n-# From P Chan (2020-11-20):\n-# Interpretation Amendment Ordinance, 1915 (No.24 of 1915) [1915-11-02]\n-# Ordinances of the Gold Coast, Ashanti, Northern Territories 1915, p 69-71\n-# https:\/\/books.google.com\/books?id=ErA-AQAAIAAJ&pg=PA70\n-# This Ordinance added \"'Time' shall mean Greenwich Mean Time\" to the\n-# Interpretation Ordinance, 1876.\n-#\n-# Determination of the Time Ordinance, 1919 (No. 18 of 1919) [1919-11-24]\n-# Ordinances of the Gold Coast, Ashanti, Northern Territories 1919, p 75-76\n-# https:\/\/books.google.com\/books?id=MbA-AQAAIAAJ&pg=PA75\n-# This Ordinance removed the previous definition of time and introduced DST.\n-#\n-# Time Determination Ordinance (Cap. 214)\n-# The Laws of the Gold Coast (including Togoland Under British Mandate)\n-# Vol. II (1937), p 2328\n-# https:\/\/books.google.com\/books?id=Z7M-AQAAIAAJ&pg=PA2328\n-# Revised edition of the 1919 Ordinance.\n-#\n-# Time Determination (Amendment) Ordinance, 1940 (No. 9 of 1940) [1940-04-06]\n-# Annual Volume of the Laws of the Gold Coast:\n-# Containing All Legislation Enacted During Year 1940, p 22\n-# https:\/\/books.google.com\/books?id=1ao-AQAAIAAJ&pg=PA22\n-# This Ordinance changed the forward transition from September to May.\n-#\n-# Defence (Time Determination Ordinance Amendment) Regulations, 1942\n-# (Regulations No. 6 of 1942) [1942-01-31, commenced on 1942-02-08]\n-# Annual Volume of the Laws of the Gold Coast:\n-# Containing All Legislation Enacted During Year 1942, p 48\n-# https:\/\/books.google.com\/books?id=Das-AQAAIAAJ&pg=PA48\n-# These regulations advanced the [standard] time by thirty minutes.\n-#\n-# Defence (Time Determination Ordinance Amendment (No.2)) Regulations,\n-# 1942 (Regulations No. 28 of 1942) [1942-04-25]\n-# Annual Volume of the Laws of the Gold Coast:\n-# Containing All Legislation Enacted During Year 1942, p 87\n-# https:\/\/books.google.com\/books?id=Das-AQAAIAAJ&pg=PA87\n-# These regulations abolished DST and changed the time to GMT+0:30.\n-#\n-# Defence (Revocation) (No.4) Regulations, 1945 (Regulations No. 45 of\n-# 1945) [1945-10-24, commenced on 1946-01-06]\n-# Annual Volume of the Laws of the Gold Coast:\n-# Containing All Legislation Enacted During Year 1945, p 256\n-# https:\/\/books.google.com\/books?id=9as-AQAAIAAJ&pg=PA256\n-# These regulations revoked the previous two sets of Regulations.\n-#\n-# Time Determination (Amendment) Ordinance, 1945 (No. 18 of 1945) [1946-01-06]\n-# Annual Volume of the Laws of the Gold Coast:\n-# Containing All Legislation Enacted During Year 1945, p 69\n-# https:\/\/books.google.com\/books?id=9as-AQAAIAAJ&pg=PA69\n-# This Ordinance abolished DST.\n-#\n-# Time Determination (Amendment) Ordinance, 1950 (No. 26 of 1950) [1950-07-22]\n-# Annual Volume of the Laws of the Gold Coast:\n-# Containing All Legislation Enacted During Year 1950, p 35\n-# https:\/\/books.google.com\/books?id=e60-AQAAIAAJ&pg=PA35\n-# This Ordinance restored DST but with thirty minutes offset.\n-#\n-# Time Determination Ordinance (Cap. 264)\n-# The Laws of the Gold Coast, Vol. V (1954), p 380\n-# https:\/\/books.google.com\/books?id=Mqc-AQAAIAAJ&pg=PA380\n-# Revised edition of the Time Determination Ordinance.\n-#\n-# Time Determination (Amendment) Ordinance, 1956 (No. 21 of 1956) [1956-08-29]\n-# Annual Volume of the Ordinances of the Gold Coast Enacted During the\n-# Year 1956, p 83\n-# https:\/\/books.google.com\/books?id=VLE-AQAAIAAJ&pg=PA83\n-# This Ordinance abolished DST.\n-\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tGhana\t1919\tonly\t-\tNov\t24\t0:00\t0:20\t+0020\n-Rule\tGhana\t1920\t1942\t-\tJan\t 1\t2:00\t0\tGMT\n-Rule\tGhana\t1920\t1939\t-\tSep\t 1\t2:00\t0:20\t+0020\n-Rule\tGhana\t1940\t1941\t-\tMay\t 1\t2:00\t0:20\t+0020\n-Rule\tGhana\t1950\t1955\t-\tSep\t 1\t2:00\t0:30\t+0030\n-Rule\tGhana\t1951\t1956\t-\tJan\t 1\t2:00\t0\tGMT\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tAfrica\/Accra\t-0:00:52 -\tLMT\t1915 Nov  2\n-\t\t\t 0:00\tGhana\t%s\t1942 Feb  8\n-\t\t\t 0:30\t-\t+0030\t1946 Jan  6\n-\t\t\t 0:00\tGhana\t%s\n-\n@@ -758,1 +671,1 @@\n-# See the 'europe' file for Spanish Morocco (Africa\/Ceuta).\n+# See Africa\/Ceuta for Spanish Morocco.\n@@ -1408,9 +1321,9 @@\n-Link Africa\/Lagos Africa\/Bangui\t     # Central African Republic\n-Link Africa\/Lagos Africa\/Brazzaville # Rep. of the Congo\n-Link Africa\/Lagos Africa\/Douala\t     # Cameroon\n-Link Africa\/Lagos Africa\/Kinshasa    # Dem. Rep. of the Congo (west)\n-Link Africa\/Lagos Africa\/Libreville  # Gabon\n-Link Africa\/Lagos Africa\/Luanda\t     # Angola\n-Link Africa\/Lagos Africa\/Malabo\t     # Equatorial Guinea\n-Link Africa\/Lagos Africa\/Niamey\t     # Niger\n-Link Africa\/Lagos Africa\/Porto-Novo  # Benin\n+Link Africa\/Lagos Africa\/Bangui\t\t# Central African Republic\n+Link Africa\/Lagos Africa\/Brazzaville\t# Rep. of the Congo\n+Link Africa\/Lagos Africa\/Douala\t\t# Cameroon\n+Link Africa\/Lagos Africa\/Kinshasa\t# Dem. Rep. of the Congo (west)\n+Link Africa\/Lagos Africa\/Libreville\t# Gabon\n+Link Africa\/Lagos Africa\/Luanda\t\t# Angola\n+Link Africa\/Lagos Africa\/Malabo\t\t# Equatorial Guinea\n+Link Africa\/Lagos Africa\/Niamey\t\t# Niger\n+Link Africa\/Lagos Africa\/Porto-Novo\t# Benin\n@@ -1423,2 +1336,0 @@\n-# Crozet Islands also observes Réunion time; see the 'antarctica' file.\n-#\n@@ -1516,2 +1427,2 @@\n-Link Africa\/Johannesburg Africa\/Maseru\t   # Lesotho\n-Link Africa\/Johannesburg Africa\/Mbabane    # Eswatini\n+Link Africa\/Johannesburg Africa\/Maseru\t# Lesotho\n+Link Africa\/Johannesburg Africa\/Mbabane\t# Eswatini\n@@ -1553,0 +1464,2 @@\n+# South Sudan\n+\n@@ -1558,1 +1471,0 @@\n-# South Sudan\n@@ -1663,1 +1575,1 @@\n-# See Europe\/Paris for PMT-related transitions.\n+# See Europe\/Paris commentary for PMT-related transitions.\n","filename":"make\/data\/tzdata\/africa","additions":18,"deletions":106,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -174,1 +174,1 @@\n-#\tsee Indian\/Reunion.\n+#\tsee Asia\/Dubai.\n@@ -188,11 +188,1 @@\n-# Dumont d'Urville, Île des Pétrels, -6640+14001, since 1956-11\n-# <https:\/\/en.wikipedia.org\/wiki\/Dumont_d'Urville_Station> (2005-12-05)\n-#\n-# Another base at Port-Martin, 50km east, began operation in 1947.\n-# It was destroyed by fire on 1952-01-14.\n-#\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Antarctica\/DumontDUrville 0 -\t-00\t1947\n-\t\t\t10:00\t-\t+10\t1952 Jan 14\n-\t\t\t0\t-\t-00\t1956 Nov\n-\t\t\t10:00\t-\t+10\n+# Dumont d'Urville - see Pacific\/Port_Moresby.\n@@ -214,14 +204,1 @@\n-# Syowa (also known as Showa), -690022+0393524, since 1957\n-#\n-# From Hideyuki Suzuki (1999-02-06):\n-# In all Japanese stations, +0300 is used as the standard time.\n-#\n-# Syowa station, which is the first antarctic station of Japan,\n-# was established on 1957-01-29.  Since Syowa station is still the main\n-# station of Japan, it's appropriate for the principal location.\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone Antarctica\/Syowa\t0\t-\t-00\t1957 Jan 29\n-\t\t\t3:00\t-\t+03\n-# See:\n-# NIPR Antarctic Research Activities (1999-08-17)\n-# http:\/\/www.nipr.ac.jp\/english\/ara01.html\n+# See Asia\/Riyadh.\n","filename":"make\/data\/tzdata\/antarctica","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -60,3 +60,0 @@\n-# A reliable and entertaining source about time zones is\n-# Derek Howse, Greenwich time and longitude, Philip Wilson Publishers (1997).\n-#\n@@ -2260,0 +2257,8 @@\n+# From Steffen Thorsen (2021-09-24):\n+# The Jordanian Government announced yesterday that they will start DST\n+# in February instead of March:\n+# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=37683&lang=en&name=en_news (English)\n+# https:\/\/petra.gov.jo\/Include\/InnerPage.jsp?ID=189969&lang=ar&name=news (Arabic)\n+# From the Arabic version, it seems to say it would be at midnight\n+# (assume 24:00) on the last Thursday in February, starting from 2022.\n+\n@@ -2290,1 +2295,1 @@\n-Rule\tJordan\t2014\tmax\t-\tMar\tlastThu\t24:00\t1:00\tS\n+Rule\tJordan\t2014\t2021\t-\tMar\tlastThu\t24:00\t1:00\tS\n@@ -2292,0 +2297,1 @@\n+Rule\tJordan\t2022\tmax\t-\tFeb\tlastThu\t24:00\t1:00\tS\n@@ -2766,1 +2772,2 @@\n-# http:\/\/www.math.nus.edu.sg\/aslaksen\/teaching\/timezone.html\n+# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n+# This agrees with Singapore since 1905-06-01.\n@@ -3526,0 +3533,6 @@\n+# From P Chan (2021-05-10):\n+# Here's a fairly comprehensive article in Japanese:\n+# https:\/\/wiki.suikawiki.org\/n\/Philippine%20Time\n+# From Paul Eggert (2021-05-10):\n+# The info in the Japanese table has not been absorbed (yet) below.\n+\n@@ -3592,0 +3605,1 @@\n+Link Asia\/Riyadh Antarctica\/Syowa\n@@ -3597,1 +3611,1 @@\n-# http:\/\/www.math.nus.edu.sg\/aslaksen\/teaching\/timezone.html\n+# https:\/\/web.archive.org\/web\/20190822231045\/http:\/\/www.math.nus.edu.sg\/~mathelmr\/teaching\/timezone.html\n","filename":"make\/data\/tzdata\/asia","additions":20,"deletions":6,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -490,1 +490,1 @@\n-Zone Pacific\/Enderbury\t-11:24:20 -\tLMT\t1901\n+Zone Pacific\/Kanton\t  0\t-\t-00\t1937 Aug 31\n@@ -623,1 +623,33 @@\n-# From Shanks & Pottenger:\n+#\n+# From Alexander Krivenyshev (2021-03-24):\n+# In 1899 the Cook Islands celebrated Christmas twice to correct the calendar.\n+# According to the old books, missionaries were unaware of\n+# the International Date line, when they came from Sydney.\n+# Thus the Cook Islands were one day ahead....\n+# http:\/\/nzetc.victoria.ac.nz\/tm\/scholarly\/tei-KloDisc-t1-body-d18.html\n+# ... Appendix to the Journals of the House of Representatives, 1900\n+# https:\/\/atojs.natlib.govt.nz\/cgi-bin\/atojs?a=d&d=AJHR1900-I.2.1.2.3\n+# (page 20)\n+#\n+# From Michael Deckers (2021-03-24):\n+# ... in the Cook Island Act of 1915-10-11, online at\n+# http:\/\/www.paclii.org\/ck\/legis\/ck-nz_act\/cia1915132\/\n+# \"651. The hour of the day shall in each of the islands included in the\n+#  Cook Islands be determined in accordance with the meridian of that island.\"\n+# so that local (mean?) time was still used in Rarotonga (and Niue) in 1915.\n+# This was changed in the Cook Island Amendment Act of 1952-10-16 ...\n+# http:\/\/www.paclii.org\/ck\/legis\/ck-nz_act\/ciaa1952212\/\n+# \"651 (1) The hour of the day in each of the islands included in the Cook\n+#  Islands, other than Niue, shall be determined as if each island were\n+#  situated on the meridian one hundred and fifty-seven degrees thirty minutes\n+#  West of Greenwich.  (2) The hour of the day in the Island of Niue shall be\n+#  determined as if that island were situated on the meridian one hundred and\n+#  seventy degrees West of Greenwich.\"\n+# This act does not state when it takes effect, so one has to assume it\n+# applies since 1952-10-16.  But there is the possibility that the act just\n+# legalized prior existing practice, as we had seen with the Guernsey law of\n+# 1913-06-18 for the switch in 1909-04-19.\n+#\n+# From Paul Eggert (2021-03-24):\n+# Transitions after 1952 are from Shanks & Pottenger.\n+#\n@@ -629,1 +661,2 @@\n-Zone Pacific\/Rarotonga\t-10:39:04 -\tLMT\t1901        # Avarua\n+Zone Pacific\/Rarotonga\t13:20:56 -\tLMT\t1899 Dec 26 # Avarua\n+\t\t\t-10:39:04 -\tLMT\t1952 Oct 16\n@@ -637,0 +670,9 @@\n+# See Pacific\/Raratonga comments for 1952 transition.\n+#\n+# From Tim Parenti (2021-09-13):\n+# Consecutive contemporaneous editions of The Air Almanac listed -11:20 for\n+# Niue as of Apr 1964 but -11 as of Aug 1964:\n+#   Apr 1964: https:\/\/books.google.com\/books?id=_1So677Y5vUC&pg=SL1-PA23\n+#   Aug 1964: https:\/\/books.google.com\/books?id=MbJloqd-zyUC&pg=SL1-PA23\n+# Without greater specificity, guess 1964-07-01 for this transition.\n+\n@@ -638,3 +680,2 @@\n-Zone\tPacific\/Niue\t-11:19:40 -\tLMT\t1901        # Alofi\n-\t\t\t-11:20\t-\t-1120\t1951\n-\t\t\t-11:30\t-\t-1130\t1978 Oct  1\n+Zone\tPacific\/Niue\t-11:19:40 -\tLMT\t1952 Oct 16\t# Alofi\n+\t\t\t-11:20\t-\t-1120\t1964 Jul\n@@ -664,0 +705,1 @@\n+Link Pacific\/Port_Moresby Antarctica\/DumontDUrville\n@@ -768,0 +810,4 @@\n+#\n+# From Geoffrey D. Bennett (2021-09-20):\n+# https:\/\/www.mcil.gov.ws\/storage\/2021\/09\/MCIL-Scan_20210920_120553.pdf\n+# DST has been cancelled for this year.\n@@ -773,2 +819,2 @@\n-Rule\tWS\t2012\tmax\t-\tApr\tSun>=1\t4:00\t0\t-\n-Rule\tWS\t2012\tmax\t-\tSep\tlastSun\t3:00\t1\t-\n+Rule\tWS\t2012\t2021\t-\tApr\tSun>=1\t4:00\t0\t-\n+Rule\tWS\t2012\t2020\t-\tSep\tlastSun\t3:00\t1\t-\n@@ -821,2 +867,2 @@\n-Zone Pacific\/Tongatapu\t12:19:20 -\tLMT\t1901\n-\t\t\t12:20\t-\t+1220\t1941\n+Zone Pacific\/Tongatapu\t12:19:12 -\tLMT\t1945 Sep 10\n+\t\t\t12:20\t-\t+1220\t1961\n@@ -1764,0 +1810,17 @@\n+# Kanton\n+\n+# From Paul Eggert (2021-05-27):\n+# Kiribati's +13 timezone is represented by Kanton, its only populated\n+# island.  (It was formerly spelled \"Canton\", but Gilbertese lacks \"C\".)\n+# Kanton was settled on 1937-08-31 by two British radio operators\n+# <https:\/\/history.state.gov\/historicaldocuments\/frus1937v02\/d94>;\n+# Americans came the next year and built an airfield, partly to\n+# establish airline service and perhaps partly anticipating the\n+# next war.  Aside from the war, the airfield was used by commercial\n+# airlines until long-range jets became standard; although currently\n+# for emergency use only, China says it is considering rebuilding the\n+# airfield for high-end niche tourism.  Kanton has about two dozen\n+# people, caretakers who rotate in from the rest of Kiribati in 2-5\n+# year shifts, and who use some of the leftover structures\n+# <http:\/\/pipa.neaq.org\/2012\/06\/images-of-kanton-island.html>.\n+\n@@ -2047,0 +2110,11 @@\n+# From Paul Eggert (2021-03-04):\n+# In 1943 \"The standard time kept is 12 hrs. 19 min. 12 sec. fast\n+# on Greenwich mean time.\" according to the Admiralty's Hydrographic\n+# Dept., Pacific Islands Pilot, Vol. II, 7th ed., 1943, p 360.\n+\n+# From Michael Deckers (2021-03-03):\n+# [Ian R Bartky: \"One Time Fits All: The Campaigns for Global Uniformity\".\n+# Stanford University Press. 2007. p. 255]:\n+# On 10 September 1945 Tonga adopted a standard time 12 hours,\n+# 20 minutes in advance of Greenwich.\n+\n@@ -2075,3 +2149,20 @@\n-\n-# From Paul Eggert (2006-03-22):\n-# Shanks & Pottenger say the transition was on 1968-10-01; go with Mundell.\n+#\n+# From Tim Parenti (2021-09-13), per Paul Eggert (2006-03-22) and Michael\n+# Deckers (2021-03-03):\n+# Mundell places the transition from +12:20 to +13 in 1941, while Shanks &\n+# Pottenger say the transition was on 1968-10-01.\n+#\n+# The Air Almanac published contemporaneous tables of standard times,\n+# which listed +12:20 as of Nov 1960 and +13 as of Mar 1961:\n+#   Nov 1960: https:\/\/books.google.com\/books?id=bVgtWM6kPZUC&pg=SL1-PA19\n+#   Mar 1961: https:\/\/books.google.com\/books?id=W2nItAul4g0C&pg=SL1-PA19\n+# (Thanks to P Chan for pointing us toward these sources.)\n+# This agrees with Bartky, who writes that \"since 1961 [Tonga's] official time\n+# has been thirteen hours in advance of Greenwich time\" (p. 202) and further\n+# writes in an endnote that this was because \"the legislation was amended\" on\n+# 1960-10-19. (p. 255)\n+#\n+# Without greater specificity, presume that Bartky and the Air Almanac point to\n+# a 1961-01-01 transition, as Tāufaʻāhau Tupou IV was still Crown Prince in\n+# 1961 and this still jives with the gist of Mundell's telling, and go with\n+# this over Shanks & Pottenger.\n","filename":"make\/data\/tzdata\/australasia","additions":104,"deletions":13,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -29,2 +29,4 @@\n-# This file provides links between current names for timezones\n-# and their old names.  Many names changed in late 1993.\n+# This file provides links from old or merged timezone names to current ones.\n+# Many names changed in late 1993.  Several of these names are\n+# also present in the file 'backzone', which has data important only\n+# for pre-1970 timestamps and so is out of scope for tzdb proper.\n@@ -39,1 +41,1 @@\n-Link\tAmerica\/Atikokan\tAmerica\/Coral_Harbour\n+Link\tAmerica\/Panama\t\tAmerica\/Coral_Harbour\n@@ -54,1 +56,1 @@\n-Link\tAmerica\/Port_of_Spain\tAmerica\/Virgin\n+Link\tAmerica\/Puerto_Rico\tAmerica\/Virgin\n@@ -129,0 +131,1 @@\n+Link\tPacific\/Kanton\t\tPacific\/Enderbury\n","filename":"make\/data\/tzdata\/backward","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -94,1 +94,0 @@\n-#        0:19:32.13 AMT* NST*       Amsterdam, Netherlands Summer (1835-1937)\n@@ -1826,0 +1825,4 @@\n+# Kosovo\n+# See Europe\/Belgrade.\n+\n+\n@@ -2176,0 +2179,4 @@\n+# From Paul Eggert (2021-05-09):\n+# I invented the abbreviations AMT for Amsterdam Mean Time and NST for\n+# Netherlands Summer Time, used in the Netherlands from 1835 to 1937.\n+\n@@ -2402,3 +2409,1 @@\n-Rule\tPort\t1947\t1949\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n-Rule\tPort\t1947\t1949\t-\tOct\tSun>=1\t 2:00s\t0\t-\n-# Shanks & Pottenger say DST was observed in 1950; go with Whitman.\n+# Whitman says DST was not observed in 1950; go with Shanks & Pottenger.\n@@ -2406,2 +2411,2 @@\n-Rule\tPort\t1951\t1965\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n-Rule\tPort\t1951\t1965\t-\tOct\tSun>=1\t 2:00s\t0\t-\n+Rule\tPort\t1947\t1965\t-\tApr\tSun>=1\t 2:00s\t1:00\tS\n+Rule\tPort\t1947\t1965\t-\tOct\tSun>=1\t 2:00s\t0\t-\n@@ -3709,0 +3714,3 @@\n+# An extra-special abbreviation style is SET for Swedish Time (svensk\n+# normaltid) 1879-1899, 3° west of the Stockholm Observatory.\n+\n","filename":"make\/data\/tzdata\/europe","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-#Expires 2021\tDec\t28\t00:00:00\n+#Expires 2022\tJun\t28\t00:00:00\n@@ -102,1 +102,1 @@\n-#expires 1640649600 (2021-12-28 00:00:00 UTC)\n+#expires 1656374400 (2022-06-28 00:00:00 UTC)\n@@ -104,2 +104,2 @@\n-#\tUpdated through IERS Bulletin C61\n-#\tFile expires on:  28 December 2021\n+#\tUpdated through IERS Bulletin C62\n+#\tFile expires on:  28 June 2022\n","filename":"make\/data\/tzdata\/leapseconds","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -755,1 +755,5 @@\n-# The following switches don't quite make our 1970 cutoff.\n+# The following switches don't make our 1970 cutoff.\n+#\n+# Kiska observed Tokyo date and time during Japanese occupation from\n+# 1942-06-06 to 1943-07-29, and similarly for Attu from 1942-06-07 to\n+# 1943-05-29 (all dates American).  Both islands are now uninhabited.\n@@ -851,0 +855,2 @@\n+Link America\/Phoenix America\/Creston\n+\n@@ -1619,18 +1625,1 @@\n-#\n-# Matthews and Vincent (1998) also write that Quebec east of the -63\n-# meridian is supposed to observe AST, but residents as far east as\n-# Natashquan use EST\/EDT, and residents east of Natashquan use AST.\n-# The Quebec department of justice writes in\n-# \"The situation in Minganie and Basse-Côte-Nord\"\n-# https:\/\/www.justice.gouv.qc.ca\/en\/department\/ministre\/functions-and-responsabilities\/legal-time-in-quebec\/the-situation-in-minganie-and-basse-cote-nord\/\n-# that the coastal strip from just east of Natashquan to Blanc-Sablon\n-# observes Atlantic standard time all year round.\n-# This common practice was codified into law as of 2007; see Legal Time Act,\n-# CQLR c T-5.1 <http:\/\/legisquebec.gouv.qc.ca\/en\/ShowDoc\/cs\/T-5.1>.\n-# For lack of better info, guess this practice began around 1970, contra to\n-# Shanks & Pottenger who have this region observing AST\/ADT.\n-\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone America\/Blanc-Sablon -3:48:28 -\tLMT\t1884\n-\t\t\t-4:00\tCanada\tA%sT\t1970\n-\t\t\t-4:00\t-\tAST\n+# See America\/Puerto_Rico for east of Natashquan.\n@@ -1675,48 +1664,0 @@\n-# From Paul Eggert (1997-10-17):\n-# Mark Brader writes that an article in the 1997-10-14 Toronto Star\n-# says that Atikokan, Ontario currently does not observe DST,\n-# but will vote on 11-10 whether to use EST\/EDT.\n-# He also writes that the Ontario Time Act (1990, Chapter T.9)\n-# http:\/\/www.gov.on.ca\/MBS\/english\/publications\/statregs\/conttext.html\n-# says that Ontario east of 90W uses EST\/EDT, and west of 90W uses CST\/CDT.\n-# Officially Atikokan is therefore on CST\/CDT, and most likely this report\n-# concerns a non-official time observed as a matter of local practice.\n-#\n-# From Paul Eggert (2000-10-02):\n-# Matthews and Vincent (1998) write that Atikokan, Pickle Lake, and\n-# New Osnaburgh observe CST all year, that Big Trout Lake observes\n-# CST\/CDT, and that Upsala and Shebandowan observe EST\/EDT, all in\n-# violation of the official Ontario rules.\n-#\n-# From Paul Eggert (2006-07-09):\n-# Chris Walton (2006-07-06) mentioned an article by Stephanie MacLellan in the\n-# 2005-07-21 Chronicle-Journal, which said:\n-#\n-#\tThe clocks in Atikokan stay set on standard time year-round.\n-#\tThis means they spend about half the time on central time and\n-#\tthe other half on eastern time.\n-#\n-#\tFor the most part, the system works, Mayor Dennis Brown said.\n-#\n-#\t\"The majority of businesses in Atikokan deal more with Eastern\n-#\tCanada, but there are some that deal with Western Canada,\" he\n-#\tsaid.  \"I don't see any changes happening here.\"\n-#\n-# Walton also writes \"Supposedly Pickle Lake and Mishkeegogamang\n-# [New Osnaburgh] follow the same practice.\"\n-\n-# From Garry McKinnon (2006-07-14) via Chris Walton:\n-# I chatted with a member of my board who has an outstanding memory\n-# and a long history in Atikokan (and in the telecom industry) and he\n-# can say for certain that Atikokan has been practicing the current\n-# time keeping since 1952, at least.\n-\n-# From Paul Eggert (2006-07-17):\n-# Shanks & Pottenger say that Atikokan has agreed with Rainy River\n-# ever since standard time was introduced, but the information from\n-# McKinnon sounds more authoritative.  For now, assume that Atikokan\n-# switched to EST immediately after WWII era daylight saving time\n-# ended.  This matches the old (less-populous) America\/Coral_Harbour\n-# entry since our cutoff date of 1970, so we can move\n-# America\/Coral_Harbour to the 'backward' file.\n-\n@@ -1853,0 +1794,1 @@\n+Link America\/Toronto America\/Nassau\n@@ -1868,5 +1810,1 @@\n-Zone America\/Atikokan\t-6:06:28 -\tLMT\t1895\n-\t\t\t-6:00\tCanada\tC%sT\t1940 Sep 29\n-\t\t\t-6:00\t1:00\tCDT\t1942 Feb  9  2:00s\n-\t\t\t-6:00\tCanada\tC%sT\t1945 Sep 30  2:00\n-\t\t\t-5:00\t-\tEST\n+# For Atikokan see America\/Panama.\n@@ -2063,54 +2001,0 @@\n-# Matthews and Vincent (1998) write that Creston is like Dawson Creek.\n-\n-# It seems though that (re: Creston) is not entirely correct:\n-\n-# From Chris Walton (2011-12-01):\n-# There are two areas within the Canadian province of British Columbia\n-# that do not currently observe daylight saving:\n-# a) The Creston Valley (includes the town of Creston and surrounding area)\n-# b) The eastern half of the Peace River Regional District\n-# (includes the cities of Dawson Creek and Fort St. John)\n-\n-# Earlier this year I stumbled across a detailed article about the time\n-# keeping history of Creston; it was written by Tammy Hardwick who is the\n-# manager of the Creston & District Museum. The article was written in May 2009.\n-# http:\/\/www.ilovecreston.com\/?p=articles&t=spec&ar=260\n-# According to the article, Creston has not changed its clocks since June 1918.\n-# i.e. Creston has been stuck on UT-7 for 93 years.\n-# Dawson Creek, on the other hand, changed its clocks as recently as April 1972.\n-\n-# Unfortunately the exact date for the time change in June 1918 remains\n-# unknown and will be difficult to ascertain.  I e-mailed Tammy a few months\n-# ago to ask if Sunday June 2 was a reasonable guess.  She said it was just\n-# as plausible as any other date (in June).  She also said that after writing\n-# the article she had discovered another time change in 1916; this is the\n-# subject of another article which she wrote in October 2010.\n-# http:\/\/www.creston.museum.bc.ca\/index.php?module=comments&uop=view_comment&cm+id=56\n-\n-# Here is a summary of the three clock change events in Creston's history:\n-# 1. 1884 or 1885: adoption of Mountain Standard Time (GMT-7)\n-# Exact date unknown\n-# 2. Oct 1916: switch to Pacific Standard Time (GMT-8)\n-# Exact date in October unknown; Sunday October 1 is a reasonable guess.\n-# 3. June 1918: switch to Pacific Daylight Time (GMT-7)\n-# Exact date in June unknown; Sunday June 2 is a reasonable guess.\n-# note 1:\n-# On Oct 27\/1918 when daylight saving ended in the rest of Canada,\n-# Creston did not change its clocks.\n-# note 2:\n-# During WWII when the Federal Government legislated a mandatory clock change,\n-# Creston did not oblige.\n-# note 3:\n-# There is no guarantee that Creston will remain on Mountain Standard Time\n-# (UTC-7) forever.\n-# The subject was debated at least once this year by the town Council.\n-# http:\/\/www.bclocalnews.com\/kootenay_rockies\/crestonvalleyadvance\/news\/116760809.html\n-\n-# During a period WWII, summer time (Daylight saying) was mandatory in Canada.\n-# In Creston, that was handled by shifting the area to PST (-8:00) then applying\n-# summer time to cause the offset to be -7:00, the same as it had been before\n-# the change.  It can be argued that the timezone abbreviation during this\n-# period should be PDT rather than MST, but that doesn't seem important enough\n-# (to anyone) to further complicate the rules.\n-\n-# The transition dates (and times) are guesses.\n@@ -2170,4 +2054,1 @@\n-Zone America\/Creston\t-7:46:04 -\tLMT\t1884\n-\t\t\t-7:00\t-\tMST\t1916 Oct 1\n-\t\t\t-8:00\t-\tPST\t1918 Jun 2\n-\t\t\t-7:00\t-\tMST\n+# For Creston see America\/Phoenix.\n@@ -2955,1 +2836,1 @@\n-# See America\/Port_of_Spain.\n+# See America\/Puerto_Rico.\n@@ -2957,29 +2838,2 @@\n-# Bahamas\n-#\n-# For 1899 Milne gives -5:09:29.5; round that.\n-#\n-# From P Chan (2020-11-27, corrected on 2020-12-02):\n-# There were two periods of DST observed in 1942-1945: 1942-05-01\n-# midnight to 1944-12-31 midnight and 1945-02-01 to 1945-10-17 midnight.\n-# \"midnight\" should mean 24:00 from the context.\n-#\n-# War Time Order 1942 [1942-05-01] and War Time (No. 2) Order 1942  [1942-09-29]\n-# Appendix to the Statutes of 7 George VI. and the Year 1942. p 34, 43\n-# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA3-PA34\n-# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA3-PA43\n-#\n-# War Time Order 1943 [1943-03-31] and War Time Order 1944 [1943-12-29]\n-# Appendix to the Statutes of 8 George VI. and the Year 1943. p 9-10, 28-29\n-# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA4-PA9\n-# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA4-PA28\n-#\n-# War Time Order 1945 [1945-01-31] and the Order which revoke War Time Order\n-# 1945 [1945-10-16] Appendix to the Statutes of 9 George VI. and the Year\n-# 1945. p 160, 247-248\n-# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA6-PA160\n-# https:\/\/books.google.com\/books?id=5rlNAQAAIAAJ&pg=RA6-PA247\n-#\n-# From Sue Williams (2006-12-07):\n-# The Bahamas announced about a month ago that they plan to change their DST\n-# rules to sync with the U.S. starting in 2007....\n-# http:\/\/www.jonesbahamas.com\/?c=45&a=10412\n+# The Bahamas\n+# See America\/Toronto.\n@@ -2987,12 +2841,0 @@\n-# Rule\tNAME\tFROM\tTO\t-\tIN\tON\tAT\tSAVE\tLETTER\/S\n-Rule\tBahamas\t1942\tonly\t-\tMay\t 1\t24:00\t1:00\tW\n-Rule\tBahamas\t1944\tonly\t-\tDec\t31\t24:00\t0\tS\n-Rule\tBahamas\t1945\tonly\t-\tFeb\t 1\t0:00\t1:00\tW\n-Rule\tBahamas\t1945\tonly\t-\tAug\t14\t23:00u\t1:00\tP # Peace\n-Rule\tBahamas\t1945\tonly\t-\tOct\t17\t24:00\t0\tS\n-Rule\tBahamas\t1964\t1975\t-\tOct\tlastSun\t2:00\t0\tS\n-Rule\tBahamas\t1964\t1975\t-\tApr\tlastSun\t2:00\t1:00\tD\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tAmerica\/Nassau\t-5:09:30 -\tLMT\t1912 Mar 2\n-\t\t\t-5:00\tBahamas\tE%sT\t1976\n-\t\t\t-5:00\tUS\tE%sT\n@@ -3004,0 +2846,29 @@\n+# From P Chan (2020-12-09 and 2020-12-11):\n+# Standard time of GMT-4 was adopted in 1911.\n+# Definition of Time Act, 1911 (1911-7) [1911-08-28]\n+# 1912, Laws of Barbados (5 v.), OCLC Number: 919801291, Vol. 4, Image No. 522\n+# 1944, Laws of Barbados (5 v.), OCLC Number: 84548697, Vol. 4, Image No. 122\n+# http:\/\/llmc.com\/browse.aspx?type=2&coll=85&div=297\n+#\n+# DST was observed in 1942-44.\n+# Defence (Daylight Saving) Regulations, 1942, 1942-04-13\n+# Defence (Daylight Saving) (Repeal) Regulations, 1942, 1942-08-22\n+# Defence (Daylight Saving) Regulations, 1943, 1943-04-16\n+# Defence (Daylight Saving) (Repeal) Regulations, 1943, 1943-09-01\n+# Defence (Daylight Saving) Regulations, 1944, 1944-03-21\n+# [Defence (Daylight Saving) (Amendment) Regulations 1944, 1944-03-28]\n+# Defence (Daylight Saving) (Repeal) Regulations, 1944, 1944-08-30\n+#\n+# 1914-, Subsidiary Legis., Annual Vols. OCLC Number: 226290591\n+# 1942: Image Nos. 527-528, 555-556\n+# 1943: Image Nos. 178-179, 198\n+# 1944: Image Nos. 113-115, 129\n+# http:\/\/llmc.com\/titledescfull.aspx?type=2&coll=85&div=297&set=98437\n+#\n+# From Tim Parenti (2021-02-20):\n+# The transitions below are derived from P Chan's sources, except that the 1977\n+# through 1980 transitions are from Shanks & Pottenger since we have no better\n+# data there.  Of particular note, the 1944 DST regulation only advanced the\n+# time to \"exactly three and a half hours later than Greenwich mean time\", as\n+# opposed to \"three hours\" in the 1942 and 1943 regulations.\n+\n@@ -3005,0 +2876,6 @@\n+Rule\tBarb\t1942\tonly\t-\tApr\t19\t5:00u\t1:00\tD\n+Rule\tBarb\t1942\tonly\t-\tAug\t31\t6:00u\t0\tS\n+Rule\tBarb\t1943\tonly\t-\tMay\t 2\t5:00u\t1:00\tD\n+Rule\tBarb\t1943\tonly\t-\tSep\t 5\t6:00u\t0\tS\n+Rule\tBarb\t1944\tonly\t-\tApr\t10\t5:00u\t0:30\t-\n+Rule\tBarb\t1944\tonly\t-\tSep\t10\t6:00u\t0\tS\n@@ -3011,2 +2888,3 @@\n-Zone America\/Barbados\t-3:58:29 -\tLMT\t1924 # Bridgetown\n-\t\t\t-3:58:29 -\tBMT\t1932 # Bridgetown Mean Time\n+Zone America\/Barbados\t-3:58:29 -\tLMT\t1911 Aug 28 # Bridgetown\n+\t\t\t-4:00\tBarb\tA%sT\t1944\n+\t\t\t-4:00\tBarb\tAST\/-0330 1945\n@@ -3174,0 +3052,3 @@\n+# Caribbean Netherlands\n+# See America\/Puerto_Rico.\n+\n@@ -3402,1 +3283,1 @@\n-# See America\/Port_of_Spain.\n+# See America\/Puerto_Rico.\n@@ -3454,1 +3335,1 @@\n-# See America\/Port_of_Spain.\n+# See America\/Puerto_Rico.\n@@ -3641,1 +3522,1 @@\n-# See America\/Port_of_Spain.\n+# See America\/Puerto_Rico.\n@@ -3713,0 +3594,1 @@\n+Link America\/Panama America\/Atikokan\n@@ -3722,0 +3604,19 @@\n+Link America\/Puerto_Rico America\/Anguilla\n+Link America\/Puerto_Rico America\/Antigua\n+Link America\/Puerto_Rico America\/Aruba\n+Link America\/Puerto_Rico America\/Curacao\n+Link America\/Puerto_Rico America\/Blanc-Sablon\t# Quebec (Lower North Shore)\n+Link America\/Puerto_Rico America\/Dominica\n+Link America\/Puerto_Rico America\/Grenada\n+Link America\/Puerto_Rico America\/Guadeloupe\n+Link America\/Puerto_Rico America\/Kralendijk\t# Caribbean Netherlands\n+Link America\/Puerto_Rico America\/Lower_Princes\t# Sint Maarten\n+Link America\/Puerto_Rico America\/Marigot\t# St Martin (French part)\n+Link America\/Puerto_Rico America\/Montserrat\n+Link America\/Puerto_Rico America\/Port_of_Spain\t# Trinidad & Tobago\n+Link America\/Puerto_Rico America\/St_Barthelemy\t# St Barthélemy\n+Link America\/Puerto_Rico America\/St_Kitts\t# St Kitts & Nevis\n+Link America\/Puerto_Rico America\/St_Lucia\n+Link America\/Puerto_Rico America\/St_Thomas\t# Virgin Islands (US)\n+Link America\/Puerto_Rico America\/St_Vincent\n+Link America\/Puerto_Rico America\/Tortola\t# Virgin Islands (UK)\n@@ -3725,1 +3626,1 @@\n-# See America\/Port_of_Spain.\n+# See America\/Puerto_Rico.\n@@ -3736,1 +3637,4 @@\n-# See America\/Port_of_Spain.\n+# See America\/Puerto_Rico.\n+\n+# Sint Maarten\n+# See America\/Puerto_Rico.\n@@ -3807,2 +3711,2 @@\n-# Virgin Is\n-# See America\/Port_of_Spain.\n+# US Virgin Is\n+# See America\/Puerto_Rico.\n","filename":"make\/data\/tzdata\/northamerica","additions":85,"deletions":181,"binary":false,"changes":266,"status":"modified"},{"patch":"@@ -600,1 +600,1 @@\n-Link America\/Curacao America\/Aruba\n+# See America\/Puerto_Rico.\n@@ -1395,16 +1395,1 @@\n-\n-# Milne gives 4:35:46.9 for Curaçao mean time; round to nearest.\n-#\n-# From Paul Eggert (2006-03-22):\n-# Shanks & Pottenger say that The Bottom and Philipsburg have been at\n-# -4:00 since standard time was introduced on 1912-03-02; and that\n-# Kralendijk and Rincon used Kralendijk Mean Time (-4:33:08) from\n-# 1912-02-02 to 1965-01-01.  The former is dubious, since S&P also say\n-# Saba Island has been like Curaçao.\n-# This all predates our 1970 cutoff, though.\n-#\n-# By July 2007 Curaçao and St Maarten are planned to become\n-# associated states within the Netherlands, much like Aruba;\n-# Bonaire, Saba and St Eustatius would become directly part of the\n-# Netherlands as Kingdom Islands.  This won't affect their time zones\n-# though, as far as we know.\n+# See America\/Puerto_Rico.\n@@ -1412,5 +1397,0 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone\tAmerica\/Curacao\t-4:35:47 -\tLMT\t1912 Feb 12 # Willemstad\n-\t\t\t-4:30\t-\t-0430\t1965\n-\t\t\t-4:00\t-\tAST\n-\n@@ -1420,4 +1400,3 @@\n-# and contains an apostrophe; use \"Lower_Princes\" below.\n-\n-Link\tAmerica\/Curacao\tAmerica\/Lower_Princes\t# Sint Maarten\n-Link\tAmerica\/Curacao\tAmerica\/Kralendijk\t# Caribbean Netherlands\n+# and contains an apostrophe; use \"Lower_Princes\"....\n+# From Paul Eggert (2021-09-29):\n+# These backward-compatibility links now are in the 'northamerica' file.\n@@ -1566,0 +1545,29 @@\n+\n+# From P Chan (2020-11-27):\n+# https:\/\/books.google.com\/books?id=5-5CAQAAMAAJ&pg=SA1-PA547\n+# The Official Gazette of British Guiana. (New Series.) Vol. XL. July to\n+# December, 1915, p 1547, lists as several notes:\n+# \"Local Mean Time 3 hours 52 mins. 39 secs. slow of Greenwich Mean Time\n+# (Georgetown.) From 1st August, 1911, British Guiana Standard Mean Time 4\n+# hours slow of Greenwich Mean Time, by notice in Official Gazette on 1st July,\n+# 1911.  From 1st March, 1915, British Guiana Standard Mean Time 3 hours 45\n+# mins. 0 secs. slow of Greenwich Mean Time, by notice in Official Gazette on\n+# 23rd January, 1915.\"\n+#\n+# https:\/\/parliament.gov.gy\/documents\/acts\/10923-act_no._27_of_1975_-_interpretation_and_general_clauses_(amendment)_act_1975.pdf\n+# Interpretation and general clauses (Amendment) Act 1975 (Act No. 27 of 1975)\n+# [dated 1975-07-31]\n+# \"This Act...shall come into operation on 1st August, 1975.\"\n+# \"...where any expression of time occurs...the time referred to shall signify\n+# the standard time of Guyana which shall be three hours behind Greenwich Mean\n+# Time.\"\n+#\n+# Circular No. 10\/1992 dated 1992-03-20\n+# https:\/\/dps.gov.gy\/wp-content\/uploads\/2018\/12\/1992-03-20-Circular-010.pdf\n+# \"...cabinet has decided that with effect from Sunday 29th March, 1992, Guyana\n+# Standard Time would be re-established at 01:00 hours by adjusting the hands\n+# of the clock back to 24:00 hours.\"\n+# Legislated in the Interpretation and general clauses (Amendment) Act 1992\n+# (Act No. 6 of 1992) [passed 1992-03-27, published 1992-04-18]\n+# https:\/\/parliament.gov.gy\/documents\/acts\/5885-6_of_1992_interpretation_and_general_clauses_(amendment)_act_1992.pdf\n+\n@@ -1567,4 +1575,4 @@\n-Zone\tAmerica\/Guyana\t-3:52:40 -\tLMT\t1915 Mar    # Georgetown\n-\t\t\t-3:45\t-\t-0345\t1975 Jul 31\n-\t\t\t-3:00\t-\t-03\t1991\n-# IATA SSIM (1996-06) says -4:00.  Assume a 1991 switch.\n+Zone\tAmerica\/Guyana\t-3:52:39 -\tLMT\t1911 Aug  1 # Georgetown\n+\t\t\t-4:00\t-\t-04\t1915 Mar  1\n+\t\t\t-3:45\t-\t-0345\t1975 Aug  1\n+\t\t\t-3:00\t-\t-03\t1992 Mar 29  1:00\n@@ -1711,18 +1719,1 @@\n-# Zone\tNAME\t\tSTDOFF\tRULES\tFORMAT\t[UNTIL]\n-Zone America\/Port_of_Spain -4:06:04 -\tLMT\t1912 Mar 2\n-\t\t\t-4:00\t-\tAST\n-\n-# These all agree with Trinidad and Tobago since 1970.\n-Link America\/Port_of_Spain America\/Anguilla\n-Link America\/Port_of_Spain America\/Antigua\n-Link America\/Port_of_Spain America\/Dominica\n-Link America\/Port_of_Spain America\/Grenada\n-Link America\/Port_of_Spain America\/Guadeloupe\n-Link America\/Port_of_Spain America\/Marigot\t# St Martin (French part)\n-Link America\/Port_of_Spain America\/Montserrat\n-Link America\/Port_of_Spain America\/St_Barthelemy # St Barthélemy\n-Link America\/Port_of_Spain America\/St_Kitts\t# St Kitts & Nevis\n-Link America\/Port_of_Spain America\/St_Lucia\n-Link America\/Port_of_Spain America\/St_Thomas\t# Virgin Islands (US)\n-Link America\/Port_of_Spain America\/St_Vincent\n-Link America\/Port_of_Spain America\/Tortola\t# Virgin Islands (UK)\n+# See America\/Puerto_Rico.\n","filename":"make\/data\/tzdata\/southamerica","additions":39,"deletions":48,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-# From Paul Eggert (2018-06-27):\n+# From Paul Eggert (2021-09-20):\n@@ -42,0 +42,3 @@\n+# Unlike zone1970.tab, a row's third column can be a Link from\n+# 'backward' instead of a Zone.\n+#\n@@ -254,1 +257,1 @@\n-KI\t-0308-17105\tPacific\/Enderbury\tPhoenix Islands\n+KI\t-0247-17143\tPacific\/Kanton\tPhoenix Islands\n@@ -417,1 +420,1 @@\n-TO\t-2110-17510\tPacific\/Tongatapu\n+TO\t-210800-1751200\tPacific\/Tongatapu\n","filename":"make\/data\/tzdata\/zone.tab","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-        undef, \\\n+        undef stringop-overflow, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10896,1 +10896,0 @@\n-  match(Set dst (MulI src1 (SubI zero src2)));\n@@ -10948,1 +10947,0 @@\n-  match(Set dst (MulL src1 (SubL zero src2)));\n@@ -10998,1 +10996,0 @@\n-  match(Set dst (MulL (ConvI2L src1) (SubL zero (ConvI2L src2))));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+extern aarch64_atomic_stub_t aarch64_atomic_fetch_add_4_relaxed_impl;\n+extern aarch64_atomic_stub_t aarch64_atomic_fetch_add_8_relaxed_impl;\n","filename":"src\/hotspot\/cpu\/aarch64\/atomic_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4842,12 +4842,0 @@\n-  \/\/ code for comparing 16 bytes of strings with same encoding\n-  void compare_string_16_bytes_same(Label &DIFF1, Label &DIFF2) {\n-    Register result = r0, str1 = r1, cnt1 = r2, str2 = r3, tmp1 = r10, tmp2 = r11;\n-    __ ldr(rscratch1, Address(__ post(str1, 8)));\n-    __ eor(rscratch2, tmp1, tmp2);\n-    __ ldr(cnt1, Address(__ post(str2, 8)));\n-    __ cbnz(rscratch2, DIFF1);\n-    __ ldr(tmp1, Address(__ post(str1, 8)));\n-    __ eor(rscratch2, rscratch1, cnt1);\n-    __ ldr(tmp2, Address(__ post(str2, 8)));\n-    __ cbnz(rscratch2, DIFF2);\n-  }\n@@ -5060,4 +5048,4 @@\n-        tmp1 = r10, tmp2 = r11;\n-    Label SMALL_LOOP, LARGE_LOOP_PREFETCH, CHECK_LAST, DIFF2, TAIL,\n-        LENGTH_DIFF, DIFF, LAST_CHECK_AND_LENGTH_DIFF,\n-        DIFF_LAST_POSITION, DIFF_LAST_POSITION2;\n+        tmp1 = r10, tmp2 = r11, tmp1h = rscratch1, tmp2h = rscratch2;\n+\n+    Label LARGE_LOOP_PREFETCH, LOOP_COMPARE16, DIFF, LESS16, LESS8, CAL_DIFFERENCE, LENGTH_DIFF;\n+\n@@ -5067,2 +5055,5 @@\n-    \/\/ cnt1\/cnt2 contains amount of characters to compare. cnt1 can be re-used\n-    \/\/ update cnt2 counter with already loaded 8 bytes\n+\n+    \/\/ before jumping to stub, pre-load 8 bytes already, so do comparison directly\n+    __ eor(rscratch2, tmp1, tmp2);\n+    __ cbnz(rscratch2, CAL_DIFFERENCE);\n+\n@@ -5077,2 +5068,9 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n+\n+        __ align(OptoLoopAlignment);\n+        for (int i = 0; i < 4; i++) {\n+          __ ldp(tmp1, tmp1h, Address(str1, i * 16));\n+          __ ldp(tmp2, tmp2h, Address(str2, i * 16));\n+          __ cmp(tmp1, tmp2);\n+          __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+          __ br(Assembler::NE, DIFF);\n+        }\n@@ -5080,1 +5078,2 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n+        __ add(str1, str1, 64);\n+        __ add(str2, str2, 64);\n@@ -5082,3 +5081,2 @@\n-        compare_string_16_bytes_same(DIFF, DIFF2);\n-        __ br(__ GT, LARGE_LOOP_PREFETCH);\n-        __ cbz(cnt2, LAST_CHECK_AND_LENGTH_DIFF); \/\/ no more chars left?\n+        __ br(Assembler::GE, LARGE_LOOP_PREFETCH);\n+        __ cbz(cnt2, LENGTH_DIFF); \/\/ no more chars left?\n@@ -5086,3 +5084,3 @@\n-    \/\/ less than 16 bytes left?\n-    __ subs(cnt2, cnt2, isLL ? 16 : 8);\n-    __ br(__ LT, TAIL);\n+\n+    __ subs(rscratch1, cnt2, isLL ? 16 : 8);\n+    __ br(Assembler::LE, LESS16);\n@@ -5090,7 +5088,22 @@\n-    __ bind(SMALL_LOOP);\n-      compare_string_16_bytes_same(DIFF, DIFF2);\n-      __ subs(cnt2, cnt2, isLL ? 16 : 8);\n-      __ br(__ GE, SMALL_LOOP);\n-    __ bind(TAIL);\n-      __ adds(cnt2, cnt2, isLL ? 16 : 8);\n-      __ br(__ EQ, LAST_CHECK_AND_LENGTH_DIFF);\n+    __ bind(LOOP_COMPARE16);\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(Assembler::NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(Assembler::LT, LESS16);\n+\n+      __ ldp(tmp1, tmp1h, Address(__ post(str1, 16)));\n+      __ ldp(tmp2, tmp2h, Address(__ post(str2, 16)));\n+      __ cmp(tmp1, tmp2);\n+      __ ccmp(tmp1h, tmp2h, 0, Assembler::EQ);\n+      __ br(Assembler::NE, DIFF);\n+      __ sub(cnt2, cnt2, isLL ? 16 : 8);\n+      __ subs(rscratch2, cnt2, isLL ? 16 : 8);\n+      __ br(Assembler::GE, LOOP_COMPARE16);\n+      __ cbz(cnt2, LENGTH_DIFF);\n+\n+    __ bind(LESS16);\n+      \/\/ each 8 compare\n@@ -5098,3 +5111,1 @@\n-      __ br(__ LE, CHECK_LAST);\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, DIFF);\n+      __ br(Assembler::LE, LESS8);\n@@ -5103,0 +5114,2 @@\n+      __ eor(rscratch2, tmp1, tmp2);\n+      __ cbnz(rscratch2, CAL_DIFFERENCE);\n@@ -5104,1 +5117,2 @@\n-    __ bind(CHECK_LAST);\n+\n+    __ bind(LESS8); \/\/ directly load last 8 bytes\n@@ -5106,1 +5120,1 @@\n-        __ add(cnt2, cnt2, cnt2); \/\/ now in bytes\n+        __ add(cnt2, cnt2, cnt2);\n@@ -5108,0 +5122,2 @@\n+      __ ldr(tmp1, Address(str1, cnt2));\n+      __ ldr(tmp2, Address(str2, cnt2));\n@@ -5109,4 +5125,0 @@\n-      __ cbnz(rscratch2, DIFF);\n-      __ ldr(rscratch1, Address(str1, cnt2));\n-      __ ldr(cnt1, Address(str2, cnt2));\n-      __ eor(rscratch2, rscratch1, cnt1);\n@@ -5114,18 +5126,2 @@\n-      \/\/ Find the first different characters in the longwords and\n-      \/\/ compute their difference.\n-    __ bind(DIFF2);\n-      __ rev(rscratch2, rscratch2);\n-      __ clz(rscratch2, rscratch2);\n-      __ andr(rscratch2, rscratch2, isLL ? -8 : -16);\n-      __ lsrv(rscratch1, rscratch1, rscratch2);\n-      if (isLL) {\n-        __ lsrv(cnt1, cnt1, rscratch2);\n-        __ uxtbw(rscratch1, rscratch1);\n-        __ uxtbw(cnt1, cnt1);\n-      } else {\n-        __ lsrv(cnt1, cnt1, rscratch2);\n-        __ uxthw(rscratch1, rscratch1);\n-        __ uxthw(cnt1, cnt1);\n-      }\n-      __ subw(result, rscratch1, cnt1);\n-      __ b(LENGTH_DIFF);\n+      __ b(CAL_DIFFERENCE);\n+\n@@ -5133,0 +5129,7 @@\n+      __ cmp(tmp1, tmp2);\n+      __ csel(tmp1, tmp1, tmp1h, Assembler::NE);\n+      __ csel(tmp2, tmp2, tmp2h, Assembler::NE);\n+      \/\/ reuse rscratch2 register for the result of eor instruction\n+      __ eor(rscratch2, tmp1, tmp2);\n+\n+    __ bind(CAL_DIFFERENCE);\n@@ -5137,0 +5140,1 @@\n+      __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5138,1 +5142,0 @@\n-        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5142,1 +5145,0 @@\n-        __ lsrv(tmp2, tmp2, rscratch2);\n@@ -5147,4 +5149,1 @@\n-      __ b(LENGTH_DIFF);\n-    __ bind(LAST_CHECK_AND_LENGTH_DIFF);\n-      __ eor(rscratch2, tmp1, tmp2);\n-      __ cbnz(rscratch2, DIFF);\n+\n@@ -6213,1 +6212,1 @@\n-  void gen_ldaddal_entry(Assembler::operand_size size) {\n+  void gen_ldadd_entry(Assembler::operand_size size, atomic_memory_order order) {\n@@ -6215,2 +6214,8 @@\n-    __ ldaddal(size, incr, prev, addr);\n-    __ membar(Assembler::StoreStore|Assembler::StoreLoad);\n+    \/\/ If not relaxed, then default to conservative.  Relaxed is the only\n+    \/\/ case we use enough to be worth specializing.\n+    if (order == memory_order_relaxed) {\n+      __ ldadd(size, incr, prev, addr);\n+    } else {\n+      __ ldaddal(size, incr, prev, addr);\n+      __ membar(Assembler::StoreStore|Assembler::StoreLoad);\n+    }\n@@ -6246,1 +6251,1 @@\n-    \/\/ All memory_order_conservative\n+    \/\/ ADD, memory_order_conservative\n@@ -6248,1 +6253,1 @@\n-    gen_ldaddal_entry(Assembler::word);\n+    gen_ldadd_entry(Assembler::word, memory_order_conservative);\n@@ -6250,1 +6255,9 @@\n-    gen_ldaddal_entry(Assembler::xword);\n+    gen_ldadd_entry(Assembler::xword, memory_order_conservative);\n+\n+    \/\/ ADD, memory_order_relaxed\n+    AtomicStubMark mark_fetch_add_4_relaxed\n+      (_masm, &aarch64_atomic_fetch_add_4_relaxed_impl);\n+    gen_ldadd_entry(MacroAssembler::word, memory_order_relaxed);\n+    AtomicStubMark mark_fetch_add_8_relaxed\n+      (_masm, &aarch64_atomic_fetch_add_8_relaxed_impl);\n+    gen_ldadd_entry(MacroAssembler::xword, memory_order_relaxed);\n@@ -6252,0 +6265,1 @@\n+    \/\/ XCHG, memory_order_conservative\n@@ -7451,0 +7465,2 @@\n+DEFAULT_ATOMIC_OP(fetch_add, 4, _relaxed)\n+DEFAULT_ATOMIC_OP(fetch_add, 8, _relaxed)\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":89,"deletions":73,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -49,2 +49,1 @@\n-  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\",\n-                                  Monitor::_safepoint_check_never);\n+  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\");\n","filename":"src\/hotspot\/os\/aix\/osThread_aix.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -48,2 +48,1 @@\n-  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\",\n-                                  Monitor::_safepoint_check_never);\n+  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\");\n","filename":"src\/hotspot\/os\/bsd\/osThread_bsd.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,2 +43,1 @@\n-  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\",\n-                                  Monitor::_safepoint_check_never);\n+  _startThread_lock = new Monitor(Mutex::event, \"startThread_lock\");\n","filename":"src\/hotspot\/os\/linux\/osThread_linux.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1861,1 +1861,5 @@\n-      st->print(\"10\");\n+      if (build_number >= 22000) {\n+        st->print(\"11\");\n+      } else {\n+        st->print(\"10\");\n+      }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,0 +50,22 @@\n+        .global aarch64_atomic_fetch_add_8_relaxed_default_impl\n+        .align 5\n+aarch64_atomic_fetch_add_8_relaxed_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldxr    x2, [x0]\n+        add     x8, x2, x1\n+        stxr    w9, x8, [x0]\n+        cbnz    w9, 0b\n+        mov     x0, x2\n+        ret\n+\n+        .global aarch64_atomic_fetch_add_4_relaxed_default_impl\n+        .align 5\n+aarch64_atomic_fetch_add_4_relaxed_default_impl:\n+        prfm    pstl1strm, [x0]\n+0:      ldxr    w2, [x0]\n+        add     w8, w2, w1\n+        stxr    w9, w8, [x0]\n+        cbnz    w9, 0b\n+        mov     w0, w2\n+        ret\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.S","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,3 +90,8 @@\n-  D old_value\n-    = atomic_fastcall(aarch64_atomic_fetch_add_4_impl, dest, add_value);\n-  return old_value;\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_fetch_add_4_relaxed_impl; break;\n+  default:\n+    stub = aarch64_atomic_fetch_add_4_impl; break;\n+  }\n+  return atomic_fastcall(stub, dest, add_value);\n@@ -101,3 +106,8 @@\n-  D old_value\n-    = atomic_fastcall(aarch64_atomic_fetch_add_8_impl, dest, add_value);\n-  return old_value;\n+  aarch64_atomic_stub_t stub;\n+  switch (order) {\n+  case memory_order_relaxed:\n+    stub = aarch64_atomic_fetch_add_8_relaxed_impl; break;\n+  default:\n+    stub = aarch64_atomic_fetch_add_8_impl; break;\n+  }\n+  return atomic_fastcall(stub, dest, add_value);\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/atomic_linux_aarch64.hpp","additions":17,"deletions":7,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1131,4 +1131,0 @@\n-  if (mapinfo->header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    mapinfo->set_header_base_archive_name_size(strlen(Arguments::GetSharedArchivePath()) + 1);\n-    mapinfo->set_header_base_archive_is_default(FLAG_IS_DEFAULT(SharedArchiveFile));\n-  }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,9 +34,11 @@\n-  { \"CDSFileMapHeaderBase::_magic\",           offset_of(CDSFileMapHeaderBase, _magic)           },\n-  { \"CDSFileMapHeaderBase::_crc\",             offset_of(CDSFileMapHeaderBase, _crc)             },\n-  { \"CDSFileMapHeaderBase::_version\",         offset_of(CDSFileMapHeaderBase, _version)         },\n-  { \"CDSFileMapHeaderBase::_space[0]\",        offset_of(CDSFileMapHeaderBase, _space)           },\n-  { \"FileMapHeader::_jvm_ident\",              offset_of(FileMapHeader, _jvm_ident)              },\n-  { \"FileMapHeader::_base_archive_name_size\", offset_of(FileMapHeader, _base_archive_name_size) },\n-  { \"CDSFileMapRegion::_crc\",                 offset_of(CDSFileMapRegion, _crc)                 },\n-  { \"CDSFileMapRegion::_used\",                offset_of(CDSFileMapRegion, _used)                },\n-  { \"DynamicArchiveHeader::_base_region_crc\", offset_of(DynamicArchiveHeader, _base_region_crc) }\n+  { \"GenericCDSFileMapHeader::_magic\",                     offset_of(GenericCDSFileMapHeader, _magic)          },\n+  { \"GenericCDSFileMapHeader::_crc\",                       offset_of(GenericCDSFileMapHeader, _crc)            },\n+  { \"GenericCDSFileMapHeader::_version\",                   offset_of(GenericCDSFileMapHeader, _version)        },\n+  { \"GenericCDSFileMapHeader::_header_size\",               offset_of(GenericCDSFileMapHeader, _header_size)    },\n+  { \"GenericCDSFileMapHeader::_base_archive_path_offset\",  offset_of(GenericCDSFileMapHeader, _base_archive_path_offset) },\n+  { \"GenericCDSFileMapHeader::_base_archive_name_size\",    offset_of(GenericCDSFileMapHeader, _base_archive_name_size)   },\n+  { \"CDSFileMapHeaderBase::_space[0]\",                     offset_of(CDSFileMapHeaderBase, _space)             },\n+  { \"FileMapHeader::_jvm_ident\",                           offset_of(FileMapHeader, _jvm_ident)                },\n+  { \"CDSFileMapRegion::_crc\",                              offset_of(CDSFileMapRegion, _crc)                   },\n+  { \"CDSFileMapRegion::_used\",                             offset_of(CDSFileMapRegion, _used)                  },\n+  { \"DynamicArchiveHeader::_base_region_crc\",              offset_of(DynamicArchiveHeader, _base_region_crc)   }\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+  FileMapInfo* base_info = FileMapInfo::current_info();\n+  \/\/ header only be available after populate_header\n+  mapinfo->populate_header(base_info->core_region_alignment());\n@@ -185,1 +188,0 @@\n-  FileMapInfo* base_info = FileMapInfo::current_info();\n@@ -190,1 +192,0 @@\n-  _header->populate(base_info, base_info->core_region_alignment());\n@@ -328,1 +329,1 @@\n-                         \" [\" SIZE_FORMAT \" bytes header, \" SIZE_FORMAT \" bytes total]\",\n+                         \" [\" UINT32_FORMAT \" bytes header, \" SIZE_FORMAT \" bytes total]\",\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/globals_extension.hpp\"\n@@ -172,2 +173,1 @@\n-  size_t header_size;\n-  if (is_static) {\n+  if (_is_static) {\n@@ -176,1 +176,0 @@\n-    header_size = sizeof(FileMapHeader);\n@@ -180,1 +179,0 @@\n-    header_size = sizeof(DynamicArchiveHeader);\n@@ -182,5 +180,0 @@\n-  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n-  memset((void*)_header, 0, header_size);\n-  _header->set_header_size(header_size);\n-  _header->set_version(INVALID_CDS_ARCHIVE_VERSION);\n-  _header->set_has_platform_or_app_classes(true);\n@@ -202,6 +195,8 @@\n-  header()->populate(this, core_region_alignment);\n-}\n-\n-void FileMapHeader::populate(FileMapInfo* mapinfo, size_t core_region_alignment) {\n-  if (DynamicDumpSharedSpaces) {\n-    _magic = CDS_DYNAMIC_ARCHIVE_MAGIC;\n+  assert(_header == NULL, \"Sanity check\");\n+  size_t c_header_size;\n+  size_t header_size;\n+  size_t base_archive_name_size = 0;\n+  size_t base_archive_path_offset = 0;\n+  if (is_static()) {\n+    c_header_size = sizeof(FileMapHeader);\n+    header_size = c_header_size;\n@@ -209,1 +204,33 @@\n-    _magic = CDS_ARCHIVE_MAGIC;\n+    \/\/ dynamic header including base archive name for non-default base archive\n+    c_header_size = sizeof(DynamicArchiveHeader);\n+    header_size = c_header_size;\n+    if (!FLAG_IS_DEFAULT(SharedArchiveFile)) {\n+      base_archive_name_size = strlen(Arguments::GetSharedArchivePath()) + 1;\n+      header_size += base_archive_name_size;\n+      base_archive_path_offset = c_header_size;\n+    }\n+  }\n+  _header = (FileMapHeader*)os::malloc(header_size, mtInternal);\n+  memset((void*)_header, 0, header_size);\n+  _header->populate(this,\n+                    core_region_alignment,\n+                    header_size,\n+                    base_archive_name_size,\n+                    base_archive_path_offset);\n+}\n+\n+void FileMapHeader::populate(FileMapInfo *info, size_t core_region_alignment,\n+                             size_t header_size, size_t base_archive_name_size,\n+                             size_t base_archive_path_offset) {\n+  \/\/ 1. We require _generic_header._magic to be at the beginning of the file\n+  \/\/ 2. FileMapHeader also assumes that _generic_header is at the beginning of the file\n+  assert(offset_of(FileMapHeader, _generic_header) == 0, \"must be\");\n+  set_header_size((unsigned int)header_size);\n+  set_base_archive_path_offset((unsigned int)base_archive_path_offset);\n+  set_base_archive_name_size((unsigned int)base_archive_name_size);\n+  set_magic(DynamicDumpSharedSpaces ? CDS_DYNAMIC_ARCHIVE_MAGIC : CDS_ARCHIVE_MAGIC);\n+  set_version(CURRENT_CDS_ARCHIVE_VERSION);\n+\n+  if (!info->is_static() && base_archive_name_size != 0) {\n+    \/\/ copy base archive name\n+    copy_base_archive_name(Arguments::GetSharedArchivePath());\n@@ -211,1 +238,0 @@\n-  _version = CURRENT_CDS_ARCHIVE_VERSION;\n@@ -248,3 +274,0 @@\n-  \/\/ the following 2 fields will be set in write_header for dynamic archive header\n-  _base_archive_name_size = 0;\n-  _base_archive_is_default = false;\n@@ -253,1 +276,1 @@\n-    set_shared_path_table(mapinfo->_shared_path_table);\n+    set_shared_path_table(info->_shared_path_table);\n@@ -258,0 +281,7 @@\n+void FileMapHeader::copy_base_archive_name(const char* archive) {\n+  assert(base_archive_name_size() != 0, \"_base_archive_name_size not set\");\n+  assert(base_archive_path_offset() != 0, \"_base_archive_path_offset not set\");\n+  assert(header_size() > sizeof(*this), \"_base_archive_name_size not included in header size?\");\n+  memcpy((char*)this + base_archive_path_offset(), archive, base_archive_name_size());\n+}\n+\n@@ -261,3 +291,6 @@\n-  st->print_cr(\"- magic:                          0x%08x\", _magic);\n-  st->print_cr(\"- crc:                            0x%08x\", _crc);\n-  st->print_cr(\"- version:                        %d\", _version);\n+  st->print_cr(\"- magic:                          0x%08x\", magic());\n+  st->print_cr(\"- crc:                            0x%08x\", crc());\n+  st->print_cr(\"- version:                        %d\", version());\n+  st->print_cr(\"- header_size:                    \" UINT32_FORMAT, header_size());\n+  st->print_cr(\"- base_archive_path_offset:       \" UINT32_FORMAT, base_archive_path_offset());\n+  st->print_cr(\"- base_archive_name_size:         \" UINT32_FORMAT, base_archive_name_size());\n@@ -271,1 +304,0 @@\n-  st->print_cr(\"- header_size:                    \" SIZE_FORMAT, _header_size);\n@@ -286,1 +318,0 @@\n-  st->print_cr(\"- base_archive_is_default:        %d\", _base_archive_is_default);\n@@ -288,1 +319,0 @@\n-  st->print_cr(\"- base_archive_name_size:         \" SIZE_FORMAT, _base_archive_name_size);\n@@ -1015,0 +1045,62 @@\n+\/\/ a utility class for checking file header\n+class FileHeaderHelper {\n+  int _fd;\n+  GenericCDSFileMapHeader _header;\n+\n+public:\n+  FileHeaderHelper() {\n+    _fd = -1;\n+  }\n+\n+  ~FileHeaderHelper() {\n+    if (_fd != -1) {\n+      os::close(_fd);\n+    }\n+  }\n+\n+  bool initialize(const char* archive_name) {\n+    _fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n+    if (_fd < 0) {\n+      return false;\n+    }\n+    return initialize(_fd);\n+  }\n+\n+  \/\/ for an already opened file, do not set _fd\n+  bool initialize(int fd) {\n+    assert(fd != -1, \"Archive should be opened\");\n+    size_t size = sizeof(GenericCDSFileMapHeader);\n+    lseek(fd, 0, SEEK_SET);\n+    size_t n = os::read(fd, (void*)&_header, (unsigned int)size);\n+    if (n != size) {\n+      vm_exit_during_initialization(\"Unable to read generic CDS file map header from shared archive\");\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  GenericCDSFileMapHeader* get_generic_file_header() {\n+    return &_header;\n+  }\n+\n+  bool read_base_archive_name(char** target) {\n+    assert(_fd != -1, \"Archive should be open\");\n+    size_t name_size = (size_t)_header._base_archive_name_size;\n+    assert(name_size != 0, \"For non-default base archive, name size should be non-zero!\");\n+    *target = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n+    lseek(_fd, _header._base_archive_path_offset, SEEK_SET); \/\/ position to correct offset.\n+    size_t n = os::read(_fd, *target, (unsigned int)name_size);\n+    if (n != name_size) {\n+      log_info(cds)(\"Unable to read base archive name from archive\");\n+      FREE_C_HEAP_ARRAY(char, *target);\n+      return false;\n+    }\n+    if (!os::file_exists(*target)) {\n+      log_info(cds)(\"Base archive %s does not exist\", *target);\n+      FREE_C_HEAP_ARRAY(char, *target);\n+      return false;\n+    }\n+    return true;\n+  }\n+};\n+\n@@ -1016,2 +1108,2 @@\n-  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-  if (fd < 0) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(archive_name)) {\n@@ -1024,10 +1116,1 @@\n-  size_t sz = is_static ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n-  void* header = os::malloc(sz, mtInternal);\n-  memset(header, 0, sz);\n-  size_t n = os::read(fd, header, (unsigned int)sz);\n-  if (n != sz) {\n-    os::free(header);\n-    os::close(fd);\n-    vm_exit_during_initialization(\"Unable to read header from shared archive\", archive_name);\n-    return false;\n-  }\n+  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n@@ -1035,4 +1118,1 @@\n-    FileMapHeader* static_header = (FileMapHeader*)header;\n-    if (static_header->magic() != CDS_ARCHIVE_MAGIC) {\n-      os::free(header);\n-      os::close(fd);\n+    if (header->_magic != CDS_ARCHIVE_MAGIC) {\n@@ -1042,0 +1122,5 @@\n+    if (header->_base_archive_path_offset != 0) {\n+      log_info(cds)(\"_base_archive_path_offset should be 0\");\n+      log_info(cds)(\"_base_archive_path_offset = \" UINT32_FORMAT, header->_base_archive_path_offset);\n+      return false;\n+    }\n@@ -1043,4 +1128,1 @@\n-    DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)header;\n-    if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-      os::free(header);\n-      os::close(fd);\n+    if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n@@ -1050,0 +1132,15 @@\n+    unsigned int name_size = header->_base_archive_name_size;\n+    unsigned int path_offset = header->_base_archive_path_offset;\n+    unsigned int header_size = header->_header_size;\n+    if (path_offset + name_size != header_size) {\n+      log_info(cds)(\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\");\n+      log_info(cds)(\"  _base_archive_name_size   = \" UINT32_FORMAT, name_size);\n+      log_info(cds)(\"  _base_archive_path_offset = \" UINT32_FORMAT, path_offset);\n+      log_info(cds)(\"  _header_size              = \" UINT32_FORMAT, header_size);\n+      return false;\n+    }\n+    char* base_name = NULL;\n+    if (!file_helper.read_base_archive_name(&base_name)) {\n+      return false;\n+    }\n+    FREE_C_HEAP_ARRAY(char, base_name);\n@@ -1051,2 +1148,0 @@\n-  os::free(header);\n-  os::close(fd);\n@@ -1057,4 +1152,3 @@\n-                                                    int* size, char** base_archive_name) {\n-  int fd = os::open(archive_name, O_RDONLY | O_BINARY, 0);\n-  if (fd < 0) {\n-    *size = 0;\n+                                                    char** base_archive_name) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(archive_name)) {\n@@ -1063,9 +1157,3 @@\n-\n-  \/\/ read the header as a dynamic archive header\n-  size_t sz = sizeof(DynamicArchiveHeader);\n-  DynamicArchiveHeader* dynamic_header = (DynamicArchiveHeader*)os::malloc(sz, mtInternal);\n-  size_t n = os::read(fd, dynamic_header, (unsigned int)sz);\n-  if (n != sz) {\n-    fail_continue(\"Unable to read the file header.\");\n-    os::free(dynamic_header);\n-    os::close(fd);\n+  GenericCDSFileMapHeader* header = file_helper.get_generic_file_header();\n+  if (header->_magic != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n+    \/\/ Not a dynamic header, no need to proceed further.\n@@ -1074,5 +1162,4 @@\n-  if (dynamic_header->magic() != CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    \/\/ Not a dynamic header, no need to proceed further.\n-    *size = 0;\n-    os::free(dynamic_header);\n-    os::close(fd);\n+\n+  if ((header->_base_archive_name_size == 0 && header->_base_archive_path_offset != 0) ||\n+      (header->_base_archive_name_size != 0 && header->_base_archive_path_offset == 0)) {\n+    fail_continue(\"Default base archive not set correct\");\n@@ -1081,1 +1168,2 @@\n-  if (dynamic_header->base_archive_is_default()) {\n+  if (header->_base_archive_name_size == 0 &&\n+      header->_base_archive_path_offset == 0) {\n@@ -1085,11 +1173,1 @@\n-    size_t name_size = dynamic_header->base_archive_name_size();\n-    if (name_size == 0) {\n-      os::free(dynamic_header);\n-      os::close(fd);\n-      return false;\n-    }\n-    *base_archive_name = NEW_C_HEAP_ARRAY(char, name_size, mtInternal);\n-    n = os::read(fd, *base_archive_name, (unsigned int)name_size);\n-    if (n != name_size) {\n-      fail_continue(\"Unable to read the base archive name from the header.\");\n-      FREE_C_HEAP_ARRAY(char, *base_archive_name);\n+    if (!file_helper.read_base_archive_name(base_archive_name)) {\n@@ -1097,2 +1175,0 @@\n-      os::free(dynamic_header);\n-      os::close(fd);\n@@ -1102,3 +1178,0 @@\n-\n-  os::free(dynamic_header);\n-  os::close(fd);\n@@ -1111,3 +1184,2 @@\n-  size_t sz = is_static() ? sizeof(FileMapHeader) : sizeof(DynamicArchiveHeader);\n-  size_t n = os::read(fd, header(), (unsigned int)sz);\n-  if (n != sz) {\n+  FileHeaderHelper file_helper;\n+  if (!file_helper.initialize(fd)) {\n@@ -1117,5 +1189,1 @@\n-\n-  if (!Arguments::has_jimage()) {\n-    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n-    return false;\n-  }\n+  GenericCDSFileMapHeader* gen_header = file_helper.get_generic_file_header();\n@@ -1124,1 +1192,1 @@\n-  if (header()->magic() != expected_magic) {\n+  if (gen_header->_magic != expected_magic) {\n@@ -1126,1 +1194,1 @@\n-    log_info(cds)(\"         actual: 0x%08x\", header()->magic());\n+    log_info(cds)(\"         actual: 0x%08x\", gen_header->_magic);\n@@ -1131,0 +1199,9 @@\n+  _header = (FileMapHeader*)os::malloc(gen_header->_header_size, mtInternal);\n+  lseek(fd, 0, SEEK_SET); \/\/ reset to begin of the archive\n+  size_t size = gen_header->_header_size;\n+  size_t n = os::read(fd, (void*)_header, (unsigned int)size);\n+  if (n != size) {\n+    fail_continue(\"Failed to read file header from the top archive file\\n\");\n+    return false;\n+  }\n+\n@@ -1138,5 +1215,11 @@\n-  if (header()->header_size() != sz) {\n-    log_info(cds)(\"_header_size expected: \" SIZE_FORMAT, sz);\n-    log_info(cds)(\"               actual: \" SIZE_FORMAT, header()->header_size());\n-    FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n-    return false;\n+  unsigned int base_offset = header()->base_archive_path_offset();\n+  unsigned int name_size = header()->base_archive_name_size();\n+  unsigned int header_size = header()->header_size();\n+  if (base_offset != 0 && name_size != 0) {\n+    if (header_size != base_offset + name_size) {\n+      log_info(cds)(\"_header_size: \" UINT32_FORMAT, header_size);\n+      log_info(cds)(\"base_archive_name_size: \" UINT32_FORMAT, name_size);\n+      log_info(cds)(\"base_archive_path_offset: \" UINT32_FORMAT, base_offset);\n+      FileMapInfo::fail_continue(\"The shared archive file has an incorrect header size.\");\n+      return false;\n+    }\n@@ -1172,1 +1255,1 @@\n-  _file_offset = n + header()->base_archive_name_size(); \/\/ accounts for the size of _base_archive_name\n+  _file_offset = header()->header_size(); \/\/ accounts for the size of _base_archive_name\n@@ -1256,3 +1339,0 @@\n-  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    header_bytes += strlen(Arguments::GetSharedArchivePath()) + 1;\n-  }\n@@ -1265,1 +1345,0 @@\n-\n@@ -1273,7 +1352,0 @@\n-\n-  if (header()->magic() == CDS_DYNAMIC_ARCHIVE_MAGIC) {\n-    char* base_archive_name = (char*)Arguments::GetSharedArchivePath();\n-    if (base_archive_name != NULL) {\n-      write_bytes(base_archive_name, header()->base_archive_name_size());\n-    }\n-  }\n@@ -2223,0 +2295,5 @@\n+  if (!Arguments::has_jimage()) {\n+    FileMapInfo::fail_continue(\"The shared archive file cannot be used with an exploded module build.\");\n+    return false;\n+  }\n+\n@@ -2261,3 +2338,3 @@\n-  \/\/ start computing from the field after _crc\n-  char* buf = (char*)&_crc + sizeof(_crc);\n-  size_t sz = _header_size - (buf - start);\n+  \/\/ start computing from the field after _crc to end of base archive name.\n+  char* buf = (char*)&(_generic_header._crc) + sizeof(_generic_header._crc);\n+  size_t sz = header_size() - (buf - start);\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":191,"deletions":114,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -187,2 +187,0 @@\n-  size_t _header_size;\n-\n@@ -206,1 +204,0 @@\n-  bool _base_archive_is_default;    \/\/ indicates if the base archive is the system default one\n@@ -213,2 +210,0 @@\n-  \/\/ size of the base archive name including NULL terminator\n-  size_t _base_archive_name_size;\n@@ -246,9 +241,14 @@\n-  \/\/ Accessors -- fields declared in CDSFileMapHeaderBase\n-  unsigned int magic()                    const { return _magic; }\n-  int crc()                               const { return _crc; }\n-  int version()                           const { return _version; }\n-\n-  void set_crc(int crc_value)                   { _crc = crc_value; }\n-  void set_version(int v)                       { _version = v; }\n-\n-  \/\/ Accessors -- fields declared in FileMapHeader\n+  \/\/ Accessors -- fields declared in GenericCDSFileMapHeader\n+  unsigned int magic()                    const { return _generic_header._magic;    }\n+  int crc()                               const { return _generic_header._crc;      }\n+  int version()                           const { return _generic_header._version;  }\n+  unsigned int header_size()              const { return _generic_header._header_size;              }\n+  unsigned int base_archive_path_offset() const { return _generic_header._base_archive_path_offset; }\n+  unsigned int base_archive_name_size()   const { return _generic_header._base_archive_name_size;   }\n+\n+  void set_magic(unsigned int m)                    { _generic_header._magic = m;       }\n+  void set_crc(int crc_value)                       { _generic_header._crc = crc_value; }\n+  void set_version(int v)                           { _generic_header._version = v;     }\n+  void set_header_size(unsigned int s)              { _generic_header._header_size = s;              }\n+  void set_base_archive_path_offset(unsigned int s) { _generic_header._base_archive_path_offset = s; }\n+  void set_base_archive_name_size(unsigned int s)   { _generic_header._base_archive_name_size = s;   }\n@@ -256,1 +256,0 @@\n-  size_t header_size()                     const { return _header_size; }\n@@ -270,1 +269,0 @@\n-  bool base_archive_is_default()           const { return _base_archive_is_default; }\n@@ -272,1 +270,0 @@\n-  size_t base_archive_name_size()          const { return _base_archive_name_size; }\n@@ -290,3 +287,0 @@\n-  void set_base_archive_name_size(size_t s)      { _base_archive_name_size = s; }\n-  void set_base_archive_is_default(bool b)       { _base_archive_is_default = b; }\n-  void set_header_size(size_t s)                 { _header_size = s; }\n@@ -296,0 +290,1 @@\n+  void copy_base_archive_name(const char* name);\n@@ -320,2 +315,2 @@\n-  void populate(FileMapInfo* info, size_t core_region_alignment);\n-\n+  void populate(FileMapInfo *info, size_t core_region_alignment, size_t header_size,\n+                size_t base_archive_name_size, size_t base_archive_path_offset);\n@@ -366,1 +361,1 @@\n-                                                int* size, char** base_archive_name);\n+                                                char** base_archive_name);\n@@ -401,3 +396,0 @@\n-  void   set_header_base_archive_name_size(size_t size)      { header()->set_base_archive_name_size(size); }\n-  void   set_header_base_archive_is_default(bool is_default) { header()->set_base_archive_is_default(is_default); }\n-\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":18,"deletions":26,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -587,1 +587,1 @@\n-  GrowableArray<Handle> _loaded_cld_handles; \/\/ keep the CLDs alive\n+  GrowableArray<OopHandle> _loaded_cld_handles; \/\/ keep the CLDs alive\n@@ -592,2 +592,2 @@\n-    for (int i = 0; i < _loaded_cld.length(); i++) {\n-      ClassLoaderData* cld = _loaded_cld.at(i);\n+    for (int i = 0; i < _loaded_cld_handles.length(); i++) {\n+      _loaded_cld_handles.at(i).release(Universe::vm_global());\n@@ -597,4 +597,3 @@\n-    if (!cld->is_unloading()) {\n-      _loaded_cld.append(cld);\n-      _loaded_cld_handles.append(Handle(_current_thread, cld->holder_phantom()));\n-    }\n+    assert(cld->is_alive(), \"must be\");\n+    _loaded_cld.append(cld);\n+    _loaded_cld_handles.append(OopHandle(Universe::vm_global(), cld->holder_phantom()));\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"classfile\/systemDictionaryShared.hpp\"\n@@ -136,2 +137,1 @@\n-  _metaspace_lock(new Mutex(Mutex::nosafepoint-2, \"MetaspaceAllocation_lock\",\n-                            Mutex::_safepoint_check_never)),\n+  _metaspace_lock(new Mutex(Mutex::nosafepoint-2, \"MetaspaceAllocation_lock\")),\n@@ -888,0 +888,2 @@\n+      \/\/ But still have to remove it from the dumptime_table.\n+      SystemDictionaryShared::handle_class_unloading(ik);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -429,15 +429,0 @@\n-\/\/ Walk classes in the loaded class dictionaries in various forms.\n-\/\/ Only walks the classes defined in this class loader.\n-void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*)) {\n-  FOR_ALL_DICTIONARY(cld) {\n-    cld->dictionary()->classes_do(f);\n-  }\n-}\n-\n-\/\/ Only walks the classes defined in this class loader.\n-void ClassLoaderDataGraph::dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS) {\n-  FOR_ALL_DICTIONARY(cld) {\n-    cld->dictionary()->classes_do(f, CHECK);\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.cpp","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -99,7 +99,0 @@\n-  \/\/ dictionary do\n-  \/\/ Iterate over all klasses in dictionary, but\n-  \/\/ just the classes from defining class loaders.\n-  static void dictionary_classes_do(void f(InstanceKlass*));\n-  \/\/ Added for initialize_itable_for_klass to handle exceptions.\n-  static void dictionary_classes_do(void f(InstanceKlass*, TRAPS), TRAPS);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataGraph.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4223,2 +4223,2 @@\n-  nmethodBucket* volatile* vmdeps_addr = (nmethodBucket* volatile*)call_site->field_addr(_vmdependencies_offset);\n-  volatile uint64_t* last_cleanup_addr = (volatile uint64_t*)call_site->field_addr(_last_cleanup_offset);\n+  nmethodBucket* volatile* vmdeps_addr = call_site->field_addr<nmethodBucket* volatile>(_vmdependencies_offset);\n+  volatile uint64_t* last_cleanup_addr = call_site->field_addr<volatile uint64_t>(_last_cleanup_offset);\n@@ -4282,1 +4282,1 @@\n-  return HeapAccess<MO_ACQUIRE>::load_at(loader, _loader_data_offset);\n+  return Atomic::load_acquire(loader->field_addr<ClassLoaderData*>(_loader_data_offset));\n@@ -4288,1 +4288,1 @@\n-  return HeapAccess<>::load_at(loader, _loader_data_offset);\n+  return *loader->field_addr<ClassLoaderData*>(_loader_data_offset);\n@@ -4294,1 +4294,1 @@\n-  HeapAccess<MO_RELEASE>::store_at(loader, _loader_data_offset, new_data);\n+  Atomic::release_store(loader->field_addr<ClassLoaderData*>(_loader_data_offset), new_data);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-  return java_string->obj_field_addr<uint8_t>(_flags_offset);\n+  return java_string->field_addr<uint8_t>(_flags_offset);\n@@ -149,1 +149,1 @@\n-  return ref->obj_field_addr<HeapWord>(_referent_offset);\n+  return ref->field_addr<HeapWord>(_referent_offset);\n@@ -165,1 +165,1 @@\n-  return ref->obj_field_addr<HeapWord>(_next_offset);\n+  return ref->field_addr<HeapWord>(_next_offset);\n@@ -181,1 +181,1 @@\n-  return ref->obj_field_addr<HeapWord>(_discovered_offset);\n+  return ref->field_addr<HeapWord>(_discovered_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -656,1 +656,6 @@\n-    nm->print_nmethod(verbose);\n+    if (verbose && st == tty) {\n+      \/\/ verbose is only ever true when called from findpc in debug.cpp\n+      nm->print_nmethod(true);\n+    } else {\n+      nm->print(st);\n+    }\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -926,1 +927,1 @@\n-      CompileTask::print(st, this, msg, \/*short_form:*\/ false);\n+      CompileTask::print(st, this, msg, \/*short_form:*\/ false, \/* cr *\/ true, \/* timestamp *\/ false);\n@@ -2531,1 +2532,1 @@\n-  print_on(tty, NULL);\n+  print_on(st, NULL);\n@@ -2882,0 +2883,3 @@\n+  \/\/ Decoding an nmethod can write to a PcDescCache (see PcDescCache::add_pc_desc)\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, Thread::current());)\n+\n@@ -2891,0 +2895,1 @@\n+    st->print_cr(\"[Disassembly]\");\n@@ -2892,0 +2897,2 @@\n+    st->bol();\n+    st->print_cr(\"[\/Disassembly]\");\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -239,1 +239,1 @@\n-                             const char* msg, bool short_form, bool cr,\n+                             const char* msg, bool short_form, bool cr, bool timestamp,\n@@ -242,2 +242,4 @@\n-    \/\/ Print current time\n-    st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n+    if (timestamp) {\n+      \/\/ Print current time\n+      st->print(\"%7d \", (int)tty->time_stamp().milliseconds());\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compileTask.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -107,1 +107,1 @@\n-    _lock = new Monitor(Mutex::nonleaf, \"CompileTask_lock\", Mutex::_safepoint_check_always);\n+    _lock = new Monitor(Mutex::safepoint, \"CompileTask_lock\");\n@@ -190,1 +190,1 @@\n-                                      const char* msg = NULL, bool short_form = false, bool cr = true,\n+                                      const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true,\n@@ -196,1 +196,1 @@\n-  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true) {\n+  static void  print(outputStream* st, const nmethod* nm, const char* msg = NULL, bool short_form = false, bool cr = true, bool timestamp = true) {\n@@ -199,1 +199,1 @@\n-                           msg, short_form, cr);\n+                           msg, short_form, cr, timestamp);\n","filename":"src\/hotspot\/share\/compiler\/compileTask.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -875,1 +875,1 @@\n-    decode((nmethod*)cb, st);\n+    ((nmethod*)cb)->decode2(st);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,0 @@\n-      _summary_bytes_used += fill_size * HeapWordSize;\n@@ -498,1 +497,0 @@\n-  _summary_bytes_used += word_size * HeapWordSize;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -226,3 +226,0 @@\n-  \/\/ The number of bytes used in the current range.\n-  size_t _summary_bytes_used;\n-\n@@ -246,1 +243,0 @@\n-    _summary_bytes_used(0),\n@@ -264,13 +260,0 @@\n-\n-  \/\/ The number of bytes allocated by this allocator.\n-  size_t used() {\n-    return _summary_bytes_used;\n-  }\n-\n-  \/\/ Clear the count of bytes allocated in prior G1 regions. This\n-  \/\/ must be done when recalculate_use is used to reset the counter\n-  \/\/ for the generic allocator, since it counts bytes in all G1\n-  \/\/ regions, including those still associated with this allocator.\n-  void clear_used() {\n-    _summary_bytes_used = 0;\n-  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Allocator.hpp","additions":0,"deletions":17,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -501,3 +501,2 @@\n-  if (_archive_allocator == NULL) {\n-    _archive_allocator = G1ArchiveAllocator::create_allocator(this, open);\n-  }\n+  assert(_archive_allocator == nullptr, \"should not be initialized\");\n+  _archive_allocator = G1ArchiveAllocator::create_allocator(this, open);\n@@ -515,1 +514,1 @@\n-  assert(_archive_allocator != NULL, \"_archive_allocator not initialized\");\n+  assert(_archive_allocator != nullptr, \"_archive_allocator not initialized\");\n@@ -517,1 +516,1 @@\n-    return NULL;\n+    return nullptr;\n@@ -525,1 +524,1 @@\n-  assert(_archive_allocator != NULL, \"_archive_allocator not initialized\");\n+  assert(_archive_allocator != nullptr, \"_archive_allocator not initialized\");\n@@ -531,1 +530,1 @@\n-  _archive_allocator = NULL;\n+  _archive_allocator = nullptr;\n@@ -1452,1 +1451,1 @@\n-  _archive_allocator(NULL),\n+  _archive_allocator(nullptr),\n@@ -1864,3 +1863,1 @@\n-  if (_archive_allocator != NULL) {\n-    result += _archive_allocator->used();\n-  }\n+  assert(_archive_allocator == nullptr, \"must be, should not contribute to used\");\n@@ -3200,3 +3197,1 @@\n-    if (_archive_allocator != NULL) {\n-      _archive_allocator->clear_used();\n-    }\n+    assert(_archive_allocator == nullptr, \"must be, should not contribute to used\");\n@@ -3396,3 +3391,1 @@\n-    if (_archive_allocator != NULL) {\n-      _archive_allocator->clear_used();\n-    }\n+    assert(_archive_allocator == nullptr, \"must be, should not contribute to used\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":10,"deletions":17,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -101,1 +101,1 @@\n-  bool in_mixed_phase() const { return !in_young_only_phase() && !_in_full_gc; }\n+  bool in_mixed_phase() const { return !_in_young_only_phase && !_in_full_gc; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectorState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -170,1 +170,1 @@\n-    _lock(Mutex::service-3, \"G1Mapper_lock\", Mutex::_safepoint_check_never) {\n+    _lock(Mutex::service-3, \"G1Mapper_lock\") {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RegionToSpaceMapper.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,3 +43,1 @@\n-    _monitor(Mutex::nosafepoint,\n-             \"G1ServiceThread_lock\",\n-             Monitor::_safepoint_check_never),\n+    _monitor(Mutex::nosafepoint, \"G1ServiceThread_lock\"),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ServiceThread.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,1 +236,1 @@\n-  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\", Mutex::_safepoint_check_never),\n+  _par_alloc_lock(Mutex::service-2, \"HeapRegionParAlloc_lock\"),\n@@ -614,2 +614,0 @@\n-          LogStream ls(log.error());\n-          to->rem_set()->print_info(&ls, p);\n@@ -620,0 +618,1 @@\n+          LogStream ls(log.error());\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegion.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  _m(Mutex::service - 1, FormatBuffer<128>(\"HeapRegionRemSet#%u_lock\", hr->hrm_index()), Monitor::_safepoint_check_never),\n+  _m(Mutex::service - 1, FormatBuffer<128>(\"HeapRegionRemSet#%u_lock\", hr->hrm_index())),\n","filename":"src\/hotspot\/share\/gc\/g1\/heapRegionRemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,2 +95,1 @@\n-  _shadow_region_monitor = new Monitor(Mutex::nosafepoint, \"CompactionManager_lock\",\n-                                       Monitor::_safepoint_check_never);\n+  _shadow_region_monitor = new Monitor(Mutex::nosafepoint, \"CompactionManager_lock\");\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-                    \"GCLogPrecious Lock\",\n-                    Mutex::_safepoint_check_never);\n+                    \"GCLogPrecious Lock\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLogPrecious.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -814,1 +814,1 @@\n-                                    int rank) {\n+                                    Mutex::Rank rank) {\n@@ -817,1 +817,1 @@\n-  return new PaddedMutex(rank, name, Mutex::_safepoint_check_never);\n+  return new PaddedMutex(rank, name);\n@@ -847,4 +847,0 @@\n-  assert(_active_mutex->_safepoint_check_required == Mutex::_safepoint_check_never,\n-         \"%s: active mutex requires never safepoint check\", _name);\n-  assert(_allocation_mutex->_safepoint_check_required == Mutex::_safepoint_check_never,\n-         \"%s: allocation mutex requires never safepoint check\", _name);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorage.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -776,2 +776,1 @@\n-  _par_alloc_lock(Mutex::nonleaf, \"OffsetTableContigSpaceParAlloc_lock\",\n-                  Mutex::_safepoint_check_always, true)\n+  _par_alloc_lock(Mutex::safepoint, \"OffsetTableContigSpaceParAlloc_lock\", true)\n","filename":"src\/hotspot\/share\/gc\/shared\/space.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  _blocker(Mutex::nosafepoint, \"TaskTerminator_lock\", Monitor::_safepoint_check_never),\n+  _blocker(Mutex::nosafepoint, \"TaskTerminator_lock\"),\n","filename":"src\/hotspot\/share\/gc\/shared\/taskTerminator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -248,2 +248,1 @@\n-  : _monitor(Mutex::nosafepoint, \"WorkGangBarrierSync_lock\",\n-             Monitor::_safepoint_check_never),\n+  : _monitor(Mutex::nosafepoint, \"WorkGangBarrierSync_lock\"),\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -53,0 +53,2 @@\n+private:\n+  const GCCause::Cause _cause;\n@@ -54,2 +56,5 @@\n-  ShenandoahBreakpointGCScope() {\n-    ShenandoahBreakpoint::at_before_gc();\n+  ShenandoahBreakpointGCScope(GCCause::Cause cause) : _cause(cause) {\n+    if (cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::start_gc();\n+      ShenandoahBreakpoint::at_before_gc();\n+    }\n@@ -59,1 +64,3 @@\n-    ShenandoahBreakpoint::at_after_gc();\n+    if (_cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::at_after_gc();\n+    }\n@@ -64,0 +71,2 @@\n+private:\n+  const GCCause::Cause _cause;\n@@ -65,2 +74,4 @@\n-  ShenandoahBreakpointMarkScope() {\n-    ShenandoahBreakpoint::at_after_marking_started();\n+  ShenandoahBreakpointMarkScope(GCCause::Cause cause) : _cause(cause) {\n+    if (_cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::at_after_marking_started();\n+    }\n@@ -70,1 +81,3 @@\n-    ShenandoahBreakpoint::at_before_marking_completed();\n+    if (_cause == GCCause::_wb_breakpoint) {\n+      ShenandoahBreakpoint::at_before_marking_completed();\n+    }\n@@ -89,4 +102,1 @@\n-  if (cause == GCCause::_wb_breakpoint) {\n-    ShenandoahBreakpoint::start_gc();\n-  }\n-  ShenandoahBreakpointGCScope breakpoint_gc_scope;\n+  ShenandoahBreakpointGCScope breakpoint_gc_scope(cause);\n@@ -101,1 +111,1 @@\n-    ShenandoahBreakpointMarkScope breakpoint_mark_scope;\n+    ShenandoahBreakpointMarkScope breakpoint_mark_scope(cause);\n@@ -660,1 +670,3 @@\n-  ShenandoahBreakpoint::at_after_reference_processing_started();\n+  if (heap->gc_cause() == GCCause::_wb_breakpoint) {\n+    ShenandoahBreakpoint::at_after_reference_processing_started();\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  _alloc_failure_waiters_lock(Mutex::nonleaf, \"ShenandoahAllocFailureGC_lock\", Monitor::_safepoint_check_always, true),\n-  _gc_waiters_lock(Mutex::nonleaf, \"ShenandoahRequestedGC_lock\", Monitor::_safepoint_check_always, true),\n+  _alloc_failure_waiters_lock(Mutex::safepoint-1, \"ShenandoahAllocFailureGC_lock\", true),\n+  _gc_waiters_lock(Mutex::safepoint-1, \"ShenandoahRequestedGC_lock\", true),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-          _wait_monitor(new Monitor(Mutex::nonleaf-1, \"ShenandoahWaitMonitor_lock\", Monitor::_safepoint_check_always, true)),\n+          _wait_monitor(new Monitor(Mutex::safepoint-1, \"ShenandoahWaitMonitor_lock\", true)),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPacer.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,3 +69,1 @@\n-    _monitor(Monitor::nosafepoint,\n-             \"ZMessagePort_lock\",\n-             Monitor::_safepoint_check_never),\n+    _monitor(Monitor::nosafepoint, \"ZMessagePort_lock\"),\n","filename":"src\/hotspot\/share\/gc\/z\/zMessagePort.inline.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-    _monitor(Monitor::nosafepoint, \"ZMetronome_lock\", Monitor::_safepoint_check_never),\n+    _monitor(Monitor::nosafepoint, \"ZMetronome_lock\"),\n","filename":"src\/hotspot\/share\/gc\/z\/zMetronome.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,2 +41,1 @@\n-#define CURRENT_CDS_ARCHIVE_VERSION 11\n-#define INVALID_CDS_ARCHIVE_VERSION -1\n+#define CURRENT_CDS_ARCHIVE_VERSION 12\n@@ -44,1 +43,1 @@\n-struct CDSFileMapRegion {\n+typedef struct CDSFileMapRegion {\n@@ -61,1 +60,1 @@\n-};\n+} CDSFileMapRegion;\n@@ -63,6 +62,21 @@\n-struct CDSFileMapHeaderBase {\n-  unsigned int _magic;           \/\/ identify file type\n-  int          _crc;             \/\/ header crc checksum\n-  int          _version;         \/\/ must be CURRENT_CDS_ARCHIVE_VERSION\n-  struct CDSFileMapRegion _space[NUM_CDS_REGIONS];\n-};\n+\/\/ This portion of the archive file header must remain unchanged for _version >= 12.\n+\/\/ This makes it possible to read important information from a CDS archive created by\n+\/\/ a different version of HotSpot, so that we can automatically regenerate the archive as necessary.\n+typedef struct GenericCDSFileMapHeader {\n+  unsigned int _magic;                    \/\/ identification of file type\n+  int          _crc;                      \/\/ header crc checksum\n+  int          _version;                  \/\/ CURRENT_CDS_ARCHIVE_VERSION of the jdk that dumped the this archive\n+  unsigned int _header_size;              \/\/ total size of the header, in bytes\n+  unsigned int _base_archive_path_offset; \/\/ offset where the base archive name is stored\n+                                          \/\/   static archive:  0\n+                                          \/\/   dynamic archive:\n+                                          \/\/     0 for default base archive\n+                                          \/\/     non-zero for non-default base archive\n+                                          \/\/       (char*)this + _base_archive_path_offset\n+                                          \/\/       points to a 0-terminated string for the base archive name\n+  unsigned int _base_archive_name_size;   \/\/ size of base archive name including ending '\\0'\n+                                          \/\/   static:  0\n+                                          \/\/   dynamic:\n+                                          \/\/     0 for default base archive\n+                                          \/\/     non-zero for non-default base archive\n+} GenericCDSFileMapHeader;\n@@ -70,1 +84,8 @@\n-typedef struct CDSFileMapHeaderBase CDSFileMapHeaderBase;\n+\/\/ This type is used by the Serviceability Agent to access the contents of\n+\/\/ a memory-mapped CDS archive.\n+typedef struct CDSFileMapHeaderBase {\n+  \/\/ We cannot inherit from GenericCDSFileMapHeader as this type may be used\n+  \/\/ by both C and C++ code.\n+  GenericCDSFileMapHeader _generic_header;\n+  CDSFileMapRegion _space[NUM_CDS_REGIONS];\n+} CDSFileMapHeaderBase;\n","filename":"src\/hotspot\/share\/include\/cds.h","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-      return HeapAccess<>::load_at(base, className::_##name##_offset);                                                    \\\n+      return *base->field_addr<jtypename>(className::_##name##_offset);                                                   \\\n@@ -240,1 +240,1 @@\n-      HeapAccess<>::store_at(base, _##name##_offset, x);                                                                  \\\n+      *base->field_addr<jtypename>(className::_##name##_offset) = x;                                                      \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -248,1 +248,1 @@\n-      _mutex(Mutex::nosafepoint, \"ParHeapInspectTask_lock\", Mutex::_safepoint_check_never) {}\n+      _mutex(Mutex::nosafepoint, \"ParHeapInspectTask_lock\") {}\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-  Mutex* lock = new Mutex(Monitor::nosafepoint, \"MetaspaceTestArea_lock\", Monitor::_safepoint_check_never);\n+  Mutex* lock = new Mutex(Monitor::nosafepoint, \"MetaspaceTestArea_lock\");\n","filename":"src\/hotspot\/share\/memory\/metaspace\/testHelpers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -526,0 +526,1 @@\n+static void reinitialize_itables() {\n@@ -527,4 +528,8 @@\n-static void initialize_itable_for_klass(InstanceKlass* k) {\n-  k->itable().initialize_itable();\n-}\n-\n+  class ReinitTableClosure : public KlassClosure {\n+   public:\n+    void do_klass(Klass* k) {\n+      if (k->is_instance_klass()) {\n+         InstanceKlass::cast(k)->itable().initialize_itable();\n+      }\n+    }\n+  };\n@@ -532,1 +537,0 @@\n-static void reinitialize_itables() {\n@@ -534,1 +538,2 @@\n-  ClassLoaderDataGraph::dictionary_classes_do(initialize_itable_for_klass);\n+  ReinitTableClosure cl;\n+  ClassLoaderDataGraph::classes_do(&cl);\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  T* p         = (T*)obj->obj_field_addr<T>(map->offset());\n+  T* p         = obj->field_addr<T>(map->offset());\n@@ -97,1 +97,1 @@\n-  T* const start = (T*)obj->obj_field_addr<T>(map->offset());\n+  T* const start = obj->field_addr<T>(map->offset());\n@@ -108,1 +108,1 @@\n-  T* p   = (T*)obj->obj_field_addr<T>(map->offset());\n+  T* p   = obj->field_addr<T>(map->offset());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1210,1 +1210,1 @@\n-    _extra_data_lock(Mutex::nonleaf-2, \"MDOExtraData_lock\", Mutex::_safepoint_check_always),\n+    _extra_data_lock(Mutex::safepoint-2, \"MDOExtraData_lock\"),\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,2 +182,2 @@\n-address oopDesc::address_field(int offset) const                      { return HeapAccess<>::load_at(as_oop(), offset); }\n-address oopDesc::address_field_acquire(int offset) const              { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n+address oopDesc::address_field(int offset) const                      { return *field_addr<address>(offset); }\n+address oopDesc::address_field_acquire(int offset) const              { return Atomic::load_acquire(field_addr<address>(offset)); }\n@@ -185,2 +185,2 @@\n-void oopDesc::address_field_put(int offset, address value)            { HeapAccess<>::store_at(as_oop(), offset, value); }\n-void oopDesc::release_address_field_put(int offset, address value)    { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+void oopDesc::address_field_put(int offset, address value)            { *field_addr<address>(offset) = value; }\n+void oopDesc::release_address_field_put(int offset, address value)    { Atomic::release_store(field_addr<address>(offset), value); }\n@@ -188,2 +188,2 @@\n-Metadata* oopDesc::metadata_field(int offset) const                   { return HeapAccess<>::load_at(as_oop(), offset); }\n-void oopDesc::metadata_field_put(int offset, Metadata* value)         { HeapAccess<>::store_at(as_oop(), offset, value); }\n+Metadata* oopDesc::metadata_field(int offset) const                   { return *field_addr<Metadata*>(offset); }\n+void oopDesc::metadata_field_put(int offset, Metadata* value)         { *field_addr<Metadata*>(offset) = value; }\n@@ -191,2 +191,2 @@\n-Metadata* oopDesc::metadata_field_acquire(int offset) const           { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_metadata_field_put(int offset, Metadata* value) { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+Metadata* oopDesc::metadata_field_acquire(int offset) const           { return Atomic::load_acquire(field_addr<Metadata*>(offset)); }\n+void oopDesc::release_metadata_field_put(int offset, Metadata* value) { Atomic::release_store(field_addr<Metadata*>(offset), value); }\n@@ -194,2 +194,2 @@\n-jbyte oopDesc::byte_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_byte_field_put(int offset, jbyte value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jbyte oopDesc::byte_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jbyte>(offset)); }\n+void oopDesc::release_byte_field_put(int offset, jbyte value)         { Atomic::release_store(field_addr<jbyte>(offset), value); }\n@@ -197,2 +197,2 @@\n-jchar oopDesc::char_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_char_field_put(int offset, jchar value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jchar oopDesc::char_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jchar>(offset)); }\n+void oopDesc::release_char_field_put(int offset, jchar value)         { Atomic::release_store(field_addr<jchar>(offset), value); }\n@@ -200,2 +200,2 @@\n-jboolean oopDesc::bool_field_acquire(int offset) const                { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_bool_field_put(int offset, jboolean value)      { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, jboolean(value & 1)); }\n+jboolean oopDesc::bool_field_acquire(int offset) const                { return Atomic::load_acquire(field_addr<jboolean>(offset)); }\n+void oopDesc::release_bool_field_put(int offset, jboolean value)      { Atomic::release_store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n@@ -203,2 +203,2 @@\n-jint oopDesc::int_field_acquire(int offset) const                     { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_int_field_put(int offset, jint value)           { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jint oopDesc::int_field_acquire(int offset) const                     { return Atomic::load_acquire(field_addr<jint>(offset)); }\n+void oopDesc::release_int_field_put(int offset, jint value)           { Atomic::release_store(field_addr<jint>(offset), value); }\n@@ -206,2 +206,2 @@\n-jshort oopDesc::short_field_acquire(int offset) const                 { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_short_field_put(int offset, jshort value)       { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jshort oopDesc::short_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jshort>(offset)); }\n+void oopDesc::release_short_field_put(int offset, jshort value)       { Atomic::release_store(field_addr<jshort>(offset), value); }\n@@ -209,2 +209,2 @@\n-jlong oopDesc::long_field_acquire(int offset) const                   { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_long_field_put(int offset, jlong value)         { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jlong oopDesc::long_field_acquire(int offset) const                   { return Atomic::load_acquire(field_addr<jlong>(offset)); }\n+void oopDesc::release_long_field_put(int offset, jlong value)         { Atomic::release_store(field_addr<jlong>(offset), value); }\n@@ -212,2 +212,2 @@\n-jfloat oopDesc::float_field_acquire(int offset) const                 { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_float_field_put(int offset, jfloat value)       { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jfloat oopDesc::float_field_acquire(int offset) const                 { return Atomic::load_acquire(field_addr<jfloat>(offset)); }\n+void oopDesc::release_float_field_put(int offset, jfloat value)       { Atomic::release_store(field_addr<jfloat>(offset), value); }\n@@ -215,2 +215,2 @@\n-jdouble oopDesc::double_field_acquire(int offset) const               { return HeapAccess<MO_ACQUIRE>::load_at(as_oop(), offset); }\n-void oopDesc::release_double_field_put(int offset, jdouble value)     { HeapAccess<MO_RELEASE>::store_at(as_oop(), offset, value); }\n+jdouble oopDesc::double_field_acquire(int offset) const               { return Atomic::load_acquire(field_addr<jdouble>(offset)); }\n+void oopDesc::release_double_field_put(int offset, jdouble value)     { Atomic::release_store(field_addr<jdouble>(offset), value); }\n","filename":"src\/hotspot\/share\/oops\/oop.cpp","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -127,5 +127,2 @@\n-  \/\/ field addresses in oop\n-  inline void* field_addr(int offset) const;\n-\n-  \/\/ Need this as public for garbage collection.\n-  template <class T> inline T* obj_field_addr(int offset) const;\n+  template<typename T>\n+  inline T* field_addr(int offset) const;\n","filename":"src\/hotspot\/share\/oops\/oop.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -211,4 +211,2 @@\n-void*    oopDesc::field_addr(int offset)     const { return reinterpret_cast<void*>(cast_from_oop<intptr_t>(as_oop()) + offset); }\n-\n-template <class T>\n-T*       oopDesc::obj_field_addr(int offset) const { return (T*) field_addr(offset); }\n+template<typename T>\n+T*       oopDesc::field_addr(int offset)     const { return reinterpret_cast<T*>(cast_from_oop<intptr_t>(as_oop()) + offset); }\n@@ -225,2 +223,2 @@\n-inline jbyte oopDesc::byte_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void  oopDesc::byte_field_put(int offset, jbyte value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jbyte oopDesc::byte_field(int offset) const                  { return *field_addr<jbyte>(offset);  }\n+inline void  oopDesc::byte_field_put(int offset, jbyte value)       { *field_addr<jbyte>(offset) = value; }\n@@ -228,2 +226,2 @@\n-inline jchar oopDesc::char_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void  oopDesc::char_field_put(int offset, jchar value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jchar oopDesc::char_field(int offset) const                  { return *field_addr<jchar>(offset);  }\n+inline void  oopDesc::char_field_put(int offset, jchar value)       { *field_addr<jchar>(offset) = value; }\n@@ -231,6 +229,6 @@\n-inline jboolean oopDesc::bool_field(int offset) const               { return HeapAccess<>::load_at(as_oop(), offset); }\n-inline void     oopDesc::bool_field_put(int offset, jboolean value) { HeapAccess<>::store_at(as_oop(), offset, jboolean(value & 1)); }\n-inline jboolean oopDesc::bool_field_volatile(int offset) const      { return HeapAccess<MO_SEQ_CST>::load_at(as_oop(), offset); }\n-inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { HeapAccess<MO_SEQ_CST>::store_at(as_oop(), offset, jboolean(value & 1)); }\n-inline jshort oopDesc::short_field(int offset) const                { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void   oopDesc::short_field_put(int offset, jshort value)    { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jboolean oopDesc::bool_field(int offset) const               { return *field_addr<jboolean>(offset); }\n+inline void     oopDesc::bool_field_put(int offset, jboolean value) { *field_addr<jboolean>(offset) = jboolean(value & 1); }\n+inline jboolean oopDesc::bool_field_volatile(int offset) const      { return RawAccess<MO_SEQ_CST>::load(field_addr<jboolean>(offset)); }\n+inline void     oopDesc::bool_field_put_volatile(int offset, jboolean value) { RawAccess<MO_SEQ_CST>::store(field_addr<jboolean>(offset), jboolean(value & 1)); }\n+inline jshort oopDesc::short_field(int offset) const                { return *field_addr<jshort>(offset);   }\n+inline void   oopDesc::short_field_put(int offset, jshort value)    { *field_addr<jshort>(offset) = value;  }\n@@ -238,2 +236,2 @@\n-inline jint oopDesc::int_field(int offset) const                    { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void oopDesc::int_field_put(int offset, jint value)          { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jint oopDesc::int_field(int offset) const                    { return *field_addr<jint>(offset);     }\n+inline void oopDesc::int_field_put(int offset, jint value)          { *field_addr<jint>(offset) = value;    }\n@@ -241,2 +239,2 @@\n-inline jlong oopDesc::long_field(int offset) const                  { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void  oopDesc::long_field_put(int offset, jlong value)       { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jlong oopDesc::long_field(int offset) const                  { return *field_addr<jlong>(offset);    }\n+inline void  oopDesc::long_field_put(int offset, jlong value)       { *field_addr<jlong>(offset) = value;   }\n@@ -244,2 +242,2 @@\n-inline jfloat oopDesc::float_field(int offset) const                { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void   oopDesc::float_field_put(int offset, jfloat value)    { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jfloat oopDesc::float_field(int offset) const                { return *field_addr<jfloat>(offset);   }\n+inline void   oopDesc::float_field_put(int offset, jfloat value)    { *field_addr<jfloat>(offset) = value;  }\n@@ -247,2 +245,2 @@\n-inline jdouble oopDesc::double_field(int offset) const              { return HeapAccess<>::load_at(as_oop(), offset);  }\n-inline void    oopDesc::double_field_put(int offset, jdouble value) { HeapAccess<>::store_at(as_oop(), offset, value); }\n+inline jdouble oopDesc::double_field(int offset) const              { return *field_addr<jdouble>(offset);  }\n+inline void    oopDesc::double_field_put(int offset, jdouble value) { *field_addr<jdouble>(offset) = value; }\n","filename":"src\/hotspot\/share\/oops\/oop.inline.hpp","additions":20,"deletions":22,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -93,3 +93,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *byte_at_addr(which);\n@@ -98,3 +96,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *byte_at_addr(which) = contents;\n@@ -104,3 +100,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jboolean>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *bool_at_addr(which);\n@@ -109,3 +103,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jboolean>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, jboolean(contents & 1));\n+  *bool_at_addr(which) = jboolean(contents & 1);\n@@ -115,3 +107,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jchar>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *char_at_addr(which);\n@@ -120,3 +110,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jchar>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *char_at_addr(which) = contents;\n@@ -126,3 +114,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *int_at_addr(which);\n@@ -131,3 +117,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *int_at_addr(which) = contents;\n@@ -137,3 +121,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jshort>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *short_at_addr(which);\n@@ -142,3 +124,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jshort>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *short_at_addr(which) = contents;\n@@ -148,3 +128,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jushort>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *ushort_at_addr(which);\n@@ -152,0 +130,1 @@\n+\n@@ -153,3 +132,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jushort>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *ushort_at_addr(which) = contents;\n@@ -159,3 +136,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *long_at_addr(which);\n@@ -164,3 +139,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *long_at_addr(which) = contents;\n@@ -170,3 +143,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jfloat>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *float_at_addr(which);\n@@ -174,0 +145,1 @@\n+\n@@ -175,3 +147,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jfloat>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *float_at_addr(which) = contents;\n@@ -181,3 +151,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jdouble>(which);\n-  return HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *double_at_addr(which);\n@@ -185,0 +153,1 @@\n+\n@@ -186,3 +155,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jdouble>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  *double_at_addr(which) = contents;\n@@ -192,3 +159,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  return HeapAccess<MO_ACQUIRE | IS_ARRAY>::load_at(as_oop(), offset);\n+  return Atomic::load_acquire(byte_at_addr(which));\n@@ -197,3 +162,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jbyte>(which);\n-  HeapAccess<MO_RELEASE | IS_ARRAY>::store_at(as_oop(), offset, contents);\n+  Atomic::release_store(byte_at_addr(which), contents);\n@@ -207,3 +170,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  return (Symbol*)(jlong) HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *reinterpret_cast<Symbol**>(long_at_addr(which));\n@@ -211,0 +172,1 @@\n+\n@@ -212,3 +174,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jlong>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, (jlong)contents);\n+  *reinterpret_cast<Symbol**>(long_at_addr(which)) = contents;\n@@ -218,3 +178,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  return (Symbol*)(jint) HeapAccess<IS_ARRAY>::load_at(as_oop(), offset);\n+  return *reinterpret_cast<Symbol**>(int_at_addr(which));\n@@ -223,3 +181,1 @@\n-  assert(is_within_bounds(which), \"index %d out of bounds %d\", which, length());\n-  ptrdiff_t offset = element_offset<jint>(which);\n-  HeapAccess<IS_ARRAY>::store_at(as_oop(), offset, (jint)contents);\n+  *reinterpret_cast<Symbol**>(int_at_addr(which)) = contents;\n","filename":"src\/hotspot\/share\/oops\/typeArrayOop.inline.hpp","additions":28,"deletions":72,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -552,0 +552,1 @@\n+                  _ilt(NULL),\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1635,0 +1635,2 @@\n+\n+  bool safe_for_if_replacement(const Node* dom) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1395,1 +1395,2 @@\n-        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom) {\n+        if (dom->req() > 1 && dom->in(1) == bol && prevdom->in(0) == dom &&\n+            safe_for_if_replacement(dom)) {\n@@ -1433,0 +1434,19 @@\n+bool PhaseIdealLoop::safe_for_if_replacement(const Node* dom) const {\n+  if (!dom->is_CountedLoopEnd()) {\n+    return true;\n+  }\n+  CountedLoopEndNode* le = dom->as_CountedLoopEnd();\n+  CountedLoopNode* cl = le->loopnode();\n+  if (cl == NULL) {\n+    return true;\n+  }\n+  if (!cl->is_main_loop()) {\n+    return true;\n+  }\n+  if (cl->is_canonical_loop_entry() == NULL) {\n+    return true;\n+  }\n+  \/\/ Further unrolling is possible so loop exit condition might change\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2964,1 +2964,1 @@\n-      JavaThread::send_async_exception(java_thread, java_throwable);\n+      JavaThread::send_async_exception(receiver, java_throwable);\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-  JavaThread::send_async_exception(java_thread->threadObj(), e);\n+  JavaThread::send_async_exception(java_thread, e);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  _lock(Mutex::nosafepoint, \"JvmtiTagMap_lock\", Mutex::_safepoint_check_never),\n+  _lock(Mutex::nosafepoint, \"JvmtiTagMap_lock\"),\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-      assert(p->field_addr((jint)byte_offset) == ptr_plus_disp,\n+      assert(p->field_addr<void>((jint)byte_offset) == ptr_plus_disp,\n@@ -221,8 +221,2 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      T ret = RawAccess<>::load(addr());\n-      return normalize_for_read(ret);\n-    } else {\n-      T ret = HeapAccess<>::load_at(_obj, _offset);\n-      return normalize_for_read(ret);\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    return normalize_for_read(*addr());\n@@ -232,6 +226,2 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      RawAccess<>::store(addr(), normalize_for_write(x));\n-    } else {\n-      HeapAccess<>::store_at(_obj, _offset, normalize_for_write(x));\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    *addr() = normalize_for_write(x);\n@@ -242,8 +232,3 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      volatile T ret = RawAccess<MO_SEQ_CST>::load(addr());\n-      return normalize_for_read(ret);\n-    } else {\n-      T ret = HeapAccess<MO_SEQ_CST>::load_at(_obj, _offset);\n-      return normalize_for_read(ret);\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    volatile T ret = RawAccess<MO_SEQ_CST>::load(addr());\n+    return normalize_for_read(ret);\n@@ -253,6 +238,2 @@\n-    if (_obj == NULL) {\n-      GuardUnsafeAccess guard(_thread);\n-      RawAccess<MO_SEQ_CST>::store(addr(), normalize_for_write(x));\n-    } else {\n-      HeapAccess<MO_SEQ_CST>::store_at(_obj, _offset, normalize_for_write(x));\n-    }\n+    GuardUnsafeAccess guard(_thread);\n+    RawAccess<MO_SEQ_CST>::store(addr(), normalize_for_write(x));\n@@ -748,7 +729,2 @@\n-  if (p == NULL) {\n-    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x);\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);\n-  }\n+  volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x);\n@@ -759,7 +735,2 @@\n-  if (p == NULL) {\n-    volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x);\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x);\n-  }\n+  volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x);\n@@ -779,7 +750,2 @@\n-  if (p == NULL) {\n-    volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x) == e;\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;\n-  }\n+  volatile jint* addr = (volatile jint*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x) == e;\n@@ -790,7 +756,2 @@\n-  if (p == NULL) {\n-    volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n-    return RawAccess<>::atomic_cmpxchg(addr, e, x) == e;\n-  } else {\n-    assert_field_offset_sane(p, offset);\n-    return HeapAccess<>::atomic_cmpxchg_at(p, (ptrdiff_t)offset, e, x) == e;\n-  }\n+  volatile jlong* addr = (volatile jlong*)index_oop_from_field_offset_long(p, offset);\n+  return Atomic::cmpxchg(addr, e, x) == e;\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":18,"deletions":57,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -3534,1 +3534,0 @@\n-        int name_size;\n@@ -3536,1 +3535,1 @@\n-          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &name_size, &SharedArchivePath);\n+          FileMapInfo::get_base_archive_name_from_header(temp_archive_path, &SharedArchivePath);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"utilities\/vmError.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagLimit.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1339,0 +1339,4 @@\n+  product(int, ErrorLogPrintCodeLimit, 3, DIAGNOSTIC,                       \\\n+          \"max number of compiled code units to print in error log\")        \\\n+          range(0, VMError::max_error_log_print_code)                       \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-  _lock(Monitor::nosafepoint, \"HandshakeState_lock\", Monitor::_safepoint_check_never),\n+  _lock(Monitor::nosafepoint, \"HandshakeState_lock\"),\n","filename":"src\/hotspot\/share\/runtime\/handshake.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"memory\/resourceArea.hpp\"\n@@ -65,5 +66,5 @@\n-  \/\/ If the JavaThread checks for safepoint, verify that the lock wasn't created with safepoint_check_never.\n-  if (thread->is_active_Java_thread()) {\n-    assert(_safepoint_check_required != _safepoint_check_never,\n-           \"This lock should never have a safepoint check for Java threads: %s\",\n-           name());\n+  \/\/ If the lock acquisition checks for safepoint, verify that the lock was created with rank that\n+  \/\/ has safepoint checks. Technically this doesn't affect NonJavaThreads since they won't actually\n+  \/\/ check for safepoint, but let's make the rule unconditional unless there's a good reason not to.\n+  assert(_rank > nosafepoint,\n+         \"This lock should not be taken with a safepoint check: %s\", name());\n@@ -71,0 +72,1 @@\n+  if (thread->is_active_Java_thread()) {\n@@ -73,4 +75,0 @@\n-  } else {\n-    \/\/ If initialized with safepoint_check_never, a NonJavaThread should never ask to safepoint check either.\n-    assert(_safepoint_check_required != _safepoint_check_never,\n-           \"NonJavaThread should not check for safepoint\");\n@@ -82,1 +80,1 @@\n-  assert(!thread->is_active_Java_thread() || _safepoint_check_required != _safepoint_check_always,\n+  assert(!thread->is_active_Java_thread() || _rank <= nosafepoint,\n@@ -170,1 +168,1 @@\n-  \/\/ Some safepoint_check_always locks use try_lock, so cannot check\n+  \/\/ Some safepoint checking locks use try_lock, so cannot check\n@@ -277,2 +275,1 @@\n-Mutex::Mutex(int Rank, const char * name, SafepointCheckRequired safepoint_check_required,\n-             bool allow_vm_block) : _owner(NULL) {\n+Mutex::Mutex(Rank rank, const char * name, bool allow_vm_block) : _owner(NULL) {\n@@ -284,2 +281,1 @@\n-  _rank            = Rank;\n-  _safepoint_check_required = safepoint_check_required;\n+  _rank            = rank;\n@@ -288,7 +284,1 @@\n-  assert(_rank >= 0 && _rank <= nonleaf, \"Bad lock rank %d: %s\", _rank, name);\n-\n-  assert(_rank > nosafepoint || _safepoint_check_required == _safepoint_check_never,\n-         \"Locks below nosafepoint rank should never safepoint: %s\", name);\n-\n-  assert(_rank <= nosafepoint || _safepoint_check_required == _safepoint_check_always,\n-         \"Locks above nosafepoint rank should safepoint: %s\", name);\n+  assert(_rank >= static_cast<Rank>(0) && _rank <= safepoint, \"Bad lock rank %s: %s\", rank_name(), name);\n@@ -298,2 +288,2 @@\n-  assert(_safepoint_check_required == _safepoint_check_always || _allow_vm_block,\n-         \"Safepoint check never locks should always allow the vm to block: %s\", name);\n+  assert(_rank > nosafepoint || _allow_vm_block,\n+         \"Locks that don't check for safepoint should always allow the vm to block: %s\", name);\n@@ -315,0 +305,24 @@\n+\/\/\n+#ifdef ASSERT\n+static Mutex::Rank _ranks[] = { Mutex::event, Mutex::service, Mutex::stackwatermark, Mutex::tty, Mutex::oopstorage,\n+                                Mutex::nosafepoint, Mutex::safepoint };\n+\n+static const char* _rank_names[] = { \"event\", \"service\", \"stackwatermark\", \"tty\", \"oopstorage\",\n+                                     \"nosafepoint\", \"safepoint\" };\n+\n+static const int _num_ranks = 7;\n+\n+static const char* rank_name_internal(Mutex::Rank r) {\n+  \/\/ Find closest rank and print out the name\n+  stringStream st;\n+  for (int i = 0; i < _num_ranks; i++) {\n+    if (r == _ranks[i]) {\n+      return _rank_names[i];\n+    } else if (r  > _ranks[i] && (i < _num_ranks-1 && r < _ranks[i+1])) {\n+      int delta = static_cast<int>(_ranks[i+1]) - static_cast<int>(r);\n+      st.print(\"%s-%d\", _rank_names[i+1], delta);\n+      return st.as_string();\n+    }\n+  }\n+  return \"fail\";\n+}\n@@ -316,6 +330,14 @@\n-#ifndef PRODUCT\n-const char* print_safepoint_check(Mutex::SafepointCheckRequired safepoint_check) {\n-  switch (safepoint_check) {\n-  case Mutex::_safepoint_check_never:     return \"safepoint_check_never\";\n-  case Mutex::_safepoint_check_always:    return \"safepoint_check_always\";\n-  default: return \"\";\n+const char* Mutex::rank_name() const {\n+  return rank_name_internal(_rank);\n+}\n+\n+\n+void Mutex::assert_no_overlap(Rank orig, Rank adjusted, int adjust) {\n+  int i = 0;\n+  while (_ranks[i] < orig) i++;\n+  \/\/ underflow is caught in constructor\n+  if (i != 0 && adjusted > event && adjusted <= _ranks[i-1]) {\n+    ResourceMark rm;\n+    assert(adjusted > _ranks[i-1],\n+           \"Rank %s-%d overlaps with %s\",\n+           rank_name_internal(orig), adjust, rank_name_internal(adjusted));\n@@ -324,0 +346,1 @@\n+#endif \/\/ ASSERT\n@@ -325,0 +348,1 @@\n+#ifndef PRODUCT\n@@ -331,1 +355,1 @@\n-  st->print(\" %s\", print_safepoint_check(_safepoint_check_required));\n+  DEBUG_ONLY(st->print(\" %s\", rank_name()));\n@@ -395,2 +419,3 @@\n-      assert(false, \"Attempting to wait on monitor %s\/%d while holding lock %s\/%d -- \"\n-             \"possible deadlock. %s\", name(), rank(), least->name(), least->rank(),\n+      ResourceMark rm(thread);\n+      assert(false, \"Attempting to wait on monitor %s\/%s while holding lock %s\/%s -- \"\n+             \"possible deadlock. %s\", name(), rank_name(), least->name(), least->rank_name(),\n@@ -412,0 +437,1 @@\n+      ResourceMark rm(thread);\n@@ -418,2 +444,2 @@\n-      assert(false, \"Attempting to acquire lock %s\/%d out of order with lock %s\/%d -- \"\n-             \"possible deadlock\", this->name(), this->rank(), least->name(), least->rank());\n+      assert(false, \"Attempting to acquire lock %s\/%s out of order with lock %s\/%s -- \"\n+             \"possible deadlock\", this->name(), this->rank_name(), least->name(), least->rank_name());\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":61,"deletions":35,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-  enum Rank {\n+  enum class Rank {\n@@ -56,2 +56,1 @@\n-       nonleaf        = nosafepoint    +  20,\n-       max_nonleaf    = nonleaf\n+       safepoint      = nosafepoint    +  20\n@@ -60,0 +59,25 @@\n+  \/\/ want C++later \"using enum\" directives.\n+  static const Rank event          = Rank::event;\n+  static const Rank service        = Rank::service;\n+  static const Rank stackwatermark = Rank::stackwatermark;\n+  static const Rank tty            = Rank::tty;\n+  static const Rank oopstorage     = Rank::oopstorage;\n+  static const Rank nosafepoint    = Rank::nosafepoint;\n+  static const Rank safepoint      = Rank::safepoint;\n+\n+  static void assert_no_overlap(Rank orig, Rank adjusted, int adjust);\n+\n+  friend Rank operator-(Rank base, int adjust) {\n+    Rank result = static_cast<Rank>(static_cast<int>(base) - adjust);\n+    DEBUG_ONLY(assert_no_overlap(base, result, adjust));\n+    return result;\n+  }\n+\n+  friend constexpr bool operator<(Rank lhs, Rank rhs) {\n+    return static_cast<int>(lhs) < static_cast<int>(rhs);\n+  }\n+\n+  friend constexpr bool operator>(Rank lhs, Rank rhs)  { return rhs < lhs; }\n+  friend constexpr bool operator<=(Rank lhs, Rank rhs) { return !(lhs > rhs); }\n+  friend constexpr bool operator>=(Rank lhs, Rank rhs) { return !(lhs < rhs); }\n+\n@@ -76,1 +100,1 @@\n-  int     _rank;                 \/\/ rank (to avoid\/detect potential deadlocks)\n+  Rank    _rank;                 \/\/ rank (to avoid\/detect potential deadlocks)\n@@ -90,1 +114,2 @@\n-  int    rank() const          { return _rank; }\n+  Rank   rank() const          { return _rank; }\n+  const char*  rank_name() const;\n@@ -110,1 +135,1 @@\n-  \/\/ Java and NonJavaThreads. When the lock is initialized with _safepoint_check_always,\n+  \/\/ Java and NonJavaThreads. When the lock is initialized with rank > nosafepoint,\n@@ -113,1 +138,1 @@\n-  \/\/ _safepoint_check_never, that means that whenever the lock is acquired by a JavaThread\n+  \/\/ rank <= nosafepoint, that means that whenever the lock is acquired by a JavaThread\n@@ -131,14 +156,0 @@\n-  enum class SafepointCheckRequired {\n-    _safepoint_check_never,       \/\/ Mutexes with this value will cause errors\n-                                  \/\/ when acquired by a JavaThread with a safepoint check.\n-    _safepoint_check_always       \/\/ Mutexes with this value will cause errors\n-                                  \/\/ when acquired by a JavaThread without a safepoint check.\n-  };\n-  \/\/ Bring the enumerator names into class scope.\n-  static const SafepointCheckRequired _safepoint_check_never =\n-    SafepointCheckRequired::_safepoint_check_never;\n-  static const SafepointCheckRequired _safepoint_check_always =\n-    SafepointCheckRequired::_safepoint_check_always;\n-\n-  NOT_PRODUCT(SafepointCheckRequired _safepoint_check_required;)\n-\n@@ -146,1 +157,1 @@\n-  Mutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block);\n+  Mutex(Rank rank, const char *name, bool allow_vm_block);\n@@ -148,3 +159,2 @@\n-  Mutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n-    Mutex(rank, name, safepoint_check_required,\n-          safepoint_check_required == _safepoint_check_never ? true : false) {}\n+  Mutex(Rank rank, const char *name) :\n+    Mutex(rank, name, rank > nosafepoint ? false : true) {}\n@@ -191,2 +201,2 @@\n-  Monitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block)  :\n-    Mutex(rank, name, safepoint_check_required, allow_vm_block) {}\n+  Monitor(Rank rank, const char *name, bool allow_vm_block)  :\n+    Mutex(rank, name, allow_vm_block) {}\n@@ -194,2 +204,2 @@\n-  Monitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n-    Mutex(rank, name, safepoint_check_required) {}\n+  Monitor(Rank rank, const char *name) :\n+    Mutex(rank, name) {}\n@@ -215,4 +225,2 @@\n-  PaddedMutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block) :\n-    Mutex(rank, name, safepoint_check_required, allow_vm_block) {};\n-  PaddedMutex(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n-    Mutex(rank, name, safepoint_check_required) {};\n+  PaddedMutex(Rank rank, const char *name, bool allow_vm_block) : Mutex(rank, name, allow_vm_block) {};\n+  PaddedMutex(Rank rank, const char *name) : Mutex(rank, name) {};\n@@ -228,4 +236,2 @@\n-  PaddedMonitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required, bool allow_vm_block) :\n-    Monitor(rank, name, safepoint_check_required, allow_vm_block) {};\n-  PaddedMonitor(int rank, const char *name, SafepointCheckRequired safepoint_check_required) :\n-    Monitor(rank, name, safepoint_check_required) {};\n+  PaddedMonitor(Rank rank, const char *name, bool allow_vm_block) : Monitor(rank, name, allow_vm_block) {};\n+  PaddedMonitor(Rank rank, const char *name) : Monitor(rank, name) {};\n","filename":"src\/hotspot\/share\/runtime\/mutex.hpp","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -202,3 +202,3 @@\n-#define def(var, type, pri, vm_block, safepoint_check_allowed ) {             \\\n-  var = new type(Mutex::pri, #var, Mutex::safepoint_check_allowed, vm_block); \\\n-  add_mutex(var);                                                             \\\n+#define def(var, type, pri, vm_block) {       \\\n+  var = new type(Mutex::pri, #var, vm_block); \\\n+  add_mutex(var);                             \\\n@@ -209,3 +209,3 @@\n-#define defl(var, type, held_lock, vm_block, safepoint_check_allowed) {                \\\n-  var = new type(held_lock->rank()-1, #var, Mutex::safepoint_check_allowed, vm_block); \\\n-  add_mutex(var); \\\n+#define defl(var, type, held_lock, vm_block) {         \\\n+  var = new type(held_lock->rank()-1, #var, vm_block); \\\n+  add_mutex(var);                                      \\\n@@ -214,3 +214,3 @@\n-#define defl(var, type, held_lock, vm_block, safepoint_check_allowed) {           \\\n-  var = new type(Mutex::nonleaf, #var, Mutex::safepoint_check_allowed, vm_block); \\\n-  add_mutex(var); \\\n+#define defl(var, type, held_lock, vm_block) {         \\\n+  var = new type(Mutex::safepoint, #var, vm_block);    \\\n+  add_mutex(var);                                      \\\n@@ -222,1 +222,1 @@\n-  def(tty_lock                     , PaddedMutex  , tty,         true,  _safepoint_check_never);      \/\/ allow to lock in VM\n+  def(tty_lock                     , PaddedMutex  , tty,            true);      \/\/ allow to lock in VM\n@@ -224,1 +224,1 @@\n-  def(STS_lock                     , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n+  def(STS_lock                     , PaddedMonitor, nosafepoint,    true);\n@@ -227,1 +227,1 @@\n-    def(CGC_lock                   , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n+    def(CGC_lock                   , PaddedMonitor, nosafepoint,    true);\n@@ -229,1 +229,1 @@\n-    def(G1DetachedRefinementStats_lock, PaddedMutex, nosafepoint-2, true, _safepoint_check_never);\n+    def(G1DetachedRefinementStats_lock, PaddedMutex, nosafepoint-2, true);\n@@ -231,4 +231,4 @@\n-    def(FreeList_lock              , PaddedMutex  , service-1,   true,  _safepoint_check_never);\n-    def(OldSets_lock               , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-    def(Uncommit_lock              , PaddedMutex  , service-2,   true,  _safepoint_check_never);\n-    def(RootRegionScan_lock        , PaddedMonitor, nosafepoint-1, true,  _safepoint_check_never);\n+    def(FreeList_lock              , PaddedMutex  , service-1,      true);\n+    def(OldSets_lock               , PaddedMutex  , nosafepoint,    true);\n+    def(Uncommit_lock              , PaddedMutex  , service-2,      true);\n+    def(RootRegionScan_lock        , PaddedMonitor, nosafepoint-1,  true);\n@@ -236,2 +236,2 @@\n-    def(MarkStackFreeList_lock     , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-    def(MarkStackChunkList_lock    , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n+    def(MarkStackFreeList_lock     , PaddedMutex  , nosafepoint,    true);\n+    def(MarkStackChunkList_lock    , PaddedMutex  , nosafepoint,    true);\n@@ -239,1 +239,1 @@\n-    def(MonitoringSupport_lock     , PaddedMutex  , service-1,   true,  _safepoint_check_never);      \/\/ used for serviceability monitoring support\n+    def(MonitoringSupport_lock     , PaddedMutex  , service-1,      true);      \/\/ used for serviceability monitoring support\n@@ -241,4 +241,4 @@\n-  def(StringDedup_lock             , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n-  def(StringDedupIntern_lock       , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(ParGCRareEvent_lock          , PaddedMutex  , nonleaf,       true,  _safepoint_check_always);\n-  def(RawMonitor_lock              , PaddedMutex  , nosafepoint-1, true,  _safepoint_check_never);\n+  def(StringDedup_lock             , PaddedMonitor, nosafepoint,    true);\n+  def(StringDedupIntern_lock       , PaddedMutex  , nosafepoint,    true);\n+  def(ParGCRareEvent_lock          , PaddedMutex  , safepoint,      true);\n+  def(RawMonitor_lock              , PaddedMutex  , nosafepoint-1,  true);\n@@ -246,1 +246,1 @@\n-  def(Metaspace_lock               , PaddedMutex  , nosafepoint-3, true,  _safepoint_check_never);\n+  def(Metaspace_lock               , PaddedMutex  , nosafepoint-3,  true);\n@@ -248,3 +248,3 @@\n-  def(Patching_lock                , PaddedMutex  , nosafepoint,     true,  _safepoint_check_never);      \/\/ used for safepointing and code patching.\n-  def(MonitorDeflation_lock        , PaddedMonitor, nosafepoint,     true,  _safepoint_check_never);      \/\/ used for monitor deflation thread operations\n-  def(Service_lock                 , PaddedMonitor, service,     true,  _safepoint_check_never);      \/\/ used for service thread operations\n+  def(Patching_lock                , PaddedMutex  , nosafepoint,    true);      \/\/ used for safepointing and code patching.\n+  def(MonitorDeflation_lock        , PaddedMonitor, nosafepoint,    true);      \/\/ used for monitor deflation thread operations\n+  def(Service_lock                 , PaddedMonitor, service,        true);      \/\/ used for service thread operations\n@@ -253,1 +253,1 @@\n-    def(Notification_lock          , PaddedMonitor, service,     true,  _safepoint_check_never);  \/\/ used for notification thread operations\n+    def(Notification_lock          , PaddedMonitor, service,        true);  \/\/ used for notification thread operations\n@@ -258,1 +258,1 @@\n-  def(JmethodIdCreation_lock       , PaddedMutex  , nosafepoint-2,   true,  _safepoint_check_never); \/\/ used for creating jmethodIDs.\n+  def(JmethodIdCreation_lock       , PaddedMutex  , nosafepoint-2,  true); \/\/ used for creating jmethodIDs.\n@@ -260,6 +260,6 @@\n-  def(SharedDictionary_lock        , PaddedMutex  , nonleaf,          true,  _safepoint_check_always);\n-  def(VMStatistic_lock             , PaddedMutex  , nonleaf,          false, _safepoint_check_always);\n-  def(JNIHandleBlockFreeList_lock  , PaddedMutex  , nosafepoint-1,    true,  _safepoint_check_never);      \/\/ handles are used by VM thread\n-  def(SignatureHandlerLibrary_lock , PaddedMutex  , nonleaf,          false, _safepoint_check_always);\n-  def(SymbolArena_lock             , PaddedMutex  , nosafepoint,      true,  _safepoint_check_never);\n-  def(ExceptionCache_lock          , PaddedMutex  , nonleaf,          false, _safepoint_check_always);\n+  def(SharedDictionary_lock        , PaddedMutex  , safepoint,      true);\n+  def(VMStatistic_lock             , PaddedMutex  , safepoint,      false);\n+  def(JNIHandleBlockFreeList_lock  , PaddedMutex  , nosafepoint-1,  true);      \/\/ handles are used by VM thread\n+  def(SignatureHandlerLibrary_lock , PaddedMutex  , safepoint,      false);\n+  def(SymbolArena_lock             , PaddedMutex  , nosafepoint,    true);\n+  def(ExceptionCache_lock          , PaddedMutex  , safepoint,      false);\n@@ -267,1 +267,1 @@\n-  def(FullGCALot_lock              , PaddedMutex  , nonleaf,          false, _safepoint_check_always); \/\/ a lock to make FullGCALot MT safe\n+  def(FullGCALot_lock              , PaddedMutex  , safepoint,      false); \/\/ a lock to make FullGCALot MT safe\n@@ -269,1 +269,1 @@\n-  def(BeforeExit_lock              , PaddedMonitor, nonleaf,          true,  _safepoint_check_always);\n+  def(BeforeExit_lock              , PaddedMonitor, safepoint,      true);\n@@ -271,2 +271,2 @@\n-  def(NonJavaThreadsList_lock      , PaddedMutex,   nosafepoint-1, true,  _safepoint_check_never);\n-  def(NonJavaThreadsListSync_lock  , PaddedMutex,   nosafepoint, true,  _safepoint_check_never);\n+  def(NonJavaThreadsList_lock      , PaddedMutex,   nosafepoint-1,  true);\n+  def(NonJavaThreadsListSync_lock  , PaddedMutex,   nosafepoint,    true);\n@@ -274,6 +274,5 @@\n-  def(RetData_lock                 , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n-  def(Terminator_lock              , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n-  def(InitCompleted_lock           , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n-  def(Notify_lock                  , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n-  def(JNICritical_lock             , PaddedMonitor, nonleaf,     true,  _safepoint_check_always); \/\/ used for JNI critical regions\n-  def(AdapterHandlerLibrary_lock   , PaddedMutex  , nonleaf,     true,  _safepoint_check_always);\n+  def(RetData_lock                 , PaddedMutex  , safepoint,      false);\n+  def(Terminator_lock              , PaddedMonitor, safepoint,      true);\n+  def(InitCompleted_lock           , PaddedMonitor, nosafepoint,    true);\n+  def(Notify_lock                  , PaddedMonitor, safepoint,      true);\n+  def(AdapterHandlerLibrary_lock   , PaddedMutex  , safepoint,      true);\n@@ -281,2 +280,2 @@\n-  def(Heap_lock                    , PaddedMonitor, nonleaf,   false, _safepoint_check_always); \/\/ Doesn't safepoint check during termination.\n-  def(JfieldIdCreation_lock        , PaddedMutex  , nonleaf,   true,  _safepoint_check_always); \/\/ jfieldID, Used in VM_Operation\n+  def(Heap_lock                    , PaddedMonitor, safepoint,      false); \/\/ Doesn't safepoint check during termination.\n+  def(JfieldIdCreation_lock        , PaddedMutex  , safepoint,      true);  \/\/ jfieldID, Used in VM_Operation\n@@ -284,5 +283,5 @@\n-  def(CompiledIC_lock              , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);      \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n-  def(MethodCompileQueue_lock      , PaddedMonitor, nonleaf,     false, _safepoint_check_always);\n-  def(CompileStatistics_lock       , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n-  def(DirectivesStack_lock         , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(MultiArray_lock              , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n+  def(CompiledIC_lock              , PaddedMutex  , nosafepoint,    true);  \/\/ locks VtableStubs_lock, InlineCacheBuffer_lock\n+  def(MethodCompileQueue_lock      , PaddedMonitor, safepoint,      false);\n+  def(CompileStatistics_lock       , PaddedMutex  , safepoint,      false);\n+  def(DirectivesStack_lock         , PaddedMutex  , nosafepoint,    true);\n+  def(MultiArray_lock              , PaddedMutex  , safepoint,      false);\n@@ -290,3 +289,3 @@\n-  def(JvmtiThreadState_lock        , PaddedMutex  , nonleaf,     false, _safepoint_check_always); \/\/ Used by JvmtiThreadState\/JvmtiEventController\n-  def(EscapeBarrier_lock           , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);  \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n-  def(Management_lock              , PaddedMutex  , nonleaf,     false, _safepoint_check_always); \/\/ used for JVM management\n+  def(JvmtiThreadState_lock        , PaddedMutex  , safepoint,      false); \/\/ Used by JvmtiThreadState\/JvmtiEventController\n+  def(EscapeBarrier_lock           , PaddedMonitor, nosafepoint,    true);  \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n+  def(Management_lock              , PaddedMutex  , safepoint,      false); \/\/ used for JVM management\n@@ -294,3 +293,3 @@\n-  def(ConcurrentGCBreakpoints_lock , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n-  def(MethodData_lock              , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n-  def(TouchedMethodLog_lock        , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n+  def(ConcurrentGCBreakpoints_lock , PaddedMonitor, safepoint,      true);\n+  def(MethodData_lock              , PaddedMutex  , safepoint,      false);\n+  def(TouchedMethodLog_lock        , PaddedMutex  , safepoint,      false);\n@@ -298,4 +297,4 @@\n-  def(CompileThread_lock           , PaddedMonitor, nonleaf,     false, _safepoint_check_always);\n-  def(PeriodicTask_lock            , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n-  def(RedefineClasses_lock         , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n-  def(Verify_lock                  , PaddedMutex,   nonleaf,     true,  _safepoint_check_always);\n+  def(CompileThread_lock           , PaddedMonitor, safepoint,      false);\n+  def(PeriodicTask_lock            , PaddedMonitor, safepoint,      true);\n+  def(RedefineClasses_lock         , PaddedMonitor, safepoint,      true);\n+  def(Verify_lock                  , PaddedMutex,   safepoint,      true);\n@@ -304,1 +303,1 @@\n-    def(Compilation_lock           , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n+    def(Compilation_lock           , PaddedMonitor, nosafepoint,    true);\n@@ -308,3 +307,3 @@\n-  def(JfrBuffer_lock               , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(JfrStacktrace_lock           , PaddedMutex  , stackwatermark-1,  true,  _safepoint_check_never);\n-  def(JfrThreadSampler_lock        , PaddedMonitor, nosafepoint, true,  _safepoint_check_never);\n+  def(JfrBuffer_lock               , PaddedMutex  , nosafepoint,       true);\n+  def(JfrStacktrace_lock           , PaddedMutex  , stackwatermark-1,  true);\n+  def(JfrThreadSampler_lock        , PaddedMonitor, nosafepoint,       true);\n@@ -314,1 +313,1 @@\n-  def(UnsafeJlong_lock             , PaddedMutex  , nosafepoint,     true,  _safepoint_check_never);\n+  def(UnsafeJlong_lock             , PaddedMutex  , nosafepoint,    true);\n@@ -317,6 +316,6 @@\n-  def(CodeHeapStateAnalytics_lock  , PaddedMutex  , nonleaf,   false, _safepoint_check_always);\n-  def(NMethodSweeperStats_lock     , PaddedMutex  , nosafepoint,   true,  _safepoint_check_never);\n-  def(ThreadsSMRDelete_lock        , PaddedMonitor, nosafepoint-3, true,  _safepoint_check_never); \/\/ Holds ConcurrentHashTableResize_lock\n-  def(ThreadIdTableCreate_lock     , PaddedMutex  , nonleaf,       false, _safepoint_check_always);\n-  def(SharedDecoder_lock           , PaddedMutex  , tty-1,         true,  _safepoint_check_never);\n-  def(DCmdFactory_lock             , PaddedMutex  , nosafepoint,   true,  _safepoint_check_never);\n+  def(CodeHeapStateAnalytics_lock  , PaddedMutex  , safepoint,      false);\n+  def(NMethodSweeperStats_lock     , PaddedMutex  , nosafepoint,    true);\n+  def(ThreadsSMRDelete_lock        , PaddedMonitor, nosafepoint-3,  true); \/\/ Holds ConcurrentHashTableResize_lock\n+  def(ThreadIdTableCreate_lock     , PaddedMutex  , safepoint,      false);\n+  def(SharedDecoder_lock           , PaddedMutex  , tty-1,          true);\n+  def(DCmdFactory_lock             , PaddedMutex  , nosafepoint,    true);\n@@ -324,1 +323,1 @@\n-  def(NMTQuery_lock                , PaddedMutex  , nonleaf, false, _safepoint_check_always);\n+  def(NMTQuery_lock                , PaddedMutex  , safepoint,      false);\n@@ -328,1 +327,1 @@\n-  def(CDSClassFileStream_lock      , PaddedMutex  , nonleaf, false, _safepoint_check_always);\n+  def(CDSClassFileStream_lock      , PaddedMutex  , safepoint,      false);\n@@ -330,5 +329,5 @@\n-  def(DumpTimeTable_lock           , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(CDSLambda_lock               , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(DumpRegion_lock              , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(ClassListFile_lock           , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(LambdaFormInvokers_lock      , PaddedMutex  , nonleaf,     false, _safepoint_check_always);\n+  def(DumpTimeTable_lock           , PaddedMutex  , nosafepoint,    true);\n+  def(CDSLambda_lock               , PaddedMutex  , nosafepoint,    true);\n+  def(DumpRegion_lock              , PaddedMutex  , nosafepoint,    true);\n+  def(ClassListFile_lock           , PaddedMutex  , nosafepoint,    true);\n+  def(LambdaFormInvokers_lock      , PaddedMutex  , safepoint,      false);\n@@ -336,2 +335,2 @@\n-  def(Bootclasspath_lock           , PaddedMutex  , nosafepoint, true,  _safepoint_check_never);\n-  def(Zip_lock                     , PaddedMonitor, nosafepoint-1, true, _safepoint_check_never); \/\/ Holds DumpTimeTable_lock\n+  def(Bootclasspath_lock           , PaddedMutex  , nosafepoint,    true);\n+  def(Zip_lock                     , PaddedMonitor, nosafepoint-1,  true); \/\/ Holds DumpTimeTable_lock\n@@ -340,1 +339,1 @@\n-  def(JVMCI_lock                   , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n+  def(JVMCI_lock                   , PaddedMonitor, safepoint,      true);\n@@ -343,6 +342,6 @@\n-  \/\/ These locks have safepoint_check_never and relative rankings.\n-  defl(InlineCacheBuffer_lock      , PaddedMutex  , CompiledIC_lock,  true,  _safepoint_check_never);\n-  defl(VtableStubs_lock            , PaddedMutex  , CompiledIC_lock,  true,  _safepoint_check_never);  \/\/ Also holds DumpTimeTable_lock\n-  defl(CodeCache_lock              , PaddedMonitor, VtableStubs_lock, true,  _safepoint_check_never);\n-  defl(CompiledMethod_lock         , PaddedMutex  , CodeCache_lock,   true,  _safepoint_check_never);\n-  defl(CodeSweeper_lock            , PaddedMonitor, CompiledMethod_lock, true,  _safepoint_check_never);\n+  \/\/ These locks have relative rankings, and inherit safepoint checking attributes from that rank.\n+  defl(InlineCacheBuffer_lock      , PaddedMutex  , CompiledIC_lock,  true);\n+  defl(VtableStubs_lock            , PaddedMutex  , CompiledIC_lock,  true);  \/\/ Also holds DumpTimeTable_lock\n+  defl(CodeCache_lock              , PaddedMonitor, VtableStubs_lock, true);\n+  defl(CompiledMethod_lock         , PaddedMutex  , CodeCache_lock,   true);\n+  defl(CodeSweeper_lock            , PaddedMonitor, CompiledMethod_lock, true);\n@@ -350,4 +349,3 @@\n-  \/\/ These locks have safepoint_check_always and relative rankings.\n-  defl(Threads_lock                , PaddedMonitor, CompileThread_lock, true, _safepoint_check_always);\n-  defl(Heap_lock                   , PaddedMonitor, MultiArray_lock,   false, _safepoint_check_always);\n-  defl(Compile_lock                , PaddedMutex ,  MethodCompileQueue_lock, false, _safepoint_check_always);\n+  defl(Threads_lock                , PaddedMonitor, CompileThread_lock, true);\n+  defl(Heap_lock                   , PaddedMonitor, MultiArray_lock,    false);\n+  defl(Compile_lock                , PaddedMutex ,  MethodCompileQueue_lock, false);\n@@ -355,5 +353,5 @@\n-  defl(PerfDataMemAlloc_lock       , PaddedMutex  , Heap_lock,         true, _safepoint_check_always);\n-  defl(PerfDataManager_lock        , PaddedMutex  , Heap_lock,         true, _safepoint_check_always);\n-  defl(ClassLoaderDataGraph_lock   , PaddedMutex  , MultiArray_lock,   false, _safepoint_check_always);\n-  defl(VMOperation_lock            , PaddedMonitor, Compile_lock,      true, _safepoint_check_always);\n-  defl(ClassInitError_lock         , PaddedMonitor, Threads_lock,      true, _safepoint_check_always);\n+  defl(PerfDataMemAlloc_lock       , PaddedMutex  , Heap_lock,         true);\n+  defl(PerfDataManager_lock        , PaddedMutex  , Heap_lock,         true);\n+  defl(ClassLoaderDataGraph_lock   , PaddedMutex  , MultiArray_lock,   false);\n+  defl(VMOperation_lock            , PaddedMonitor, Compile_lock,      true);\n+  defl(ClassInitError_lock         , PaddedMonitor, Threads_lock,      true);\n@@ -362,1 +360,1 @@\n-    defl(G1OldGCCount_lock         , PaddedMonitor, Threads_lock, true, _safepoint_check_always);\n+    defl(G1OldGCCount_lock         , PaddedMonitor, Threads_lock,      true);\n@@ -364,5 +362,6 @@\n-  defl(CompileTaskAlloc_lock       , PaddedMutex ,  MethodCompileQueue_lock,   true, _safepoint_check_always);\n-  defl(ExpandHeap_lock             , PaddedMutex ,  Heap_lock,                 true, _safepoint_check_always);\n-  defl(OopMapCacheAlloc_lock       , PaddedMutex ,  Threads_lock,              true, _safepoint_check_always);\n-  defl(Module_lock                 , PaddedMutex ,  ClassLoaderDataGraph_lock, false, _safepoint_check_always);\n-  defl(SystemDictionary_lock       , PaddedMonitor, Module_lock,               true, _safepoint_check_always);\n+  defl(CompileTaskAlloc_lock       , PaddedMutex ,  MethodCompileQueue_lock,   true);\n+  defl(ExpandHeap_lock             , PaddedMutex ,  Heap_lock,                 true);\n+  defl(OopMapCacheAlloc_lock       , PaddedMutex ,  Threads_lock,              true);\n+  defl(Module_lock                 , PaddedMutex ,  ClassLoaderDataGraph_lock, false);\n+  defl(SystemDictionary_lock       , PaddedMonitor, Module_lock,               true);\n+  defl(JNICritical_lock            , PaddedMonitor, MultiArray_lock,           true); \/\/ used for JNI critical regions\n@@ -371,1 +370,1 @@\n-  defl(JfrMsg_lock                 , PaddedMonitor, Module_lock,               true,  _safepoint_check_always);\n+  defl(JfrMsg_lock                 , PaddedMonitor, Module_lock,               true);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":105,"deletions":106,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -134,1 +134,0 @@\n-      case _thread_in_native_trans:\n","filename":"src\/hotspot\/share\/runtime\/safepoint.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    _lock(Mutex::stackwatermark, \"StackWatermark_lock\", Mutex::_safepoint_check_never),\n+    _lock(Mutex::stackwatermark, \"StackWatermark_lock\"),\n","filename":"src\/hotspot\/share\/runtime\/stackWatermark.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1004,1 +1004,0 @@\n-  _async_exception_condition(_no_async_condition),\n@@ -1006,0 +1005,3 @@\n+#ifdef ASSERT\n+  _is_unsafe_access_error(false),\n+#endif\n@@ -1575,3 +1577,0 @@\n-\/\/ Note: this function shouldn't block if it's called in\n-\/\/ _thread_in_native_trans state (such as from\n-\/\/ check_special_condition_for_native_trans()).\n@@ -1603,9 +1602,1 @@\n-  AsyncExceptionCondition condition = clear_async_exception_condition();\n-  if (condition == _no_async_condition) {\n-    \/\/ Conditions have changed since has_special_runtime_exit_condition()\n-    \/\/ was called:\n-    \/\/ - if we were here only because of an external suspend request,\n-    \/\/   then that was taken care of above (or cancelled) so we are done\n-    \/\/ - if we were here because of another async request, then it has\n-    \/\/   been cleared between the has_special_runtime_exit_condition()\n-    \/\/   and now so again we are done\n+  if (!clear_async_exception_condition()) {\n@@ -1615,1 +1606,0 @@\n-  \/\/ Check for pending async. exception\n@@ -1617,1 +1607,1 @@\n-    \/\/ Only overwrite an already pending exception, if it is not a threadDeath.\n+    \/\/ Only overwrite an already pending exception if it is not a threadDeath.\n@@ -1634,3 +1624,0 @@\n-      _pending_async_exception = NULL;\n-      \/\/ Clear condition from _suspend_flags since we have finished processing it.\n-      clear_suspend_flag(_has_async_exception);\n@@ -1638,1 +1625,6 @@\n-  }\n+    \/\/ Always null out the _pending_async_exception oop here since the async condition was\n+    \/\/ already cleared above and thus considered handled.\n+    _pending_async_exception = NULL;\n+  } else {\n+    assert(_is_unsafe_access_error, \"must be\");\n+    DEBUG_ONLY(_is_unsafe_access_error = false);\n@@ -1640,1 +1632,0 @@\n-  if (condition == _async_unsafe_access_error && !has_pending_exception()) {\n@@ -1647,6 +1638,3 @@\n-      return;\n-    }\n-    case _thread_in_native: {\n-      ThreadInVMfromNative tiv(this);\n-      JavaThread* THREAD = this;\n-      Exceptions::throw_unsafe_access_internal_error(THREAD, __FILE__, __LINE__, \"a fault occurred in an unsafe memory access operation\");\n+      \/\/ We might have blocked in a ThreadBlockInVM wrapper in the call above so make sure we process pending\n+      \/\/ suspend requests and object reallocation operations if any since we might be going to Java after this.\n+      SafepointMechanism::process_if_requested_with_exit_check(this, true \/* check asyncs *\/);\n@@ -1665,2 +1653,0 @@\n-\n-  assert(has_pending_exception(), \"must have handled the async condition if no exception\");\n@@ -1699,1 +1685,1 @@\n-void JavaThread::send_async_exception(oop java_thread, oop java_throwable) {\n+void JavaThread::send_async_exception(JavaThread* target, oop java_throwable) {\n@@ -1701,1 +1687,0 @@\n-  JavaThread* target = java_lang_Thread::thread(java_thread);\n@@ -1850,0 +1835,2 @@\n+  thread->set_thread_state(_thread_in_vm);\n+\n@@ -1853,1 +1840,1 @@\n-  SafepointMechanism::process_if_requested_with_exit_check(thread, false \/* check asyncs *\/);\n+  SafepointMechanism::process_if_requested_with_exit_check(thread, true \/* check asyncs *\/);\n@@ -1859,6 +1846,0 @@\n-\n-  if (thread->has_async_exception_condition(false \/* check unsafe access error *\/)) {\n-    \/\/ We are in _thread_in_native_trans state, don't handle unsafe\n-    \/\/ access error since that may block.\n-    thread->check_and_handle_async_exceptions();\n-  }\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":18,"deletions":37,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -805,14 +805,4 @@\n-  enum AsyncExceptionCondition {\n-    _no_async_condition = 0,\n-    _async_exception,\n-    _async_unsafe_access_error\n-  };\n-  AsyncExceptionCondition _async_exception_condition;\n-  oop                     _pending_async_exception;\n-\n-  void set_async_exception_condition(AsyncExceptionCondition aec) { _async_exception_condition = aec; }\n-  AsyncExceptionCondition clear_async_exception_condition() {\n-    AsyncExceptionCondition x = _async_exception_condition;\n-    _async_exception_condition = _no_async_condition;\n-    return x;\n-  }\n+  oop     _pending_async_exception;\n+#ifdef ASSERT\n+  bool    _is_unsafe_access_error;\n+#endif\n@@ -820,0 +810,1 @@\n+  inline bool clear_async_exception_condition();\n@@ -821,3 +812,2 @@\n-  bool has_async_exception_condition(bool check_unsafe_access_error = true) {\n-    return check_unsafe_access_error ? _async_exception_condition != _no_async_condition\n-                                     : _async_exception_condition == _async_exception;\n+  bool has_async_exception_condition() {\n+    return (_suspend_flags & _has_async_exception) != 0;\n@@ -826,9 +816,2 @@\n-  void set_pending_unsafe_access_error()  {\n-    \/\/ Don't overwrite an asynchronous exception sent by another thread\n-    if (_async_exception_condition == _no_async_condition) {\n-      set_async_exception_condition(_async_unsafe_access_error);\n-    }\n-  }\n-  void check_and_handle_async_exceptions();\n-  \/\/ Installs a pending exception to be inserted later\n-  static void send_async_exception(oop thread_oop, oop java_throwable);\n+  inline void set_pending_unsafe_access_error();\n+  static void send_async_exception(JavaThread* jt, oop java_throwable);\n@@ -836,0 +819,1 @@\n+  void check_and_handle_async_exceptions();\n@@ -1180,2 +1164,1 @@\n-    return (_async_exception_condition != _no_async_condition) ||\n-           (_suspend_flags & (_obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n+    return (_suspend_flags & (_has_async_exception | _obj_deopt JFR_ONLY(| _trace_flag))) != 0;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":11,"deletions":28,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -125,0 +125,6 @@\n+inline bool JavaThread::clear_async_exception_condition() {\n+  bool ret = has_async_exception_condition();\n+  clear_suspend_flag(_has_async_exception);\n+  return ret;\n+}\n+\n@@ -127,4 +133,0 @@\n-  set_async_exception_condition(_async_exception);\n-  \/\/ Set _suspend_flags too so we save a comparison in the transition from native to Java\n-  \/\/ in the native wrappers. It will be cleared in check_and_handle_async_exceptions()\n-  \/\/ when we actually install the exception.\n@@ -134,0 +136,5 @@\n+inline void JavaThread::set_pending_unsafe_access_error() {\n+  set_suspend_flag(_has_async_exception);\n+  DEBUG_ONLY(_is_unsafe_access_error = true);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -371,1 +371,1 @@\n-  Monitor timer(Mutex::nosafepoint, \"VM_ExitTimer_lock\", Monitor::_safepoint_check_never);\n+  Monitor timer(Mutex::nosafepoint, \"VM_ExitTimer_lock\");\n","filename":"src\/hotspot\/share\/runtime\/vmOperations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -720,1 +720,0 @@\n-  nonstatic_field(JavaThread,                  _async_exception_condition,                    JavaThread::AsyncExceptionCondition)   \\\n@@ -1954,1 +1953,0 @@\n-  declare_integer_type(JavaThread::AsyncExceptionCondition)               \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,2 +131,1 @@\n-  _terminate_lock = new Monitor(Mutex::nosafepoint, \"VMThreadTerminate_lock\",\n-                                Monitor::_safepoint_check_never);\n+  _terminate_lock = new Monitor(Mutex::nosafepoint, \"VMThreadTerminate_lock\");\n","filename":"src\/hotspot\/share\/runtime\/vmThread.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -751,1 +751,1 @@\n-    _lock = new (std::nothrow) PaddedMonitor(Mutex::nonleaf, \"ParallelHProfWriter_lock\", Mutex::_safepoint_check_always);\n+    _lock = new (std::nothrow) PaddedMonitor(Mutex::safepoint, \"ParallelHProfWriter_lock\");\n@@ -1817,2 +1817,1 @@\n-     _lock(new (std::nothrow) PaddedMonitor(Mutex::nonleaf, \"DumperController_lock\",\n-    Mutex::_safepoint_check_always)),\n+     _lock(new (std::nothrow) PaddedMonitor(Mutex::safepoint, \"DumperController_lock\")),\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -203,2 +203,1 @@\n-  _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"HProfCompressionBackend_lock\",\n-    Mutex::_safepoint_check_never)) {\n+  _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"HProfCompressionBackend_lock\")) {\n","filename":"src\/hotspot\/share\/services\/heapDumperCompression.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,2 +177,1 @@\n-  _last_gc_lock = new Mutex(Mutex::nosafepoint, \"GCMemoryManager_lock\",\n-                            Mutex::_safepoint_check_never);\n+  _last_gc_lock = new Mutex(Mutex::nosafepoint, \"GCMemoryManager_lock\");\n","filename":"src\/hotspot\/share\/services\/memoryManager.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1017,2 +1017,1 @@\n-    new Mutex(Mutex::nosafepoint-2, \"ConcurrentHashTableResize_lock\",\n-              Mutex::_safepoint_check_never);\n+    new Mutex(Mutex::nosafepoint-2, \"ConcurrentHashTableResize_lock\");\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-    _mutex(Mutex::event, name, Mutex::_safepoint_check_never),\n+    _mutex(Mutex::event, name),\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+bool              VMError::_print_native_stack_used = false;\n@@ -244,0 +245,102 @@\n+\/**\n+ * Adds `value` to `list` iff it's not already present and there is sufficient\n+ * capacity (i.e. length(list) < `list_capacity`). The length of the list\n+ * is the index of the first nullptr entry or `list_capacity` if there are\n+ * no nullptr entries.\n+ *\n+ * @ return true if the value was added, false otherwise\n+ *\/\n+static bool add_if_absent(address value, address* list, int list_capacity) {\n+  for (int i = 0; i < list_capacity; i++) {\n+    if (list[i] == value) {\n+      return false;\n+    }\n+    if (list[i] == nullptr) {\n+      list[i] = value;\n+      if (i + 1 < list_capacity) {\n+        list[i + 1] = nullptr;\n+      }\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+\/**\n+ * Prints the VM generated code unit, if any, containing `pc` if it has not already\n+ * been printed. If the code unit is an InterpreterCodelet or StubCodeDesc, it is\n+ * only printed if `is_crash_pc` is true.\n+ *\n+ * @param printed array of code units that have already been printed (delimited by NULL entry)\n+ * @param printed_capacity the capacity of `printed`\n+ * @return true if the code unit was printed, false otherwise\n+ *\/\n+static bool print_code(outputStream* st, Thread* thread, address pc, bool is_crash_pc,\n+                       address* printed, int printed_capacity) {\n+  if (Interpreter::contains(pc)) {\n+    if (is_crash_pc) {\n+      \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n+      InterpreterCodelet* codelet = Interpreter::codelet_containing(pc);\n+      if (codelet != nullptr) {\n+        if (add_if_absent((address) codelet, printed, printed_capacity)) {\n+          codelet->print_on(st);\n+          Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n+          return true;\n+        }\n+      }\n+    }\n+  } else {\n+    StubCodeDesc* desc = StubCodeDesc::desc_for(pc);\n+    if (desc != nullptr) {\n+      if (is_crash_pc) {\n+        if (add_if_absent((address) desc, printed, printed_capacity)) {\n+          desc->print_on(st);\n+          Disassembler::decode(desc->begin(), desc->end(), st);\n+          return true;\n+        }\n+      }\n+    } else if (thread != nullptr) {\n+      CodeBlob* cb = CodeCache::find_blob(pc);\n+      if (cb != nullptr && add_if_absent((address) cb, printed, printed_capacity)) {\n+        \/\/ Disassembling nmethod will incur resource memory allocation,\n+        \/\/ only do so when thread is valid.\n+        ResourceMark rm(thread);\n+        Disassembler::decode(cb, st);\n+        st->cr();\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+\/**\n+ * Gets the caller frame of `fr`.\n+ *\n+ * @returns an invalid frame (i.e. fr.pc() === 0) if the caller cannot be obtained\n+ *\/\n+static frame next_frame(frame fr, Thread* t) {\n+  \/\/ Compiled code may use EBP register on x86 so it looks like\n+  \/\/ non-walkable C frame. Use frame.sender() for java frames.\n+  frame invalid;\n+  if (t != nullptr && t->is_Java_thread()) {\n+    \/\/ Catch very first native frame by using stack address.\n+    \/\/ For JavaThread stack_base and stack_size should be set.\n+    if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n+      return invalid;\n+    }\n+    if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n+      RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n+      return fr.sender(&map);\n+    } else {\n+      \/\/ is_first_C_frame() does only simple checks for frame pointer,\n+      \/\/ it will pass if java compiled code has a pointer in EBP.\n+      if (os::is_first_C_frame(&fr)) return invalid;\n+      return os::get_sender_for_C_frame(&fr);\n+    }\n+  } else {\n+    if (os::is_first_C_frame(&fr)) return invalid;\n+    return os::get_sender_for_C_frame(&fr);\n+  }\n+}\n+\n@@ -261,20 +364,3 @@\n-      \/\/ Compiled code may use EBP register on x86 so it looks like\n-      \/\/ non-walkable C frame. Use frame.sender() for java frames.\n-      if (t && t->is_Java_thread()) {\n-        \/\/ Catch very first native frame by using stack address.\n-        \/\/ For JavaThread stack_base and stack_size should be set.\n-        if (!t->is_in_full_stack((address)(fr.real_fp() + 1))) {\n-          break;\n-        }\n-        if (fr.is_java_frame() || fr.is_native_frame() || fr.is_runtime_frame()) {\n-          RegisterMap map(JavaThread::cast(t), false); \/\/ No update\n-          fr = fr.sender(&map);\n-        } else {\n-          \/\/ is_first_C_frame() does only simple checks for frame pointer,\n-          \/\/ it will pass if java compiled code has a pointer in EBP.\n-          if (os::is_first_C_frame(&fr)) break;\n-          fr = os::get_sender_for_C_frame(&fr);\n-        }\n-      } else {\n-        if (os::is_first_C_frame(&fr)) break;\n-        fr = os::get_sender_for_C_frame(&fr);\n+      fr = next_frame(fr, t);\n+      if (fr.pc() == nullptr) {\n+        break;\n@@ -750,0 +836,1 @@\n+       _print_native_stack_used = true;\n@@ -824,1 +911,1 @@\n-  STEP(\"printing code blob if possible\")\n+  STEP(\"printing code blobs if possible\")\n@@ -827,8 +914,16 @@\n-       CodeBlob* cb = CodeCache::find_blob(_pc);\n-       if (cb != NULL) {\n-         if (Interpreter::contains(_pc)) {\n-           \/\/ The interpreter CodeBlob is very large so try to print the codelet instead.\n-           InterpreterCodelet* codelet = Interpreter::codelet_containing(_pc);\n-           if (codelet != NULL) {\n-             codelet->print_on(st);\n-             Disassembler::decode(codelet->code_begin(), codelet->code_end(), st);\n+       const int printed_capacity = max_error_log_print_code;\n+       address printed[printed_capacity];\n+       printed[0] = nullptr;\n+       int printed_len = 0;\n+       \/\/ Even though ErrorLogPrintCodeLimit is ranged checked\n+       \/\/ during argument parsing, there's no way to prevent it\n+       \/\/ subsequently (i.e., after parsing) being set to a\n+       \/\/ value outside the range.\n+       int limit = MIN2(ErrorLogPrintCodeLimit, printed_capacity);\n+       if (limit > 0) {\n+         \/\/ Scan the native stack\n+         if (!_print_native_stack_used) {\n+           \/\/ Only try to print code of the crashing frame since\n+           \/\/ the native stack cannot be walked with next_frame.\n+           if (print_code(st, _thread, _pc, true, printed, printed_capacity)) {\n+             printed_len++;\n@@ -837,10 +932,19 @@\n-           StubCodeDesc* desc = StubCodeDesc::desc_for(_pc);\n-           if (desc != NULL) {\n-             desc->print_on(st);\n-             Disassembler::decode(desc->begin(), desc->end(), st);\n-           } else if (_thread != NULL) {\n-             \/\/ Disassembling nmethod will incur resource memory allocation,\n-             \/\/ only do so when thread is valid.\n-             ResourceMark rm(_thread);\n-             Disassembler::decode(cb, st);\n-             st->cr();\n+           frame fr = os::fetch_frame_from_context(_context);\n+           while (printed_len < limit && fr.pc() != nullptr) {\n+             if (print_code(st, _thread, fr.pc(), fr.pc() == _pc, printed, printed_capacity)) {\n+               printed_len++;\n+             }\n+             fr = next_frame(fr, _thread);\n+           }\n+         }\n+\n+         \/\/ Scan the Java stack\n+         if (_thread != nullptr && _thread->is_Java_thread()) {\n+           JavaThread* jt = JavaThread::cast(_thread);\n+           if (jt->has_last_Java_frame()) {\n+             for (StackFrameStream sfs(jt, true \/* update *\/, true \/* process_frames *\/); printed_len < limit && !sfs.is_done(); sfs.next()) {\n+               address pc = sfs.current()->pc();\n+               if (print_code(st, _thread, pc, pc == _pc, printed, printed_capacity)) {\n+                 printed_len++;\n+               }\n+             }\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":143,"deletions":39,"binary":false,"changes":182,"status":"modified"},{"patch":"@@ -54,0 +54,4 @@\n+  \/\/ records if VMError::print_native_stack was used to\n+  \/\/ print the native stack instead of os::platform_print_native_stack\n+  static bool        _print_native_stack_used;\n+\n@@ -184,0 +188,3 @@\n+  \/\/ Max value for the ErrorLogPrintCodeLimit flag.\n+  static const int max_error_log_print_code = 10;\n+\n","filename":"src\/hotspot\/share\/utilities\/vmError.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -234,8 +234,0 @@\n-    \/**\n-     * The maximum size of array to allocate (unless necessary).\n-     * Some VMs reserve some header words in an array.\n-     * Attempts to allocate larger arrays may result in\n-     * OutOfMemoryError: Requested array size exceeds VM limit\n-     *\/\n-    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;\n-\n@@ -247,2 +239,2 @@\n-     * {@code (MAX_ARRAY_SIZE >> coder)} unless the given minimum capacity\n-     * is greater than that.\n+     * {@code (SOFT_MAX_ARRAY_LENGTH >> coder)}\n+     * unless the given minimum capacity is greater than that.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":2,"deletions":10,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2210,1 +2210,0 @@\n-            ru.host = child.host;\n@@ -3493,0 +3492,2 @@\n+                p = q;\n+                q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);\n@@ -3494,0 +3495,2 @@\n+                    if (input.charAt(q - 1) == '-')\n+                        fail(\"Illegal character in hostname\", q - 1);\n@@ -3495,6 +3498,0 @@\n-                    q = scan(p, n, L_ALPHANUM | L_DASH, H_ALPHANUM | H_DASH);\n-                    if (q > p) {\n-                        if (input.charAt(q - 1) == '-')\n-                            fail(\"Illegal character in hostname\", q - 1);\n-                        p = q;\n-                    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2517,0 +2517,1 @@\n+     * @see FileSystemProvider#checkAccess\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Files.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -752,1 +752,1 @@\n-                        (getManifestFromReference());\n+                        (getManifestFromReference(), jv.manifestName);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-                mev = new ManifestEntryVerifier(man);\n+                mev = new ManifestEntryVerifier(man, jv.manifestName);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarInputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -447,1 +447,1 @@\n-            this.mev = new ManifestEntryVerifier(man);\n+            this.mev = new ManifestEntryVerifier(man, jv.manifestName);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarVerifier.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,3 @@\n-    private Manifest man;\n+\n+    private final String manifestFileName; \/\/ never null\n+    private final Manifest man;\n@@ -77,1 +79,1 @@\n-    public ManifestEntryVerifier(Manifest man)\n+    public ManifestEntryVerifier(Manifest man, String manifestFileName)\n@@ -82,0 +84,1 @@\n+        this.manifestFileName = manifestFileName;\n@@ -190,1 +193,0 @@\n-     *\n@@ -212,1 +214,0 @@\n-\n@@ -254,1 +255,2 @@\n-     * or null if the signers for this entry have already been checked.\n+     * or null if the signers for this entry have already been checked\n+     * or there are no signers for this entry.\n@@ -265,1 +267,1 @@\n-        if (verifiedSigners.containsKey(JarFile.MANIFEST_NAME)) {\n+        if (verifiedSigners.containsKey(manifestFileName)) {\n@@ -271,1 +273,1 @@\n-                    verifiedSigners.get(JarFile.MANIFEST_NAME));\n+                    verifiedSigners.get(manifestFileName));\n@@ -274,0 +276,3 @@\n+            if (debug != null) {\n+                debug.println(manifestFileName + \" not present in verifiedSigners\");\n+            }\n@@ -275,1 +280,1 @@\n-            if (verifiedSigners.containsValue(signers)) {\n+            if (signers == null || verifiedSigners.containsValue(signers)) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/ManifestEntryVerifier.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -577,1 +577,1 @@\n-                    \/\/ Ideally, if JSR310 can just pass in the nagative and\n+                    \/\/ Ideally, if JSR310 can just pass in the negative and\n@@ -621,28 +621,0 @@\n-\n-                \/\/ Note: known mismatching -> Asia\/Amman\n-                \/\/ ZoneInfo :      startDayOfWeek=5     <= Thursday\n-                \/\/                 startTime=86400000   <= 24 hours\n-                \/\/ This:           startDayOfWeek=6\n-                \/\/                 startTime=0\n-                \/\/ Similar workaround needs to be applied to Africa\/Cairo and\n-                \/\/ its endDayOfWeek and endTime\n-                \/\/ Below is the workarounds, it probably slows down everyone a little\n-                if (params[2] == 6 && params[3] == 0 &&\n-                    (zoneId.equals(\"Asia\/Amman\"))) {\n-                    params[2] = 5;\n-                    params[3] = 86400000;\n-                }\n-                \/\/ Additional check for startDayOfWeek=6 and starTime=86400000\n-                \/\/ is needed for Asia\/Amman;\n-                if (params[2] == 7 && params[3] == 0 &&\n-                     (zoneId.equals(\"Asia\/Amman\"))) {\n-                    params[2] = 6;        \/\/ Friday\n-                    params[3] = 86400000; \/\/ 24h\n-                }\n-                \/\/endDayOfWeek and endTime workaround\n-                if (params[7] == 6 && params[8] == 0 &&\n-                    (zoneId.equals(\"Africa\/Cairo\"))) {\n-                    params[7] = 5;\n-                    params[8] = 86400000;\n-                }\n-\n@@ -897,0 +869,1 @@\n+    \/\/ timeEndOfDay is included in secondOfDay as \"86,400\" secs.\n@@ -902,1 +875,0 @@\n-        private final boolean timeEndOfDay;\n@@ -920,1 +892,0 @@\n-            this.timeEndOfDay = timeByte == 24;\n@@ -922,1 +893,0 @@\n-\n@@ -941,3 +911,0 @@\n-            if (timeEndOfDay) {\n-                epochDay += 1;\n-            }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/calendar\/ZoneInfoFile.java","additions":2,"deletions":35,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -474,0 +474,2 @@\n+         * Windows 11                   10              0  (VER_NT_WORKSTATION)\n+         *       where (buildNumber >= 22000)\n@@ -547,1 +549,8 @@\n-                    case  0: sprops.os_name = \"Windows 10\";           break;\n+                    case  0:\n+                        \/* Windows 11 21H2 (original release) build number is 22000 *\/\n+                        if (buildNumber >= 22000) {\n+                            sprops.os_name = \"Windows 11\";\n+                        } else {\n+                            sprops.os_name = \"Windows 10\";\n+                        }\n+                        break;\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,1 +122,1 @@\n-    private volatile long overriddenWindowHandle = 0L;\n+    private volatile long overriddenWindowHandle;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWLightweightFramePeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-    private volatile boolean isMouseOver = false;\n+    private volatile boolean isMouseOver;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/LWWindowPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n-    volatile boolean fIsIndeterminate = false;\n+    volatile boolean fIsIndeterminate;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CCheckboxMenuItem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        return (label != null && label.equals(\"-\"));\n+        return \"-\".equals(label);\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CMenuItem.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,2 +53,2 @@\n-    private volatile int screenX = 0;\n-    private volatile int screenY = 0;\n+    private volatile int screenX;\n+    private volatile int screenY;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPlatformEmbeddedFrame.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private volatile int currentIcon = 0;\n+    private volatile int currentIcon;\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CWarningWindow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,5 +101,2 @@\n-                IIOInvalidTreeException newGuy =\n-                    new IIOInvalidTreeException\n-                    (\"Can't get User Object\", node);\n-                newGuy.initCause(e);\n-                throw newGuy;\n+                throw new IIOInvalidTreeException\n+                        (\"Can't get User Object\", e, node);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/MarkerSegment.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-    private static volatile Set<Integer> essentialTags = null;\n+    private static volatile Set<Integer> essentialTags;\n@@ -64,1 +64,1 @@\n-            essentialTags = tags = Set.of(\n+            essentialTags = Set.of(\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/tiff\/TIFFIFD.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1711,1 +1711,1 @@\n-            return Boolean.valueOf(str).booleanValue();\n+            return Boolean.parseBoolean(str);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/Metacity.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -364,1 +364,1 @@\n-        protected volatile boolean flushing = false;\n+        protected volatile boolean flushing;\n@@ -367,4 +367,4 @@\n-        protected volatile boolean doIO = false;     \/\/ true in between start() and stop() calls\n-        protected volatile boolean stoppedWritten = false; \/\/ true if a write occurred in stopped state\n-        protected volatile boolean drained = false; \/\/ set to true when drain function returns, set to false in write()\n-        protected boolean monitoring = false;\n+        protected volatile boolean doIO;     \/\/ true in between start() and stop() calls\n+        protected volatile boolean stoppedWritten; \/\/ true if a write occurred in stopped state\n+        protected volatile boolean drained; \/\/ set to true when drain function returns, set to false in write()\n+        protected boolean monitoring;\n@@ -382,1 +382,1 @@\n-        protected volatile boolean noService = false; \/\/ do not run the nService method\n+        protected volatile boolean noService; \/\/ do not run the nService method\n@@ -978,1 +978,1 @@\n-        private volatile byte[] audioData = null;\n+        private volatile byte[] audioData;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DirectAudioDevice.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,2 @@\n-    private volatile boolean active = false;\n-    private SourceDataLine sourceDataLine = null;\n+    private volatile boolean active;\n+    private SourceDataLine sourceDataLine;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftAudioPusher.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-        public volatile long silent_samples = 0;\n+        public volatile long silent_samples;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/SoftSynthesizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -398,1 +398,1 @@\n-    private volatile boolean valid = false;\n+    private volatile boolean valid;\n@@ -9343,1 +9343,1 @@\n-        private transient volatile int propertyListenersCount = 0;\n+        private transient volatile int propertyListenersCount;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Component.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3864,1 +3864,1 @@\n-        private transient volatile int propertyListenersCount = 0;\n+        private transient volatile int propertyListenersCount;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Container.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -304,1 +304,1 @@\n-    transient volatile boolean isInHide = false;\n+    transient volatile boolean isInHide;\n@@ -315,1 +315,1 @@\n-    transient volatile boolean isInDispose = false;\n+    transient volatile boolean isInDispose;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Dialog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -407,2 +407,2 @@\n-    private transient volatile int securityWarningWidth = 0;\n-    private transient volatile int securityWarningHeight = 0;\n+    private transient volatile int securityWarningWidth;\n+    private transient volatile int securityWarningHeight;\n@@ -420,1 +420,1 @@\n-        systemSyncLWRequests = (s != null && s.equals(\"true\"));\n+        systemSyncLWRequests = \"true\".equals(s);\n@@ -424,1 +424,1 @@\n-        locationByPlatformProp = (s2 != null && s2.equals(\"true\"));\n+        locationByPlatformProp = \"true\".equals(s2);\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Window.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -119,1 +119,1 @@\n-    private volatile boolean dispatched = false;\n+    private volatile boolean dispatched;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/InvocationEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1367,1 +1367,1 @@\n-    private transient volatile int stCache = 0;\n+    private transient volatile int stCache;\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/font\/NumericShaper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -410,4 +410,1 @@\n-            RuntimeException ex =\n-                new IllegalStateException (\"Can't obtain format\");\n-            ex.initCause(e);\n-            throw ex;\n+            throw new IllegalStateException(\"Can't obtain format\", e);\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/metadata\/IIOMetadata.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n@@ -33,3 +31,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import javax.imageio.ImageReader;\n@@ -39,1 +34,0 @@\n-import javax.imageio.stream.ImageInputStream;\n@@ -600,4 +594,1 @@\n-            RuntimeException ex =\n-                new IllegalStateException (\"Can't obtain format\");\n-            ex.initCause(e);\n-            throw ex;\n+            throw new IllegalStateException(\"Can't obtain format\", e);\n","filename":"src\/java.desktop\/share\/classes\/javax\/imageio\/spi\/ImageReaderWriterSpi.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,1 +331,1 @@\n-            } else if (mode != null && mode.equals(\"outline\")) {\n+            } else if (\"outline\".equals(mode)) {\n@@ -333,1 +333,1 @@\n-            } else if (mode != null && mode.equals(\"faster\")\n+            } else if (\"faster\".equals(mode)\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/DefaultDesktopManager.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3755,1 +3755,1 @@\n-        private transient volatile int propertyListenersCount = 0;\n+        private transient volatile int propertyListenersCount;\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JComponent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,1 +208,1 @@\n-                    if(layer != null && layer.equals(FRAME_CONTENT_LAYER))\n+                    if (FRAME_CONTENT_LAYER.equals(layer))\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JLayeredPane.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-            suppressDropSupport = Boolean.valueOf(\n+            suppressDropSupport = Boolean.parseBoolean(\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/SwingUtilities.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -827,1 +827,1 @@\n-            if (parent != null && parent.equals(\"\/net\")) {\n+            if (\"\/net\".equals(parent)) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/filechooser\/FileSystemView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,3 +379,4 @@\n-     * receiver is contained in changes. Will create the\n-     * <code>leftButton<\/code> and <code>rightButton<\/code> if they\n-     * are null. invalidates the receiver as well.\n+     * divider is contained in changes. Will create the\n+     * <code>leftButton<\/code> and <code>rightButton<\/code> if they are null\n+     * and corresponding JSplitPane supports oneTouchExpandable property.\n+     * Invalidates the corresponding JSplitPane as well.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -128,2 +128,1 @@\n-                useSystemFonts = (systemFonts != null &&\n-                               (Boolean.valueOf(systemFonts).booleanValue()));\n+                useSystemFonts = Boolean.parseBoolean(systemFonts);\n@@ -1401,2 +1400,2 @@\n-            \"Tree.expandedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(Boolean.valueOf(MetalIconFactory.DARK)),\n-            \"Tree.collapsedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(Boolean.valueOf( MetalIconFactory.LIGHT )),\n+            \"Tree.expandedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(MetalIconFactory.DARK),\n+            \"Tree.collapsedIcon\",(LazyValue) t -> MetalIconFactory.getTreeControlIcon(MetalIconFactory.LIGHT),\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1329,1 +1329,1 @@\n-                    if ((ws != null) && ws.equals(\"pre\")) {\n+                    if (\"pre\".equals(ws)) {\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/text\/html\/HTMLEditorKit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-    private static volatile AppContext mainAppContext = null;\n+    private static volatile AppContext mainAppContext;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/AppContext.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-        touchKeyboardAutoShowIsEnabled = Boolean.valueOf(\n+        touchKeyboardAutoShowIsEnabled = Boolean.parseBoolean(\n@@ -1770,2 +1770,1 @@\n-                useSystemAAFontSettings =\n-                    Boolean.valueOf(systemAAFonts).booleanValue();\n+                useSystemAAFontSettings = Boolean.parseBoolean(systemAAFonts);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/SunToolkit.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,1 +74,1 @@\n-    private volatile int numberOfFlavorListeners = 0;\n+    private volatile int numberOfFlavorListeners;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/SunClipboard.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -94,1 +94,1 @@\n-                throw (IOException)new IOException().initCause(cnfe);\n+                throw new IOException(cnfe);\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/datatransfer\/TransferableProxy.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,2 +77,2 @@\n-    private static volatile boolean dragDropInProgress = false;\n-    private static volatile boolean discardingMouseEvents = false;\n+    private static volatile boolean dragDropInProgress;\n+    private static volatile boolean discardingMouseEvents;\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/dnd\/SunDragSourceContextPeer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-        Boolean.valueOf(java.security.AccessController.doPrivileged(\n+        Boolean.parseBoolean(java.security.AccessController.doPrivileged(\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/VSyncedBSManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -187,1 +187,1 @@\n-    public static volatile boolean pollingQueue = false;\n+    public static volatile boolean pollingQueue;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-import sun.awt.image.SurfaceManager.FlushableCacheData;\n@@ -77,1 +76,1 @@\n-        if (manimg != null && manimg.equals(\"false\")) {\n+        if (\"false\".equals(manimg)) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/SurfaceDataProxy.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -244,1 +244,1 @@\n-        return Boolean.valueOf(AccessController.doPrivileged(\n+        return Boolean.parseBoolean(AccessController.doPrivileged(\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/MarlinProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -337,1 +337,1 @@\n-        private static volatile RendererStatsHolder SINGLETON = null;\n+        private static volatile RendererStatsHolder SINGLETON;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/marlin\/RendererStats.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1550,1 +1550,1 @@\n-        if (js != null && js.equals(JobSheets.NONE)) {\n+        if (JobSheets.NONE.equals(js)) {\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-    private volatile long widget = 0L;\n+    private volatile long widget;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/GtkFileDialogPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -82,2 +82,2 @@\n-    private boolean mouseDraggedOutVertically = false;\n-    private volatile boolean vsbVisibilityChanged = false;\n+    private boolean mouseDraggedOutVertically;\n+    private volatile boolean vsbVisibilityChanged;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/ListHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -431,3 +431,3 @@\n-            r = Integer.valueOf(color.substring(0,4),16).intValue() >> 8;\n-            g = Integer.valueOf(color.substring(4,8),16).intValue() >> 8;\n-            b = Integer.valueOf(color.substring(8,12),16).intValue() >> 8;\n+            r = Integer.parseInt(color.substring(0, 4), 16) >> 8;\n+            g = Integer.parseInt(color.substring(4, 8), 16) >> 8;\n+            b = Integer.parseInt(color.substring(8, 12), 16) >> 8;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/MotifColorUtilities.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-    private static volatile long xicFocus = 0;\n+    private static volatile long xicFocus;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XInputMethod.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,1 +85,1 @@\n-    private volatile long overriddenWindowHandle = 0L;\n+    private volatile long overriddenWindowHandle;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XLightweightFramePeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-        isUnity = de != null && de.equals(\"Unity\");\n+        isUnity = \"Unity\".equals(de);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XTaskbarPeer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private volatile int currentIcon = 0;\n+    private volatile int currentIcon;\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XWarningWindow.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-        if (js != null && js.equals(JobSheets.NONE)) {\n+        if (JobSheets.NONE.equals(js)) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/UnixPrintJob.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -189,2 +189,1 @@\n-        useSystemFontSettings = (systemFonts == null ||\n-                                 Boolean.valueOf(systemFonts).booleanValue());\n+        useSystemFontSettings = systemFonts == null || Boolean.parseBoolean(systemFonts);\n","filename":"src\/java.desktop\/windows\/classes\/com\/sun\/java\/swing\/plaf\/windows\/WindowsLookAndFeel.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-    private static volatile boolean valid = false;\n+    private static volatile boolean valid;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/ThemeReader.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-        Boolean.valueOf(AccessController.doPrivileged(\n+        Boolean.parseBoolean(AccessController.doPrivileged(\n@@ -75,1 +75,1 @@\n-        Boolean.valueOf(AccessController.doPrivileged(\n+        Boolean.parseBoolean(AccessController.doPrivileged(\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/TranslucentWindowPainter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -271,1 +271,1 @@\n-        if (smoothingOn != null && smoothingOn.equals(Boolean.TRUE)) {\n+        if (Boolean.TRUE.equals(smoothingOn)) {\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WDesktopProperties.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-    volatile Error createError = null;\n+    volatile Error createError;\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WObjectPeer.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1803,0 +1803,1 @@\n+                preFlow(c);\n@@ -5921,0 +5922,2 @@\n+            initTypeIfNeeded(that);\n+            initTypeIfNeeded(that.var);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-        hprofBufferedOut = fos;\n+        hprofBufferedOut = new BufferedOutputStream(fos);\n@@ -415,1 +415,1 @@\n-                hprofBufferedOut = new GZIPOutputStream(fos) {\n+                hprofBufferedOut = new GZIPOutputStream(hprofBufferedOut) {\n@@ -618,0 +618,2 @@\n+            \/\/ We must flush all data to the file before reading the current file position.\n+            out.flush();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/HeapHprofBinWriter.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -359,3 +359,4 @@\n-      memset(&header, 0, sizeof(CDSFileMapHeaderBase));\n-      if ((n = read(fd, &header, sizeof(CDSFileMapHeaderBase)))\n-           != sizeof(CDSFileMapHeaderBase)) {\n+      size_t header_size = sizeof(CDSFileMapHeaderBase);\n+      memset(&header, 0, header_size);\n+      if ((n = read(fd, &header, header_size))\n+           != header_size) {\n@@ -368,1 +369,1 @@\n-      if (header._magic != CDS_ARCHIVE_MAGIC) {\n+      if (header._generic_header._magic != CDS_ARCHIVE_MAGIC) {\n@@ -370,1 +371,1 @@\n-                    classes_jsa, header._magic, CDS_ARCHIVE_MAGIC);\n+                    classes_jsa, header._generic_header._magic, CDS_ARCHIVE_MAGIC);\n@@ -376,1 +377,1 @@\n-      if (header._version != CURRENT_CDS_ARCHIVE_VERSION) {\n+      if (header._generic_header._version != CURRENT_CDS_ARCHIVE_VERSION) {\n@@ -378,1 +379,1 @@\n-                     classes_jsa, header._version, CURRENT_CDS_ARCHIVE_VERSION);\n+                     classes_jsa, header._generic_header._version, CURRENT_CDS_ARCHIVE_VERSION);\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/ps_core_common.c","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -154,1 +154,1 @@\n-        for (Element te : utils.getAllClasses(pkg)) {\n+        for (TypeElement te : utils.getAllClasses(pkg)) {\n@@ -160,1 +160,1 @@\n-                convertClass((TypeElement)te, outputdir);\n+                convertClass(te, outputdir);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SourceToHTMLConverter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -236,2 +236,1 @@\n-        for (Element e : utils.getFieldsUnfiltered(currentTypeElement)) {\n-            VariableElement field = (VariableElement)e;\n+        for (VariableElement field : utils.getFieldsUnfiltered(currentTypeElement)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/builders\/SerializedFormBuilder.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -115,2 +115,1 @@\n-        for (Element e : configuration.getIncludedTypeElements()) {\n-            TypeElement te = (TypeElement)e;\n+        for (TypeElement te : configuration.getIncludedTypeElements()) {\n@@ -118,2 +117,2 @@\n-            if (belongsToSummary.test(e)) {\n-                switch (e.getKind()) {\n+            if (belongsToSummary.test(te)) {\n+                switch (te.getKind()) {\n@@ -122,1 +121,1 @@\n-                        eset.add(e);\n+                        eset.add(te);\n@@ -132,1 +131,1 @@\n-                        eset.add(e);\n+                        eset.add(te);\n@@ -136,1 +135,1 @@\n-                        eset.add(e);\n+                        eset.add(te);\n@@ -140,1 +139,1 @@\n-                        eset.add(e);\n+                        eset.add(te);\n@@ -144,1 +143,1 @@\n-                        eset.add(e);\n+                        eset.add(te);\n@@ -155,1 +154,1 @@\n-            if (utils.isEnum(e)) {\n+            if (utils.isEnum(te)) {\n@@ -168,1 +167,1 @@\n-            if (utils.isAnnotationType(e)) {\n+            if (utils.isAnnotationType(te)) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/SummaryAPIListBuilder.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-    _lock = new Mutex(Monitor::nosafepoint, \"gtest-IsMetaspaceObjTest_lock\", Monitor::_safepoint_check_never);\n+    _lock = new Mutex(Monitor::nosafepoint, \"gtest-IsMetaspaceObjTest_lock\");\n","filename":"test\/hotspot\/gtest\/metaspace\/test_is_metaspace_obj.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTest_lock\", Monitor::_safepoint_check_never);\n+    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTest_lock\");\n@@ -742,0 +742,47 @@\n+\n+\/\/ Test that repeated allocation-deallocation cycles with the same block size\n+\/\/  do not increase metaspace usage after the initial allocation (the deallocated\n+\/\/  block should be reused by the next allocation).\n+static void test_repeatedly_allocate_and_deallocate(bool is_topmost) {\n+  if (Settings::handle_deallocations()) {\n+    \/\/ Test various sizes, including (important) the max. possible block size = 1 root chunk\n+    for (size_t blocksize = Metaspace::max_allocation_word_size(); blocksize >= 1; blocksize \/= 2) {\n+      size_t used1 = 0, used2 = 0, committed1 = 0, committed2 = 0;\n+      MetaWord* p = NULL, *p2 = NULL;\n+\n+      MetaspaceGtestContext context;\n+      MetaspaceArenaTestHelper helper(context, Metaspace::StandardMetaspaceType, false);\n+\n+      \/\/ First allocation\n+      helper.allocate_from_arena_with_tests_expect_success(&p, blocksize);\n+      if (!is_topmost) {\n+        \/\/ another one on top, size does not matter.\n+        helper.allocate_from_arena_with_tests_expect_success(0x10);\n+      }\n+\n+      \/\/ Measure\n+      helper.usage_numbers_with_test(&used1, &committed1, NULL);\n+\n+      \/\/ Dealloc, alloc several times with the same size.\n+      for (int i = 0; i < 5; i ++) {\n+        helper.deallocate_with_tests(p, blocksize);\n+        helper.allocate_from_arena_with_tests_expect_success(&p2, blocksize);\n+        \/\/ We should get the same pointer back.\n+        EXPECT_EQ(p2, p);\n+      }\n+\n+      \/\/ Measure again\n+      helper.usage_numbers_with_test(&used2, &committed2, NULL);\n+      EXPECT_EQ(used2, used1);\n+      EXPECT_EQ(committed1, committed2);\n+    }\n+  }\n+}\n+\n+TEST_VM(metaspace, MetaspaceArena_test_repeatedly_allocate_and_deallocate_top_allocation) {\n+  test_repeatedly_allocate_and_deallocate(true);\n+}\n+\n+TEST_VM(metaspace, MetaspaceArena_test_repeatedly_allocate_and_deallocate_nontop_allocation) {\n+  test_repeatedly_allocate_and_deallocate(false);\n+}\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena.cpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTestBed_lock\", Monitor::_safepoint_check_never);\n+    _lock = new Mutex(Monitor::nosafepoint, \"gtest-MetaspaceArenaTestBed_lock\");\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspacearena_stress.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  m[i] = new Mutex(Mutex::nosafepoint, FormatBuffer<128>(\"MyLock#%u_lock\", i), Mutex::_safepoint_check_never);\n+  m[i] = new Mutex(Mutex::nosafepoint, FormatBuffer<128>(\"MyLock#%u_lock\", i));\n@@ -56,3 +56,3 @@\n-const int rankA = Mutex::nonleaf-5;\n-const int rankAplusOne = Mutex::nonleaf-4;\n-const int rankAplusTwo = Mutex::nonleaf-3;\n+const Mutex::Rank rankA = Mutex::safepoint-5;\n+const Mutex::Rank rankAplusOne = Mutex::safepoint-4;\n+const Mutex::Rank rankAplusTwo = Mutex::safepoint-3;\n@@ -64,2 +64,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n@@ -74,1 +74,1 @@\n-                   \".* Attempting to acquire lock mutex_rankA_plus_one\/.* out of order with lock mutex_rankA\/.* -- possible deadlock\") {\n+                   \".* Attempting to acquire lock mutex_rankA_plus_one\/safepoint-4 out of order with lock mutex_rankA\/safepoint-5 -- possible deadlock\") {\n@@ -78,2 +78,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n@@ -92,2 +92,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n-  Mutex* mutex_rankB = new Mutex(rankA, \"mutex_rankB\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n+  Mutex* mutex_rankB = new Mutex(rankA, \"mutex_rankB\");\n@@ -105,3 +105,3 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n-  Mutex* mutex_rankA_plus_two = new Mutex(rankAplusTwo, \"mutex_rankA_plus_two\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n+  Mutex* mutex_rankA_plus_two = new Mutex(rankAplusTwo, \"mutex_rankA_plus_two\");\n@@ -122,2 +122,2 @@\n-  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\", Mutex::_safepoint_check_always);\n-  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Mutex* mutex_rankA = new Mutex(rankA, \"mutex_rankA\");\n+  Mutex* mutex_rankA_plus_one = new Mutex(rankAplusOne, \"mutex_rankA_plus_one\");\n@@ -134,1 +134,1 @@\n-                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/.* out of order with lock mutex_rank_event\/0 \"\n+                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/nosafepoint out of order with lock mutex_rank_event\/event \"\n@@ -139,2 +139,2 @@\n-  Mutex* mutex_rank_event = new Mutex(Mutex::event, \"mutex_rank_event\", Mutex::_safepoint_check_never);\n-  Mutex* mutex_rank_nonleaf = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\", Mutex::_safepoint_check_never);\n+  Mutex* mutex_rank_event = new Mutex(Mutex::event, \"mutex_rank_event\");\n+  Mutex* mutex_rank_safepoint = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\");\n@@ -143,2 +143,2 @@\n-  mutex_rank_nonleaf->lock_without_safepoint_check();\n-  mutex_rank_nonleaf->unlock();\n+  mutex_rank_safepoint->lock_without_safepoint_check();\n+  mutex_rank_safepoint->unlock();\n@@ -149,1 +149,1 @@\n-                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/.* out of order with lock mutex_rank_tty\/.*\"\n+                   \".* Attempting to acquire lock mutex_rank_nosafepoint\/nosafepoint out of order with lock mutex_rank_tty\/tty \"\n@@ -154,2 +154,2 @@\n-  Mutex* mutex_rank_tty = new Mutex(Mutex::tty, \"mutex_rank_tty\", Mutex::_safepoint_check_never);\n-  Mutex* mutex_rank_nosafepoint = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\", Mutex::_safepoint_check_never);\n+  Mutex* mutex_rank_tty = new Mutex(Mutex::tty, \"mutex_rank_tty\");\n+  Mutex* mutex_rank_nosafepoint = new Mutex(Mutex::nosafepoint, \"mutex_rank_nosafepoint\");\n@@ -167,2 +167,2 @@\n-  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", Mutex::_safepoint_check_always);\n-  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\");\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\");\n@@ -183,2 +183,2 @@\n-  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", Mutex::_safepoint_check_always);\n-  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\");\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\");\n@@ -199,2 +199,2 @@\n-  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\", Mutex::_safepoint_check_always);\n-  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\", Mutex::_safepoint_check_always);\n+  Monitor* monitor_rankA = new Monitor(rankA, \"monitor_rankA\");\n+  Monitor* monitor_rankA_plus_one = new Monitor(rankAplusOne, \"monitor_rankA_plus_one\");\n@@ -215,2 +215,3 @@\n-  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", Mutex::_safepoint_check_never);\n-  Monitor* monitor_rank_nosafepoint_minus_one = new Monitor(Mutex::nosafepoint - 1, \"monitor_rank_nosafepoint_minus_one\", Mutex::_safepoint_check_never);\n+  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\");\n+  Monitor* monitor_rank_nosafepoint_minus_one = new Monitor(Mutex::nosafepoint - 1,\n+                                                            \"monitor_rank_nosafepoint_minus_one\");\n@@ -229,2 +230,2 @@\n-    Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\", Mutex::_safepoint_check_never);\n-    Monitor* monitor_rank_event = new Monitor(Mutex::event, \"monitor_rank_event\", Mutex::_safepoint_check_never);\n+    Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\");\n+    Monitor* monitor_rank_event = new Monitor(Mutex::event, \"monitor_rank_event\");\n@@ -241,1 +242,1 @@\n-                   \".* Attempting to wait on monitor monitor_rank_event\/0 while holding lock monitor_rank_tty\/.*\"\n+                   \".* Attempting to wait on monitor monitor_rank_event\/event while holding lock monitor_rank_tty\/tty \"\n@@ -249,1 +250,1 @@\n-                   \".* Attempting to wait on monitor monitor_rank_tty\/.* while holding lock monitor_rank_nosafepoint\/.*\"\n+                   \".* Attempting to wait on monitor monitor_rank_tty\/.* while holding lock monitor_rank_nosafepoint\/.* \"\n@@ -254,2 +255,2 @@\n-  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", Mutex::_safepoint_check_never);\n-  Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\", Mutex::_safepoint_check_never);\n+  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\");\n+  Monitor* monitor_rank_tty = new Monitor(Mutex::tty, \"monitor_rank_tty\");\n@@ -265,1 +266,1 @@\n-                   \".*Safepoint check never locks should always allow the vm to block\") {\n+                   \".*Locks that don't check for safepoint should always allow the vm to block: monitor_rank_nosafepoint\") {\n@@ -269,1 +270,1 @@\n-  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", Mutex::_safepoint_check_never, false);\n+  Monitor* monitor_rank_nosafepoint = new Monitor(Mutex::nosafepoint, \"monitor_rank_nosafepoint\", false);\n@@ -279,1 +280,1 @@\n-  Monitor* monitor_rank_broken = new Monitor(Mutex::event-1, \"monitor_rank_broken\", Mutex::_safepoint_check_never);\n+  Monitor* monitor_rank_broken = new Monitor(Mutex::safepoint-100, \"monitor_rank_broken\");\n@@ -284,2 +285,2 @@\n-TEST_VM_ASSERT_MSG(MutexRank, monitor_nosafepoint_rank,\n-                   \".*failed: Locks above nosafepoint rank should safepoint: monitor_rank_nonleaf\") {\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_overlapping_oopstorage_rank,\n+                   \".*Rank oopstorage-4 overlaps with tty-1\") {\n@@ -289,3 +290,43 @@\n-  Monitor* monitor_rank_nonleaf = new Monitor(Mutex::nonleaf, \"monitor_rank_nonleaf\", Mutex::_safepoint_check_never);\n-  monitor_rank_nonleaf->lock_without_safepoint_check();\n-  monitor_rank_nonleaf->unlock();\n+  Monitor* monitor_rank_broken = new Monitor(Mutex::oopstorage-4, \"monitor_rank_broken\");\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_overlapping_safepoint_rank,\n+                   \".*Rank safepoint-40 overlaps with service-5\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Monitor* monitor_rank_broken = new Monitor(Mutex::safepoint-40, \"monitor_rank_broken\");\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexRank, monitor_overlapping_safepoint_rank2,\n+                   \".*Rank safepoint-1-39 overlaps with service-5\") {\n+  JavaThread* THREAD = JavaThread::current();\n+  ThreadInVMfromNative invm(THREAD);\n+\n+  Monitor* monitor_rank_ok = new Monitor(Mutex::safepoint-1, \"monitor_rank_ok\");\n+  Monitor* monitor_rank_broken = new Monitor(monitor_rank_ok->rank()-39, \"monitor_rank_broken\");\n+}\n+\n+\/\/ Test mismatched safepoint check flag on lock declaration vs. lock acquisition.\n+TEST_VM_ASSERT_MSG(MutexSafepoint, always_check,\n+    \".*This lock should always have a safepoint check for Java threads: SFPT_Test_lock\") {\n+  MutexLocker ml(new Mutex(Mutex::safepoint, \"SFPT_Test_lock\"),\n+                 Mutex::_no_safepoint_check_flag);\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexSafepoint, never_check,\n+    \".*This lock should not be taken with a safepoint check: SFPT_Test_lock\") {\n+  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SFPT_Test_lock\"),\n+                 Mutex::_safepoint_check_flag);\n+}\n+\n+TEST_VM_ASSERT_MSG(MutexSafepoint, possible_safepoint_lock,\n+    \".* Possible safepoint reached by thread that does not allow it\") {\n+  JavaThread* thread = JavaThread::current();\n+  ThreadInVMfromNative in_native(thread);\n+  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SpecialTest_lock\"),\n+                   Mutex::_no_safepoint_check_flag);\n+  thread->print_thread_state_on(tty);\n+  \/\/ If the lock above succeeds, try to safepoint to test the NSV implied with this nosafepoint lock.\n+  ThreadBlockInVM tbivm(thread);\n+  thread->print_thread_state_on(tty);\n","filename":"test\/hotspot\/gtest\/runtime\/test_mutex.cpp","additions":87,"deletions":46,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1,63 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"runtime\/interfaceSupport.inline.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"unittest.hpp\"\n-\n-#ifdef ASSERT\n-\n-\/\/ Test mismatched safepoint check flag on lock declaration vs. lock acquisition.\n-TEST_VM_ASSERT_MSG(SafepointLockAssertTest, always_check,\n-    \".*This lock should always have a safepoint check for Java threads: SFPT_Test_lock\") {\n-  MutexLocker ml(new Mutex(Mutex::nonleaf, \"SFPT_Test_lock\", Mutex::_safepoint_check_always),\n-                 Mutex::_no_safepoint_check_flag);\n-}\n-\n-TEST_VM_ASSERT_MSG(SafepointLockAssertTest, never_check,\n-    \".*This lock should never have a safepoint check for Java threads: SFPT_Test_lock\") {\n-  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SFPT_Test_lock\", Mutex::_safepoint_check_never),\n-                 Mutex::_safepoint_check_flag);\n-}\n-\n-TEST_VM_ASSERT_MSG(SafepointLockAssertTest, nosafepoint_locks,\n-    \".*Locks below nosafepoint rank should never safepoint: SpecialTest_lock\") {\n-  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SpecialTest_lock\", Mutex::_safepoint_check_always),\n-                 Mutex::_safepoint_check_flag);\n-}\n-\n-TEST_VM_ASSERT_MSG(SafepointLockAssertTest, possible_safepoint_lock,\n-    \".* Possible safepoint reached by thread that does not allow it\") {\n-  JavaThread* thread = JavaThread::current();\n-  ThreadInVMfromNative in_native(thread);\n-  MutexLocker ml(new Mutex(Mutex::nosafepoint, \"SpecialTest_lock\", Mutex::_safepoint_check_never),\n-                   Mutex::_no_safepoint_check_flag);\n-  thread->print_thread_state_on(tty);\n-  \/\/ If the lock above succeeds, try to safepoint to test the NSV implied with this nosafepoint lock.\n-  ThreadBlockInVM tbivm(thread);\n-  thread->print_thread_state_on(tty);\n-}\n-\n-#endif \/\/ ASSERT\n","filename":"test\/hotspot\/gtest\/runtime\/test_safepoint_locks.cpp","additions":0,"deletions":63,"binary":false,"changes":63,"status":"deleted"},{"patch":"@@ -199,1 +199,1 @@\n-  Mutex lock(Mutex::nosafepoint, \"Test_lock\", Mutex::_safepoint_check_never);\n+  Mutex lock(Mutex::nosafepoint, \"Test_lock\");\n","filename":"test\/hotspot\/gtest\/utilities\/test_filterQueue.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,3 @@\n+\n+compiler\/vectorapi\/VectorCastShape64Test.java 8274855 generic-x64\n+compiler\/vectorapi\/VectorCastShape128Test.java 8274855 generic-x64\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,2 +123,0 @@\n-resourcehogs\/serviceability\/sa\/TestHeapDumpForLargeArray.java 8274620 macosx-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -292,0 +292,1 @@\n+        UNSAFE.storeFence(); \/\/ Make all new Node fields visible to concurrent readers.\n","filename":"test\/hotspot\/jtreg\/compiler\/gcbarriers\/UnsafeIntrinsicsTest.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8274145\n+ * @summary C2: Incorrect computation after JDK-8269752\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestIfReplacedByMainLoopExit::iMeth -XX:CompileOnly=TestIfReplacedByMainLoopExit::mainTest -XX:-TieredCompilation TestIfReplacedByMainLoopExit\n+ *\n+ *\/\n+\n+public class TestIfReplacedByMainLoopExit {\n+\n+    public static final int N = 400;\n+\n+    public static long instanceCount=3024694135L;\n+    public static boolean bFld=true;\n+    public int iFld=-11;\n+\n+    public static long iMeth_check_sum = 0;\n+\n+    public static void vMeth(int i3, int i4, int i5) {\n+\n+        int i6=-71, i7=88, i8=217, i9=14, i10=9677, i18=-244, i19=107, iArr[]=new int[N];\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static long checkSum(int[] a) {\n+        long sum = 0;\n+        for (int j = 0; j < a.length; j++) {\n+            sum += (a[j] \/ (j + 1) + a[j] % (j + 1));\n+        }\n+        return sum;\n+    }\n+\n+    public static int iMeth(boolean b, int i2) {\n+\n+        byte by=81;\n+        int i21=-24074, i22=7, i23=-7, i24=-70, iArr2[]=new int[N];\n+        boolean b2=false;\n+        init(iArr2, -27);\n+\n+        vMeth(189, i2, i2);\n+        for (int i20 : iArr2) {\n+            by *= (byte) TestIfReplacedByMainLoopExit.instanceCount;\n+            for (i23 = 1; i23 < 4; ++i23) {\n+                i24 -= i23;\n+                TestIfReplacedByMainLoopExit.bFld = b2;\n+            }\n+        }\n+        long meth_res = (b ? 1 : 0) + i2 + by + i21 + i22 + i23 + i24 + (b2 ? 1 : 0) + checkSum(iArr2);\n+        iMeth_check_sum += meth_res;\n+        return (int)meth_res;\n+    }\n+\n+    public void mainTest(String[] strArr1) {\n+        int i, i1, i25, i26=9, i27, i28;\n+        byte by1=35;\n+        float f2;\n+\n+        for (i = 17; 310 > i; ++i) {\n+            i1 = ((iMeth(TestIfReplacedByMainLoopExit.bFld, iFld) - iFld) + by1);\n+        }\n+        i1 = 231;\n+        iFld += -13496;\n+        for (i25 = 2; i25 < 271; i25++) {\n+            i26 -= i;\n+            if (TestIfReplacedByMainLoopExit.bFld) break;\n+        }\n+        i26 = i;\n+        iFld += (int)1.338F;\n+        iFld += 30984;\n+        i27 = 1;\n+        do {\n+            iFld *= i25;\n+            for (i28 = 4; i28 < 75; ++i28) {\n+                i1 += i25;\n+            }\n+        } while (++i27 < 335);\n+        f2 = 210;\n+        do {\n+            iFld -= i25;\n+        } while (--f2 > 0);\n+\n+        System.out.println(\"iFld = \" + iFld);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestIfReplacedByMainLoopExit _instance = new TestIfReplacedByMainLoopExit();\n+        _instance.mainTest(strArr);\n+        int iFld_sav = _instance.iFld;\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.iFld=-11;\n+            _instance.mainTest(strArr);\n+            if (_instance.iFld != iFld_sav) {\n+                throw new RuntimeException(\"incorrect execution \" + _instance.iFld + \" != \" + iFld_sav);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestIfReplacedByMainLoopExit.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8272586\n+ * @requires vm.compiler2.enabled\n+ * @summary Test that abstract machine code is dumped for the top frames in a hs-err log\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run driver MachCodeFramesInErrorFile\n+ *\/\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import java.util.regex.Pattern;\n+import java.util.regex.Matcher;\n+\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.misc.Unsafe;\n+\n+public class MachCodeFramesInErrorFile {\n+\n+    private static class Crasher {\n+        \/\/ Make Crasher.unsafe a compile-time constant so that\n+        \/\/ C2 intrinsifies calls to Unsafe intrinsics.\n+        private static final Unsafe unsafe = Unsafe.getUnsafe();\n+\n+        public static void main(String[] args) throws Exception {\n+            if (args[0].equals(\"crashInJava\")) {\n+                \/\/ This test relies on Unsafe.putLong(Object, long, long) being intrinsified\n+                if (!Stream.of(Unsafe.class.getDeclaredMethod(\"putLong\", Object.class, long.class, long.class).getAnnotations()).\n+                    anyMatch(a -> a.annotationType().getName().equals(\"jdk.internal.vm.annotation.IntrinsicCandidate\"))) {\n+                    throw new RuntimeException(\"Unsafe.putLong(Object, long, long) is not an intrinsic\");\n+                }\n+                crashInJava1(10);\n+            } else {\n+                assert args[0].equals(\"crashInVM\");\n+                crashInNative1(10);\n+            }\n+        }\n+\n+        static void crashInJava1(long address) {\n+            System.out.println(\"in crashInJava1\");\n+            crashInJava2(address);\n+        }\n+        static void crashInJava2(long address) {\n+            System.out.println(\"in crashInJava2\");\n+            crashInJava3(address);\n+        }\n+        static void crashInJava3(long address) {\n+            unsafe.putLong(null, address, 42);\n+            System.out.println(\"wrote value to 0x\" + Long.toHexString(address));\n+        }\n+\n+        static void crashInNative1(long address) {\n+            System.out.println(\"in crashInNative1\");\n+            crashInNative2(address);\n+        }\n+        static void crashInNative2(long address) {\n+            System.out.println(\"in crashInNative2\");\n+            crashInNative3(address);\n+        }\n+        static void crashInNative3(long address) {\n+            System.out.println(\"read value \" + unsafe.getLong(address) + \" from 0x\" + Long.toHexString(address));\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        run(true);\n+        run(false);\n+    }\n+\n+    \/**\n+     * Runs Crasher in Xcomp mode. The inner\n+     * most method crashes the VM with Unsafe. The resulting hs-err log is\n+     * expected to have a min number of MachCode sections.\n+     *\/\n+    private static void run(boolean crashInJava) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+            \"-Xmx64m\", \"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\",\n+            \"-XX:-CreateCoredumpOnCrash\",\n+            \"-Xcomp\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:CompileCommand=compileonly,MachCodeFramesInErrorFile$Crasher.crashIn*\",\n+            \"-XX:CompileCommand=dontinline,MachCodeFramesInErrorFile$Crasher.crashIn*\",\n+            \"-XX:CompileCommand=dontinline,*\/Unsafe.getLong\", \/\/ ensures VM call when crashInJava == false\n+            Crasher.class.getName(),\n+            crashInJava ? \"crashInJava\" : \"crashInVM\");\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+\n+        \/\/ Extract hs_err_pid file.\n+        String hs_err_file = output.firstMatch(\"# *(\\\\S*hs_err_pid\\\\d+\\\\.log)\", 1);\n+        if (hs_err_file == null) {\n+            throw new RuntimeException(\"Did not find hs_err_pid file in output.\\n\" +\n+                                       \"stderr:\\n\" + output.getStderr() + \"\\n\" +\n+                                       \"stdout:\\n\" + output.getStdout());\n+        }\n+        Path hsErrPath = Paths.get(hs_err_file);\n+        if (!Files.exists(hsErrPath)) {\n+            throw new RuntimeException(\"hs_err_pid file missing at \" + hsErrPath + \".\\n\");\n+        }\n+        String hsErr = Files.readString(hsErrPath);\n+        if (System.getenv(\"DEBUG\") != null) {\n+            System.err.println(hsErr);\n+        }\n+        Set<String> frames = new HashSet<>();\n+        extractFrames(hsErr, frames, true);\n+        if (!crashInJava) {\n+            \/\/ A crash in native will have Java frames in the hs-err log\n+            \/\/ as there is a Java frame anchor on the stack.\n+            extractFrames(hsErr, frames, false);\n+        }\n+        int compiledJavaFrames = (int) frames.stream().filter(f -> f.startsWith(\"J \")).count();\n+\n+        Matcher matcherDisasm = Pattern.compile(\"\\\\[Disassembly\\\\].*\\\\[\/Disassembly\\\\]\", Pattern.DOTALL).matcher(hsErr);\n+        if (matcherDisasm.find()) {\n+            \/\/ Real disassembly is present, no MachCode is expected.\n+            return;\n+        }\n+\n+        Matcher matcher = Pattern.compile(\"\\\\[MachCode\\\\]\\\\s*\\\\[Verified Entry Point\\\\]\\\\s*  # \\\\{method\\\\} \\\\{[^}]*\\\\} '([^']+)' '([^']+)' in '([^']+)'\", Pattern.DOTALL).matcher(hsErr);\n+        List<String> machCodeHeaders = matcher.results().map(mr -> String.format(\"'%s' '%s' in '%s'\", mr.group(1), mr.group(2), mr.group(3))).collect(Collectors.toList());\n+        int minExpectedMachCodeSections = Math.max(1, compiledJavaFrames);\n+        if (machCodeHeaders.size() < minExpectedMachCodeSections) {\n+            Asserts.fail(machCodeHeaders.size() + \" < \" + minExpectedMachCodeSections);\n+        }\n+    }\n+\n+    \/**\n+     * Extracts the lines in {@code hsErr} below the line starting with\n+     * \"Native frames:\" or \"Java frames:\" up to the next blank line\n+     * and adds them to {@code frames}.\n+     *\/\n+    private static void extractFrames(String hsErr, Set<String> frames, boolean nativeStack) {\n+        String marker = (nativeStack ? \"Native\" : \"Java\") + \" frames: \";\n+        boolean seenMarker = false;\n+        for (String line : hsErr.split(System.lineSeparator())) {\n+            if (line.startsWith(marker)) {\n+                seenMarker = true;\n+            } else if (seenMarker) {\n+                if (line.trim().isEmpty()) {\n+                    return;\n+                }\n+                frames.add(line);\n+            }\n+        }\n+        throw new RuntimeException(\"\\\"\" + marker + \"\\\" line missing in hs_err_pid file:\\n\" + hsErr);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/ErrorHandling\/MachCodeFramesInErrorFile.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -61,0 +61,2 @@\n+        \"UseSharedSpaces: Header checksum verification failed.\",\n+        \"The shared archive file has an incorrect header size.\",\n@@ -161,1 +163,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic, -1);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetMagic(), -1);\n@@ -173,1 +175,1 @@\n-        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion, 0x00000000);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetVersion(), 0x00000000);\n@@ -216,0 +218,1 @@\n+        \/\/ modify contents in random area\n@@ -221,0 +224,11 @@\n+\n+        \/\/ modify _base_archive_path_offet to non-zero\n+        System.out.println(\"\\n8. modify _base_archive_path_offset to non-zero\\n\");\n+        String baseArchivePathOffsetName = startNewArchive(\"base-arhive-path-offset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, baseArchivePathOffsetName);\n+        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        System.out.println(\"    baseArchivePathOffset = \" + baseArchivePathOffset);\n+        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), 1024);\n+        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        System.out.println(\"new baseArchivePathOffset = \" + baseArchivePathOffset);\n+        testAndCheck(verifyExecArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":16,"deletions":2,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import jdk.test.lib.cds.CDSTestUtils;\n@@ -55,0 +56,25 @@\n+    static void runTwo(String base, String top,\n+                       String jarName, String mainClassName, int exitValue,\n+                       String ... checkMessages) throws Exception {\n+        CDSTestUtils.Result result = run2(base, top,\n+                \"-Xlog:cds\",\n+                \"-Xlog:cds+dynamic=debug\",\n+                \"-XX:+VerifySharedSpaces\",\n+                \"-cp\",\n+                jarName,\n+                mainClassName);\n+        if (exitValue == 0) {\n+            result.assertNormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        } else {\n+            result.assertAbnormalExit( output -> {\n+                for (String s : checkMessages) {\n+                    output.shouldContain(s);\n+                }\n+            });\n+        }\n+    }\n+\n@@ -71,1 +97,2 @@\n-        \/\/ Modify the CRC values in the header of the top archive.\n+        \/\/ 1. Modify the CRC values in the header of the top archive.\n+        System.out.println(\"\\n1. Modify the CRC values in the header of the top archive\");\n@@ -76,10 +103,55 @@\n-        run2(baseArchiveName, modTop,\n-            \"-Xlog:class+load\",\n-            \"-Xlog:cds+dynamic=debug,cds=debug\",\n-            \"-XX:+VerifySharedSpaces\",\n-            \"-cp\", appJar, mainClass)\n-            .assertAbnormalExit(output -> {\n-                    output.shouldContain(\"Header checksum verification failed\")\n-                          .shouldContain(\"Unable to use shared archive\")\n-                          .shouldHaveExitValue(1);\n-                });\n+        runTwo(baseArchiveName, modTop,\n+               appJar, mainClass, 1,\n+               new String[] {\"Header checksum verification failed\",\n+                             \"Unable to use shared archive\"});\n+\n+        \/\/ 2. Make header size larger than the archive size\n+        System.out.println(\"\\n2. Make header size larger than the archive size\");\n+        String largerHeaderSize = getNewArchiveName(\"largerHeaderSize\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, largerHeaderSize);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetHeaderSize(),  (int)copiedJsa.length() + 1024);\n+        runTwo(baseArchiveName, largerHeaderSize,\n+               appJar, mainClass, 1,\n+               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+                             \"Unable to use shared archive\"});\n+\n+        \/\/ 3. Make base archive path offset beyond of header size\n+        System.out.println(\"\\n3. Make base archive path offset beyond of header size.\");\n+        String wrongBaseArchivePathOffset = getNewArchiveName(\"wrongBaseArchivePathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseArchivePathOffset);\n+        int fileHeaderSize = (int)CDSArchiveUtils.fileHeaderSize(copiedJsa);\n+        int baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, CDSArchiveUtils.offsetBaseArchivePathOffset(), baseArchivePathOffset + 1024);\n+        runTwo(baseArchiveName, wrongBaseArchivePathOffset,\n+               appJar, mainClass, 1,\n+               new String[] {\"_header_size should be equal to _base_archive_path_offset plus _base_archive_name_size\",\n+                             \"The shared archive file has an incorrect header size\",\n+                             \"Unable to use shared archive\"});\n+\n+        \/\/ 4. Make base archive path offset points to middle of name size\n+        System.out.println(\"\\n4. Make base archive path offset points to middle of name size\");\n+        String wrongBasePathOffset = getNewArchiveName(\"wrongBasePathOffset\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBasePathOffset);\n+        int baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        CDSArchiveUtils.modifyHeaderIntField(copiedJsa, baseArchivePathOffset,\n+                                             baseArchivePathOffset + baseArchiveNameSize\/2);\n+        runTwo(baseArchiveName, wrongBasePathOffset,\n+               appJar, mainClass, 1,\n+               new String[] {\"An error has occurred while processing the shared archive file.\",\n+                             \"Header checksum verification failed\",\n+                             \"Unable to use shared archive\"});\n+        \/\/ 5. Make base archive name not terminated with '\\0'\n+        System.out.println(\"\\n5. Make base archive name not terminated with '\\0'\");\n+        String wrongBaseName = getNewArchiveName(\"wrongBaseName\");\n+        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongBaseName);\n+        baseArchivePathOffset = CDSArchiveUtils.baseArchivePathOffset(copiedJsa);\n+        baseArchiveNameSize = CDSArchiveUtils.baseArchiveNameSize(copiedJsa);\n+        long offset = baseArchivePathOffset + baseArchiveNameSize - 1;  \/\/ end of line\n+        CDSArchiveUtils.writeData(copiedJsa, offset, new byte[] {(byte)'X'});\n+\n+        runTwo(baseArchiveName, wrongBaseName,\n+               appJar, mainClass, 1,\n+               new String[] {\"Base archive \" + baseArchiveName,\n+                             \" does not exist\",\n+                             \"Header checksum verification failed\"});\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":83,"deletions":11,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -55,0 +55,17 @@\n+\/**\n+ * @test id=custom-cl-zgc\n+ * @requires vm.cds.custom.loaders\n+ * @requires vm.gc.Z\n+ * @summary Test dumptime_table entries are removed with zgc eager class unloading\n+ * @bug 8274935\n+ * @library \/test\/lib\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/test-classes\n+ *          \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\n+ * @modules java.base\/jdk.internal.misc\n+ *          jdk.httpserver\n+ * @build sun.hotspot.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller sun.hotspot.WhiteBox\n+ * @run main\/othervm\/timeout=180 -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xbootclasspath\/a:. DynamicLoaderConstraintsTest custom-zgc\n+ *\/\n+\n@@ -86,0 +103,1 @@\n+    static boolean useZGC;\n@@ -89,0 +107,1 @@\n+        useZGC = (args.length != 0 && args[0].equals(\"custom-zgc\"));\n@@ -127,2 +146,9 @@\n-                cmdLine = TestCommon.concat(cmdLine, \"-cp\", loaderJar,\n-                                          loaderMainClass, appJar);\n+                if (useZGC) {\n+                    \/\/ Add options to force eager class unloading.\n+                    cmdLine = TestCommon.concat(cmdLine, \"-cp\", loaderJar,\n+                                                \"-XX:+UseZGC\", \"-XX:ZCollectionInterval=0.01\",\n+                                                loaderMainClass, appJar);\n+                } else {\n+                    cmdLine = TestCommon.concat(cmdLine, \"-cp\", loaderJar,\n+                                                loaderMainClass, appJar);\n+                }\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/loaderConstraints\/DynamicLoaderConstraintsTest.java","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -385,0 +385,3 @@\n+jdk_editpad = \\\n+     jdk\/editpad\n+\n@@ -394,1 +397,2 @@\n-    :jdk_client_sanity\n+    :jdk_client_sanity \\\n+    :jdk_editpad\n","filename":"test\/jdk\/TEST.groups","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-import java.util.stream.Collectors;\n@@ -147,0 +146,9 @@\n+            @Override\n+            public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {\n+                String dirName = dir.toString();\n+                if (dirName.endsWith(\".dSYM\")) {\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+                return super.preVisitDirectory(dir, attrs);\n+            }\n+\n","filename":"test\/jdk\/build\/AbsPathsInImage.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-  @run main\/manual=yesno DialogOrient\n+  @run main\/manual DialogOrient\n","filename":"test\/jdk\/java\/awt\/print\/Dialog\/DialogOrient.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- *      8228469\n+ *      8228469 8274407\n@@ -105,1 +105,1 @@\n-            new ZoneDescriptor(\"MIT\", 780, true),\n+            new ZoneDescriptor(\"MIT\", 780, false), \/\/ Samoa no longer observes DST starting 2021b\n","filename":"test\/jdk\/java\/util\/TimeZone\/TimeZoneTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @requires vm.hasJFR\n+ * @requires vm.hasJFR & vm.compiler1.enabled\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestRecordedFrameType.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n- * @requires vm.gc != \"Z\"\n+ * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestObjectDescription.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.oldobject;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.internal.test.WhiteBox;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.gc.Shenandoah\n+ * @summary Test leak profiler with Shenandoah\n+ * @library \/test\/lib \/test\/jdk\n+ * @modules jdk.jfr\/jdk.jfr.internal.test\n+ * @run main\/othervm  -XX:TLABSize=2k -XX:+UseShenandoahGC jdk.jfr.event.oldobject.TestShenandoah\n+ *\/\n+public class TestShenandoah {\n+\n+    static private class FindMe {\n+    }\n+\n+    public static List<FindMe[]> list = new ArrayList<>(OldObjects.MIN_SIZE);\n+\n+    public static void main(String[] args) throws Exception {\n+        WhiteBox.setWriteAllObjectSamples(true);\n+\n+        while (true) {\n+            try (Recording r = new Recording()) {\n+                r.enable(EventNames.OldObjectSample).withStackTrace().with(\"cutoff\", \"infinity\");\n+                r.start();\n+                allocateFindMe();\n+                System.gc();\n+                r.stop();\n+                List<RecordedEvent> events = Events.fromRecording(r);\n+                System.out.println(events);\n+                if (OldObjects.countMatchingEvents(events, FindMe[].class, null, null, -1, \"allocateFindMe\") > 0) {\n+                    return;\n+                }\n+                System.out.println(\"Could not find leaking object, retrying...\");\n+            }\n+            list.clear();\n+        }\n+    }\n+\n+    public static void allocateFindMe() {\n+        for (int i = 0; i < OldObjects.MIN_SIZE; i++) {\n+            \/\/ Allocate array to trigger sampling code path for interpreter \/ c1\n+            list.add(new FindMe[0]);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/jdk\/jfr\/event\/oldobject\/TestShenandoah.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.util.JarUtils;\n+\n+import java.nio.file.*;\n+import java.security.Security;\n+import java.util.Collections;\n+\n+\n+\/**\n+ * @test\n+ * @bug 8273826\n+ * @summary Test for signed jar file with lowercase META-INF files\n+ * @library \/test\/lib ..\/\n+ * @build jdk.test.lib.util.JarUtils\n+ * @run main LowerCaseManifest\n+ *\/\n+public class LowerCaseManifest extends Test {\n+\n+    public static void main(String[] args) throws Throwable {\n+        new LowerCaseManifest().start();\n+    }\n+\n+    private void start() throws Throwable {\n+        \/\/ create a jar file that contains one class file\n+        Utils.createFiles(FIRST_FILE);\n+        JarUtils.createJar(UNSIGNED_JARFILE, FIRST_FILE);\n+\n+        \/\/ create key pair for jar signing\n+        createAlias(CA_KEY_ALIAS, \"-ext\", \"bc:c\");\n+        createAlias(KEY_ALIAS);\n+\n+        issueCert(KEY_ALIAS);\n+\n+        \/\/ sign jar\n+        OutputAnalyzer analyzer = jarsigner(\n+                \"-keystore\", KEYSTORE,\n+                \"-verbose\",\n+                \"-storepass\", PASSWORD,\n+                \"-keypass\", PASSWORD,\n+                \"-signedjar\", SIGNED_JARFILE,\n+                UNSIGNED_JARFILE,\n+                KEY_ALIAS);\n+\n+        checkSigning(analyzer);\n+\n+        \/\/ verify signed jar\n+        analyzer = jarsigner(\n+                \"-verify\",\n+                \"-verbose\",\n+                \"-keystore\", KEYSTORE,\n+                \"-storepass\", PASSWORD,\n+                \"-keypass\", PASSWORD,\n+                SIGNED_JARFILE,\n+                KEY_ALIAS);\n+\n+        checkVerifying(analyzer, 0, JAR_VERIFIED);\n+\n+        \/\/ verify signed jar in strict mode\n+        analyzer = jarsigner(\n+                \"-verify\",\n+                \"-verbose\",\n+                \"-strict\",\n+                \"-keystore\", KEYSTORE,\n+                \"-storepass\", PASSWORD,\n+                \"-keypass\", PASSWORD,\n+                SIGNED_JARFILE,\n+                KEY_ALIAS);\n+\n+        checkVerifying(analyzer, 0, JAR_VERIFIED);\n+\n+        \/\/ convert the META-INF\/ files to lower case\n+        FileSystem fs = FileSystems.newFileSystem(Path.of(SIGNED_JARFILE), Collections.emptyMap());\n+        for (String s : new String[]{\"ALIAS.SF\",  \"ALIAS.RSA\", \"MANIFEST.MF\"}) {\n+            Path origPath = fs.getPath(\"META-INF\/\" + s);\n+            Path lowerCase = fs.getPath(\"META-INF\/\" + s.toLowerCase());\n+            Files.write(lowerCase, Files.readAllBytes(origPath));\n+            Files.delete(origPath);\n+        }\n+        fs.close();\n+\n+        \/\/ verify signed jar in strict mode (with lower case META-INF names in place)\n+        analyzer = jarsigner(\n+                \"-verify\",\n+                \"-verbose\",\n+                \"-strict\",\n+                \"-J-Djava.security.debug=jar\",\n+                \"-keystore\", KEYSTORE,\n+                \"-storepass\", PASSWORD,\n+                \"-keypass\", PASSWORD,\n+                SIGNED_JARFILE,\n+                KEY_ALIAS);\n+\n+        checkVerifying(analyzer, 0,\n+                JAR_VERIFIED, \"!not present in verifiedSigners\");\n+        System.out.println(\"Test passed\");\n+    }\n+\n+}\n","filename":"test\/jdk\/sun\/security\/tools\/jarsigner\/warnings\/LowerCaseManifest.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658 8246774\n+ * @bug 8205418 8207229 8207230 8230847 8245786 8247334 8248641 8240658 8246774 8274347\n@@ -91,0 +91,1 @@\n+        new TestGetScopeResult().testNestedSwitchExpression();\n@@ -754,0 +755,71 @@\n+    void testNestedSwitchExpression() throws IOException {\n+        JavacTool c = JavacTool.create();\n+        try (StandardJavaFileManager fm = c.getStandardFileManager(null, null, null)) {\n+            String code = \"\"\"\n+                          class Test {\n+                              void t(Object o1, Object o2) {\n+                                  System.err.println(switch (o1) {\n+                                    case String s -> switch (j) {\n+                                        case Integer i -> {\n+                                            int scopeHere;\n+                                            yield \"\";\n+                                        }\n+                                        default -> \"\";\n+                                    };\n+                                    default -> \"\";\n+                                  });\n+                              }\n+                          }\n+                          \"\"\";\n+            class MyFileObject extends SimpleJavaFileObject {\n+                MyFileObject() {\n+                    super(URI.create(\"myfo:\/\/\/Test.java\"), SOURCE);\n+                }\n+                @Override\n+                public String getCharContent(boolean ignoreEncodingErrors) {\n+                    return code;\n+                }\n+            }\n+            Context ctx = new Context();\n+            TestAnalyzer.preRegister(ctx);\n+            JavacTask t = (JavacTask) c.getTask(null, fm, null, null, null,\n+                                                List.of(new MyFileObject()), ctx);\n+            CompilationUnitTree cut = t.parse().iterator().next();\n+            t.analyze();\n+\n+            List<List<String>> actual = new ArrayList<>();\n+\n+            new TreePathScanner<Void, Void>() {\n+                @Override\n+                public Void visitVariable(VariableTree node, Void p) {\n+                    if (node.getName().contentEquals(\"scopeHere\")) {\n+                        Scope scope = Trees.instance(t).getScope(getCurrentPath());\n+                        actual.add(dumpScope(scope));\n+                        JCTree body = getCaseBody(scope);\n+                        if (body == null) {\n+                            throw new AssertionError(\"Unexpected null body.\");\n+                        }\n+                    }\n+                    return super.visitVariable(node, p);\n+                }\n+                JCTree getCaseBody(Scope scope) {\n+                    return ((JCCase) ((JavacScope) scope).getEnv().next.next.tree).body;\n+                }\n+            }.scan(cut, null);\n+\n+            List<List<String>> expected =\n+                    List.of(List.of(\"scopeHere:int\",\n+                                    \"i:java.lang.Integer\",\n+                                    \"s:java.lang.String\",\n+                                    \"o2:java.lang.Object\",\n+                                    \"o1:java.lang.Object\",\n+                                    \"super:java.lang.Object\",\n+                                    \"this:Test\"\n+                                ));\n+\n+            if (!expected.equals(actual)) {\n+                throw new AssertionError(\"Unexpected Scope content: \" + actual);\n+            }\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/api\/TestGetScopeResult.java","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * @bug 8206986 8254286\n+ * @bug 8206986 8254286 8274347\n@@ -86,0 +86,10 @@\n+    void preflow(int i, int j) {\n+        System.out.println(switch (i) {\n+            case 1 -> switch (j) {\n+                    case 1 -> \"one and one\";\n+                    default -> \"one and many\";\n+                };\n+            case 2 -> \"two\";\n+            default -> \"many\";\n+        });\n+    }\n","filename":"test\/langtools\/tools\/javac\/switchexpr\/ExpressionSwitchInfer.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -49,7 +49,10 @@\n-    public static int offsetMagic;                \/\/ CDSFileMapHeaderBase::_magic\n-    public static int offsetVersion;              \/\/ CDSFileMapHeaderBase::_version\n-    public static int offsetJvmIdent;             \/\/ FileMapHeader::_jvm_ident\n-    public static int offsetBaseArchiveNameSize;  \/\/ FileMapHeader::_base_archive_name_size\n-    public static int spOffsetCrc;                \/\/ CDSFileMapRegion::_crc\n-    public static int spOffset;                   \/\/ offset of CDSFileMapRegion\n-    public static int spUsedOffset;               \/\/ offset of CDSFileMapRegion::_used\n+    private static int offsetMagic;                \/\/ offset of GenericCDSFileMapHeader::_magic\n+    private static int offsetCrc;                  \/\/ offset of GenericCDSFileMapHeader::_crc\n+    private static int offsetVersion;              \/\/ offset of GenericCDSFileMapHeader::_version\n+    private static int offsetHeaderSize;           \/\/ offset of GenericCDSFileMapHeader::_header_size\n+    private static int offsetBaseArchivePathOffset;\/\/ offset of GenericCDSFileMapHeader::_base_archive_path_offset\n+    private static int offsetBaseArchiveNameSize;  \/\/ offset of GenericCDSFileMapHeader::_base_archive_name_size\n+    private static int offsetJvmIdent;             \/\/ offset of FileMapHeader::_jvm_ident\n+    private static int spOffsetCrc;                \/\/ offset of CDSFileMapRegion::_crc\n+    private static int spOffset;                   \/\/ offset of CDSFileMapRegion\n+    private static int spUsedOffset;               \/\/ offset of CDSFileMapRegion::_used\n@@ -57,8 +60,8 @@\n-    public static int staticMagic;                \/\/ static magic value defined in hotspot\n-    public static int dynamicMagic;               \/\/ dyamic magic value defined in hotspot\n-    public static int sizetSize;                  \/\/ size of size_t\n-    public static int intSize;                    \/\/ size of int\n-    public static int staticArchiveHeaderSize;    \/\/ static archive file header size\n-    public static int dynamicArchiveHeaderSize;   \/\/ dynamic archive file header size\n-    public static int cdsFileMapRegionSize;       \/\/ size of CDSFileMapRegion\n-    public static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n+    private static int staticMagic;                \/\/ static magic value defined in hotspot\n+    private static int dynamicMagic;               \/\/ dyamic magic value defined in hotspot\n+    private static int sizetSize;                  \/\/ size of size_t\n+    private static int intSize;                    \/\/ size of int\n+    private static int staticArchiveHeaderSize;    \/\/ static archive file header size\n+    private static int dynamicArchiveHeaderSize;   \/\/ dynamic archive file header size\n+    private static int cdsFileMapRegionSize;       \/\/ size of CDSFileMapRegion\n+    private static long alignment;                 \/\/ MetaspaceShared::core_region_alignment\n@@ -67,1 +70,1 @@\n-    public static String[] shared_region_name = {\n+    private static String[] shared_region_name = {\n@@ -76,1 +79,1 @@\n-    public static int num_regions = shared_region_name.length;\n+    private static int num_regions = shared_region_name.length;\n@@ -83,2 +86,6 @@\n-            offsetMagic = wb.getCDSOffsetForName(\"CDSFileMapHeaderBase::_magic\");\n-            offsetVersion = wb.getCDSOffsetForName(\"CDSFileMapHeaderBase::_version\");\n+            offsetMagic = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_magic\");\n+            offsetCrc = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_crc\");\n+            offsetVersion = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_version\");\n+            offsetHeaderSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_header_size\");\n+            offsetBaseArchivePathOffset = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_path_offset\");\n+            offsetBaseArchiveNameSize = wb.getCDSOffsetForName(\"GenericCDSFileMapHeader::_base_archive_name_size\");\n@@ -86,1 +93,0 @@\n-            offsetBaseArchiveNameSize = wb.getCDSOffsetForName(\"FileMapHeader::_base_archive_name_size\");\n@@ -93,0 +99,1 @@\n+            \/\/ following two sizes are runtime values\n@@ -99,2 +106,0 @@\n-            \/\/ file_header_size is structure size, real size aligned with alignment\n-            \/\/ so must be calculated after alignment is available\n@@ -113,0 +118,23 @@\n+    \/\/ accessors\n+    \/\/ offsets\n+    public static int offsetMagic()                 { return offsetMagic;                 }\n+    public static int offsetCrc()                   { return offsetCrc;                   }\n+    public static int offsetVersion()               { return offsetVersion;               }\n+    public static int offsetHeaderSize()            { return offsetHeaderSize;            }\n+    public static int offsetBaseArchivePathOffset() { return offsetBaseArchivePathOffset; }\n+    public static int offsetBaseArchiveNameSize()   { return offsetBaseArchiveNameSize;   }\n+    public static int offsetJvmIdent()              { return offsetJvmIdent;              }\n+    public static int spOffsetCrc()                 { return spOffsetCrc;                 }\n+    public static int spOffset()                    { return spOffset;                    }\n+    public static int spUsedOffset()                { return spUsedOffset;                }\n+    \/\/ constants\n+    public static int staticMagic()                 { return staticMagic;                 }\n+    public static int dynamicMagic()                { return dynamicMagic;                }\n+    public static int sizetSize()                   { return sizetSize;                   }\n+    public static int staticArchiveHeaderSize()     { return staticArchiveHeaderSize;     }\n+    public static int dynamicArchiveHeaderSize()    { return dynamicArchiveHeaderSize;    }\n+    public static int cdsFileMapRegionSize()        { return cdsFileMapRegionSize;        }\n+    public static long alignment()                  { return alignment;                   }\n+\n+\n+\n@@ -114,10 +142,21 @@\n-      long magicValue = readInt(jsaFile, offsetMagic, 4);\n-      if (magicValue == staticMagic) {\n-          return alignUpWithAlignment((long)staticArchiveHeaderSize);\n-      } else if (magicValue == dynamicMagic) {\n-          \/\/ dynamic archive store base archive name after header, so we count it in header size.\n-          int baseArchiveNameSize = (int)readInt(jsaFile, (long)offsetBaseArchiveNameSize, 4);\n-          return alignUpWithAlignment((long)dynamicArchiveHeaderSize + baseArchiveNameSize);\n-      } else {\n-          throw new RuntimeException(\"Wrong magic value from archive file: \" + magicValue);\n-      }\n+        long  headerSize = readInt(jsaFile, offsetHeaderSize, 4);\n+        return headerSize;\n+    }\n+\n+    public static long fileHeaderSizeAligned(File jsaFile) throws Exception {\n+        long size = fileHeaderSize(jsaFile);\n+        return alignUpWithAlignment(size);\n+    }\n+\n+    public static int baseArchivePathOffset(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n+    }\n+\n+    public static int baseArchiveNameSize(File jsaFile) throws Exception {\n+        return (int)readInt(jsaFile, offsetBaseArchiveNameSize, 4);\n+    }\n+\n+    public static String baseArchiveName(File jsaFile) throws Exception {\n+        int size = baseArchiveNameSize(jsaFile);\n+        int baseArchivePathOffset = (int)readInt(jsaFile, offsetBaseArchivePathOffset, 4);\n+        return readString(jsaFile, baseArchivePathOffset, size - 1); \/\/ exclude terminating '\\0'\n@@ -162,1 +201,1 @@\n-        start0 = fileHeaderSize(jsaFile);\n+        start0 = fileHeaderSizeAligned(jsaFile);\n@@ -191,1 +230,1 @@\n-        start0 = fileHeaderSize(jsaFile);\n+        start0 = fileHeaderSizeAligned(jsaFile);\n@@ -228,1 +267,1 @@\n-        long regionStartOffset = fileHeaderSize(jsaFile);\n+        long regionStartOffset = fileHeaderSizeAligned(jsaFile);\n@@ -233,1 +272,1 @@\n-                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSize(jsaFile)) + \")\");\n+                           + \" (header_size + 0x\" + Long.toHexString(regionStartOffset - fileHeaderSizeAligned(jsaFile)) + \")\");\n@@ -265,0 +304,4 @@\n+    public static void modifyFileHeaderSize(File jsaFile, int newHeaderSize) throws Exception {\n+        modifyHeaderIntField(jsaFile, offsetHeaderSize, newHeaderSize);\n+    }\n+\n@@ -271,4 +314,1 @@\n-        System.out.println(\"    offset \" + offset);\n-\n-        byte[] bytes = ByteBuffer.allocate(4).putInt(value).array();\n-        writeData(jsaFile, offset, bytes);\n+        writeData(jsaFile, offset, value);\n@@ -303,1 +343,1 @@\n-    public static long readInt(File file, long offset, int nBytes) throws Exception {\n+    private static long readInt(File file, long offset, int nBytes) throws Exception {\n@@ -305,2 +345,1 @@\n-            ByteBuffer bb = ByteBuffer.allocate(nBytes);\n-            bb.order(ByteOrder.nativeOrder());\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes).order(ByteOrder.nativeOrder());\n@@ -309,0 +348,1 @@\n+            bb.rewind();\n@@ -313,0 +353,14 @@\n+    private static String readString(File file, long offset, int nBytes) throws Exception {\n+        try (FileChannel fc = getFileChannel(file, false \/*read only*\/)) {\n+            ByteBuffer bb = ByteBuffer.allocate(nBytes).order(ByteOrder.nativeOrder());\n+            fc.position(offset);\n+            fc.read(bb);\n+            byte[] arr = bb.flip().array();\n+            for (byte i : arr) {\n+                System.out.print((char)i);\n+            }\n+            System.out.println(\"\");\n+            return new String(arr);\n+        }\n+    }\n+\n@@ -321,0 +375,1 @@\n+            bbuf.order(ByteOrder.nativeOrder());\n@@ -327,1 +382,4 @@\n-            ByteBuffer bbuf = ByteBuffer.allocate(4).putInt(value).position(0);\n+            ByteBuffer bbuf = ByteBuffer.allocate(4)\n+                                        .order(ByteOrder.nativeOrder())\n+                                        .putInt(value)\n+                                        .rewind();\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":102,"deletions":44,"binary":false,"changes":146,"status":"modified"}]}