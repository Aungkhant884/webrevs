{"files":[{"patch":"@@ -74,25 +74,0 @@\n-void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs_nm == nullptr) {\n-    return;\n-  }\n-\n-  __ block_comment(\"nmethod_entry_barrier (nmethod_entry_barrier) {\");\n-\n-    \/\/ Load jump addr:\n-    __ load_const(Z_R1_scratch, (uint64_t)StubRoutines::zarch::nmethod_entry_barrier()); \/\/ 2*6 bytes\n-\n-    \/\/ Load value from current java object:\n-    __ z_lg(Z_R0_scratch, in_bytes(bs_nm->thread_disarmed_offset()), Z_thread); \/\/ 6 bytes\n-\n-    \/\/ Compare to current patched value:\n-    __ z_cfi(Z_R0_scratch, \/* to be patched *\/ -1); \/\/ 6 bytes (2 + 4 byte imm val)\n-\n-    \/\/ Conditional Jump\n-    __ z_larl(Z_R14, (Assembler::instr_len((unsigned long)LARL_ZOPC) + Assembler::instr_len((unsigned long)BCR_ZOPC)) \/ 2); \/\/ 6 bytes\n-    __ z_bcr(Assembler::bcondNotEqual, Z_R1_scratch); \/\/ 2 bytes\n-\n-    \/\/ Fall through to method body.\n-  __ block_comment(\"} nmethod_entry_barrier (nmethod_entry_barrier)\");\n-}\n-\n@@ -133,0 +108,64 @@\n+void BarrierSetAssembler::nmethod_entry_barrier(MacroAssembler* masm) {\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm == nullptr) {\n+    return;\n+  }\n+\n+  __ block_comment(\"nmethod_entry_barrier (nmethod_entry_barrier) {\");\n+\n+    \/\/ Load jump addr:\n+    __ load_const(Z_R1_scratch, (uint64_t)StubRoutines::zarch::nmethod_entry_barrier()); \/\/ 2*6 bytes\n+\n+    \/\/ Load value from current java object:\n+    __ z_lg(Z_R0_scratch, in_bytes(bs_nm->thread_disarmed_offset()), Z_thread); \/\/ 6 bytes\n+\n+    \/\/ Compare to current patched value:\n+    __ z_cfi(Z_R0_scratch, \/* to be patched *\/ -1); \/\/ 6 bytes (2 + 4 byte imm val)\n+\n+    \/\/ Conditional Jump\n+    __ z_larl(Z_R14, (Assembler::instr_len((unsigned long)LARL_ZOPC) + Assembler::instr_len((unsigned long)BCR_ZOPC)) \/ 2); \/\/ 6 bytes\n+    __ z_bcr(Assembler::bcondNotEqual, Z_R1_scratch); \/\/ 2 bytes\n+\n+    \/\/ Fall through to method body.\n+  __ block_comment(\"} nmethod_entry_barrier (nmethod_entry_barrier)\");\n+}\n+\n+void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n+  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n+  if (bs_nm == nullptr) {\n+    return;\n+  }\n+\n+  Label bad_call, skip_barrier;\n+\n+  __ block_comment(\"c2i_entry_barrier (c2i_entry_barrier) {\");\n+\n+  \/\/ Fast path: If no method is given, the call is definitely bad.\n+  __ cfi(Z_method, 0);\n+  __ z_bre(bad_call); \/\/ Diff instr for jumping to a label?\n+\n+  \/\/ Load class loader data to determine whether the method's holder is concurrently unloading.\n+  __ load_method_holder(Z_R0_scratch, Z_method);\n+  __ lg(Z_R0_scratch, in_bytes(InstanceKlass::class_loader_data_offset()), Z_R0_scratch);\n+\n+  \/\/ Fast path: If class loader is strong, the holder cannot be unloaded.\n+  __ llgf(Z_R1_scratch, in_bytes(ClassLoaderData::keep_alive_offset()), Z_R0_scratch);\n+  __ cfi(Z_R1_scratch, 0);\n+  __ z_brne(skip_barrier);\n+\n+  \/\/ Class loader is weak. Determine whether the holder is still alive.\n+  __ z_lg(Z_R1_scratch, in_bytes(ClassLoaderData::holder_offset()), Z_R0_scratch);\n+  __ resolve_weak_handle(\/*TODO*\/);\n+  __ z_cfi(Z_R1_scratch, 0);\n+  __ brne(skip_barrier);\n+\n+  __ bind(bad_call);\n+\n+  __ load_const_optimized(Z_R1_scratch, SharedRuntime::get_handle_wrong_method_stub());\n+  __ z_br(Z_R1_scratch); \/\/ Does not return\n+\n+  __ bind(skip_barrier);\n+\n+  __ block_comment(\"} c2i_entry_barrier (c2i_entry_barrier)\");\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.cpp","additions":64,"deletions":25,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/s390\/gc\/shared\/barrierSetAssembler_s390.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4191,0 +4191,5 @@\n+void resolve_weak_handle(Register result, Register tmp1, Register tmp2,\n+                         MacroAssembler::PreservationLevel preservation_level) {\n+  \/\/ TODO\n+}\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -814,0 +814,3 @@\n+  void resolve_weak_handle(Register result, Register tmp1, Register tmp2,\n+                           MacroAssembler::PreservationLevel preservation_level);\n+\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}