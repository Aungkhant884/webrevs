{"files":[{"patch":"@@ -136,1 +136,1 @@\n-        g.drawLine((3*stkWidth\/2)-1, h-(stkWidth-stkWidth\/2),\n+        g.drawLine((stkWidth\/2), h-(stkWidth-stkWidth\/2),\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/EtchedBorder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,13 @@\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n@@ -28,0 +41,1 @@\n+import javax.swing.Box;\n@@ -29,1 +43,0 @@\n-import javax.swing.JCheckBox;\n@@ -35,8 +48,0 @@\n-import javax.swing.border.Border;\n-import java.awt.BorderLayout;\n-import java.awt.Color;\n-import java.awt.Graphics2D;\n-import java.awt.Robot;\n-import java.awt.image.BufferedImage;\n-import java.io.File;\n-import java.io.IOException;\n@@ -55,0 +60,2 @@\n+    public static final Dimension SIZE = new Dimension(120, 20);\n+\n@@ -62,1 +69,10 @@\n-    public static boolean showFrame = true;\n+    public static boolean showFrame = false;\n+\n+    private static final double[] scales =\n+            {1.00, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00};\n+\n+    private static final List<BufferedImage> images =\n+            new ArrayList<>(scales.length);\n+\n+    private static final List<Point> panelLocations =\n+            new ArrayList<>(4);\n@@ -65,0 +81,1 @@\n+        showFrame = args.length > 1 && \"-show\".equals(args[0]);\n@@ -71,3 +88,1 @@\n-        for (double scaling : new double[] {1.50}) {\n-            testScaling(scaling, showFrame);\n-        }\n+        testScaling(showFrame);\n@@ -76,3 +91,2 @@\n-    private static void testScaling(double scaling, boolean show) throws Exception {\n-        SwingUtilities.invokeAndWait(() -> createAndShowGUI(scaling, show));\n-        Robot robot = new Robot();\n+    private static void testScaling(boolean show) throws Exception {\n+        SwingUtilities.invokeAndWait(() -> createAndShowGUI(show));\n@@ -80,1 +94,3 @@\n-        while(showFrame && frame.isVisible()) Thread.sleep(500);\n+        for (int i = 0; i < images.size(); i++) {\n+                BufferedImage img = images.get(i);\n+                double scaling = scales[i];\n@@ -82,6 +98,5 @@\n-        robot.waitForIdle();\n-        \/\/ testing left edge\n-        checkVerticalBorder(15, 70, 20, 80, highlight, scaling);\n-        checkVerticalBorder(18, 120, 23, 130, highlight, scaling);\n-        checkVerticalBorder(20, 170, 25, 180, highlight, scaling);\n-        checkVerticalBorder(22, 220, 28, 230, highlight, scaling);\n+                \/\/ For vertical count the number of shadow \/ highlight in\n+                \/\/ the middle of the image at (x = SIZE.width \/ 2)\n+                \/\/ (there must be no background color between these two colours)\n+                \/\/ Then skip background until the next border where you count\n+                \/\/ shadow and highlight thickness\n@@ -89,1 +104,2 @@\n-        \/\/ testing right edge\n+                 int x = SIZE.width \/ 2;\n+                 checkVerticalBorder(x, img, scaling);\n@@ -91,3 +107,5 @@\n-        \/\/ testing top edge\n-\n-        \/\/ testing bottom edge\n+                \/\/ For horizontal border, take the middle of each panel and\n+                \/\/ count the number of shadow and highlight pixels\n+                for (Point p : panelLocations) {\n+                    int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n+                    System.out.println(scaling + \" : \" + y);\n@@ -95,0 +113,3 @@\n+                     checkHorizontalBorder(y, img, scaling);\n+                }\n+        }\n@@ -97,16 +118,14 @@\n-    private static void checkHorizontalBorder(int x1, int y1, int x2, int y2,\n-                                              Color color, double scaling) throws RuntimeException {\n-        for (int j = x1; j < x2; j++) {\n-            int thickness = 0;\n-            for (int i = y1; i < y2; i++) {\n-                if (buff.getRGB(i, j) == color.getRGB()) thickness++;\n-            }\n-            if (thickness > Math.floor(scaling)) {\n-                System.out.println(y1 + \" \" + y2 + \" \" + thickness);\n-                saveImage(buff, \"test.png\");\n-                throw new RuntimeException(\"Border drawn too thick.\");\n-            } else if (thickness < Math.floor(scaling)) {\n-                System.out.println(y1 + \" \" + y2 + \" \" + thickness);\n-                saveImage(buff, \"test.png\");\n-                throw new RuntimeException(\"BorderLayout was clipped or overdrawn.\");\n-            }\n+    private static void hBorderLoop(int x1, int x2, int y, BufferedImage buff,\n+                                    Color c, double scaling) throws RuntimeException {\n+        int thickness = 0;\n+        for (int i = x1; i < x2; i++) {\n+            if (buff.getRGB(i, y) == c.getRGB()) thickness++;\n+        }\n+\n+        int expected = (int) Math.floor(scaling);\n+        if (thickness > expected) {\n+            throw new RuntimeException(\"Horizontal Border drawn too thick. Thickness: \"\n+                    + thickness + \" Scaling: \" + scaling + \" y: \" + y);\n+        } else if (thickness < expected) {\n+            throw new RuntimeException(\"Horizontal Border drawn too thin. Thickness: \"\n+                    + thickness + \" Scaling: \" + scaling + \" y: \" + y);\n@@ -116,15 +135,58 @@\n-    private static void checkVerticalBorder(int x1, int y1, int x2, int y2,\n-                                            Color color, double scaling) throws RuntimeException {\n-        for (int j = y1; j < y2; j++) {\n-            int thickness = 0;\n-            for (int i = x1; i < x2; i++) {\n-                if (buff.getRGB(i, j) == color.getRGB()) thickness++;\n-            }\n-            if (thickness > Math.floor(scaling)) {\n-                System.out.println(y1 + \" \" + y2 + \" \" + thickness);\n-                saveImage(buff, \"test.png\");\n-                throw new RuntimeException(\"Border drawn too thick.\");\n-            } else if (thickness < Math.floor(scaling)) {\n-                System.out.println(y1 + \" \" + y2 + \" \" + thickness);\n-                saveImage(buff, \"test.png\");\n-                throw new RuntimeException(\"BorderLayout was clipped or overdrawn.\");\n+    private static void checkHorizontalBorder(int y, BufferedImage img, double scaling) throws RuntimeException {\n+        \/\/ checking left border\n+        hBorderLoop(0, (int) (Math.floor(scaling)+(5*scaling)), y, img, shadow, scaling);\n+        hBorderLoop((int) Math.floor(scaling), (int) (Math.floor(scaling)*2+5*scaling), y, img, highlight, scaling);\n+\n+        \/\/ checking right border\n+        hBorderLoop(img.getWidth() - ((int) (Math.floor(scaling)*2+5*scaling)), img.getWidth() - ((int) Math.floor(scaling)),\n+                y, img, shadow, scaling);\n+        hBorderLoop(img.getWidth() - ((int) (Math.floor(scaling)+5*scaling)), img.getWidth(),\n+                y, img, highlight, scaling);\n+    }\n+\n+    private static void verifyThickness(int x, int thickness, double scaling) {\n+        int expected = (int) Math.floor(scaling);\n+        if (thickness < expected) throw new RuntimeException(\"Vertical Border drawn too thin. Thickness: \"\n+                + thickness + \" Scaling: \" + scaling + \" x: \" + x);\n+        if (thickness > expected) throw new RuntimeException(\"Vertical Border drawn too thick. Thickness: \"\n+                + thickness + \" Scaling: \" + scaling + \" x: \" + x);\n+    }\n+\n+    private static void checkVerticalBorder(int x, BufferedImage img, double scaling) throws RuntimeException {\n+        int thickness = 0;\n+        boolean checkShadow = false;\n+        boolean checkHighlight = false;\n+        for (int i = 0; i < img.getHeight(); i++) {\n+            int color = img.getRGB(x,i);\n+            if (!checkHighlight && !checkShadow) {\n+                if (color == shadow.getRGB()) {\n+                    checkHighlight = true;\n+                    thickness++;\n+                } else if (color == highlight.getRGB()) {\n+                    throw new RuntimeException(\"Vertical Border was clipped or overdrawn.\"\n+                            + \" Scaling: \" + scaling + \" x: \" + x);\n+                } else {\n+                    continue;\n+                }\n+            } else if (checkHighlight) {\n+                if (color == shadow.getRGB()) {\n+                    thickness++;\n+                } else if (color == highlight.getRGB()) {\n+                    verifyThickness(x, thickness, scaling);\n+                    checkHighlight = false;\n+                    checkShadow = true;\n+                    thickness = 1;\n+                } else {\n+                    throw new RuntimeException(\"Vertical Border has empty space between highlight and shadow.\"\n+                            + \" Scaling: \" + scaling + \" x: \" + x);\n+                }\n+            } else {\n+                if (color == shadow.getRGB()) {\n+                    throw new RuntimeException(\"Border colors reversed.\");\n+                } else if (color == highlight.getRGB()) {\n+                    thickness++;\n+                } else {\n+                    verifyThickness(x, thickness, scaling);\n+                    checkShadow = false;\n+                    thickness = 0;\n+                }\n@@ -135,1 +197,1 @@\n-    private static void createAndShowGUI(double scaling, boolean showFrame) {\n+    private static void createAndShowGUI(boolean showFrame) {\n@@ -139,1 +201,0 @@\n-        contentPanel.setSize(new java.awt.Dimension(300, 200));\n@@ -143,1 +204,1 @@\n-            parentPanel.setBorder(BorderFactory.createEmptyBorder(5, 5 + i, 5, 5));\n+            parentPanel.setBorder(BorderFactory.createEmptyBorder(0, i, 4, 0));\n@@ -147,1 +208,1 @@\n-            childPanel.add(new JCheckBox(), BorderLayout.CENTER);\n+            childPanel.add(Box.createRigidArea(SIZE), BorderLayout.CENTER);\n@@ -153,4 +214,5 @@\n-        \/\/ Create BufferedImage\n-        buff = new BufferedImage(contentPanel.getWidth() * ((int) Math.ceil(scaling)),\n-                contentPanel.getHeight() * ((int) Math.ceil(scaling)), BufferedImage.TYPE_INT_ARGB);\n-        Graphics2D graph = buff.createGraphics();\n+        frame = new JFrame(\"Swing Test\");\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        frame.getContentPane().add(contentPanel, BorderLayout.CENTER);\n+        frame.pack();\n+        frame.setLocationRelativeTo(null);\n@@ -158,6 +220,18 @@\n-        \/\/ Set affine transform\n-        graph.scale(scaling, scaling);\n-\n-        \/\/ Painting panel onto BufferedImage\n-        contentPanel.paint(graph);\n-        graph.dispose();\n+        for (double scaling : scales) {\n+            \/\/ Create BufferedImage\n+            BufferedImage buff = new BufferedImage((int) Math.ceil(contentPanel.getWidth() * scaling),\n+                    (int) Math.ceil(contentPanel.getHeight() * scaling),\n+                    BufferedImage.TYPE_INT_ARGB);\n+            Graphics2D graph = buff.createGraphics();\n+            graph.scale(scaling, scaling);\n+            \/\/ Painting panel onto BufferedImage\n+            contentPanel.paint(graph);\n+            graph.dispose();\n+            \/\/ Save each image ? -- Here it's useful for debugging\n+            saveImage(buff, String.format(\"test%.2f.png\", scaling));\n+            images.add(buff);\n+        }\n+        \/\/ Save coordinates of the panels\n+        Arrays.stream(contentPanel.getComponents())\n+                .map(Component::getLocation)\n+                .forEach(panelLocations::add);\n@@ -166,3 +240,0 @@\n-            frame = new JFrame(\"Swing Test\");\n-            frame.setSize(300, 200);\n-            frame.getContentPane().add(contentPanel, BorderLayout.CENTER);\n@@ -170,0 +241,2 @@\n+        } else {\n+            frame.dispose();\n@@ -193,1 +266,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/TitledBorder\/TitledBorderTest.java","additions":149,"deletions":76,"binary":false,"changes":225,"status":"modified"}]}