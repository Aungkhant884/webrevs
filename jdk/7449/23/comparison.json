{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.awt.BasicStroke;\n@@ -28,0 +29,1 @@\n+import java.awt.Graphics2D;\n@@ -29,1 +31,0 @@\n-import java.awt.Rectangle;\n@@ -32,0 +33,3 @@\n+import java.awt.RenderingHints;\n+import java.awt.Stroke;\n+import java.awt.geom.AffineTransform;\n@@ -122,0 +126,16 @@\n+    private void paintBorderHighlight(Graphics g, Color c, int w, int h, int stkWidth) {\n+        g.setColor(c);\n+        g.drawRect(stkWidth\/2, stkWidth\/2, w-(2*stkWidth), h-(2*stkWidth));\n+    }\n+\n+    private void paintBorderShadow(Graphics g, Color c, int w, int h, int stkWidth) {\n+        g.setColor(c);\n+        g.drawLine(((3*stkWidth)\/2), h-((3*stkWidth)\/2), ((3*stkWidth)\/2), ((3*stkWidth)\/2)); \/\/ left line\n+        g.drawLine(((3*stkWidth)\/2), ((3*stkWidth)\/2), w-((3*stkWidth)\/2), ((3*stkWidth)\/2)); \/\/ top line\n+\n+        g.drawLine((stkWidth\/2), h-(stkWidth-stkWidth\/2),\n+                w-(stkWidth-stkWidth\/2), h-(stkWidth-stkWidth\/2)); \/\/ bottom line\n+        g.drawLine(w-(stkWidth-stkWidth\/2), h-(stkWidth-stkWidth\/2),\n+                w-(stkWidth-stkWidth\/2), stkWidth\/2); \/\/ right line\n+    }\n+\n@@ -134,16 +154,55 @@\n-        int w = width;\n-        int h = height;\n-\n-        g.translate(x, y);\n-\n-        g.setColor(etchType == LOWERED? getShadowColor(c) : getHighlightColor(c));\n-        g.drawRect(0, 0, w-2, h-2);\n-\n-        g.setColor(etchType == LOWERED? getHighlightColor(c) : getShadowColor(c));\n-        g.drawLine(1, h-3, 1, 1);\n-        g.drawLine(1, 1, w-3, 1);\n-\n-        g.drawLine(0, h-1, w-1, h-1);\n-        g.drawLine(w-1, h-1, w-1, 0);\n-\n-        g.translate(-x, -y);\n+        \/\/ We remove any initial transforms to prevent rounding errors\n+        \/\/ when drawing in non-integer scales\n+        AffineTransform at = new AffineTransform();\n+        Stroke oldStk = new BasicStroke();\n+        int stkWidth = 1;\n+        boolean resetTransform = false;\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            at = g2d.getTransform();\n+            oldStk = g2d.getStroke();\n+            \/\/ if m01 or m10 is non-zero, then there is a rotation or shear\n+            \/\/ skip resetting the transform\n+            resetTransform = (at.getShearX() == 0) && (at.getShearY() == 0);\n+            if (resetTransform) {\n+                g2d.setTransform(new AffineTransform());\n+                stkWidth = (int) Math.floor(Math.min(at.getScaleX(), at.getScaleY()));\n+                g2d.setStroke(new BasicStroke((float) stkWidth));\n+            }\n+            RenderingHints rend =\n+                    new RenderingHints(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);\n+        }\n+\n+        int w;\n+        int h;\n+        int xtranslation;\n+        int ytranslation;\n+        if (resetTransform) {\n+            w = (int) Math.floor(at.getScaleX() * width - 1);\n+            h = (int) Math.floor(at.getScaleY() * height - 1);\n+            xtranslation = (int) Math.ceil(at.getScaleX()*x+at.getTranslateX());\n+            ytranslation = (int) Math.ceil(at.getScaleY()*y+at.getTranslateY());\n+        } else {\n+            w = width;\n+            h = height;\n+            xtranslation = x;\n+            ytranslation = y;\n+        }\n+\n+        g.translate(xtranslation, ytranslation);\n+\n+        paintBorderShadow(g, (etchType == LOWERED) ? getHighlightColor(c)\n+                                                   : getShadowColor(c),\n+                          w, h, stkWidth);\n+        paintBorderHighlight(g, (etchType == LOWERED) ? getShadowColor(c)\n+                                                      : getHighlightColor(c),\n+                             w, h, stkWidth);\n+\n+        g.translate(-xtranslation, -ytranslation);\n+\n+        \/\/ Set the transform we removed earlier\n+        if (g instanceof Graphics2D) {\n+            Graphics2D g2d = (Graphics2D) g;\n+            g2d.setTransform(at);\n+            g2d.setStroke(oldStk);\n+        }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/border\/EtchedBorder.java","additions":77,"deletions":18,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Graphics2D;\n+import java.awt.Point;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import javax.imageio.ImageIO;\n+import javax.swing.BorderFactory;\n+import javax.swing.Box;\n+import javax.swing.BoxLayout;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8279614\n+ * @summary The left line of the TitledBorder is not painted on 150 scale factor\n+ * @requires (os.family == \"windows\")\n+ * @run main ScaledEtchedBorderTest\n+ *\/\n+\n+public class ScaledEtchedBorderTest {\n+\n+    public static final Dimension SIZE = new Dimension(120, 20);\n+\n+    public static Color highlight = Color.RED;\n+    public static Color shadow = Color.BLUE;\n+\n+    private static final double[] scales =\n+            {1.00, 1.25, 1.50, 1.75, 2.00, 2.50, 3.00};\n+\n+    private static final List<BufferedImage> images =\n+            new ArrayList<>(scales.length);\n+\n+    private static final List<Point> panelLocations =\n+            new ArrayList<>(4);\n+\n+    public static void main(String[] args) throws Exception {\n+        boolean showFrame = args.length > 0 && \"-show\".equals(args[0]);\n+        SwingUtilities.invokeAndWait(() -> testScaling(showFrame));\n+    }\n+\n+    private static void testScaling(boolean show) {\n+        createGUI(show);\n+\n+        for (int i = 0; i < scales.length; i++) {\n+            BufferedImage img = images.get(i);\n+            double scaling = scales[i];\n+            System.out.println(\"Testing scaling: \" + scaling);\n+\n+\n+            \/\/ checking vertical border\n+            int x = SIZE.width \/ 2;\n+            checkVerticalBorder(x, img, scaling);\n+\n+            for (Point p : panelLocations) {\n+                int y = (int) (p.y * scaling) + SIZE.height \/ 2;\n+                checkHorizontalBorder(y, img, scaling);\n+            }\n+        }\n+    }\n+\n+    private static void checkHorizontalBorder(int y, BufferedImage img, double scaling) {\n+        int thickness = 0;\n+        boolean checkShadow = false;\n+        boolean checkHighlight = false;\n+        for (int x = 0; x < img.getWidth(); x++) {\n+            int color = img.getRGB(x, y);\n+            if (!checkHighlight && !checkShadow) {\n+                if (color == shadow.getRGB()) {\n+                    checkHighlight = true;\n+                    thickness++;\n+                } else if (color == highlight.getRGB()) {\n+                    throw new RuntimeException(\"Horizontal Border was clipped or overdrawn.\");\n+                }\n+            } else if (checkHighlight) {\n+                if (color == shadow.getRGB()) {\n+                    thickness++;\n+                } else if (color == highlight.getRGB()) {\n+                    verifyThickness(x, y, thickness, scaling, \"Horizontal\");\n+                    checkHighlight = false;\n+                    checkShadow = true;\n+                    thickness = 1;\n+                } else {\n+                    throw new RuntimeException(\"Horizontal Border has empty space between highlight and shadow.\");\n+                }\n+            } else {\n+                if (color == shadow.getRGB()) {\n+                    throw new RuntimeException(\"Border colors reversed.\");\n+                } else if (color == highlight.getRGB()) {\n+                    thickness++;\n+                } else {\n+                    verifyThickness(x, y, thickness, scaling, \"Horizontal\");\n+                    checkShadow = false;\n+                    thickness = 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void verifyThickness(int x, int y, int thickness, double scaling, String orientation) {\n+        int expected = (int) Math.floor(scaling);\n+        if (thickness != expected) {\n+            throw new RuntimeException(\"Unexpected \" + orientation + \" Border thickness at x:\"\n+                                       + x + \" y: \" + y + \". Expected: \" + expected + \" Actual: \" + thickness);\n+        }\n+    }\n+\n+    private static void checkVerticalBorder(int x, BufferedImage img, double scaling) {\n+        int thickness = 0;\n+        boolean checkShadow = false;\n+        boolean checkHighlight = false;\n+        for (int y = 0; y < img.getHeight(); y++) {\n+            int color = img.getRGB(x, y);\n+            if (!checkHighlight && !checkShadow) {\n+                if (color == shadow.getRGB()) {\n+                    checkHighlight = true;\n+                    thickness++;\n+                } else if (color == highlight.getRGB()) {\n+                    throw new RuntimeException(\"Vertical Border was clipped or overdrawn.\");\n+                }\n+            } else if (checkHighlight) {\n+                if (color == shadow.getRGB()) {\n+                    thickness++;\n+                } else if (color == highlight.getRGB()) {\n+                    verifyThickness(x, y, thickness, scaling, \"Vertical\");\n+                    checkHighlight = false;\n+                    checkShadow = true;\n+                    thickness = 1;\n+                } else {\n+                    throw new RuntimeException(\"Vertical Border has empty space between highlight and shadow.\");\n+                }\n+            } else {\n+                if (color == shadow.getRGB()) {\n+                    throw new RuntimeException(\"Border colors reversed.\");\n+                } else if (color == highlight.getRGB()) {\n+                    thickness++;\n+                } else {\n+                    verifyThickness(x, y, thickness, scaling, \"Vertical\");\n+                    checkShadow = false;\n+                    thickness = 0;\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void createGUI(boolean show) {\n+        \/\/ Render content panel\n+        JPanel contentPanel = new JPanel();\n+        contentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));\n+\n+        Dimension childSize = null;\n+        for (int i = 0; i < 4; i++) {\n+            JPanel childPanel = new JPanel(new BorderLayout());\n+            childPanel.setBorder(BorderFactory.createCompoundBorder(\n+                    BorderFactory.createEmptyBorder(0, i, 4, 4),\n+                    BorderFactory.createEtchedBorder(highlight, shadow)));\n+            childPanel.add(Box.createRigidArea(SIZE), BorderLayout.CENTER);\n+\n+            contentPanel.add(childPanel);\n+            if (childSize == null) {\n+                childSize = childPanel.getPreferredSize();\n+            }\n+            childPanel.setBounds(0, childSize.height * i, childSize.width, childSize.height);\n+        }\n+\n+        contentPanel.setSize(childSize.width, childSize.height * 4);\n+\n+        for (double scaling : scales) {\n+            \/\/ Create BufferedImage\n+            BufferedImage buff = new BufferedImage((int) Math.ceil(contentPanel.getWidth() * scaling),\n+                    (int) Math.ceil(contentPanel.getHeight() * scaling),\n+                    BufferedImage.TYPE_INT_ARGB);\n+            Graphics2D graph = buff.createGraphics();\n+            graph.scale(scaling, scaling);\n+            \/\/ Painting panel onto BufferedImage\n+            contentPanel.paint(graph);\n+            graph.dispose();\n+            \/\/ Save each image ? -- Here it's useful for debugging\n+            saveImage(buff, String.format(\"test%.2f.png\", scaling));\n+            images.add(buff);\n+        }\n+        \/\/ Save coordinates of the panels\n+        for (Component comp : contentPanel.getComponents()) {\n+            panelLocations.add(comp.getLocation());\n+        }\n+\n+        if (show) {\n+            JFrame frame = new JFrame(\"Swing Test\");\n+            frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+            frame.getContentPane().add(contentPanel, BorderLayout.CENTER);\n+            frame.pack();\n+            frame.setLocationRelativeTo(null);\n+            frame.setVisible(true);\n+        }\n+    }\n+\n+    private static void saveImage(BufferedImage image, String filename) {\n+        try {\n+            ImageIO.write(image, \"png\", new File(filename));\n+        } catch (IOException e) {\n+            \/\/ Don't propagate the exception\n+            e.printStackTrace();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/border\/EtchedBorder\/ScaledEtchedBorderTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"}]}