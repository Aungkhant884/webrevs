{"files":[{"patch":"@@ -494,1 +494,1 @@\n-    \/** An inner class has an outer instance if it is not an interface\n+    \/** An inner class has an outer instance if it is not an interface, enum or record,\n@@ -504,1 +504,1 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | ENUM | RECORD | NOOUTERTHIS)) == 0;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -399,1 +399,1 @@\n-        if (c.owner.kind.matches(KindSelector.VAL_MTH)) {\n+        if (c.owner.kind.matches(KindSelector.VAL_MTH) && !c.isStatic()) {\n@@ -2691,0 +2691,1 @@\n+            !currentClass.isStatic() &&\n@@ -2826,1 +2827,1 @@\n-        if (c.isDirectlyOrIndirectlyLocal()) {\n+        if (c.isDirectlyOrIndirectlyLocal() && !c.isStatic()) {\n@@ -3028,1 +3029,1 @@\n-            if (c.isDirectlyOrIndirectlyLocal()) {\n+            if (c.isDirectlyOrIndirectlyLocal() && !c.isStatic()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8282714\n+ * @summary synthetic arguments are being added to the constructors of static local classes\n+ * @library \/lib\/combo \/tools\/lib \/tools\/javac\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.file\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @run testng\/othervm LocalStaticDeclarations2\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import tools.javac.combo.CompilationTestCase;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+@Test\n+public class LocalStaticDeclarations2 extends CompilationTestCase {\n+    public void testLocalStatic() {\n+        assertOK(\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Inner() { enum E { A } }\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Inner() {\n+                            record R(Object o) {\n+                                static R create() { return new R(\"hi\"); }\n+                            }\n+                        }\n+                    }\n+                }\n+                \"\"\");\n+        assertOK(\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Inner() {\n+                            record R(Object o) {\n+                                static R create(Object obj) { return new R(obj); }\n+                            }\n+                        }\n+                    }\n+                }\n+                \"\"\");\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/records\/LocalStaticDeclarations2.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n- * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130\n+ * @bug 8250629 8252307 8247352 8241151 8246774 8259025 8288130 8282714\n@@ -1262,12 +1262,41 @@\n-        int numberOfFieldRefs = 0;\n-        File dir = assertOK(true, \"record R(int recordComponent) {}\");\n-        for (final File fileEntry : dir.listFiles()) {\n-            if (fileEntry.getName().equals(\"R.class\")) {\n-                ClassFile classFile = ClassFile.read(fileEntry);\n-                for (CPInfo cpInfo : classFile.constant_pool.entries()) {\n-                    if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {\n-                        numberOfFieldRefs++;\n-                        ConstantPool.CONSTANT_NameAndType_info nameAndType =\n-                                (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool\n-                                        .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);\n-                        Assert.check(nameAndType.getName().equals(\"recordComponent\"));\n+        for (String source : List.of(\n+                \"record R(int recordComponent) {}\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        Inner() {\n+                            record R(int recordComponent) {}\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    class Inner {\n+                        void m() {\n+                            record R(int recordComponent) {}\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class Test {\n+                    void m() {\n+                        record R(int recordComponent) {}\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            File dir = assertOK(true, source);\n+            int numberOfFieldRefs = 0;\n+            for (final File fileEntry : dir.listFiles()) {\n+                if (fileEntry.getName().endsWith(\"R.class\")) {\n+                    ClassFile classFile = ClassFile.read(fileEntry);\n+                    for (CPInfo cpInfo : classFile.constant_pool.entries()) {\n+                        if (cpInfo instanceof ConstantPool.CONSTANT_Fieldref_info) {\n+                            numberOfFieldRefs++;\n+                            ConstantPool.CONSTANT_NameAndType_info nameAndType =\n+                                    (ConstantPool.CONSTANT_NameAndType_info)classFile.constant_pool\n+                                            .get(((ConstantPool.CONSTANT_Fieldref_info)cpInfo).name_and_type_index);\n+                            Assert.check(nameAndType.getName().equals(\"recordComponent\"));\n+                        }\n@@ -1275,0 +1304,1 @@\n+                    Assert.check(numberOfFieldRefs == 1);\n@@ -1278,1 +1308,0 @@\n-        Assert.check(numberOfFieldRefs == 1);\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":43,"deletions":14,"binary":false,"changes":57,"status":"modified"}]}