{"files":[{"patch":"@@ -895,1 +895,4 @@\n-static bool set_fp_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n+static bool set_fp_numeric_flag(JVMFlag* flag, const char* value, JVMFlagOrigin origin) {\n+  if (*value == '\\0' || isspace(*value)) {\n+    return false;\n+  }\n@@ -902,0 +905,4 @@\n+  if (g_isnan(v) || !g_isfinite(v)) {\n+    \/\/ Currently we cannot handle these special values.\n+    return false;\n+  }\n@@ -909,4 +916,2 @@\n-static JVMFlag::Error set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n-  if (flag == NULL) {\n-    return JVMFlag::INVALID_FLAG;\n-  }\n+static bool set_numeric_flag(JVMFlag* flag, const char* value, JVMFlagOrigin origin) {\n+  JVMFlag::Error result = JVMFlag::WRONG_FORMAT;\n@@ -917,1 +922,1 @@\n-      return JVMFlagAccess::set_int(flag, &v, origin);\n+      result = JVMFlagAccess::set_int(flag, &v, origin);\n@@ -922,1 +927,1 @@\n-      return JVMFlagAccess::set_uint(flag, &v, origin);\n+      result = JVMFlagAccess::set_uint(flag, &v, origin);\n@@ -927,1 +932,1 @@\n-      return JVMFlagAccess::set_intx(flag, &v, origin);\n+      result = JVMFlagAccess::set_intx(flag, &v, origin);\n@@ -932,1 +937,1 @@\n-      return JVMFlagAccess::set_uintx(flag, &v, origin);\n+      result = JVMFlagAccess::set_uintx(flag, &v, origin);\n@@ -937,1 +942,1 @@\n-      return JVMFlagAccess::set_uint64_t(flag, &v, origin);\n+      result = JVMFlagAccess::set_uint64_t(flag, &v, origin);\n@@ -942,14 +947,1 @@\n-      return JVMFlagAccess::set_size_t(flag, &v, origin);\n-    }\n-  } else if (flag->is_double()) {\n-    \/\/ This function parses only input strings without a decimal\n-    \/\/ point character (.)\n-    \/\/ If a string looks like a FP number, it would be parsed by\n-    \/\/ set_fp_numeric_flag(). See Arguments::parse_argument().\n-    jlong v;\n-    if (parse_integer(value, &v)) {\n-      double double_v = (double) v;\n-      if (value[0] == '-' && v == 0) { \/\/ special case: 0.0 is different than -0.0.\n-        double_v = -0.0;\n-      }\n-      return JVMFlagAccess::set_double(flag, &double_v, origin);\n+      result = JVMFlagAccess::set_size_t(flag, &v, origin);\n@@ -959,1 +951,1 @@\n-  return JVMFlag::WRONG_FORMAT;\n+  return result == JVMFlag::SUCCESS;\n@@ -963,0 +955,3 @@\n+  if (value[0] == '\\0') {\n+    value = NULL;\n+  }\n@@ -996,1 +991,1 @@\n-const char* Arguments::handle_aliases_and_deprecation(const char* arg, bool warn) {\n+const char* Arguments::handle_aliases_and_deprecation(const char* arg) {\n@@ -1014,10 +1009,8 @@\n-      if (warn) {\n-        char version[256];\n-        since.to_string(version, sizeof(version));\n-        if (real_name != arg) {\n-          warning(\"Option %s was deprecated in version %s and will likely be removed in a future release. Use option %s instead.\",\n-                  arg, version, real_name);\n-        } else {\n-          warning(\"Option %s was deprecated in version %s and will likely be removed in a future release.\",\n-                  arg, version);\n-        }\n+      char version[256];\n+      since.to_string(version, sizeof(version));\n+      if (real_name != arg) {\n+        warning(\"Option %s was deprecated in version %s and will likely be removed in a future release. Use option %s instead.\",\n+                arg, version, real_name);\n+      } else {\n+        warning(\"Option %s was deprecated in version %s and will likely be removed in a future release.\",\n+                arg, version);\n@@ -1032,4 +1025,0 @@\n-bool Arguments::parse_argument(const char* arg, JVMFlagOrigin origin) {\n-\n-  \/\/ range of acceptable characters spelled out for portability reasons\n-#define NAME_RANGE  \"[abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]\"\n@@ -1037,4 +1026,0 @@\n-  char name[BUFLEN+1];\n-  char dummy;\n-  const char* real_name;\n-  bool warn_if_deprecated = true;\n@@ -1042,4 +1027,9 @@\n-  if (sscanf(arg, \"-%\" XSTR(BUFLEN) NAME_RANGE \"%c\", name, &dummy) == 1) {\n-    real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);\n-    if (real_name == NULL) {\n-      return false;\n+JVMFlag* Arguments::find_jvm_flag(const char* name, size_t name_length) {\n+  char name_copied[BUFLEN+1];\n+  if (name[name_length] != 0) {\n+    if (name_length > BUFLEN) {\n+      return NULL;\n+    } else {\n+      strncpy(name_copied, name, name_length);\n+      name_copied[name_length] = '\\0';\n+      name = name_copied;\n@@ -1047,2 +1037,0 @@\n-    JVMFlag* flag = JVMFlag::find_flag(real_name);\n-    return set_bool_flag(flag, false, origin);\n@@ -1050,4 +1038,29 @@\n-  if (sscanf(arg, \"+%\" XSTR(BUFLEN) NAME_RANGE \"%c\", name, &dummy) == 1) {\n-    real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);\n-    if (real_name == NULL) {\n-      return false;\n+\n+  const char* real_name = Arguments::handle_aliases_and_deprecation(name);\n+  if (real_name == NULL) {\n+    return NULL;\n+  }\n+  JVMFlag* flag = JVMFlag::find_flag(real_name);\n+  return flag;\n+}\n+\n+bool Arguments::parse_argument(const char* arg, JVMFlagOrigin origin) {\n+  bool is_bool = false;\n+  bool bool_val = false;\n+  char c = *arg;\n+  if (c == '+' || c == '-') {\n+    is_bool = true;\n+    bool_val = (c == '+');\n+    arg++;\n+  }\n+\n+  const char* name = arg;\n+  while (true) {\n+    c = *arg;\n+    if (('a' <= c && c <= 'z' ) ||\n+        ('A' <= c && c <= 'Z' ) ||\n+        ('0' <= c && c <= '9' ) ||\n+        ('_' == c)) {\n+      ++arg;\n+    } else {\n+      break;\n@@ -1055,2 +1068,0 @@\n-    JVMFlag* flag = JVMFlag::find_flag(real_name);\n-    return set_bool_flag(flag, true, origin);\n@@ -1059,3 +1070,5 @@\n-  char punct;\n-  if (sscanf(arg, \"%\" XSTR(BUFLEN) NAME_RANGE \"%c\", name, &punct) == 2 && punct == '=') {\n-    const char* value = strchr(arg, '=') + 1;\n+  size_t name_len = size_t(arg - name);\n+  JVMFlag* flag = find_jvm_flag(name, name_len);\n+  if (flag == NULL) {\n+    return false;\n+  }\n@@ -1063,3 +1076,3 @@\n-    \/\/ this scanf pattern matches both strings (handled here) and numbers (handled later))\n-    real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);\n-    if (real_name == NULL) {\n+  if (is_bool) {\n+    if (*arg != 0) {\n+      \/\/ Error -- extra characters such as -XX:+BoolFlag=123\n@@ -1068,2 +1081,6 @@\n-    JVMFlag* flag = JVMFlag::find_flag(real_name);\n-    if (flag != NULL && flag->is_ccstr()) {\n+    return set_bool_flag(flag, bool_val, origin);\n+  }\n+\n+  if (arg[0] == '=') {\n+    const char* value = arg + 1;\n+    if (flag->is_ccstr()) {\n@@ -1073,3 +1090,0 @@\n-        if (value[0] == '\\0') {\n-          value = NULL;\n-        }\n@@ -1078,0 +1092,2 @@\n+    } else if (flag->is_double()) {\n+      return set_fp_numeric_flag(flag, value, origin);\n@@ -1079,1 +1095,1 @@\n-      warn_if_deprecated = false; \/\/ if arg is deprecated, we've already done warning...\n+      return set_numeric_flag(flag, value, origin);\n@@ -1083,2 +1099,1 @@\n-  if (sscanf(arg, \"%\" XSTR(BUFLEN) NAME_RANGE \":%c\", name, &punct) == 2 && punct == '=') {\n-    const char* value = strchr(arg, '=') + 1;\n+  if (arg[0] == ':' && arg[1] == '=') {\n@@ -1086,8 +1101,1 @@\n-    if (value[0] == '\\0') {\n-      value = NULL;\n-    }\n-    real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);\n-    if (real_name == NULL) {\n-      return false;\n-    }\n-    JVMFlag* flag = JVMFlag::find_flag(real_name);\n+    const char* value = arg + 2;\n@@ -1097,27 +1105,0 @@\n-#define SIGNED_FP_NUMBER_RANGE \"[-0123456789.eE+]\"\n-#define SIGNED_NUMBER_RANGE    \"[-0123456789]\"\n-#define        NUMBER_RANGE    \"[0123456789eE+-]\"\n-  char value[BUFLEN + 1];\n-  char value2[BUFLEN + 1];\n-  if (sscanf(arg, \"%\" XSTR(BUFLEN) NAME_RANGE \"=\" \"%\" XSTR(BUFLEN) SIGNED_NUMBER_RANGE \".\" \"%\" XSTR(BUFLEN) NUMBER_RANGE \"%c\", name, value, value2, &dummy) == 3) {\n-    \/\/ Looks like a floating-point number -- try again with more lenient format string\n-    if (sscanf(arg, \"%\" XSTR(BUFLEN) NAME_RANGE \"=\" \"%\" XSTR(BUFLEN) SIGNED_FP_NUMBER_RANGE \"%c\", name, value, &dummy) == 2) {\n-      real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);\n-      if (real_name == NULL) {\n-        return false;\n-      }\n-      JVMFlag* flag = JVMFlag::find_flag(real_name);\n-      return set_fp_numeric_flag(flag, value, origin);\n-    }\n-  }\n-\n-#define VALUE_RANGE \"[-kmgtxKMGTX0123456789abcdefABCDEF]\"\n-  if (sscanf(arg, \"%\" XSTR(BUFLEN) NAME_RANGE \"=\" \"%\" XSTR(BUFLEN) VALUE_RANGE \"%c\", name, value, &dummy) == 2) {\n-    real_name = handle_aliases_and_deprecation(name, warn_if_deprecated);\n-    if (real_name == NULL) {\n-      return false;\n-    }\n-    JVMFlag* flag = JVMFlag::find_flag(real_name);\n-    return set_numeric_flag(flag, value, origin) == JVMFlag::SUCCESS;\n-  }\n-\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":86,"deletions":105,"binary":false,"changes":191,"status":"modified"},{"patch":"@@ -39,0 +39,2 @@\n+class JVMFlag;\n+\n@@ -466,0 +468,1 @@\n+  static JVMFlag* find_jvm_flag(const char* name, size_t name_length);\n@@ -469,1 +472,1 @@\n-  static const char* handle_aliases_and_deprecation(const char* arg, bool warn);\n+  static const char* handle_aliases_and_deprecation(const char* arg);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <errno.h>\n@@ -264,1 +265,1 @@\n-    \/\/ Invalid strings for *any* type of integer VM arguments\n+    \/\/ Invalid strings for *any* numeric type of VM arguments\n@@ -270,4 +271,0 @@\n-      \"999999999999999999999999999999\",\n-      \"0x10000000000000000\", \"18446744073709551616\",\n-      \"-0x10000000000000000\", \"-18446744073709551616\",\n-      \"-0x8000000000000001\", \"-9223372036854775809\",\n@@ -283,1 +280,9 @@\n-  if (!is_double) {\n+  if (is_double) {\n+    const char* invalid_strings_for_double[] = {\n+      \"INF\", \"Inf\", \"Infinity\", \"INFINITY\",\n+      \"-INF\", \"-Inf\", \"-Infinity\", \"-INFINITY\",\n+      \"nan\", \"NAN\", \"NaN\",\n+      NULL,\n+    };\n+    check_invalid_numeric_string(flag, invalid_strings_for_double);\n+  } else {\n@@ -286,0 +291,4 @@\n+      \"999999999999999999999999999999\",\n+      \"0x10000000000000000\", \"18446744073709551616\",\n+      \"-0x10000000000000000\", \"-18446744073709551616\",\n+      \"-0x8000000000000001\", \"-9223372036854775809\",\n@@ -552,2 +561,0 @@\n-  \/\/ TODO -- JDK-8282774\n-  \/\/ Need to add more test input that have a fractional part like \"4.2\".\n@@ -567,0 +574,32 @@\n+\n+  const char* more_valid_strings[] = {\n+    \/\/ These examples are from https:\/\/en.cppreference.com\/w\/cpp\/language\/floating_literal\n+    \/\/ (but with the L and F suffix removed).\n+    \"1e10\", \"1e-5\",\n+    \"1.e-2\", \"3.14\",\n+    \".1\", \"0.1e-1\",\n+    \"0x1ffp10\", \"0X0p-1\",\n+    \"0x1.p0\", \"0xf.p-1\",\n+    \"0x0.123p-1\", \"0xa.bp10\",\n+    \"0x1.4p3\",\n+    \/\/ More test cases\n+    \"1.5\", \"6.02e23\", \"-6.02e+23\",\n+    \"1.7976931348623157E+308\", \/\/ max double\n+    \"-0\", \"0\",\n+    \"0x1.91eb85p+1\",\n+    \"999999999999999999999999999999\",\n+  };\n+  for (uint i = 0; i < ARRAY_SIZE(more_valid_strings); i++) {\n+    const char* str = more_valid_strings[i];\n+\n+    char* dummy;\n+    double expected = strtod(str, &dummy);\n+    ASSERT_TRUE(errno == 0);\n+\n+    ASSERT_TRUE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Valid string '\" <<\n+        str << \"' did not parse for type \" << flag->type_string() << \".\";\n+    double d = flag->get_double();\n+    ASSERT_TRUE(d == expected)\n+        << \"Parsed number \" << d << \" is not the same as expected \" << expected;\n+  }\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":47,"deletions":8,"binary":false,"changes":55,"status":"modified"}]}