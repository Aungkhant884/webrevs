{"files":[{"patch":"@@ -47,1 +47,0 @@\n-import jdk.internal.vm.annotation.Stable;\n@@ -65,3 +64,0 @@\n-    \/\/ volatile ensures static fields set before are published\n-    @Stable\n-    private static volatile boolean initted;\n@@ -74,29 +70,0 @@\n-    \/\/\n-    \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n-    \/\/ Method.invoke() and Constructor.newInstance() currently costs\n-    \/\/ 3-4x more than an invocation via native code for the first\n-    \/\/ invocation (though subsequent invocations have been benchmarked\n-    \/\/ to be over 20x faster). Unfortunately this cost increases\n-    \/\/ startup time for certain applications that use reflection\n-    \/\/ intensively (but only once per class) to bootstrap themselves.\n-    \/\/ To avoid this penalty we reuse the existing JVM entry points\n-    \/\/ for the first few invocations of Methods and Constructors and\n-    \/\/ then switch to the bytecode-based implementations.\n-    \/\/\n-    \/\/ Package-private to be accessible to NativeMethodAccessorImpl\n-    \/\/ and NativeConstructorAccessorImpl\n-    private static boolean noInflation        = false;\n-    private static int     inflationThreshold = 15;\n-\n-    \/\/\n-    \/\/ New implementation uses direct invocation of method handles\n-    private static final int METHOD_MH_ACCESSOR      = 0x1;\n-    private static final int FIELD_MH_ACCESSOR       = 0x2;\n-    private static final int ALL_MH_ACCESSORS        = METHOD_MH_ACCESSOR|FIELD_MH_ACCESSOR;\n-\n-    private static int     useDirectMethodHandle = ALL_MH_ACCESSORS;\n-    private static boolean useNativeAccessorOnly = false;  \/\/ for testing only\n-\n-    \/\/ true if deserialization constructor checking is disabled\n-    private static boolean disableSerialConstructorChecks = false;\n-\n@@ -166,2 +133,0 @@\n-        checkInitted();\n-\n@@ -186,2 +151,0 @@\n-        checkInitted();\n-\n@@ -197,1 +160,1 @@\n-            if (noInflation && !method.getDeclaringClass().isHidden()) {\n+            if (noInflation() && !method.getDeclaringClass().isHidden()) {\n@@ -221,2 +184,0 @@\n-        checkInitted();\n-\n@@ -248,1 +209,1 @@\n-            if (noInflation && !c.getDeclaringClass().isHidden()) {\n+            if (noInflation() && !c.getDeclaringClass().isHidden()) {\n@@ -436,1 +397,1 @@\n-                (!disableSerialConstructorChecks && !superHasAccessibleConstructor(prev))) {\n+                (!disableSerialConstructorChecks() && !superHasAccessibleConstructor(prev))) {\n@@ -629,0 +590,2 @@\n+    \/\/ Package-private to be accessible to NativeMethodAccessorImpl\n+    \/\/ and NativeConstructorAccessorImpl\n@@ -630,1 +593,1 @@\n-        return inflationThreshold;\n+        return config().inflationThreshold;\n@@ -634,1 +597,1 @@\n-        return noInflation;\n+        return config().noInflation;\n@@ -638,1 +601,1 @@\n-        return (useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n+        return (config().useDirectMethodHandle & Config.METHOD_MH_ACCESSOR) == Config.METHOD_MH_ACCESSOR;\n@@ -642,1 +605,1 @@\n-        return (useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n+        return (config().useDirectMethodHandle & Config.FIELD_MH_ACCESSOR) == Config.FIELD_MH_ACCESSOR;\n@@ -646,1 +609,5 @@\n-        return useNativeAccessorOnly;\n+        return config().useNativeAccessorOnly;\n+    }\n+\n+    private static boolean disableSerialConstructorChecks() {\n+        return config().disableSerialConstructorChecks;\n@@ -654,2 +621,1 @@\n-    private static void checkInitted() {\n-        if (initted) return;\n+    private static Config config;\n@@ -657,0 +623,1 @@\n+    private static Config config() {\n@@ -661,1 +628,1 @@\n-            return;\n+            return Config.fallback;\n@@ -664,4 +631,3 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        String val = props.getProperty(\"sun.reflect.noInflation\");\n-        if (val != null && val.equals(\"true\")) {\n-            noInflation = true;\n+        Config c = config;\n+        if (c == null) {\n+            config = c = new Config(true);\n@@ -669,0 +635,2 @@\n+        return c;\n+    }\n@@ -670,22 +638,70 @@\n-        val = props.getProperty(\"sun.reflect.inflationThreshold\");\n-        if (val != null) {\n-            try {\n-                inflationThreshold = Integer.parseInt(val);\n-            } catch (NumberFormatException e) {\n-                throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n-            }\n-        }\n-        val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n-        if (val != null) {\n-            if (val.equals(\"false\")) {\n-                useDirectMethodHandle = 0;\n-            } else if (val.equals(\"methods\")) {\n-                useDirectMethodHandle = METHOD_MH_ACCESSOR;\n-            } else if (val.equals(\"fields\")) {\n-                useDirectMethodHandle = FIELD_MH_ACCESSOR;\n-            }\n-        }\n-        val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n-        if (val != null && val.equals(\"true\")) {\n-            useNativeAccessorOnly = true;\n-        }\n+    \/**\n+     * The configurations exist as an object to avoid race conditions.\n+     * See bug 8261407.\n+     *\/\n+    private static final class Config {\n+        private static final Config fallback = new Config(false);\n+\n+        \/\/\n+        \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n+        \/\/ Method.invoke() and Constructor.newInstance() currently costs\n+        \/\/ 3-4x more than an invocation via native code for the first\n+        \/\/ invocation (though subsequent invocations have been benchmarked\n+        \/\/ to be over 20x faster). Unfortunately this cost increases\n+        \/\/ startup time for certain applications that use reflection\n+        \/\/ intensively (but only once per class) to bootstrap themselves.\n+        \/\/ To avoid this penalty we reuse the existing JVM entry points\n+        \/\/ for the first few invocations of Methods and Constructors and\n+        \/\/ then switch to the bytecode-based implementations.\n+        \/\/\n+        private final boolean noInflation;\n+        private final int     inflationThreshold;\n+\n+        \/\/\n+        \/\/ New implementation uses direct invocation of method handles\n+        private static final int METHOD_MH_ACCESSOR      = 0x1;\n+        private static final int FIELD_MH_ACCESSOR       = 0x2;\n+        private static final int ALL_MH_ACCESSORS        = METHOD_MH_ACCESSOR|FIELD_MH_ACCESSOR;\n+\n+        private final int     useDirectMethodHandle;\n+        private final boolean useNativeAccessorOnly;  \/\/ for testing only\n+\n+        \/\/ true if deserialization constructor checking is disabled\n+        private final boolean disableSerialConstructorChecks;\n+\n+        private Config(boolean getProperties) {\n+            boolean noInflation = false;\n+            int inflationThreshold = 15;\n+            int useDirectMethodHandle = ALL_MH_ACCESSORS;\n+            boolean useNativeAccessorOnly = false;\n+            boolean disableSerialConstructorChecks = false;\n+\n+            if (getProperties) {\n+                Properties props = GetPropertyAction.privilegedGetProperties();\n+                String val = props.getProperty(\"sun.reflect.noInflation\");\n+                if (val != null && val.equals(\"true\")) {\n+                    noInflation = true;\n+                }\n+\n+                val = props.getProperty(\"sun.reflect.inflationThreshold\");\n+                if (val != null) {\n+                    try {\n+                        inflationThreshold = Integer.parseInt(val);\n+                    } catch (NumberFormatException e) {\n+                        throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n+                    }\n+                }\n+                val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n+                if (val != null) {\n+                    if (val.equals(\"false\")) {\n+                        useDirectMethodHandle = 0;\n+                    } else if (val.equals(\"methods\")) {\n+                        useDirectMethodHandle = METHOD_MH_ACCESSOR;\n+                    } else if (val.equals(\"fields\")) {\n+                        useDirectMethodHandle = FIELD_MH_ACCESSOR;\n+                    }\n+                }\n+                val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n+                if (val != null && val.equals(\"true\")) {\n+                    useNativeAccessorOnly = true;\n+                }\n@@ -693,2 +709,3 @@\n-        disableSerialConstructorChecks =\n-            \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+                disableSerialConstructorChecks =\n+                        \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+            }\n@@ -696,1 +713,6 @@\n-        initted = true;\n+            this.noInflation = noInflation;\n+            this.inflationThreshold = inflationThreshold;\n+            this.useDirectMethodHandle = useDirectMethodHandle;\n+            this.useNativeAccessorOnly = useNativeAccessorOnly;\n+            this.disableSerialConstructorChecks = disableSerialConstructorChecks;\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":101,"deletions":79,"binary":false,"changes":180,"status":"modified"}]}