{"files":[{"patch":"@@ -594,1 +594,1 @@\n-        return Config.instance().inflationThreshold;\n+        return config().inflationThreshold;\n@@ -598,1 +598,1 @@\n-        return Config.instance().noInflation;\n+        return config().noInflation;\n@@ -602,1 +602,1 @@\n-        return (Config.instance().useDirectMethodHandle & Config.METHOD_MH_ACCESSOR) == Config.METHOD_MH_ACCESSOR;\n+        return (config().useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n@@ -606,1 +606,1 @@\n-        return (Config.instance().useDirectMethodHandle & Config.FIELD_MH_ACCESSOR) == Config.FIELD_MH_ACCESSOR;\n+        return (config().useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n@@ -610,1 +610,1 @@\n-        return Config.instance().useNativeAccessorOnly;\n+        return config().useNativeAccessorOnly;\n@@ -614,1 +614,1 @@\n-        return Config.instance().disableSerialConstructorChecks;\n+        return config().disableSerialConstructorChecks;\n@@ -617,0 +617,5 @@\n+    \/\/ New implementation uses direct invocation of method handles\n+    private static final int METHOD_MH_ACCESSOR = 0x1;\n+    private static final int FIELD_MH_ACCESSOR = 0x2;\n+    private static final int ALL_MH_ACCESSORS = METHOD_MH_ACCESSOR | FIELD_MH_ACCESSOR;\n+\n@@ -618,2 +623,6 @@\n-     * The configurations exist as an object to avoid race conditions.\n-     * See bug 8261407. The object methods backed by indy may not be available.\n+     * The configuration is lazily initialized after the module system is initialized.\n+     *\n+     * The static initializer of ReflectionFactory is run before the system properties are set up.\n+     * The class initialization is caused by the class initialization of java.lang.reflect.Method\n+     * (more properly, caused by the class initialization for java.lang.reflect.AccessibleObject)\n+     * that happens very early VM startup, initPhase1.\n@@ -621,46 +630,18 @@\n-    private record Config(\n-            \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n-            \/\/ Method.invoke() and Constructor.newInstance() currently costs\n-            \/\/ 3-4x more than an invocation via native code for the first\n-            \/\/ invocation (though subsequent invocations have been benchmarked\n-            \/\/ to be over 20x faster). Unfortunately this cost increases\n-            \/\/ startup time for certain applications that use reflection\n-            \/\/ intensively (but only once per class) to bootstrap themselves.\n-            \/\/ To avoid this penalty we reuse the existing JVM entry points\n-            \/\/ for the first few invocations of Methods and Constructors and\n-            \/\/ then switch to the bytecode-based implementations.\n-            boolean noInflation,\n-            int inflationThreshold,\n-            int useDirectMethodHandle,\n-            boolean useNativeAccessorOnly,\n-            \/\/ true if deserialization constructor checking is disabled\n-            boolean disableSerialConstructorChecks\n-    ) {\n-\n-        \/\/ New implementation uses direct invocation of method handles\n-        private static final int METHOD_MH_ACCESSOR = 0x1;\n-        private static final int FIELD_MH_ACCESSOR = 0x2;\n-        private static final int ALL_MH_ACCESSORS = METHOD_MH_ACCESSOR | FIELD_MH_ACCESSOR;\n-\n-        private static final Config DEFAULT = new Config(\n-                false, \/\/ noInflation\n-                15, \/\/ inflationThreshold\n-                ALL_MH_ACCESSORS, \/\/ useDirectMethodHandle\n-                false, \/\/ useNativeAccessorOnly\n-                false \/\/ disableSerialConstructorChecks\n-        );\n-\n-        \/**\n-         * We have to defer full initialization of this class until after\n-         * the static initializer is run since java.lang.reflect.Method's\n-         * static initializer (more properly, that for\n-         * java.lang.reflect.AccessibleObject) causes this class's to be\n-         * run, before the system properties are set up.\n-         *\/\n-        private static @Stable Config instance;\n-\n-        private static Config instance() {\n-            Config c = instance;\n-            if (c != null) {\n-                return c;\n-            }\n+    private static @Stable Config config;\n+\n+    \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n+    \/\/ Method.invoke() and Constructor.newInstance() currently costs\n+    \/\/ 3-4x more than an invocation via native code for the first\n+    \/\/ invocation (though subsequent invocations have been benchmarked\n+    \/\/ to be over 20x faster). Unfortunately this cost increases\n+    \/\/ startup time for certain applications that use reflection\n+    \/\/ intensively (but only once per class) to bootstrap themselves.\n+    \/\/ To avoid this penalty we reuse the existing JVM entry points\n+    \/\/ for the first few invocations of Methods and Constructors and\n+    \/\/ then switch to the bytecode-based implementations.\n+\n+    private static final Config DEFAULT_CONFIG = new Config(false, \/\/ noInflation\n+            15, \/\/ inflationThreshold\n+            ALL_MH_ACCESSORS, \/\/ useDirectMethodHandle\n+            false, \/\/ useNativeAccessorOnly\n+            false); \/\/ disableSerialConstructorChecks\n@@ -668,6 +649,17 @@\n-            \/\/ Defer initialization until module system is initialized so as\n-            \/\/ to avoid inflation and spinning bytecode in unnamed modules\n-            \/\/ during early startup.\n-            if (!VM.isModuleSystemInited()) {\n-                return DEFAULT;\n-            }\n+    \/**\n+     * The configurations for the reflection factory. Configurable via\n+     * system properties but only available after ReflectionFactory is\n+     * loaded during early VM startup. See bug 8261407.\n+     *\n+     * Note that the default implementation of the object methods of\n+     * this Config record (toString, equals, hashCode) use indy,\n+     * which is available to use only after initPhase1. These methods\n+     * are currently not called, but should they be needed, a workaround\n+     * is to override them.\n+     *\/\n+    private record Config(boolean noInflation,\n+                          int inflationThreshold,\n+                          int useDirectMethodHandle,\n+                          boolean useNativeAccessorOnly,\n+                          boolean disableSerialConstructorChecks) {\n+    }\n@@ -675,1 +667,4 @@\n-            return instance = load();\n+    private static Config config() {\n+        Config c = config;\n+        if (c != null) {\n+            return c;\n@@ -678,2 +673,6 @@\n-        private static Config load() {\n-            assert VM.isModuleSystemInited();\n+        \/\/ Defer initialization until module system is initialized so as\n+        \/\/ to avoid inflation and spinning bytecode in unnamed modules\n+        \/\/ during early startup.\n+        if (!VM.isModuleSystemInited()) {\n+            return DEFAULT_CONFIG;\n+        }\n@@ -681,5 +680,2 @@\n-            boolean noInflation = DEFAULT.noInflation;\n-            int inflationThreshold = DEFAULT.inflationThreshold;\n-            int useDirectMethodHandle = DEFAULT.useDirectMethodHandle;\n-            boolean useNativeAccessorOnly = DEFAULT.useNativeAccessorOnly;\n-            boolean disableSerialConstructorChecks = DEFAULT.disableSerialConstructorChecks;\n+        return config = loadConfig();\n+    }\n@@ -687,5 +683,2 @@\n-            Properties props = GetPropertyAction.privilegedGetProperties();\n-            String val = props.getProperty(\"sun.reflect.noInflation\");\n-            if (val != null && val.equals(\"true\")) {\n-                noInflation = true;\n-            }\n+    private static Config loadConfig() {\n+        assert VM.isModuleSystemInited();\n@@ -693,17 +686,18 @@\n-            val = props.getProperty(\"sun.reflect.inflationThreshold\");\n-            if (val != null) {\n-                try {\n-                    inflationThreshold = Integer.parseInt(val);\n-                } catch (NumberFormatException e) {\n-                    throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n-                }\n-            }\n-            val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n-            if (val != null) {\n-                if (val.equals(\"false\")) {\n-                    useDirectMethodHandle = 0;\n-                } else if (val.equals(\"methods\")) {\n-                    useDirectMethodHandle = METHOD_MH_ACCESSOR;\n-                } else if (val.equals(\"fields\")) {\n-                    useDirectMethodHandle = FIELD_MH_ACCESSOR;\n-                }\n+        boolean noInflation = DEFAULT_CONFIG.noInflation;\n+        int inflationThreshold = DEFAULT_CONFIG.inflationThreshold;\n+        int useDirectMethodHandle = DEFAULT_CONFIG.useDirectMethodHandle;\n+        boolean useNativeAccessorOnly = DEFAULT_CONFIG.useNativeAccessorOnly;\n+        boolean disableSerialConstructorChecks = DEFAULT_CONFIG.disableSerialConstructorChecks;\n+\n+        Properties props = GetPropertyAction.privilegedGetProperties();\n+        String val = props.getProperty(\"sun.reflect.noInflation\");\n+        if (val != null && val.equals(\"true\")) {\n+            noInflation = true;\n+        }\n+\n+        val = props.getProperty(\"sun.reflect.inflationThreshold\");\n+        if (val != null) {\n+            try {\n+                inflationThreshold = Integer.parseInt(val);\n+            } catch (NumberFormatException e) {\n+                throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n@@ -711,3 +705,9 @@\n-            val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n-            if (val != null && val.equals(\"true\")) {\n-                useNativeAccessorOnly = true;\n+        }\n+        val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n+        if (val != null) {\n+            if (val.equals(\"false\")) {\n+                useDirectMethodHandle = 0;\n+            } else if (val.equals(\"methods\")) {\n+                useDirectMethodHandle = METHOD_MH_ACCESSOR;\n+            } else if (val.equals(\"fields\")) {\n+                useDirectMethodHandle = FIELD_MH_ACCESSOR;\n@@ -715,0 +715,5 @@\n+        }\n+        val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n+        if (val != null && val.equals(\"true\")) {\n+            useNativeAccessorOnly = true;\n+        }\n@@ -716,2 +721,2 @@\n-            disableSerialConstructorChecks =\n-                    \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+        disableSerialConstructorChecks =\n+                \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n@@ -719,8 +724,5 @@\n-            return new Config(\n-                    noInflation,\n-                    inflationThreshold,\n-                    useDirectMethodHandle,\n-                    useNativeAccessorOnly,\n-                    disableSerialConstructorChecks\n-            );\n-        }\n+        return new Config(noInflation,\n+                inflationThreshold,\n+                useDirectMethodHandle,\n+                useNativeAccessorOnly,\n+                disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":105,"deletions":103,"binary":false,"changes":208,"status":"modified"}]}