{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -64,1 +65,0 @@\n-    private static boolean initted = false;\n@@ -71,29 +71,0 @@\n-    \/\/\n-    \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n-    \/\/ Method.invoke() and Constructor.newInstance() currently costs\n-    \/\/ 3-4x more than an invocation via native code for the first\n-    \/\/ invocation (though subsequent invocations have been benchmarked\n-    \/\/ to be over 20x faster). Unfortunately this cost increases\n-    \/\/ startup time for certain applications that use reflection\n-    \/\/ intensively (but only once per class) to bootstrap themselves.\n-    \/\/ To avoid this penalty we reuse the existing JVM entry points\n-    \/\/ for the first few invocations of Methods and Constructors and\n-    \/\/ then switch to the bytecode-based implementations.\n-    \/\/\n-    \/\/ Package-private to be accessible to NativeMethodAccessorImpl\n-    \/\/ and NativeConstructorAccessorImpl\n-    private static boolean noInflation        = false;\n-    private static int     inflationThreshold = 15;\n-\n-    \/\/\n-    \/\/ New implementation uses direct invocation of method handles\n-    private static final int METHOD_MH_ACCESSOR      = 0x1;\n-    private static final int FIELD_MH_ACCESSOR       = 0x2;\n-    private static final int ALL_MH_ACCESSORS        = METHOD_MH_ACCESSOR|FIELD_MH_ACCESSOR;\n-\n-    private static int     useDirectMethodHandle = ALL_MH_ACCESSORS;\n-    private static boolean useNativeAccessorOnly = false;  \/\/ for testing only\n-\n-    \/\/ true if deserialization constructor checking is disabled\n-    private static boolean disableSerialConstructorChecks = false;\n-\n@@ -163,2 +134,0 @@\n-        checkInitted();\n-\n@@ -183,2 +152,0 @@\n-        checkInitted();\n-\n@@ -194,1 +161,1 @@\n-            if (noInflation && !method.getDeclaringClass().isHidden()) {\n+            if (noInflation() && !method.getDeclaringClass().isHidden()) {\n@@ -218,2 +185,0 @@\n-        checkInitted();\n-\n@@ -245,1 +210,1 @@\n-            if (noInflation && !c.getDeclaringClass().isHidden()) {\n+            if (noInflation() && !c.getDeclaringClass().isHidden()) {\n@@ -433,1 +398,1 @@\n-                (!disableSerialConstructorChecks && !superHasAccessibleConstructor(prev))) {\n+                (!disableSerialConstructorChecks() && !superHasAccessibleConstructor(prev))) {\n@@ -626,0 +591,2 @@\n+    \/\/ Package-private to be accessible to NativeMethodAccessorImpl\n+    \/\/ and NativeConstructorAccessorImpl\n@@ -627,1 +594,1 @@\n-        return inflationThreshold;\n+        return config().inflationThreshold;\n@@ -631,1 +598,1 @@\n-        return noInflation;\n+        return config().noInflation;\n@@ -635,1 +602,1 @@\n-        return (useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n+        return (config().useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n@@ -639,1 +606,1 @@\n-        return (useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n+        return (config().useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n@@ -643,1 +610,1 @@\n-        return useNativeAccessorOnly;\n+        return config().useNativeAccessorOnly;\n@@ -646,7 +613,59 @@\n-    \/** We have to defer full initialization of this class until after\n-        the static initializer is run since java.lang.reflect.Method's\n-        static initializer (more properly, that for\n-        java.lang.reflect.AccessibleObject) causes this class's to be\n-        run, before the system properties are set up. *\/\n-    private static void checkInitted() {\n-        if (initted) return;\n+    private static boolean disableSerialConstructorChecks() {\n+        return config().disableSerialConstructorChecks;\n+    }\n+\n+    \/\/ New implementation uses direct invocation of method handles\n+    private static final int METHOD_MH_ACCESSOR = 0x1;\n+    private static final int FIELD_MH_ACCESSOR = 0x2;\n+    private static final int ALL_MH_ACCESSORS = METHOD_MH_ACCESSOR | FIELD_MH_ACCESSOR;\n+\n+    \/**\n+     * The configuration is lazily initialized after the module system is initialized.\n+     *\n+     * The static initializer of ReflectionFactory is run before the system properties are set up.\n+     * The class initialization is caused by the class initialization of java.lang.reflect.Method\n+     * (more properly, caused by the class initialization for java.lang.reflect.AccessibleObject)\n+     * that happens very early VM startup, initPhase1.\n+     *\/\n+    private static @Stable Config config;\n+\n+    \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n+    \/\/ Method.invoke() and Constructor.newInstance() currently costs\n+    \/\/ 3-4x more than an invocation via native code for the first\n+    \/\/ invocation (though subsequent invocations have been benchmarked\n+    \/\/ to be over 20x faster). Unfortunately this cost increases\n+    \/\/ startup time for certain applications that use reflection\n+    \/\/ intensively (but only once per class) to bootstrap themselves.\n+    \/\/ To avoid this penalty we reuse the existing JVM entry points\n+    \/\/ for the first few invocations of Methods and Constructors and\n+    \/\/ then switch to the bytecode-based implementations.\n+\n+    private static final Config DEFAULT_CONFIG = new Config(false, \/\/ noInflation\n+            15, \/\/ inflationThreshold\n+            ALL_MH_ACCESSORS, \/\/ useDirectMethodHandle\n+            false, \/\/ useNativeAccessorOnly\n+            false); \/\/ disableSerialConstructorChecks\n+\n+    \/**\n+     * The configurations for the reflection factory. Configurable via\n+     * system properties but only available after ReflectionFactory is\n+     * loaded during early VM startup. See bug 8261407.\n+     *\n+     * Note that the default implementation of the object methods of\n+     * this Config record (toString, equals, hashCode) use indy,\n+     * which is available to use only after initPhase1. These methods\n+     * are currently not called, but should they be needed, a workaround\n+     * is to override them.\n+     *\/\n+    private record Config(boolean noInflation,\n+                          int inflationThreshold,\n+                          int useDirectMethodHandle,\n+                          boolean useNativeAccessorOnly,\n+                          boolean disableSerialConstructorChecks) {\n+    }\n+\n+    private static Config config() {\n+        Config c = config;\n+        if (c != null) {\n+            return c;\n+        }\n@@ -658,1 +677,1 @@\n-            return;\n+            return DEFAULT_CONFIG;\n@@ -661,0 +680,12 @@\n+        return config = loadConfig();\n+    }\n+\n+    private static Config loadConfig() {\n+        assert VM.isModuleSystemInited();\n+\n+        boolean noInflation = DEFAULT_CONFIG.noInflation;\n+        int inflationThreshold = DEFAULT_CONFIG.inflationThreshold;\n+        int useDirectMethodHandle = DEFAULT_CONFIG.useDirectMethodHandle;\n+        boolean useNativeAccessorOnly = DEFAULT_CONFIG.useNativeAccessorOnly;\n+        boolean disableSerialConstructorChecks = DEFAULT_CONFIG.disableSerialConstructorChecks;\n+\n@@ -691,1 +722,1 @@\n-            \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+                \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n@@ -693,1 +724,5 @@\n-        initted = true;\n+        return new Config(noInflation,\n+                inflationThreshold,\n+                useDirectMethodHandle,\n+                useNativeAccessorOnly,\n+                disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":89,"deletions":54,"binary":false,"changes":143,"status":"modified"}]}