{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -64,1 +65,0 @@\n-    private static boolean initted = false;\n@@ -71,29 +71,0 @@\n-    \/\/\n-    \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n-    \/\/ Method.invoke() and Constructor.newInstance() currently costs\n-    \/\/ 3-4x more than an invocation via native code for the first\n-    \/\/ invocation (though subsequent invocations have been benchmarked\n-    \/\/ to be over 20x faster). Unfortunately this cost increases\n-    \/\/ startup time for certain applications that use reflection\n-    \/\/ intensively (but only once per class) to bootstrap themselves.\n-    \/\/ To avoid this penalty we reuse the existing JVM entry points\n-    \/\/ for the first few invocations of Methods and Constructors and\n-    \/\/ then switch to the bytecode-based implementations.\n-    \/\/\n-    \/\/ Package-private to be accessible to NativeMethodAccessorImpl\n-    \/\/ and NativeConstructorAccessorImpl\n-    private static boolean noInflation        = false;\n-    private static int     inflationThreshold = 15;\n-\n-    \/\/\n-    \/\/ New implementation uses direct invocation of method handles\n-    private static final int METHOD_MH_ACCESSOR      = 0x1;\n-    private static final int FIELD_MH_ACCESSOR       = 0x2;\n-    private static final int ALL_MH_ACCESSORS        = METHOD_MH_ACCESSOR|FIELD_MH_ACCESSOR;\n-\n-    private static int     useDirectMethodHandle = ALL_MH_ACCESSORS;\n-    private static boolean useNativeAccessorOnly = false;  \/\/ for testing only\n-\n-    \/\/ true if deserialization constructor checking is disabled\n-    private static boolean disableSerialConstructorChecks = false;\n-\n@@ -163,2 +134,0 @@\n-        checkInitted();\n-\n@@ -183,2 +152,0 @@\n-        checkInitted();\n-\n@@ -194,1 +161,1 @@\n-            if (noInflation && !method.getDeclaringClass().isHidden()) {\n+            if (noInflation() && !method.getDeclaringClass().isHidden()) {\n@@ -218,2 +185,0 @@\n-        checkInitted();\n-\n@@ -245,1 +210,1 @@\n-            if (noInflation && !c.getDeclaringClass().isHidden()) {\n+            if (noInflation() && !c.getDeclaringClass().isHidden()) {\n@@ -433,1 +398,1 @@\n-                (!disableSerialConstructorChecks && !superHasAccessibleConstructor(prev))) {\n+                (!disableSerialConstructorChecks() && !superHasAccessibleConstructor(prev))) {\n@@ -626,0 +591,2 @@\n+    \/\/ Package-private to be accessible to NativeMethodAccessorImpl\n+    \/\/ and NativeConstructorAccessorImpl\n@@ -627,1 +594,1 @@\n-        return inflationThreshold;\n+        return Config.instance().inflationThreshold;\n@@ -631,1 +598,1 @@\n-        return noInflation;\n+        return Config.instance().noInflation;\n@@ -635,1 +602,1 @@\n-        return (useDirectMethodHandle & METHOD_MH_ACCESSOR) == METHOD_MH_ACCESSOR;\n+        return (Config.instance().useDirectMethodHandle & Config.METHOD_MH_ACCESSOR) == Config.METHOD_MH_ACCESSOR;\n@@ -639,1 +606,1 @@\n-        return (useDirectMethodHandle & FIELD_MH_ACCESSOR) == FIELD_MH_ACCESSOR;\n+        return (Config.instance().useDirectMethodHandle & Config.FIELD_MH_ACCESSOR) == Config.FIELD_MH_ACCESSOR;\n@@ -643,17 +610,2 @@\n-        return useNativeAccessorOnly;\n-    }\n-\n-    \/** We have to defer full initialization of this class until after\n-        the static initializer is run since java.lang.reflect.Method's\n-        static initializer (more properly, that for\n-        java.lang.reflect.AccessibleObject) causes this class's to be\n-        run, before the system properties are set up. *\/\n-    private static void checkInitted() {\n-        if (initted) return;\n-\n-        \/\/ Defer initialization until module system is initialized so as\n-        \/\/ to avoid inflation and spinning bytecode in unnamed modules\n-        \/\/ during early startup.\n-        if (!VM.isModuleSystemInited()) {\n-            return;\n-        }\n+        return Config.instance().useNativeAccessorOnly;\n+    }\n@@ -661,5 +613,3 @@\n-        Properties props = GetPropertyAction.privilegedGetProperties();\n-        String val = props.getProperty(\"sun.reflect.noInflation\");\n-        if (val != null && val.equals(\"true\")) {\n-            noInflation = true;\n-        }\n+    private static boolean disableSerialConstructorChecks() {\n+        return Config.instance().disableSerialConstructorChecks;\n+    }\n@@ -667,6 +617,49 @@\n-        val = props.getProperty(\"sun.reflect.inflationThreshold\");\n-        if (val != null) {\n-            try {\n-                inflationThreshold = Integer.parseInt(val);\n-            } catch (NumberFormatException e) {\n-                throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n+    \/**\n+     * The configurations exist as an object to avoid race conditions.\n+     * See bug 8261407. The object methods backed by indy may not be available.\n+     *\/\n+    private record Config(\n+            \/\/ \"Inflation\" mechanism. Loading bytecodes to implement\n+            \/\/ Method.invoke() and Constructor.newInstance() currently costs\n+            \/\/ 3-4x more than an invocation via native code for the first\n+            \/\/ invocation (though subsequent invocations have been benchmarked\n+            \/\/ to be over 20x faster). Unfortunately this cost increases\n+            \/\/ startup time for certain applications that use reflection\n+            \/\/ intensively (but only once per class) to bootstrap themselves.\n+            \/\/ To avoid this penalty we reuse the existing JVM entry points\n+            \/\/ for the first few invocations of Methods and Constructors and\n+            \/\/ then switch to the bytecode-based implementations.\n+            boolean noInflation,\n+            int inflationThreshold,\n+            int useDirectMethodHandle,\n+            boolean useNativeAccessorOnly,\n+            \/\/ true if deserialization constructor checking is disabled\n+            boolean disableSerialConstructorChecks\n+    ) {\n+\n+        \/\/ New implementation uses direct invocation of method handles\n+        private static final int METHOD_MH_ACCESSOR = 0x1;\n+        private static final int FIELD_MH_ACCESSOR = 0x2;\n+        private static final int ALL_MH_ACCESSORS = METHOD_MH_ACCESSOR | FIELD_MH_ACCESSOR;\n+\n+        private static final Config DEFAULT = new Config(\n+                false, \/\/ noInflation\n+                15, \/\/ inflationThreshold\n+                ALL_MH_ACCESSORS, \/\/ useDirectMethodHandle\n+                false, \/\/ useNativeAccessorOnly\n+                false \/\/ disableSerialConstructorChecks\n+        );\n+\n+        \/**\n+         * We have to defer full initialization of this class until after\n+         * the static initializer is run since java.lang.reflect.Method's\n+         * static initializer (more properly, that for\n+         * java.lang.reflect.AccessibleObject) causes this class's to be\n+         * run, before the system properties are set up.\n+         *\/\n+        private static @Stable Config instance;\n+\n+        private static Config instance() {\n+            Config c = instance;\n+            if (c != null) {\n+                return c;\n@@ -674,9 +667,6 @@\n-        }\n-        val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n-        if (val != null) {\n-            if (val.equals(\"false\")) {\n-                useDirectMethodHandle = 0;\n-            } else if (val.equals(\"methods\")) {\n-                useDirectMethodHandle = METHOD_MH_ACCESSOR;\n-            } else if (val.equals(\"fields\")) {\n-                useDirectMethodHandle = FIELD_MH_ACCESSOR;\n+\n+            \/\/ Defer initialization until module system is initialized so as\n+            \/\/ to avoid inflation and spinning bytecode in unnamed modules\n+            \/\/ during early startup.\n+            if (!VM.isModuleSystemInited()) {\n+                return DEFAULT;\n@@ -684,0 +674,2 @@\n+\n+            return instance = load();\n@@ -685,4 +677,0 @@\n-        val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n-        if (val != null && val.equals(\"true\")) {\n-            useNativeAccessorOnly = true;\n-        }\n@@ -690,2 +678,37 @@\n-        disableSerialConstructorChecks =\n-            \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+        private static Config load() {\n+            assert VM.isModuleSystemInited();\n+\n+            boolean noInflation = DEFAULT.noInflation;\n+            int inflationThreshold = DEFAULT.inflationThreshold;\n+            int useDirectMethodHandle = DEFAULT.useDirectMethodHandle;\n+            boolean useNativeAccessorOnly = DEFAULT.useNativeAccessorOnly;\n+            boolean disableSerialConstructorChecks = DEFAULT.disableSerialConstructorChecks;\n+\n+            Properties props = GetPropertyAction.privilegedGetProperties();\n+            String val = props.getProperty(\"sun.reflect.noInflation\");\n+            if (val != null && val.equals(\"true\")) {\n+                noInflation = true;\n+            }\n+\n+            val = props.getProperty(\"sun.reflect.inflationThreshold\");\n+            if (val != null) {\n+                try {\n+                    inflationThreshold = Integer.parseInt(val);\n+                } catch (NumberFormatException e) {\n+                    throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n+                }\n+            }\n+            val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n+            if (val != null) {\n+                if (val.equals(\"false\")) {\n+                    useDirectMethodHandle = 0;\n+                } else if (val.equals(\"methods\")) {\n+                    useDirectMethodHandle = METHOD_MH_ACCESSOR;\n+                } else if (val.equals(\"fields\")) {\n+                    useDirectMethodHandle = FIELD_MH_ACCESSOR;\n+                }\n+            }\n+            val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n+            if (val != null && val.equals(\"true\")) {\n+                useNativeAccessorOnly = true;\n+            }\n@@ -693,1 +716,11 @@\n-        initted = true;\n+            disableSerialConstructorChecks =\n+                    \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+\n+            return new Config(\n+                    noInflation,\n+                    inflationThreshold,\n+                    useDirectMethodHandle,\n+                    useNativeAccessorOnly,\n+                    disableSerialConstructorChecks\n+            );\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":120,"deletions":87,"binary":false,"changes":207,"status":"modified"}]}