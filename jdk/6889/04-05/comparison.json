{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -593,1 +594,1 @@\n-        return config().inflationThreshold;\n+        return Config.instance().inflationThreshold;\n@@ -597,1 +598,1 @@\n-        return config().noInflation;\n+        return Config.instance().noInflation;\n@@ -601,1 +602,1 @@\n-        return (config().useDirectMethodHandle & Config.METHOD_MH_ACCESSOR) == Config.METHOD_MH_ACCESSOR;\n+        return (Config.instance().useDirectMethodHandle & Config.METHOD_MH_ACCESSOR) == Config.METHOD_MH_ACCESSOR;\n@@ -605,1 +606,1 @@\n-        return (config().useDirectMethodHandle & Config.FIELD_MH_ACCESSOR) == Config.FIELD_MH_ACCESSOR;\n+        return (Config.instance().useDirectMethodHandle & Config.FIELD_MH_ACCESSOR) == Config.FIELD_MH_ACCESSOR;\n@@ -609,1 +610,1 @@\n-        return config().useNativeAccessorOnly;\n+        return Config.instance().useNativeAccessorOnly;\n@@ -613,23 +614,1 @@\n-        return config().disableSerialConstructorChecks;\n-    }\n-\n-    \/** We have to defer full initialization of this class until after\n-        the static initializer is run since java.lang.reflect.Method's\n-        static initializer (more properly, that for\n-        java.lang.reflect.AccessibleObject) causes this class's to be\n-        run, before the system properties are set up. *\/\n-    private static Config config;\n-\n-    private static Config config() {\n-        \/\/ Defer initialization until module system is initialized so as\n-        \/\/ to avoid inflation and spinning bytecode in unnamed modules\n-        \/\/ during early startup.\n-        if (!VM.isModuleSystemInited()) {\n-            return Config.fallback;\n-        }\n-\n-        Config c = config;\n-        if (c == null) {\n-            config = c = new Config(true);\n-        }\n-        return c;\n+        return Config.instance().disableSerialConstructorChecks;\n@@ -640,1 +619,1 @@\n-     * See bug 8261407.\n+     * See bug 8261407. Indy is not ready so this cannot be a record.\n@@ -643,2 +622,0 @@\n-        private static final Config fallback = new Config(false);\n-\n@@ -672,41 +649,17 @@\n-        private Config(boolean getProperties) {\n-            boolean noInflation = false;\n-            int inflationThreshold = 15;\n-            int useDirectMethodHandle = ALL_MH_ACCESSORS;\n-            boolean useNativeAccessorOnly = false;\n-            boolean disableSerialConstructorChecks = false;\n-\n-            if (getProperties) {\n-                Properties props = GetPropertyAction.privilegedGetProperties();\n-                String val = props.getProperty(\"sun.reflect.noInflation\");\n-                if (val != null && val.equals(\"true\")) {\n-                    noInflation = true;\n-                }\n-\n-                val = props.getProperty(\"sun.reflect.inflationThreshold\");\n-                if (val != null) {\n-                    try {\n-                        inflationThreshold = Integer.parseInt(val);\n-                    } catch (NumberFormatException e) {\n-                        throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n-                    }\n-                }\n-                val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n-                if (val != null) {\n-                    if (val.equals(\"false\")) {\n-                        useDirectMethodHandle = 0;\n-                    } else if (val.equals(\"methods\")) {\n-                        useDirectMethodHandle = METHOD_MH_ACCESSOR;\n-                    } else if (val.equals(\"fields\")) {\n-                        useDirectMethodHandle = FIELD_MH_ACCESSOR;\n-                    }\n-                }\n-                val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n-                if (val != null && val.equals(\"true\")) {\n-                    useNativeAccessorOnly = true;\n-                }\n-\n-                disableSerialConstructorChecks =\n-                        \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n-            }\n-\n+        private static final Config DEFAULT = new Config(\n+                false, \/\/ noInflation\n+                15, \/\/ inflationThreshold\n+                ALL_MH_ACCESSORS, \/\/ useDirectMethodHandle\n+                false, \/\/ useNativeAccessorOnly\n+                false \/\/ disableSerialConstructorChecks\n+        );\n+\n+        \/** We have to defer full initialization of this class until after\n+         the static initializer is run since java.lang.reflect.Method's\n+         static initializer (more properly, that for\n+         java.lang.reflect.AccessibleObject) causes this class's to be\n+         run, before the system properties are set up. *\/\n+        private static @Stable Config instance;\n+\n+        private Config(boolean noInflation, int inflationThreshold, int useDirectMethodHandle,\n+                       boolean useNativeAccessorOnly, boolean disableSerialConstructorChecks) {\n@@ -719,0 +672,65 @@\n+\n+        private static Config instance() {\n+            \/\/ Defer initialization until module system is initialized so as\n+            \/\/ to avoid inflation and spinning bytecode in unnamed modules\n+            \/\/ during early startup.\n+            if (!VM.isModuleSystemInited()) {\n+                return DEFAULT;\n+            }\n+\n+            Config c = instance;\n+            if (c == null) {\n+                instance = c = load();\n+            }\n+            return c;\n+        }\n+\n+        private static Config load() {\n+            assert VM.isModuleSystemInited();\n+\n+            boolean noInflation = DEFAULT.noInflation;\n+            int inflationThreshold = DEFAULT.inflationThreshold;\n+            int useDirectMethodHandle = DEFAULT.useDirectMethodHandle;\n+            boolean useNativeAccessorOnly = DEFAULT.useNativeAccessorOnly;\n+            boolean disableSerialConstructorChecks = DEFAULT.disableSerialConstructorChecks;\n+\n+            Properties props = GetPropertyAction.privilegedGetProperties();\n+            String val = props.getProperty(\"sun.reflect.noInflation\");\n+            if (val != null && val.equals(\"true\")) {\n+                noInflation = true;\n+            }\n+\n+            val = props.getProperty(\"sun.reflect.inflationThreshold\");\n+            if (val != null) {\n+                try {\n+                    inflationThreshold = Integer.parseInt(val);\n+                } catch (NumberFormatException e) {\n+                    throw new RuntimeException(\"Unable to parse property sun.reflect.inflationThreshold\", e);\n+                }\n+            }\n+            val = props.getProperty(\"jdk.reflect.useDirectMethodHandle\");\n+            if (val != null) {\n+                if (val.equals(\"false\")) {\n+                    useDirectMethodHandle = 0;\n+                } else if (val.equals(\"methods\")) {\n+                    useDirectMethodHandle = METHOD_MH_ACCESSOR;\n+                } else if (val.equals(\"fields\")) {\n+                    useDirectMethodHandle = FIELD_MH_ACCESSOR;\n+                }\n+            }\n+            val = props.getProperty(\"jdk.reflect.useNativeAccessorOnly\");\n+            if (val != null && val.equals(\"true\")) {\n+                useNativeAccessorOnly = true;\n+            }\n+\n+            disableSerialConstructorChecks =\n+                    \"true\".equals(props.getProperty(\"jdk.disableSerialConstructorChecks\"));\n+\n+            return new Config(\n+                    noInflation,\n+                    inflationThreshold,\n+                    useDirectMethodHandle,\n+                    useNativeAccessorOnly,\n+                    disableSerialConstructorChecks\n+            );\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":90,"deletions":72,"binary":false,"changes":162,"status":"modified"}]}