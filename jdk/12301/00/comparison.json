{"files":[{"patch":"@@ -63,0 +63,1 @@\n+    private static final double TWO54   =  0x1.0p54; \/\/ 1.80143985094819840000e+16\n@@ -782,1 +783,0 @@\n-        private static double two54     = 0x1.0p54;              \/\/ 1.80143985094819840000e+16;\n@@ -802,1 +802,1 @@\n-                    return -two54\/0.0;               \/* log(+-0)=-inf *\/\n+                    return -TWO54\/0.0;               \/* log(+-0)=-inf *\/\n@@ -808,1 +808,1 @@\n-                x *= two54; \/* subnormal number, scale up x *\/\n+                x *= TWO54; \/* subnormal number, scale up x *\/\n@@ -825,0 +825,163 @@\n+\n+    \/**\n+     * Returns the natural logarithm of the sum of the argument and 1.\n+     *\n+     * Method :\n+     *   1. Argument Reduction: find k and f such that\n+     *                      1+x = 2^k * (1+f),\n+     *         where  sqrt(2)\/2 < 1+f < sqrt(2) .\n+     *\n+     *      Note. If k=0, then f=x is exact. However, if k!=0, then f\n+     *      may not be representable exactly. In that case, a correction\n+     *      term is need. Let u=1+x rounded. Let c = (1+x)-u, then\n+     *      log(1+x) - log(u) ~ c\/u. Thus, we proceed to compute log(u),\n+     *      and add back the correction term c\/u.\n+     *      (Note: when x > 2**53, one can simply return log(x))\n+     *\n+     *   2. Approximation of log1p(f).\n+     *      Let s = f\/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n+     *               = 2s + 2\/3 s**3 + 2\/5 s**5 + .....,\n+     *               = 2s + s*R\n+     *      We use a special Reme algorithm on [0,0.1716] to generate\n+     *      a polynomial of degree 14 to approximate R The maximum error\n+     *      of this polynomial approximation is bounded by 2**-58.45. In\n+     *      other words,\n+     *                      2      4      6      8      10      12      14\n+     *          R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s\n+     *      (the values of Lp1 to Lp7 are listed in the program)\n+     *      and\n+     *          |      2          14          |     -58.45\n+     *          | Lp1*s +...+Lp7*s    -  R(z) | <= 2\n+     *          |                             |\n+     *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f\/2.\n+     *      In order to guarantee error in log below 1ulp, we compute log\n+     *      by\n+     *              log1p(f) = f - (hfsq - s*(hfsq+R)).\n+     *\n+     *      3. Finally, log1p(x) = k*ln2 + log1p(f).\n+     *                           = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n+     *         Here ln2 is split into two floating point number:\n+     *                      ln2_hi + ln2_lo,\n+     *         where n*ln2_hi is always exact for |n| < 2000.\n+     *\n+     * Special cases:\n+     *      log1p(x) is NaN with signal if x < -1 (including -INF) ;\n+     *      log1p(+INF) is +INF; log1p(-1) is -INF with signal;\n+     *      log1p(NaN) is that NaN with no signal.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\n+     * Note: Assuming log() return accurate answer, the following\n+     *       algorithm can be used to compute log1p(x) to within a few ULP:\n+     *\n+     *              u = 1+x;\n+     *              if(u==1.0) return x ; else\n+     *                         return log(u)*(x\/(u-1.0));\n+     *\n+     *       See HP-15C Advanced Functions Handbook, p.193.\n+     *\/\n+    static class Log1p {\n+        private static final double ln2_hi = 0x1.62e42feep-1;       \/\/ 6.93147180369123816490e-01\n+        private static final double ln2_lo = 0x1.a39ef35793c76p-33; \/\/ 1.90821492927058770002e-10\n+        private static final double Lp1    = 0x1.5555555555593p-1;  \/\/ 6.666666666666735130e-01\n+        private static final double Lp2    = 0x1.999999997fa04p-2;  \/\/ 3.999999999940941908e-01\n+        private static final double Lp3    = 0x1.2492494229359p-2;  \/\/ 2.857142874366239149e-01\n+        private static final double Lp4    = 0x1.c71c51d8e78afp-3;  \/\/ 2.222219843214978396e-01\n+        private static final double Lp5    = 0x1.7466496cb03dep-3;  \/\/ 1.818357216161805012e-01\n+        private static final double Lp6    = 0x1.39a09d078c69fp-3;  \/\/ 1.531383769920937332e-01\n+        private static final double Lp7    = 0x1.2f112df3e5244p-3;  \/\/ 1.479819860511658591e-01\n+\n+        public static double compute(double x) {\n+            double hfsq, f=0, c=0, s, z, R, u;\n+            int k, hx, hu=0, ax;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            ax = hx & 0x7fffffff;\n+\n+            k = 1;\n+            if (hx < 0x3FDA827A) {                  \/* x < 0.41422  *\/\n+                if(ax >= 0x3ff00000) {                \/* x <= -1.0 *\/\n+                    if (x == -1.0) \/* log1p(-1)=-inf *\/\n+                        return -INFINITY;\n+                    else\n+                        return Double.NaN;           \/* log1p(x < -1) = NaN *\/\n+                }\n+\n+                if (ax < 0x3e200000) {                 \/* |x| < 2**-29 *\/\n+                    if (TWO54 + x > 0.0                 \/* raise inexact *\/\n+                       && ax < 0x3c900000)            \/* |x| < 2**-54 *\/\n+                        return x;\n+                    else\n+                        return x - x*x*0.5;\n+                }\n+\n+                if (hx > 0 || hx <= 0xbfd2bec3) { \/* -0.2929 < x < 0.41422 *\/\n+                    k=0;\n+                    f=x;\n+                    hu=1;\n+                }\n+            }\n+\n+            if (hx >= 0x7ff00000) {\n+                return x+x;\n+            }\n+\n+            if (k != 0) {\n+                if (hx < 0x43400000) {\n+                    u  = 1.0 + x;\n+                    hu = __HI(u);           \/* high word of u *\/\n+                    k  = (hu >> 20) - 1023;\n+                    c  = (k > 0)? 1.0 - (u-x) : x-(u-1.0); \/* correction term *\/\n+                    c \/= u;\n+                } else {\n+                    u  = x;\n+                    hu = __HI(u);           \/* high word of u *\/\n+                    k  = (hu >> 20) - 1023;\n+                    c  = 0;\n+                }\n+                hu &= 0x000fffff;\n+                if (hu < 0x6a09e) {\n+                    u = __HI(u, hu | 0x3ff00000);        \/* normalize u *\/\n+                } else {\n+                    k += 1;\n+                    u = __HI(u, hu | 0x3fe00000);        \/* normalize u\/2 *\/\n+                    hu = (0x00100000 - hu) >> 2;\n+                }\n+                f = u - 1.0;\n+            }\n+\n+            hfsq = 0.5*f*f;\n+            if (hu == 0) {     \/* |f| < 2**-20 *\/\n+                if (f == 0.0) {\n+                    if (k == 0) {\n+                        return 0.0;\n+                    } else {\n+                        c += k * ln2_lo;\n+                        return k * ln2_hi + c;\n+                    }\n+                }\n+                R = hfsq * (1.0 - 0.66666666666666666*f);\n+                if (k == 0) {\n+                    return f - R;\n+                } else {\n+                    return k * ln2_hi - ((R-(k * ln2_lo+c)) - f);\n+                }\n+            }\n+            s = f\/(2.0 + f);\n+            z = s * s;\n+            R = z * (Lp1 + z * (Lp2 + z * (Lp3 + z * (Lp4 + z * (Lp5 + z * (Lp6 + z*Lp7))))));\n+            if (k == 0) {\n+                return f-(hfsq-s*(hfsq+R));\n+            } else {\n+                return k * ln2_hi - ((hfsq - (s*(hfsq + R) + (k * ln2_lo+c))) - f);\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/FdLibm.java","additions":166,"deletions":3,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -2127,1 +2127,3 @@\n-    public static native double log1p(double x);\n+    public static double log1p(double x) {\n+        return FdLibm.Log1p.compute(x);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StrictMath.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -85,0 +85,4 @@\n+    public static double log1p(double x) {\n+        return Log1p.compute(x);\n+    }\n+\n@@ -463,0 +467,147 @@\n+\n+    \/**\n+     * Returns the natural logarithm of the sum of the argument and 1.\n+     *\n+     * Method :\n+     *   1. Argument Reduction: find k and f such that\n+     *                      1+x = 2^k * (1+f),\n+     *         where  sqrt(2)\/2 < 1+f < sqrt(2) .\n+     *\n+     *      Note. If k=0, then f=x is exact. However, if k!=0, then f\n+     *      may not be representable exactly. In that case, a correction\n+     *      term is need. Let u=1+x rounded. Let c = (1+x)-u, then\n+     *      log(1+x) - log(u) ~ c\/u. Thus, we proceed to compute log(u),\n+     *      and add back the correction term c\/u.\n+     *      (Note: when x > 2**53, one can simply return log(x))\n+     *\n+     *   2. Approximation of log1p(f).\n+     *      Let s = f\/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)\n+     *               = 2s + 2\/3 s**3 + 2\/5 s**5 + .....,\n+     *               = 2s + s*R\n+     *      We use a special Reme algorithm on [0,0.1716] to generate\n+     *      a polynomial of degree 14 to approximate R The maximum error\n+     *      of this polynomial approximation is bounded by 2**-58.45. In\n+     *      other words,\n+     *                      2      4      6      8      10      12      14\n+     *          R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s\n+     *      (the values of Lp1 to Lp7 are listed in the program)\n+     *      and\n+     *          |      2          14          |     -58.45\n+     *          | Lp1*s +...+Lp7*s    -  R(z) | <= 2\n+     *          |                             |\n+     *      Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f\/2.\n+     *      In order to guarantee error in log below 1ulp, we compute log\n+     *      by\n+     *              log1p(f) = f - (hfsq - s*(hfsq+R)).\n+     *\n+     *      3. Finally, log1p(x) = k*ln2 + log1p(f).\n+     *                           = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))\n+     *         Here ln2 is split into two floating point number:\n+     *                      ln2_hi + ln2_lo,\n+     *         where n*ln2_hi is always exact for |n| < 2000.\n+     *\n+     * Special cases:\n+     *      log1p(x) is NaN with signal if x < -1 (including -INF) ;\n+     *      log1p(+INF) is +INF; log1p(-1) is -INF with signal;\n+     *      log1p(NaN) is that NaN with no signal.\n+     *\n+     * Accuracy:\n+     *      according to an error analysis, the error is always less than\n+     *      1 ulp (unit in the last place).\n+     *\n+     * Constants:\n+     * The hexadecimal values are the intended ones for the following\n+     * constants. The decimal values may be used, provided that the\n+     * compiler will convert from decimal to binary accurately enough\n+     * to produce the hexadecimal values shown.\n+     *\n+     * Note: Assuming log() return accurate answer, the following\n+     *       algorithm can be used to compute log1p(x) to within a few ULP:\n+     *\n+     *              u = 1+x;\n+     *              if(u==1.0) return x ; else\n+     *                         return log(u)*(x\/(u-1.0));\n+     *\n+     *       See HP-15C Advanced Functions Handbook, p.193.\n+     *\/\n+    static class Log1p {\n+        private static double ln2_hi  =  6.93147180369123816490e-01;  \/* 3fe62e42 fee00000 *\/\n+        private static double ln2_lo  =  1.90821492927058770002e-10;  \/* 3dea39ef 35793c76 *\/\n+        private static double two54   =  1.80143985094819840000e+16;  \/* 43500000 00000000 *\/\n+        private static double Lp1 = 6.666666666666735130e-01;  \/* 3FE55555 55555593 *\/\n+        private static double Lp2 = 3.999999999940941908e-01;  \/* 3FD99999 9997FA04 *\/\n+        private static double Lp3 = 2.857142874366239149e-01;  \/* 3FD24924 94229359 *\/\n+        private static double Lp4 = 2.222219843214978396e-01;  \/* 3FCC71C5 1D8E78AF *\/\n+        private static double Lp5 = 1.818357216161805012e-01;  \/* 3FC74664 96CB03DE *\/\n+        private static double Lp6 = 1.531383769920937332e-01;  \/* 3FC39A09 D078C69F *\/\n+        private static double Lp7 = 1.479819860511658591e-01;  \/* 3FC2F112 DF3E5244 *\/\n+        private static double zero = 0.0;\n+\n+        public static double compute(double x) {\n+            double hfsq,f=0,c=0,s,z,R,u;\n+            int k,hx,hu=0,ax;\n+\n+            hx = __HI(x);           \/* high word of x *\/\n+            ax = hx&0x7fffffff;\n+\n+            k = 1;\n+            if (hx < 0x3FDA827A) {                  \/* x < 0.41422  *\/\n+                if(ax>=0x3ff00000) {                \/* x <= -1.0 *\/\n+                    \/*\n+                     * Added redundant test against hx to work around VC++\n+                     * code generation problem.\n+                     *\/\n+                    if(x==-1.0 && (hx==0xbff00000)) \/* log1p(-1)=-inf *\/\n+                        return -two54\/zero;\n+                    else\n+                        return (x-x)\/(x-x);           \/* log1p(x<-1)=NaN *\/\n+                }\n+                if(ax<0x3e200000) {                 \/* |x| < 2**-29 *\/\n+                    if(two54+x>zero                 \/* raise inexact *\/\n+                       &&ax<0x3c900000)            \/* |x| < 2**-54 *\/\n+                        return x;\n+                    else\n+                        return x - x*x*0.5;\n+                }\n+                if(hx>0||hx<=((int)0xbfd2bec3)) {\n+                    k=0;f=x;hu=1;}  \/* -0.2929<x<0.41422 *\/\n+            }\n+            if (hx >= 0x7ff00000) return x+x;\n+            if(k!=0) {\n+                if(hx<0x43400000) {\n+                    u  = 1.0+x;\n+                    hu = __HI(u);           \/* high word of u *\/\n+                    k  = (hu>>20)-1023;\n+                    c  = (k>0)? 1.0-(u-x):x-(u-1.0);\/* correction term *\/\n+                    c \/= u;\n+                } else {\n+                    u  = x;\n+                    hu = __HI(u);           \/* high word of u *\/\n+                    k  = (hu>>20)-1023;\n+                    c  = 0;\n+                }\n+                hu &= 0x000fffff;\n+                if(hu<0x6a09e) {\n+                    u = __HI(u, hu|0x3ff00000);        \/* normalize u *\/\n+                } else {\n+                    k += 1;\n+                    u = __HI(u, hu|0x3fe00000);        \/* normalize u\/2 *\/\n+                    hu = (0x00100000-hu)>>2;\n+                }\n+                f = u-1.0;\n+            }\n+            hfsq=0.5*f*f;\n+            if(hu==0) {     \/* |f| < 2**-20 *\/\n+                if(f==zero) { if(k==0) return zero;\n+                    else {c += k*ln2_lo; return k*ln2_hi+c;}}\n+                R = hfsq*(1.0-0.66666666666666666*f);\n+                if(k==0) return f-R; else\n+                    return k*ln2_hi-((R-(k*ln2_lo+c))-f);\n+            }\n+            s = f\/(2.0+f);\n+            z = s*s;\n+            R = z*(Lp1+z*(Lp2+z*(Lp3+z*(Lp4+z*(Lp5+z*(Lp6+z*Lp7))))));\n+            if(k==0) return f-(hfsq-s*(hfsq+R)); else\n+                return k*ln2_hi-((hfsq-(s*(hfsq+R)+(k*ln2_lo+c)))-f);\n+        }\n+    }\n","filename":"test\/jdk\/java\/lang\/StrictMath\/FdlibmTranslit.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,8 @@\n- * @bug 4851638\n+ * @bug 4851638 8301392\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n+ * @build Tests\n+ * @build FdlibmTranslit\n+ * @build Log1pTests\n+ * @run main Log1pTests\n@@ -30,0 +37,2 @@\n+import jdk.test.lib.RandomFactory;\n+\n@@ -44,0 +53,13 @@\n+    public static void main(String... args) {\n+        int failures = 0;\n+\n+        failures += testLog1p();\n+        failures += testAgainstTranslit();\n+\n+        if (failures > 0) {\n+            System.err.println(\"Testing log1p incurred \"\n+                               + failures + \" failures.\");\n+            throw new RuntimeException();\n+        }\n+    }\n+\n@@ -198,1 +220,7 @@\n-    public static void main(String [] argv) {\n+    \/\/ Initialize shared random number generator\n+    private static java.util.Random random = RandomFactory.getRandom();\n+\n+    \/**\n+     * Test StrictMath.log1p against transliteration port of log1p.\n+     *\/\n+    private static int testAgainstTranslit() {\n@@ -200,0 +228,1 @@\n+        double x;\n@@ -201,1 +230,3 @@\n-        failures += testLog1p();\n+        \/\/ Test just above subnormal threshold...\n+        x = Double.MIN_NORMAL;\n+        failures += testRange(x, Math.ulp(x), 1000);\n@@ -203,4 +234,32 @@\n-        if (failures > 0) {\n-            System.err.println(\"Testing log1p incurred \"\n-                               + failures + \" failures.\");\n-            throw new RuntimeException();\n+        \/\/ ... and just below subnormal threshold ...\n+        x =  Math.nextDown(Double.MIN_NORMAL);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 1.0 ...\n+        x = 1.0;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+        x = Math.nextDown(1.0);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+        \/\/ ... and near 2^-29 ...\n+        x = 0x1.0p-29;\n+        failures += testRange(x, Math.ulp(x), 1000);\n+        x = Math.nextDown(1.0);\n+        failures += testRange(x, -Math.ulp(x), 1000);\n+\n+         x = Tests.createRandomDouble(random);\n+\n+         \/\/ Make the increment twice the ulp value in case the random\n+         \/\/ value is near an exponent threshold. Don't worry about test\n+         \/\/ elements overflowing to infinity if the starting value is\n+         \/\/ near Double.MAX_VALUE.\n+         failures += testRange(x, 2.0 * Math.ulp(x), 1000);\n+\n+         return failures;\n+    }\n+\n+    private static int testRange(double start, double increment, int count) {\n+        int failures = 0;\n+        double x = start;\n+        for (int i = 0; i < count; i++, x += increment) {\n+            failures += testLog1pCase(x, FdlibmTranslit.log1p(x));\n@@ -208,0 +267,1 @@\n+        return failures;\n","filename":"test\/jdk\/java\/lang\/StrictMath\/Log1pTests.java","additions":68,"deletions":8,"binary":false,"changes":76,"status":"modified"}]}