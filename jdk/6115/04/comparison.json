{"files":[{"patch":"@@ -2688,0 +2688,41 @@\n+bool can_combine_with_imm(Node* binary_node, Node* replicate_node) {\n+  if (UseSVE == 0 || !VectorNode::is_invariant_vector(replicate_node)){\n+    return false;\n+  }\n+  Node* imm_node = replicate_node->in(1);\n+  if (!imm_node->is_Con()) {\n+    return false;\n+  }\n+\n+  const Type* t = imm_node->bottom_type();\n+  if (!(t->isa_int() || t->isa_long())) {\n+    return false;\n+  }\n+\n+  switch (binary_node->Opcode()) {\n+  case Op_AndV:\n+  case Op_OrV:\n+  case Op_XorV: {\n+    Assembler::SIMD_RegVariant T = Assembler::elemType_to_regVariant(Matcher::vector_element_basic_type(binary_node));\n+    uint64_t value = t->isa_long() ? (uint64_t)imm_node->get_long() : (uint64_t)imm_node->get_int();\n+    return Assembler::operand_valid_for_sve_logical_immediate(Assembler::regVariant_to_elemBits(T), value);\n+  }\n+  case Op_AddVB:\n+    return (imm_node->get_int() <= 255 && imm_node->get_int() >= -255);\n+  case Op_AddVS:\n+  case Op_AddVI:\n+    return Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)imm_node->get_int());\n+  case Op_AddVL:\n+    return Assembler::operand_valid_for_sve_add_sub_immediate(imm_node->get_long());\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool is_vector_arith_imm_pattern(Node* n, Node* m) {\n+  if (n != NULL && m != NULL) {\n+    return can_combine_with_imm(n, m);\n+  }\n+  return false;\n+}\n+\n@@ -2692,0 +2733,1 @@\n+  \/\/ Binary src (Replicate con)\n@@ -2693,1 +2735,2 @@\n-      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask && n->Opcode() == Op_StoreVector)) {\n+      (UseSVE > 0 && m->Opcode() == Op_VectorStoreMask && n->Opcode() == Op_StoreVector) ||\n+      is_vector_arith_imm_pattern(n, m)) {\n@@ -4614,0 +4657,11 @@\n+\/\/ 8 bit integer valid for vector add sub immediate\n+operand immBAddSubV()\n+%{\n+  predicate(n->get_int() <= 255 && n->get_int() >= -255);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4624,0 +4678,11 @@\n+\/\/ 32 bit integer valid for vector add sub immediate\n+operand immIAddSubV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4625,1 +4690,21 @@\n-\/\/ TODO -- check this is right when e.g the mask is 0x80000000\n+\n+operand immBLog()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_logical_immediate(BitsPerByte, (uint64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immSLog()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_logical_immediate(BitsPerShort, (uint64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4703,0 +4788,11 @@\n+\/\/ 64 bit integer valid for addv subv immediate\n+operand immLAddSubV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_add_sub_immediate(n->get_long()));\n+  match(ConL);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":98,"deletions":2,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -938,0 +938,211 @@\n+\/\/ vector add reg imm (unpredicated)\n+\n+instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ B, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ B, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ H, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ H, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ S, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ S, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ D, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ D, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector binary op reg imm (unpredicated)\n+\n+instruct vandB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":211,"deletions":0,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -606,0 +606,19 @@\n+dnl\n+dnl ADD_IMM($1,          $2,   $3      )\n+dnl ADD_IMM(name_suffix, size, imm_type)\n+define(`ADD_IMM', `\n+instruct vaddImm$1(vReg dst_src, $3 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ $2, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ $2, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n@@ -607,0 +626,35 @@\n+\/\/ vector add reg imm (unpredicated)\n+ADD_IMM(B, B, immBAddSubV)\n+ADD_IMM(S, H, immIAddSubV)\n+ADD_IMM(I, S, immIAddSubV)\n+ADD_IMM(L, D, immLAddSubV)\n+dnl\n+dnl BITWISE_OP_IMM($1,        $2        $3,   $4    $5      )\n+dnl BITWISE_OP_IMM(insn_name, op_name1, size, type, op_name2)\n+define(`BITWISE_OP_IMM', `\n+instruct $1(vReg dst_src, imm$4Log con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src (Replicate$4 con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst_src, $dst_src, $con\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst_src$$reg), __ $3,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector binary op reg imm (unpredicated)\n+BITWISE_OP_IMM(vandB, AndV, B, B, sve_and)\n+BITWISE_OP_IMM(vandH, AndV, H, S, sve_and)\n+BITWISE_OP_IMM(vandS, AndV, S, I, sve_and)\n+BITWISE_OP_IMM(vandD, AndV, D, L, sve_and)\n+BITWISE_OP_IMM(vorB,  OrV,  B, B, sve_orr)\n+BITWISE_OP_IMM(vorH,  OrV,  H, S, sve_orr)\n+BITWISE_OP_IMM(vorS,  OrV,  S, I, sve_orr)\n+BITWISE_OP_IMM(vorD,  OrV,  D, L, sve_orr)\n+BITWISE_OP_IMM(vxorB, XorV, B, B, sve_eor)\n+BITWISE_OP_IMM(vxorH, XorV, H, S, sve_eor)\n+BITWISE_OP_IMM(vxorS, XorV, S, I, sve_eor)\n+BITWISE_OP_IMM(vxorD, XorV, D, L, sve_eor)\n+dnl\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+unsigned Assembler::regVariant_to_elemBits(Assembler::SIMD_RegVariant T){\n+  guarantee(T != Q, \"Invalid register variant\");\n+  return 1 << (T + 3);\n+}\n+\n@@ -342,9 +347,5 @@\n-  bool shift = false;\n-  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n-  if (uimm < (1 << 12))\n-    return true;\n-  if (uimm < (1 << 24)\n-      && ((uimm >> 12) << 12 == uimm)) {\n-    return true;\n-  }\n-  return false;\n+  return operand_valid_for_immediate_bits(imm, 12);\n+}\n+\n+bool Assembler::operand_valid_for_sve_add_sub_immediate(int64_t imm) {\n+  return operand_valid_for_immediate_bits(imm, 8);\n@@ -357,0 +358,4 @@\n+bool Assembler::operand_valid_for_sve_logical_immediate(unsigned elembits, uint64_t imm) {\n+  return encode_sve_logical_immediate(elembits, imm) != 0xffffffff;\n+}\n+\n@@ -386,0 +391,11 @@\n+bool asm_util::operand_valid_for_immediate_bits(int64_t imm, unsigned nbits) {\n+  guarantee(nbits == 8 || nbits == 12, \"invalid nbits value\");\n+  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n+  if (uimm < (UCONST64(1) << nbits))\n+    return true;\n+  if (uimm < (UCONST64(1) << (2 * nbits))\n+      && ((uimm >> nbits) << nbits == uimm)) {\n+    return true;\n+  }\n+  return false;\n+}\n@@ -406,0 +422,19 @@\n+uint32_t\n+asm_util::encode_sve_logical_immediate(unsigned elembits, uint64_t imm) {\n+  guarantee(elembits == 8 || elembits == 16 ||\n+            elembits == 32 || elembits == 64, \"unsupported element size\");\n+  uint64_t upper = UCONST64(-1) << (elembits\/2) << (elembits\/2);\n+  \/* Allow all zeros or all ones in top bits, so that\n+   * constant expressions like ~1 are permitted. *\/\n+  if ((imm & ~upper) != imm && (imm | upper) != imm)\n+    return 0xffffffff;\n+\n+  \/\/ Replicate the immediate in different element sizes to 64 bits.\n+  imm &= ~upper;\n+  for (unsigned i = elembits; i < 64; i *= 2) {\n+    imm |= (imm << i);\n+  }\n+\n+  return encoding_for_logical_immediate(imm);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":44,"deletions":9,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -162,0 +162,2 @@\n+  uint32_t encode_sve_logical_immediate(unsigned elembits, uint64_t imm);\n+  bool operand_valid_for_immediate_bits(int64_t imm, unsigned nbits);\n@@ -1519,0 +1521,2 @@\n+  \/\/ Return the corresponding bits for different SIMD_RegVariant value.\n+  static unsigned regVariant_to_elemBits(SIMD_RegVariant T);\n@@ -2956,0 +2960,26 @@\n+\/\/ SVE integer add\/subtract immediate (unpredicated)\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, unsigned imm8) {       \\\n+    starti;                                                             \\\n+    \/* The immediate is an unsigned value in the range 0 to 255, and    \\\n+     * for element width of 16 bits or higher it may also be a          \\\n+     * positive multiple of 256 in the range 256 to 65280.              \\\n+     *\/                                                                 \\\n+    assert(T != Q, \"invalid size\");                                     \\\n+    int sh = 0;                                                         \\\n+    if (imm8 <= 0xff) {                                                 \\\n+      sh = 0;                                                           \\\n+    } else if (T != B && imm8 <= 0xff00 && (imm8 & 0xff) == 0) {        \\\n+      sh = 1;                                                           \\\n+      imm8 = (imm8 >> 8);                                               \\\n+    } else {                                                            \\\n+      guarantee(false, \"invalid immediate\");                            \\\n+    }                                                                   \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000, 21, 17);            \\\n+    f(op, 16, 14), f(sh, 13), f(imm8, 12, 5), rf(Zd, 0);                \\\n+  }\n+\n+  INSN(sve_add, 0b011);\n+  INSN(sve_sub, 0b111);\n+#undef INSN\n+\n@@ -3093,0 +3123,14 @@\n+\/\/ SVE bitwise logical with immediate (unpredicated)\n+#define INSN(NAME, opc)                                                      \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, uint64_t imm) {             \\\n+    starti;                                                                  \\\n+    unsigned elembits = regVariant_to_elemBits(T);                           \\\n+    uint32_t val = encode_sve_logical_immediate(elembits, imm);              \\\n+    f(0b00000101, 31, 24), f(opc, 23, 22), f(0b0000, 21, 18);                \\\n+    f(val, 17, 5), rf(Zd, 0);                                                \\\n+  }\n+  INSN(sve_and, 0b10);\n+  INSN(sve_eor, 0b01);\n+  INSN(sve_orr, 0b00);\n+#undef INSN\n+\n@@ -3642,0 +3686,1 @@\n+  static bool operand_valid_for_sve_logical_immediate(unsigned elembits, uint64_t imm);\n@@ -3643,0 +3688,1 @@\n+  static bool operand_valid_for_sve_add_sub_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -10,0 +10,49 @@\n+# These tables are legal immediate logical operands\n+immediates8 \\\n+     = [0x1, 0x0c, 0x3e, 0x60, 0x7c, 0x80, 0x83,\n+        0xe1, 0xbf, 0xef, 0xf3, 0xfe]\n+\n+immediates16 \\\n+     = [0x1, 0x38, 0x7e, 0xff, 0x1fc, 0x1ff, 0x3f0,\n+        0x7e0, 0xfc0, 0x1f80, 0x3ff0, 0x7e00, 0x7e00,\n+        0x8000, 0x81ff, 0xc1ff, 0xc003, 0xc7ff, 0xdfff,\n+        0xe03f, 0xe10f, 0xe1ff, 0xf801, 0xfc00, 0xfc07,\n+        0xff03, 0xfffe]\n+\n+immediates32 \\\n+     = [0x1, 0x3f, 0x1f0, 0x7e0,\n+        0x1c00, 0x3ff0, 0x8000, 0x1e000,\n+        0x3e000, 0x78000, 0xe0000, 0x100000,\n+        0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8,\n+        0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0,\n+        0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00,\n+        0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe,\n+        0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80,\n+        0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f,\n+        0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003,\n+        0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff,\n+        0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff,\n+        0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87,\n+        0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1,\n+        0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff,\n+        0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07,\n+        0xffffffbf, 0xfffffffd]\n+\n+immediates64 \\\n+     = [0x1, 0x1f80, 0x3fff0, 0x3ffffc,\n+        0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000,\n+        0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000,\n+        0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000,\n+        0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000,\n+        0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000,\n+        0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8,\n+        0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000,\n+        0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff,\n+        0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003,\n+        0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff,\n+        0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000,\n+        0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f,\n+        0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff,\n+        0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff,\n+        0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]\n+\n@@ -354,39 +403,0 @@\n-\n-     # These tables are legal immediate logical operands\n-     immediates32 \\\n-         = [0x1, 0x3f, 0x1f0, 0x7e0,\n-            0x1c00, 0x3ff0, 0x8000, 0x1e000,\n-            0x3e000, 0x78000, 0xe0000, 0x100000,\n-            0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8,\n-            0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0,\n-            0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00,\n-            0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe,\n-            0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80,\n-            0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f,\n-            0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003,\n-            0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff,\n-            0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff,\n-            0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87,\n-            0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1,\n-            0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff,\n-            0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07,\n-            0xffffffbf, 0xfffffffd]\n-\n-     immediates \\\n-         = [0x1, 0x1f80, 0x3fff0, 0x3ffffc,\n-            0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000,\n-            0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000,\n-            0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000,\n-            0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000,\n-            0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000,\n-            0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8,\n-            0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000,\n-            0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff,\n-            0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003,\n-            0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff,\n-            0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000,\n-            0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f,\n-            0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff,\n-            0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff,\n-            0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]\n-\n@@ -396,1 +406,1 @@\n-              self.immediates32[random.randint(0, len(self.immediates32)-1)] \\\n+              immediates32[random.randint(0, len(immediates32)-1)] \\\n@@ -398,1 +408,1 @@\n-              self.immediates[random.randint(0, len(self.immediates)-1)]\n+              immediates64[random.randint(0, len(immediates64)-1)]\n@@ -409,0 +419,38 @@\n+class SVEBinaryImmOp(Instruction):\n+    def __init__(self, name):\n+        reg = SVEVectorRegister().generate()\n+        self.reg = [reg, reg]\n+        self.numRegs = len(self.reg)\n+        self._width = RegVariant(0, 3)\n+        self._isLogical = False\n+        if name in [\"and\", \"eor\", \"orr\"]:\n+            self._isLogical = True\n+        Instruction.__init__(self, name)\n+\n+    def generate(self):\n+        Instruction.generate(self)\n+        self.immed = random.randint(0, (1<<8)-1)\n+        if self._isLogical:\n+            vectype = self._width.cstr()\n+            if vectype == \"__ B\":\n+                self.immed = immediates8[random.randint(0, len(immediates8)-1)]\n+            elif vectype == \"__ H\":\n+                self.immed = immediates16[random.randint(0, len(immediates16)-1)]\n+            elif vectype == \"__ S\":\n+                self.immed = immediates32[random.randint(0, len(immediates32)-1)]\n+            elif vectype == \"__ D\":\n+                self.immed = immediates64[random.randint(0, len(immediates64)-1)]\n+        return self\n+\n+    def cstr(self):\n+        formatStr = \"%s%s, %s, %su);\"\n+        return (formatStr\n+                % tuple([\"__ sve_\" + self._name + \"(\"] +\n+                        [str(self.reg[0]), self._width.cstr(), self.immed]))\n+\n+    def astr(self):\n+        formatStr = \"%s%s, %s, #0x%x\"\n+        Regs = [str(self.reg[i]) + self._width.astr() for i in range(0, self.numRegs)]\n+        return (formatStr\n+                % tuple([Instruction.astr(self)] + Regs + [self.immed]))\n+\n@@ -1722,0 +1770,3 @@\n+for i in range(6):\n+    generate(SVEBinaryImmOp, [\"add\", \"sub\", \"and\", \"eor\", \"orr\"])\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":92,"deletions":41,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -1016,0 +1016,42 @@\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z4, __ B, 147u);                        \/\/       add     z4.b, z4.b, #0x93\n+    __ sve_sub(z0, __ B, 124u);                        \/\/       sub     z0.b, z0.b, #0x7c\n+    __ sve_and(z1, __ H, 508u);                        \/\/       and     z1.h, z1.h, #0x1fc\n+    __ sve_eor(z9, __ D, 18374686479671656447u);       \/\/       eor     z9.d, z9.d, #0xff00000000007fff\n+    __ sve_orr(z22, __ S, 251662080u);                 \/\/       orr     z22.s, z22.s, #0xf000f00\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z8, __ S, 248u);                        \/\/       add     z8.s, z8.s, #0xf8\n+    __ sve_sub(z6, __ S, 16u);                         \/\/       sub     z6.s, z6.s, #0x10\n+    __ sve_and(z11, __ D, 4160749568u);                \/\/       and     z11.d, z11.d, #0xf8000000\n+    __ sve_eor(z26, __ S, 1610637312u);                \/\/       eor     z26.s, z26.s, #0x60006000\n+    __ sve_orr(z13, __ D, 18446181398634037247u);      \/\/       orr     z13.d, z13.d, #0xfffe003fffffffff\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z5, __ B, 112u);                        \/\/       add     z5.b, z5.b, #0x70\n+    __ sve_sub(z10, __ S, 88u);                        \/\/       sub     z10.s, z10.s, #0x58\n+    __ sve_and(z26, __ S, 253952u);                    \/\/       and     z26.s, z26.s, #0x3e000\n+    __ sve_eor(z22, __ S, 496u);                       \/\/       eor     z22.s, z22.s, #0x1f0\n+    __ sve_orr(z19, __ S, 536870910u);                 \/\/       orr     z19.s, z19.s, #0x1ffffffe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z14, __ H, 22u);                        \/\/       add     z14.h, z14.h, #0x16\n+    __ sve_sub(z16, __ B, 172u);                       \/\/       sub     z16.b, z16.b, #0xac\n+    __ sve_and(z23, __ B, 62u);                        \/\/       and     z23.b, z23.b, #0x3e\n+    __ sve_eor(z17, __ H, 33279u);                     \/\/       eor     z17.h, z17.h, #0x81ff\n+    __ sve_orr(z16, __ B, 254u);                       \/\/       orr     z16.b, z16.b, #0xfe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z3, __ B, 49u);                         \/\/       add     z3.b, z3.b, #0x31\n+    __ sve_sub(z17, __ S, 110u);                       \/\/       sub     z17.s, z17.s, #0x6e\n+    __ sve_and(z12, __ S, 4290777087u);                \/\/       and     z12.s, z12.s, #0xffc00fff\n+    __ sve_eor(z19, __ S, 134217216u);                 \/\/       eor     z19.s, z19.s, #0x7fffe00\n+    __ sve_orr(z23, __ B, 254u);                       \/\/       orr     z23.b, z23.b, #0xfe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z13, __ S, 54u);                        \/\/       add     z13.s, z13.s, #0x36\n+    __ sve_sub(z0, __ B, 120u);                        \/\/       sub     z0.b, z0.b, #0x78\n+    __ sve_and(z17, __ D, 18014398509481728u);         \/\/       and     z17.d, z17.d, #0x3fffffffffff00\n+    __ sve_eor(z22, __ S, 4294709247u);                \/\/       eor     z22.s, z22.s, #0xfffc0fff\n+    __ sve_orr(z2, __ B, 225u);                        \/\/       orr     z2.b, z2.b, #0xe1\n+\n@@ -1017,45 +1059,45 @@\n-    __ sve_add(z4, __ B, z6, z17);                     \/\/       add     z4.b, z6.b, z17.b\n-    __ sve_sub(z3, __ H, z15, z1);                     \/\/       sub     z3.h, z15.h, z1.h\n-    __ sve_fadd(z6, __ D, z5, z9);                     \/\/       fadd    z6.d, z5.d, z9.d\n-    __ sve_fmul(z7, __ D, z20, z22);                   \/\/       fmul    z7.d, z20.d, z22.d\n-    __ sve_fsub(z5, __ D, z10, z8);                    \/\/       fsub    z5.d, z10.d, z8.d\n-    __ sve_abs(z30, __ B, p1, z17);                    \/\/       abs     z30.b, p1\/m, z17.b\n-    __ sve_add(z11, __ B, p7, z28);                    \/\/       add     z11.b, p7\/m, z11.b, z28.b\n-    __ sve_and(z26, __ H, p5, z28);                    \/\/       and     z26.h, p5\/m, z26.h, z28.h\n-    __ sve_asr(z13, __ D, p7, z16);                    \/\/       asr     z13.d, p7\/m, z13.d, z16.d\n-    __ sve_cnt(z5, __ H, p0, z13);                     \/\/       cnt     z5.h, p0\/m, z13.h\n-    __ sve_eor(z15, __ S, p2, z26);                    \/\/       eor     z15.s, p2\/m, z15.s, z26.s\n-    __ sve_lsl(z11, __ S, p1, z22);                    \/\/       lsl     z11.s, p1\/m, z11.s, z22.s\n-    __ sve_lsr(z4, __ S, p0, z19);                     \/\/       lsr     z4.s, p0\/m, z4.s, z19.s\n-    __ sve_mul(z17, __ H, p3, z14);                    \/\/       mul     z17.h, p3\/m, z17.h, z14.h\n-    __ sve_neg(z2, __ S, p4, z3);                      \/\/       neg     z2.s, p4\/m, z3.s\n-    __ sve_not(z23, __ B, p1, z6);                     \/\/       not     z23.b, p1\/m, z6.b\n-    __ sve_orr(z17, __ S, p3, z27);                    \/\/       orr     z17.s, p3\/m, z17.s, z27.s\n-    __ sve_smax(z16, __ D, p1, z2);                    \/\/       smax    z16.d, p1\/m, z16.d, z2.d\n-    __ sve_smin(z3, __ S, p1, z6);                     \/\/       smin    z3.s, p1\/m, z3.s, z6.s\n-    __ sve_sub(z19, __ S, p3, z12);                    \/\/       sub     z19.s, p3\/m, z19.s, z12.s\n-    __ sve_fabs(z8, __ D, p6, z19);                    \/\/       fabs    z8.d, p6\/m, z19.d\n-    __ sve_fadd(z0, __ S, p2, z23);                    \/\/       fadd    z0.s, p2\/m, z0.s, z23.s\n-    __ sve_fdiv(z19, __ D, p7, z13);                   \/\/       fdiv    z19.d, p7\/m, z19.d, z13.d\n-    __ sve_fmax(z6, __ S, p0, z7);                     \/\/       fmax    z6.s, p0\/m, z6.s, z7.s\n-    __ sve_fmin(z17, __ S, p6, z8);                    \/\/       fmin    z17.s, p6\/m, z17.s, z8.s\n-    __ sve_fmul(z22, __ D, p5, z22);                   \/\/       fmul    z22.d, p5\/m, z22.d, z22.d\n-    __ sve_fneg(z2, __ D, p0, z15);                    \/\/       fneg    z2.d, p0\/m, z15.d\n-    __ sve_frintm(z20, __ D, p1, z4);                  \/\/       frintm  z20.d, p1\/m, z4.d\n-    __ sve_frintn(z7, __ D, p0, z8);                   \/\/       frintn  z7.d, p0\/m, z8.d\n-    __ sve_frintp(z19, __ D, p5, z4);                  \/\/       frintp  z19.d, p5\/m, z4.d\n-    __ sve_fsqrt(z9, __ D, p5, z11);                   \/\/       fsqrt   z9.d, p5\/m, z11.d\n-    __ sve_fsub(z5, __ S, p7, z16);                    \/\/       fsub    z5.s, p7\/m, z5.s, z16.s\n-    __ sve_fmad(z22, __ S, p3, z1, z13);               \/\/       fmad    z22.s, p3\/m, z1.s, z13.s\n-    __ sve_fmla(z20, __ S, p4, z25, z15);              \/\/       fmla    z20.s, p4\/m, z25.s, z15.s\n-    __ sve_fmls(z4, __ D, p4, z8, z6);                 \/\/       fmls    z4.d, p4\/m, z8.d, z6.d\n-    __ sve_fnmla(z4, __ D, p7, z16, z29);              \/\/       fnmla   z4.d, p7\/m, z16.d, z29.d\n-    __ sve_fnmls(z9, __ D, p3, z2, z11);               \/\/       fnmls   z9.d, p3\/m, z2.d, z11.d\n-    __ sve_mla(z3, __ S, p1, z1, z26);                 \/\/       mla     z3.s, p1\/m, z1.s, z26.s\n-    __ sve_mls(z17, __ S, p3, z8, z17);                \/\/       mls     z17.s, p3\/m, z8.s, z17.s\n-    __ sve_and(z24, z5, z19);                          \/\/       and     z24.d, z5.d, z19.d\n-    __ sve_eor(z17, z22, z16);                         \/\/       eor     z17.d, z22.d, z16.d\n-    __ sve_orr(z20, z19, z0);                          \/\/       orr     z20.d, z19.d, z0.d\n-    __ sve_bic(z17, z23, z4);                          \/\/       bic     z17.d, z23.d, z4.d\n-    __ sve_uzp1(z4, __ S, z23, z25);                   \/\/       uzp1    z4.s, z23.s, z25.s\n-    __ sve_uzp2(z2, __ H, z8, z8);                     \/\/       uzp2    z2.h, z8.h, z8.h\n+    __ sve_add(z20, __ D, z7, z4);                     \/\/       add     z20.d, z7.d, z4.d\n+    __ sve_sub(z7, __ S, z0, z8);                      \/\/       sub     z7.s, z0.s, z8.s\n+    __ sve_fadd(z19, __ D, z22, z4);                   \/\/       fadd    z19.d, z22.d, z4.d\n+    __ sve_fmul(z9, __ D, z22, z11);                   \/\/       fmul    z9.d, z22.d, z11.d\n+    __ sve_fsub(z5, __ S, z30, z16);                   \/\/       fsub    z5.s, z30.s, z16.s\n+    __ sve_abs(z22, __ H, p3, z1);                     \/\/       abs     z22.h, p3\/m, z1.h\n+    __ sve_add(z8, __ D, p5, z16);                     \/\/       add     z8.d, p5\/m, z8.d, z16.d\n+    __ sve_and(z15, __ S, p1, z4);                     \/\/       and     z15.s, p1\/m, z15.s, z4.s\n+    __ sve_asr(z8, __ B, p1, z29);                     \/\/       asr     z8.b, p1\/m, z8.b, z29.b\n+    __ sve_cnt(z28, __ D, p4, z29);                    \/\/       cnt     z28.d, p4\/m, z29.d\n+    __ sve_eor(z9, __ H, p3, z2);                      \/\/       eor     z9.h, p3\/m, z9.h, z2.h\n+    __ sve_lsl(z28, __ B, p0, z7);                     \/\/       lsl     z28.b, p0\/m, z28.b, z7.b\n+    __ sve_lsr(z26, __ H, p5, z17);                    \/\/       lsr     z26.h, p5\/m, z26.h, z17.h\n+    __ sve_mul(z8, __ D, p4, z21);                     \/\/       mul     z8.d, p4\/m, z8.d, z21.d\n+    __ sve_neg(z5, __ S, p5, z21);                     \/\/       neg     z5.s, p5\/m, z21.s\n+    __ sve_not(z22, __ S, p4, z29);                    \/\/       not     z22.s, p4\/m, z29.s\n+    __ sve_orr(z19, __ S, p0, z4);                     \/\/       orr     z19.s, p0\/m, z19.s, z4.s\n+    __ sve_smax(z23, __ B, p1, z19);                   \/\/       smax    z23.b, p1\/m, z23.b, z19.b\n+    __ sve_smin(z23, __ B, p6, z19);                   \/\/       smin    z23.b, p6\/m, z23.b, z19.b\n+    __ sve_sub(z8, __ D, p2, z14);                     \/\/       sub     z8.d, p2\/m, z8.d, z14.d\n+    __ sve_fabs(z17, __ S, p7, z21);                   \/\/       fabs    z17.s, p7\/m, z21.s\n+    __ sve_fadd(z30, __ D, p0, z10);                   \/\/       fadd    z30.d, p0\/m, z30.d, z10.d\n+    __ sve_fdiv(z12, __ S, p0, z9);                    \/\/       fdiv    z12.s, p0\/m, z12.s, z9.s\n+    __ sve_fmax(z24, __ D, p4, z4);                    \/\/       fmax    z24.d, p4\/m, z24.d, z4.d\n+    __ sve_fmin(z6, __ D, p2, z27);                    \/\/       fmin    z6.d, p2\/m, z6.d, z27.d\n+    __ sve_fmul(z13, __ D, p4, z30);                   \/\/       fmul    z13.d, p4\/m, z13.d, z30.d\n+    __ sve_fneg(z22, __ D, p5, z30);                   \/\/       fneg    z22.d, p5\/m, z30.d\n+    __ sve_frintm(z9, __ S, p3, z19);                  \/\/       frintm  z9.s, p3\/m, z19.s\n+    __ sve_frintn(z20, __ S, p7, z9);                  \/\/       frintn  z20.s, p7\/m, z9.s\n+    __ sve_frintp(z13, __ S, p3, z19);                 \/\/       frintp  z13.s, p3\/m, z19.s\n+    __ sve_fsqrt(z24, __ S, p2, z19);                  \/\/       fsqrt   z24.s, p2\/m, z19.s\n+    __ sve_fsub(z17, __ S, p4, z16);                   \/\/       fsub    z17.s, p4\/m, z17.s, z16.s\n+    __ sve_fmad(z0, __ S, p0, z11, z7);                \/\/       fmad    z0.s, p0\/m, z11.s, z7.s\n+    __ sve_fmla(z14, __ D, p4, z4, z15);               \/\/       fmla    z14.d, p4\/m, z4.d, z15.d\n+    __ sve_fmls(z5, __ D, p0, z10, z21);               \/\/       fmls    z5.d, p0\/m, z10.d, z21.d\n+    __ sve_fnmla(z3, __ D, p0, z9, z19);               \/\/       fnmla   z3.d, p0\/m, z9.d, z19.d\n+    __ sve_fnmls(z10, __ S, p6, z3, z19);              \/\/       fnmls   z10.s, p6\/m, z3.s, z19.s\n+    __ sve_mla(z23, __ H, p7, z13, z21);               \/\/       mla     z23.h, p7\/m, z13.h, z21.h\n+    __ sve_mls(z26, __ S, p3, z17, z30);               \/\/       mls     z26.s, p3\/m, z17.s, z30.s\n+    __ sve_and(z14, z2, z29);                          \/\/       and     z14.d, z2.d, z29.d\n+    __ sve_eor(z21, z20, z7);                          \/\/       eor     z21.d, z20.d, z7.d\n+    __ sve_orr(z2, z1, z26);                           \/\/       orr     z2.d, z1.d, z26.d\n+    __ sve_bic(z9, z16, z17);                          \/\/       bic     z9.d, z16.d, z17.d\n+    __ sve_uzp1(z0, __ D, z4, z2);                     \/\/       uzp1    z0.d, z4.d, z2.d\n+    __ sve_uzp2(z14, __ S, z6, z11);                   \/\/       uzp2    z14.s, z6.s, z11.s\n@@ -1064,9 +1106,9 @@\n-    __ sve_andv(v24, __ S, p4, z30);                   \/\/       andv s24, p4, z30.s\n-    __ sve_orv(v4, __ H, p7, z1);                      \/\/       orv h4, p7, z1.h\n-    __ sve_eorv(v19, __ H, p3, z0);                    \/\/       eorv h19, p3, z0.h\n-    __ sve_smaxv(v7, __ B, p6, z17);                   \/\/       smaxv b7, p6, z17.b\n-    __ sve_sminv(v27, __ D, p1, z9);                   \/\/       sminv d27, p1, z9.d\n-    __ sve_fminv(v23, __ D, p3, z16);                  \/\/       fminv d23, p3, z16.d\n-    __ sve_fmaxv(v22, __ D, p5, z20);                  \/\/       fmaxv d22, p5, z20.d\n-    __ sve_fadda(v28, __ D, p2, z13);                  \/\/       fadda d28, p2, d28, z13.d\n-    __ sve_uaddv(v7, __ H, p5, z28);                   \/\/       uaddv d7, p5, z28.h\n+    __ sve_andv(v14, __ H, p4, z29);                   \/\/       andv h14, p4, z29.h\n+    __ sve_orv(v3, __ H, p0, z22);                     \/\/       orv h3, p0, z22.h\n+    __ sve_eorv(v3, __ B, p6, z27);                    \/\/       eorv b3, p6, z27.b\n+    __ sve_smaxv(v19, __ D, p5, z7);                   \/\/       smaxv d19, p5, z7.d\n+    __ sve_sminv(v21, __ H, p3, z5);                   \/\/       sminv h21, p3, z5.h\n+    __ sve_fminv(v25, __ D, p1, z21);                  \/\/       fminv d25, p1, z21.d\n+    __ sve_fmaxv(v17, __ S, p0, z3);                   \/\/       fmaxv s17, p0, z3.s\n+    __ sve_fadda(v19, __ S, p3, z7);                   \/\/       fadda s19, p3, s19, z7.s\n+    __ sve_uaddv(v14, __ H, p4, z17);                  \/\/       uaddv d14, p4, z17.h\n@@ -1091,7 +1133,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400037a,     0x94000000,\n-    0x97ffffd4,     0x94000377,     0x3400000a,     0x34fffa2a,\n-    0x34006e8a,     0x35000008,     0x35fff9c8,     0x35006e28,\n-    0xb400000b,     0xb4fff96b,     0xb4006dcb,     0xb500001d,\n-    0xb5fff91d,     0xb5006d7d,     0x10000013,     0x10fff8b3,\n-    0x10006d13,     0x90000013,     0x36300016,     0x3637f836,\n-    0x36306c96,     0x3758000c,     0x375ff7cc,     0x37586c2c,\n+    0x14000000,     0x17ffffd7,     0x14000398,     0x94000000,\n+    0x97ffffd4,     0x94000395,     0x3400000a,     0x34fffa2a,\n+    0x3400724a,     0x35000008,     0x35fff9c8,     0x350071e8,\n+    0xb400000b,     0xb4fff96b,     0xb400718b,     0xb500001d,\n+    0xb5fff91d,     0xb500713d,     0x10000013,     0x10fff8b3,\n+    0x100070d3,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36307056,     0x3758000c,     0x375ff7cc,     0x37586fec,\n@@ -1102,13 +1144,13 @@\n-    0x54006a00,     0x54000001,     0x54fff541,     0x540069a1,\n-    0x54000002,     0x54fff4e2,     0x54006942,     0x54000002,\n-    0x54fff482,     0x540068e2,     0x54000003,     0x54fff423,\n-    0x54006883,     0x54000003,     0x54fff3c3,     0x54006823,\n-    0x54000004,     0x54fff364,     0x540067c4,     0x54000005,\n-    0x54fff305,     0x54006765,     0x54000006,     0x54fff2a6,\n-    0x54006706,     0x54000007,     0x54fff247,     0x540066a7,\n-    0x54000008,     0x54fff1e8,     0x54006648,     0x54000009,\n-    0x54fff189,     0x540065e9,     0x5400000a,     0x54fff12a,\n-    0x5400658a,     0x5400000b,     0x54fff0cb,     0x5400652b,\n-    0x5400000c,     0x54fff06c,     0x540064cc,     0x5400000d,\n-    0x54fff00d,     0x5400646d,     0x5400000e,     0x54ffefae,\n-    0x5400640e,     0x5400000f,     0x54ffef4f,     0x540063af,\n+    0x54006dc0,     0x54000001,     0x54fff541,     0x54006d61,\n+    0x54000002,     0x54fff4e2,     0x54006d02,     0x54000002,\n+    0x54fff482,     0x54006ca2,     0x54000003,     0x54fff423,\n+    0x54006c43,     0x54000003,     0x54fff3c3,     0x54006be3,\n+    0x54000004,     0x54fff364,     0x54006b84,     0x54000005,\n+    0x54fff305,     0x54006b25,     0x54000006,     0x54fff2a6,\n+    0x54006ac6,     0x54000007,     0x54fff247,     0x54006a67,\n+    0x54000008,     0x54fff1e8,     0x54006a08,     0x54000009,\n+    0x54fff189,     0x540069a9,     0x5400000a,     0x54fff12a,\n+    0x5400694a,     0x5400000b,     0x54fff0cb,     0x540068eb,\n+    0x5400000c,     0x54fff06c,     0x5400688c,     0x5400000d,\n+    0x54fff00d,     0x5400682d,     0x5400000e,     0x54ffefae,\n+    0x540067ce,     0x5400000f,     0x54ffef4f,     0x5400676f,\n@@ -1146,1 +1188,1 @@\n-    0xbd1b1869,     0x580053fb,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x580057bb,     0x1800000b,     0xf8945060,\n@@ -1300,15 +1342,22 @@\n-    0xcec0835a,     0xce608ad8,     0x043100c4,     0x046105e3,\n-    0x65c900a6,     0x65d60a87,     0x65c80545,     0x0416a63e,\n-    0x04001f8b,     0x045a179a,     0x04d09e0d,     0x045aa1a5,\n-    0x04990b4f,     0x049386cb,     0x04918264,     0x04500dd1,\n-    0x0497b062,     0x041ea4d7,     0x04980f71,     0x04c80450,\n-    0x048a04c3,     0x04810d93,     0x04dcba68,     0x65808ae0,\n-    0x65cd9db3,     0x658680e6,     0x65879911,     0x65c296d6,\n-    0x04dda1e2,     0x65c2a494,     0x65c0a107,     0x65c1b493,\n-    0x65cdb569,     0x65819e05,     0x65ad8c36,     0x65af1334,\n-    0x65e63104,     0x65fd5e04,     0x65eb6c49,     0x049a4423,\n-    0x04916d11,     0x043330b8,     0x04b032d1,     0x04603274,\n-    0x04e432f1,     0x05b96ae4,     0x05686d02,     0x049a33d8,\n-    0x04583c24,     0x04592c13,     0x04083a27,     0x04ca253b,\n-    0x65c72e17,     0x65c63696,     0x65d829bc,     0x04413787,\n-\n+    0xcec0835a,     0xce608ad8,     0x2520d264,     0x2521cf80,\n+    0x058074c1,     0x054242c9,     0x05004476,     0x25a0df08,\n+    0x25a1c206,     0x0583288b,     0x05401c3a,     0x05027e8d,\n+    0x2520ce05,     0x25a1cb0a,     0x0580989a,     0x0540e096,\n+    0x0500fb73,     0x2560c2ce,     0x2521d590,     0x05803e97,\n+    0x05400d31,     0x05003ed0,     0x2520c623,     0x25a1cdd1,\n+    0x058052ac,     0x0540ba33,     0x05003ed7,     0x25a0c6cd,\n+    0x2521cf00,     0x0583c5b1,     0x05407336,     0x05001e62,\n+    0x04e400f4,     0x04a80407,     0x65c402d3,     0x65cb0ac9,\n+    0x659007c5,     0x0456ac36,     0x04c01608,     0x049a048f,\n+    0x041087a8,     0x04dab3bc,     0x04590c49,     0x041380fc,\n+    0x0451963a,     0x04d012a8,     0x0497b6a5,     0x049eb3b6,\n+    0x04980093,     0x04080677,     0x040a1a77,     0x04c109c8,\n+    0x049cbeb1,     0x65c0815e,     0x658d812c,     0x65c69098,\n+    0x65c78b66,     0x65c293cd,     0x04ddb7d6,     0x6582ae69,\n+    0x6580bd34,     0x6581ae6d,     0x658daa78,     0x65819211,\n+    0x65a78160,     0x65ef108e,     0x65f52145,     0x65f34123,\n+    0x65b3786a,     0x04555db7,     0x049e6e3a,     0x043d304e,\n+    0x04a73295,     0x047a3022,     0x04f13209,     0x05e26880,\n+    0x05ab6cce,     0x045a33ae,     0x045822c3,     0x04193b63,\n+    0x04c834f3,     0x044a2cb5,     0x65c726b9,     0x65862071,\n+    0x65982cf3,     0x0441322e,\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":139,"deletions":90,"binary":false,"changes":229,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    byte[] a3 = new byte[ARRLEN];\n@@ -97,0 +98,10 @@\n+      test_addImm127(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_addImm256(a1, a2);\n+      test_addImmNeg128(a1, a2);\n+      test_addImmNeg129(a1, a2);\n+      test_subImm(a1, a2, a3);\n+      test_andImm21(a1, a2);\n+      test_andImm7(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2, a3);\n@@ -490,0 +501,71 @@\n+      byte base = (byte) 10;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte) 10;\n+      }\n+      byte golden = (byte)(base + 127);\n+      test_addImm127(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm127: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (byte)(base + 8);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      test_addImm256(a1, a2);\n+      golden = (byte)(base + 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm256: a3\", i, a2[i], golden);\n+      }\n+      test_addImmNeg128(a1, a2);\n+      golden = (byte)(base + (-128));\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImmNeg128: a2\", i, a2[i], golden);\n+      }\n+      test_addImmNeg129(a1, a2);\n+      golden = (byte)(base + (-129));\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImmNeg129: a2\", i, a2[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = (byte) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte) 120;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = (byte) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_andImm21(a1, a2);\n+      golden = (byte) (base & 21);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm21: a2\", i, a2[i], golden);\n+      }\n+      test_andImm7(a1, a2);\n+      golden = (byte) (base & 7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm7: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (byte) (base | 3);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2, a3);\n+      golden = (byte) (base ^ 127);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base ^ 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a3\", i, a3[i], golden);\n+      }\n@@ -733,0 +815,53 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm127(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm127: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImmNeg128(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImmNeg128: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImmNeg129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImmNeg129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm7(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm7: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n@@ -948,0 +1083,53 @@\n+  static void test_addImm127(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 127);\n+    }\n+  }\n+  static void test_addImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 8);\n+      c[i] = (byte) (a[i] + 255);\n+    }\n+  }\n+  static void test_addImm256(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 256);\n+    }\n+  }\n+  static void test_addImmNeg128(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + (-128));\n+    }\n+  }\n+  static void test_addImmNeg129(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + (-129));\n+    }\n+  }\n+  static void test_subImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] - 56);\n+      c[i] = (byte) (a[i] - 256);\n+    }\n+  }\n+  static void test_andImm21(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] & 21);\n+    }\n+  }\n+  static void test_andImm7(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] & 7);\n+    }\n+  }\n+  static void test_orImm(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] | 3);\n+    }\n+  }\n+  static void test_xorImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] ^ 127);\n+      c[i] = (byte) (a[i] ^ 255);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteVect.java","additions":189,"deletions":1,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    char[] a3 = new char[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm129(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_subImm56(a1, a2);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,50 @@\n+      \/\/ Reset for binary operation with immediate.\n+      char base = (char) 3;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (char) 3;\n+      }\n+      char golden = (char)(base + 129);\n+      test_addImm129(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm129: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (char)(base + 129);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (char) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      \/\/ Reset for sub operation test.\n+      base = (char) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (char) 120;\n+      }\n+      test_subImm56(a1, a2);\n+      golden = (char) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm56: a2\", i, a2[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = (char) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = (char) (base & 0xfe);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (char) (base | 0xff);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = (char) (base ^ 0xc7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n+\n@@ -733,0 +791,43 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm56(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm56: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n+\n@@ -948,0 +1049,41 @@\n+  static void test_addImm129(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] + 129);\n+    }\n+  }\n+  static void test_addImm(char[] a, char[] b, char[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] + 129);\n+      c[i] = (char) (a[i] + 255);\n+    }\n+  }\n+\n+  static void test_subImm56(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] - 56);\n+    }\n+  }\n+\n+  static void test_subImm256(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] - 256);\n+    }\n+  }\n+\n+  static void test_andImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] & 0xfe);\n+    }\n+  }\n+\n+  static void test_orImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] | 0xff);\n+    }\n+  }\n+\n+  static void test_xorImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] ^ 0xc7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect.java","additions":143,"deletions":1,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    int[] a3 = new int[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm127(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_addImm256(a1, a2);\n+      test_subImm(a1, a2, a3);\n+      test_andImm(a1, a2, a3);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,57 @@\n+      \/\/ Reset for binary operation with immediate\n+      int base = 10;\n+      for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = 10;\n+      }\n+      int golden = base + 127;\n+      test_addImm127(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm127: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = base + 127;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base + 255;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      test_addImm256(a1, a2);\n+      golden = base + 256;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm256: a2\", i, a2[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = 10000;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = 10000;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = base - 2304;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base - 65280;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_andImm(a1, a2, a3);\n+      golden = base + 2560;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base & 516096;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a3\", i, a3[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = base | 8257536;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = base ^ 2032;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +798,42 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm127(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm127: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -948,0 +1055,44 @@\n+  static void test_addImm127(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 127;\n+    }\n+  }\n+  static void test_addImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 127;\n+      c[i] = a[i] + 255;\n+    }\n+  }\n+  static void test_addImm256(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 256;\n+    }\n+  }\n+  static void test_subImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] - 2304;\n+      c[i] = a[i] - 65280;\n+    }\n+  }\n+  static void test_andImm21(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 21;\n+    }\n+  }\n+  static void test_andImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 2560;\n+      c[i] = a[i] & 516096;\n+    }\n+  }\n+  static void test_orImm(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] | 8257536;\n+    }\n+  }\n+  static void test_xorImm(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] ^ 2032;\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntVect.java","additions":152,"deletions":1,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    long[] a3 = new long[ARRLEN];\n@@ -97,0 +98,6 @@\n+      test_addImm(a1, a2, a3);\n+      test_subImm(a1, a2, a3);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +497,47 @@\n+      \/\/ Reset for binary operations with immediate.\n+      for (int i=0; i<ARRLEN; i++) {\n+      a1[i] = 10;\n+      }\n+      long base = 10;\n+      test_addImm(a1, a2, a3);\n+      long golden = base & 516097;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base + 65280;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      base = 120;\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = 120;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = base + 65535;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base - 2147483647;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = base - 256;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = base & 132120576;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = base | 2113929216;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = base ^ 516096;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +787,36 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -949,0 +1039,38 @@\n+  static void test_addImm(long[] a, long[] b, long[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 516097;\n+      c[i] = a[i] + 65280;\n+    }\n+  }\n+\n+  static void test_subImm(long[] a, long[] b, long[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 65535;\n+      c[i] = a[i] - 2147483647;\n+    }\n+  }\n+\n+  static void test_subImm256(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] - 256;\n+    }\n+  }\n+\n+  static void test_andImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 132120576;\n+    }\n+  }\n+\n+  static void test_orImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] | 2113929216;\n+    }\n+  }\n+\n+  static void test_xorImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] ^ 516096;\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongVect.java","additions":129,"deletions":1,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    short[] a3 = new short[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm129(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_subImm56(a1, a2);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,48 @@\n+      short base = (short) 3;\n+      for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = (short) 3;\n+      }\n+      short golden = (short)(base + 129);\n+      test_addImm129(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm129: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (short)(base + 129);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (short) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = (short) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short) 120;\n+      }\n+      test_subImm56(a1, a2);\n+      golden = (short) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm56: a2\", i, a2[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = (short) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = (short) (base & 0xfe);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (short) (base | 0xff);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = (short) (base ^ 0xc7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +789,42 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm56(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm56: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -948,0 +1046,37 @@\n+  static void test_addImm129(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] + 129);\n+    }\n+  }\n+\n+  static void test_addImm(short[] a, short[] b, short[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] + 129);\n+      c[i] = (short) (a[i] + 255);\n+    }\n+  }\n+  static void test_subImm56(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] - 56);\n+    }\n+  }\n+  static void test_subImm256(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] - 256);\n+    }\n+  }\n+  static void test_andImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] & 0xfe);\n+    }\n+  }\n+  static void test_orImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] | 0xff);\n+    }\n+  }\n+  static void test_xorImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] ^ 0xc7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortVect.java","additions":136,"deletions":1,"binary":false,"changes":137,"status":"modified"}]}