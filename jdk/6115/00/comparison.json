{"files":[{"patch":"@@ -2662,0 +2662,37 @@\n+bool can_combine_with_imm(Node* binary_node, Node* replicate_node) {\n+  if (UseSVE == 0 || !VectorNode::is_invariant_vector(replicate_node)){\n+    return false;\n+  }\n+  Node* imm_node = replicate_node->in(1);\n+  if (!imm_node->is_Con() ||\n+      !(imm_node->bottom_type()->isa_int() || imm_node->bottom_type()->isa_long())) {\n+    return false;\n+  }\n+  switch (binary_node->Opcode()) {\n+  case Op_AndV:\n+  case Op_OrV:\n+  case Op_XorV: {\n+    Assembler::SIMD_RegVariant T = Assembler::elemType_to_regVariant(Matcher::vector_element_basic_type(binary_node));\n+    uint64_t value = imm_node->bottom_type()->isa_long() ? (uint64_t)imm_node->get_long()\n+                                                         : (uint64_t)imm_node->get_int();\n+    return Assembler::operand_valid_for_logical_immediate(Assembler::regVariant_to_elemBits(T), value);\n+  }\n+  case Op_AddVB:\n+    return (imm_node->get_int() <= 255 && imm_node->get_int() >= -255);\n+  case Op_AddVS:\n+  case Op_AddVI:\n+    return Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)imm_node->get_int());\n+  case Op_AddVL:\n+    return Assembler::operand_valid_for_sve_add_sub_immediate(imm_node->get_long());\n+  default:\n+    return false;\n+  }\n+}\n+\n+bool is_vector_arith_imm_pattern(Node* n, Node* m) {\n+  if (n != NULL && m != NULL) {\n+    return can_combine_with_imm(n, m);\n+  }\n+  return false;\n+}\n+\n@@ -2664,2 +2701,4 @@\n-  if (is_vshift_con_pattern(n, m)) { \/\/ ShiftV src (ShiftCntV con)\n-    mstack.push(m, Visit);           \/\/ m = ShiftCntV\n+  \/\/ ShiftV src (ShiftCntV con), m = ShiftCntV\n+  \/\/ Binary src (Replicate con), m = Replicate\n+  if (is_vshift_con_pattern(n, m) || is_vector_arith_imm_pattern(n, m)) {\n+    mstack.push(m, Visit);\n@@ -4584,0 +4623,11 @@\n+\/\/ 8 bit integer valid for vector add sub immediate\n+operand immBAddSubV()\n+%{\n+  predicate(n->get_int() <= 255 && n->get_int() >= -255);\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4589,0 +4639,12 @@\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 32 bit integer valid for vector add sub immediate\n+operand immIAddSubV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_add_sub_immediate((int64_t)n->get_int()));\n+  match(ConI);\n+\n@@ -4595,1 +4657,21 @@\n-\/\/ TODO -- check this is right when e.g the mask is 0x80000000\n+\n+operand immBLog()\n+%{\n+  predicate(Assembler::operand_valid_for_logical_immediate(BitsPerByte, (uint64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+operand immSLog()\n+%{\n+  predicate(Assembler::operand_valid_for_logical_immediate(BitsPerShort, (uint64_t)n->get_int()));\n+  match(ConI);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4598,1 +4680,1 @@\n-  predicate(Assembler::operand_valid_for_logical_immediate(\/*is32*\/true, (uint64_t)n->get_int()));\n+  predicate(Assembler::operand_valid_for_logical_immediate(BitsPerInt, (uint64_t)n->get_int()));\n@@ -4668,0 +4750,12 @@\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ 64 bit integer valid for addv subv immediate\n+operand immLAddSubV()\n+%{\n+  predicate(Assembler::operand_valid_for_sve_add_sub_immediate(n->get_long()));\n+  match(ConL);\n+\n@@ -4676,1 +4770,1 @@\n-  predicate(Assembler::operand_valid_for_logical_immediate(\/*is32*\/false, (uint64_t)n->get_long()));\n+  predicate(Assembler::operand_valid_for_logical_immediate(BitsPerLong, (uint64_t)n->get_long()));\n@@ -4678,0 +4772,1 @@\n+\n@@ -4688,0 +4783,1 @@\n+\n@@ -16114,2 +16210,1 @@\n-  predicate(Assembler::operand_valid_for_logical_immediate\n-            (\/*is_32*\/false, n->in(1)->in(2)->get_long()));\n+  predicate(Assembler::operand_valid_for_logical_immediate(BitsPerLong, n->in(1)->in(2)->get_long()));\n@@ -16127,2 +16222,1 @@\n-  predicate(Assembler::operand_valid_for_logical_immediate\n-            (\/*is_32*\/true, n->in(1)->in(2)->get_int()));\n+  predicate(Assembler::operand_valid_for_logical_immediate(BitsPerInt, n->in(1)->in(2)->get_int()));\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":103,"deletions":9,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -533,0 +533,212 @@\n+\/\/ vector add reg imm (unpredicated)\n+\n+instruct vaddImmB(vReg dst_src, immBAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVB dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ B, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ B, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmS(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVS dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ H, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ H, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmI(vReg dst_src, immIAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVI dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ S, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ S, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vaddImmL(vReg dst_src, immLAddSubV con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddVL dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ D, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ D, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ vector binary op reg imm (unpredicated)\n+\n+instruct vandB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vandD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AndV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_and $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_and(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vorD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (OrV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_orr $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_orr(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorB(vReg dst_src, immBLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateB con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (B)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ B,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorH(vReg dst_src, immSLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateS con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (H)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ H,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorS(vReg dst_src, immILog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateI con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (S)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ S,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+instruct vxorD(vReg dst_src, immLLog con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (XorV dst_src (ReplicateL con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_eor $dst_src, $dst_src, $con\\t # vector (sve) (D)\" %}\n+  ins_encode %{\n+    __ sve_eor(as_FloatRegister($dst_src$$reg), __ D,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve.ad","additions":212,"deletions":0,"binary":false,"changes":212,"status":"modified"},{"patch":"@@ -360,0 +360,54 @@\n+dnl ADD_IMM($1,          $2,   $3      )\n+dnl ADD_IMM(name_suffix, size, imm_type)\n+define(`ADD_IMM', `\n+instruct vaddImm$1(vReg dst_src, $3 con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src (AddV$1 dst_src (Replicate$1 con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"sve_add $dst_src, $dst_src, $con\\t # vector (sve) ($2)\" %}\n+  ins_encode %{\n+    int32_t val = $con$$constant;\n+    if (val > 0){\n+      __ sve_add(as_FloatRegister($dst_src$$reg), __ $2, val);\n+    } else if (val < 0){\n+      __ sve_sub(as_FloatRegister($dst_src$$reg), __ $2, -val);\n+    }\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector add reg imm (unpredicated)\n+ADD_IMM(B, B, immBAddSubV)\n+ADD_IMM(S, H, immIAddSubV)\n+ADD_IMM(I, S, immIAddSubV)\n+ADD_IMM(L, D, immLAddSubV)\n+dnl\n+dnl BITWISE_OP_IMM($1,        $2        $3,   $4    $5      )\n+dnl BITWISE_OP_IMM(insn_name, op_name1, size, type, op_name2)\n+define(`BITWISE_OP_IMM', `\n+instruct $1(vReg dst_src, imm$4Log con) %{\n+  predicate(UseSVE > 0);\n+  match(Set dst_src ($2 dst_src (Replicate$4 con)));\n+  ins_cost(SVE_COST);\n+  format %{ \"$5 $dst_src, $dst_src, $con\\t # vector (sve) ($3)\" %}\n+  ins_encode %{\n+    __ $5(as_FloatRegister($dst_src$$reg), __ $3,\n+         (uint64_t)($con$$constant));\n+  %}\n+  ins_pipe(pipe_slow);\n+%}')dnl\n+\n+\/\/ vector binary op reg imm (unpredicated)\n+BITWISE_OP_IMM(vandB, AndV, B, B, sve_and)\n+BITWISE_OP_IMM(vandH, AndV, H, S, sve_and)\n+BITWISE_OP_IMM(vandS, AndV, S, I, sve_and)\n+BITWISE_OP_IMM(vandD, AndV, D, L, sve_and)\n+BITWISE_OP_IMM(vorB,  OrV,  B, B, sve_orr)\n+BITWISE_OP_IMM(vorH,  OrV,  H, S, sve_orr)\n+BITWISE_OP_IMM(vorS,  OrV,  S, I, sve_orr)\n+BITWISE_OP_IMM(vorD,  OrV,  D, L, sve_orr)\n+BITWISE_OP_IMM(vxorB, XorV, B, B, sve_eor)\n+BITWISE_OP_IMM(vxorH, XorV, H, S, sve_eor)\n+BITWISE_OP_IMM(vxorS, XorV, S, I, sve_eor)\n+BITWISE_OP_IMM(vxorD, XorV, D, L, sve_eor)\n+dnl\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_sve_ad.m4","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -85,0 +85,4 @@\n+unsigned Assembler::regVariant_to_elemBits(Assembler::SIMD_RegVariant T){\n+  return 1 << (T + 3);\n+}\n+\n@@ -342,9 +346,1 @@\n-  bool shift = false;\n-  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n-  if (uimm < (1 << 12))\n-    return true;\n-  if (uimm < (1 << 24)\n-      && ((uimm >> 12) << 12 == uimm)) {\n-    return true;\n-  }\n-  return false;\n+  return operand_valid_for_immediate_bits(imm, 12);\n@@ -353,2 +349,6 @@\n-bool Assembler::operand_valid_for_logical_immediate(bool is32, uint64_t imm) {\n-  return encode_logical_immediate(is32, imm) != 0xffffffff;\n+bool Assembler::operand_valid_for_sve_add_sub_immediate(int64_t imm) {\n+  return operand_valid_for_immediate_bits(imm, 8);\n+}\n+\n+bool Assembler::operand_valid_for_logical_immediate(unsigned elembits, uint64_t imm) {\n+  return encode_logical_immediate(elembits, imm) != 0xffffffff;\n@@ -386,0 +386,10 @@\n+bool asm_util::operand_valid_for_immediate_bits(int64_t imm, unsigned nbits) {\n+  uint64_t uimm = (uint64_t)uabs((jlong)imm);\n+  if (uimm < (UCONST64(1) << nbits))\n+    return true;\n+  if (uimm < (UCONST64(1) << (2 * nbits))\n+      && ((uimm >> nbits) << nbits == uimm)) {\n+    return true;\n+  }\n+  return false;\n+}\n@@ -391,1 +401,1 @@\n-asm_util::encode_logical_immediate(bool is32, uint64_t imm)\n+asm_util::encode_logical_immediate(unsigned elembits, uint64_t imm)\n@@ -393,8 +403,12 @@\n-  if (is32) {\n-    \/* Allow all zeros or all ones in top 32-bits, so that\n-       constant expressions like ~1 are permitted. *\/\n-    if (imm >> 32 != 0 && imm >> 32 != 0xffffffff)\n-      return 0xffffffff;\n-    \/* Replicate the 32 lower bits to the 32 upper bits.  *\/\n-    imm &= 0xffffffff;\n-    imm |= imm << 32;\n+  guarantee(elembits == 8 || elembits == 16 ||\n+            elembits == 32 || elembits == 64, \"unsupported element size\");\n+  uint64_t upper = UCONST64(-1) << (elembits\/2) << (elembits\/2);\n+  \/* Allow all zeros or all ones in top bits, so that\n+   * constant expressions like ~1 are permitted. *\/\n+  if ((imm & ~upper) != imm && (imm | upper) != imm)\n+    return 0xffffffff;\n+\n+  \/\/ Replicate the immediate in different element sizes to 64 bits.\n+  imm &= ~upper;\n+  for (unsigned i = elembits; i < 64; i *= 2) {\n+    imm |= (imm << i);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":34,"deletions":20,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -161,1 +161,2 @@\n-  uint32_t encode_logical_immediate(bool is32, uint64_t imm);\n+  uint32_t encode_logical_immediate(unsigned elembits, uint64_t imm);\n+  bool operand_valid_for_immediate_bits(int64_t imm, unsigned nbits);\n@@ -772,1 +773,1 @@\n-#define INSN(NAME, decode, is32)                                \\\n+#define INSN(NAME, decode, elembits)                            \\\n@@ -775,1 +776,1 @@\n-    uint32_t val = encode_logical_immediate(is32, imm);         \\\n+    uint32_t val = encode_logical_immediate(elembits, imm);     \\\n@@ -780,6 +781,6 @@\n-  INSN(andw, 0b000, true);\n-  INSN(orrw, 0b001, true);\n-  INSN(eorw, 0b010, true);\n-  INSN(andr,  0b100, false);\n-  INSN(orr,  0b101, false);\n-  INSN(eor,  0b110, false);\n+  INSN(andw, 0b000, 32);\n+  INSN(orrw, 0b001, 32);\n+  INSN(eorw, 0b010, 32);\n+  INSN(andr, 0b100, 64);\n+  INSN(orr,  0b101, 64);\n+  INSN(eor,  0b110, 64);\n@@ -789,1 +790,1 @@\n-#define INSN(NAME, decode, is32)                                \\\n+#define INSN(NAME, decode, elembits)                            \\\n@@ -792,1 +793,1 @@\n-    uint32_t val = encode_logical_immediate(is32, imm);         \\\n+    uint32_t val = encode_logical_immediate(elembits, imm);     \\\n@@ -797,2 +798,2 @@\n-  INSN(ands, 0b111, false);\n-  INSN(andsw, 0b011, true);\n+  INSN(ands,  0b111, 64);\n+  INSN(andsw, 0b011, 32);\n@@ -1519,0 +1520,2 @@\n+  \/\/ Return the corresponding bits for different SIMD_RegVariant value.\n+  static unsigned regVariant_to_elemBits(SIMD_RegVariant T);\n@@ -2945,0 +2948,26 @@\n+\/\/ SVE integer add\/subtract immediate (unpredicated)\n+#define INSN(NAME, op)                                                  \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, unsigned imm8) {       \\\n+    starti;                                                             \\\n+    \/* The immediate is an unsigned value in the range 0 to 255, and    \\\n+     * for element width of 16 bits or higher it may also be a          \\\n+     * positive multiple of 256 in the range 256 to 65280.              \\\n+     *\/                                                                 \\\n+    assert(T != Q, \"invalid size\");                                     \\\n+    int sh = 0;                                                         \\\n+    if (imm8 <= 0xff) {                                                 \\\n+      sh = 0;                                                           \\\n+    } else if (T != B && imm8 <= 0xff00 && (imm8 & 0xff) == 0) {        \\\n+      sh = 1;                                                           \\\n+      imm8 = (imm8 >> 8);                                               \\\n+    } else {                                                            \\\n+      guarantee(false, \"invalid immediate\");                            \\\n+    }                                                                   \\\n+    f(0b00100101, 31, 24), f(T, 23, 22), f(0b10000, 21, 17);            \\\n+    f(op, 16, 14), f(sh, 13), f(imm8, 12, 5), rf(Zd, 0);                \\\n+  }\n+\n+  INSN(sve_add, 0b011);\n+  INSN(sve_sub, 0b111);\n+#undef INSN\n+\n@@ -3052,0 +3081,14 @@\n+\/\/ SVE bitwise logical with immediate (unpredicated)\n+#define INSN(NAME, opc)                                                      \\\n+  void NAME(FloatRegister Zd, SIMD_RegVariant T, uint64_t imm) {             \\\n+    starti;                                                                  \\\n+    unsigned elembits = regVariant_to_elemBits(T);                           \\\n+    uint32_t val = encode_logical_immediate(elembits, imm);                  \\\n+    f(0b00000101, 31, 24), f(opc, 23, 22), f(0b0000, 21, 18);                \\\n+    f(val, 17, 5), rf(Zd, 0);                                                \\\n+  }\n+  INSN(sve_and, 0b10);\n+  INSN(sve_eor, 0b01);\n+  INSN(sve_orr, 0b00);\n+#undef INSN\n+\n@@ -3527,1 +3570,1 @@\n-  static bool operand_valid_for_logical_immediate(bool is32, uint64_t imm);\n+  static bool operand_valid_for_logical_immediate(unsigned elembits, uint64_t imm);\n@@ -3529,0 +3572,1 @@\n+  static bool operand_valid_for_sve_add_sub_immediate(int64_t imm);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":58,"deletions":14,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-    if (!Assembler::operand_valid_for_logical_immediate(false, x)) {\n+    if (!Assembler::operand_valid_for_logical_immediate(BitsPerLong, x)) {\n@@ -238,1 +238,1 @@\n-    if (!Assembler::operand_valid_for_logical_immediate(true, x)) {\n+    if (!Assembler::operand_valid_for_logical_immediate(BitsPerInt, x)) {\n@@ -678,5 +678,5 @@\n-  if (right.is_constant()\n-      && ((right.type()->tag() == intTag\n-           && Assembler::operand_valid_for_logical_immediate(true, right.get_jint_constant()))\n-          || (right.type()->tag() == longTag\n-              && Assembler::operand_valid_for_logical_immediate(false, right.get_jlong_constant()))))  {\n+  if (right.is_constant() &&\n+      ((right.type()->tag() == intTag &&\n+        Assembler::operand_valid_for_logical_immediate(BitsPerInt, right.get_jint_constant())) ||\n+       (right.type()->tag() == longTag &&\n+        Assembler::operand_valid_for_logical_immediate(BitsPerLong, right.get_jlong_constant()))))  {\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRGenerator_aarch64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1379,1 +1379,1 @@\n-  if (operand_valid_for_logical_immediate(false, imm64)) {\n+  if (operand_valid_for_logical_immediate(64, imm64)) {\n@@ -1492,1 +1492,1 @@\n-  if (operand_valid_for_logical_immediate(true, imm32)) {\n+  if (operand_valid_for_logical_immediate(32, imm32)) {\n@@ -3834,1 +3834,1 @@\n-        \/*is32*\/false, (uint64_t)CompressedKlassPointers::base())) {\n+        64, (uint64_t)CompressedKlassPointers::base())) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -10,0 +10,49 @@\n+# These tables are legal immediate logical operands\n+immediates8 \\\n+     = [0x1, 0x0c, 0x3e, 0x60, 0x7c, 0x80, 0x83,\n+        0xe1, 0xbf, 0xef, 0xf3, 0xfe]\n+\n+immediates16 \\\n+     = [0x1, 0x38, 0x7e, 0xff, 0x1fc, 0x1ff, 0x3f0,\n+        0x7e0, 0xfc0, 0x1f80, 0x3ff0, 0x7e00, 0x7e00,\n+        0x8000, 0x81ff, 0xc1ff, 0xc003, 0xc7ff, 0xdfff,\n+        0xe03f, 0xe10f, 0xe1ff, 0xf801, 0xfc00, 0xfc07,\n+        0xff03, 0xfffe]\n+\n+immediates32 \\\n+     = [0x1, 0x3f, 0x1f0, 0x7e0,\n+        0x1c00, 0x3ff0, 0x8000, 0x1e000,\n+        0x3e000, 0x78000, 0xe0000, 0x100000,\n+        0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8,\n+        0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0,\n+        0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00,\n+        0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe,\n+        0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80,\n+        0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f,\n+        0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003,\n+        0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff,\n+        0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff,\n+        0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87,\n+        0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1,\n+        0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff,\n+        0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07,\n+        0xffffffbf, 0xfffffffd]\n+\n+immediates64 \\\n+     = [0x1, 0x1f80, 0x3fff0, 0x3ffffc,\n+        0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000,\n+        0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000,\n+        0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000,\n+        0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000,\n+        0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000,\n+        0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8,\n+        0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000,\n+        0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff,\n+        0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003,\n+        0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff,\n+        0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000,\n+        0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f,\n+        0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff,\n+        0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff,\n+        0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]\n+\n@@ -354,39 +403,0 @@\n-\n-     # These tables are legal immediate logical operands\n-     immediates32 \\\n-         = [0x1, 0x3f, 0x1f0, 0x7e0,\n-            0x1c00, 0x3ff0, 0x8000, 0x1e000,\n-            0x3e000, 0x78000, 0xe0000, 0x100000,\n-            0x1fffe0, 0x3fe000, 0x780000, 0x7ffff8,\n-            0xff8000, 0x1800180, 0x1fffc00, 0x3c003c0,\n-            0x3ffff00, 0x7c00000, 0x7fffe00, 0xf000f00,\n-            0xfffe000, 0x18181818, 0x1ffc0000, 0x1ffffffe,\n-            0x3f003f00, 0x3fffe000, 0x60006000, 0x7f807f80,\n-            0x7ffffc00, 0x800001ff, 0x803fffff, 0x9f9f9f9f,\n-            0xc0000fff, 0xc0c0c0c0, 0xe0000000, 0xe003e003,\n-            0xe3ffffff, 0xf0000fff, 0xf0f0f0f0, 0xf80000ff,\n-            0xf83ff83f, 0xfc00007f, 0xfc1fffff, 0xfe0001ff,\n-            0xfe3fffff, 0xff003fff, 0xff800003, 0xff87ff87,\n-            0xffc00fff, 0xffe0000f, 0xffefffef, 0xfff1fff1,\n-            0xfff83fff, 0xfffc0fff, 0xfffe0fff, 0xffff3fff,\n-            0xffffc007, 0xffffe1ff, 0xfffff80f, 0xfffffe07,\n-            0xffffffbf, 0xfffffffd]\n-\n-     immediates \\\n-         = [0x1, 0x1f80, 0x3fff0, 0x3ffffc,\n-            0x3fe0000, 0x1ffc0000, 0xf8000000, 0x3ffffc000,\n-            0xffffffe00, 0x3ffffff800, 0xffffc00000, 0x3f000000000,\n-            0x7fffffff800, 0x1fe000001fe0, 0x3ffffff80000, 0xc00000000000,\n-            0x1ffc000000000, 0x3ffff0003ffff, 0x7ffffffe00000, 0xfffffffffc000,\n-            0x1ffffffffffc00, 0x3fffffffffff00, 0x7ffffffffffc00, 0xffffffffff8000,\n-            0x1ffffffff800000, 0x3fffffc03fffffc, 0x7fffc0000000000, 0xff80ff80ff80ff8,\n-            0x1c00000000000000, 0x1fffffffffff0000, 0x3fffff803fffff80, 0x7fc000007fc00000,\n-            0x8000000000000000, 0x803fffff803fffff, 0xc000007fc000007f, 0xe00000000000ffff,\n-            0xe3ffffffffffffff, 0xf007f007f007f007, 0xf80003ffffffffff, 0xfc000003fc000003,\n-            0xfe000000007fffff, 0xff00000000007fff, 0xff800000000003ff, 0xffc00000000000ff,\n-            0xffe00000000003ff, 0xfff0000000003fff, 0xfff80000001fffff, 0xfffc0000fffc0000,\n-            0xfffe003fffffffff, 0xffff3fffffffffff, 0xffffc0000007ffff, 0xffffe01fffffe01f,\n-            0xfffff800000007ff, 0xfffffc0fffffffff, 0xffffff00003fffff, 0xffffffc0000007ff,\n-            0xfffffff0000001ff, 0xfffffffc00003fff, 0xffffffff07ffffff, 0xffffffffe003ffff,\n-            0xfffffffffc01ffff, 0xffffffffffc00003, 0xfffffffffffc000f, 0xffffffffffffe07f]\n-\n@@ -396,1 +406,1 @@\n-              self.immediates32[random.randint(0, len(self.immediates32)-1)] \\\n+              immediates32[random.randint(0, len(immediates32)-1)] \\\n@@ -398,1 +408,1 @@\n-              self.immediates[random.randint(0, len(self.immediates)-1)]\n+              immediates64[random.randint(0, len(immediates64)-1)]\n@@ -409,0 +419,38 @@\n+class SVEBinaryImmOp(Instruction):\n+    def __init__(self, name):\n+        reg = SVEVectorRegister().generate()\n+        self.reg = [reg, reg]\n+        self.numRegs = len(self.reg)\n+        self._width = RegVariant(0, 3)\n+        self._isLogical = False\n+        if name in [\"and\", \"eor\", \"orr\"]:\n+            self._isLogical = True\n+        Instruction.__init__(self, name)\n+\n+    def generate(self):\n+        Instruction.generate(self)\n+        self.immed = random.randint(0, (1<<8)-1)\n+        if self._isLogical:\n+            vectype = self._width.cstr()\n+            if vectype == \"__ B\":\n+                self.immed = immediates8[random.randint(0, len(immediates8)-1)]\n+            elif vectype == \"__ H\":\n+                self.immed = immediates16[random.randint(0, len(immediates16)-1)]\n+            elif vectype == \"__ S\":\n+                self.immed = immediates32[random.randint(0, len(immediates32)-1)]\n+            elif vectype == \"__ D\":\n+                self.immed = immediates64[random.randint(0, len(immediates64)-1)]\n+        return self\n+\n+    def cstr(self):\n+        formatStr = \"%s%s, %s, %su);\"\n+        return (formatStr\n+                % tuple([\"__ sve_\" + self._name + \"(\"] +\n+                        [str(self.reg[0]), self._width.cstr(), self.immed]))\n+\n+    def astr(self):\n+        formatStr = \"%s%s, %s, #0x%x\"\n+        Regs = [str(self.reg[i]) + self._width.astr() for i in range(0, self.numRegs)]\n+        return (formatStr\n+                % tuple([Instruction.astr(self)] + Regs + [self.immed]))\n+\n@@ -1680,0 +1728,3 @@\n+for i in range(6):\n+    generate(SVEBinaryImmOp, [\"add\", \"sub\", \"and\", \"eor\", \"orr\"])\n+\n","filename":"test\/hotspot\/gtest\/aarch64\/aarch64-asmtest.py","additions":92,"deletions":41,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -974,0 +974,42 @@\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z4, __ B, 147u);                        \/\/       add     z4.b, z4.b, #0x93\n+    __ sve_sub(z0, __ B, 124u);                        \/\/       sub     z0.b, z0.b, #0x7c\n+    __ sve_and(z1, __ H, 508u);                        \/\/       and     z1.h, z1.h, #0x1fc\n+    __ sve_eor(z9, __ D, 18374686479671656447u);       \/\/       eor     z9.d, z9.d, #0xff00000000007fff\n+    __ sve_orr(z22, __ S, 251662080u);                 \/\/       orr     z22.s, z22.s, #0xf000f00\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z8, __ S, 248u);                        \/\/       add     z8.s, z8.s, #0xf8\n+    __ sve_sub(z6, __ S, 16u);                         \/\/       sub     z6.s, z6.s, #0x10\n+    __ sve_and(z11, __ D, 4160749568u);                \/\/       and     z11.d, z11.d, #0xf8000000\n+    __ sve_eor(z26, __ S, 1610637312u);                \/\/       eor     z26.s, z26.s, #0x60006000\n+    __ sve_orr(z13, __ D, 18446181398634037247u);      \/\/       orr     z13.d, z13.d, #0xfffe003fffffffff\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z5, __ B, 112u);                        \/\/       add     z5.b, z5.b, #0x70\n+    __ sve_sub(z10, __ S, 88u);                        \/\/       sub     z10.s, z10.s, #0x58\n+    __ sve_and(z26, __ S, 253952u);                    \/\/       and     z26.s, z26.s, #0x3e000\n+    __ sve_eor(z22, __ S, 496u);                       \/\/       eor     z22.s, z22.s, #0x1f0\n+    __ sve_orr(z19, __ S, 536870910u);                 \/\/       orr     z19.s, z19.s, #0x1ffffffe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z14, __ H, 22u);                        \/\/       add     z14.h, z14.h, #0x16\n+    __ sve_sub(z16, __ B, 172u);                       \/\/       sub     z16.b, z16.b, #0xac\n+    __ sve_and(z23, __ B, 62u);                        \/\/       and     z23.b, z23.b, #0x3e\n+    __ sve_eor(z17, __ H, 33279u);                     \/\/       eor     z17.h, z17.h, #0x81ff\n+    __ sve_orr(z16, __ B, 254u);                       \/\/       orr     z16.b, z16.b, #0xfe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z3, __ B, 49u);                         \/\/       add     z3.b, z3.b, #0x31\n+    __ sve_sub(z17, __ S, 110u);                       \/\/       sub     z17.s, z17.s, #0x6e\n+    __ sve_and(z12, __ S, 4290777087u);                \/\/       and     z12.s, z12.s, #0xffc00fff\n+    __ sve_eor(z19, __ S, 134217216u);                 \/\/       eor     z19.s, z19.s, #0x7fffe00\n+    __ sve_orr(z23, __ B, 254u);                       \/\/       orr     z23.b, z23.b, #0xfe\n+\n+\/\/ SVEBinaryImmOp\n+    __ sve_add(z13, __ S, 54u);                        \/\/       add     z13.s, z13.s, #0x36\n+    __ sve_sub(z0, __ B, 120u);                        \/\/       sub     z0.b, z0.b, #0x78\n+    __ sve_and(z17, __ D, 18014398509481728u);         \/\/       and     z17.d, z17.d, #0x3fffffffffff00\n+    __ sve_eor(z22, __ S, 4294709247u);                \/\/       eor     z22.s, z22.s, #0xfffc0fff\n+    __ sve_orr(z2, __ B, 225u);                        \/\/       orr     z2.b, z2.b, #0xe1\n+\n@@ -975,41 +1017,41 @@\n-    __ sve_add(z4, __ B, z6, z17);                     \/\/       add     z4.b, z6.b, z17.b\n-    __ sve_sub(z3, __ H, z15, z1);                     \/\/       sub     z3.h, z15.h, z1.h\n-    __ sve_fadd(z6, __ D, z5, z9);                     \/\/       fadd    z6.d, z5.d, z9.d\n-    __ sve_fmul(z7, __ D, z20, z22);                   \/\/       fmul    z7.d, z20.d, z22.d\n-    __ sve_fsub(z5, __ D, z10, z8);                    \/\/       fsub    z5.d, z10.d, z8.d\n-    __ sve_abs(z30, __ B, p1, z17);                    \/\/       abs     z30.b, p1\/m, z17.b\n-    __ sve_add(z11, __ B, p7, z28);                    \/\/       add     z11.b, p7\/m, z11.b, z28.b\n-    __ sve_asr(z26, __ H, p5, z28);                    \/\/       asr     z26.h, p5\/m, z26.h, z28.h\n-    __ sve_cnt(z13, __ D, p7, z16);                    \/\/       cnt     z13.d, p7\/m, z16.d\n-    __ sve_lsl(z5, __ H, p0, z13);                     \/\/       lsl     z5.h, p0\/m, z5.h, z13.h\n-    __ sve_lsr(z15, __ S, p2, z26);                    \/\/       lsr     z15.s, p2\/m, z15.s, z26.s\n-    __ sve_mul(z11, __ S, p1, z22);                    \/\/       mul     z11.s, p1\/m, z11.s, z22.s\n-    __ sve_neg(z4, __ S, p0, z19);                     \/\/       neg     z4.s, p0\/m, z19.s\n-    __ sve_not(z17, __ H, p3, z14);                    \/\/       not     z17.h, p3\/m, z14.h\n-    __ sve_smax(z2, __ S, p4, z3);                     \/\/       smax    z2.s, p4\/m, z2.s, z3.s\n-    __ sve_smin(z23, __ B, p1, z6);                    \/\/       smin    z23.b, p1\/m, z23.b, z6.b\n-    __ sve_sub(z17, __ S, p3, z27);                    \/\/       sub     z17.s, p3\/m, z17.s, z27.s\n-    __ sve_fabs(z16, __ D, p1, z2);                    \/\/       fabs    z16.d, p1\/m, z2.d\n-    __ sve_fadd(z3, __ D, p1, z6);                     \/\/       fadd    z3.d, p1\/m, z3.d, z6.d\n-    __ sve_fdiv(z19, __ D, p3, z12);                   \/\/       fdiv    z19.d, p3\/m, z19.d, z12.d\n-    __ sve_fmax(z8, __ D, p6, z19);                    \/\/       fmax    z8.d, p6\/m, z8.d, z19.d\n-    __ sve_fmin(z0, __ S, p2, z23);                    \/\/       fmin    z0.s, p2\/m, z0.s, z23.s\n-    __ sve_fmul(z19, __ D, p7, z13);                   \/\/       fmul    z19.d, p7\/m, z19.d, z13.d\n-    __ sve_fneg(z6, __ S, p0, z7);                     \/\/       fneg    z6.s, p0\/m, z7.s\n-    __ sve_frintm(z17, __ S, p6, z8);                  \/\/       frintm  z17.s, p6\/m, z8.s\n-    __ sve_frintn(z22, __ D, p5, z22);                 \/\/       frintn  z22.d, p5\/m, z22.d\n-    __ sve_frintp(z2, __ D, p0, z15);                  \/\/       frintp  z2.d, p0\/m, z15.d\n-    __ sve_fsqrt(z20, __ D, p1, z4);                   \/\/       fsqrt   z20.d, p1\/m, z4.d\n-    __ sve_fsub(z7, __ D, p0, z8);                     \/\/       fsub    z7.d, p0\/m, z7.d, z8.d\n-    __ sve_fmla(z19, __ S, p5, z4, z15);               \/\/       fmla    z19.s, p5\/m, z4.s, z15.s\n-    __ sve_fmls(z22, __ D, p2, z25, z5);               \/\/       fmls    z22.d, p2\/m, z25.d, z5.d\n-    __ sve_fnmla(z16, __ S, p3, z22, z11);             \/\/       fnmla   z16.s, p3\/m, z22.s, z11.s\n-    __ sve_fnmls(z13, __ D, p2, z20, z16);             \/\/       fnmls   z13.d, p2\/m, z20.d, z16.d\n-    __ sve_mla(z15, __ H, p1, z4, z17);                \/\/       mla     z15.h, p1\/m, z4.h, z17.h\n-    __ sve_mls(z6, __ S, p7, z4, z28);                 \/\/       mls     z6.s, p7\/m, z4.s, z28.s\n-    __ sve_and(z29, z26, z9);                          \/\/       and     z29.d, z26.d, z9.d\n-    __ sve_eor(z2, z11, z28);                          \/\/       eor     z2.d, z11.d, z28.d\n-    __ sve_orr(z7, z1, z26);                           \/\/       orr     z7.d, z1.d, z26.d\n-    __ sve_bic(z17, z14, z8);                          \/\/       bic     z17.d, z14.d, z8.d\n-    __ sve_uzp1(z21, __ S, z24, z5);                   \/\/       uzp1    z21.s, z24.s, z5.s\n-    __ sve_uzp2(z21, __ S, z17, z22);                  \/\/       uzp2    z21.s, z17.s, z22.s\n+    __ sve_add(z20, __ D, z7, z4);                     \/\/       add     z20.d, z7.d, z4.d\n+    __ sve_sub(z7, __ S, z0, z8);                      \/\/       sub     z7.s, z0.s, z8.s\n+    __ sve_fadd(z19, __ D, z22, z4);                   \/\/       fadd    z19.d, z22.d, z4.d\n+    __ sve_fmul(z9, __ D, z22, z11);                   \/\/       fmul    z9.d, z22.d, z11.d\n+    __ sve_fsub(z5, __ S, z30, z16);                   \/\/       fsub    z5.s, z30.s, z16.s\n+    __ sve_abs(z22, __ H, p3, z1);                     \/\/       abs     z22.h, p3\/m, z1.h\n+    __ sve_add(z8, __ D, p5, z16);                     \/\/       add     z8.d, p5\/m, z8.d, z16.d\n+    __ sve_asr(z15, __ S, p1, z4);                     \/\/       asr     z15.s, p1\/m, z15.s, z4.s\n+    __ sve_cnt(z8, __ B, p1, z29);                     \/\/       cnt     z8.b, p1\/m, z29.b\n+    __ sve_lsl(z28, __ D, p4, z29);                    \/\/       lsl     z28.d, p4\/m, z28.d, z29.d\n+    __ sve_lsr(z9, __ H, p3, z2);                      \/\/       lsr     z9.h, p3\/m, z9.h, z2.h\n+    __ sve_mul(z28, __ B, p0, z7);                     \/\/       mul     z28.b, p0\/m, z28.b, z7.b\n+    __ sve_neg(z26, __ H, p5, z17);                    \/\/       neg     z26.h, p5\/m, z17.h\n+    __ sve_not(z8, __ D, p4, z21);                     \/\/       not     z8.d, p4\/m, z21.d\n+    __ sve_smax(z5, __ S, p5, z21);                    \/\/       smax    z5.s, p5\/m, z5.s, z21.s\n+    __ sve_smin(z22, __ S, p4, z29);                   \/\/       smin    z22.s, p4\/m, z22.s, z29.s\n+    __ sve_sub(z19, __ S, p0, z4);                     \/\/       sub     z19.s, p0\/m, z19.s, z4.s\n+    __ sve_fabs(z23, __ S, p1, z19);                   \/\/       fabs    z23.s, p1\/m, z19.s\n+    __ sve_fadd(z23, __ S, p6, z19);                   \/\/       fadd    z23.s, p6\/m, z23.s, z19.s\n+    __ sve_fdiv(z8, __ D, p2, z14);                    \/\/       fdiv    z8.d, p2\/m, z8.d, z14.d\n+    __ sve_fmax(z17, __ S, p7, z21);                   \/\/       fmax    z17.s, p7\/m, z17.s, z21.s\n+    __ sve_fmin(z30, __ D, p0, z10);                   \/\/       fmin    z30.d, p0\/m, z30.d, z10.d\n+    __ sve_fmul(z12, __ S, p0, z9);                    \/\/       fmul    z12.s, p0\/m, z12.s, z9.s\n+    __ sve_fneg(z24, __ D, p4, z4);                    \/\/       fneg    z24.d, p4\/m, z4.d\n+    __ sve_frintm(z6, __ D, p2, z27);                  \/\/       frintm  z6.d, p2\/m, z27.d\n+    __ sve_frintn(z13, __ D, p4, z30);                 \/\/       frintn  z13.d, p4\/m, z30.d\n+    __ sve_frintp(z22, __ D, p5, z30);                 \/\/       frintp  z22.d, p5\/m, z30.d\n+    __ sve_fsqrt(z9, __ S, p3, z19);                   \/\/       fsqrt   z9.s, p3\/m, z19.s\n+    __ sve_fsub(z20, __ S, p7, z9);                    \/\/       fsub    z20.s, p7\/m, z20.s, z9.s\n+    __ sve_fmla(z13, __ D, p3, z19, z1);               \/\/       fmla    z13.d, p3\/m, z19.d, z1.d\n+    __ sve_fmls(z8, __ D, p4, z13, z17);               \/\/       fmls    z8.d, p4\/m, z13.d, z17.d\n+    __ sve_fnmla(z16, __ S, p1, z0, z3);               \/\/       fnmla   z16.s, p1\/m, z0.s, z3.s\n+    __ sve_fnmls(z7, __ S, p3, z14, z15);              \/\/       fnmls   z7.s, p3\/m, z14.s, z15.s\n+    __ sve_mla(z15, __ H, p7, z5, z0);                 \/\/       mla     z15.h, p7\/m, z5.h, z0.h\n+    __ sve_mls(z21, __ H, p6, z3, z0);                 \/\/       mls     z21.h, p6\/m, z3.h, z0.h\n+    __ sve_and(z19, z28, z10);                         \/\/       and     z19.d, z28.d, z10.d\n+    __ sve_eor(z3, z19, z7);                           \/\/       eor     z3.d, z19.d, z7.d\n+    __ sve_orr(z28, z13, z21);                         \/\/       orr     z28.d, z13.d, z21.d\n+    __ sve_bic(z26, z12, z17);                         \/\/       bic     z26.d, z12.d, z17.d\n+    __ sve_uzp1(z17, __ D, z14, z2);                   \/\/       uzp1    z17.d, z14.d, z2.d\n+    __ sve_uzp2(z16, __ B, z21, z20);                  \/\/       uzp2    z16.b, z21.b, z20.b\n@@ -1018,9 +1060,9 @@\n-    __ sve_andv(v29, __ B, p5, z19);                   \/\/       andv b29, p5, z19.b\n-    __ sve_orv(v4, __ B, p4, z23);                     \/\/       orv b4, p4, z23.b\n-    __ sve_eorv(v19, __ D, p1, z23);                   \/\/       eorv d19, p1, z23.d\n-    __ sve_smaxv(v19, __ H, p0, z8);                   \/\/       smaxv h19, p0, z8.h\n-    __ sve_sminv(v14, __ D, p6, z17);                  \/\/       sminv d14, p6, z17.d\n-    __ sve_fminv(v21, __ S, p1, z30);                  \/\/       fminv s21, p1, z30.s\n-    __ sve_fmaxv(v10, __ S, p5, z12);                  \/\/       fmaxv s10, p5, z12.s\n-    __ sve_fadda(v9, __ D, p1, z24);                   \/\/       fadda d9, p1, d9, z24.d\n-    __ sve_uaddv(v4, __ H, p6, z6);                    \/\/       uaddv d4, p6, z6.h\n+    __ sve_andv(v19, __ D, p0, z1);                    \/\/       andv d19, p0, z1.d\n+    __ sve_orv(v17, __ S, p2, z16);                    \/\/       orv s17, p2, z16.s\n+    __ sve_eorv(v21, __ B, p0, z4);                    \/\/       eorv b21, p0, z4.b\n+    __ sve_smaxv(v23, __ H, p3, z6);                   \/\/       smaxv h23, p3, z6.h\n+    __ sve_sminv(v20, __ D, p3, z16);                  \/\/       sminv d20, p3, z16.d\n+    __ sve_fminv(v12, __ D, p0, z3);                   \/\/       fminv d12, p0, z3.d\n+    __ sve_fmaxv(v9, __ D, p0, z24);                   \/\/       fmaxv d9, p0, z24.d\n+    __ sve_fadda(v3, __ S, p4, z22);                   \/\/       fadda s3, p4, s3, z22.s\n+    __ sve_uaddv(v25, __ B, p5, z13);                  \/\/       uaddv d25, p5, z13.b\n@@ -1045,7 +1087,7 @@\n-    0x14000000,     0x17ffffd7,     0x1400034c,     0x94000000,\n-    0x97ffffd4,     0x94000349,     0x3400000a,     0x34fffa2a,\n-    0x340068ca,     0x35000008,     0x35fff9c8,     0x35006868,\n-    0xb400000b,     0xb4fff96b,     0xb400680b,     0xb500001d,\n-    0xb5fff91d,     0xb50067bd,     0x10000013,     0x10fff8b3,\n-    0x10006753,     0x90000013,     0x36300016,     0x3637f836,\n-    0x363066d6,     0x3758000c,     0x375ff7cc,     0x3758666c,\n+    0x14000000,     0x17ffffd7,     0x1400036a,     0x94000000,\n+    0x97ffffd4,     0x94000367,     0x3400000a,     0x34fffa2a,\n+    0x34006c8a,     0x35000008,     0x35fff9c8,     0x35006c28,\n+    0xb400000b,     0xb4fff96b,     0xb4006bcb,     0xb500001d,\n+    0xb5fff91d,     0xb5006b7d,     0x10000013,     0x10fff8b3,\n+    0x10006b13,     0x90000013,     0x36300016,     0x3637f836,\n+    0x36306a96,     0x3758000c,     0x375ff7cc,     0x37586a2c,\n@@ -1056,13 +1098,13 @@\n-    0x54006440,     0x54000001,     0x54fff541,     0x540063e1,\n-    0x54000002,     0x54fff4e2,     0x54006382,     0x54000002,\n-    0x54fff482,     0x54006322,     0x54000003,     0x54fff423,\n-    0x540062c3,     0x54000003,     0x54fff3c3,     0x54006263,\n-    0x54000004,     0x54fff364,     0x54006204,     0x54000005,\n-    0x54fff305,     0x540061a5,     0x54000006,     0x54fff2a6,\n-    0x54006146,     0x54000007,     0x54fff247,     0x540060e7,\n-    0x54000008,     0x54fff1e8,     0x54006088,     0x54000009,\n-    0x54fff189,     0x54006029,     0x5400000a,     0x54fff12a,\n-    0x54005fca,     0x5400000b,     0x54fff0cb,     0x54005f6b,\n-    0x5400000c,     0x54fff06c,     0x54005f0c,     0x5400000d,\n-    0x54fff00d,     0x54005ead,     0x5400000e,     0x54ffefae,\n-    0x54005e4e,     0x5400000f,     0x54ffef4f,     0x54005def,\n+    0x54006800,     0x54000001,     0x54fff541,     0x540067a1,\n+    0x54000002,     0x54fff4e2,     0x54006742,     0x54000002,\n+    0x54fff482,     0x540066e2,     0x54000003,     0x54fff423,\n+    0x54006683,     0x54000003,     0x54fff3c3,     0x54006623,\n+    0x54000004,     0x54fff364,     0x540065c4,     0x54000005,\n+    0x54fff305,     0x54006565,     0x54000006,     0x54fff2a6,\n+    0x54006506,     0x54000007,     0x54fff247,     0x540064a7,\n+    0x54000008,     0x54fff1e8,     0x54006448,     0x54000009,\n+    0x54fff189,     0x540063e9,     0x5400000a,     0x54fff12a,\n+    0x5400638a,     0x5400000b,     0x54fff0cb,     0x5400632b,\n+    0x5400000c,     0x54fff06c,     0x540062cc,     0x5400000d,\n+    0x54fff00d,     0x5400626d,     0x5400000e,     0x54ffefae,\n+    0x5400620e,     0x5400000f,     0x54ffef4f,     0x540061af,\n@@ -1100,1 +1142,1 @@\n-    0xbd1b1869,     0x58004e3b,     0x1800000b,     0xf8945060,\n+    0xbd1b1869,     0x580051fb,     0x1800000b,     0xf8945060,\n@@ -1244,13 +1286,21 @@\n-    0x043100c4,     0x046105e3,     0x65c900a6,     0x65d60a87,\n-    0x65c80545,     0x0416a63e,     0x04001f8b,     0x0450979a,\n-    0x04dabe0d,     0x045381a5,     0x04918b4f,     0x049006cb,\n-    0x0497a264,     0x045eadd1,     0x04881062,     0x040a04d7,\n-    0x04810f71,     0x04dca450,     0x65c084c3,     0x65cd8d93,\n-    0x65c69a68,     0x65878ae0,     0x65c29db3,     0x049da0e6,\n-    0x6582b911,     0x65c0b6d6,     0x65c1a1e2,     0x65cda494,\n-    0x65c18107,     0x65af1493,     0x65e52b36,     0x65ab4ed0,\n-    0x65f06a8d,     0x0451448f,     0x049c7c86,     0x0429335d,\n-    0x04bc3162,     0x047a3027,     0x04e831d1,     0x05a56b15,\n-    0x05b66e35,     0x041a367d,     0x041832e4,     0x04d926f3,\n-    0x04482113,     0x04ca3a2e,     0x658727d5,     0x6586358a,\n-    0x65d82709,     0x044138c4,\n+    0x2520d264,     0x2521cf80,     0x058074c1,     0x054242c9,\n+    0x05004476,     0x25a0df08,     0x25a1c206,     0x0583288b,\n+    0x05401c3a,     0x05027e8d,     0x2520ce05,     0x25a1cb0a,\n+    0x0580989a,     0x0540e096,     0x0500fb73,     0x2560c2ce,\n+    0x2521d590,     0x05803e97,     0x05400d31,     0x05003ed0,\n+    0x2520c623,     0x25a1cdd1,     0x058052ac,     0x0540ba33,\n+    0x05003ed7,     0x25a0c6cd,     0x2521cf00,     0x0583c5b1,\n+    0x05407336,     0x05001e62,     0x04e400f4,     0x04a80407,\n+    0x65c402d3,     0x65cb0ac9,     0x659007c5,     0x0456ac36,\n+    0x04c01608,     0x0490848f,     0x041aa7a8,     0x04d393bc,\n+    0x04518c49,     0x041000fc,     0x0457b63a,     0x04deb2a8,\n+    0x048816a5,     0x048a13b6,     0x04810093,     0x049ca677,\n+    0x65809a77,     0x65cd89c8,     0x65869eb1,     0x65c7815e,\n+    0x6582812c,     0x04ddb098,     0x65c2ab66,     0x65c0b3cd,\n+    0x65c1b7d6,     0x658dae69,     0x65819d34,     0x65e10e6d,\n+    0x65f131a8,     0x65a34410,     0x65af6dc7,     0x04405caf,\n+    0x04407875,     0x042a3393,     0x04a73263,     0x047531bc,\n+    0x04f1319a,     0x05e269d1,     0x05346eb0,     0x04da2033,\n+    0x04982a11,     0x04192095,     0x04482cd7,     0x04ca2e14,\n+    0x65c7206c,     0x65c62309,     0x659832c3,     0x040135b9,\n+\n@@ -1259,1 +1309,0 @@\n-\n","filename":"test\/hotspot\/gtest\/aarch64\/asmtest.out.h","additions":134,"deletions":85,"binary":false,"changes":219,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    byte[] a3 = new byte[ARRLEN];\n@@ -97,0 +98,10 @@\n+      test_addImm127(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_addImm256(a1, a2);\n+      test_addImmNeg128(a1, a2);\n+      test_addImmNeg129(a1, a2);\n+      test_subImm(a1, a2, a3);\n+      test_andImm21(a1, a2);\n+      test_andImm7(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2, a3);\n@@ -490,0 +501,71 @@\n+      byte base = (byte) 10;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte) 10;\n+      }\n+      byte golden = (byte)(base + 127);\n+      test_addImm127(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm127: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (byte)(base + 8);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      test_addImm256(a1, a2);\n+      golden = (byte)(base + 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm256: a3\", i, a2[i], golden);\n+      }\n+      test_addImmNeg128(a1, a2);\n+      golden = (byte)(base + (-128));\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImmNeg128: a2\", i, a2[i], golden);\n+      }\n+      test_addImmNeg129(a1, a2);\n+      golden = (byte)(base + (-129));\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImmNeg129: a2\", i, a2[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = (byte) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (byte) 120;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = (byte) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_andImm21(a1, a2);\n+      golden = (byte) (base & 21);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm21: a2\", i, a2[i], golden);\n+      }\n+      test_andImm7(a1, a2);\n+      golden = (byte) (base & 7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm7: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (byte) (base | 3);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2, a3);\n+      golden = (byte) (base ^ 127);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (byte) (base ^ 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a3\", i, a3[i], golden);\n+      }\n@@ -733,0 +815,53 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm127(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm127: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImmNeg128(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImmNeg128: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImmNeg129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImmNeg129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm7(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm7: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n@@ -948,0 +1083,53 @@\n+  static void test_addImm127(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 127);\n+    }\n+  }\n+  static void test_addImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 8);\n+      c[i] = (byte) (a[i] + 255);\n+    }\n+  }\n+  static void test_addImm256(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + 256);\n+    }\n+  }\n+  static void test_addImmNeg128(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + (-128));\n+    }\n+  }\n+  static void test_addImmNeg129(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] + (-129));\n+    }\n+  }\n+  static void test_subImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] - 56);\n+      c[i] = (byte) (a[i] - 256);\n+    }\n+  }\n+  static void test_andImm21(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] & 21);\n+    }\n+  }\n+  static void test_andImm7(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] & 7);\n+    }\n+  }\n+  static void test_orImm(byte[] a, byte[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] | 3);\n+    }\n+  }\n+  static void test_xorImm(byte[] a, byte[] b, byte[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (byte) (a[i] ^ 127);\n+      c[i] = (byte) (a[i] ^ 255);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestByteVect.java","additions":189,"deletions":1,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    char[] a3 = new char[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm129(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_subImm56(a1, a2);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,50 @@\n+      \/\/ Reset for binary operation with immediate.\n+      char base = (char) 3;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (char) 3;\n+      }\n+      char golden = (char)(base + 129);\n+      test_addImm129(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm129: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (char)(base + 129);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (char) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      \/\/ Reset for sub operation test.\n+      base = (char) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (char) 120;\n+      }\n+      test_subImm56(a1, a2);\n+      golden = (char) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm56: a2\", i, a2[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = (char) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = (char) (base & 0xfe);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (char) (base | 0xff);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = (char) (base ^ 0xc7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n+\n@@ -733,0 +791,43 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm56(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm56: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n+\n@@ -948,0 +1049,41 @@\n+  static void test_addImm129(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] + 129);\n+    }\n+  }\n+  static void test_addImm(char[] a, char[] b, char[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] + 129);\n+      c[i] = (char) (a[i] + 255);\n+    }\n+  }\n+\n+  static void test_subImm56(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] - 56);\n+    }\n+  }\n+\n+  static void test_subImm256(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] - 256);\n+    }\n+  }\n+\n+  static void test_andImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] & 0xfe);\n+    }\n+  }\n+\n+  static void test_orImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] | 0xff);\n+    }\n+  }\n+\n+  static void test_xorImm(char[] a, char[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (char) (a[i] ^ 0xc7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestCharVect.java","additions":143,"deletions":1,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    int[] a3 = new int[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm127(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_addImm256(a1, a2);\n+      test_subImm(a1, a2, a3);\n+      test_andImm(a1, a2, a3);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,57 @@\n+      \/\/ Reset for binary operation with immediate\n+      int base = 10;\n+      for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = 10;\n+      }\n+      int golden = base + 127;\n+      test_addImm127(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm127: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = base + 127;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base + 255;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      test_addImm256(a1, a2);\n+      golden = base + 256;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm256: a2\", i, a2[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = 10000;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = 10000;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = base - 2304;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base - 65280;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_andImm(a1, a2, a3);\n+      golden = base + 2560;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base & 516096;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a3\", i, a3[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = base | 8257536;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = base ^ 2032;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +798,42 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm127(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm127: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -948,0 +1055,44 @@\n+  static void test_addImm127(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 127;\n+    }\n+  }\n+  static void test_addImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 127;\n+      c[i] = a[i] + 255;\n+    }\n+  }\n+  static void test_addImm256(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 256;\n+    }\n+  }\n+  static void test_subImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] - 2304;\n+      c[i] = a[i] - 65280;\n+    }\n+  }\n+  static void test_andImm21(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 21;\n+    }\n+  }\n+  static void test_andImm(int[] a, int[] b, int[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 2560;\n+      c[i] = a[i] & 516096;\n+    }\n+  }\n+  static void test_orImm(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] | 8257536;\n+    }\n+  }\n+  static void test_xorImm(int[] a, int[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] ^ 2032;\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestIntVect.java","additions":152,"deletions":1,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    long[] a3 = new long[ARRLEN];\n@@ -97,0 +98,6 @@\n+      test_addImm(a1, a2, a3);\n+      test_subImm(a1, a2, a3);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +497,47 @@\n+      \/\/ Reset for binary operations with immediate.\n+      for (int i=0; i<ARRLEN; i++) {\n+      a1[i] = 10;\n+      }\n+      long base = 10;\n+      test_addImm(a1, a2, a3);\n+      long golden = base & 516097;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base + 65280;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      base = 120;\n+      for (int i=0; i<ARRLEN; i++) {\n+        a1[i] = 120;\n+      }\n+      test_subImm(a1, a2, a3);\n+      golden = base + 65535;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a2\", i, a2[i], golden);\n+      }\n+      golden = base - 2147483647;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm: a3\", i, a3[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = base - 256;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = base & 132120576;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = base | 2113929216;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = base ^ 516096;\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +787,36 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -949,0 +1039,38 @@\n+  static void test_addImm(long[] a, long[] b, long[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 516097;\n+      c[i] = a[i] + 65280;\n+    }\n+  }\n+\n+  static void test_subImm(long[] a, long[] b, long[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] + 65535;\n+      c[i] = a[i] - 2147483647;\n+    }\n+  }\n+\n+  static void test_subImm256(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] - 256;\n+    }\n+  }\n+\n+  static void test_andImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] & 132120576;\n+    }\n+  }\n+\n+  static void test_orImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] | 2113929216;\n+    }\n+  }\n+\n+  static void test_xorImm(long[] a, long[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = a[i] ^ 516096;\n+    }\n+  }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestLongVect.java","additions":129,"deletions":1,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,1 @@\n+    short[] a3 = new short[ARRLEN];\n@@ -97,0 +98,7 @@\n+      test_addImm129(a1, a2);\n+      test_addImm(a1, a2, a3);\n+      test_subImm56(a1, a2);\n+      test_subImm256(a1, a2);\n+      test_andImm(a1, a2);\n+      test_orImm(a1, a2);\n+      test_xorImm(a1, a2);\n@@ -490,0 +498,48 @@\n+      short base = (short) 3;\n+      for (int i = 0; i < ARRLEN; i++) {\n+          a1[i] = (short) 3;\n+      }\n+      short golden = (short)(base + 129);\n+      test_addImm129(a1, a2);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm129: a2\", i, a2[i], golden);\n+      }\n+      test_addImm(a1, a2, a3);\n+      golden = (short)(base + 129);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a2\", i, a2[i], golden);\n+      }\n+      golden = (short) (base + 255);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_addImm: a3\", i, a3[i], golden);\n+      }\n+      \/\/ Reset for sub test\n+      base = (short) 120;\n+      for (int i = 0; i < ARRLEN; i++) {\n+        a1[i] = (short) 120;\n+      }\n+      test_subImm56(a1, a2);\n+      golden = (short) (base - 56);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm56: a2\", i, a2[i], golden);\n+      }\n+      test_subImm256(a1, a2);\n+      golden = (short) (base - 256);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_subImm256: a2\", i, a2[i], golden);\n+      }\n+      test_andImm(a1, a2);\n+      golden = (short) (base & 0xfe);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_andImm: a2\", i, a2[i], golden);\n+      }\n+      test_orImm(a1, a2);\n+      golden = (short) (base | 0xff);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_orImm: a2\", i, a2[i], golden);\n+      }\n+      test_xorImm(a1, a2);\n+      golden = (short) (base ^ 0xc7);\n+      for (int i=0; i<ARRLEN; i++) {\n+        errn += verify(\"test_xorImm: a2\", i, a2[i], golden);\n+      }\n@@ -733,0 +789,42 @@\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm129(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm129: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_addImm(a1, a2, a3);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_addImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm56(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm56: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_subImm256(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_subImm256: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_andImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_andImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_orImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_orImm: \" + (end - start));\n+    start = System.currentTimeMillis();\n+    for (int i=0; i<ITERS; i++) {\n+      test_xorImm(a1, a2);\n+    }\n+    end = System.currentTimeMillis();\n+    System.out.println(\"test_xorImm: \" + (end - start));\n@@ -948,0 +1046,37 @@\n+  static void test_addImm129(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] + 129);\n+    }\n+  }\n+\n+  static void test_addImm(short[] a, short[] b, short[] c) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] + 129);\n+      c[i] = (short) (a[i] + 255);\n+    }\n+  }\n+  static void test_subImm56(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] - 56);\n+    }\n+  }\n+  static void test_subImm256(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] - 256);\n+    }\n+  }\n+  static void test_andImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] & 0xfe);\n+    }\n+  }\n+  static void test_orImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] | 0xff);\n+    }\n+  }\n+  static void test_xorImm(short[] a, short[] b) {\n+    for (int i = 0; i < a.length; i++) {\n+      b[i] = (short) (a[i] ^ 0xc7);\n+    }\n+  }\n","filename":"test\/hotspot\/jtreg\/compiler\/codegen\/TestShortVect.java","additions":136,"deletions":1,"binary":false,"changes":137,"status":"modified"}]}