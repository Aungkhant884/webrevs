{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -413,7 +414,2 @@\n-  union {\n-    jdouble double_value;\n-    uint64_t double_bits;\n-  };\n-\n-  double_value = d;\n-  return double_bits;\n+    \/\/ This matches with Template #5  of cast<To>(From).\n+    return PrimitiveConversions::cast<uint64_t>(d);\n@@ -502,6 +498,3 @@\n-  union {\n-    unsigned ival;\n-    float val;\n-  };\n-  ival = fp_immediate_for_encoding(value, 0);\n-  return val;\n+  unsigned ival = fp_immediate_for_encoding(value, 0);\n+  \/\/ This matches with Template #5 of cast<To>(From).\n+  return PrimitiveConversions::cast<float>(ival);\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":7,"deletions":14,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +30,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -390,6 +392,0 @@\n-  union {\n-    float fpval;\n-    double dpval;\n-    uint64_t val;\n-  };\n-\n@@ -401,1 +397,1 @@\n-  fpval = (16.0 + f) \/ 16.0;\n+  float fpval = (16.0 + f) \/ 16.0;\n@@ -419,1 +415,3 @@\n-    dpval = (double)fpval;\n+    double dpval = (double)fpval;\n+    \/\/ This matches with Template #5 of cast<To>(From).\n+    return PrimitiveConversions::cast<uint64_t>(dpval);\n@@ -421,1 +419,2 @@\n-  return val;\n+  \/\/ This matches with Template #6 of cast<To>(From).\n+  return PrimitiveConversions::cast<uint64_t>(fpval);\n@@ -433,6 +432,2 @@\n-\n-  union {\n-    float fpval;\n-    uint32_t val;\n-  };\n-  fpval = immediate;\n+  \/\/ This matches with Template #5 of cast<To>(From).\n+  uint32_t val = PrimitiveConversions::cast<uint32_t>(immediate);\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":10,"deletions":15,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -282,1 +282,2 @@\n-      _num.val = v;\n+      \/\/ This matches with Template #5 of cast<To>(From).\n+     _num_bits = PrimitiveConversions::cast<unsigned int>(v);\n@@ -285,4 +286,4 @@\n-    virtual unsigned int f_hi4() const { return (_num.bits << 9) >> (19+9); }\n-    virtual bool f_lo_is_null() const { return (_num.bits & ((1 << 19) - 1)) == 0; }\n-    virtual int e() const { return ((_num.bits << 1) >> (23+1)) - 127; }\n-    virtual unsigned int s() const { return _num.bits >> 31; }\n+    virtual unsigned int f_hi4() const { return (_num_bits << 9) >> (19+9); }\n+    virtual bool f_lo_is_null() const { return (_num_bits & ((1 << 19) - 1)) == 0; }\n+    virtual int e() const { return ((_num_bits << 1) >> (23+1)) - 127; }\n+    virtual unsigned int s() const { return _num_bits >> 31; }\n@@ -291,4 +292,1 @@\n-    union {\n-      float val;\n-      unsigned int bits;\n-    } _num;\n+    unsigned int _num_bits;\n@@ -300,1 +298,2 @@\n-      _num.val = v;\n+      \/\/ This matches with Template #5 of cast<To>(From).\n+      _num_bits = PrimitiveConversions::cast<unsigned long long>(v);\n@@ -303,4 +302,4 @@\n-    virtual unsigned int f_hi4() const { return (_num.bits << 12) >> (48+12); }\n-    virtual bool f_lo_is_null() const { return (_num.bits & ((1LL << 48) - 1)) == 0; }\n-    virtual int e() const { return ((_num.bits << 1) >> (52+1)) - 1023; }\n-    virtual unsigned int s() const { return _num.bits >> 63; }\n+    virtual unsigned int f_hi4() const { return (_num_bits << 12) >> (48+12); }\n+    virtual bool f_lo_is_null() const { return (_num_bits & ((1LL << 48) - 1)) == 0; }\n+    virtual int e() const { return ((_num_bits << 1) >> (52+1)) - 1023; }\n+    virtual unsigned int s() const { return _num_bits >> 63; }\n@@ -309,4 +308,1 @@\n-    union {\n-      double val;\n-      unsigned long long bits;\n-    } _num;\n+    unsigned long long _num_bits;\n","filename":"src\/hotspot\/cpu\/arm\/assembler_arm.hpp","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -676,5 +677,0 @@\n-  union {\n-    jfloat f;\n-    jint i;\n-  } accessor;\n-  accessor.f = c;\n@@ -684,1 +680,2 @@\n-  emit_int32(accessor.i);\n+  \/\/ This matches with Template #5 of cast<To>(From).\n+  emit_int32(PrimitiveConversions::cast<jint>(c));\n@@ -690,5 +687,0 @@\n-  union {\n-    jdouble d;\n-    jint i[2];\n-  } accessor;\n-  accessor.d = c;\n@@ -698,2 +690,4 @@\n-  emit_int32(accessor.i[0]);\n-  emit_int32(accessor.i[1]);\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  jint *accessor = PrimitiveConversions::cast<jint*>(&c);\n+  emit_int32(accessor[0]);\n+  emit_int32(accessor[1]);\n","filename":"src\/hotspot\/cpu\/arm\/macroAssembler_arm.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/globalJavaValue.hpp\"\n","filename":"src\/hotspot\/share\/code\/compressedStream.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -130,7 +131,1 @@\n-  union {\n-    bool bool_value;\n-    intx intx_value;\n-    uintx uintx_value;\n-    double double_value;\n-    ccstr ccstr_value;\n-  } _u;\n+  int64_t _u_value;\n@@ -141,1 +136,1 @@\n-      memset(&_u, 0, sizeof(_u));\n+      _u_value = 0;\n@@ -162,1 +157,3 @@\n-  template<typename T> T value();\n+  template<typename T> T value() {\n+    return PrimitiveConversions::cast<T>(_u_value);\n+  }\n@@ -170,34 +167,6 @@\n-template<> intx TypedMethodOptionMatcher::value<intx>() {\n-  return _u.intx_value;\n-}\n-\n-template<> uintx TypedMethodOptionMatcher::value<uintx>() {\n-  return _u.uintx_value;\n-}\n-\n-template<> bool TypedMethodOptionMatcher::value<bool>() {\n-  return _u.bool_value;\n-}\n-\n-template<> double TypedMethodOptionMatcher::value<double>() {\n-  return _u.double_value;\n-}\n-\n-template<> ccstr TypedMethodOptionMatcher::value<ccstr>() {\n-  return _u.ccstr_value;\n-}\n-\n-template<> void TypedMethodOptionMatcher::set_value(intx value) {\n-  _u.intx_value = value;\n-}\n-\n-template<> void TypedMethodOptionMatcher::set_value(uintx value) {\n-  _u.uintx_value = value;\n-}\n-\n-template<> void TypedMethodOptionMatcher::set_value(double value) {\n-  _u.double_value = value;\n-}\n-\n-template<> void TypedMethodOptionMatcher::set_value(bool value) {\n-  _u.bool_value = value;\n+  template<> ccstr TypedMethodOptionMatcher::value<ccstr>() {\n+    \/\/ There is no Template in cast<to>(From) for this case.\n+    return (ccstr)(_u_value);\n+  }\n+template<typename T> void TypedMethodOptionMatcher::set_value(T value) {\n+  _u_value = PrimitiveConversions::cast<int64_t>(value);\n@@ -207,1 +176,1 @@\n-  _u.ccstr_value = (const ccstr)os::strdup_check_oom(value);\n+  _u_value = (int64_t)(const ccstr)os::strdup_check_oom(value);\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":13,"deletions":44,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"  \/\/ Just for definition of uint.\n","filename":"src\/hotspot\/share\/gc\/g1\/g1GCPauseType.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-class JavaValue;\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaCall.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -706,6 +707,0 @@\n-  union {\n-      jlong l;\n-      jdouble d;\n-      jfloat f;\n-  } uu;\n-  uu.l = value;\n@@ -718,1 +713,1 @@\n-    case 'F': tty->print(\"%f\", uu.f); break;\n+    case 'F': tty->print(\"%f\", PrimitiveConversions::cast<jfloat>(value)); break; \/\/ This matches with Template #6 of cast<To>(from).\n@@ -720,1 +715,1 @@\n-    case 'D': tty->print(\"%lf\", uu.d); break;\n+    case 'D': tty->print(\"%lf\", PrimitiveConversions::cast<jdouble>(value)); break;\/\/ This matches with Template #5 of cast<To>(From).\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,2 @@\n-#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/globalDefinitionsForConversions.hpp\"\n+#include <cstdint>\n@@ -35,0 +36,14 @@\n+  \/\/ True if type T is pointer to an integral\n+  template<typename T>\n+  static constexpr bool is_integral_pointer() {\n+    typedef T T_t;\n+    typedef typename std::remove_pointer<T_t>::type T_Points_To_t; \/\/ The type that T points to.\n+    return std::is_pointer<T>::value && std::is_integral<T_Points_To_t>::value;\n+  }\n+  \/\/ True if type is pointer to floating point\n+  template<typename T>\n+  static constexpr bool is_float_pointer() {\n+    typedef T T_t;\n+    typedef typename std::remove_pointer<T_t>::type T_Points_To_t; \/\/ The type that T points to.\n+    return std::is_pointer<T>::value && std::is_floating_point<T_Points_To_t>::value;\n+  }\n@@ -59,0 +74,2 @@\n+  \/\/\n+  \/\/ Template #1\n@@ -69,0 +86,2 @@\n+  \/\/\n+  \/\/ Template #2\n@@ -76,0 +95,2 @@\n+  \/\/\n+  \/\/ Template #3\n@@ -85,0 +106,2 @@\n+  \/\/\n+  \/\/ Template #4\n@@ -99,0 +122,2 @@\n+  \/\/\n+  \/\/ Template #5\n@@ -108,0 +133,47 @@\n+  \/\/ integral -> floating point, floating point -> integral where sizes are not the same.\n+  \/\/ To be able to use cast for floating-point narrowing and widening cases.\n+  \/\/\n+  \/\/ Template #6\n+  template<typename To, typename From,\n+           ENABLE_IF((sizeof(To) != sizeof(From))),\n+           ENABLE_IF(std::is_integral<To>::value || std::is_integral<From>::value),\n+           ENABLE_IF(std::is_floating_point<To>::value ||\n+                     std::is_floating_point<From>::value)>\n+  static To cast(From x) {\n+    union { From from; To to; } converter = { x };\n+    return converter.to;\n+  }\n+\n+  \/\/ integral <-> integral with different sizes.\n+  \/\/ To be able to use cast for integral narrowing and widening cases.\n+  \/\/\n+  \/\/ Template #7\n+  template<typename To, typename From,\n+           ENABLE_IF((sizeof(To) != sizeof(From))),\n+           ENABLE_IF(std::is_integral<To>::value && std::is_integral<From>::value)>\n+  static To cast(From x) {\n+    return (To)(x);\n+  }\n+\n+  \/\/ pointer to integral <-> pointer to floating point\n+  \/\/ To be able to use cast for \"int* <-> float*\" casts.\n+  \/\/\n+  \/\/ Template #8\n+  template<typename To, typename From,\n+           ENABLE_IF(is_integral_pointer<To>() || is_integral_pointer<From>()),\n+           ENABLE_IF(is_float_pointer<To>() || is_float_pointer<From>())>\n+  static To cast(From x) {\n+    return reinterpret_cast<To>(x);\n+  }\n+  \/\/ In arm32 targets, 'long long' type is casted as a reference passed in to this method.\n+  \/\/ Explicitly, the case is jobject JavaValue::get_jobject() where calls cast<jobject>(const JavaCallValue&)\n+  \/\/ Use reinterpret_cast, so no constexpr support.\n+  \/\/\n+  \/\/ Template #9\n+  template<typename To, typename From,\n+           ENABLE_IF((std::is_pointer<To>::value)),\n+           ENABLE_IF((std::is_reference<From>::value))>\n+  static To cast(From x) {\n+    return reinterpret_cast<To>(x);\n+  }\n+\n","filename":"src\/hotspot\/share\/metaprogramming\/primitiveConversions.hpp","additions":74,"deletions":2,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"utilities\/globalJavaValue.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -240,3 +241,3 @@\n-  union { jfloat f; juint i; } xbits, ybits;\n-  xbits.f = x;\n-  ybits.f = y;\n+  \/\/ These casts match with Template #5 of cast<To>(From).\n+  juint xbits_i = PrimitiveConversions::cast<juint>(x);\n+  juint ybits_i = PrimitiveConversions::cast<juint>(y);\n@@ -244,2 +245,2 @@\n-  if (((xbits.i & float_sign_mask) != float_infinity) &&\n-       ((ybits.i & float_sign_mask) == float_infinity) ) {\n+  if (((xbits_i & float_sign_mask) != float_infinity) &&\n+       ((ybits_i & float_sign_mask) == float_infinity) ) {\n@@ -257,3 +258,3 @@\n-  union { jdouble d; julong l; } xbits, ybits;\n-  xbits.d = x;\n-  ybits.d = y;\n+  \/\/ These casts match with Template #5 of cast<To>(From).\n+  julong xbits_l = PrimitiveConversions::cast<julong>(x);\n+  julong ybits_l = PrimitiveConversions::cast<julong>(y);\n@@ -261,2 +262,2 @@\n-  if (((xbits.l & double_sign_mask) != double_infinity) &&\n-       ((ybits.l & double_sign_mask) == double_infinity) ) {\n+  if (((xbits_l & double_sign_mask) != double_infinity) &&\n+       ((ybits_l & double_sign_mask) == double_infinity) ) {\n@@ -450,3 +451,2 @@\n-  union {jfloat f; jint i;} bits;\n-  bits.f = x;\n-  jint doppel = bits.i;\n+  \/\/ This matches with Template #5 of cast<To>(From).\n+  jint doppel = PrimitiveConversions::cast<jint>(x);\n@@ -503,1 +503,0 @@\n-  union {jfloat f; jint i;} bits;\n@@ -521,2 +520,2 @@\n-      bits.i = 0x7f800000;\n-      return sign * bits.f;\n+      \/\/ This matches with Template #5 of cast<To>(From).\n+      return sign * PrimitiveConversions::cast<jfloat>(0x7f800000);\n@@ -524,3 +523,3 @@\n-      bits.i = (hf_sign_bit << 16) | 0x7f800000 |\n-               (hf_significand_bits << significand_shift);\n-      return bits.f;\n+      \/\/ This matches with Template #5 of cast<To>(From).\n+      return PrimitiveConversions::cast<jfloat>((hf_sign_bit << 16) | 0x7f800000 |\n+                                               (hf_significand_bits << significand_shift));\n@@ -534,4 +533,3 @@\n-  bits.i = (hf_sign_bit << 16) | float_exp_bits |\n-           (hf_significand_bits << significand_shift);\n-\n-  return bits.f;\n+  \/\/ This matches with Template #5 of cast<To>(From).\n+  return PrimitiveConversions::cast<jfloat>((hf_sign_bit << 16) | float_exp_bits |\n+                                            (hf_significand_bits << significand_shift));\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -30,4 +31,0 @@\n-\/\/ Used to access the lower\/higher 32 bits of a double\n-typedef union {\n-    double d;\n-    struct {\n@@ -35,2 +32,2 @@\n-      int lo;\n-      int hi;\n+  #define _Lo 0\n+  #define _Hi 1\n@@ -38,2 +35,2 @@\n-      int hi;\n-      int lo;\n+  #define _Hi 0\n+  #define _Lo 1\n@@ -41,3 +38,0 @@\n-    } split;\n-} DoubleIntConv;\n-\n@@ -45,3 +39,3 @@\n-  DoubleIntConv x;\n-  x.d = d;\n-  return x.split.hi;\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  int *di = PrimitiveConversions::cast<int*>(&d);\n+  return di[_Hi];\n@@ -51,3 +45,3 @@\n-  DoubleIntConv x;\n-  x.d = d;\n-  return x.split.lo;\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  int *di = PrimitiveConversions::cast<int*>(&d);\n+  return di[_Lo];\n@@ -57,4 +51,3 @@\n-  DoubleIntConv conv;\n-  conv.d = *d;\n-  conv.split.hi = high;\n-  *d = conv.d;\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  int *di = PrimitiveConversions::cast<int*>(d);\n+  di[_Hi] = high;\n@@ -64,4 +57,3 @@\n-  DoubleIntConv conv;\n-  conv.d = *d;\n-  conv.split.lo = low;\n-  *d = conv.d;\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  int *di = PrimitiveConversions::cast<int*>(d);\n+  di[_Lo] = low;\n@@ -71,4 +63,5 @@\n-  DoubleIntConv convX;\n-  convX.d = x;\n-  convX.split.hi = (convX.split.hi & 0x7fffffff) | (high(y) & 0x80000000);\n-  return convX.d;\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  int *di = PrimitiveConversions::cast<int*>(&x);\n+  di[_Hi] = (di[_Hi] & 0x7fffffff) | (high(y) & 0x80000000);\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  return *PrimitiveConversions::cast<double*>(di);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntimeMath.hpp","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -152,4 +153,4 @@\n-      union { intptr_t p; jfloat jf; } value;\n-      value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-      value.jf = (jfloat) *(jdouble*) value_addr;\n-      return new StackValue(value.p); \/\/ 64-bit high half is stack junk\n+      intptr_t value_p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n+      jfloat value_jf = (jfloat) *(jdouble*) value_addr;\n+      \/\/ This matches with Template #8 of cast<To>(From).\n+      return new StackValue(*PrimitiveConversions::cast<intptr_t*>(&value_jf)); \/\/ 64-bit high half is stack junk\n@@ -163,4 +164,4 @@\n-      union { intptr_t p; jint ji;} value;\n-      value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-      value.ji = (jint) *(jlong*) value_addr;\n-      return new StackValue(value.p); \/\/ 64-bit high half is stack junk\n+      intptr_t value_p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n+      jint value_ji = (jint) *(jlong*) value_addr;\n+      \/\/ This matches with Template #7 of cast<To>(From).\n+      return new StackValue(PrimitiveConversions::cast<intptr_t>(value_ji)); \/\/ 64-bit high half is stack junk\n@@ -186,4 +187,4 @@\n-      union { intptr_t p; jint ji;} value;\n-      value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-      value.ji = *(jint*)value_addr;\n-      return new StackValue(value.p);\n+      intptr_t value_p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n+      jint value_ji = *(jint*)value_addr;\n+      \/\/ This matches with Template #7 of cast<To>(From).\n+      return new StackValue(PrimitiveConversions::cast<intptr_t>(value_ji));\n@@ -215,4 +216,4 @@\n-    union { intptr_t p; double d; } value;\n-    value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-    value.d = ((ConstantDoubleValue *)sv)->value();\n-    return new StackValue(value.p);\n+    intptr_t value_p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n+    jdouble value_jd = ((ConstantDoubleValue *)sv)->value();\n+    \/\/ This matches with Template #5 of cast<To>(From).\n+    return new StackValue(PrimitiveConversions::cast<intptr_t>(value_jd));\n@@ -221,4 +222,4 @@\n-    union { intptr_t p; jlong jl; } value;\n-    value.p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n-    value.jl = ((ConstantLongValue *)sv)->value();\n-    return new StackValue(value.p);\n+    intptr_t value_p = (intptr_t) CONST64(0xDEADDEAFDEADDEAF);\n+    jlong value_jl = ((ConstantLongValue *)sv)->value();\n+    \/\/ This matches with Template #1 of cast<To>(From).\n+    return new StackValue(PrimitiveConversions::cast<intptr_t>(value_jl));\n","filename":"src\/hotspot\/share\/runtime\/stackValue.cpp","additions":22,"deletions":21,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n@@ -64,4 +65,0 @@\n-  union {\n-    jdouble jd;\n-    jint    array[2];\n-  } value;\n@@ -70,3 +67,5 @@\n-  value.array[0] = at(slot+1)->get_int();\n-  value.array[1] = at(slot  )->get_int();\n-  return value.jd;\n+  jint value_array[2] ;\n+  value_array[0] = at(slot+1)->get_int();\n+  value_array[1] = at(slot  )->get_int();\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  return *PrimitiveConversions::cast<jdouble *>(value_array);\n@@ -85,0 +84,1 @@\n+\n@@ -86,4 +86,0 @@\n-  union {\n-    jlong jl;\n-    jint  array[2];\n-  } x;\n@@ -92,3 +88,5 @@\n-  x.jl = value;\n-  at(slot+1)->set_int(x.array[0]);\n-  at(slot+0)->set_int(x.array[1]);\n+  \/\/ In arm32 bit builds, no cast<To>(From) can be found by compiler.\n+  \/\/ So it is not possible to use jint *x_array = PrimitiveConversions::cast<jint*>(&value);\n+  jint *x_array = (jint*)(&value);\n+  at(slot+1)->set_int(x_array[0]);\n+  at(slot+0)->set_int(x_array[1]);\n@@ -121,4 +119,0 @@\n-  union {\n-    jdouble jd;\n-    jint    array[2];\n-  } x;\n@@ -127,3 +121,5 @@\n-  x.jd = value;\n-  at(slot+1)->set_int(x.array[0]);\n-  at(slot+0)->set_int(x.array[1]);\n+  \/\/ This matches with Template #8 of cast<To>(From).\n+  \/\/ Note: It was expected that this cast can also be used for set_long_at() above.\n+  jint *x_array = PrimitiveConversions::cast<jint*>(&value);\n+  at(slot+1)->set_int(x_array[0]);\n+  at(slot+0)->set_int(x_array[1]);\n","filename":"src\/hotspot\/share\/runtime\/stackValueCollection.cpp","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/globalJavaValue.hpp\"\n@@ -37,0 +38,1 @@\n+\n@@ -660,21 +662,0 @@\n-\/\/----------------------------------------------------------------------------------------------------\n-\/\/ Special casts\n-\/\/ Cast floats into same-size integers and vice-versa w\/o changing bit-pattern\n-typedef union {\n-  jfloat f;\n-  jint i;\n-} FloatIntConv;\n-\n-typedef union {\n-  jdouble d;\n-  jlong l;\n-  julong ul;\n-} DoubleLongConv;\n-\n-inline jint    jint_cast    (jfloat  x)  { return ((FloatIntConv*)&x)->i; }\n-inline jfloat  jfloat_cast  (jint    x)  { return ((FloatIntConv*)&x)->f; }\n-\n-inline jlong   jlong_cast   (jdouble x)  { return ((DoubleLongConv*)&x)->l;  }\n-inline julong  julong_cast  (jdouble x)  { return ((DoubleLongConv*)&x)->ul; }\n-inline jdouble jdouble_cast (jlong   x)  { return ((DoubleLongConv*)&x)->d;  }\n-\n@@ -707,28 +688,0 @@\n-\/\/ NOTE: replicated in SA in vm\/agent\/sun\/jvm\/hotspot\/runtime\/BasicType.java\n-enum BasicType {\n-\/\/ The values T_BOOLEAN..T_LONG (4..11) are derived from the JVMS.\n-  T_BOOLEAN     = JVM_T_BOOLEAN,\n-  T_CHAR        = JVM_T_CHAR,\n-  T_FLOAT       = JVM_T_FLOAT,\n-  T_DOUBLE      = JVM_T_DOUBLE,\n-  T_BYTE        = JVM_T_BYTE,\n-  T_SHORT       = JVM_T_SHORT,\n-  T_INT         = JVM_T_INT,\n-  T_LONG        = JVM_T_LONG,\n-  \/\/ The remaining values are not part of any standard.\n-  \/\/ T_OBJECT and T_VOID denote two more semantic choices\n-  \/\/ for method return values.\n-  \/\/ T_OBJECT and T_ARRAY describe signature syntax.\n-  \/\/ T_ADDRESS, T_METADATA, T_NARROWOOP, T_NARROWKLASS describe\n-  \/\/ internal references within the JVM as if they were Java\n-  \/\/ types in their own right.\n-  T_OBJECT      = 12,\n-  T_ARRAY       = 13,\n-  T_VOID        = 14,\n-  T_ADDRESS     = 15,\n-  T_NARROWOOP   = 16,\n-  T_METADATA    = 17,\n-  T_NARROWKLASS = 18,\n-  T_CONFLICT    = 19, \/\/ for stack value type with conflicting contents\n-  T_ILLEGAL     = 99\n-};\n@@ -884,56 +837,0 @@\n-\/\/ JavaValue serves as a container for arbitrary Java values.\n-\n-class JavaValue {\n-\n- public:\n-  typedef union JavaCallValue {\n-    jfloat   f;\n-    jdouble  d;\n-    jint     i;\n-    jlong    l;\n-    jobject  h;\n-    oopDesc* o;\n-  } JavaCallValue;\n-\n- private:\n-  BasicType _type;\n-  JavaCallValue _value;\n-\n- public:\n-  JavaValue(BasicType t = T_ILLEGAL) { _type = t; }\n-\n-  JavaValue(jfloat value) {\n-    _type    = T_FLOAT;\n-    _value.f = value;\n-  }\n-\n-  JavaValue(jdouble value) {\n-    _type    = T_DOUBLE;\n-    _value.d = value;\n-  }\n-\n- jfloat get_jfloat() const { return _value.f; }\n- jdouble get_jdouble() const { return _value.d; }\n- jint get_jint() const { return _value.i; }\n- jlong get_jlong() const { return _value.l; }\n- jobject get_jobject() const { return _value.h; }\n- oopDesc* get_oop() const { return _value.o; }\n- JavaCallValue* get_value_addr() { return &_value; }\n- BasicType get_type() const { return _type; }\n-\n- void set_jfloat(jfloat f) { _value.f = f;}\n- void set_jdouble(jdouble d) { _value.d = d;}\n- void set_jint(jint i) { _value.i = i;}\n- void set_jlong(jlong l) { _value.l = l;}\n- void set_jobject(jobject h) { _value.h = h;}\n- void set_oop(oopDesc* o) { _value.o = o;}\n- void set_type(BasicType t) { _type = t; }\n-\n- jboolean get_jboolean() const { return (jboolean) (_value.i);}\n- jbyte get_jbyte() const { return (jbyte) (_value.i);}\n- jchar get_jchar() const { return (jchar) (_value.i);}\n- jshort get_jshort() const { return (jshort) (_value.i);}\n-\n-};\n-\n-\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":106,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_GLOBALDEFINITIONSFORCONVERSIONS_HPP\n+#define SHARE_UTILITIES_GLOBALDEFINITIONSFORCONVERSIONS_HPP\n+\n+#include \"utilities\/compilerWarnings.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ Get constants like JVM_T_CHAR and JVM_SIGNATURE_INT, before pulling in <jvm.h>.\n+#include \"classfile_constants.h\"\n+\n+#include COMPILER_HEADER(utilities\/globalDefinitions)\n+\n+\n+#include <cstddef>\n+#include <type_traits>\n+#endif \/\/ SHARE_UTILITIES_GLOBALDEFINITIONSFORCONVERSIONS_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitionsForConversions.hpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_GLOBALJAVAVALUE_HPP\n+#define SHARE_UTILITIES_GLOBALJAVAVALUE_HPP\n+\n+\n+#include \"metaprogramming\/primitiveConversions.hpp\"\n+#include \"utilities\/compilerWarnings.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+\/\/ Get constants like JVM_T_CHAR and JVM_SIGNATURE_INT, before pulling in <jvm.h>.\n+#include \"classfile_constants.h\"\n+\n+#include COMPILER_HEADER(utilities\/globalDefinitions)\n+\n+#include <cstddef>\n+#include <type_traits>\n+\n+\/\/ NOTE: replicated in SA in vm\/agent\/sun\/jvm\/hotspot\/runtime\/BasicType.java\n+enum BasicType {\n+\/\/ The values T_BOOLEAN..T_LONG (4..11) are derived from the JVMS.\n+  T_BOOLEAN     = JVM_T_BOOLEAN,\n+  T_CHAR        = JVM_T_CHAR,\n+  T_FLOAT       = JVM_T_FLOAT,\n+  T_DOUBLE      = JVM_T_DOUBLE,\n+  T_BYTE        = JVM_T_BYTE,\n+  T_SHORT       = JVM_T_SHORT,\n+  T_INT         = JVM_T_INT,\n+  T_LONG        = JVM_T_LONG,\n+  \/\/ The remaining values are not part of any standard.\n+  \/\/ T_OBJECT and T_VOID denote two more semantic choices\n+  \/\/ for method return values.\n+  \/\/ T_OBJECT and T_ARRAY describe signature syntax.\n+  \/\/ T_ADDRESS, T_METADATA, T_NARROWOOP, T_NARROWKLASS describe\n+  \/\/ internal references within the JVM as if they were Java\n+  \/\/ types in their own right.\n+  T_OBJECT      = 12,\n+  T_ARRAY       = 13,\n+  T_VOID        = 14,\n+  T_ADDRESS     = 15,\n+  T_NARROWOOP   = 16,\n+  T_METADATA    = 17,\n+  T_NARROWKLASS = 18,\n+  T_CONFLICT    = 19, \/\/ for stack value type with conflicting contents\n+  T_ILLEGAL     = 99\n+};\n+\n+\n+\/\/ JavaValue serves as a container for arbitrary Java values.\n+class JavaValue {\n+\n+ public:\n+  \/\/ Define it large enough to hold all possible primitive types.\n+  typedef long long JavaCallValue;\n+\n+ private:\n+  BasicType _type;\n+  JavaCallValue _value;\n+\n+ public:\n+  JavaValue(BasicType t = T_ILLEGAL) { _type = t; }\n+\n+  JavaValue(jfloat value) {\n+    _type    = T_FLOAT;\n+    \/\/ This matches with Template #6 of cast<To>(From).\n+    _value = PrimitiveConversions::cast<JavaCallValue>(value);\n+  }\n+\n+  JavaValue(jdouble value) {\n+    _type    = T_DOUBLE;\n+    \/\/ This matches with Template #5 of cast<To>(From).\n+    _value = PrimitiveConversions::cast<JavaCallValue>(value);\n+  }\n+\n+ jfloat get_jfloat() const    { return PrimitiveConversions::cast<jfloat>(_value);  } \/\/ Tempalte #6.\n+ jdouble get_jdouble() const  { return PrimitiveConversions::cast<jdouble>(_value); } \/\/ Tempalte #5.\n+ jint get_jint() const        { return PrimitiveConversions::cast<jint>(_value);    } \/\/ Tempalte #7.\n+ jlong get_jlong() const      { return PrimitiveConversions::cast<jlong>(_value);   } \/\/ Tempalte #1.\n+ jobject get_jobject() const {\n+  #ifdef ARM32\n+    \/\/ In arm32 archs, this call compiles to cast<jobject>(const JavaCallValue&) and\n+    \/\/ does not match with any of the cast<To>(From) instances.\n+    return *(jobject*)(&_value);\n+  #else\n+    return PrimitiveConversions::cast<jobject>(_value);\n+  #endif\n+ }\n+ oopDesc* get_oop() const     {\n+  #ifdef ARM32\n+    \/\/ In arm32 archs, this call compiles to cast<oopDesc*>(const JavaCallValue&) and\n+    \/\/ does not match with any of the cast<To>(From) instances.\n+    return (oopDesc*)(&_value);\n+  #else\n+    \/\/ This matches with Template #4 of cast<To>(From).\n+    return PrimitiveConversions::cast<oopDesc*>(_value);\n+  #endif\n+ }\n+\n+ JavaCallValue* get_value_addr() { return &_value; }\n+ BasicType get_type() const { return _type; }\n+\n+ void set_jfloat(jfloat f)   { _value = PrimitiveConversions::cast<JavaCallValue>(f); } \/\/ Tempalte #6.\n+ void set_jdouble(jdouble d) { _value = PrimitiveConversions::cast<JavaCallValue>(d); } \/\/ Tempalte #5.\n+ void set_jint(jint i)       { _value = PrimitiveConversions::cast<JavaCallValue>(i); } \/\/ Tempalte #7.\n+ void set_jlong(jlong l)     { _value = PrimitiveConversions::cast<JavaCallValue>(l); } \/\/ Tempalte #1.\n+ void set_jobject(jobject h) {\n+  #ifdef ARM32\n+    \/\/ In arm32 archs, this call compiles to cast<JavaCallValue>(_jobject*&) and\n+    \/\/ does not match with any of the cast<To>(From) instances.\n+    _value = *(JavaCallValue*)h;\n+  #else\n+    _value = PrimitiveConversions::cast<JavaCallValue>(h);\n+  #endif\n+ }\n+ void set_oop(oopDesc* o)    {\n+  #ifdef ARM32\n+    \/\/ In arm32 archs, this call compiles to cast<JavaCallValue>(oopDesc*&) and\n+    \/\/ does not match with any of the cast<To>(From) instances.\n+    _value = *(JavaCallValue*)o;\n+  #else\n+    _value = PrimitiveConversions::cast<JavaCallValue>(o);\n+  #endif\n+ }\n+ void set_type(BasicType t) { _type = t; }\n+\n+ jboolean get_jboolean() const { return PrimitiveConversions::cast<jboolean>(PrimitiveConversions::cast<jint>(_value)); } \/\/ Tempalte #7.\n+ jbyte get_jbyte() const       { return PrimitiveConversions::cast<jbyte>(PrimitiveConversions::cast<jint>(_value));    } \/\/ Tempalte #7.\n+ jchar get_jchar() const       { return PrimitiveConversions::cast<jchar>(PrimitiveConversions::cast<jint>(_value));    } \/\/ Tempalte #7.\n+ jshort get_jshort() const     { return PrimitiveConversions::cast<jshort>(PrimitiveConversions::cast<jint>(_value));   } \/\/ Tempalte #7.\n+\n+};\n+\n+\/\/----------------------------------------------------------------------------------------------------\n+\/\/ Special casts\n+\/\/ Cast floats into same-size integers and vice-versa w\/o changing bit-pattern\n+\n+inline jint    jint_cast    (jfloat  x)  { return PrimitiveConversions::cast<jint>(x);    } \/\/ Template #5 of cast<To>(From).\n+inline jfloat  jfloat_cast  (jint    x)  { return PrimitiveConversions::cast<jfloat>(x);  } \/\/ Tempalte #5\n+\n+inline jlong   jlong_cast   (jdouble x)  { return PrimitiveConversions::cast<jlong>(x);   } \/\/ Tempalte #5\n+inline julong  julong_cast  (jdouble x)  { return PrimitiveConversions::cast<julong>(x);  } \/\/ Tempalte #5\n+inline jdouble jdouble_cast (jlong   x)  { return PrimitiveConversions::cast<jdouble>(x); } \/\/ Tempalte #5\n+#endif \/\/ SHARE_UTILITIES_GLOBALJAVAVALUE_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/utilities\/globalJavaValue.hpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}