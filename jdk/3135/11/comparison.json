{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -1948,0 +1949,1 @@\n+  LogAsyncFlusher::abort();\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -720,0 +721,1 @@\n+    case os::asynclog_thread:\n@@ -1100,0 +1102,1 @@\n+  LogAsyncFlusher::abort();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+void AsyncLogMessage::writeback() {\n+  if (_message != NULL) {\n+    assert(_decorations != NULL, \"sanity check\");\n+    _output.write_blocking(*_decorations, _message);\n+  }\n+}\n+\n+void LogAsyncFlusher::enqueue_impl(const AsyncLogMessage& msg) {\n+  assert_lock_strong(&_lock);\n+\n+  if (_buffer.size() >= _buffer_max_size)  {\n+    const AsyncLogMessage* h = _buffer.front();\n+    assert(h != NULL, \"sanity check\");\n+\n+    if (h->message() != nullptr) {\n+      bool p_created;\n+      uintx* counter = _stats.add_if_absent(h->output(), 0, &p_created);\n+      *counter = *counter + 1;\n+\n+      if (Verbose) {\n+        \/\/ Temporarily turn off SerializeVMOutput so defaultStream will not\n+        \/\/ invoke set_owner(self) for tty_lock.\n+        FlagSetting t(SerializeVMOutput, false);\n+        \/\/ The writing below can not guarantee non-blocking because tty may be piped by the filesystems\n+        \/\/ or throttled by XOFF, so only dump the dropping message in Verbose mode.\n+        tty->print_cr(\"asynclog dropping message: %s\", h->message());\n+      }\n+    }\n+\n+    _buffer.pop_front();\n+  }\n+  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n+\n+  \/\/ notify asynclog thread if occupancy is over 3\/4\n+  size_t sz = _buffer.size();\n+  if (sz > (_buffer_max_size >> 2) * 3 ) {\n+    _lock.notify();\n+  }\n+}\n+\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+  AsyncLogMessage m(output, decorations, msg);\n+\n+  { \/\/ critical area\n+    \/\/ The rank of _lock is same as _tty_lock on purpuse.\n+    \/\/ if logging thread is holding _tty_lock now, temporarily yield to _lock.\n+    ttyUnlocker ttyul;\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    enqueue_impl(m);\n+  }\n+}\n+\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsages.\n+\/\/ the mutex here gurantees its integrity.\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  ttyUnlocker ttyul;\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), msg_iterator.message());\n+    enqueue_impl(m);\n+  }\n+}\n+\n+LogAsyncFlusher::LogAsyncFlusher()\n+  : _state(ThreadState::Running),\n+    _lock(Mutex::tty, \"async-log-monitor\", true \/* allow_vm_block *\/, Mutex::_safepoint_check_never),\n+    _stats(17 \/*table_size*\/) {\n+  if (os::create_thread(this, os::asynclog_thread)) {\n+    os::start_thread(this);\n+  }\n+\n+  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n+                    _buffer_max_size, AsyncLogBufferSize);\n+}\n+\n+bool AsyncLogMapIterator::do_entry(LogFileOutput* output, uintx* counter) {\n+  using dummy = LogTagSetMapping<LogTag::__NO_TAG>;\n+  LogDecorations decorations(LogLevel::Warning, dummy::tagset(), output->decorators());\n+  const int sz = 128;\n+  char out_of_band[sz];\n+\n+  if (*counter > 0) {\n+    jio_snprintf(out_of_band, sz, UINTX_FORMAT_W(6) \" messages dropped...\", *counter);\n+    output->write_blocking(decorations, out_of_band);\n+    *counter = 0;\n+  }\n+\n+  return true;\n+}\n+\n+void LogAsyncFlusher::writeback(const LinkedList<AsyncLogMessage>& logs) {\n+  LinkedListIterator<AsyncLogMessage> it(logs.head());\n+  while (!it.is_empty()) {\n+    AsyncLogMessage* e = it.next();\n+    e->writeback();\n+    e->destroy();\n+  }\n+}\n+\n+void LogAsyncFlusher::flush(bool with_lock) {\n+  LinkedListImpl<AsyncLogMessage, ResourceObj::C_HEAP, mtLogging> logs;\n+\n+  if (with_lock) { \/\/ critical area\n+    \/\/ Caveat: current thread must not hold _tty_lock or other lower rank lockers.\n+    \/\/ Cannot install ttyUnlocker here because flush() may be invoked before defaultStream\n+    \/\/ initialization.\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    _buffer.pop_all(&logs);\n+    AsyncLogMapIterator iter;\n+    _stats.iterate(&iter);\n+  } else {\n+    \/\/ C++ lambda can simplify the code snippet.\n+    _buffer.pop_all(&logs);\n+    AsyncLogMapIterator iter;\n+    _stats.iterate(&iter);\n+  }\n+\n+  writeback(logs);\n+}\n+\n+void LogAsyncFlusher::run() {\n+  while (_state == ThreadState::Running) {\n+    {\n+      MonitorLocker m(&_lock, Mutex::_no_safepoint_check_flag);\n+      m.wait(500 \/* ms, timeout*\/);\n+    }\n+    flush();\n+  }\n+\n+  \/\/ Signal thread has terminated\n+  MonitorLocker ml(Terminator_lock);\n+  _state = ThreadState::Terminated;\n+  ml.notify_all();\n+}\n+\n+LogAsyncFlusher* LogAsyncFlusher::_instance = nullptr;\n+\n+void LogAsyncFlusher::initialize() {\n+  if (!LogConfiguration::is_async_mode()) return;\n+\n+  if (_instance == NULL) {\n+    Atomic::release_store(&LogAsyncFlusher::_instance, new LogAsyncFlusher());\n+  }\n+}\n+\n+\/\/ Termination\n+\/\/ 1. issue an atomic release_store to close the logging window.\n+\/\/ 2. flush itself in-place.\n+\/\/ 3. signal asynclog thread to exit.\n+\/\/ 4. wait until asynclog thread exits.\n+\/\/ 5. (optional) delete this in post_run().\n+void LogAsyncFlusher::terminate() {\n+  if (_instance != NULL) {\n+    LogAsyncFlusher* self = _instance;\n+\n+    Atomic::release_store<LogAsyncFlusher*, LogAsyncFlusher*>(&_instance, nullptr);\n+    self->flush();\n+    {\n+      MonitorLocker ml(&self->_lock, Mutex::_no_safepoint_check_flag);\n+      self->_state = ThreadState::Terminating;\n+      ml.notify();\n+    }\n+    {\n+      MonitorLocker ml(Terminator_lock, Mutex::_no_safepoint_check_flag);\n+      while (self->_state != ThreadState::Terminated) {\n+        ml.wait();\n+      }\n+    }\n+  }\n+}\n+\n+LogAsyncFlusher* LogAsyncFlusher::instance() {\n+  if (Thread::current_or_null() != nullptr) {\n+    return _instance;\n+  } else {\n+    \/\/ current thread may has been detached.\n+    return nullptr;\n+  }\n+}\n+\n+\/\/ Different from terminate(), abort is invoked by os::abort().\n+\/\/ There are 2 constraints:\n+\/\/ 1. must be async-safe because os::abort() may be invoked by a signal handler while other\n+\/\/ threads are executing.\n+\/\/ 2. must not obtain _lock. eg. gtest.MutexRank.mutex_lock_access_leaf(test_mutex_rank.cpp)\n+\/\/ holds a 'assess' lock and then traps SIGSEGV on purpose.\n+\/\/\n+\/\/ Unlike terminate, abort() just ensures all pending log messages are flushed. It doesnot\n+\/\/ exit asynclog thread.\n+void LogAsyncFlusher::abort() {\n+  if (_instance != nullptr) {\n+    \/\/ To meet prior constraints, I borrow the idea in LogConfiguration::disable_outputs(),\n+    \/\/ the following code shut down all outputs for all tagsets with a RCU synchroniziation.\n+    \/\/ After then, I can flush pending queue without a lock.\n+    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+      ts->disable_outputs();\n+    }\n+    _instance->flush(false \/*with_lock*\/);\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_LOGGING_ASYNC_FLUSHER_HPP\n+#define SHARE_LOGGING_ASYNC_FLUSHER_HPP\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logDecorations.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logMessageBuffer.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/linkedlist.hpp\"\n+\n+template <typename E, MEMFLAGS F>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n+ private:\n+  LinkedListNode<E>* _tail;\n+  size_t _size;\n+\n+ public:\n+  LinkedListDeque() : _tail(NULL), _size(0) {}\n+  void push_back(const E& e) {\n+    if (!_tail) {\n+      _tail = this->add(e);\n+    } else {\n+      _tail = this->insert_after(e, _tail);\n+    }\n+\n+    ++_size;\n+  }\n+\n+  void pop_all(LinkedList<E>* logs) {\n+    logs->move(static_cast<LinkedList<E>* >(this));\n+    _tail = NULL;\n+    _size = 0;\n+  }\n+\n+  void pop_front() {\n+    LinkedListNode<E>* h = this->unlink_head();\n+    if (h == _tail) {\n+      _tail = NULL;\n+    }\n+\n+    if (h != NULL) {\n+      --_size;\n+      this->delete_node(h);\n+    }\n+  }\n+\n+  size_t size() const { return _size; }\n+\n+  const E* front() const {\n+    return this->_head == NULL ? NULL : this->_head->peek();\n+  }\n+\n+  const E* back() const {\n+    return _tail == NULL ? NULL : _tail->peek();\n+  }\n+};\n+\n+class AsyncLogMessage {\n+  LogFileOutput&   _output;\n+  LogDecorations*  _decorations;\n+  char*            _message;\n+\n+public:\n+  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, const char* msg)\n+    : _output(output) {\n+    _decorations = new LogDecorations(decorations);\n+      \/\/ allow to fail here, then _message is NULL\n+    _message = os::strdup(msg, mtLogging);\n+  }\n+\n+  void destroy() {\n+    delete _decorations;\n+    _decorations = NULL;\n+\n+    if (_message != NULL) {\n+      os::free(_message);\n+    }\n+  }\n+\n+  void writeback();\n+\n+  \/\/ two AsyncLogMessage are equal if both _output and _message are same.\n+  bool equals(const AsyncLogMessage& o) const {\n+    if (_message == o._message) {\n+      return &_output == &o._output;\n+    } else if (_message == NULL || o._message == NULL) {\n+      return false;\n+    } else {\n+      return &_output == &o._output && !strcmp(_message, o._message);\n+    }\n+  }\n+\n+  const char* message() const { return _message; }\n+  LogFileOutput* output() const { return &_output; }\n+};\n+\n+typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n+typedef KVHashtable<LogFileOutput*, uintx, mtLogging> AsyncLogMap;\n+struct AsyncLogMapIterator {\n+  bool do_entry(LogFileOutput* output, uintx* counter);\n+};\n+\n+class LogAsyncFlusher : public NonJavaThread {\n+ private:\n+  static LogAsyncFlusher* _instance;\n+\n+  enum class ThreadState {\n+    Running = 0,\n+    Terminating,\n+    Terminated\n+  };\n+\n+  volatile ThreadState _state;\n+  \/\/ The semantics of _lock is more like a Java monitor.\n+  \/\/ AssyncLog thread sleeps on _lock until the occupancy of the buffer is over 3\/4, or timeout\n+  \/\/ It also acts as a mutex to consolidate buffer's MT-safety.\n+  Monitor _lock;\n+  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n+  AsyncLogBuffer _buffer;\n+\n+  \/\/ The memory use of each AsyncLogMessage(payload) consist of itself, a logDecoration object\n+  \/\/ and a variable-length c-string message.\n+  \/\/ A normal logging  message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n+  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + sizeof(LogDecorations) + vwrite_buffer_size)};\n+\n+  LogAsyncFlusher();\n+  void enqueue_impl(const AsyncLogMessage& msg);\n+  static void writeback(const LinkedList<AsyncLogMessage>& logs);\n+  void run() override;\n+  void pre_run() override {\n+    NonJavaThread::pre_run();\n+    log_debug(logging, thread)(\"starting AsyncLog Thread tid = \" INTX_FORMAT, os::current_thread_id());\n+  }\n+  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n+\n+ public:\n+  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+  \/\/ Use with_lock = false at your own risk. It is only safe without any active reader.\n+  void flush(bool with_lock = true);\n+\n+  static LogAsyncFlusher* instance();\n+  \/\/ None of following functions are thread-safe.\n+  static void initialize();\n+  static void terminate();\n+  static void abort();\n+};\n+\n+#endif \/\/ SHARE_LOGGING_ASYNC_FLUSHER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -281,0 +282,9 @@\n+  \/\/ Handle jcmd VM.log disable\n+  \/\/ ts->disable_outputs() above deletes output_list with RCU synchronization.\n+  \/\/ Therefore, no new logging entry will enter asynchronous queue after then.\n+  \/\/ flush pending entries before the LogOutput instances die.\n+  LogAsyncFlusher* async = LogAsyncFlusher::instance();\n+  if (async != nullptr) {\n+    async->flush(false \/* with_lock *\/);\n+  }\n+\n@@ -545,0 +555,6 @@\n+  out->print_cr(\"\\nAsynchronous logging(off by default):\");\n+  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\"  All log messages write to an intermediate buffer first and then will be flushed\"\n+                \" to the corresponding log outputs by a standalone thread. Write operations at logsites are\"\n+                \" guaranteed non-blocking.\");\n+  out->cr();\n@@ -587,0 +603,4 @@\n+\n+  out->print_cr(\" -Xlog:async -Xlog:gc=debug:file=gc.log -Xlog:safepoint=trace\");\n+  out->print_cr(\"\\t Write logs asynchronously. Enable messages tagged with 'safepoint' up to 'trace' level to stdout \");\n+  out->print_cr(\"\\t and messages tagged with 'gc' up to 'trace' level to file 'gc.log'.\");\n@@ -613,0 +633,2 @@\n+\n+bool LogConfiguration::_async_mode = false;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-\n+  static bool _async_mode;\n@@ -126,0 +126,5 @@\n+\n+  static bool is_async_mode() { return _async_mode; }\n+  static void set_async_mode(bool value) {\n+    _async_mode = value;\n+  }\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -40,0 +40,20 @@\n+LogDecorations::LogDecorations(const LogDecorations& o)\n+    : _level(o._level), _tagset(o._tagset) {\n+  size_t sz = 0;\n+  for (int i = 0; i < LogDecorators::Count; ++i) {\n+    if (o._decoration_offset[i] != NULL) {\n+      sz += strlen(o._decoration_offset[i]) + 1;\n+    }\n+  }\n+\n+  \/\/ safe to call with sz = 0\n+  memcpy(_decorations_buffer, o._decorations_buffer, sz);\n+  for (int i = 0; i < LogDecorators::Count; ++i) {\n+    if (o._decoration_offset[i] != NULL) {\n+      _decoration_offset[i] = (o._decoration_offset[i] - o._decorations_buffer) + _decorations_buffer;\n+    } else {\n+      _decoration_offset[i] = NULL;\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-class LogDecorations {\n+class LogDecorations : public CHeapObj<mtLogging> {\n@@ -48,0 +48,1 @@\n+  LogDecorations& operator=(const LogDecorations& o) = delete;\n@@ -50,0 +51,1 @@\n+  LogDecorations(const LogDecorations& o);\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  };\n+  }\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -287,6 +288,1 @@\n-int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n+int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n@@ -307,0 +303,15 @@\n+int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (flusher != NULL) {\n+    flusher->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n+\n+  return write_blocking(decorations, msg);\n+}\n+\n@@ -313,0 +324,6 @@\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (flusher != NULL) {\n+    flusher->enqueue(*this, msg_iterator);\n+    return -1;\n+  }\n+\n@@ -464,1 +481,1 @@\n-  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s\", _file_count,\n+  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s,async=%s\", _file_count,\n@@ -466,1 +483,2 @@\n-             proper_unit_for_byte_size(_rotate_size));\n+             proper_unit_for_byte_size(_rotate_size),\n+             LogConfiguration::is_async_mode() ? \"true\" : \"false\");\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+  friend class AsyncLogMessage;\n+  friend struct AsyncLogMapIterator;\n@@ -39,0 +41,1 @@\n+  static const char* const AsyncOptionKey;\n@@ -82,0 +85,1 @@\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -163,0 +163,1 @@\n+extern const size_t vwrite_buffer_size;\n","filename":"src\/hotspot\/share\/logging\/logTagSet.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2748,0 +2748,3 @@\n+      } else if (strcmp(tail, \":async\") == 0) {\n+        LogConfiguration::set_async_mode(true);\n+        ret = true;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,0 +2024,4 @@\n+  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n+          \"Memory budget(in bytes) for the buffer of AsyncLogging. \")       \\\n+          range(100*K, 50*M)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -128,0 +129,1 @@\n+  LogAsyncFlusher::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,0 +442,1 @@\n+    asynclog_thread,   \/\/ dedicated to flushing logs\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -3761,0 +3762,3 @@\n+  \/\/ stop AsyncLog Thread\n+  LogAsyncFlusher::terminate();\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+\/\/     - LogAsyncFlusher\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -287,0 +287,1 @@\n+template class BasicHashtable<mtLogging>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"jvm.h\"\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,248 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logTestFixture.hpp\"\n+#include \"logTestUtils.inline.hpp\"\n+#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"unittest.hpp\"\n+\n+\/\/ So far, shutdown asynclogging on-the-fly can only be done in vmthread.\n+\/\/ Use it only in gtest.\n+class AsyncLogDisabler : public VM_GTestExecuteAtSafepoint {\n+  void doit() override {\n+    LogConfiguration::set_async_mode(false);\n+    LogAsyncFlusher::terminate();\n+  }\n+};\n+\n+class AsyncLogTest : public LogTestFixture {\n+  bool _saved_async_mode;\n+\n+ public:\n+  AsyncLogTest() : _saved_async_mode(LogConfiguration::is_async_mode()) {\n+    LogConfiguration::set_async_mode(true);\n+    LogAsyncFlusher::initialize();\n+  }\n+\n+  ~AsyncLogTest() {\n+    if (!_saved_async_mode) {\n+      AsyncLogDisabler op;\n+      ThreadInVMfromNative invm(JavaThread::current());\n+      VMThread::execute(&op);\n+    }\n+  }\n+};\n+\n+TEST_VM_F(AsyncLogTest, fifo) {\n+  LinkedListDeque<int, mtLogging> fifo;\n+  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n+\n+  fifo.push_back(1);\n+  EXPECT_EQ(fifo.size(), (size_t)1);\n+  EXPECT_EQ(*(fifo.back()), 1);\n+\n+  fifo.pop_all(&result);\n+  EXPECT_EQ(fifo.size(), (size_t)0);\n+  EXPECT_EQ(NULL, fifo.back());\n+  EXPECT_EQ(result.size(), (size_t)1);\n+  EXPECT_EQ(*(result.head()->data()), 1);\n+  result.clear();\n+\n+  fifo.push_back(2);\n+  fifo.push_back(1);\n+  fifo.pop_all(&result);\n+  EXPECT_EQ(result.size(), (size_t)2);\n+  EXPECT_EQ(*(result.head()->data()), 2);\n+  EXPECT_EQ(*(result.head()->next()->data()), 1);\n+  result.clear();\n+  const int N = 1000;\n+  for (int i=0; i<N; ++i) {\n+    fifo.push_back(i);\n+  }\n+  fifo.pop_all(&result);\n+\n+  EXPECT_EQ(result.size(), (size_t)N);\n+  LinkedListIterator<int> it(result.head());\n+  for (int i=0; i<N; ++i) {\n+    int* e = it.next();\n+    EXPECT_EQ(*e, i);\n+  }\n+}\n+\n+TEST_VM_F(AsyncLogTest, deque) {\n+  LinkedListDeque<int, mtLogging> deque;\n+  const int N = 10;\n+\n+  EXPECT_EQ(NULL, deque.front());\n+  EXPECT_EQ(NULL, deque.back());\n+  for (int i = 0; i < N; ++i) {\n+    deque.push_back(i);\n+  }\n+\n+  EXPECT_EQ(*(deque.front()), 0);\n+  EXPECT_EQ(*(deque.back()), N-1);\n+  EXPECT_EQ(deque.size(), (size_t)N);\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)(N - 1));\n+  EXPECT_EQ(*(deque.front()), 1);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)(N - 2));\n+  EXPECT_EQ(*(deque.front()), 2);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+\n+\n+  for (int i=2; i < N-1; ++i) {\n+    deque.pop_front();\n+  }\n+  EXPECT_EQ(deque.size(), (size_t)1);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+  EXPECT_EQ(deque.front(), deque.back());\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)0);\n+}\n+\n+class VM_TestFlusher: public VM_GTestExecuteAtSafepoint {\n+public:\n+  void doit() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n+\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n+\n+    test_asynclog_raw();\n+  }\n+\n+  void test_asynclog_raw() {\n+    Log(logging) logger;\n+#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n+LOG_LEVEL_LIST\n+#undef LOG_LEVEL\n+\n+    LogTarget(Trace, logging) t;\n+    LogTarget(Debug, logging) d;\n+    EXPECT_FALSE(t.is_enabled());\n+    EXPECT_TRUE(d.is_enabled());\n+\n+    d.print(\"AsyncLogTarget.print = %d\", 1);\n+    log_trace(logging)(\"log_trace-test\");\n+    log_debug(logging)(\"log_debug-test\");\n+  }\n+};\n+\n+TEST_VM_F(AsyncLogTest, asynclog) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  {\n+    VM_TestFlusher op;\n+    ThreadInVMfromNative invm(JavaThread::current());\n+    VMThread::execute(&op);\n+  }\n+  flusher->flush();\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, logMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+\n+  const int MULTI_LINES = 20;\n+  {\n+\n+    LogMessage(logging) msg;\n+    Log(logging) logger;\n+\n+    for (int i = 0; i < MULTI_LINES; ++i) {\n+      msg.debug(\"nonbreakable log message line-%02d\", i);\n+\n+      if (0 == (i % 4)) {\n+        logger.debug(\"a noisy message from other logger\");\n+      }\n+    }\n+    logger.debug(\"a noisy message from other logger\");\n+  }\n+  flusher->flush();\n+\n+  ResourceMark rm;\n+  LogMessageBuffer buffer;\n+  const char* strs[MULTI_LINES + 1];\n+  strs[MULTI_LINES] = NULL;\n+  for (int i = 0; i < MULTI_LINES; ++i) {\n+    stringStream ss;\n+    ss.print_cr(\"nonbreakable log message line-%02d\", i);\n+    strs[i] = ss.as_string();\n+  }\n+  \/\/ check nonbreakable log messages are consecutive\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"a noisy message from other logger\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, droppingMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  const size_t sz = 100;\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  \/\/ shrink async buffer.\n+  AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+  LogMessage(logging) lm;\n+\n+  \/\/ write 100x more messages than its capacity in burst\n+  for (size_t i = 0; i < sz * 100; ++i) {\n+    lm.debug(\"a lot of log...\");\n+  }\n+  lm.flush();\n+  flusher->flush();\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped...\"));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":248,"deletions":0,"binary":false,"changes":248,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,0 +233,19 @@\n+\n+TEST(LogDecorations, copyctor) {\n+  LogDecorators decorator_selection;\n+  ASSERT_TRUE(decorator_selection.parse(\"uptime,tid,level\"));\n+  LogDecorations decorations(LogLevel::Info, tagset, decorator_selection);\n+\n+  const char* saved_tid    = decorations.decoration(LogDecorators::tid_decorator);\n+  const char* saved_uptime = decorations.decoration(LogDecorators::uptime_decorator);\n+  const char* saved_level  = decorations.decoration(LogDecorators::level_decorator);\n+\n+  LogDecorations copy(decorations);\n+  EXPECT_STREQ(saved_tid, copy.decoration(LogDecorators::tid_decorator));\n+  EXPECT_STREQ(saved_uptime, copy.decoration(LogDecorators::uptime_decorator));\n+  \/\/ level is special\n+  EXPECT_EQ(saved_level, copy.decoration(LogDecorators::level_decorator));\n+\n+  EXPECT_EQ(NULL, copy.decoration(LogDecorators::tags_decorator));\n+  EXPECT_EQ(NULL, copy.decoration(LogDecorators::hostname_decorator));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"}]}