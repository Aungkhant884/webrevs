{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -1949,0 +1950,3 @@\n+  \/\/ flush buffered messages\n+  AsyncLogWriter::flush();\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -717,0 +718,1 @@\n+    case os::asynclog_thread:\n@@ -1097,0 +1099,3 @@\n+  \/\/ flush buffered messages\n+  AsyncLogWriter::flush();\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,199 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+Semaphore AsyncLogWriter::_sem(0);\n+\n+class AsyncLogLocker : public StackObj {\n+ private:\n+  debug_only(static intx _locking_thread_id;)\n+  static Semaphore _lock;\n+ public:\n+  AsyncLogLocker() {\n+    _lock.wait();\n+    debug_only(_locking_thread_id = os::current_thread_id());\n+  }\n+\n+  ~AsyncLogLocker() {\n+    debug_only(_locking_thread_id = -1);\n+    _lock.signal();\n+  }\n+};\n+\n+Semaphore AsyncLogLocker::_lock(1);\n+debug_only(intx AsyncLogLocker::_locking_thread_id = -1;)\n+\n+void AsyncLogWriter::enqueue_locked(const AsyncLogMessage& msg) {\n+  if (_buffer.size() >= _buffer_max_size)  {\n+    const AsyncLogMessage* h = _buffer.front();\n+    assert(h != NULL, \"sanity check\");\n+\n+    if (h->message() != nullptr) {\n+      bool p_created;\n+      uint32_t* counter = _stats.add_if_absent(h->output(), 0, &p_created);\n+      *counter = *counter + 1;\n+    }\n+    \/\/ drop the enqueueing message.\n+    return;\n+  }\n+\n+  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n+  _sem.signal();\n+}\n+\n+void AsyncLogWriter::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+  AsyncLogMessage m(output, decorations, os::strdup(msg));\n+\n+  { \/\/ critical area\n+    AsyncLogLocker lock;\n+    enqueue_locked(m);\n+  }\n+}\n+\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsages.\n+\/\/ the mutex here gurantees its integrity.\n+void AsyncLogWriter::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  AsyncLogLocker lock;\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n+    enqueue_locked(m);\n+  }\n+}\n+\n+AsyncLogWriter::AsyncLogWriter()\n+  : _state(ThreadState::NotReady),\n+    _stats(17 \/*table_size*\/) {\n+  if (os::create_thread(this, os::asynclog_thread)) {\n+    _state = ThreadState::Initialized;\n+  }\n+\n+  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n+                    _buffer_max_size, AsyncLogBufferSize);\n+}\n+\n+class AsyncLogMapIterator {\n+  AsyncLogBuffer& _logs;\n+\n+ public:\n+  AsyncLogMapIterator(AsyncLogBuffer& logs) :_logs(logs) {}\n+  bool do_entry(LogFileOutput* output, uint32_t* counter) {\n+    using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+\n+    if (*counter > 0) {\n+      LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+      stringStream ss;\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+      AsyncLogMessage msg(*output, decorations, ss.as_string(true \/*c_heap*\/));\n+      _logs.push_back(msg);\n+      *counter = 0;\n+    }\n+\n+    return true;\n+  }\n+};\n+\n+void AsyncLogWriter::perform_IO() {\n+  \/\/ use kind of copy-and-swap idiom here.\n+  \/\/ Empty 'logs' 'swaps' the content with _buffer.\n+  \/\/ Along with logs destruction, all procceeded messages are deleted.\n+  \/\/\n+  \/\/ the atomic operation 'move' is done in O(1). All I\/O jobs are done without lock.\n+  \/\/ This guarantees I\/O jobs don't block logsites.\n+  AsyncLogBuffer logs;\n+  { \/\/ critical region\n+    AsyncLogLocker ml;\n+    AsyncLogMapIterator dropped_counters_iter(logs);\n+\n+    _buffer.pop_all(&logs);\n+    \/\/ append meta-message of dropped counters\n+    _stats.iterate(&dropped_counters_iter);\n+  }\n+\n+  LinkedListIterator<AsyncLogMessage> it(logs.head());\n+  while (!it.is_empty()) {\n+    AsyncLogMessage* e = it.next();\n+    char* msg = e->message();\n+\n+    if (msg != nullptr) {\n+      e->output()->write_blocking(e->decorations(), msg);\n+      os::free(msg);\n+    }\n+  }\n+}\n+\n+void AsyncLogWriter::run() {\n+  assert(_state == ThreadState::Running, \"sanity check\");\n+\n+  while (_state == ThreadState::Running) {\n+    _sem.wait();\n+    perform_IO();\n+  }\n+\n+  assert(_state == ThreadState::Terminated, \"sanity check\");\n+  perform_IO(); \/\/ in case there are some messages left\n+}\n+\n+AsyncLogWriter* AsyncLogWriter::_instance = nullptr;\n+\n+void AsyncLogWriter::initialize() {\n+  if (!LogConfiguration::is_async_mode()) return;\n+\n+  if (_instance == nullptr) {\n+    AsyncLogWriter* self = new AsyncLogWriter();\n+\n+    if (self->_state == ThreadState::Initialized) {\n+      Atomic::release_store_fence(&AsyncLogWriter::_instance, self);\n+      \/\/ all readers of _instance after fence see NULL,\n+      \/\/ but we still need to ensure no active reader of any tagset.\n+      \/\/ After then, we start AsyncLog Thread and it exclusively takes\n+      \/\/ over all logging I\/O.\n+      for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+        ts->wait_until_no_readers();\n+      }\n+      self->_state = ThreadState::Running;\n+      os::start_thread(self);\n+      log_debug(logging, thread)(\"AsyncLogging starts working.\");\n+    } else {\n+      log_warning(logging, thread)(\"AsyncLogging failed to launch thread. fall back to synchronous logging.\");\n+    }\n+  }\n+}\n+\n+AsyncLogWriter* AsyncLogWriter::instance() {\n+  return _instance;\n+}\n+\n+void AsyncLogWriter::flush() {\n+  if (_instance != nullptr) {\n+    _instance->perform_IO();\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":199,"deletions":0,"binary":false,"changes":199,"status":"added"},{"patch":"@@ -0,0 +1,154 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_LOG_ASYNC_WTRITER_HPP\n+#define SHARE_LOG_ASYNC_WTRITER_HPP\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logDecorations.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logMessageBuffer.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/linkedlist.hpp\"\n+\n+template <typename E, MEMFLAGS F>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n+ private:\n+  LinkedListNode<E>* _tail;\n+  size_t _size;\n+\n+ public:\n+  LinkedListDeque() : _tail(NULL), _size(0) {}\n+  void push_back(const E& e) {\n+    if (!_tail) {\n+      _tail = this->add(e);\n+    } else {\n+      _tail = this->insert_after(e, _tail);\n+    }\n+\n+    ++_size;\n+  }\n+\n+  \/\/ pop all elements to logs.\n+  void pop_all(LinkedList<E>* logs) {\n+    logs->move(static_cast<LinkedList<E>* >(this));\n+    _tail = NULL;\n+    _size = 0;\n+  }\n+\n+  void pop_all(LinkedListDeque<E, F>* logs) {\n+    logs->_size = _size;\n+    logs->_tail = _tail;\n+    pop_all(static_cast<LinkedList<E>* >(logs));\n+  }\n+\n+  void pop_front() {\n+    LinkedListNode<E>* h = this->unlink_head();\n+    if (h == _tail) {\n+      _tail = NULL;\n+    }\n+\n+    if (h != NULL) {\n+      --_size;\n+      this->delete_node(h);\n+    }\n+  }\n+\n+  size_t size() const { return _size; }\n+\n+  const E* front() const {\n+    return this->_head == NULL ? NULL : this->_head->peek();\n+  }\n+\n+  const E* back() const {\n+    return _tail == NULL ? NULL : _tail->peek();\n+  }\n+\n+  LinkedListNode<E>* head() const {\n+    return static_cast<const LinkedList<E>* >(this)->head();\n+  }\n+};\n+\n+class AsyncLogMessage {\n+  LogFileOutput& _output;\n+  const LogDecorations _decorations;\n+  char* _message;\n+\n+public:\n+  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, char* msg)\n+    : _output(output), _decorations(decorations), _message(msg) {}\n+\n+  \/\/ placeholder for LinkedListImpl.\n+  bool equals(const AsyncLogMessage& o) const { return false; }\n+\n+  LogFileOutput* output() const { return &_output; }\n+  const LogDecorations& decorations() const { return _decorations; }\n+  char* message() const { return _message; }\n+};\n+\n+typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n+typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n+\n+class AsyncLogWriter: public NonJavaThread {\n+ private:\n+  static AsyncLogWriter* _instance;\n+  static Semaphore _sem;\n+\n+  enum class ThreadState {\n+    NotReady,\n+    Initialized,\n+    Running,\n+    Terminated,\n+  };\n+\n+  volatile ThreadState _state;\n+  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n+  AsyncLogBuffer _buffer;\n+\n+  \/\/ The memory use of each AsyncLogMessage(payload) consist of itself, a logDecoration object\n+  \/\/ and a variable-length c-string message.\n+  \/\/ A normal logging  message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n+  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + sizeof(LogDecorations) + vwrite_buffer_size)};\n+\n+  AsyncLogWriter();\n+  void enqueue_locked(const AsyncLogMessage& msg);\n+  void perform_IO();\n+  void run() override;\n+  void pre_run() override {\n+    NonJavaThread::pre_run();\n+    log_debug(logging, thread)(\"starting AsyncLog Thread tid = \" INTX_FORMAT, os::current_thread_id());\n+  }\n+  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n+\n+ public:\n+  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+\n+  \/\/ None of following functions are thread-safe.\n+  static AsyncLogWriter* instance();\n+  static void initialize();\n+  static void flush();\n+};\n+\n+#endif \/\/ SHARE_LOG_ASYNC_WTRITER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":154,"deletions":0,"binary":false,"changes":154,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -281,0 +282,6 @@\n+  \/\/ Handle jcmd VM.log disable\n+  \/\/ ts->disable_outputs() above has deleted output_list with RCU synchronization.\n+  \/\/ Therefore, no new logging entry can enter AsyncLog buffer for the time being.\n+  \/\/ flush pending entries before LogOutput instances die.\n+  AsyncLogWriter::flush();\n+\n@@ -548,0 +555,6 @@\n+  out->print_cr(\"\\nAsynchronous logging(off by default):\");\n+  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\"  All log messages write to an intermediate buffer first and then will be flushed\"\n+                \" to the corresponding log outputs by a standalone thread. Write operations at logsites are\"\n+                \" guaranteed non-blocking.\");\n+  out->cr();\n@@ -590,0 +603,4 @@\n+\n+  out->print_cr(\" -Xlog:async -Xlog:gc=debug:file=gc.log -Xlog:safepoint=trace\");\n+  out->print_cr(\"\\t Write logs asynchronously. Enable messages tagged with 'safepoint' up to 'trace' level to stdout \");\n+  out->print_cr(\"\\t and messages tagged with 'gc' up to 'trace' level to file 'gc.log'.\");\n@@ -616,0 +633,2 @@\n+\n+bool LogConfiguration::_async_mode = false;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static bool                       _async_mode;\n@@ -126,0 +127,5 @@\n+\n+  static bool is_async_mode() { return _async_mode; }\n+  static void set_async_mode(bool value) {\n+    _async_mode = value;\n+  }\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  };\n+  }\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -287,6 +288,1 @@\n-int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n+int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n@@ -307,0 +303,15 @@\n+int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, decorations, msg);\n+    return -1;\n+  }\n+\n+  return write_blocking(decorations, msg);\n+}\n+\n@@ -313,0 +324,6 @@\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, msg_iterator);\n+    return -1;\n+  }\n+\n@@ -464,1 +481,1 @@\n-  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s\", _file_count,\n+  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s,async=%s\", _file_count,\n@@ -466,1 +483,2 @@\n-             proper_unit_for_byte_size(_rotate_size));\n+             proper_unit_for_byte_size(_rotate_size),\n+             LogConfiguration::is_async_mode() ? \"true\" : \"false\");\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  void wait_until_no_readers() const;\n@@ -94,0 +93,1 @@\n+  void wait_until_no_readers() const;\n","filename":"src\/hotspot\/share\/logging\/logOutputList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+  void wait_until_no_readers() const {\n+    _output_list.wait_until_no_readers();\n+  }\n+\n@@ -166,0 +170,1 @@\n+extern const size_t vwrite_buffer_size;\n","filename":"src\/hotspot\/share\/logging\/logTagSet.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2750,0 +2750,3 @@\n+      } else if (strcmp(tail, \":async\") == 0) {\n+        LogConfiguration::set_async_mode(true);\n+        ret = true;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1992,0 +1992,5 @@\n+  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n+          \"Memory budget(in bytes) for the buffer of Asynchronous \"         \\\n+          \"Logging (-Xlog:async).\")                                         \\\n+          range(100*K, 50*M)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -126,0 +127,1 @@\n+  AsyncLogWriter::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+    asynclog_thread,   \/\/ dedicated to flushing logs\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+\/\/     - LogAsyncFlusher\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -287,0 +287,1 @@\n+template class BasicHashtable<mtLogging>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+#include \"jvm.h\"\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logTestFixture.hpp\"\n+#include \"logTestUtils.inline.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"unittest.hpp\"\n+\n+class AsyncLogTest : public LogTestFixture {\n+ public:\n+  AsyncLogTest() {\n+    if(!LogConfiguration::is_async_mode()) {\n+      fprintf(stderr, \"Warning: asynclog is OFF.\\n\");\n+    }\n+  }\n+\n+  void test_asynclog_ls() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n+\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n+  }\n+\n+  void test_asynclog_raw() {\n+    Log(logging) logger;\n+#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n+LOG_LEVEL_LIST\n+#undef LOG_LEVEL\n+\n+    LogTarget(Trace, logging) t;\n+    LogTarget(Debug, logging) d;\n+    EXPECT_FALSE(t.is_enabled());\n+    EXPECT_TRUE(d.is_enabled());\n+\n+    d.print(\"AsyncLogTarget.print = %d\", 1);\n+    log_trace(logging)(\"log_trace-test\");\n+    log_debug(logging)(\"log_debug-test\");\n+  }\n+};\n+\n+TEST_VM(AsyncLogBufferTest, fifo) {\n+  LinkedListDeque<int, mtLogging> fifo;\n+  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n+\n+  fifo.push_back(1);\n+  EXPECT_EQ((size_t)1, fifo.size());\n+  EXPECT_EQ(1, *(fifo.back()));\n+\n+  fifo.pop_all(&result);\n+  EXPECT_EQ((size_t)0, fifo.size());\n+  EXPECT_EQ(NULL, fifo.back());\n+  EXPECT_EQ((size_t)1, result.size());\n+  EXPECT_EQ(1, *(result.head()->data()));\n+  result.clear();\n+\n+  fifo.push_back(2);\n+  fifo.push_back(1);\n+  fifo.pop_all(&result);\n+  EXPECT_EQ((size_t)2, result.size());\n+  EXPECT_EQ(2, *(result.head()->data()));\n+  EXPECT_EQ(1, *(result.head()->next()->data()));\n+  result.clear();\n+  const int N = 1000;\n+  for (int i=0; i<N; ++i) {\n+    fifo.push_back(i);\n+  }\n+  fifo.pop_all(&result);\n+\n+  EXPECT_EQ((size_t)N, result.size());\n+  LinkedListIterator<int> it(result.head());\n+  for (int i=0; i<N; ++i) {\n+    int* e = it.next();\n+    EXPECT_EQ(i, *e);\n+  }\n+}\n+\n+TEST_VM(AsyncLogBufferTest, deque) {\n+  LinkedListDeque<int, mtLogging> deque;\n+  const int N = 10;\n+\n+  EXPECT_EQ(NULL, deque.front());\n+  EXPECT_EQ(NULL, deque.back());\n+  for (int i = 0; i < N; ++i) {\n+    deque.push_back(i);\n+  }\n+\n+  EXPECT_EQ(0, *(deque.front()));\n+  EXPECT_EQ(N-1, *(deque.back()));\n+  EXPECT_EQ((size_t)N, deque.size());\n+\n+  deque.pop_front();\n+  EXPECT_EQ((size_t)(N - 1), deque.size());\n+  EXPECT_EQ(1, *(deque.front()));\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+\n+  deque.pop_front();\n+  EXPECT_EQ((size_t)(N - 2), deque.size());\n+  EXPECT_EQ(2, *(deque.front()));\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+\n+\n+  for (int i=2; i < N-1; ++i) {\n+    deque.pop_front();\n+  }\n+  EXPECT_EQ((size_t)1, deque.size());\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+  EXPECT_EQ(deque.back(), deque.front());\n+\n+  deque.pop_front();\n+  EXPECT_EQ((size_t)0, deque.size());\n+}\n+\n+TEST_VM_F(AsyncLogTest, asynclog) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+\n+  test_asynclog_ls();\n+  test_asynclog_raw();\n+  AsyncLogWriter::flush();\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, logMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+\n+  const int MULTI_LINES = 20;\n+  {\n+\n+    LogMessage(logging) msg;\n+    Log(logging) logger;\n+\n+    for (int i = 0; i < MULTI_LINES; ++i) {\n+      msg.debug(\"nonbreakable log message line-%02d\", i);\n+\n+      if (0 == (i % 4)) {\n+        logger.debug(\"a noisy message from other logger\");\n+      }\n+    }\n+    logger.debug(\"a noisy message from other logger\");\n+  }\n+  AsyncLogWriter::flush();\n+\n+  ResourceMark rm;\n+  LogMessageBuffer buffer;\n+  const char* strs[MULTI_LINES + 1];\n+  strs[MULTI_LINES] = NULL;\n+  for (int i = 0; i < MULTI_LINES; ++i) {\n+    stringStream ss;\n+    ss.print_cr(\"nonbreakable log message line-%02d\", i);\n+    strs[i] = ss.as_string();\n+  }\n+  \/\/ check nonbreakable log messages are consecutive\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"a noisy message from other logger\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, droppingMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  const size_t sz = 100;\n+\n+  if (AsyncLogWriter::instance() != nullptr) {\n+    \/\/ shrink async buffer.\n+    AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+    LogMessage(logging) lm;\n+\n+    \/\/ write 100x more messages than its capacity in burst\n+    for (size_t i = 0; i < sz * 100; ++i) {\n+      lm.debug(\"a lot of log...\");\n+    }\n+    lm.flush();\n+    AsyncLogWriter::flush();\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Note: This runs the asynclog parts of gtest in async mode.\n+ * The reason is that hotspot can't safely turn off asynclogging dyanmically.\n+ * There's no TEST_OTHER_VM_F.\n+ *\/\n+\n+\/* @test\n+ * @summary Run asynclog gtest in async mode.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=AsyncLogTest* -Xlog:async\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/AsyncLogGtest.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}