{"files":[{"patch":"@@ -717,0 +717,1 @@\n+    case os::asynclog_thread:\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,194 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+Semaphore AsyncLogWriter::_sem(0);\n+Semaphore AsyncLogWriter::_io_sem(1);\n+\n+class AsyncLogLocker : public StackObj {\n+ private:\n+  static Semaphore _lock;\n+ public:\n+  AsyncLogLocker() {\n+    _lock.wait();\n+  }\n+\n+  ~AsyncLogLocker() {\n+    _lock.signal();\n+  }\n+};\n+\n+Semaphore AsyncLogLocker::_lock(1);\n+\n+void AsyncLogWriter::enqueue_locked(const AsyncLogMessage& msg) {\n+  if (_buffer.size() >= _buffer_max_size)  {\n+    bool p_created;\n+    uint32_t* counter = _stats.add_if_absent(msg.output(), 0, &p_created);\n+    *counter = *counter + 1;\n+    \/\/ drop the enqueueing message.\n+    return;\n+  }\n+\n+  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n+  _sem.signal();\n+}\n+\n+void AsyncLogWriter::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+  AsyncLogMessage m(output, decorations, os::strdup(msg));\n+\n+  { \/\/ critical area\n+    AsyncLogLocker lock;\n+    enqueue_locked(m);\n+  }\n+}\n+\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsage.\n+\/\/ The lock here gurantees its integrity.\n+void AsyncLogWriter::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  AsyncLogLocker lock;\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n+    enqueue_locked(m);\n+  }\n+}\n+\n+AsyncLogWriter::AsyncLogWriter()\n+  : _initialized(false),\n+    _stats(17 \/*table_size*\/) {\n+  if (os::create_thread(this, os::asynclog_thread)) {\n+    _initialized = true;\n+  } else {\n+    log_warning(logging, thread)(\"AsyncLogging failed to create thread. Falling back to synchronous logging.\");\n+  }\n+\n+  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n+                    _buffer_max_size, AsyncLogBufferSize);\n+}\n+\n+class AsyncLogMapIterator {\n+  AsyncLogBuffer& _logs;\n+\n+ public:\n+  AsyncLogMapIterator(AsyncLogBuffer& logs) :_logs(logs) {}\n+  bool do_entry(LogFileOutput* output, uint32_t* counter) {\n+    using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+\n+    if (*counter > 0) {\n+      LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+      stringStream ss;\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+      AsyncLogMessage msg(*output, decorations, ss.as_string(true \/*c_heap*\/));\n+      _logs.push_back(msg);\n+      *counter = 0;\n+    }\n+\n+    return true;\n+  }\n+};\n+\n+void AsyncLogWriter::write() {\n+  \/\/ Use kind of copy-and-swap idiom here.\n+  \/\/ Empty 'logs' swaps the content with _buffer.\n+  \/\/ Along with logs destruction, all processed messages are deleted.\n+  \/\/\n+  \/\/ The operation 'pop_all()' is done in O(1). All I\/O jobs are then performed without\n+  \/\/ lock protection. This guarantees I\/O jobs don't block logsites.\n+  AsyncLogBuffer logs;\n+  bool own_io = false;\n+\n+  { \/\/ critical region\n+    AsyncLogLocker lock;\n+\n+    _buffer.pop_all(&logs);\n+    \/\/ append meta-messages of dropped counters\n+    AsyncLogMapIterator dropped_counters_iter(logs);\n+    _stats.iterate(&dropped_counters_iter);\n+    own_io = _io_sem.trywait();\n+  }\n+\n+  LinkedListIterator<AsyncLogMessage> it(logs.head());\n+  if (!own_io) {\n+    _io_sem.wait();\n+  }\n+\n+  while (!it.is_empty()) {\n+    AsyncLogMessage* e = it.next();\n+    char* msg = e->message();\n+\n+    if (msg != nullptr) {\n+      e->output()->write_blocking(e->decorations(), msg);\n+      os::free(msg);\n+    }\n+  }\n+  _io_sem.signal();\n+}\n+\n+void AsyncLogWriter::run() {\n+  while (true) {\n+    \/\/ The value of a semphore cannot be negative. Therefore, the current thread falls asleep\n+    \/\/ when its value is zero. It will be waken up when new messages are enqueued.\n+    _sem.wait();\n+    write();\n+  }\n+}\n+\n+AsyncLogWriter* AsyncLogWriter::_instance = nullptr;\n+\n+void AsyncLogWriter::initialize() {\n+  if (!LogConfiguration::is_async_mode()) return;\n+\n+  assert(_instance == nullptr, \"initialize() should only be invoked once.\");\n+\n+  AsyncLogWriter* self = new AsyncLogWriter();\n+  if (self->_initialized) {\n+    Atomic::release_store_fence(&AsyncLogWriter::_instance, self);\n+    \/\/ All readers of _instance after the fence see non-NULL.\n+    \/\/ We use LogOutputList's RCU counters to ensure all synchronous logsites have completed.\n+    \/\/ After that, we start AsyncLog Thread and it exclusively takes over all logging I\/O.\n+    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+      ts->wait_until_no_readers();\n+    }\n+    os::start_thread(self);\n+    log_debug(logging, thread)(\"Async logging thread started.\");\n+  }\n+}\n+\n+AsyncLogWriter* AsyncLogWriter::instance() {\n+  return _instance;\n+}\n+\n+\/\/ write() acquires and releases _io_sem even _buffer is empty.\n+\/\/ This guarantees all logging I\/O of dequeued messages are done when it returns.\n+void AsyncLogWriter::flush() {\n+  if (_instance != nullptr) {\n+    _instance->write();\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":194,"deletions":0,"binary":false,"changes":194,"status":"added"},{"patch":"@@ -0,0 +1,176 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_LOGGING_LOGASYNCWRITER_HPP\n+#define SHARE_LOGGING_LOGASYNCWRITER_HPP\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logDecorations.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logMessageBuffer.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/linkedlist.hpp\"\n+\n+template <typename E, MEMFLAGS F>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n+ private:\n+  LinkedListNode<E>* _tail;\n+  size_t _size;\n+\n+ public:\n+  LinkedListDeque() : _tail(NULL), _size(0) {}\n+  void push_back(const E& e) {\n+    if (!_tail) {\n+      _tail = this->add(e);\n+    } else {\n+      _tail = this->insert_after(e, _tail);\n+    }\n+\n+    ++_size;\n+  }\n+\n+  \/\/ pop all elements to logs.\n+  void pop_all(LinkedList<E>* logs) {\n+    logs->move(static_cast<LinkedList<E>* >(this));\n+    _tail = NULL;\n+    _size = 0;\n+  }\n+\n+  void pop_all(LinkedListDeque<E, F>* logs) {\n+    logs->_size = _size;\n+    logs->_tail = _tail;\n+    pop_all(static_cast<LinkedList<E>* >(logs));\n+  }\n+\n+  void pop_front() {\n+    LinkedListNode<E>* h = this->unlink_head();\n+    if (h == _tail) {\n+      _tail = NULL;\n+    }\n+\n+    if (h != NULL) {\n+      --_size;\n+      this->delete_node(h);\n+    }\n+  }\n+\n+  size_t size() const { return _size; }\n+\n+  const E* front() const {\n+    return this->_head == NULL ? NULL : this->_head->peek();\n+  }\n+\n+  const E* back() const {\n+    return _tail == NULL ? NULL : _tail->peek();\n+  }\n+\n+  LinkedListNode<E>* head() const {\n+    return this->_head;\n+  }\n+};\n+\n+class AsyncLogMessage {\n+  LogFileOutput& _output;\n+  const LogDecorations _decorations;\n+  char* _message;\n+\n+public:\n+  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, char* msg)\n+    : _output(output), _decorations(decorations), _message(msg) {}\n+\n+  \/\/ placeholder for LinkedListImpl.\n+  bool equals(const AsyncLogMessage& o) const { return false; }\n+\n+  LogFileOutput* output() const { return &_output; }\n+  const LogDecorations& decorations() const { return _decorations; }\n+  char* message() const { return _message; }\n+};\n+\n+typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n+typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n+\n+\/\/\n+\/\/ ASYNC LOGGING SUPPORT\n+\/\/\n+\/\/ Summary:\n+\/\/ Async Logging is working on the basis of singleton AsyncLogWriter, which manages an immediate buffer and a flushing thread.\n+\/\/\n+\/\/ Interface:\n+\/\/\n+\/\/ initialize() is called once when JVM is initialized. It creates and initializes the singleton instance of AsyncLogWriter.\n+\/\/ Once async logging is established, there's no way to turn it off.\n+\/\/\n+\/\/ instance() is MT-safe and returns the pointer of the singleton instance if and only if async logging is enabled and has well\n+\/\/ initialized. Clients can use its return value to determine async logging is established or not.\n+\/\/\n+\/\/ The basic operation of AsyncLogWriter is enqueue(). 2 overloading versions of it are provided to match LogOutput::write().\n+\/\/ They are both MT-safe and non-blocking. Derived classes of LogOutput can invoke the corresponding enqueue() in write() and\n+\/\/ return 0. AsyncLogWriter is responsible of copying neccessary data.\n+\/\/\n+\/\/ The static member function flush() is designated to flush out all pending messages when JVM is terminating.\n+\/\/ In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). flush() is MT-safe and can be invoked arbitrary\n+\/\/ times. It is no-op if async logging is not established.\n+\/\/\n+class AsyncLogWriter : public NonJavaThread {\n+  static AsyncLogWriter* _instance;\n+  \/\/ _sem is a semaphore whose value denotes how many messages have been enqueued.\n+  \/\/ It decreases in AsyncLogWriter::run()\n+  static Semaphore _sem;\n+  \/\/ A lock of IO\n+  static Semaphore _io_sem;\n+\n+  volatile bool _initialized;\n+  AsyncLogMap _stats; \/\/ statistics for dropped messages\n+  AsyncLogBuffer _buffer;\n+\n+  \/\/ The memory use of each AsyncLogMessage (payload) consists of itself and a variable-length c-str message.\n+  \/\/ A regular logging message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n+  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + vwrite_buffer_size)};\n+\n+  AsyncLogWriter();\n+  void enqueue_locked(const AsyncLogMessage& msg);\n+  void write();\n+  void run() override;\n+  void pre_run() override {\n+    NonJavaThread::pre_run();\n+    log_debug(logging, thread)(\"starting AsyncLog Thread tid = \" INTX_FORMAT, os::current_thread_id());\n+  }\n+  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n+  bool is_Named_thread() const override { return true; }\n+  void print_on(outputStream* st) const override {\n+    st->print(\"\\\"%s\\\" \", name());\n+    Thread::print_on(st);\n+    st->cr();\n+  }\n+\n+ public:\n+  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+\n+  static AsyncLogWriter* instance();\n+  static void initialize();\n+  static void flush();\n+};\n+\n+#endif \/\/ SHARE_LOGGING_LOGASYNCWRITER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":176,"deletions":0,"binary":false,"changes":176,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -264,0 +265,1 @@\n+    AsyncLogWriter::flush();\n@@ -281,0 +283,6 @@\n+  \/\/ Handle jcmd VM.log disable\n+  \/\/ ts->disable_outputs() above has deleted output_list with RCU synchronization.\n+  \/\/ Therefore, no new logging entry can enter AsyncLog buffer for the time being.\n+  \/\/ flush pending entries before LogOutput instances die.\n+  AsyncLogWriter::flush();\n+\n@@ -548,0 +556,6 @@\n+  out->print_cr(\"\\nAsynchronous logging (off by default):\");\n+  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\"  All log messages are written to an intermediate buffer first and will then be flushed\"\n+                \" to the corresponding log outputs by a standalone thread. Write operations at logsites are\"\n+                \" guaranteed non-blocking.\");\n+  out->cr();\n@@ -590,0 +604,4 @@\n+\n+  out->print_cr(\" -Xlog:async -Xlog:gc=debug:file=gc.log -Xlog:safepoint=trace\");\n+  out->print_cr(\"\\t Write logs asynchronously. Enable messages tagged with 'safepoint' up to 'trace' level to stdout \");\n+  out->print_cr(\"\\t and messages tagged with 'gc' up to 'debug' level to file 'gc.log'.\");\n@@ -616,0 +634,2 @@\n+\n+bool LogConfiguration::_async_mode = false;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+  static bool                       _async_mode;\n@@ -126,0 +127,5 @@\n+\n+  static bool is_async_mode() { return _async_mode; }\n+  static void set_async_mode(bool value) {\n+    _async_mode = value;\n+  }\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-  };\n+  }\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -287,6 +288,1 @@\n-int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n+int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n@@ -307,0 +303,15 @@\n+int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n+\n+  return write_blocking(decorations, msg);\n+}\n+\n@@ -313,0 +324,6 @@\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, msg_iterator);\n+    return 0;\n+  }\n+\n@@ -464,1 +481,1 @@\n-  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s\", _file_count,\n+  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s,async=%s\", _file_count,\n@@ -466,1 +483,2 @@\n-             proper_unit_for_byte_size(_rotate_size));\n+             proper_unit_for_byte_size(_rotate_size),\n+             LogConfiguration::is_async_mode() ? \"true\" : \"false\");\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,1 @@\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  void wait_until_no_readers() const;\n@@ -94,0 +93,1 @@\n+  void wait_until_no_readers() const;\n","filename":"src\/hotspot\/share\/logging\/logOutputList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+  void wait_until_no_readers() const {\n+    _output_list.wait_until_no_readers();\n+  }\n+\n@@ -166,0 +170,1 @@\n+extern const size_t vwrite_buffer_size;\n","filename":"src\/hotspot\/share\/logging\/logTagSet.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2750,0 +2750,3 @@\n+      } else if (strcmp(tail, \":async\") == 0) {\n+        LogConfiguration::set_async_mode(true);\n+        ret = true;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1992,0 +1992,5 @@\n+  product(size_t, AsyncLogBufferSize, 2*M,                                  \\\n+          \"Memory budget (in bytes) for the buffer of Asynchronous \"        \\\n+          \"Logging (-Xlog:async).\")                                         \\\n+          range(100*K, 50*M)                                                \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -126,0 +127,1 @@\n+  AsyncLogWriter::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -453,0 +453,1 @@\n+    asynclog_thread,   \/\/ dedicated to flushing logs\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -3760,0 +3761,1 @@\n+  cl.do_thread(AsyncLogWriter::instance());\n@@ -3813,0 +3815,1 @@\n+  print_on_error(AsyncLogWriter::instance(), st, current, buf, buflen, &found_current);\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+\/\/     - LogAsyncWriter\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -1339,0 +1340,1 @@\n+        declare_type(AsyncLogWriter, NonJavaThread)                       \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -287,0 +287,1 @@\n+template class BasicHashtable<mtLogging>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  AsyncLogWriter::flush();\n","filename":"test\/hotspot\/gtest\/logging\/logTestFixture.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -49,0 +50,1 @@\n+  AsyncLogWriter::flush();\n@@ -138,0 +140,1 @@\n+  AsyncLogWriter::flush();\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"logTestFixture.hpp\"\n+#include \"logTestUtils.inline.hpp\"\n+#include \"unittest.hpp\"\n+\n+class AsyncLogTest : public LogTestFixture {\n+ public:\n+  AsyncLogTest() {\n+    if(!LogConfiguration::is_async_mode()) {\n+      fprintf(stderr, \"Warning: asynclog is OFF.\\n\");\n+    }\n+  }\n+\n+  void test_asynclog_ls() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n+\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n+  }\n+\n+  void test_asynclog_raw() {\n+    Log(logging) logger;\n+#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n+LOG_LEVEL_LIST\n+#undef LOG_LEVEL\n+\n+    LogTarget(Trace, logging) t;\n+    LogTarget(Debug, logging) d;\n+    EXPECT_FALSE(t.is_enabled());\n+    EXPECT_TRUE(d.is_enabled());\n+\n+    d.print(\"AsyncLogTarget.print = %d\", 1);\n+    log_trace(logging)(\"log_trace-test\");\n+    log_debug(logging)(\"log_debug-test\");\n+  }\n+};\n+\n+TEST_VM(AsyncLogBufferTest, fifo) {\n+  LinkedListDeque<int, mtLogging> fifo;\n+  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n+\n+  fifo.push_back(1);\n+  EXPECT_EQ((size_t)1, fifo.size());\n+  EXPECT_EQ(1, *(fifo.back()));\n+\n+  fifo.pop_all(&result);\n+  EXPECT_EQ((size_t)0, fifo.size());\n+  EXPECT_EQ(NULL, fifo.back());\n+  EXPECT_EQ((size_t)1, result.size());\n+  EXPECT_EQ(1, *(result.head()->data()));\n+  result.clear();\n+\n+  fifo.push_back(2);\n+  fifo.push_back(1);\n+  fifo.pop_all(&result);\n+  EXPECT_EQ((size_t)2, result.size());\n+  EXPECT_EQ(2, *(result.head()->data()));\n+  EXPECT_EQ(1, *(result.head()->next()->data()));\n+  result.clear();\n+  const int N = 1000;\n+  for (int i=0; i<N; ++i) {\n+    fifo.push_back(i);\n+  }\n+  fifo.pop_all(&result);\n+\n+  EXPECT_EQ((size_t)N, result.size());\n+  LinkedListIterator<int> it(result.head());\n+  for (int i=0; i<N; ++i) {\n+    int* e = it.next();\n+    EXPECT_EQ(i, *e);\n+  }\n+}\n+\n+TEST_VM(AsyncLogBufferTest, deque) {\n+  LinkedListDeque<int, mtLogging> deque;\n+  const int N = 10;\n+\n+  EXPECT_EQ(NULL, deque.front());\n+  EXPECT_EQ(NULL, deque.back());\n+  for (int i = 0; i < N; ++i) {\n+    deque.push_back(i);\n+  }\n+\n+  EXPECT_EQ(0, *(deque.front()));\n+  EXPECT_EQ(N-1, *(deque.back()));\n+  EXPECT_EQ((size_t)N, deque.size());\n+\n+  deque.pop_front();\n+  EXPECT_EQ((size_t)(N - 1), deque.size());\n+  EXPECT_EQ(1, *(deque.front()));\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+\n+  deque.pop_front();\n+  EXPECT_EQ((size_t)(N - 2), deque.size());\n+  EXPECT_EQ(2, *(deque.front()));\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+\n+\n+  for (int i=2; i < N-1; ++i) {\n+    deque.pop_front();\n+  }\n+  EXPECT_EQ((size_t)1, deque.size());\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+  EXPECT_EQ(deque.back(), deque.front());\n+\n+  deque.pop_front();\n+  EXPECT_EQ((size_t)0, deque.size());\n+}\n+\n+TEST_VM_F(AsyncLogTest, asynclog) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+\n+  test_asynclog_ls();\n+  test_asynclog_raw();\n+  AsyncLogWriter::flush();\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, logMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+\n+  const int MULTI_LINES = 20;\n+  {\n+\n+    LogMessage(logging) msg;\n+    Log(logging) logger;\n+\n+    for (int i = 0; i < MULTI_LINES; ++i) {\n+      msg.debug(\"nonbreakable log message line-%02d\", i);\n+\n+      if (0 == (i % 4)) {\n+        logger.debug(\"a noisy message from other logger\");\n+      }\n+    }\n+    logger.debug(\"a noisy message from other logger\");\n+  }\n+  AsyncLogWriter::flush();\n+\n+  ResourceMark rm;\n+  LogMessageBuffer buffer;\n+  const char* strs[MULTI_LINES + 1];\n+  strs[MULTI_LINES] = NULL;\n+  for (int i = 0; i < MULTI_LINES; ++i) {\n+    stringStream ss;\n+    ss.print_cr(\"nonbreakable log message line-%02d\", i);\n+    strs[i] = ss.as_string();\n+  }\n+  \/\/ check nonbreakable log messages are consecutive\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"a noisy message from other logger\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, droppingMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\");\n+  const size_t sz = 100;\n+\n+  if (AsyncLogWriter::instance() != nullptr) {\n+    \/\/ shrink async buffer.\n+    AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+    LogMessage(logging) lm;\n+\n+    \/\/ write 100x more messages than its capacity in burst\n+    for (size_t i = 0; i < sz * 100; ++i) {\n+      lm.debug(\"a lot of log...\");\n+    }\n+    lm.flush();\n+    AsyncLogWriter::flush();\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+  AsyncLogWriter::flush();\n","filename":"test\/hotspot\/gtest\/logging\/test_log.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Note: This runs the unified logging part of gtest in async mode.\n+ * The reason is that hotspot can't safely turn off asynclogging dyanmically.\n+ * There's no TEST_OTHER_VM_F.\n+ *\/\n+\n+\/* @test\n+ * @summary Run logging gtest in async mode.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=AsyncLogTest* -Xlog:async\n+ * @run main\/native GTestWrapper --gtest_filter=Log*Test* -Xlog:async\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/AsyncLogGtest.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"}]}