{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -1948,0 +1949,1 @@\n+  LogAsyncFlusher::abort();\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -720,0 +721,1 @@\n+    case os::asynclog_thread:\n@@ -1100,0 +1102,1 @@\n+  LogAsyncFlusher::abort();\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+void AsyncLogMessage::writeback() {\n+  if (_message != NULL) {\n+    \/\/ should cache this object somehow\n+    LogDecorations decorations(_level, _tagset, _decorators);\n+    _output.write_blocking(decorations, _message);\n+  }\n+}\n+\n+void LogAsyncFlusher::enqueue_impl(const AsyncLogMessage& msg) {\n+  assert_lock_strong(&_lock);\n+\n+  if (_buffer.size() >= AsyncLogBufferSize)  {\n+    const AsyncLogMessage* h = _buffer.front();\n+    assert(h != NULL, \"sanity check\");\n+\n+    if (h->message() != nullptr) {\n+      bool p_created;\n+      uintx* counter = _stats.add_if_absent(h->output(), 0, &p_created);\n+      *counter = *counter + 1;\n+\n+      if (Verbose) {\n+        \/\/ Temporarily turn off SerializeVMOutput so defaultStream will not\n+        \/\/ invoke set_owner(self) for tty_lock.\n+        FlagSetting t(SerializeVMOutput, false);\n+        \/\/ The writing below can not guarantee non-blocking because tty may be piped by the filesystems\n+        \/\/ or throttled by XOFF, so only dump the dropping message in Verbose mode.\n+        tty->print_cr(\"asynclog dropping message: %s\", h->message());\n+      }\n+    }\n+\n+    _buffer.pop_front();\n+  }\n+  assert(_buffer.size() < AsyncLogBufferSize, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n+\n+  \/\/ notify async log thread if occupancy is over 3\/4\n+  size_t sz = _buffer.size();\n+  if (sz > (AsyncLogBufferSize >> 2) * 3 ) {\n+    _lock.notify();\n+  }\n+}\n+\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+  AsyncLogMessage m(output, decorations, msg);\n+\n+  { \/\/ critical area\n+    \/\/ The rank of _lock is same as _tty_lock on purpuse.\n+    \/\/ if logging thread is holding _tty_lock now, temporarily yield to _lock.\n+    ttyUnlocker ttyul;\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    enqueue_impl(m);\n+  }\n+}\n+\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsage.\n+\/\/ the mutex here gurantees its interity.\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  ttyUnlocker ttyul;\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), msg_iterator.message());\n+    enqueue_impl(m);\n+  }\n+}\n+\n+LogAsyncFlusher::LogAsyncFlusher()\n+  : _state(ThreadState::Running),\n+    _lock(Mutex::tty, \"async-log-monitor\", true \/* allow_vm_block *\/, Mutex::_safepoint_check_never),\n+    _stats(17 \/*table_size*\/) {\n+  if (os::create_thread(this, os::asynclog_thread)) {\n+    os::start_thread(this);\n+  }\n+}\n+\n+bool AsyncLogMapIterator::do_entry(LogFileOutput* output, uintx* counter) {\n+  LogDecorators decorators = output->decorators();\n+  decorators.without(LogDecorators::tags_decorator);\n+  LogDecorations decorations(LogLevel::Warning, decorators);\n+  const int sz = 128;\n+  char out_of_band[sz];\n+\n+  if (*counter > 0) {\n+    jio_snprintf(out_of_band, sz, UINTX_FORMAT \" messages dropped...\", *counter);\n+    output->write_blocking(decorations, out_of_band);\n+    *counter = 0;\n+  }\n+\n+  return true;\n+}\n+\n+void LogAsyncFlusher::writeback(const LinkedList<AsyncLogMessage>& logs) {\n+  LinkedListIterator<AsyncLogMessage> it(logs.head());\n+  while (!it.is_empty()) {\n+    AsyncLogMessage* e = it.next();\n+    e->writeback();\n+  }\n+}\n+\n+void LogAsyncFlusher::flush(bool with_lock) {\n+  LinkedListImpl<AsyncLogMessage, ResourceObj::C_HEAP, mtLogging> logs;\n+\n+  if (with_lock) { \/\/ critical area\n+    \/\/ Caveat: current thread must not hold _tty_lock or other lower rank lockers.\n+    \/\/ Cannot install ttyUnlocker here because flush() may be invoked before defaultStream\n+    \/\/ initialization.\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    _buffer.pop_all(&logs);\n+    AsyncLogMapIterator iter;\n+    _stats.iterate(&iter);\n+  } else {\n+    \/\/ C++ lambda can simplify the code snippet.\n+    _buffer.pop_all(&logs);\n+    AsyncLogMapIterator iter;\n+    _stats.iterate(&iter);\n+  }\n+\n+  writeback(logs);\n+}\n+\n+void LogAsyncFlusher::run() {\n+  while (_state == ThreadState::Running) {\n+    {\n+      MonitorLocker m(&_lock, Mutex::_no_safepoint_check_flag);\n+      m.wait(500 \/* ms, timeout*\/);\n+    }\n+    flush();\n+  }\n+\n+  \/\/ Signal thread has terminated\n+  MonitorLocker ml(Terminator_lock);\n+  Atomic::release_store(&_state, ThreadState::Terminated);\n+  ml.notify_all();\n+}\n+\n+LogAsyncFlusher* LogAsyncFlusher::_instance = nullptr;\n+\n+void LogAsyncFlusher::initialize() {\n+  if (!_instance) {\n+    _instance = new LogAsyncFlusher();\n+  }\n+}\n+\n+\/\/ Termination\n+\/\/ 1. issue an atomic store-&-fence to close the logging window.\n+\/\/ 2. flush itself in-place\n+\/\/ 3. signal the flusher thread to exit\n+\/\/ 4. wait until asynclog thread exits.\n+\/\/ 4. (optional) deletes this in post_run()\n+void LogAsyncFlusher::terminate() {\n+  if (_instance != NULL) {\n+    LogAsyncFlusher* self = _instance;\n+\n+    Atomic::release_store_fence<LogAsyncFlusher*, LogAsyncFlusher*>(&_instance, nullptr);\n+    self->flush();\n+    {\n+      MonitorLocker ml(&self->_lock, Mutex::_no_safepoint_check_flag);\n+      Atomic::release_store(&self->_state, ThreadState::Terminating);\n+      ml.notify();\n+    }\n+    {\n+      MonitorLocker ml(Terminator_lock, Mutex::_no_safepoint_check_flag);\n+      while (self->_state != ThreadState::Terminated) {\n+        ml.wait();\n+      }\n+    }\n+  }\n+}\n+\n+LogAsyncFlusher* LogAsyncFlusher::instance() {\n+  if (Thread::current_or_null() != nullptr) {\n+    return _instance;\n+  } else {\n+    \/\/ current thread may has been detached.\n+    return nullptr;\n+  }\n+}\n+\n+\/\/ Different from terminate(), abort is invoked by os::abort().\n+\/\/ There are 2 constraints:\n+\/\/ 1. must be async-safe because os::abort may be invoked by a signal handler while other\n+\/\/ threads are executing.\n+\/\/ 2. must not obtain _lock. eg. gtest.MutexRank.mutex_lock_access_leaf(test_mutex_rank.cpp)\n+\/\/ holds assess lock and then traps SIGSEGV on purpose.\n+\/\/\n+\/\/ Unlike terminate, abort() just ensures all pending log messages are flushed.\n+void LogAsyncFlusher::abort() {\n+  if (_instance != nullptr) {\n+    \/\/ to meet prior constraints, I borrow the idea in LogConfiguration::disable_outputs(),\n+    \/\/ the following code shut down all outputs for all tagsets with RCU synchroniziation.\n+    \/\/ After then, I can flush pending queue without a lock.\n+    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+      ts->disable_outputs();\n+    }\n+    _instance->flush(false \/*with_lock*\/);\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_LOGGING_ASYNC_FLUSHER_HPP\n+#define SHARE_LOGGING_ASYNC_FLUSHER_HPP\n+#include \"logging\/logDecorations.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logMessageBuffer.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/linkedlist.hpp\"\n+\n+template <typename E>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, mtLogging> {\n+ private:\n+  LinkedListNode<E>* _tail;\n+  size_t _size;\n+\n+ public:\n+  LinkedListDeque() : _tail(NULL), _size(0) {}\n+  void push_back(const E& e) {\n+    if (!_tail)\n+      _tail = this->add(e);\n+    else\n+      _tail = this->insert_after(e, _tail);\n+\n+    ++_size;\n+  }\n+\n+  void pop_all(LinkedList<E>* logs) {\n+    logs->move(static_cast<LinkedList<E>* >(this));\n+    _tail = NULL;\n+    _size = 0;\n+  }\n+\n+  void pop_front() {\n+    LinkedListNode<E>* h = this->unlink_head();\n+    if (h == _tail) {\n+      _tail = NULL;\n+    }\n+\n+    if (h != NULL) {\n+      --_size;\n+      this->delete_node(h);\n+    }\n+  }\n+\n+  size_t size() const { return _size; }\n+\n+  const E* front() const {\n+    return this->_head == NULL ? NULL : this->_head->peek();\n+  }\n+\n+  const E* back() const {\n+    return _tail == NULL ? NULL : _tail->peek();\n+  }\n+};\n+\n+class AsyncLogMessage {\n+  LogFileOutput& _output;\n+  mutable char* _message;\n+  LogDecorators _decorators;\n+  LogLevelType _level;\n+  const LogTagSet& _tagset;\n+\n+public:\n+  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, const char* msg)\n+    : _output(output), _decorators(output.decorators()),\n+    _level(decorations.get_level()), _tagset(decorations.get_logTagSet()) {\n+      \/\/ allow to fail here, then _message is NULL\n+      _message = os::strdup(msg, mtLogging);\n+    }\n+\n+  ~AsyncLogMessage() {\n+    if (_message != NULL) {\n+      os::free(_message);\n+      _message = NULL;\n+    }\n+  }\n+\n+  AsyncLogMessage(const AsyncLogMessage& o)\n+    :_output(o._output), _decorators(o._decorators), _level(o._level), _tagset(o._tagset) {\n+    _message = o._message;\n+    o._message = NULL; \/\/ transfer the ownership of _message to this\n+  }\n+\n+  void writeback();\n+\n+  bool equals(const AsyncLogMessage& o) const {\n+    return (&_output == &o._output) && (_message == o._message || !strcmp(_message, o._message));\n+  }\n+\n+  const char* message() const { return _message; }\n+  LogFileOutput* output() const { return &_output; }\n+};\n+\n+typedef LinkedListDeque<AsyncLogMessage> AsyncLogBuffer;\n+typedef KVHashtable<LogFileOutput*, uintx, mtLogging> AsyncLogMap;\n+struct AsyncLogMapIterator {\n+  bool do_entry(LogFileOutput* output, uintx* counter);\n+};\n+\n+\/\/ Flusher is a NonJavaThread which manages a FIFO capacity-bound buffer.\n+class LogAsyncFlusher : public NonJavaThread {\n+ private:\n+  static LogAsyncFlusher* _instance;\n+\n+  enum class ThreadState {\n+    Running = 0,\n+    Terminating,\n+    Terminated\n+  };\n+\n+  volatile ThreadState _state;\n+  \/\/ The semantics of _lock is more like a Java monitor.\n+  \/\/ AssyncLog thread sleeps on _lock until the occupancy of the buffer is over 3\/4, or timeout\n+  \/\/ It also acts as a mutex to consolidate buffer's MT-safety.\n+  Monitor _lock;\n+  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n+  AsyncLogBuffer _buffer;\n+\n+  LogAsyncFlusher();\n+  void enqueue_impl(const AsyncLogMessage& msg);\n+  static void writeback(const LinkedList<AsyncLogMessage>& logs);\n+  void run() override;\n+  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n+\n+ public:\n+  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+  void flush(bool with_lock = true);\n+\n+  static LogAsyncFlusher* instance();\n+  \/\/ None of following functions are thread-safe.\n+  static void initialize();\n+  static void terminate();\n+  static void abort();\n+};\n+\n+#endif \/\/ SHARE_LOGGING_ASYNC_FLUSHER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -281,0 +282,9 @@\n+  \/\/ Handle jcmd VM.log disable\n+  \/\/ ts->disable_outputs() above deletes output_list with RCU synchronization.\n+  \/\/ Therefore, no new logging entry will enter asynchronous queue after then.\n+  \/\/ flush pending entries before the LogOutput instances die.\n+  LogAsyncFlusher* async = LogAsyncFlusher::instance();\n+  if (async != nullptr) {\n+    async->flush(false \/* with_lock *\/);\n+  }\n+\n@@ -544,0 +554,1 @@\n+  out->print_cr(\"   async=true|false - write asynchronously or not.\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,1 +36,7 @@\n-    : _level(level), _tagset(tagset) {\n+    : _level(level), _tagset(&tagset) {\n+  create_decorations(decorators);\n+}\n+\n+LogDecorations::LogDecorations(LogLevelType level, const LogDecorators &decorators)\n+    : _level(level), _tagset(nullptr) {\n+  assert(!decorators.is_decorator(LogDecorators::tags_decorator), \"_tagset can't be NULL\");\n@@ -134,1 +140,5 @@\n-  int written = _tagset.label(pos, DecorationsBufferSize - (pos - _decorations_buffer));\n+  int written = 0;\n+\n+  if (_tagset != nullptr) {\n+    _tagset->label(pos, DecorationsBufferSize - (pos - _decorations_buffer));\n+  }\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-  const LogTagSet& _tagset;\n+  const LogTagSet* _tagset;\n@@ -50,0 +50,1 @@\n+  LogDecorations(LogLevelType level, const LogDecorators& decorators);\n@@ -55,0 +56,6 @@\n+  LogLevelType get_level() const { return _level; }\n+\n+  const LogTagSet& get_logTagSet() const {\n+    return *_tagset;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,11 @@\n-  };\n+  }\n+\n+  LogDecorators(const LogDecorators& o) : _decorators(o._decorators) {\n+  }\n+\n+  LogDecorators& operator=(const LogDecorators& rhs) {\n+    if (this != &rhs) {\n+      _decorators = rhs._decorators;\n+    }\n+    return *this;\n+  }\n@@ -107,0 +117,8 @@\n+  void combine_with(LogDecorators::Decorator source) {\n+    _decorators |= LogDecorators::mask(source);\n+  }\n+\n+  void without(LogDecorators::Decorator source) {\n+    _decorators &= ~LogDecorators::mask(source);\n+  }\n+\n@@ -111,0 +129,4 @@\n+  bool operator==(const LogDecorators& rhs) {\n+    return _decorators == rhs._decorators;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":24,"deletions":2,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -42,0 +43,1 @@\n+const char* const LogFileOutput::AsyncOptionKey = \"async\";\n@@ -48,1 +50,1 @@\n-      _file_count(DefaultFileCount), _is_default_file_count(true), _archive_name_len(0),\n+      _file_count(DefaultFileCount), _is_default_file_count(true), _async_mode(AsyncLogging), _archive_name_len(0),\n@@ -218,0 +220,11 @@\n+    } else if (strcmp(AsyncOptionKey, key) == 0) {\n+      if (strcasecmp(value_str, \"true\") == 0) {\n+        _async_mode = true;\n+      } else if (strcasecmp(value_str, \"false\") == 0) {\n+        _async_mode =false;\n+      } else {\n+        errstream->print_cr(\"Invalid option: %s must be either true or false.\",\n+                            AsyncOptionKey);\n+        success = false;\n+        break;\n+      }\n@@ -287,6 +300,1 @@\n-int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n+int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n@@ -307,0 +315,15 @@\n+int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (_async_mode && flusher != NULL) {\n+    flusher->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n+\n+  return write_blocking(decorations, msg);\n+}\n+\n@@ -313,0 +336,6 @@\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (_async_mode && flusher != NULL) {\n+    flusher->enqueue(*this, msg_iterator);\n+    return -1;\n+  }\n+\n@@ -464,1 +493,1 @@\n-  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s\", _file_count,\n+  out->print(\"filecount=%u,filesize=\" SIZE_FORMAT \"%s,async=%s\", _file_count,\n@@ -466,1 +495,2 @@\n-             proper_unit_for_byte_size(_rotate_size));\n+             proper_unit_for_byte_size(_rotate_size),\n+             _async_mode ? \"true\" : \"false\");\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":39,"deletions":9,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+  friend class AsyncLogMessage;\n+  friend struct AsyncLogMapIterator;\n@@ -39,0 +41,1 @@\n+  static const char* const AsyncOptionKey;\n@@ -58,0 +61,1 @@\n+  bool  _async_mode;\n@@ -82,0 +86,1 @@\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2024,0 +2024,7 @@\n+  product(bool, AsyncLogging, false,                                        \\\n+          \"Enble asynchronous mode for all file-based log outputs\")         \\\n+                                                                            \\\n+  product(size_t, AsyncLogBufferSize, 2*K,                                  \\\n+          \"Entries of the buffer for Async logs\")                           \\\n+          range(100, 100*K)                                                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -128,0 +129,1 @@\n+  LogAsyncFlusher::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -442,0 +442,1 @@\n+    asynclog_thread,  \/\/ dedicated to flushing logs\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -3761,0 +3762,3 @@\n+  \/\/ stop AsyncLog Thread\n+  LogAsyncFlusher::terminate();\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -287,0 +287,1 @@\n+template class BasicHashtable<mtLogging>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-\n+#include \"jvm.h\"\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,225 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logTestFixture.hpp\"\n+#include \"logTestUtils.inline.hpp\"\n+#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"unittest.hpp\"\n+\n+\n+class AsyncLogTest : public LogTestFixture {\n+};\n+\n+TEST_VM_F(AsyncLogTest, fifo) {\n+  LinkedListDeque<int> fifo;\n+  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n+\n+  fifo.push_back(1);\n+  EXPECT_EQ(fifo.size(), (size_t)1);\n+  EXPECT_EQ(*(fifo.back()), 1);\n+\n+  fifo.pop_all(&result);\n+  EXPECT_EQ(fifo.size(), (size_t)0);\n+  EXPECT_EQ(NULL, fifo.back());\n+  EXPECT_EQ(result.size(), (size_t)1);\n+  EXPECT_EQ(*(result.head()->data()), 1);\n+  result.clear();\n+\n+  fifo.push_back(2);\n+  fifo.push_back(1);\n+  fifo.pop_all(&result);\n+  EXPECT_EQ(result.size(), (size_t)2);\n+  EXPECT_EQ(*(result.head()->data()), 2);\n+  EXPECT_EQ(*(result.head()->next()->data()), 1);\n+  result.clear();\n+  const int N = 1000;\n+  for (int i=0; i<N; ++i) {\n+    fifo.push_back(i);\n+  }\n+  fifo.pop_all(&result);\n+\n+  EXPECT_EQ(result.size(), (size_t)N);\n+  LinkedListIterator<int> it(result.head());\n+  for (int i=0; i<N; ++i) {\n+    int* e = it.next();\n+    EXPECT_EQ(*e, i);\n+  }\n+}\n+\n+TEST_VM_F(AsyncLogTest, deque) {\n+  LinkedListDeque<int> deque;\n+  const int N = 10;\n+\n+  EXPECT_EQ(NULL, deque.front());\n+  EXPECT_EQ(NULL, deque.back());\n+  for (int i = 0; i < N; ++i) {\n+    deque.push_back(i);\n+  }\n+\n+  EXPECT_EQ(*(deque.front()), 0);\n+  EXPECT_EQ(*(deque.back()), N-1);\n+  EXPECT_EQ(deque.size(), (size_t)N);\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)(N - 1));\n+  EXPECT_EQ(*(deque.front()), 1);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)(N - 2));\n+  EXPECT_EQ(*(deque.front()), 2);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+\n+\n+  for (int i=2; i < N-1; ++i) {\n+    deque.pop_front();\n+  }\n+  EXPECT_EQ(deque.size(), (size_t)1);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+  EXPECT_EQ(deque.front(), deque.back());\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)0);\n+}\n+\n+class VM_TestFlusher: public VM_GTestExecuteAtSafepoint {\n+public:\n+  void doit() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n+\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n+\n+    test_asynclog_raw();\n+  }\n+\n+  void test_asynclog_raw() {\n+    Log(logging) logger;\n+#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n+LOG_LEVEL_LIST\n+#undef LOG_LEVEL\n+\n+    LogTarget(Trace, logging) t;\n+    LogTarget(Debug, logging) d;\n+    EXPECT_FALSE(t.is_enabled());\n+    EXPECT_TRUE(d.is_enabled());\n+\n+    d.print(\"AsyncLogTarget.print = %d\", 1);\n+    log_trace(logging)(\"log_trace-test\");\n+    log_debug(logging)(\"log_debug-test\");\n+  }\n+};\n+\n+TEST_VM_F(AsyncLogTest, asynclog) {\n+  set_log_config(TestLogFileName, \"logging=debug\", NULL, \"async=true\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  {\n+    VM_TestFlusher op;\n+    ThreadInVMfromNative invm(JavaThread::current());\n+    VMThread::execute(&op);\n+  }\n+  flusher->flush();\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, logMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+\n+  const int MULTI_LINES = 20;\n+  {\n+\n+    LogMessage(logging) msg;\n+    Log(logging) logger;\n+\n+    for (int i = 0; i < MULTI_LINES; ++i) {\n+      msg.debug(\"nonbreakable log message line-%02d\", i);\n+\n+      if (0 == (i % 4)) {\n+        logger.debug(\"a noisy message from other logger\");\n+      }\n+    }\n+    logger.debug(\"a noisy message from other logger\");\n+  }\n+  flusher->flush();\n+\n+  ResourceMark rm;\n+  LogMessageBuffer buffer;\n+  const char* strs[MULTI_LINES + 1];\n+  strs[MULTI_LINES] = NULL;\n+  for (int i = 0; i < MULTI_LINES; ++i) {\n+    stringStream ss;\n+    ss.print_cr(\"nonbreakable log message line-%02d\", i);\n+    strs[i] = ss.as_string();\n+  }\n+  \/\/ check nonbreakable log messages are consecutive\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"a noisy message from other logger\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, droppingMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+  const size_t sz = 100;\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  \/\/ shrink async buffer.\n+  AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz);\n+  LogMessage(logging) lm;\n+\n+  \/\/ write 100x more messages than its capacity in burst\n+  for (size_t i = 0; i < sz * 100; ++i) {\n+    lm.debug(\"a lot of log...\");\n+  }\n+  lm.flush();\n+  flusher->flush();\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped...\"));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":225,"deletions":0,"binary":false,"changes":225,"status":"added"}]}