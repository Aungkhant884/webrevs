{"files":[{"patch":"@@ -42,4 +42,9 @@\n-    if (Verbose) {\n-      const AsyncLogMessage* h = _buffer.front();\n-      assert(h != NULL, \"sanity check\");\n-      if (h->message() != NULL) {\n+    const AsyncLogMessage* h = _buffer.front();\n+    assert(h != NULL, \"sanity check\");\n+\n+    if (h->message() != nullptr) {\n+      bool p_created;\n+      uintx* counter = _stats.add_if_absent(h->output(), 0, &p_created);\n+      *counter = *counter + 1;\n+\n+      if (Verbose) {\n@@ -88,1 +93,2 @@\n-    _lock(Mutex::tty, \"async-log-monitor\", true \/* allow_vm_block *\/, Mutex::_safepoint_check_never) {\n+    _lock(Mutex::tty, \"async-log-monitor\", true \/* allow_vm_block *\/, Mutex::_safepoint_check_never),\n+    _stats(17 \/*table_size*\/) {\n@@ -94,0 +100,16 @@\n+bool AsyncLogMapIterator::do_entry(LogFileOutput* output, uintx* counter) {\n+  LogDecorators decorators = output->decorators();\n+  decorators.without(LogDecorators::tags_decorator);\n+  LogDecorations decorations(LogLevel::Warning, decorators);\n+  const int sz = 128;\n+  char out_of_band[sz];\n+\n+  if (*counter > 0) {\n+    jio_snprintf(out_of_band, sz, UINTX_FORMAT \" messages dropped...\", *counter);\n+    output->write_blocking(decorations, out_of_band);\n+    *counter = 0;\n+  }\n+\n+  return true;\n+}\n+\n@@ -100,0 +122,3 @@\n+\n+    AsyncLogMapIterator iter;\n+    _stats.iterate(&iter);\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":30,"deletions":5,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logFileOutput.hpp\"\n@@ -31,1 +32,1 @@\n-#include \"runtime\/task.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n@@ -33,1 +34,0 @@\n-#include \"utilities\/pair.hpp\"\n@@ -81,2 +81,0 @@\n-class LogFileOutput;\n-\n@@ -92,1 +90,1 @@\n-    : _output(output), _decorators(decorations.get_decorators()),\n+    : _output(output), _decorators(output.decorators()),\n@@ -118,0 +116,1 @@\n+  LogFileOutput* output() const { return &_output; }\n@@ -121,0 +120,4 @@\n+typedef KVHashtable<LogFileOutput*, uintx, mtLogging> AsyncLogMap;\n+struct AsyncLogMapIterator {\n+  bool do_entry(LogFileOutput* output, uintx* counter);\n+};\n@@ -136,0 +139,1 @@\n+  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n@@ -139,1 +143,0 @@\n-\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -36,1 +36,7 @@\n-    : _level(level), _tagset(tagset) {\n+    : _level(level), _tagset(&tagset) {\n+  create_decorations(decorators);\n+}\n+\n+LogDecorations::LogDecorations(LogLevelType level, const LogDecorators &decorators)\n+    : _level(level), _tagset(nullptr) {\n+  assert(!decorators.is_decorator(LogDecorators::tags_decorator), \"_tagset can't be NULL\");\n@@ -67,15 +73,0 @@\n-\n-  assert(get_decorators() == decorators, \"sanity check\");\n-}\n-\n-LogDecorators LogDecorations::get_decorators() const {\n-  LogDecorators decorators(LogDecorators::None);\n-\n-#define DECORATOR(full_name, abbr)                                        \\\n-  if (_decoration_offset[LogDecorators::full_name##_decorator] != NULL) { \\\n-    decorators.combine_with(LogDecorators::full_name##_decorator);        \\\n-  }\n-  DECORATOR_LIST\n-#undef DECORATOR\n-\n-  return decorators;\n@@ -149,1 +140,5 @@\n-  int written = _tagset.label(pos, DecorationsBufferSize - (pos - _decorations_buffer));\n+  int written = 0;\n+\n+  if (_tagset != nullptr) {\n+    _tagset->label(pos, DecorationsBufferSize - (pos - _decorations_buffer));\n+  }\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":12,"deletions":17,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  const LogTagSet& _tagset;\n+  const LogTagSet* _tagset;\n@@ -50,0 +50,1 @@\n+  LogDecorations(LogLevelType level, const LogDecorators& decorators);\n@@ -58,1 +59,1 @@\n-    return _tagset;\n+    return *_tagset;\n@@ -67,2 +68,0 @@\n-\n-  LogDecorators get_decorators() const;\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -121,0 +121,4 @@\n+  void without(LogDecorators::Decorator source) {\n+    _decorators &= ~LogDecorators::mask(source);\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+  friend struct AsyncLogMapIterator;\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -324,0 +324,1 @@\n+template class BasicHashtable<mtLogging>;\n","filename":"src\/hotspot\/share\/utilities\/hashtable.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -208,0 +208,14 @@\n+\n+TEST_VM_F(AsyncLogTest, droppingMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+  const size_t sz = 100;\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz);\n+\n+  for (size_t i=0; i < sz * 1000; ++i) {\n+    log_debug(logging)(\"a lot of log...\");\n+  }\n+  flusher->flush();\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped...\"));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}