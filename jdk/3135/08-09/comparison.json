{"files":[{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logConfiguration.hpp\"\n@@ -33,2 +34,2 @@\n-    LogDecorations decorations(_level, _tagset, _decorations_ref);\n-    _output.write_blocking(decorations, _message);\n+    assert(_decorations != NULL, \"sanity check\");\n+    _output.write_blocking(*_decorations, _message);\n@@ -41,1 +42,1 @@\n-  if (_buffer.size() >= AsyncLogBufferSize)  {\n+  if (_buffer.size() >= AsyncLogBufferEntries)  {\n@@ -62,1 +63,1 @@\n-  assert(_buffer.size() < AsyncLogBufferSize, \"_buffer is over-sized.\");\n+  assert(_buffer.size() < AsyncLogBufferEntries, \"_buffer is over-sized.\");\n@@ -67,1 +68,1 @@\n-  if (sz > (AsyncLogBufferSize >> 2) * 3 ) {\n+  if (sz > (AsyncLogBufferEntries >> 2) * 3 ) {\n@@ -126,0 +127,1 @@\n+    e->destroy();\n@@ -161,1 +163,1 @@\n-  Atomic::release_store(&_state, ThreadState::Terminated);\n+  _state = ThreadState::Terminated;\n@@ -168,2 +170,4 @@\n-  if (!_instance) {\n-    _instance = new LogAsyncFlusher();\n+  if (!LogConfiguration::is_async_mode()) return;\n+\n+  if (_instance == NULL) {\n+    Atomic::release_store(&LogAsyncFlusher::_instance, new LogAsyncFlusher());\n@@ -174,1 +178,1 @@\n-\/\/ 1. issue an atomic release_store&fence to close the logging window.\n+\/\/ 1. issue an atomic release_store to close the logging window.\n@@ -183,1 +187,1 @@\n-    Atomic::release_store_fence<LogAsyncFlusher*, LogAsyncFlusher*>(&_instance, nullptr);\n+    Atomic::release_store<LogAsyncFlusher*, LogAsyncFlusher*>(&_instance, nullptr);\n@@ -187,1 +191,1 @@\n-      Atomic::release_store(&self->_state, ThreadState::Terminating);\n+      self->_state = ThreadState::Terminating;\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -84,5 +84,3 @@\n-  LogFileOutput& _output;\n-  mutable char* _message;\n-  LogDecorationsRef& _decorations_ref;\n-  LogLevelType _level;\n-  const LogTagSet& _tagset;\n+  LogFileOutput&   _output;\n+  LogDecorations*  _decorations;\n+  char*            _message;\n@@ -92,2 +90,2 @@\n-    : _output(output), _decorations_ref(decorations.ref()),\n-    _level(decorations.get_level()), _tagset(decorations.get_logTagSet()) {\n+    : _output(output) {\n+    _decorations = new LogDecorations(decorations);\n@@ -95,3 +93,6 @@\n-      _message = os::strdup(msg, mtLogging);\n-      ++_decorations_ref;\n-    }\n+    _message = os::strdup(msg, mtLogging);\n+  }\n+\n+  void destroy() {\n+    delete _decorations;\n+    _decorations = NULL;\n@@ -99,2 +100,0 @@\n-  ~AsyncLogMessage() {\n-    --_decorations_ref;\n@@ -103,1 +102,0 @@\n-      _message = NULL;\n@@ -107,7 +105,0 @@\n-  AsyncLogMessage(const AsyncLogMessage& o)\n-    :_output(o._output), _decorations_ref(o._decorations_ref), _level(o._level), _tagset(o._tagset) {\n-    _message = o._message;\n-    o._message = NULL; \/\/ transfer the ownership of _message to this\n-    ++_decorations_ref;\n-  }\n-\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -554,1 +554,6 @@\n-  out->print_cr(\"   async=true|false - write asynchronously or not, false by default.\");\n+  out->cr();\n+  out->print_cr(\"\\nAsynchronous logging(off by default):\");\n+  out->print_cr(\" -Xlog:async\");\n+  out->print_cr(\"  All log messages write to an intermediate buffer first defined by AsyncLogBufferEntries \"\n+                \" and then will be flushed to the corresponding log outputs by a standalone thread. Write operation at logsites \"\n+                \" guarantee non-blocking.\");\n@@ -598,0 +603,4 @@\n+\n+  out->print_cr(\" -Xlog:async -Xlog:gc=debug:file=gc.log -Xlog:safepoint=trace\");\n+  out->print_cr(\"\\t Write logs asynchronously. Enable messages tagged with 'safepoint' up to 'trace' level to stdout \");\n+  out->print_cr(\"\\t and messages tagged with 'gc' up to 'trace' level to file 'gc.log'.\");\n@@ -624,0 +633,2 @@\n+\n+bool LogConfiguration::_async_mode = false;\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-\n+  static bool _async_mode;\n@@ -126,0 +126,5 @@\n+\n+  static bool is_async_mode() { return _async_mode; }\n+  static void set_async_mode(bool value) {\n+    _async_mode = value;\n+  }\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    : _level(level), _tagset(&tagset), _ref(nullptr) {\n+    : _level(level), _tagset(&tagset) {\n@@ -40,6 +40,0 @@\n-LogDecorations::LogDecorations(LogLevelType level, const LogTagSet &tagset, LogDecorationsRef& ref)\n-    : _level(level), _tagset(&tagset), _ref(&ref) {\n-  assert(ref._refcnt > 0, \"pass in an invalid LogDecorationsRef.\");\n-  ++(*_ref);\n-}\n-\n@@ -47,1 +41,1 @@\n-    : _level(level), _tagset(nullptr), _ref(nullptr) {\n+    : _level(level), _tagset(nullptr) {\n@@ -52,0 +46,20 @@\n+LogDecorations::LogDecorations(const LogDecorations& o)\n+    : _level(o._level), _tagset(o._tagset) {\n+  size_t sz = 0;\n+  for (int i = 0; i < LogDecorators::Count; ++i) {\n+    if (o._decoration_offset[i] != NULL) {\n+      sz += strlen(o._decoration_offset[i]) + 1;\n+    }\n+  }\n+\n+  \/\/ safe to call with sz = 0\n+  memcpy(_decorations_buffer, o._decorations_buffer, sz);\n+  for (int i = 0; i < LogDecorators::Count; ++i) {\n+    if (o._decoration_offset[i] != NULL) {\n+      _decoration_offset[i] = (o._decoration_offset[i] - o._decorations_buffer) + _decorations_buffer;\n+    } else {\n+      _decoration_offset[i] = NULL;\n+    }\n+  }\n+}\n+\n@@ -158,31 +172,0 @@\n-\n-LogDecorationsRef LogDecorationsRef::NoneRef = {};\n-\n-LogDecorationsRef& LogDecorations::ref() const {\n-  if (_ref == nullptr) {\n-    size_t sz = 0;\n-\n-    for (int i = 0; i < LogDecorators::Count; ++i) {\n-      if (_decoration_offset[i] != NULL) {\n-        sz += strlen(_decoration_offset[i]) + 1;\n-      }\n-    }\n-\n-    if (sz == 0) { \/\/ decorators == 'none'\n-      return ++LogDecorationsRef::NoneRef;\n-    }\n-\n-    _ref = new LogDecorationsRef();\n-    _ref->_decorations_buffer = NEW_C_HEAP_ARRAY(char, sz, mtLogging);\n-    memcpy(_ref->_decorations_buffer, _decorations_buffer, sz);\n-    for (int i = 0; i < LogDecorators::Count; ++i) {\n-      if (_decoration_offset[i] != NULL) {\n-        _ref->_decoration_offset[i] = (_decoration_offset[i] - _decorations_buffer) + _ref->_decorations_buffer;\n-      } else {\n-        _ref->_decoration_offset[i] = NULL;\n-      }\n-    }\n-  }\n-\n-  return ++(*_ref);\n-}\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":22,"deletions":39,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,39 +30,0 @@\n-\/\/ LogDecorations objects are temporary variables in LogTagSet::log()\n-\/\/ It doesnot fit asynchronous logging well because flusher will access\n-\/\/ them in AsyncLog Thread. some decorators are very context sensitive, eg.\n-\/\/ uptime and tid, async logging has to copy LogDecorations objects to secure\n-\/\/ the accurarcy.\n-\/\/\n-\/\/ LogDecorationsRef provides a relatively cheaper copy of LogDecorations,\n-\/\/ which consists of 256-byte buffer. The ref only copys strings what have\n-\/\/ materialized and use refcnt to avoid from duplicating.\n-class LogDecorationsRef : public CHeapObj<mtLogging>{\n-  friend class LogDecorations;\n-private:\n-  char* _decorations_buffer;\n-  char* _decoration_offset[LogDecorators::Count];\n-  size_t _refcnt;\n-\n-  \/\/ only LogDecorations can create it.\n-  LogDecorationsRef() : _refcnt(0) {}\n-  LogDecorationsRef(const LogDecorationsRef& rhs) = delete;\n-public:\n-  LogDecorationsRef& operator++() {\n-    _refcnt++;\n-    return *this;\n-  }\n-\n-  void operator--() {\n-    if (--_refcnt == 0 && this != &NoneRef) {\n-      FREE_C_HEAP_ARRAY(char, _decorations_buffer);\n-      delete this;\n-    }\n-  }\n-\n-  size_t refcnt() const { return _refcnt; }\n-\n-  \/\/ It is not constant value for convenience.\n-  \/\/ Do not need to care its refcnt as long as it does not delete itself.\n-  static LogDecorationsRef NoneRef;\n-};\n-\n@@ -70,1 +31,1 @@\n-class LogDecorations {\n+class LogDecorations : public CHeapObj<mtLogging> {\n@@ -78,1 +39,0 @@\n-  mutable LogDecorationsRef* _ref;\n@@ -88,0 +48,1 @@\n+  LogDecorations& operator=(const LogDecorations& o) = delete;\n@@ -90,1 +51,0 @@\n-  LogDecorations(LogLevelType level, const LogTagSet& tagset, LogDecorationsRef& ref);\n@@ -92,5 +52,2 @@\n-  ~LogDecorations() {\n-    if (_ref != nullptr) {\n-      --(*_ref);\n-    }\n-  }\n+  LogDecorations(const LogDecorations& o);\n+\n@@ -111,6 +68,1 @@\n-\n-    if (_ref == nullptr) {\n-      return _decoration_offset[decorator];\n-    } else {\n-      return _ref->_decoration_offset[decorator];\n-    }\n+    return _decoration_offset[decorator];\n@@ -118,2 +70,0 @@\n-\n-  LogDecorationsRef& ref() const;\n@@ -121,0 +71,1 @@\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":6,"deletions":55,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -43,1 +43,0 @@\n-const char* const LogFileOutput::AsyncOptionKey = \"async\";\n@@ -50,1 +49,1 @@\n-      _file_count(DefaultFileCount), _is_default_file_count(true), _async_mode(AsyncLogging), _archive_name_len(0),\n+      _file_count(DefaultFileCount), _is_default_file_count(true), _archive_name_len(0),\n@@ -220,11 +219,0 @@\n-    } else if (strcmp(AsyncOptionKey, key) == 0) {\n-      if (strcasecmp(value_str, \"true\") == 0) {\n-        _async_mode = true;\n-      } else if (strcasecmp(value_str, \"false\") == 0) {\n-        _async_mode =false;\n-      } else {\n-        errstream->print_cr(\"Invalid option: %s must be either true or false.\",\n-                            AsyncOptionKey);\n-        success = false;\n-        break;\n-      }\n@@ -262,3 +250,2 @@\n-                     \", filesize: \" SIZE_FORMAT \" KiB, async: %s).\",\n-                     _file_name, _file_count, _rotate_size \/ K,\n-                     _async_mode ? \"true\" : \"false\");\n+                     \", filesize: \" SIZE_FORMAT \" KiB).\",\n+                     _file_name, _file_count, _rotate_size \/ K);\n@@ -323,1 +310,1 @@\n-  if (_async_mode && flusher != NULL) {\n+  if (flusher != NULL) {\n@@ -338,1 +325,1 @@\n-  if (_async_mode && flusher != NULL) {\n+  if (flusher != NULL) {\n@@ -497,1 +484,1 @@\n-             _async_mode ? \"true\" : \"false\");\n+             LogConfiguration::is_async_mode() ? \"true\" : \"false\");\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -61,1 +61,0 @@\n-  bool  _async_mode;\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2748,0 +2748,3 @@\n+      } else if (strcmp(tail, \":async\") == 0) {\n+        LogConfiguration::set_async_mode(true);\n+        ret = true;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2024,6 +2024,6 @@\n-  product(bool, AsyncLogging, false,                                        \\\n-          \"Enble asynchronous mode for all file-based log outputs\")         \\\n-                                                                            \\\n-  product(size_t, AsyncLogBufferSize, 2*K,                                  \\\n-          \"Entries of the buffer for Async logs\")                           \\\n-          range(100, 100*K)                                                 \\\n+  product(size_t, AsyncLogBufferEntries, 2*K,                               \\\n+          \"Entries of the buffer for AsyncLogging. \"                        \\\n+          \"Each entry consists of the log messages and decorations \"        \\\n+          \"which are variable-length. The maximal memory taken by \"         \\\n+          \"an entry is roughly 520 bytes\")                                  \\\n+          range(100, 500*K)                                                 \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -35,0 +35,8 @@\n+\/\/ So far, shutdown asynclogging on-the-fly can only be done in vmthread.\n+\/\/ Use it only in gtest.\n+class AsyncLogDisabler : public VM_GTestExecuteAtSafepoint {\n+  void doit() override {\n+    LogConfiguration::set_async_mode(false);\n+    LogAsyncFlusher::terminate();\n+  }\n+};\n@@ -37,0 +45,15 @@\n+  bool _saved_async_mode;\n+\n+ public:\n+  AsyncLogTest() : _saved_async_mode(LogConfiguration::is_async_mode()) {\n+    LogConfiguration::set_async_mode(true);\n+    LogAsyncFlusher::initialize();\n+  }\n+\n+  ~AsyncLogTest() {\n+    if (!_saved_async_mode) {\n+      AsyncLogDisabler op;\n+      ThreadInVMfromNative invm(JavaThread::current());\n+      VMThread::execute(&op);\n+    }\n+  }\n@@ -146,1 +169,1 @@\n-  set_log_config(TestLogFileName, \"logging=debug\", NULL, \"async=true\");\n+  set_log_config(TestLogFileName, \"logging=debug\");\n@@ -173,1 +196,1 @@\n-  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+  set_log_config(TestLogFileName, \"logging=debug\");\n@@ -210,1 +233,1 @@\n-  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+  set_log_config(TestLogFileName, \"logging=debug\");\n@@ -215,1 +238,1 @@\n-  AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz);\n+  AutoModifyRestore<size_t> saver(AsyncLogBufferEntries, sz);\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":27,"deletions":4,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -234,1 +234,1 @@\n-TEST_VM(LogDecorations, ref) {\n+TEST(LogDecorations, copyctor) {\n@@ -236,1 +236,1 @@\n-  ASSERT_TRUE(decorator_selection.parse(\"tid,uptime,level\"));\n+  ASSERT_TRUE(decorator_selection.parse(\"uptime,tid,level\"));\n@@ -238,0 +238,1 @@\n+\n@@ -241,18 +242,0 @@\n-  LogDecorationsRef& ref = decorations.ref();\n-\n-  \/\/ test refcnt\n-  EXPECT_EQ(ref.refcnt(), (size_t)1);\n-  ++ref;\n-  EXPECT_EQ(ref.refcnt(), (size_t)2);\n-  --ref;\n-  EXPECT_EQ(ref.refcnt(), (size_t)1);\n-\n-  \/\/ test contents\n-  EXPECT_STREQ(decorations.decoration(LogDecorators::tid_decorator), saved_tid);\n-  EXPECT_NE(decorations.decoration(LogDecorators::tid_decorator), saved_tid);\n-  EXPECT_STREQ(decorations.decoration(LogDecorators::uptime_decorator), saved_uptime);\n-  EXPECT_NE(decorations.decoration(LogDecorators::uptime_decorator), saved_uptime);\n-  EXPECT_STREQ(decorations.decoration(LogDecorators::level_decorator), saved_level);\n-  \/\/ level is special.\n-  EXPECT_EQ(decorations.decoration(LogDecorators::level_decorator), saved_level);\n-}\n@@ -260,12 +243,3 @@\n-TEST_VM(LogDecorations, ref_none) {\n-  LogDecorators decorator_selection;\n-  ASSERT_TRUE(decorator_selection.parse(\"none\"));\n-  LogDecorations decorations(LogLevel::Info, tagset, decorator_selection);\n-  LogDecorationsRef& ref = decorations.ref();\n-\n-  EXPECT_EQ(&ref, &LogDecorationsRef::NoneRef);\n-  EXPECT_EQ(ref.refcnt(), (size_t)1);\n-  --ref;\n-\n-  EXPECT_EQ(NULL, decorations.decoration(LogDecorators::tid_decorator));\n-  EXPECT_EQ(NULL, decorations.decoration(LogDecorators::uptime_decorator));\n+  LogDecorations copy(decorations);\n+  EXPECT_STREQ(saved_tid, copy.decoration(LogDecorators::tid_decorator));\n+  EXPECT_STREQ(saved_uptime, copy.decoration(LogDecorators::uptime_decorator));\n@@ -273,1 +247,4 @@\n-  EXPECT_EQ(LogLevel::name(LogLevel::Info), decorations.decoration(LogDecorators::level_decorator));\n+  EXPECT_EQ(saved_level, copy.decoration(LogDecorators::level_decorator));\n+\n+  EXPECT_EQ(NULL, copy.decoration(LogDecorators::tags_decorator));\n+  EXPECT_EQ(NULL, copy.decoration(LogDecorators::hostname_decorator));\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":10,"deletions":33,"binary":false,"changes":43,"status":"modified"}]}