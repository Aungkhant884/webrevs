{"files":[{"patch":"@@ -63,2 +63,2 @@\n-\n-    _buffer.pop_front();\n+    \/\/ drop the enqueueing message.\n+    return;\n@@ -66,0 +66,1 @@\n+\n@@ -102,5 +103,2 @@\n-bool AsyncLogMapIterator::do_entry(LogFileOutput* output, uint32_t* counter) {\n-  using none = LogTagSetMapping<LogTag::__NO_TAG>;\n-  LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n-  const int sz = 128;\n-  char out_of_band[sz];\n+class AsyncLogMapIterator {\n+  AsyncLogBuffer& _logs;\n@@ -108,5 +106,13 @@\n-  if (*counter > 0) {\n-    jio_snprintf(out_of_band, sz, UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n-    output->write_blocking(decorations, out_of_band);\n-    *counter = 0;\n-  }\n+ public:\n+  AsyncLogMapIterator(AsyncLogBuffer& logs) :_logs(logs) {}\n+  bool do_entry(LogFileOutput* output, uint32_t* counter) {\n+    using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+\n+    if (*counter > 0) {\n+      LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+      stringStream ss;\n+      ss.print(UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+      AsyncLogMessage msg(*output, decorations, ss.as_string(true \/*c_heap*\/));\n+      _logs.push_back(msg);\n+      *counter = 0;\n+    }\n@@ -114,2 +120,3 @@\n-  return true;\n-}\n+    return true;\n+  }\n+};\n@@ -118,2 +125,2 @@\n-  \/\/ use copy-and-swap idiom here.\n-  \/\/ 'logs' swaps content with _buffer.\n+  \/\/ use kind of copy-and-swap idiom here.\n+  \/\/ Empty 'logs' 'swaps' the content with _buffer.\n@@ -122,1 +129,1 @@\n-  \/\/ the atomic operation is done in O(1). All I\/O jobs are done without lock.\n+  \/\/ the atomic operation 'move' is done in O(1). All I\/O jobs are done without lock.\n@@ -124,1 +131,1 @@\n-  LinkedListImpl<AsyncLogMessage, ResourceObj::C_HEAP, mtLogging> logs;\n+  AsyncLogBuffer logs;\n@@ -127,0 +134,1 @@\n+    AsyncLogMapIterator dropped_counters_iter(logs);\n@@ -129,2 +137,2 @@\n-    AsyncLogMapIterator iter;\n-    _stats.iterate(&iter);\n+    \/\/ append meta-message of dropped counters\n+    _stats.iterate(&dropped_counters_iter);\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":28,"deletions":20,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+  \/\/ pop all elements to logs.\n@@ -59,0 +60,6 @@\n+  void pop_all(LinkedListDeque<E, F>* logs) {\n+    logs->_size = _size;\n+    logs->_tail = _tail;\n+    pop_all(static_cast<LinkedList<E>* >(logs));\n+  }\n+\n@@ -80,0 +87,4 @@\n+\n+  LinkedListNode<E>* head() const {\n+    return static_cast<const LinkedList<E>* >(this)->head();\n+  }\n@@ -101,3 +112,0 @@\n-struct AsyncLogMapIterator {\n-  bool do_entry(LogFileOutput* output, uint32_t* counter);\n-};\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -26,2 +26,2 @@\n- * Note: This runs the asynclog parts of gtest in async mode. \n- * The reason is that hotspot can't safely turn off asynclogging dyanmically. \n+ * Note: This runs the asynclog parts of gtest in async mode.\n+ * The reason is that hotspot can't safely turn off asynclogging dyanmically.\n","filename":"test\/hotspot\/jtreg\/gtest\/AsyncLogGtest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}