{"files":[{"patch":"@@ -75,2 +75,2 @@\n-\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsages.\n-\/\/ the mutex here gurantees its integrity.\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsage.\n+\/\/ The lock here gurantees its integrity.\n@@ -91,0 +91,2 @@\n+  } else {\n+    log_warning(logging, thread)(\"AsyncLogging failed to create thread. Falling back to synchronous logging.\");\n@@ -118,1 +120,1 @@\n-void AsyncLogWriter::perform_IO() {\n+void AsyncLogWriter::write() {\n@@ -121,1 +123,1 @@\n-  \/\/ Along with logs destruction, all procceeded messages are deleted.\n+  \/\/ Along with logs destruction, all processed messages are deleted.\n@@ -148,1 +150,1 @@\n-  assert(_state == ThreadState::Running, \"sanity check\");\n+  _state = ThreadState::Running;\n@@ -151,0 +153,2 @@\n+    \/\/ The value of a semphore cannot be negative. Therefore, the current thread falls asleep\n+    \/\/ when its value is zero. It will be waken up when new messages are enqueued.\n@@ -152,1 +156,1 @@\n-    perform_IO();\n+    write();\n@@ -154,3 +158,0 @@\n-\n-  assert(_state == ThreadState::Terminated, \"sanity check\");\n-  perform_IO(); \/\/ in case there are some messages left\n@@ -164,16 +165,10 @@\n-  if (_instance == nullptr) {\n-    AsyncLogWriter* self = new AsyncLogWriter();\n-\n-    if (self->_state == ThreadState::Initialized) {\n-      Atomic::release_store_fence(&AsyncLogWriter::_instance, self);\n-      \/\/ All readers of _instance after the fence see non-NULL.\n-      \/\/ We make use LogOutputList's RCU counters to ensure all synchronous logsites have completed.\n-      \/\/ After that, we start AsyncLog Thread and it exclusively takee over all logging I\/O.\n-      for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n-        ts->wait_until_no_readers();\n-      }\n-      self->_state = ThreadState::Running;\n-      os::start_thread(self);\n-      log_debug(logging, thread)(\"AsyncLogging starts working.\");\n-    } else {\n-      log_warning(logging, thread)(\"AsyncLogging failed to launch thread. fall back to synchronous logging.\");\n+  assert(_instance == nullptr, \"initialize() should only be invoked once.\");\n+\n+  AsyncLogWriter* self = new AsyncLogWriter();\n+  if (self->_state == ThreadState::Initialized) {\n+    Atomic::release_store_fence(&AsyncLogWriter::_instance, self);\n+    \/\/ All readers of _instance after the fence see non-NULL.\n+    \/\/ We use LogOutputList's RCU counters to ensure all synchronous logsites have completed.\n+    \/\/ After that, we start AsyncLog Thread and it exclusively takes over all logging I\/O.\n+    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+      ts->wait_until_no_readers();\n@@ -181,0 +176,2 @@\n+    os::start_thread(self);\n+    log_debug(logging, thread)(\"Async logging thread started.\");\n@@ -190,1 +187,1 @@\n-    _instance->perform_IO();\n+    _instance->write();\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":23,"deletions":26,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -24,2 +24,2 @@\n-#ifndef SHARE_LOG_ASYNC_WTRITER_HPP\n-#define SHARE_LOG_ASYNC_WTRITER_HPP\n+#ifndef SHARE_LOGGING_LOGASYNCWRITER_HPP\n+#define SHARE_LOGGING_LOGASYNCWRITER_HPP\n@@ -113,1 +113,23 @@\n-class AsyncLogWriter: public NonJavaThread {\n+\/\/\n+\/\/ ASYNC LOGGING SUPPORT\n+\/\/\n+\/\/ Summary:\n+\/\/ Async Logging is working on the basis of singleton AsyncLogWriter, which manages an immediate buffer and a flushing thread.\n+\/\/\n+\/\/ Interface:\n+\/\/\n+\/\/ initialize() is called once when JVM is initialized. It creates and initializes the singleton instance of AsyncLogWriter.\n+\/\/ Once async logging is established, there's no way to turn it off.\n+\/\/\n+\/\/ instance() is MT-safe and returns the pointer of the singleton instance if and only if async logging is enabled and has well\n+\/\/ initialized. Clients can use its return value to determine async logging is established or not.\n+\/\/\n+\/\/ The basic operation of AsyncLogWriter is enqueue(). 2 overloading versions of it are provided to match LogOutput::write().\n+\/\/ They are both MT-safe and non-blocking. Derived classes of LogOutput can invoke the corresponding enqueue() in write() and\n+\/\/ return 0. AsyncLogWriter is responsible of copying neccessary data.\n+\/\/\n+\/\/ The static member function flush() is designated to flush out all pending messages when JVM is terminating or aborting.\n+\/\/ In normal JVM termination, flush() is invoked in LogConfiguration::finalize(). In abortion situation, flush() is invoked in\n+\/\/ os::shutdown(). flush() is MT-safe and can be invoked arbitrary times. It is no-op if async logging is not established.\n+\/\/\n+class AsyncLogWriter : public NonJavaThread {\n@@ -115,0 +137,1 @@\n+  \/\/ _sem is a semaphore whose value denotes how many messages have been enqueued.\n@@ -125,1 +148,1 @@\n-  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n+  AsyncLogMap _stats; \/\/ statistics for dropped messages\n@@ -128,1 +151,1 @@\n-  \/\/ The memory use of each AsyncLogMessage(payload) consist of itself and a variable-length c-str message.\n+  \/\/ The memory use of each AsyncLogMessage (payload) consists of itself and a variable-length c-str message.\n@@ -134,1 +157,1 @@\n-  void perform_IO();\n+  void write();\n@@ -152,1 +175,0 @@\n-  \/\/ None of following functions are thread-safe.\n@@ -158,1 +180,1 @@\n-#endif \/\/ SHARE_LOG_ASYNC_WTRITER_HPP\n+#endif \/\/ SHARE_LOGGING_LOGASYNCWRITER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":30,"deletions":8,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-  out->print_cr(\"\\nAsynchronous logging(off by default):\");\n+  out->print_cr(\"\\nAsynchronous logging (off by default):\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -312,1 +312,1 @@\n-    return -1;\n+    return 0;\n@@ -327,1 +327,1 @@\n-    return -1;\n+    return 0;\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1993,1 +1993,1 @@\n-          \"Memory budget(in bytes) for the buffer of Asynchronous \"         \\\n+          \"Memory budget (in bytes) for the buffer of Asynchronous \"        \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}