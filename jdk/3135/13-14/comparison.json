{"files":[{"patch":"@@ -32,1 +32,1 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -1950,1 +1950,3 @@\n-  LogAsyncFlusher::abort();\n+  \/\/ flush buffered messages\n+  AsyncLogWriter::flush();\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -1099,1 +1099,3 @@\n-  LogAsyncFlusher::abort();\n+  \/\/ flush buffered messages\n+  AsyncLogWriter::flush();\n+\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,233 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-#include \"precompiled.hpp\"\n-#include \"jvm.h\"\n-#include \"logging\/logAsyncFlusher.hpp\"\n-#include \"logging\/logConfiguration.hpp\"\n-#include \"logging\/logFileOutput.hpp\"\n-#include \"logging\/logHandle.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-\n-void AsyncLogMessage::writeback() {\n-  if (_message != NULL) {\n-    _output.write_blocking(_decorations, _message);\n-    os::free(_message);\n-  }\n-}\n-\n-void LogAsyncFlusher::enqueue_impl(const AsyncLogMessage& msg) {\n-  assert_lock_strong(&_lock);\n-\n-  if (_buffer.size() >= _buffer_max_size)  {\n-    const AsyncLogMessage* h = _buffer.front();\n-    assert(h != NULL, \"sanity check\");\n-\n-    if (h->message() != nullptr) {\n-      bool p_created;\n-      uint32_t* counter = _stats.add_if_absent(h->output(), 0, &p_created);\n-      *counter = *counter + 1;\n-\n-      if (Verbose) {\n-        \/\/ Temporarily turn off SerializeVMOutput so defaultStream will not\n-        \/\/ invoke set_owner(self) for tty_lock.\n-        FlagSetting t(SerializeVMOutput, false);\n-        \/\/ The writing below can not guarantee non-blocking because tty may be piped by the filesystems\n-        \/\/ or throttled by XOFF, so only dump the dropping message in Verbose mode.\n-        tty->print_cr(\"asynclog dropping message: %s\", h->message());\n-      }\n-    }\n-\n-    _buffer.pop_front();\n-  }\n-  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n-  _buffer.push_back(msg);\n-\n-  \/\/ notify asynclog thread if occupancy is over 3\/4\n-  size_t sz = _buffer.size();\n-  if (sz > (_buffer_max_size >> 2) * 3 ) {\n-    _lock.notify();\n-  }\n-}\n-\n-void LogAsyncFlusher::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n-  AsyncLogMessage m(output, decorations, os::strdup(msg));\n-\n-  { \/\/ critical area\n-    \/\/ The rank of _lock is same as _tty_lock on purpuse.\n-    \/\/ if logging thread is holding _tty_lock now, temporarily yield to _lock.\n-    ttyUnlocker ttyul;\n-    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-    enqueue_impl(m);\n-  }\n-}\n-\n-\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsages.\n-\/\/ the mutex here gurantees its integrity.\n-void LogAsyncFlusher::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n-  ttyUnlocker ttyul;\n-  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-\n-  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n-    AsyncLogMessage m(output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n-    enqueue_impl(m);\n-  }\n-}\n-\n-LogAsyncFlusher::LogAsyncFlusher()\n-  : _state(ThreadState::Running),\n-    _lock(Mutex::tty, \"async-log-monitor\", true \/* allow_vm_block *\/, Mutex::_safepoint_check_never),\n-    _stats(17 \/*table_size*\/) {\n-  if (os::create_thread(this, os::asynclog_thread)) {\n-    os::start_thread(this);\n-  }\n-\n-  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n-                    _buffer_max_size, AsyncLogBufferSize);\n-}\n-\n-bool AsyncLogMapIterator::do_entry(LogFileOutput* output, uint32_t* counter) {\n-  using dummy = LogTagSetMapping<LogTag::__NO_TAG>;\n-  LogDecorations decorations(LogLevel::Warning, dummy::tagset(), output->decorators());\n-  const int sz = 128;\n-  char out_of_band[sz];\n-\n-  if (*counter > 0) {\n-    jio_snprintf(out_of_band, sz, UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n-    output->write_blocking(decorations, out_of_band);\n-    *counter = 0;\n-  }\n-\n-  return true;\n-}\n-\n-void LogAsyncFlusher::writeback(const LinkedList<AsyncLogMessage>& logs) {\n-  LinkedListIterator<AsyncLogMessage> it(logs.head());\n-  while (!it.is_empty()) {\n-    AsyncLogMessage* e = it.next();\n-    e->writeback();\n-  }\n-}\n-\n-void LogAsyncFlusher::flush(bool with_lock) {\n-  LinkedListImpl<AsyncLogMessage, ResourceObj::C_HEAP, mtLogging> logs;\n-\n-  if (with_lock) { \/\/ critical area\n-    \/\/ Caveat: current thread must not hold _tty_lock or other lower rank lockers.\n-    \/\/ Cannot install ttyUnlocker here because flush() may be invoked before defaultStream\n-    \/\/ initialization.\n-    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n-    _buffer.pop_all(&logs);\n-    AsyncLogMapIterator iter;\n-    _stats.iterate(&iter);\n-  } else {\n-    \/\/ C++ lambda can simplify the code snippet.\n-    _buffer.pop_all(&logs);\n-    AsyncLogMapIterator iter;\n-    _stats.iterate(&iter);\n-  }\n-\n-  writeback(logs);\n-}\n-\n-void LogAsyncFlusher::run() {\n-  while (_state == ThreadState::Running) {\n-    {\n-      MonitorLocker m(&_lock, Mutex::_no_safepoint_check_flag);\n-      m.wait(ASYNCLOG_WAIT_TIMEOUT);\n-    }\n-    flush();\n-  }\n-\n-  \/\/ Signal thread has terminated\n-  MonitorLocker ml(Terminator_lock);\n-  _state = ThreadState::Terminated;\n-  ml.notify_all();\n-}\n-\n-LogAsyncFlusher* LogAsyncFlusher::_instance = nullptr;\n-\n-void LogAsyncFlusher::initialize() {\n-  if (!LogConfiguration::is_async_mode()) return;\n-\n-  if (_instance == NULL) {\n-    Atomic::release_store(&LogAsyncFlusher::_instance, new LogAsyncFlusher());\n-  }\n-}\n-\n-\/\/ Termination\n-\/\/ 1. issue an atomic release_store to close the logging window.\n-\/\/ 2. flush itself in-place.\n-\/\/ 3. signal asynclog thread to exit.\n-\/\/ 4. wait until asynclog thread exits.\n-\/\/ 5. (optional) delete this in post_run().\n-void LogAsyncFlusher::terminate() {\n-  if (_instance != NULL) {\n-    LogAsyncFlusher* self = _instance;\n-\n-    Atomic::release_store<LogAsyncFlusher*, LogAsyncFlusher*>(&_instance, nullptr);\n-    self->flush();\n-    {\n-      MonitorLocker ml(&self->_lock, Mutex::_no_safepoint_check_flag);\n-      self->_state = ThreadState::Terminating;\n-      ml.notify();\n-    }\n-    {\n-      MonitorLocker ml(Terminator_lock, Mutex::_no_safepoint_check_flag);\n-      while (self->_state != ThreadState::Terminated) {\n-        ml.wait();\n-      }\n-    }\n-  }\n-}\n-\n-LogAsyncFlusher* LogAsyncFlusher::instance() {\n-  \/\/ thread may has been detached, then Thread::current() used by Mutex is inavailable.\n-  \/\/ eg. ThreadsSMRSupport::smr_delete() uses log_debug() after delete thread.\n-  if (Thread::current_or_null() != nullptr) {\n-    return _instance;\n-  } else {\n-    return nullptr;\n-  }\n-}\n-\n-\/\/ Different from terminate(), abort is invoked by os::abort().\n-\/\/ There are 2 constraints:\n-\/\/ 1. must be async-safe because os::abort() may be invoked by a signal handler while other\n-\/\/ threads are executing.\n-\/\/ 2. must not obtain _lock. eg. gtest.MutexRank.mutex_lock_access_leaf(test_mutex_rank.cpp)\n-\/\/ holds a 'assess' lock and then traps SIGSEGV on purpose.\n-\/\/\n-\/\/ Unlike terminate, abort() just ensures all pending log messages are flushed. It doesnot\n-\/\/ exit asynclog thread.\n-void LogAsyncFlusher::abort() {\n-  if (_instance != nullptr) {\n-    \/\/ To meet prior constraints, I borrow the idea in LogConfiguration::disable_outputs(),\n-    \/\/ the following code shut down all outputs for all tagsets with a RCU synchroniziation.\n-    \/\/ After then, I can flush pending queue without a lock.\n-    for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n-      ts->disable_outputs();\n-    }\n-    _instance->flush(false \/*with_lock*\/);\n-  }\n-}\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":0,"deletions":233,"binary":false,"changes":233,"status":"deleted"},{"patch":"@@ -1,162 +0,0 @@\n-\/*\n- * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-#ifndef SHARE_LOGGING_ASYNC_FLUSHER_HPP\n-#define SHARE_LOGGING_ASYNC_FLUSHER_HPP\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logDecorations.hpp\"\n-#include \"logging\/logFileOutput.hpp\"\n-#include \"logging\/logMessageBuffer.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/nonJavaThread.hpp\"\n-#include \"utilities\/hashtable.hpp\"\n-#include \"utilities\/linkedlist.hpp\"\n-\n-template <typename E, MEMFLAGS F>\n-class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n- private:\n-  LinkedListNode<E>* _tail;\n-  size_t _size;\n-\n- public:\n-  LinkedListDeque() : _tail(NULL), _size(0) {}\n-  void push_back(const E& e) {\n-    if (!_tail) {\n-      _tail = this->add(e);\n-    } else {\n-      _tail = this->insert_after(e, _tail);\n-    }\n-\n-    ++_size;\n-  }\n-\n-  void pop_all(LinkedList<E>* logs) {\n-    logs->move(static_cast<LinkedList<E>* >(this));\n-    _tail = NULL;\n-    _size = 0;\n-  }\n-\n-  void pop_front() {\n-    LinkedListNode<E>* h = this->unlink_head();\n-    if (h == _tail) {\n-      _tail = NULL;\n-    }\n-\n-    if (h != NULL) {\n-      --_size;\n-      this->delete_node(h);\n-    }\n-  }\n-\n-  size_t size() const { return _size; }\n-\n-  const E* front() const {\n-    return this->_head == NULL ? NULL : this->_head->peek();\n-  }\n-\n-  const E* back() const {\n-    return _tail == NULL ? NULL : _tail->peek();\n-  }\n-};\n-\n-class AsyncLogMessage {\n-  LogFileOutput&   _output;\n-  const LogDecorations _decorations;\n-  char*            _message;\n-\n-public:\n-  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, char* msg)\n-    : _output(output), _decorations(decorations), _message(msg) {}\n-\n-  void writeback();\n-\n-  \/\/ two AsyncLogMessage are equal if both _output and _message are same.\n-  bool equals(const AsyncLogMessage& o) const {\n-    if (_message == o._message) {\n-      return &_output == &o._output;\n-    } else if (_message == NULL || o._message == NULL) {\n-      return false;\n-    } else {\n-      return &_output == &o._output && !strcmp(_message, o._message);\n-    }\n-  }\n-\n-  const char* message() const { return _message; }\n-  LogFileOutput* output() const { return &_output; }\n-};\n-\n-typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n-typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n-struct AsyncLogMapIterator {\n-  bool do_entry(LogFileOutput* output, uint32_t* counter);\n-};\n-\n-class LogAsyncFlusher : public NonJavaThread {\n- private:\n-  static LogAsyncFlusher* _instance;\n-\n-  enum class ThreadState {\n-    Running = 0,\n-    Terminating,\n-    Terminated\n-  };\n-\n-  volatile ThreadState _state;\n-  \/\/ The semantics of _lock is more like a Java monitor.\n-  \/\/ AssyncLog thread sleeps on _lock until the occupancy of the buffer is over 3\/4, or timeout\n-  \/\/ It also acts as a mutex to consolidate buffer's MT-safety.\n-  Monitor _lock;\n-  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n-  AsyncLogBuffer _buffer;\n-\n-  \/\/ The memory use of each AsyncLogMessage(payload) consist of itself, a logDecoration object\n-  \/\/ and a variable-length c-string message.\n-  \/\/ A normal logging  message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n-  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + sizeof(LogDecorations) + vwrite_buffer_size)};\n-  static const int64_t ASYNCLOG_WAIT_TIMEOUT = 500; \/\/ timeout in millisecond.\n-\n-  LogAsyncFlusher();\n-  void enqueue_impl(const AsyncLogMessage& msg);\n-  static void writeback(const LinkedList<AsyncLogMessage>& logs);\n-  void run() override;\n-  void pre_run() override {\n-    NonJavaThread::pre_run();\n-    log_debug(logging, thread)(\"starting AsyncLog Thread tid = \" INTX_FORMAT, os::current_thread_id());\n-  }\n-  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n-\n- public:\n-  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n-  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n-  \/\/ Use with_lock = false at your own risk. It is only safe without any active reader.\n-  void flush(bool with_lock = true);\n-\n-  static LogAsyncFlusher* instance();\n-  \/\/ None of following functions are thread-safe.\n-  static void initialize();\n-  static void terminate();\n-  static void abort();\n-};\n-\n-#endif \/\/ SHARE_LOGGING_ASYNC_FLUSHER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":0,"deletions":162,"binary":false,"changes":162,"status":"deleted"},{"patch":"@@ -0,0 +1,191 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"logging\/logAsyncWriter.hpp\"\n+#include \"logging\/logConfiguration.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+Semaphore AsyncLogWriter::_sem(0);\n+\n+class AsyncLogLocker : public StackObj {\n+ private:\n+  debug_only(static intx _locking_thread_id;)\n+  static Semaphore _lock;\n+ public:\n+  AsyncLogLocker() {\n+    _lock.wait();\n+    debug_only(_locking_thread_id = os::current_thread_id());\n+  }\n+\n+  ~AsyncLogLocker() {\n+    debug_only(_locking_thread_id = -1);\n+    _lock.signal();\n+  }\n+};\n+\n+Semaphore AsyncLogLocker::_lock(1);\n+debug_only(intx AsyncLogLocker::_locking_thread_id = -1;)\n+\n+void AsyncLogWriter::enqueue_locked(const AsyncLogMessage& msg) {\n+  if (_buffer.size() >= _buffer_max_size)  {\n+    const AsyncLogMessage* h = _buffer.front();\n+    assert(h != NULL, \"sanity check\");\n+\n+    if (h->message() != nullptr) {\n+      bool p_created;\n+      uint32_t* counter = _stats.add_if_absent(h->output(), 0, &p_created);\n+      *counter = *counter + 1;\n+    }\n+\n+    _buffer.pop_front();\n+  }\n+  assert(_buffer.size() < _buffer_max_size, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n+  _sem.signal();\n+}\n+\n+void AsyncLogWriter::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+  AsyncLogMessage m(output, decorations, os::strdup(msg));\n+\n+  { \/\/ critical area\n+    AsyncLogLocker lock;\n+    enqueue_locked(m);\n+  }\n+}\n+\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsages.\n+\/\/ the mutex here gurantees its integrity.\n+void AsyncLogWriter::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  AsyncLogLocker lock;\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), os::strdup(msg_iterator.message()));\n+    enqueue_locked(m);\n+  }\n+}\n+\n+AsyncLogWriter::AsyncLogWriter()\n+  : _state(ThreadState::NotReady),\n+    _stats(17 \/*table_size*\/) {\n+  if (os::create_thread(this, os::asynclog_thread)) {\n+    _state = ThreadState::Initialized;\n+  }\n+\n+  log_info(logging)(\"The maximum entries of AsyncLogBuffer: \" SIZE_FORMAT \", estimated memory use: \" SIZE_FORMAT \" bytes\",\n+                    _buffer_max_size, AsyncLogBufferSize);\n+}\n+\n+bool AsyncLogMapIterator::do_entry(LogFileOutput* output, uint32_t* counter) {\n+  using none = LogTagSetMapping<LogTag::__NO_TAG>;\n+  LogDecorations decorations(LogLevel::Warning, none::tagset(), output->decorators());\n+  const int sz = 128;\n+  char out_of_band[sz];\n+\n+  if (*counter > 0) {\n+    jio_snprintf(out_of_band, sz, UINT32_FORMAT_W(6) \" messages dropped due to async logging\", *counter);\n+    output->write_blocking(decorations, out_of_band);\n+    *counter = 0;\n+  }\n+\n+  return true;\n+}\n+\n+void AsyncLogWriter::perform_IO() {\n+  \/\/ use copy-and-swap idiom here.\n+  \/\/ 'logs' swaps content with _buffer.\n+  \/\/ Along with logs destruction, all procceeded messages are deleted.\n+  \/\/\n+  \/\/ the atomic operation is done in O(1). All I\/O jobs are done without lock.\n+  \/\/ This guarantees I\/O jobs don't block logsites.\n+  LinkedListImpl<AsyncLogMessage, ResourceObj::C_HEAP, mtLogging> logs;\n+  { \/\/ critical region\n+    AsyncLogLocker ml;\n+\n+    _buffer.pop_all(&logs);\n+    AsyncLogMapIterator iter;\n+    _stats.iterate(&iter);\n+  }\n+\n+  LinkedListIterator<AsyncLogMessage> it(logs.head());\n+  while (!it.is_empty()) {\n+    AsyncLogMessage* e = it.next();\n+    char* msg = e->message();\n+\n+    if (msg != nullptr) {\n+      e->output()->write_blocking(e->decorations(), msg);\n+      os::free(msg);\n+    }\n+  }\n+}\n+\n+void AsyncLogWriter::run() {\n+  assert(_state == ThreadState::Running, \"sanity check\");\n+\n+  while (_state == ThreadState::Running) {\n+    _sem.wait();\n+    perform_IO();\n+  }\n+\n+  assert(_state == ThreadState::Terminated, \"sanity check\");\n+  perform_IO(); \/\/ in case there are some messages left\n+}\n+\n+AsyncLogWriter* AsyncLogWriter::_instance = nullptr;\n+\n+void AsyncLogWriter::initialize() {\n+  if (!LogConfiguration::is_async_mode()) return;\n+\n+  if (_instance == nullptr) {\n+    AsyncLogWriter* self = new AsyncLogWriter();\n+\n+    if (self->_state == ThreadState::Initialized) {\n+      Atomic::release_store_fence(&AsyncLogWriter::_instance, self);\n+      \/\/ all readers of _instance after fence see NULL,\n+      \/\/ but we still need to ensure no active reader of any tagset.\n+      \/\/ After then, we start AsyncLog Thread and it exclusively takes\n+      \/\/ over all logging I\/O.\n+      for (LogTagSet* ts = LogTagSet::first(); ts != NULL; ts = ts->next()) {\n+        ts->wait_until_no_readers();\n+      }\n+      self->_state = ThreadState::Running;\n+      os::start_thread(self);\n+      log_debug(logging, thread)(\"AsyncLogging starts working.\");\n+    } else {\n+      log_warning(logging, thread)(\"AsyncLogging failed to launch thread. fall back to synchronous logging.\");\n+    }\n+  }\n+}\n+\n+AsyncLogWriter* AsyncLogWriter::instance() {\n+  return _instance;\n+}\n+\n+void AsyncLogWriter::flush() {\n+  if (_instance != nullptr) {\n+    _instance->perform_IO();\n+  }\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.cpp","additions":191,"deletions":0,"binary":false,"changes":191,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_LOG_ASYNC_WTRITER_HPP\n+#define SHARE_LOG_ASYNC_WTRITER_HPP\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logDecorations.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logMessageBuffer.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/nonJavaThread.hpp\"\n+#include \"utilities\/hashtable.hpp\"\n+#include \"utilities\/linkedlist.hpp\"\n+\n+template <typename E, MEMFLAGS F>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n+ private:\n+  LinkedListNode<E>* _tail;\n+  size_t _size;\n+\n+ public:\n+  LinkedListDeque() : _tail(NULL), _size(0) {}\n+  void push_back(const E& e) {\n+    if (!_tail) {\n+      _tail = this->add(e);\n+    } else {\n+      _tail = this->insert_after(e, _tail);\n+    }\n+\n+    ++_size;\n+  }\n+\n+  void pop_all(LinkedList<E>* logs) {\n+    logs->move(static_cast<LinkedList<E>* >(this));\n+    _tail = NULL;\n+    _size = 0;\n+  }\n+\n+  void pop_front() {\n+    LinkedListNode<E>* h = this->unlink_head();\n+    if (h == _tail) {\n+      _tail = NULL;\n+    }\n+\n+    if (h != NULL) {\n+      --_size;\n+      this->delete_node(h);\n+    }\n+  }\n+\n+  size_t size() const { return _size; }\n+\n+  const E* front() const {\n+    return this->_head == NULL ? NULL : this->_head->peek();\n+  }\n+\n+  const E* back() const {\n+    return _tail == NULL ? NULL : _tail->peek();\n+  }\n+};\n+\n+class AsyncLogMessage {\n+  LogFileOutput& _output;\n+  const LogDecorations _decorations;\n+  char* _message;\n+\n+public:\n+  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, char* msg)\n+    : _output(output), _decorations(decorations), _message(msg) {}\n+\n+  \/\/ placeholder for LinkedListImpl.\n+  bool equals(const AsyncLogMessage& o) const { return false; }\n+\n+  LogFileOutput* output() const { return &_output; }\n+  const LogDecorations& decorations() const { return _decorations; }\n+  char* message() const { return _message; }\n+};\n+\n+typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n+typedef KVHashtable<LogFileOutput*, uint32_t, mtLogging> AsyncLogMap;\n+struct AsyncLogMapIterator {\n+  bool do_entry(LogFileOutput* output, uint32_t* counter);\n+};\n+\n+class AsyncLogWriter: public NonJavaThread {\n+ private:\n+  static AsyncLogWriter* _instance;\n+  static Semaphore _sem;\n+\n+  enum class ThreadState {\n+    NotReady,\n+    Initialized,\n+    Running,\n+    Terminated,\n+  };\n+\n+  volatile ThreadState _state;\n+  AsyncLogMap _stats; \/\/ statistics of dropping messages.\n+  AsyncLogBuffer _buffer;\n+\n+  \/\/ The memory use of each AsyncLogMessage(payload) consist of itself, a logDecoration object\n+  \/\/ and a variable-length c-string message.\n+  \/\/ A normal logging  message is smaller than vwrite_buffer_size, which is defined in logtagset.cpp\n+  const size_t _buffer_max_size = {AsyncLogBufferSize \/ (sizeof(AsyncLogMessage) + sizeof(LogDecorations) + vwrite_buffer_size)};\n+\n+  AsyncLogWriter();\n+  void enqueue_locked(const AsyncLogMessage& msg);\n+  void perform_IO();\n+  void run() override;\n+  void pre_run() override {\n+    NonJavaThread::pre_run();\n+    log_debug(logging, thread)(\"starting AsyncLog Thread tid = \" INTX_FORMAT, os::current_thread_id());\n+  }\n+  char* name() const override { return (char*)\"AsyncLog Thread\"; }\n+\n+ public:\n+  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+\n+  \/\/ None of following functions are thread-safe.\n+  static AsyncLogWriter* instance();\n+  static void initialize();\n+  static void flush();\n+};\n+\n+#endif \/\/ SHARE_LOG_ASYNC_WTRITER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncWriter.hpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -283,2 +283,2 @@\n-  \/\/ ts->disable_outputs() above deletes output_list with RCU synchronization.\n-  \/\/ Therefore, no new logging entry will enter AsyncLog buffer since then.\n+  \/\/ ts->disable_outputs() above has deleted output_list with RCU synchronization.\n+  \/\/ Therefore, no new logging entry can enter AsyncLog buffer for the time being.\n@@ -286,4 +286,1 @@\n-  LogAsyncFlusher* async = LogAsyncFlusher::instance();\n-  if (async != nullptr) {\n-    async->flush();\n-  }\n+  AsyncLogWriter::flush();\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -309,3 +309,3 @@\n-  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n-  if (flusher != NULL) {\n-    flusher->enqueue(*this, decorations, msg);\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, decorations, msg);\n@@ -324,3 +324,3 @@\n-  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n-  if (flusher != NULL) {\n-    flusher->enqueue(*this, msg_iterator);\n+  AsyncLogWriter* aio_writer = AsyncLogWriter::instance();\n+  if (aio_writer != nullptr) {\n+    aio_writer->enqueue(*this, msg_iterator);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,2 +35,0 @@\n-  friend class AsyncLogMessage;\n-  friend struct AsyncLogMapIterator;\n@@ -84,1 +82,0 @@\n-  int write_blocking(const LogDecorations& decorations, const char* msg);\n@@ -91,0 +88,1 @@\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  void wait_until_no_readers() const;\n@@ -94,0 +93,1 @@\n+  void wait_until_no_readers() const;\n","filename":"src\/hotspot\/share\/logging\/logOutputList.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,0 +70,4 @@\n+  void wait_until_no_readers() const {\n+    _output_list.wait_until_no_readers();\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logTagSet.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -127,1 +127,1 @@\n-  LogAsyncFlusher::initialize();\n+  AsyncLogWriter::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,0 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n@@ -3424,3 +3423,0 @@\n-  \/\/ stop AsyncLog Thread\n-  LogAsyncFlusher::terminate();\n-\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logAsyncWriter.hpp\"\n@@ -35,6 +35,6 @@\n-\/\/ So far, shutdown asynclogging on-the-fly can only be done in vmthread.\n-\/\/ Use it only in gtest.\n-class AsyncLogDisabler : public VM_GTestExecuteAtSafepoint {\n-  void doit() override {\n-    LogConfiguration::set_async_mode(false);\n-    LogAsyncFlusher::terminate();\n+class AsyncLogTest : public LogTestFixture {\n+ public:\n+  AsyncLogTest() {\n+    if(!LogConfiguration::is_async_mode()) {\n+      fprintf(stderr, \"Warning: asynclog is OFF.\\n\");\n+    }\n@@ -42,1 +42,0 @@\n-};\n@@ -44,2 +43,5 @@\n-class AsyncLogTest : public LogTestFixture {\n-  const bool _saved_async_mode;\n+  void test_asynclog_ls() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n@@ -47,4 +49,5 @@\n- public:\n-  AsyncLogTest() : _saved_async_mode(LogConfiguration::is_async_mode()) {\n-    LogConfiguration::set_async_mode(true);\n-    LogAsyncFlusher::initialize();\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n@@ -53,6 +56,14 @@\n-  ~AsyncLogTest() {\n-    if (!_saved_async_mode) {\n-      AsyncLogDisabler op;\n-      ThreadInVMfromNative invm(JavaThread::current());\n-      VMThread::execute(&op);\n-    }\n+  void test_asynclog_raw() {\n+    Log(logging) logger;\n+#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n+LOG_LEVEL_LIST\n+#undef LOG_LEVEL\n+\n+    LogTarget(Trace, logging) t;\n+    LogTarget(Debug, logging) d;\n+    EXPECT_FALSE(t.is_enabled());\n+    EXPECT_TRUE(d.is_enabled());\n+\n+    d.print(\"AsyncLogTarget.print = %d\", 1);\n+    log_trace(logging)(\"log_trace-test\");\n+    log_debug(logging)(\"log_debug-test\");\n@@ -62,1 +73,1 @@\n-TEST_VM_F(AsyncLogTest, fifo) {\n+TEST_VM(AsyncLogBufferTest, fifo) {\n@@ -67,2 +78,2 @@\n-  EXPECT_EQ(fifo.size(), (size_t)1);\n-  EXPECT_EQ(*(fifo.back()), 1);\n+  EXPECT_EQ((size_t)1, fifo.size());\n+  EXPECT_EQ(1, *(fifo.back()));\n@@ -71,1 +82,1 @@\n-  EXPECT_EQ(fifo.size(), (size_t)0);\n+  EXPECT_EQ((size_t)0, fifo.size());\n@@ -73,2 +84,2 @@\n-  EXPECT_EQ(result.size(), (size_t)1);\n-  EXPECT_EQ(*(result.head()->data()), 1);\n+  EXPECT_EQ((size_t)1, result.size());\n+  EXPECT_EQ(1, *(result.head()->data()));\n@@ -80,3 +91,3 @@\n-  EXPECT_EQ(result.size(), (size_t)2);\n-  EXPECT_EQ(*(result.head()->data()), 2);\n-  EXPECT_EQ(*(result.head()->next()->data()), 1);\n+  EXPECT_EQ((size_t)2, result.size());\n+  EXPECT_EQ(2, *(result.head()->data()));\n+  EXPECT_EQ(1, *(result.head()->next()->data()));\n@@ -90,1 +101,1 @@\n-  EXPECT_EQ(result.size(), (size_t)N);\n+  EXPECT_EQ((size_t)N, result.size());\n@@ -94,1 +105,1 @@\n-    EXPECT_EQ(*e, i);\n+    EXPECT_EQ(i, *e);\n@@ -98,1 +109,1 @@\n-TEST_VM_F(AsyncLogTest, deque) {\n+TEST_VM(AsyncLogBufferTest, deque) {\n@@ -108,3 +119,3 @@\n-  EXPECT_EQ(*(deque.front()), 0);\n-  EXPECT_EQ(*(deque.back()), N-1);\n-  EXPECT_EQ(deque.size(), (size_t)N);\n+  EXPECT_EQ(0, *(deque.front()));\n+  EXPECT_EQ(N-1, *(deque.back()));\n+  EXPECT_EQ((size_t)N, deque.size());\n@@ -113,3 +124,3 @@\n-  EXPECT_EQ(deque.size(), (size_t)(N - 1));\n-  EXPECT_EQ(*(deque.front()), 1);\n-  EXPECT_EQ(*(deque.back()), N - 1);\n+  EXPECT_EQ((size_t)(N - 1), deque.size());\n+  EXPECT_EQ(1, *(deque.front()));\n+  EXPECT_EQ(N - 1, *(deque.back()));\n@@ -118,3 +129,3 @@\n-  EXPECT_EQ(deque.size(), (size_t)(N - 2));\n-  EXPECT_EQ(*(deque.front()), 2);\n-  EXPECT_EQ(*(deque.back()), N - 1);\n+  EXPECT_EQ((size_t)(N - 2), deque.size());\n+  EXPECT_EQ(2, *(deque.front()));\n+  EXPECT_EQ(N - 1, *(deque.back()));\n@@ -126,3 +137,3 @@\n-  EXPECT_EQ(deque.size(), (size_t)1);\n-  EXPECT_EQ(*(deque.back()), N - 1);\n-  EXPECT_EQ(deque.front(), deque.back());\n+  EXPECT_EQ((size_t)1, deque.size());\n+  EXPECT_EQ(N - 1, *(deque.back()));\n+  EXPECT_EQ(deque.back(), deque.front());\n@@ -131,1 +142,1 @@\n-  EXPECT_EQ(deque.size(), (size_t)0);\n+  EXPECT_EQ((size_t)0, deque.size());\n@@ -134,34 +145,0 @@\n-class VM_TestFlusher: public VM_GTestExecuteAtSafepoint {\n-public:\n-  void doit() {\n-    LogStream ls(Log(logging)::info());\n-    outputStream* os = &ls;\n-    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n-    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n-\n-    \/\/multi-lines\n-    os->print(\"logStream msg1-\");\n-    os->print(\"msg2-\");\n-    os->print(\"msg3\\n\");\n-    os->print_cr(\"logStream newline\");\n-\n-    test_asynclog_raw();\n-  }\n-\n-  void test_asynclog_raw() {\n-    Log(logging) logger;\n-#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n-LOG_LEVEL_LIST\n-#undef LOG_LEVEL\n-\n-    LogTarget(Trace, logging) t;\n-    LogTarget(Debug, logging) d;\n-    EXPECT_FALSE(t.is_enabled());\n-    EXPECT_TRUE(d.is_enabled());\n-\n-    d.print(\"AsyncLogTarget.print = %d\", 1);\n-    log_trace(logging)(\"log_trace-test\");\n-    log_debug(logging)(\"log_debug-test\");\n-  }\n-};\n-\n@@ -171,8 +148,3 @@\n-  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n-  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n-  {\n-    VM_TestFlusher op;\n-    ThreadInVMfromNative invm(JavaThread::current());\n-    VMThread::execute(&op);\n-  }\n-  flusher->flush();\n+  test_asynclog_ls();\n+  test_asynclog_raw();\n+  AsyncLogWriter::flush();\n@@ -198,3 +170,0 @@\n-  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n-  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n-\n@@ -216,1 +185,1 @@\n-  flusher->flush();\n+  AsyncLogWriter::flush();\n@@ -235,9 +204,13 @@\n-  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n-  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n-  \/\/ shrink async buffer.\n-  AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n-  LogMessage(logging) lm;\n-\n-  \/\/ write 100x more messages than its capacity in burst\n-  for (size_t i = 0; i < sz * 100; ++i) {\n-    lm.debug(\"a lot of log...\");\n+\n+  if (AsyncLogWriter::instance() != nullptr) {\n+    \/\/ shrink async buffer.\n+    AutoModifyRestore<size_t> saver(AsyncLogBufferSize, sz * 1024 \/*in byte*\/);\n+    LogMessage(logging) lm;\n+\n+    \/\/ write 100x more messages than its capacity in burst\n+    for (size_t i = 0; i < sz * 100; ++i) {\n+      lm.debug(\"a lot of log...\");\n+    }\n+    lm.flush();\n+    AsyncLogWriter::flush();\n+    EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n@@ -245,3 +218,0 @@\n-  lm.flush();\n-  flusher->flush();\n-  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"messages dropped due to async logging\"));\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":73,"deletions":103,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * Note: This runs the asynclog parts of gtest in async mode. \n+ * The reason is that hotspot can't safely turn off asynclogging dyanmically. \n+ * There's no TEST_OTHER_VM_F.\n+ *\/\n+\n+\/* @test\n+ * @summary Run asynclog gtest in async mode.\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.xml\n+ * @run main\/native GTestWrapper --gtest_filter=AsyncLogTest* -Xlog:async\n+ *\/\n","filename":"test\/hotspot\/jtreg\/gtest\/AsyncLogGtest.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"}]}