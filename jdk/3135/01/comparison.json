{"files":[{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logFileOutput.hpp\"\n+#include \"logging\/logHandle.hpp\"\n+\n+void AsyncLogMessage::writeback() {\n+  if (_message != NULL) {\n+    \/\/ should cache this object somehow\n+    LogDecorations decorations(_level, _tagset, _decorators);\n+    _output.write_blocking(decorations, _message);\n+  }\n+}\n+\n+void LogAsyncFlusher::enqueue_impl(const AsyncLogMessage& msg) {\n+  assert_lock_strong(&_lock);\n+\n+  if (_buffer.size() >= AsyncLogBufferSize)  {\n+    if (Verbose) {\n+      const AsyncLogMessage* h = _buffer.front();\n+      assert(h != NULL, \"sanity check\");\n+      if (h->message() != NULL) {\n+        \/\/ Temporarily turn off SerializeVMOutput so defaultStream will not\n+        \/\/ invoke set_owner(self) for tty_lock.\n+        FlagSetting t(SerializeVMOutput, false);\n+        \/\/ The writing below can not guarantee non-blocking because tty may be piped by the filesystems\n+        \/\/ or throttled by XOFF, so only dump the dropping message in Verbose mode.\n+        tty->print_cr(\"asynclog dropping message: %s\", h->message());\n+      }\n+    }\n+\n+    _buffer.pop_front();\n+  }\n+  assert(_buffer.size() < AsyncLogBufferSize, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n+}\n+\n+void LogAsyncFlusher::task() {\n+  LinkedListImpl<AsyncLogMessage, ResourceObj::C_HEAP, mtLogging> logs;\n+\n+  { \/\/ critical area\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    _buffer.pop_all(&logs);\n+  }\n+\n+  LinkedListIterator<AsyncLogMessage> it(logs.head());\n+  while (!it.is_empty()) {\n+    AsyncLogMessage* e = it.next();\n+    e->writeback();\n+  }\n+}\n+\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg) {\n+  AsyncLogMessage m(output, decorations, msg);\n+\n+  { \/\/ critical area\n+    MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+    enqueue_impl(m);\n+  }\n+}\n+\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsage.\n+\/\/ the mutex here gurantees its interity.\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), msg_iterator.message());\n+    enqueue_impl(m);\n+  }\n+}\n+\n+LogAsyncFlusher* LogAsyncFlusher::_instance = NULL;\n+\n+void LogAsyncFlusher::initialize() {\n+  if (!_instance) {\n+    _instance = new LogAsyncFlusher(LogAsyncInterval);\n+  }\n+}\n+\n+void LogAsyncFlusher::cleanup() {\n+  if (_instance != NULL) {\n+    _instance->flush();\n+    delete _instance;\n+    _instance = NULL;\n+  }\n+}\n+\n+LogAsyncFlusher* LogAsyncFlusher::instance() {\n+  return _instance;\n+}\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_LOGGING_ASYNC_FLUSHER_HPP\n+#define SHARE_LOGGING_ASYNC_FLUSHER_HPP\n+#include \"logging\/logDecorations.hpp\"\n+#include \"logging\/logMessageBuffer.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/task.hpp\"\n+#include \"utilities\/linkedlist.hpp\"\n+#include \"utilities\/pair.hpp\"\n+\n+template <typename E>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, mtLogging> {\n+ private:\n+  LinkedListNode<E>* _tail;\n+  size_t _size;\n+\n+ public:\n+  LinkedListDeque() : _tail(NULL), _size(0) {}\n+  void push_back(const E& e) {\n+    if (!_tail)\n+      _tail = this->add(e);\n+    else\n+      _tail = this->insert_after(e, _tail);\n+\n+    ++_size;\n+  }\n+\n+  void pop_all(LinkedList<E>* logs) {\n+    logs->move(static_cast<LinkedList<E>* >(this));\n+    _tail = NULL;\n+    _size = 0;\n+  }\n+\n+  void pop_front() {\n+    LinkedListNode<E>* h = this->unlink_head();\n+    if (h == _tail) {\n+      _tail = NULL;\n+    }\n+\n+    if (h != NULL) {\n+      --_size;\n+      this->delete_node(h);\n+    }\n+  }\n+\n+  size_t size() const { return _size; }\n+\n+  const E* front() const {\n+    return this->_head == NULL ? NULL : this->_head->peek();\n+  }\n+\n+  const E* back() const {\n+    return _tail == NULL ? NULL : _tail->peek();\n+  }\n+};\n+\n+class LogFileOutput;\n+\n+class AsyncLogMessage {\n+  LogFileOutput& _output;\n+  mutable char* _message;\n+  LogDecorators _decorators;\n+  LogLevelType _level;\n+  const LogTagSet& _tagset;\n+\n+public:\n+  AsyncLogMessage(LogFileOutput& output, const LogDecorations& decorations, const char* msg)\n+    : _output(output), _decorators(decorations.get_decorators()),\n+    _level(decorations.get_level()), _tagset(decorations.get_logTagSet()) {\n+      \/\/ allow to fail here, then _message is NULL\n+      _message = os::strdup(msg, mtLogging);\n+    }\n+\n+  ~AsyncLogMessage() {\n+    if (_message != NULL) {\n+      os::free(_message);\n+      _message = NULL;\n+    }\n+  }\n+\n+  AsyncLogMessage(const AsyncLogMessage& o)\n+    :_output(o._output), _decorators(o._decorators), _level(o._level), _tagset(o._tagset) {\n+    _message = o._message;\n+    o._message = NULL; \/\/ transfer the ownership of _message to this\n+  }\n+\n+  void writeback();\n+\n+  bool equals(const AsyncLogMessage& o) const {\n+    return (&_output == &o._output) && (_message == o._message || !strcmp(_message, o._message));\n+  }\n+\n+  const char* message() const { return _message; }\n+};\n+\n+typedef LinkedListDeque<AsyncLogMessage> AsyncLogBuffer;\n+\n+class LogAsyncFlusher : public PeriodicTask {\n+ private:\n+  static LogAsyncFlusher* _instance;\n+  Mutex _lock;\n+  AsyncLogBuffer _buffer;\n+\n+  LogAsyncFlusher(size_t interval\/*ms*\/) : PeriodicTask(interval),\n+                  _lock(Mutex::tty, \"logAsyncFlusher\",\n+                  Mutex::_allow_vm_block_flag, Mutex::_safepoint_check_never) {\n+    this->enroll();\n+  }\n+\n+  void enqueue_impl(const AsyncLogMessage& msg);\n+\n+ protected:\n+  void task();\n+\n+ public:\n+  void enqueue(LogFileOutput& output, const LogDecorations& decorations, const char* msg);\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n+  void flush() { task(); }\n+\n+  \/\/ none of following functions are thread-safe.\n+  \/\/ Meyer's singleton is not thread-safe until C++11.\n+  static void initialize();\n+  static void cleanup();\n+  static LogAsyncFlusher* instance();\n+};\n+\n+#endif \/\/ SHARE_LOGGING_ASYNC_FLUSHER_HPP\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -544,0 +544,1 @@\n+  out->print_cr(\"   async=true|false - write asynchronously or not.\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,15 @@\n+\n+  assert(get_decorators() == decorators, \"sanity check\");\n+}\n+\n+LogDecorators LogDecorations::get_decorators() const {\n+  LogDecorators decorators(LogDecorators::None);\n+\n+#define DECORATOR(full_name, abbr)                                        \\\n+  if (_decoration_offset[LogDecorators::full_name##_decorator] != NULL) { \\\n+    decorators.combine_with(LogDecorators::full_name##_decorator);        \\\n+  }\n+  DECORATOR_LIST\n+#undef DECORATOR\n+\n+  return decorators;\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,6 @@\n+  LogLevelType get_level() const { return _level; }\n+\n+  const LogTagSet& get_logTagSet() const {\n+    return _tagset;\n+  }\n+\n@@ -61,0 +67,2 @@\n+\n+  LogDecorators get_decorators() const;\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,11 @@\n-  };\n+  }\n+\n+  LogDecorators(const LogDecorators& o) : _decorators(o._decorators) {\n+  }\n+\n+  LogDecorators& operator=(const LogDecorators& rhs) {\n+    if (this != &rhs) {\n+      _decorators = rhs._decorators;\n+    }\n+    return *this;\n+  }\n@@ -107,0 +117,4 @@\n+  void combine_with(LogDecorators::Decorator source) {\n+    _decorators |= LogDecorators::mask(source);\n+  }\n+\n@@ -111,0 +125,4 @@\n+  bool operator==(const LogDecorators& rhs) {\n+    return _decorators == rhs._decorators;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -42,0 +43,1 @@\n+const char* const LogFileOutput::AsyncOptionKey = \"async\";\n@@ -48,1 +50,1 @@\n-      _file_count(DefaultFileCount), _is_default_file_count(true), _archive_name_len(0),\n+      _file_count(DefaultFileCount), _is_default_file_count(true), _async_mode(false), _archive_name_len(0),\n@@ -218,0 +220,11 @@\n+    } else if (strcmp(AsyncOptionKey, key) == 0) {\n+      if (strcasecmp(value_str, \"true\") == 0) {\n+        _async_mode = true;\n+      } else if (strcasecmp(value_str, \"false\") == 0) {\n+        _async_mode =false;\n+      } else {\n+        errstream->print_cr(\"Invalid option: %s must be either true or false.\",\n+                            AsyncOptionKey);\n+        success = false;\n+        break;\n+      }\n@@ -287,6 +300,1 @@\n-int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n-  if (_stream == NULL) {\n-    \/\/ An error has occurred with this output, avoid writing to it.\n-    return 0;\n-  }\n-\n+int LogFileOutput::write_blocking(const LogDecorations& decorations, const char* msg) {\n@@ -307,0 +315,15 @@\n+int LogFileOutput::write(const LogDecorations& decorations, const char* msg) {\n+  if (_stream == NULL) {\n+    \/\/ An error has occurred with this output, avoid writing to it.\n+    return 0;\n+  }\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (_async_mode && flusher != NULL) {\n+    flusher->enqueue(*this, decorations, msg);\n+    return 0;\n+  }\n+\n+  return write_blocking(decorations, msg);\n+}\n+\n@@ -313,0 +336,6 @@\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (_async_mode && flusher != NULL) {\n+    flusher->enqueue(*this, msg_iterator);\n+    return -1;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":37,"deletions":8,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+  friend class AsyncLogMessage;\n@@ -39,0 +40,1 @@\n+  static const char* const AsyncOptionKey;\n@@ -58,0 +60,1 @@\n+  bool  _async_mode;\n@@ -82,0 +85,1 @@\n+  int write_blocking(const LogDecorations& decorations, const char* msg);\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,12 @@\n+JVMFlag::Error LogAsyncIntervalConstraintFunc(intx value, bool verbose) {\n+    if ((value % PeriodicTask::interval_gran) != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"LogAsyncInterval (\" INTX_FORMAT \") must be \"\n+                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n+                        value, PeriodicTask::interval_gran);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+  f(intx,   LogAsyncIntervalConstraintFunc)           \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2030,0 +2030,9 @@\n+  product(intx, LogAsyncInterval, 300,                                      \\\n+          \"Milliseconds between asynchronous log flushing\")                 \\\n+          range(PeriodicTask::min_interval, max_jint)                       \\\n+          constraint(LogAsyncIntervalConstraintFunc, AtParse)               \\\n+                                                                            \\\n+  product(size_t, AsyncLogBufferSize, 2*K,                                  \\\n+          \"Entries of the buffer for Async logs\")                           \\\n+          range(100, 100*K)                                                 \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -125,0 +126,1 @@\n+  LogAsyncFlusher::initialize();\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logAsyncFlusher.hpp\"\n@@ -960,0 +961,1 @@\n+  LogAsyncFlusher::cleanup();\n@@ -973,0 +975,5 @@\n+  LogAsyncFlusher* async = LogAsyncFlusher::instance();\n+  if (async != NULL) {\n+    async->flush();\n+  }\n+\n","filename":"src\/hotspot\/share\/utilities\/ostream.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logTestFixture.hpp\"\n+#include \"logTestUtils.inline.hpp\"\n+#include \"logging\/logAsyncFlusher.hpp\"\n+#include \"logging\/logMessage.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/vmOperations.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n+#include \"unittest.hpp\"\n+\n+\n+class AsyncLogTest : public LogTestFixture {\n+};\n+\n+TEST_VM_F(AsyncLogTest, fifo) {\n+  LinkedListDeque<int> fifo;\n+  LinkedListImpl<int, ResourceObj::C_HEAP, mtLogging> result;\n+\n+  fifo.push_back(1);\n+  EXPECT_EQ(fifo.size(), (size_t)1);\n+  EXPECT_EQ(*(fifo.back()), 1);\n+\n+  fifo.pop_all(&result);\n+  EXPECT_EQ(fifo.size(), (size_t)0);\n+  EXPECT_EQ(NULL, fifo.back());\n+  EXPECT_EQ(result.size(), (size_t)1);\n+  EXPECT_EQ(*(result.head()->data()), 1);\n+  result.clear();\n+\n+  fifo.push_back(2);\n+  fifo.push_back(1);\n+  fifo.pop_all(&result);\n+  EXPECT_EQ(result.size(), (size_t)2);\n+  EXPECT_EQ(*(result.head()->data()), 2);\n+  EXPECT_EQ(*(result.head()->next()->data()), 1);\n+  result.clear();\n+  const int N = 1000;\n+  for (int i=0; i<N; ++i) {\n+    fifo.push_back(i);\n+  }\n+  fifo.pop_all(&result);\n+\n+  EXPECT_EQ(result.size(), (size_t)N);\n+  LinkedListIterator<int> it(result.head());\n+  for (int i=0; i<N; ++i) {\n+    int* e = it.next();\n+    EXPECT_EQ(*e, i);\n+  }\n+}\n+\n+TEST_VM_F(AsyncLogTest, deque) {\n+  LinkedListDeque<int> deque;\n+  const int N = 10;\n+\n+  EXPECT_EQ(NULL, deque.front());\n+  EXPECT_EQ(NULL, deque.back());\n+  for (int i = 0; i < N; ++i) {\n+    deque.push_back(i);\n+  }\n+\n+  EXPECT_EQ(*(deque.front()), 0);\n+  EXPECT_EQ(*(deque.back()), N-1);\n+  EXPECT_EQ(deque.size(), (size_t)N);\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)(N - 1));\n+  EXPECT_EQ(*(deque.front()), 1);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)(N - 2));\n+  EXPECT_EQ(*(deque.front()), 2);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+\n+\n+  for (int i=2; i < N-1; ++i) {\n+    deque.pop_front();\n+  }\n+  EXPECT_EQ(deque.size(), (size_t)1);\n+  EXPECT_EQ(*(deque.back()), N - 1);\n+  EXPECT_EQ(deque.front(), deque.back());\n+\n+  deque.pop_front();\n+  EXPECT_EQ(deque.size(), (size_t)0);\n+}\n+\n+class VM_TestFlusher: public VM_GTestExecuteAtSafepoint {\n+public:\n+  void doit() {\n+    LogStream ls(Log(logging)::info());\n+    outputStream* os = &ls;\n+    os->print_cr(\"LogStreamWithAsyncLogImpl\");\n+    os->print_cr(\"LogStreamWithAsyncLogImpl secondline\");\n+\n+    \/\/multi-lines\n+    os->print(\"logStream msg1-\");\n+    os->print(\"msg2-\");\n+    os->print(\"msg3\\n\");\n+    os->print_cr(\"logStream newline\");\n+\n+    test_asynclog_raw();\n+  }\n+\n+  void test_asynclog_raw() {\n+    Log(logging) logger;\n+#define LOG_LEVEL(level, name) logger.name(\"1\" #level);\n+LOG_LEVEL_LIST\n+#undef LOG_LEVEL\n+\n+    LogTarget(Trace, logging) t;\n+    LogTarget(Debug, logging) d;\n+    EXPECT_FALSE(t.is_enabled());\n+    EXPECT_TRUE(d.is_enabled());\n+\n+    d.print(\"AsyncLogTarget.print = %d\", 1);\n+    log_trace(logging)(\"log_trace-test\");\n+    log_debug(logging)(\"log_debug-test\");\n+  }\n+};\n+\n+TEST_VM_F(AsyncLogTest, asynclog) {\n+  set_log_config(TestLogFileName, \"logging=debug\", NULL, \"async=true\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  {\n+    VM_TestFlusher op;\n+    ThreadInVMfromNative invm(JavaThread::current());\n+    VMThread::execute(&op);\n+  }\n+  flusher->flush();\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"LogStreamWithAsyncLogImpl\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream msg1-msg2-msg3\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"logStream newline\"));\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Debug\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Info\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Warning\"));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"1Error\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"1Trace\")); \/\/ trace message is masked out\n+\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"AsyncLogTarget.print = 1\"));\n+  EXPECT_FALSE(file_contains_substring(TestLogFileName, \"log_trace-test\")); \/\/ trace message is masked out\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"log_debug-test\"));\n+}\n+\n+TEST_VM_F(AsyncLogTest, logMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+\n+  const int MULTI_LINES = 20;\n+  {\n+\n+    LogMessage(logging) msg;\n+    Log(logging) logger;\n+\n+    for (int i = 0; i < MULTI_LINES; ++i) {\n+      msg.debug(\"nonbreakable log message line-%02d\", i);\n+\n+      if (0 == (i % 4)) {\n+        logger.debug(\"a noisy message from other logger\");\n+      }\n+    }\n+    logger.debug(\"a noisy message from other logger\");\n+  }\n+  flusher->flush();\n+\n+  ResourceMark rm;\n+  LogMessageBuffer buffer;\n+  const char* strs[MULTI_LINES + 1];\n+  strs[MULTI_LINES] = NULL;\n+  for (int i = 0; i < MULTI_LINES; ++i) {\n+    stringStream ss;\n+    ss.print_cr(\"nonbreakable log message line-%02d\", i);\n+    strs[i] = ss.as_string();\n+  }\n+  \/\/ check nonbreakable log messages are consecutive\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"a noisy message from other logger\"));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"}]}