{"files":[{"patch":"@@ -37,9 +37,18 @@\n-#ifndef PRODUCT\n-template<> void LinkedListDeque<AsyncLogMessage>::log_drop(AsyncLogMessage* e) {\n-  if (Verbose && e->message() != NULL) {\n-    \/\/ Temporarily turn off SerializeVMOutput so defaultStream will not\n-    \/\/ invoke set_owner(self) for tty_lock.\n-    FlagSetting t(SerializeVMOutput, false);\n-    \/\/ The writing below can not guarantee non-blocking because tty may be piped by the filesystems\n-    \/\/ or throttled by XOFF, so only dump the dropping message in Verbose mode.\n-    tty->print_cr(\"asynclog dropping message: %s\", e->message());\n+void LogAsyncFlusher::enqueue_impl(const AsyncLogMessage& msg) {\n+  assert_lock_strong(&_lock);\n+\n+  if (_buffer.size() >= AsyncLogBufferSize)  {\n+    if (Verbose) {\n+      const AsyncLogMessage* h = _buffer.front();\n+      assert(h != NULL, \"sanity check\");\n+      if (h->message() != NULL) {\n+        \/\/ Temporarily turn off SerializeVMOutput so defaultStream will not\n+        \/\/ invoke set_owner(self) for tty_lock.\n+        FlagSetting t(SerializeVMOutput, false);\n+        \/\/ The writing below can not guarantee non-blocking because tty may be piped by the filesystems\n+        \/\/ or throttled by XOFF, so only dump the dropping message in Verbose mode.\n+        tty->print_cr(\"asynclog dropping message: %s\", h->message());\n+      }\n+    }\n+\n+    _buffer.pop_front();\n@@ -47,0 +56,2 @@\n+  assert(_buffer.size() < AsyncLogBufferSize, \"_buffer is over-sized.\");\n+  _buffer.push_back(msg);\n@@ -48,1 +59,0 @@\n-#endif\n@@ -70,0 +80,3 @@\n+    enqueue_impl(m);\n+  }\n+}\n@@ -71,5 +84,8 @@\n-    if (_buffer.size() >= GCLogBufferSize)  {\n-      _buffer.pop_front();\n-    }\n-    assert(_buffer.size() < GCLogBufferSize, \"_buffer is over-sized.\");\n-    _buffer.push_back(m);\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsage.\n+\/\/ the mutex here gurantees its interity.\n+void LogAsyncFlusher::enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator) {\n+  MutexLocker ml(&_lock, Mutex::_no_safepoint_check_flag);\n+\n+  for (; !msg_iterator.is_at_end(); msg_iterator++) {\n+    AsyncLogMessage m(output, msg_iterator.decorations(), msg_iterator.message());\n+    enqueue_impl(m);\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":31,"deletions":15,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"logging\/logMessageBuffer.hpp\"\n@@ -64,1 +65,0 @@\n-      log_drop(h->data());\n@@ -78,2 +78,0 @@\n-\n-  void log_drop(E* e) {}\n@@ -135,0 +133,2 @@\n+  void enqueue_impl(const AsyncLogMessage& msg);\n+\n@@ -140,0 +140,1 @@\n+  void enqueue(LogFileOutput& output, LogMessageBuffer::Iterator msg_iterator);\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  assert(get_decorators() == decorators, \"insanity check\");\n+  assert(get_decorators() == decorators, \"sanity check\");\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-      _file_count(DefaultFileCount), _is_default_file_count(true), _async_mode(AsyncLogging), _archive_name_len(0),\n+      _file_count(DefaultFileCount), _is_default_file_count(true), _async_mode(false), _archive_name_len(0),\n@@ -336,1 +336,6 @@\n-  assert(!_async_mode, \"AsyncLogging is not supported yet\");\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  if (_async_mode && flusher != NULL) {\n+    flusher->enqueue(*this, msg_iterator);\n+    return -1;\n+  }\n+\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,12 @@\n+JVMFlag::Error LogAsyncIntervalConstraintFunc(intx value, bool verbose) {\n+    if ((value % PeriodicTask::interval_gran) != 0) {\n+    JVMFlag::printError(verbose,\n+                        \"LogAsyncInterval (\" INTX_FORMAT \") must be \"\n+                        \"evenly divisible by PeriodicTask::interval_gran (%d)\\n\",\n+                        value, PeriodicTask::interval_gran);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.cpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+  f(intx,   LogAsyncIntervalConstraintFunc)           \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/jvmFlagConstraintsRuntime.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2032,0 +2032,2 @@\n+          range(PeriodicTask::min_interval, max_jint)                       \\\n+          constraint(LogAsyncIntervalConstraintFunc, AtParse)               \\\n@@ -2033,5 +2035,2 @@\n-  product(bool, AsyncLogging, false,                                        \\\n-          \"Enble asynchronous GC logging\")                                  \\\n-                                                                            \\\n-  product(size_t, GCLogBufferSize, 2*K,                                     \\\n-          \"Entries of ringbuffer for GC log writing\")                       \\\n+  product(size_t, AsyncLogBufferSize, 2*K,                                  \\\n+          \"Entries of the buffer for Async logs\")                           \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"logging\/logMessage.hpp\"\n@@ -36,3 +37,0 @@\n-  const FlagSetting enabler;\n- protected:\n-  AsyncLogTest(): enabler(AsyncLogging, true) {}\n@@ -150,3 +148,8 @@\n-  VM_TestFlusher op;\n-  ThreadInVMfromNative invm(JavaThread::current());\n-  VMThread::execute(&op);\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+  {\n+    VM_TestFlusher op;\n+    ThreadInVMfromNative invm(JavaThread::current());\n+    VMThread::execute(&op);\n+  }\n+  flusher->flush();\n@@ -154,1 +157,0 @@\n-  LogAsyncFlusher::cleanup();\n@@ -168,1 +170,38 @@\n-}\n\\ No newline at end of file\n+}\n+\n+TEST_VM_F(AsyncLogTest, logMessage) {\n+  set_log_config(TestLogFileName, \"logging=debug\", \"none\" \/*decorators*\/, \"async=true\");\n+\n+  LogAsyncFlusher* flusher = LogAsyncFlusher::instance();\n+  ASSERT_NE(flusher, nullptr) <<  \"async flusher must not be null\";\n+\n+  const int MULTI_LINES = 20;\n+  {\n+\n+    LogMessage(logging) msg;\n+    Log(logging) logger;\n+\n+    for (int i = 0; i < MULTI_LINES; ++i) {\n+      msg.debug(\"nonbreakable log message line-%02d\", i);\n+\n+      if (0 == (i % 4)) {\n+        logger.debug(\"a noisy message from other logger\");\n+      }\n+    }\n+    logger.debug(\"a noisy message from other logger\");\n+  }\n+  flusher->flush();\n+\n+  ResourceMark rm;\n+  LogMessageBuffer buffer;\n+  const char* strs[MULTI_LINES + 1];\n+  strs[MULTI_LINES] = NULL;\n+  for (int i = 0; i < MULTI_LINES; ++i) {\n+    stringStream ss;\n+    ss.print_cr(\"nonbreakable log message line-%02d\", i);\n+    strs[i] = ss.as_string();\n+  }\n+  \/\/ check nonbreakable log messages are consecutive\n+  EXPECT_TRUE(file_contains_substrings_in_order(TestLogFileName, strs));\n+  EXPECT_TRUE(file_contains_substring(TestLogFileName, \"a noisy message from other logger\"));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":47,"deletions":8,"binary":false,"changes":55,"status":"modified"}]}