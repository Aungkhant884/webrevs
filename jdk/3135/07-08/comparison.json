{"files":[{"patch":"@@ -33,2 +33,1 @@\n-    \/\/ should cache this object somehow\n-    LogDecorations decorations(_level, _tagset, _decorators);\n+    LogDecorations decorations(_level, _tagset, _decorations_ref);\n@@ -66,1 +65,1 @@\n-  \/\/ notify async log thread if occupancy is over 3\/4\n+  \/\/ notify asynclog thread if occupancy is over 3\/4\n@@ -85,2 +84,2 @@\n-\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsage.\n-\/\/ the mutex here gurantees its interity.\n+\/\/ LogMessageBuffer consists of a multiple-part\/multiple-line messsages.\n+\/\/ the mutex here gurantees its integrity.\n@@ -114,1 +113,1 @@\n-    jio_snprintf(out_of_band, sz, UINTX_FORMAT \" messages dropped...\", *counter);\n+    jio_snprintf(out_of_band, sz, UINTX_FORMAT_W(6) \" messages dropped...\", *counter);\n@@ -175,3 +174,3 @@\n-\/\/ 1. issue an atomic store-&-fence to close the logging window.\n-\/\/ 2. flush itself in-place\n-\/\/ 3. signal the flusher thread to exit\n+\/\/ 1. issue an atomic release_store&fence to close the logging window.\n+\/\/ 2. flush itself in-place.\n+\/\/ 3. signal asynclog thread to exit.\n@@ -179,1 +178,1 @@\n-\/\/ 4. (optional) deletes this in post_run()\n+\/\/ 5. (optional) delete this in post_run().\n@@ -211,1 +210,1 @@\n-\/\/ 1. must be async-safe because os::abort may be invoked by a signal handler while other\n+\/\/ 1. must be async-safe because os::abort() may be invoked by a signal handler while other\n@@ -214,1 +213,1 @@\n-\/\/ holds assess lock and then traps SIGSEGV on purpose.\n+\/\/ holds a 'assess' lock and then traps SIGSEGV on purpose.\n@@ -216,1 +215,2 @@\n-\/\/ Unlike terminate, abort() just ensures all pending log messages are flushed.\n+\/\/ Unlike terminate, abort() just ensures all pending log messages are flushed. It doesnot\n+\/\/ exit asynclog thread.\n@@ -219,2 +219,2 @@\n-    \/\/ to meet prior constraints, I borrow the idea in LogConfiguration::disable_outputs(),\n-    \/\/ the following code shut down all outputs for all tagsets with RCU synchroniziation.\n+    \/\/ To meet prior constraints, I borrow the idea in LogConfiguration::disable_outputs(),\n+    \/\/ the following code shut down all outputs for all tagsets with a RCU synchroniziation.\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.cpp","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"logging\/log.hpp\"\n@@ -35,2 +36,2 @@\n-template <typename E>\n-class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, mtLogging> {\n+template <typename E, MEMFLAGS F>\n+class LinkedListDeque : private LinkedListImpl<E, ResourceObj::C_HEAP, F> {\n@@ -44,1 +45,1 @@\n-    if (!_tail)\n+    if (!_tail) {\n@@ -46,1 +47,1 @@\n-    else\n+    } else {\n@@ -48,0 +49,1 @@\n+    }\n@@ -84,1 +86,1 @@\n-  LogDecorators _decorators;\n+  LogDecorationsRef& _decorations_ref;\n@@ -90,1 +92,1 @@\n-    : _output(output), _decorators(output.decorators()),\n+    : _output(output), _decorations_ref(decorations.ref()),\n@@ -94,0 +96,1 @@\n+      ++_decorations_ref;\n@@ -97,0 +100,1 @@\n+    --_decorations_ref;\n@@ -104,1 +108,1 @@\n-    :_output(o._output), _decorators(o._decorators), _level(o._level), _tagset(o._tagset) {\n+    :_output(o._output), _decorations_ref(o._decorations_ref), _level(o._level), _tagset(o._tagset) {\n@@ -107,0 +111,1 @@\n+    ++_decorations_ref;\n@@ -111,0 +116,1 @@\n+  \/\/ two AsyncLogMessage are equal if both _output and _message are same.\n@@ -112,1 +118,7 @@\n-    return (&_output == &o._output) && (_message == o._message || !strcmp(_message, o._message));\n+    if (_message == o._message) {\n+      return &_output == &o._output;\n+    } else if (_message == NULL || o._message == NULL) {\n+      return false;\n+    } else {\n+      return &_output == &o._output && !strcmp(_message, o._message);\n+    }\n@@ -119,1 +131,1 @@\n-typedef LinkedListDeque<AsyncLogMessage> AsyncLogBuffer;\n+typedef LinkedListDeque<AsyncLogMessage, mtLogging> AsyncLogBuffer;\n@@ -125,1 +137,0 @@\n-\/\/ Flusher is a NonJavaThread which manages a FIFO capacity-bound buffer.\n@@ -148,0 +159,4 @@\n+  void pre_run() override {\n+    NonJavaThread::pre_run();\n+    log_debug(logging, thread)(\"starting AsyncLog Thread tid = \" INTX_FORMAT, os::current_thread_id());\n+  }\n@@ -153,0 +168,1 @@\n+  \/\/ Use with_lock = false at your own risk. It is only safe without any active reader.\n","filename":"src\/hotspot\/share\/logging\/logAsyncFlusher.hpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -554,1 +554,1 @@\n-  out->print_cr(\"   async=true|false - write asynchronously or not.\");\n+  out->print_cr(\"   async=true|false - write asynchronously or not, false by default.\");\n","filename":"src\/hotspot\/share\/logging\/logConfiguration.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-    : _level(level), _tagset(&tagset) {\n+    : _level(level), _tagset(&tagset), _ref(nullptr) {\n@@ -40,0 +40,6 @@\n+LogDecorations::LogDecorations(LogLevelType level, const LogTagSet &tagset, LogDecorationsRef& ref)\n+    : _level(level), _tagset(&tagset), _ref(&ref) {\n+  assert(ref._refcnt > 0, \"pass in an invalid LogDecorationsRef.\");\n+  ++(*_ref);\n+}\n+\n@@ -41,1 +47,1 @@\n-    : _level(level), _tagset(nullptr) {\n+    : _level(level), _tagset(nullptr), _ref(nullptr) {\n@@ -152,0 +158,31 @@\n+\n+LogDecorationsRef LogDecorationsRef::NoneRef = {};\n+\n+LogDecorationsRef& LogDecorations::ref() const {\n+  if (_ref == nullptr) {\n+    size_t sz = 0;\n+\n+    for (int i = 0; i < LogDecorators::Count; ++i) {\n+      if (_decoration_offset[i] != NULL) {\n+        sz += strlen(_decoration_offset[i]) + 1;\n+      }\n+    }\n+\n+    if (sz == 0) { \/\/ decorators == 'none'\n+      return ++LogDecorationsRef::NoneRef;\n+    }\n+\n+    _ref = new LogDecorationsRef();\n+    _ref->_decorations_buffer = NEW_C_HEAP_ARRAY(char, sz, mtLogging);\n+    memcpy(_ref->_decorations_buffer, _decorations_buffer, sz);\n+    for (int i = 0; i < LogDecorators::Count; ++i) {\n+      if (_decoration_offset[i] != NULL) {\n+        _ref->_decoration_offset[i] = (_decoration_offset[i] - _decorations_buffer) + _ref->_decorations_buffer;\n+      } else {\n+        _ref->_decoration_offset[i] = NULL;\n+      }\n+    }\n+  }\n+\n+  return ++(*_ref);\n+}\n","filename":"src\/hotspot\/share\/logging\/logDecorations.cpp","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -30,0 +30,39 @@\n+\/\/ LogDecorations objects are temporary variables in LogTagSet::log()\n+\/\/ It doesnot fit asynchronous logging well because flusher will access\n+\/\/ them in AsyncLog Thread. some decorators are very context sensitive, eg.\n+\/\/ uptime and tid, async logging has to copy LogDecorations objects to secure\n+\/\/ the accurarcy.\n+\/\/\n+\/\/ LogDecorationsRef provides a relatively cheaper copy of LogDecorations,\n+\/\/ which consists of 256-byte buffer. The ref only copys strings what have\n+\/\/ materialized and use refcnt to avoid from duplicating.\n+class LogDecorationsRef : public CHeapObj<mtLogging>{\n+  friend class LogDecorations;\n+private:\n+  char* _decorations_buffer;\n+  char* _decoration_offset[LogDecorators::Count];\n+  size_t _refcnt;\n+\n+  \/\/ only LogDecorations can create it.\n+  LogDecorationsRef() : _refcnt(0) {}\n+  LogDecorationsRef(const LogDecorationsRef& rhs) = delete;\n+public:\n+  LogDecorationsRef& operator++() {\n+    _refcnt++;\n+    return *this;\n+  }\n+\n+  void operator--() {\n+    if (--_refcnt == 0 && this != &NoneRef) {\n+      FREE_C_HEAP_ARRAY(char, _decorations_buffer);\n+      delete this;\n+    }\n+  }\n+\n+  size_t refcnt() const { return _refcnt; }\n+\n+  \/\/ It is not constant value for convenience.\n+  \/\/ Do not need to care its refcnt as long as it does not delete itself.\n+  static LogDecorationsRef NoneRef;\n+};\n+\n@@ -39,0 +78,1 @@\n+  mutable LogDecorationsRef* _ref;\n@@ -50,0 +90,1 @@\n+  LogDecorations(LogLevelType level, const LogTagSet& tagset, LogDecorationsRef& ref);\n@@ -51,1 +92,5 @@\n-\n+  ~LogDecorations() {\n+    if (_ref != nullptr) {\n+      --(*_ref);\n+    }\n+  }\n@@ -66,1 +111,6 @@\n-    return _decoration_offset[decorator];\n+\n+    if (_ref == nullptr) {\n+      return _decoration_offset[decorator];\n+    } else {\n+      return _ref->_decoration_offset[decorator];\n+    }\n@@ -68,1 +118,0 @@\n-};\n@@ -70,0 +119,2 @@\n+  LogDecorationsRef& ref() const;\n+};\n","filename":"src\/hotspot\/share\/logging\/logDecorations.hpp","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -89,10 +89,0 @@\n-  LogDecorators(const LogDecorators& o) : _decorators(o._decorators) {\n-  }\n-\n-  LogDecorators& operator=(const LogDecorators& rhs) {\n-    if (this != &rhs) {\n-      _decorators = rhs._decorators;\n-    }\n-    return *this;\n-  }\n-\n@@ -117,4 +107,0 @@\n-  void combine_with(LogDecorators::Decorator source) {\n-    _decorators |= LogDecorators::mask(source);\n-  }\n-\n@@ -129,4 +115,0 @@\n-  bool operator==(const LogDecorators& rhs) {\n-    return _decorators == rhs._decorators;\n-  }\n-\n","filename":"src\/hotspot\/share\/logging\/logDecorators.hpp","additions":0,"deletions":18,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -262,2 +262,3 @@\n-                     \", filesize: \" SIZE_FORMAT \" KiB).\",\n-                     _file_name, _file_count, _rotate_size \/ K);\n+                     \", filesize: \" SIZE_FORMAT \" KiB, async: %s).\",\n+                     _file_name, _file_count, _rotate_size \/ K,\n+                     _async_mode ? \"true\" : \"false\");\n","filename":"src\/hotspot\/share\/logging\/logFileOutput.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-    asynclog_thread,  \/\/ dedicated to flushing logs\n+    asynclog_thread,   \/\/ dedicated to flushing logs\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+\/\/     - LogAsyncFlusher\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+\n","filename":"test\/hotspot\/gtest\/logging\/logTestUtils.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  LinkedListDeque<int> fifo;\n+  LinkedListDeque<int, mtLogging> fifo;\n@@ -76,1 +76,1 @@\n-  LinkedListDeque<int> deque;\n+  LinkedListDeque<int, mtLogging> deque;\n","filename":"test\/hotspot\/gtest\/logging\/test_asynclog.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,0 +233,42 @@\n+\n+TEST_VM(LogDecorations, ref) {\n+  LogDecorators decorator_selection;\n+  ASSERT_TRUE(decorator_selection.parse(\"tid,uptime,level\"));\n+  LogDecorations decorations(LogLevel::Info, tagset, decorator_selection);\n+  const char* saved_tid    = decorations.decoration(LogDecorators::tid_decorator);\n+  const char* saved_uptime = decorations.decoration(LogDecorators::uptime_decorator);\n+  const char* saved_level  = decorations.decoration(LogDecorators::level_decorator);\n+  LogDecorationsRef& ref = decorations.ref();\n+\n+  \/\/ test refcnt\n+  EXPECT_EQ(ref.refcnt(), (size_t)1);\n+  ++ref;\n+  EXPECT_EQ(ref.refcnt(), (size_t)2);\n+  --ref;\n+  EXPECT_EQ(ref.refcnt(), (size_t)1);\n+\n+  \/\/ test contents\n+  EXPECT_STREQ(decorations.decoration(LogDecorators::tid_decorator), saved_tid);\n+  EXPECT_NE(decorations.decoration(LogDecorators::tid_decorator), saved_tid);\n+  EXPECT_STREQ(decorations.decoration(LogDecorators::uptime_decorator), saved_uptime);\n+  EXPECT_NE(decorations.decoration(LogDecorators::uptime_decorator), saved_uptime);\n+  EXPECT_STREQ(decorations.decoration(LogDecorators::level_decorator), saved_level);\n+  \/\/ level is special.\n+  EXPECT_EQ(decorations.decoration(LogDecorators::level_decorator), saved_level);\n+}\n+\n+TEST_VM(LogDecorations, ref_none) {\n+  LogDecorators decorator_selection;\n+  ASSERT_TRUE(decorator_selection.parse(\"none\"));\n+  LogDecorations decorations(LogLevel::Info, tagset, decorator_selection);\n+  LogDecorationsRef& ref = decorations.ref();\n+\n+  EXPECT_EQ(&ref, &LogDecorationsRef::NoneRef);\n+  EXPECT_EQ(ref.refcnt(), (size_t)1);\n+  --ref;\n+\n+  EXPECT_EQ(NULL, decorations.decoration(LogDecorators::tid_decorator));\n+  EXPECT_EQ(NULL, decorations.decoration(LogDecorators::uptime_decorator));\n+  \/\/ level is special\n+  EXPECT_EQ(LogLevel::name(LogLevel::Info), decorations.decoration(LogDecorators::level_decorator));\n+}\n","filename":"test\/hotspot\/gtest\/logging\/test_logDecorations.cpp","additions":43,"deletions":1,"binary":false,"changes":44,"status":"modified"}]}