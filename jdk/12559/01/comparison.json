{"files":[{"patch":"@@ -38,1 +38,0 @@\n-inline bool os::numa_has_static_binding()   { AIX_ONLY(ShouldNotReachHere();) return true; }\n","filename":"src\/hotspot\/os\/posix\/os_posix.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-inline bool os::numa_has_static_binding()   { return true;   }\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -119,21 +119,0 @@\n-          if (!os::numa_has_static_binding()) {\n-            size_t touched_words = words_to_fill;\n-#ifndef ASSERT\n-            if (!ZapUnusedHeapArea) {\n-              touched_words = MIN2((size_t)align_object_size(typeArrayOopDesc::header_size(T_INT)),\n-                touched_words);\n-            }\n-#endif\n-            MemRegion invalid;\n-            HeapWord *crossing_start = align_up(cur_top, os::vm_page_size());\n-            HeapWord *crossing_end = align_down(cur_top + touched_words, os::vm_page_size());\n-            if (crossing_start != crossing_end) {\n-              \/\/ If object header crossed a small page boundary we mark the area\n-              \/\/ as invalid rounding it to a page_size().\n-              HeapWord *start = MAX2(align_down(cur_top, page_size()), s->bottom());\n-              HeapWord *end = MIN2(align_up(cur_top + touched_words, page_size()), s->end());\n-              invalid = MemRegion(start, end);\n-            }\n-\n-            ls->add_invalid_region(invalid);\n-          }\n@@ -145,15 +124,1 @@\n-      if (!os::numa_has_static_binding()) {\n-#ifdef ASSERT\n-        MemRegion invalid(s->top(), s->end());\n-        ls->add_invalid_region(invalid);\n-#else\n-        if (ZapUnusedHeapArea) {\n-          MemRegion invalid(s->top(), s->end());\n-          ls->add_invalid_region(invalid);\n-        } else {\n-          return;\n-        }\n-#endif\n-      } else {\n-          return;\n-      }\n+      return;\n@@ -281,12 +246,1 @@\n-  bool should_initialize = false;\n-  if (!os::numa_has_static_binding()) {\n-    for (int i = 0; i < lgrp_spaces()->length(); i++) {\n-      if (!lgrp_spaces()->at(i)->invalid_region().is_empty()) {\n-        should_initialize = true;\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (should_initialize ||\n-      (UseAdaptiveNUMAChunkSizing && adaptation_cycles() < samples_count())) {\n+  if (UseAdaptiveNUMAChunkSizing && adaptation_cycles() < samples_count()) {\n@@ -608,12 +562,0 @@\n-    if (!os::numa_has_static_binding()) {\n-      MemRegion invalid_region = ls->invalid_region().intersection(new_region);\n-      \/\/ Invalid region is a range of memory that could've possibly\n-      \/\/ been allocated on the other node. That's relevant only on Solaris where\n-      \/\/ there is no static memory binding.\n-      if (!invalid_region.is_empty()) {\n-        merge_regions(new_region, &intersection, &invalid_region);\n-        free_region(invalid_region);\n-        ls->set_invalid_region(MemRegion());\n-      }\n-    }\n-\n@@ -622,11 +564,4 @@\n-    if (!os::numa_has_static_binding()) {\n-      \/\/ If that's a system with the first-touch policy then it's enough\n-      \/\/ to free the pages.\n-      free_region(bottom_region);\n-      free_region(top_region);\n-    } else {\n-      \/\/ In a system with static binding we have to change the bias whenever\n-      \/\/ we reshape the heap.\n-      bias_region(bottom_region, ls->lgrp_id());\n-      bias_region(top_region, ls->lgrp_id());\n-    }\n+    \/\/ In a system with static binding we have to change the bias whenever\n+    \/\/ we reshape the heap.\n+    bias_region(bottom_region, ls->lgrp_id());\n+    bias_region(top_region, ls->lgrp_id());\n@@ -667,3 +602,0 @@\n-      if (!os::numa_has_static_binding() && top < value && top < s->end()) {\n-        ls->add_invalid_region(MemRegion(top, value));\n-      }\n@@ -674,1 +606,1 @@\n-            s->set_top(s->bottom());\n+          s->set_top(s->bottom());\n@@ -676,3 +608,0 @@\n-          if (!os::numa_has_static_binding() && top < s->end()) {\n-            ls->add_invalid_region(MemRegion(top, s->end()));\n-          }\n@@ -745,6 +674,0 @@\n-  \/\/ Make the page allocation happen here if there is no static binding.\n-  if (p != nullptr && !os::numa_has_static_binding() ) {\n-    for (HeapWord *i = p; i < p + size; i += os::vm_page_size() >> LogHeapWordSize) {\n-      *(int*)i = 0;\n-    }\n-  }\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":7,"deletions":84,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -492,1 +492,0 @@\n-  static bool   numa_has_static_binding();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}