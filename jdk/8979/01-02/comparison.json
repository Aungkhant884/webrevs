{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,3 @@\n-import java.lang.ref.PhantomReference;\n-import java.lang.ref.Reference;\n-import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.Cleaner;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -35,16 +35,3 @@\n-    \/**\n-     * Causes the current thread to wait until the {@code booleanSupplier}\n-     * returns true, or a predefined waiting time (10 seconds) elapses.\n-     *\n-     * @param booleanSupplier boolean supplier\n-     * @return true if the {@code booleanSupplier} returns true, or false\n-     *     if did not complete after 10 Seconds\n-     *\/\n-    public static boolean wait(BooleanSupplier booleanSupplier) {\n-        ReferenceQueue<Object> queue = new ReferenceQueue<>();\n-        Object obj = new Object();\n-        PhantomReference<Object> ref = new PhantomReference<>(obj, queue);\n-        obj = null;\n-        Reference.reachabilityFence(obj);\n-        Reference.reachabilityFence(ref);\n-        System.gc();\n+    private final CountDownLatch cleanerInvoked = new CountDownLatch(1);\n+    private final Cleaner cleaner = Cleaner.create();\n+    private Object o;\n@@ -52,4 +39,4 @@\n-        for (int retries = 10; retries > 0; retries--) {\n-            if (booleanSupplier.getAsBoolean()) {\n-                return true;\n-            }\n+    public ForceGC() {\n+        this.o = new Object();\n+        cleaner.register(o, () -> cleanerInvoked.countDown());\n+    }\n@@ -57,8 +44,8 @@\n-            try {\n-                \/\/ The remove() will always block for the specified milliseconds\n-                \/\/ if the reference has already been removed from the queue.\n-                \/\/ But it is fine.  For most cases, the 1st GC is sufficient\n-                \/\/ to trigger and complete the cleanup.\n-                queue.remove(1000L);\n-            } catch (InterruptedException ie) {\n-                \/\/ ignore, the loop will try again\n+    private void doit(int iter) {\n+        try {\n+            for (int i = 0; i < 10; i++) {\n+                System.gc();\n+                System.out.println(\"doit() iter: \" + iter + \", gc \" + i);\n+                if (cleanerInvoked.await(1L, TimeUnit.SECONDS)) {\n+                    return;\n+                }\n@@ -66,1 +53,2 @@\n-            System.gc();\n+        } catch (InterruptedException unexpected) {\n+            throw new AssertionError(\"unexpected InterruptedException\");\n@@ -68,0 +56,1 @@\n+    }\n@@ -69,0 +58,19 @@\n+    \/**\n+     * Causes the current thread to wait until the {@code BooleanSupplier} returns true,\n+     * unless the thread is interrupted or a predefined waiting time elapses.\n+     *\n+     * @param s boolean supplier\n+     * @return true if the {@code BooleanSupplier} returns true and false if\n+     *         the predefined waiting time elapsed before the count reaches zero.\n+     * @throws InterruptedException if the current thread is interrupted while waiting\n+     *\/\n+    public boolean await(BooleanSupplier s) {\n+        o = null; \/\/ Keep reference to Object until now, to ensure the Cleaner\n+                  \/\/ doesn't count down the latch before await() is called.\n+        for (int i = 0; i < 10; i++) {\n+            if (s.getAsBoolean()) return true;\n+            doit(i);\n+            try { Thread.sleep(1000); } catch (InterruptedException e) {\n+                throw new AssertionError(\"unexpected interrupted sleep\", e);\n+            }\n+        }\n@@ -72,1 +80,0 @@\n-\n","filename":"test\/lib\/jdk\/test\/lib\/util\/ForceGC.java","additions":41,"deletions":34,"binary":false,"changes":75,"status":"modified"}]}