{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8155740\n+ * @bug 8160266 8225790\n@@ -30,5 +30,0 @@\n- * @summary com.apple.junit.java.awt.Frame\n- * @library ..\/..\/..\/regtesthelpers\n- * @build VisibilityValidator\n- * @build Util\n- * @build Waypoint\n@@ -47,7 +42,13 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.Enumeration;\n-\n-import test.java.awt.regtesthelpers.Waypoint;\n-import test.java.awt.regtesthelpers.VisibilityValidator;\n-import test.java.awt.regtesthelpers.Util;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GridBagLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n@@ -56,6 +57,3 @@\n-\n-    Waypoint[] event_checkpoint = new Waypoint[3];\n-    VisibilityValidator[] win_checkpoint = new VisibilityValidator[2];\n-\n-    IntermediateDialog interDiag;\n-    TextDialog txtDiag;\n+    private static Frame frame;\n+    private static IntermediateDialog interDiag;\n+    private static TextDialog txtDiag;\n@@ -64,12 +62,3 @@\n-    Button[] robot_button = new Button[2];\n-    TextField robot_text = null;\n-    static Robot _robot = null;\n-\n-    \/*\n-     * @throws InterruptedException\n-     * @throws WaypointException\n-     *\/\n-    public void testModalDialogs() throws Exception {\n-        Frame frame = null;\n-        String result = \"\";\n-        Robot robot = getRobot();\n+    private static Button[] robot_button = new Button[2];\n+    private static TextField robot_text = null;\n+    private static Robot robot = null;\n@@ -77,31 +66,9 @@\n-        event_checkpoint[0] = new Waypoint(); \/\/ \"-Launch 1-\"\n-        event_checkpoint[1] = new Waypoint(); \/\/ \"-Launch 2-\"\n-\n-        \/\/ Thread.currentThread().setName(\"NestedModalDialogTest Thread\");\n-        \/\/ launch first frame with firstButton\n-        frame = new StartFrame();\n-        VisibilityValidator.setVisibleAndConfirm(frame);\n-        Util.clickOnComp(robot_button[0], robot);\n-\n-        \/\/ Dialog must be created and onscreen before we proceed.\n-        \/\/   The event_checkpoint waits for the Dialog to be created.\n-        \/\/   The win_checkpoint waits for the Dialog to be visible.\n-        event_checkpoint[0].requireClear(\"TestFrame actionPerformed() never \"\n-                + \"called, see <rdar:\/\/problem\/3429130>\");\n-        win_checkpoint[0].requireVisible();\n-        Util.clickOnComp(robot_button[1], robot);\n-\n-        \/\/ Again, the Dialog must be created and onscreen before we proceed.\n-        \/\/   The event_checkpoint waits for the Dialog to be created.\n-        \/\/   The win_checkpoint waits for the Dialog to be visible.\n-        event_checkpoint[1].requireClear(\"IntermediateDialog actionPerformed() \"\n-                + \"never called, see <rdar:\/\/problem\/3429130>\");\n-        win_checkpoint[1].requireVisible();\n-        Util.clickOnComp(robot_text, robot);\n-\n-        \/\/ I'm really not sure whether the click is needed for focus\n-        \/\/ but since it's asynchronous, as is the actually gaining of focus\n-        \/\/ we might as well do our best\n-        try {\n-            EventQueue.invokeAndWait(new Runnable() {\n-                public void run() {\n+    private static void blockTillDisplayed(Component comp) {\n+        Point p = null;\n+        while (p == null) {\n+            try {\n+                p = comp.getLocationOnScreen();\n+            } catch (IllegalStateException e) {\n+                try {\n+                    Thread.sleep(500);\n+                } catch (InterruptedException ie) {\n@@ -109,2 +76,1 @@\n-            });\n-        } catch (Exception e) {\n+            }\n@@ -112,0 +78,1 @@\n+    }\n@@ -113,13 +80,3 @@\n-        robot.keyPress(KeyEvent.VK_SHIFT);\n-\n-        robot.keyPress(KeyEvent.VK_H);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_H);\n-\n-        robot.keyRelease(KeyEvent.VK_SHIFT);\n-\n-        robot.keyPress(KeyEvent.VK_E);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_E);\n-\n-        robot.keyPress(KeyEvent.VK_L);\n+    private static void clickOnComp(Component comp) {\n+        Rectangle bounds = new Rectangle(comp.getLocationOnScreen(), comp.getSize());\n+        robot.mouseMove(bounds.x + bounds.width \/ 2, bounds.y + bounds.height \/ 2);\n@@ -127,3 +84,2 @@\n-        robot.keyRelease(KeyEvent.VK_L);\n-\n-        robot.keyPress(KeyEvent.VK_L);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -131,39 +87,0 @@\n-        robot.keyRelease(KeyEvent.VK_L);\n-\n-        robot.keyPress(KeyEvent.VK_O);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_O);\n-\n-        \/\/\n-        \/\/ NOTE THAT WE MAY HAVE MORE SYNCHRONIZATION WORK TO DO HERE.\n-        \/\/ CURRENTLY THERE IS NO GUARANTEE THAT THE KEYEVENT THAT THAT\n-        \/\/ TYPES THE 'O' HAS BEEN PROCESSED BEFORE WE GET THE RESULT\n-        \/\/\n-        \/\/ This is a (lame) attempt at waiting for the last typeKey events to\n-        \/\/ propagate. It's not quite right because robot uses\n-        \/\/ CGRemoteOperations, which are asynchronous. But that's why I put in\n-        \/\/ the pause\n-        try {\n-            EventQueue.invokeAndWait(new Runnable() {\n-                public void run() {\n-                }\n-            });\n-        } catch (Exception e) {\n-        }\n-\n-        \/\/ Need to call this before the dialog that robot_text is in is disposed\n-        result = robot_text.getText();\n-\n-        Thread.sleep(50); \/\/ shouldn't need this, but pause adds stability\n-        \/\/ Click Close box of modal dialog with textField\n-        Util.clickOnComp(txtDiag, robot);\n-\n-        Thread.sleep(50); \/\/ shouldn't need this, but pause adds stability\n-        \/\/ Click Close box of intermediate modal dialog\n-        Util.clickOnComp(interDiag, robot);\n-\n-        Thread.sleep(50); \/\/ shouldn't need this, but pause adds stability\n-        \/\/ Click Close box of intermediate modal dialog\n-        Util.clickOnComp(frame, robot);\n-\n-        String expected = \"Hello\";\n@@ -172,6 +89,48 @@\n-    private static Robot getRobot() {\n-        if (_robot == null) {\n-            try {\n-                _robot = new Robot();\n-            } catch (AWTException e) {\n-                throw new RuntimeException(\"Robot creation failed\");\n+    public void testModalDialogs() throws Exception {\n+        try {\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+\n+            \/\/ launch first frame with firstButton\n+            frame = new StartFrame();\n+            blockTillDisplayed(frame);\n+            clickOnComp(robot_button[0]);\n+\n+            \/\/ Dialog must be created and onscreen before we proceed.\n+            blockTillDisplayed(interDiag);\n+            clickOnComp(robot_button[1]);\n+\n+            \/\/ Again, the Dialog must be created and onscreen before we proceed.\n+            blockTillDisplayed(robot_text);\n+            clickOnComp(robot_text);\n+\n+            robot.keyPress(KeyEvent.VK_SHIFT);\n+            robot.keyPress(KeyEvent.VK_H);\n+            robot.keyRelease(KeyEvent.VK_H);\n+            robot.keyRelease(KeyEvent.VK_SHIFT);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_E);\n+            robot.keyRelease(KeyEvent.VK_E);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_L);\n+            robot.keyRelease(KeyEvent.VK_L);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_L);\n+            robot.keyRelease(KeyEvent.VK_L);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_O);\n+            robot.keyRelease(KeyEvent.VK_O);\n+            robot.waitForIdle();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+            if (interDiag != null) {\n+                interDiag.dispose();\n+            }\n+            if (txtDiag != null) {\n+                txtDiag.dispose();\n@@ -180,1 +139,0 @@\n-        return _robot;\n@@ -201,1 +159,0 @@\n-                    win_checkpoint[0] = new VisibilityValidator(interDiag);\n@@ -207,1 +164,0 @@\n-                    event_checkpoint[0].clear();\n@@ -214,0 +170,1 @@\n+            setVisible(true);\n@@ -215,6 +172,0 @@\n-            addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    setVisible(false);\n-                    dispose();\n-                }\n-            });\n@@ -237,1 +188,0 @@\n-                    win_checkpoint[1] = new VisibilityValidator(txtDiag);\n@@ -239,1 +189,0 @@\n-                    event_checkpoint[1].clear();\n@@ -247,6 +196,0 @@\n-            addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    setVisible(false);\n-                    dispose();\n-                }\n-            });\n@@ -269,6 +212,0 @@\n-            addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    setVisible(false);\n-                    dispose();\n-                }\n-            });\n","filename":"test\/jdk\/java\/awt\/Dialog\/NestedDialogs\/Modal\/NestedModalDialogTest.java","additions":86,"deletions":149,"binary":false,"changes":235,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8155740\n+ * @bug 8160266 8225790\n@@ -30,6 +30,1 @@\n- * @summary com.apple.junit.java.awt.Frame\n- * @library ..\/..\/..\/regtesthelpers\n- * @build VisibilityValidator\n- * @build Util\n- * @build Waypoint\n- * @run main NestedModelessDialogTest -Xlog:exception\n+ * @run main NestedModelessDialogTest\n@@ -46,3 +41,0 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.util.Enumeration;\n@@ -50,3 +42,13 @@\n-import test.java.awt.regtesthelpers.Util;\n-import test.java.awt.regtesthelpers.VisibilityValidator;\n-import test.java.awt.regtesthelpers.Waypoint;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dialog;\n+import java.awt.Frame;\n+import java.awt.GridBagLayout;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n@@ -55,0 +57,3 @@\n+    private static Frame frame;\n+    private static IntermediateDialog interDiag;\n+    private static TextDialog txtDiag;\n@@ -56,2 +61,4 @@\n-    Waypoint[] event_checkpoint = new Waypoint[3];\n-    VisibilityValidator[] win_checkpoint = new VisibilityValidator[2];\n+    \/\/ Global variables so the robot thread can locate things.\n+    private static Button[] robot_button = new Button[2];\n+    private static TextField robot_text = null;\n+    private static Robot robot;\n@@ -59,2 +66,13 @@\n-    IntermediateDialog interDiag;\n-    TextDialog txtDiag;\n+    private static void blockTillDisplayed(Component comp) {\n+        Point p = null;\n+        while (p == null) {\n+            try {\n+                p = comp.getLocationOnScreen();\n+            } catch (IllegalStateException e) {\n+                try {\n+                    Thread.sleep(500);\n+                } catch (InterruptedException ie) {\n+                }\n+            }\n+        }\n+    }\n@@ -62,4 +80,8 @@\n-    \/\/ Global variables so the robot thread can locate things.\n-    Button[] robot_button = new Button[2];\n-    TextField robot_text = null;\n-    static Robot _robot = null;\n+    private static void clickOnComp(Component comp) {\n+        Rectangle bounds = new Rectangle(comp.getLocationOnScreen(), comp.getSize());\n+        robot.mouseMove(bounds.x + bounds.width \/ 2, bounds.y + bounds.height \/ 2);\n+        robot.waitForIdle();\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.waitForIdle();\n+    }\n@@ -73,29 +95,0 @@\n-        Frame frame = null;\n-        String result = \"\";\n-        Robot robot = getRobot();\n-\n-        event_checkpoint[0] = new Waypoint(); \/\/ \"-Launch 1-\"\n-        event_checkpoint[1] = new Waypoint(); \/\/ \"-Launch 2-\"\n-\n-        \/\/ launch first frame with fistButton\n-        frame = new StartFrame();\n-        VisibilityValidator.setVisibleAndConfirm(frame);\n-        Util.clickOnComp(robot_button[0], robot);\n-\n-        \/\/ Dialog must be created and onscreen before we proceed.\n-        \/\/   The event_checkpoint waits for the Dialog to be created.\n-        \/\/   The win_checkpoint waits for the Dialog to be visible.\n-        event_checkpoint[0].requireClear();\n-        win_checkpoint[0].requireVisible();\n-        Util.clickOnComp(robot_button[1], robot);\n-\n-        \/\/ Again, the Dialog must be created and onscreen before we proceed.\n-        \/\/   The event_checkpoint waits for the Dialog to be created.\n-        \/\/   The win_checkpoint waits for the Dialog to be visible.\n-        event_checkpoint[1].requireClear();\n-        win_checkpoint[1].requireVisible();\n-        Util.clickOnComp(robot_text, robot);\n-\n-        \/\/ I'm really not sure whether the click is needed for focus\n-        \/\/ but since it's asynchronous, as is the actually gaining of focus\n-        \/\/ we might as well do our best\n@@ -103,72 +96,47 @@\n-            EventQueue.invokeAndWait(new Runnable() {\n-                public void run() {\n-                }\n-            });\n-        } catch (Exception e) {\n-        }\n-\n-        robot.keyPress(KeyEvent.VK_SHIFT);\n-\n-        robot.keyPress(KeyEvent.VK_H);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_H);\n-\n-        robot.keyRelease(KeyEvent.VK_SHIFT);\n-\n-        robot.keyPress(KeyEvent.VK_E);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_E);\n-\n-        robot.keyPress(KeyEvent.VK_L);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_L);\n-\n-        robot.keyPress(KeyEvent.VK_L);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_L);\n-\n-        robot.keyPress(KeyEvent.VK_O);\n-        robot.waitForIdle();\n-        robot.keyRelease(KeyEvent.VK_O);\n-\n-        \/\/\n-        \/\/ NOTE THAT WE MAY HAVE MORE SYNCHRONIZATION WORK TO DO HERE.\n-        \/\/ CURRENTLY THERE IS NO GUARANTEE THAT THE KEYEVENT THAT THAT\n-        \/\/ TYPES THE 'O' HAS BEEN PROCESSED BEFORE WE GET THE RESULT\n-        \/\/\n-        \/\/ This is a (lame) attempt at waiting for the last typeKey events to\n-        \/\/ propagate. It's not quite right because robot uses\n-        \/\/ CGRemoteOperations, which are asynchronous. But that's why I put in\n-        \/\/ the Thread.sleep\n-        try {\n-            EventQueue.invokeAndWait(new Runnable() {\n-                public void run() {\n-                }\n-            });\n-        } catch (Exception e) {\n-        }\n-\n-        \/\/ Need to call this before the dialog that robot_text is in is disposed\n-        result = robot_text.getText();\n-\n-        Thread.sleep(50); \/\/ Thread.sleep adds stability\n-        \/\/ Click Close box of modeless dialog with textField\n-        Util.clickOnComp(txtDiag, robot);\n-\n-        Thread.sleep(50); \/\/ Thread.sleep adds stability\n-        \/\/ Click Close box of intermediate modal dialog\n-        Util.clickOnComp(interDiag, robot);\n-\n-        Thread.sleep(50); \/\/ Thread.sleep adds stability\n-        \/\/ Click Close box of intermediate modal dialog\n-        Util.clickOnComp(frame, robot);\n-\n-        String expected = \"Hello\";\n-    }\n-\n-    private static Robot getRobot() {\n-        if (_robot == null) {\n-            try {\n-                _robot = new Robot();\n-            } catch (AWTException e) {\n-                throw new RuntimeException(\"Robot creation failed\");\n+            robot = new Robot();\n+            robot.setAutoDelay(100);\n+\n+            \/\/ launch first frame with fistButton\n+            frame = new StartFrame();\n+            robot.waitForIdle();\n+            blockTillDisplayed(frame);\n+            clickOnComp(robot_button[0]);\n+\n+            \/\/ Dialog must be created and onscreen before we proceed.\n+            blockTillDisplayed(interDiag);\n+            clickOnComp(robot_button[1]);\n+\n+            \/\/ Again, the Dialog must be created and onscreen before we proceed.\n+            blockTillDisplayed(robot_text);\n+            clickOnComp(robot_text);\n+\n+            robot.keyPress(KeyEvent.VK_SHIFT);\n+            robot.keyPress(KeyEvent.VK_H);\n+            robot.keyRelease(KeyEvent.VK_H);\n+            robot.keyRelease(KeyEvent.VK_SHIFT);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_E);\n+            robot.keyRelease(KeyEvent.VK_E);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_L);\n+            robot.keyRelease(KeyEvent.VK_L);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_L);\n+            robot.keyRelease(KeyEvent.VK_L);\n+            robot.waitForIdle();\n+\n+            robot.keyPress(KeyEvent.VK_O);\n+            robot.keyRelease(KeyEvent.VK_O);\n+            robot.waitForIdle();\n+        } finally {\n+            if (frame != null) {\n+                frame.dispose();\n+            }\n+            if (interDiag != null) {\n+                interDiag.dispose();\n+            }\n+            if (txtDiag != null) {\n+                txtDiag.dispose();\n@@ -177,1 +145,0 @@\n-        return _robot;\n@@ -198,1 +165,0 @@\n-                    win_checkpoint[0] = new VisibilityValidator(interDiag);\n@@ -204,1 +170,0 @@\n-                    event_checkpoint[0].clear();\n@@ -211,0 +176,1 @@\n+            setVisible(true);\n@@ -212,6 +178,0 @@\n-            addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    setVisible(false);\n-                    dispose();\n-                }\n-            });\n@@ -234,1 +194,0 @@\n-                    win_checkpoint[1] = new VisibilityValidator(txtDiag);\n@@ -236,1 +195,0 @@\n-                    event_checkpoint[1].clear();\n@@ -244,6 +202,0 @@\n-            addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    setVisible(false);\n-                    dispose();\n-                }\n-            });\n@@ -266,6 +218,0 @@\n-            addWindowListener(new WindowAdapter() {\n-                public void windowClosing(WindowEvent e) {\n-                    setVisible(false);\n-                    dispose();\n-                }\n-            });\n","filename":"test\/jdk\/java\/awt\/Dialog\/NestedDialogs\/Modeless\/NestedModelessDialogTest.java","additions":92,"deletions":146,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/*\n- * @summary Utility routines that wait for a window to be displayed or for\n-colors to be visible\n- * @summary com.apple.junit.utils\n- *\/\n-package test.java.awt.regtesthelpers;\n-\n-import java.awt.*;\n-import java.awt.event.*;\n-\n-\/\/import junit.framework.Assert;\n-public class VisibilityValidator {\n-\n-    \/\/ Wait up to five seconds for our window events\n-    static final int SETUP_PERIOD = 5000;\n-    static final boolean DEBUG = false;\n-\n-    volatile Window win = null;\n-    boolean activated = false;\n-    boolean opened = false;\n-    boolean focused = false;\n-    volatile boolean valid = false;\n-\n-    \/\/\n-    \/\/ Utility functions that encapsulates normal usage patterns\n-    \/\/\n-    public static void setVisibleAndConfirm(Frame testframe) throws Exception {\n-        setVisibleAndConfirm(testframe, \"Could not confirm test frame was \"\n-                + \"visible\");\n-    }\n-\n-    public static void setVisibleAndConfirm(Frame testframe, String msg)\n-            throws Exception {\n-        if (testframe.isVisible()) {\n-            throw new RuntimeException(\"Frame is already visible\");\n-        }\n-\n-        VisibilityValidator checkpoint = new VisibilityValidator(testframe);\n-        testframe.setVisible(true);\n-        checkpoint.requireVisible();\n-        if (!checkpoint.isValid()) {\n-            \/\/System.err.println(msg);\n-            throw new Exception(\"Frame not visible after \" + SETUP_PERIOD\n-                    + \" milliseconds\");\n-        }\n-    }\n-\n-    \/\/\n-    \/\/ Add listeners to the window\n-    \/\/\n-    public VisibilityValidator(Window win) {\n-        this.win = win;\n-        WindowAdapter watcher = new WindowAdapter() {\n-            public void windowOpened(WindowEvent e) {\n-                doOpen();\n-            }\n-\n-            public void windowActivated(WindowEvent e) {\n-                doActivate();\n-            }\n-\n-            public void windowGainedFocus(WindowEvent e) {\n-                doGainedFocus();\n-            }\n-        };\n-\n-        win.addWindowListener(watcher);\n-        win.addWindowFocusListener(watcher);\n-    }\n-\n-    \/\/ Make the window visible\n-    \/\/\n-    \/\/ The only way to make it through this routine is for the window to\n-    \/\/ generate BOTH a windowOpened, a windowActivated event and a\n-    \/\/ windowGainedFocus, or to timeout.\n-    \/\/\n-    synchronized public void requireVisible() {\n-        int tries = 0;\n-\n-        \/\/ wait for windowOpened and windowActivated events\n-        try {\n-            while ((opened == false)\n-                    || (activated == false)\n-                    || (focused == false)) {\n-                if (tries < 4) {\n-                    tries += 1;\n-                    wait(SETUP_PERIOD);\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            if (opened && activated) {\n-                valid = true;\n-            } else {\n-                valid = false;\n-            }\n-        } catch (InterruptedException ix) {\n-            valid = false;\n-        }\n-\n-        \/\/ Extra-super paranoid checks\n-        if (win.isVisible() == false) {\n-            valid = false;\n-        }\n-\n-        if (win.isShowing() == false) {\n-            valid = false;\n-        }\n-\n-        if (win.isFocused() == false) {\n-            valid = false;\n-        }\n-\n-        if (DEBUG) {\n-            if (!isValid()) {\n-                System.out.println(\"\\tactivated:\" + new Boolean(activated));\n-                System.out.println(\"\\topened:\" + new Boolean(opened));\n-                System.out.println(\"\\tfocused:\" + new Boolean(focused));\n-                System.out.println(\"\\tvalid:\" + new Boolean(valid));\n-                System.out.println(\"\\tisVisible():\"\n-                        + new Boolean(win.isVisible()));\n-                System.out.println(\"\\tisShowing():\"\n-                        + new Boolean(win.isShowing()));\n-                System.out.println(\"\\tisFocused():\"\n-                        + new Boolean(win.isFocused()));\n-            }\n-        }\n-\n-    }\n-\n-    synchronized void doOpen() {\n-        opened = true;\n-        notify();\n-    }\n-\n-    synchronized void doActivate() {\n-        activated = true;\n-        notify();\n-    }\n-\n-    synchronized void doGainedFocus() {\n-        focused = true;\n-        notify();\n-    }\n-\n-    public boolean isValid() {\n-        return valid;\n-    }\n-\n-    public boolean isClear() {\n-        return valid;\n-    }\n-\n-    volatile static Robot robot = null;\n-\n-    \/\/ utility function that waits until a Component is shown with the\n-    \/\/ appropriate color\n-    public static boolean waitForColor(Component c,\n-            Color expected) throws AWTException,\n-            InterruptedException {\n-        Dimension dim = c.getSize();\n-        int xOff = dim.width \/ 2;\n-        int yOff = dim.height \/ 2;\n-        return waitForColor(c, xOff, yOff, expected);\n-    }\n-\n-    \/\/ utility function that waits for 5 seconds for Component to be shown with\n-    \/\/ the appropriate color\n-    public static boolean waitForColor(Component c,\n-            int xOff,\n-            int yOff,\n-            Color expected) throws AWTException, InterruptedException {\n-        return waitForColor(c, xOff, yOff, expected, 5000L);\n-    }\n-\n-    \/\/ utility function that waits until a Component is up with the appropriate\n-    \/\/ color\n-    public static boolean waitForColor(Component c,\n-            int xOff,\n-            int yOff,\n-            Color expected,\n-            long timeout) throws AWTException, InterruptedException {\n-        Point p = c.getLocationOnScreen();\n-        int x = (int) p.getX() + xOff;\n-        int y = (int) p.getY() + yOff;\n-        return waitForColor(x, y, expected, timeout);\n-    }\n-\n-    \/\/ utility function that waits until specific screen coords have the\n-    \/\/ appropriate color\n-    public static boolean waitForColor(int locX,\n-            int locY,\n-            Color expected,\n-            long timeout) throws AWTException, InterruptedException {\n-        if (robot == null) {\n-            robot = new Robot();\n-        }\n-\n-        long endtime = System.currentTimeMillis() + timeout;\n-        while (endtime > System.currentTimeMillis()) {\n-            if (colorMatch(robot.getPixelColor(locX, locY), expected)) {\n-                return true;\n-            }\n-            Thread.sleep(50);\n-        }\n-\n-        return false;\n-    }\n-\n-    \/\/ utility function that asserts that two colors are similar to each other\n-    public static void assertColorEquals(final String message,\n-            final Color actual,\n-            final Color expected) {\n-        System.out.println(\"actual color: \" + actual);\n-        System.out.println(\"expect color: \" + expected);\n-        \/\/Assert.assertTrue(message, colorMatch(actual, expected));\n-    }\n-\n-    \/\/ determines if two colors are close in hue and brightness\n-    public static boolean colorMatch(final Color actual, final Color expected) {\n-        final float[] actualHSB = getHSB(actual);\n-        final float[] expectedHSB = getHSB(expected);\n-\n-        final float actualHue = actualHSB[0];\n-        final float expectedHue = expectedHSB[0];\n-        final boolean hueMatched = closeMatchHue(actualHue, expectedHue, 0.17f);\n-        \/\/System.out.println(\"hueMatched? \" + hueMatched);\n-        final float actualBrightness = actualHSB[2];\n-        final float expectedBrightness = expectedHSB[2];\n-        final boolean brightnessMatched = closeMatch(actualBrightness,\n-                expectedBrightness, 0.15f);\n-        \/\/System.out.println(\"brightnessMatched? \" + brightnessMatched);\n-\n-        \/\/ check to see if the brightness was so low or so high that the hue\n-        \/\/ got clamped to red\n-        if (brightnessMatched && !hueMatched) {\n-            return (expectedBrightness < 0.15f);\n-        }\n-\n-        return brightnessMatched && hueMatched;\n-    }\n-\n-    static float[] getHSB(final Color color) {\n-        final float[] hsb = new float[3];\n-        Color.RGBtoHSB(color.getRed(), color.getGreen(), color.getBlue(), hsb);\n-        return hsb;\n-    }\n-\n-    \/\/ matches hues from 0.0 to 1.0, accounting for wrap-around at the 1.0\/0.0\n-    \/\/ boundry\n-    static boolean closeMatchHue(final float actual,\n-            final float expected,\n-            final float tolerance) {\n-        if (closeMatch(actual, expected, tolerance)) {\n-            return true;\n-        }\n-\n-        \/\/ all that remains is the overflow and underflow cases\n-        final float expectedHigh = expected + tolerance;\n-        final float expectedLow = expected - tolerance;\n-\n-        if (expectedHigh > 1.0f) {\n-            \/\/ expected is too high, and actual was too low\n-            \/\/System.out.println(\"\\thue expected too high, actual too low\");\n-            return closeMatch(actual + 0.5f, expected - 0.5f, tolerance);\n-        }\n-\n-        if (expectedLow < 0.0f) {\n-            \/\/ expected is too low, and actual was too high\n-            \/\/System.out.println(\"\\thue expected too low, actual too high\");\n-            return closeMatch(actual - 0.5f, expected + 0.5f, tolerance);\n-        }\n-\n-        \/\/System.out.println(\"\\tcloseMatchHue? \" + false);\n-        return false;\n-    }\n-\n-    static boolean closeMatch(final float actual,\n-            final float expected,\n-            final float tolerance) {\n-        return (expected + tolerance) > actual && (expected - tolerance) < actual;\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/VisibilityValidator.java","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"},{"patch":"@@ -1,105 +0,0 @@\n-\/*\n- * Copyright (c) 2011, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n- \/*\n- * @summary This is a utility for coordinating the flow of events on different\n-            threads.\n- * @summary com.apple.junit.utils\n- *\/\n-package test.java.awt.regtesthelpers;\n-\n-public class Waypoint {\n-\n-    static final String MSG = \"Waypoint timed out\";\n-    \/\/ Wait up to five seconds for our clear() to be called\n-    static final int TIMEOUT = 5000;\n-    boolean clear = false;\n-\n-    public Waypoint() {\n-\n-    }\n-\n-    \/\/\n-    \/\/    Pause for either TIMEOUT millis or until clear() is called\n-    \/\/\n-    synchronized public void requireClear() throws RuntimeException {\n-        requireClear(MSG, TIMEOUT);\n-    }\n-\n-    synchronized public void requireClear(long timeout)\n-            throws RuntimeException {\n-        requireClear(MSG, timeout);\n-    }\n-\n-    synchronized public void requireClear(String timeOutMsg)\n-            throws RuntimeException {\n-        requireClear(timeOutMsg, TIMEOUT);\n-    }\n-\n-    synchronized public void requireClear(String timeOutMsg, long timeout)\n-            throws RuntimeException {\n-        long endtime = System.currentTimeMillis() + timeout;\n-        try {\n-            while (isClear() == false) {\n-                if (System.currentTimeMillis() < endtime) {\n-                    wait(200);\n-                } else {\n-                    break;\n-                }\n-            }\n-\n-            if (!isClear()) {\n-                throw new RuntimeException(timeOutMsg);\n-            }\n-        } catch (InterruptedException ix) {\n-        }\n-    }\n-\n-    \/\/\n-    \/\/    Called when it is valid to procede past the waypoint\n-    \/\/\n-    synchronized public void clear() {\n-        clear = true;\n-        notify();\n-    }\n-\n-    \/\/\n-    \/\/    Should be checked after a call to requireClear() to make\n-    \/\/    sure that we did not time out.\n-    \/\/\n-    synchronized public boolean isClear() {\n-        return clear;\n-    }\n-\n-    synchronized public boolean isValid() {\n-        return clear;\n-    }\n-\n-    \/\/\n-    \/\/    For re-use of a waypoint.  Be careful.\n-    \/\/\n-    synchronized public void reset() {\n-        clear = false;\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/awt\/regtesthelpers\/Waypoint.java","additions":0,"deletions":105,"binary":false,"changes":105,"status":"deleted"}]}