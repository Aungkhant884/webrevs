{"files":[{"patch":"@@ -44,0 +44,1 @@\n+#include \"utilities\/vmError.hpp\"\n@@ -856,0 +857,123 @@\n+\n+\/\/ Only when the current frame is a C frame(implicit in call sites)\n+\/\/ and the sender frame has a code blob but is not an interpreted frame\n+\/\/ or entry frame(for these two frames, we do not need accurate sp to\n+\/\/ be able to walk the stack correctly), we need to deduce the sender's sp.\n+\/\/\n+\/\/ To reduce the impact, we are only doing this when a VM error is reported.\n+\/\/ And when PreserveFramePointer is enabled, we also don't need to rely on\n+\/\/ the accurate sp.(See JDK-8277948 for more details)\n+bool frame::need_to_deduce_sender_sp(frame &sender) {\n+  return VMError::is_error_reported() && !PreserveFramePointer\n+         && sender.cb() != NULL && !sender.is_interpreted_frame()\n+         && !sender.is_entry_frame();\n+}\n+\n+#define STP_PRE_INDEX_X29_X30_SP_MASK  0xA9807BFD \/\/ stp x29, x30, [sp, #-N]!\n+#define STP_PRE_INDEX_R_R_SP_MASK      0xA98003E0 \/\/ stp x?, x?, [sp, #-N]!\n+#define STP_SIGNED_OFFSET_X29_X30_MASK 0xA9007BFD \/\/ stp x29, x30, [sp, #N]\n+#define SUB_SP_MASK                    0xD10003FF \/\/ sub sp, sp, #N\n+\n+#define IS_INSTRUCTION(ins, mask)         ((ins) & (mask)) == (mask)\n+#define IS_STP_PRE_INDEX_X29_X30_SP(ins)  IS_INSTRUCTION(ins, STP_PRE_INDEX_X29_X30_SP_MASK)\n+#define IS_STP_SIGNED_OFFSET_X29_X30(ins) IS_INSTRUCTION(ins, STP_SIGNED_OFFSET_X29_X30_MASK)\n+#define IS_SUB_SP(ins)                    IS_INSTRUCTION(ins, SUB_SP_MASK)\n+#define IS_STP_PRE_INDEX_R_R_SP(ins)      IS_INSTRUCTION(ins, STP_PRE_INDEX_R_R_SP_MASK)\n+\n+#define ADD_SP_16                               0x910043FF \/\/ add sp, sp, #16\n+#define LDP_POST_INDEX_LTP_X8_X12_SP_16         0xA8C133E8 \/\/ ldp rscratch1(x8), rmethod(x12), sp, #16\n+#define IS_ADD_SP_16(ins)                       ins == ADD_SP_16\n+#define IS_LDP_POST_INDEX_LTP_X8_X12_SP_16(ins) ins == LDP_POST_INDEX_LTP_X8_X12_SP_16\n+\n+#define GET_STP_IMMEDIATE(ins) (signed char)(((int)(ins) << 10) >> 25)\n+#define GET_SUB_IMMEDIATE(ins) (((ins) << 10) >> (20 + 3))\n+\n+intptr_t *frame::deduce_sender_sp(frame &fr) {\n+#ifdef ASSERT\n+  frame sender(fr.link(), fr.link(), fr.sender_pc());\n+  assert(need_to_deduce_sender_sp(sender), \"sanity check\");\n+#endif\n+\n+  address pc = fr.pc();\n+  int offset;\n+  char dummy[1];\n+  if (pc != (address)-1 && os::dll_address_to_function_name(pc, dummy, 1, &offset, false)\n+      && offset > 0) {\n+    unsigned *cur = (unsigned *)(pc - offset);\n+    if (cur < (unsigned *)pc) {\n+      intptr_t *result;\n+      bool matched = false;\n+      unsigned ins;\n+      do {\n+        ins = *cur;\n+        if (IS_STP_PRE_INDEX_X29_X30_SP(ins)) {\n+          \/\/ Pattern 1:\n+          \/\/   ...\n+          \/\/   stp x29, x30, [sp, #-N]!\n+          \/\/   ...\n+          \/\/   mov x29, sp\n+          \/\/   ...\n+          \/\/ => sender sp = fp + N\n+          signed char imm = GET_STP_IMMEDIATE(ins);\n+          result = fr.addr_at(-imm);\n+          matched = true;\n+          break;\n+        } else if (IS_SUB_SP(ins)) {\n+          \/\/ Pattern 2:\n+          \/\/   ...\n+          \/\/   sub sp, sp, #N1\n+          \/\/   ...\n+          \/\/   stp x29, x30, [sp, #N2]\n+          \/\/   add x29, sp, #N2\n+          \/\/   ...\n+          \/\/ => sender sp = fp + (N1 - N2)\n+          int n1 = GET_SUB_IMMEDIATE(ins);\n+          while (++cur < (unsigned *) pc) {\n+            ins = *cur;\n+            if (IS_STP_SIGNED_OFFSET_X29_X30(ins)) {\n+              signed char n2 = GET_STP_IMMEDIATE(ins);\n+              result = fr.addr_at(n1 - (int) n2);\n+              matched = true;\n+              break;\n+            }\n+          }\n+          break;\n+        } else if (IS_STP_PRE_INDEX_R_R_SP(ins)) {\n+          \/\/ Pattern 3:\n+          \/\/   ...\n+          \/\/   stp Xt1, Xt2, [sp, #-N1]! ; Xt1 is not x29, Xt2 is not x30\n+          \/\/   ...\n+          \/\/   stp x29, x30, [sp, #N2]\n+          \/\/   add x29, sp, #N2\n+          \/\/   ...\n+          \/\/ => sender sp = fp + (N1 - N2)\n+          signed char n1 = GET_STP_IMMEDIATE(ins);\n+          while (++cur < (unsigned *) pc) {\n+            ins = *cur;\n+            if (IS_STP_SIGNED_OFFSET_X29_X30(ins)) {\n+              signed char n2 = GET_STP_IMMEDIATE(ins);\n+              result = fr.addr_at(-n1 - n2);\n+              matched = true;\n+              break;\n+            }\n+          }\n+          break;\n+        }\n+      } while (++cur < (unsigned *)pc);\n+\n+      if (matched) {\n+        ins = *(unsigned *)fr.sender_pc();\n+        \/\/ There are two cases to be dealt with specially:\n+        \/\/ a. In aarch64.ad, aarch64_enc_java_to_runtime left a breadcrumb: add sp, sp, #16\n+        \/\/ b. MacroAssembler::call_VM_leaf_base saved rmethod: ldp rscratch1, rmethod, sp, #16\n+        if (IS_ADD_SP_16(ins) || IS_LDP_POST_INDEX_LTP_X8_X12_SP_16(ins)) {\n+          \/\/ skip 2 slots to get the original sp\n+          result += 2;\n+        }\n+        return result;\n+      }\n+    }\n+  }\n+  \/\/ fall through\n+  return fr.link();\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":124,"deletions":0,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -175,0 +175,2 @@\n+  static bool need_to_deduce_sender_sp(frame& sender);\n+  static intptr_t* deduce_sender_sp(frame& frame);\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -179,1 +179,5 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  frame sender(fr->link(), fr->link(), fr->sender_pc());\n+  if (frame::need_to_deduce_sender_sp(sender)) {\n+    return frame(frame::deduce_sender_sp(*fr), fr->link(), fr->sender_pc());\n+  }\n+  return sender;\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -149,1 +149,5 @@\n-  return frame(fr->link(), fr->link(), fr->sender_pc());\n+  frame sender(fr->link(), fr->link(), fr->sender_pc());\n+  if (frame::need_to_deduce_sender_sp(sender)) {\n+    return frame(frame::deduce_sender_sp(*fr), fr->link(), fr->sender_pc());\n+  }\n+  return sender;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}