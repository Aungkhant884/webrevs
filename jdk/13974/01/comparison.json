{"files":[{"patch":"@@ -5515,0 +5515,25 @@\n+\/\/ Combined rule for VectorStoreMask + VectorMaskTrueCount when the vector element type is not T_BYTE.\n+\n+instruct vstoremask_truecount(iRegINoSp dst, vReg src, immI_gt_1 size, vReg vtmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask src size)));\n+  effect(TEMP vtmp);\n+  format %{ \"vstoremask_truecount $dst, $src\\t# KILL $vtmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector mask represented as lanes with\n+    \/\/ 0\/-1 as element values.\n+    uint esize = (uint)$size$$constant;\n+    if (esize == 8) {\n+      __ addpd($vtmp$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+      Assembler::SIMD_Arrangement arrangement = Assembler::esize2arrangement(esize,\n+                                                                             \/* isQ *\/ length_in_bytes == 16);\n+      __ addv($vtmp$$FloatRegister, arrangement, $src$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $vtmp$$FloatRegister, __ B, 0);\n+    __ neg($dst$$Register, $dst$$Register);\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -3821,0 +3821,25 @@\n+  %}\n+  ins_pipe(pipe_slow);\n+%}\n+\n+\/\/ Combined rule for VectorStoreMask + VectorMaskTrueCount when the vector element type is not T_BYTE.\n+\n+instruct vstoremask_truecount(iRegINoSp dst, vReg src, immI_gt_1 size, vReg vtmp) %{\n+  predicate(UseSVE == 0);\n+  match(Set dst (VectorMaskTrueCount (VectorStoreMask src size)));\n+  effect(TEMP vtmp);\n+  format %{ \"vstoremask_truecount $dst, $src\\t# KILL $vtmp\" %}\n+  ins_encode %{\n+    \/\/ Input \"src\" is a vector mask represented as lanes with\n+    \/\/ 0\/-1 as element values.\n+    uint esize = (uint)$size$$constant;\n+    if (esize == 8) {\n+      __ addpd($vtmp$$FloatRegister, $src$$FloatRegister);\n+    } else {\n+      uint length_in_bytes = Matcher::vector_length_in_bytes(this, $src);\n+      Assembler::SIMD_Arrangement arrangement = Assembler::esize2arrangement(esize,\n+                                                                             \/* isQ *\/ length_in_bytes == 16);\n+      __ addv($vtmp$$FloatRegister, arrangement, $src$$FloatRegister);\n+    }\n+    __ smov($dst$$Register, $vtmp$$FloatRegister, __ B, 0);\n+    __ neg($dst$$Register, $dst$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1471,0 +1471,5 @@\n+    public static final String VSTOREMASK_TRUECOUNT = PREFIX + \"VSTOREMASK_TRUECOUNT\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(VSTOREMASK_TRUECOUNT, \"vstoremask_truecount\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright (c) 2023, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8307795\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @requires os.arch==\"aarch64\"\n+ * @summary AArch64: Optimize VectorMask.truecount() on Neon\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.TestVectorMaskTrueCount\n+ *\/\n+\n+public class TestVectorMaskTrueCount {\n+    private static final VectorSpecies<Double> SPECIES = DoubleVector.SPECIES_PREFERRED;\n+    private static final int LENGTH = 1024;\n+    private static final Random RD = new Random();\n+    private static boolean[] ba;\n+    private static boolean[] bb;\n+\n+    static {\n+        ba = new boolean[LENGTH];\n+        bb = new boolean[LENGTH];\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = RD.nextBoolean();\n+            bb[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    static int maskAndTrueCount(boolean[] a, boolean[] b, int idx) {\n+        int trueCount = 0;\n+        boolean[] c = new boolean[SPECIES.length()];\n+\n+        for (int i = idx; i < idx + SPECIES.length(); i++) {\n+            c[i - idx] = a[i] & b[i];\n+        }\n+\n+        for (int i = 0; i < c.length; i++) {\n+            trueCount += c[i] ? 1 : 0;\n+        }\n+\n+        return trueCount;\n+    }\n+\n+    static void assertArrayEquals(int[] r, boolean[] a, boolean[] b) {\n+        for (int i = 0; i < a.length; i += SPECIES.length()) {\n+            Asserts.assertEquals(r[i], maskAndTrueCount(a, b, i));\n+        }\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.VSTOREMASK_TRUECOUNT, \">= 1\" })\n+    public static void test() {\n+        int[] r = new int[LENGTH];\n+        for (int i = 0; i < LENGTH; i += SPECIES.length()) {\n+            VectorMask<Double> ma = VectorMask.fromArray(SPECIES, ba, i);\n+            VectorMask<Double> mb = VectorMask.fromArray(SPECIES, bb, i);\n+            r[i] = ma.and(mb).trueCount();\n+        }\n+\n+        assertArrayEquals(r, ba, bb);\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework testFramework = new TestFramework();\n+        testFramework.setDefaultWarmup(10000)\n+                     .addFlags(\"--add-modules=jdk.incubator.vector\")\n+                     .addFlags(\"-XX:UseSVE=0\")\n+                     .start();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorMaskTrueCount.java","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,84 @@\n+\/\/\n+\/\/ Copyright (c) 2023, Arm Limited. All rights reserved.\n+\/\/ DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+\/\/\n+\/\/ This code is free software; you can redistribute it and\/or modify it\n+\/\/ under the terms of the GNU General Public License version 2 only, as\n+\/\/ published by the Free Software Foundation.\n+\/\/\n+\/\/ This code is distributed in the hope that it will be useful, but WITHOUT\n+\/\/ ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+\/\/ FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+\/\/ version 2 for more details (a copy is included in the LICENSE file that\n+\/\/ accompanied this code).\n+\/\/\n+\/\/ You should have received a copy of the GNU General Public License version\n+\/\/ 2 along with this work; if not, write to the Free Software Foundation,\n+\/\/ Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+\/\/\n+\/\/ Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+\/\/ or visit www.oracle.com if you need additional information or have any\n+\/\/ questions.\n+\/\/\n+\/\/\n+package org.openjdk.bench.jdk.incubator.vector;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+import jdk.incubator.vector.*;\n+import org.openjdk.jmh.annotations.*;\n+\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@Fork(jvmArgsPrepend = {\"--add-modules=jdk.incubator.vector\"})\n+public class StoreMaskTrueCount {\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_PREFERRED;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_PREFERRED;\n+    private static final int LENGTH = 1024;\n+    private static final Random RD = new Random();\n+    private static boolean[] ba;\n+\n+    static {\n+        ba = new boolean[LENGTH];\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    @Benchmark\n+    public static int testShort() {\n+        VectorMask<Short> m = VectorMask.fromArray(S_SPECIES, ba, 0);\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i++) {\n+            m = m.not();\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public static int testInt() {\n+        VectorMask<Integer> m = VectorMask.fromArray(I_SPECIES, ba, 0);\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i++) {\n+            m = m.not();\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public static int testLong() {\n+        VectorMask<Long> m = VectorMask.fromArray(L_SPECIES, ba, 0);\n+        int res = 0;\n+        for (int i = 0; i < LENGTH; i++) {\n+            m = m.not();\n+            res += m.trueCount();\n+        }\n+\n+        return res;\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/StoreMaskTrueCount.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"}]}