{"files":[{"patch":"@@ -2840,2 +2840,2 @@\n-  _survivor_evac_stats.adjust_desired_plab_sz();\n-  _old_evac_stats.adjust_desired_plab_sz();\n+  _survivor_evac_stats.adjust_desired_plab_size();\n+  _old_evac_stats.adjust_desired_plab_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-  size_t gclab_word_size = alloc_buffer_stats(dest)->desired_plab_sz(workers()->active_workers());\n+  size_t gclab_word_size = alloc_buffer_stats(dest)->desired_plab_size(workers()->active_workers());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,12 @@\n-  PLABStats::log_plab_allocation();\n+  log_debug(gc, plab)(\"%s PLAB allocation: \"\n+                      \"allocated: %zuB, \"\n+                      \"wasted: %zuB, \"\n+                      \"unused: %zuB, \"\n+                      \"used: %zuB, \"\n+                      \"undo waste: %zuB, \",\n+                      _description,\n+                      _allocated * HeapWordSize,\n+                      _wasted * HeapWordSize,\n+                      _unused * HeapWordSize,\n+                      used() * HeapWordSize,\n+                      _undo_wasted * HeapWordSize);\n@@ -36,1 +47,1 @@\n-                      \"region end waste: \" SIZE_FORMAT \"B, \"\n+                      \"region end waste: %zuB, \"\n@@ -38,3 +49,3 @@\n-                      \"direct allocated: \" SIZE_FORMAT \"B, \"\n-                      \"failure used: \" SIZE_FORMAT \"B, \"\n-                      \"failure wasted: \" SIZE_FORMAT \"B\",\n+                      \"direct allocated: %zuB, \"\n+                      \"failure used: %zuB, \"\n+                      \"failure wasted: %zuB\",\n@@ -49,1 +60,10 @@\n-size_t G1EvacStats::compute_desired_plab_sz() {\n+void G1EvacStats::log_sizing(size_t calculated_words, size_t net_desired_words) {\n+  log_debug(gc, plab)(\"%s sizing: \"\n+                      \"calculated: %zuB, \"\n+                      \"actual: %zuB\",\n+                      _description,\n+                      calculated_words * HeapWordSize,\n+                      net_desired_words * HeapWordSize);\n+}\n+\n+size_t G1EvacStats::compute_desired_plab_size() const {\n@@ -89,2 +109,1 @@\n-  size_t const cur_plab_sz = (size_t)((double)total_waste_allowed \/ G1LastPLABAverageOccupancy);\n-  return cur_plab_sz;\n+  return (size_t)((double)total_waste_allowed \/ G1LastPLABAverageOccupancy);\n@@ -94,1 +113,4 @@\n-  PLABStats(description, default_per_thread_plab_size, default_per_thread_plab_size * ParallelGCThreads, wt),\n+  PLABStats(description),\n+  _default_plab_size(default_per_thread_plab_size),\n+  _desired_net_plab_size(default_per_thread_plab_size * ParallelGCThreads),\n+  _net_plab_size_filter(wt),\n@@ -102,0 +124,22 @@\n+\/\/ Calculates plab size for current number of gc worker threads.\n+size_t G1EvacStats::desired_plab_size(uint no_of_gc_workers) const {\n+  if (!ResizePLAB) {\n+      return _default_plab_size;\n+  }\n+  return align_object_size(clamp(_desired_net_plab_size \/ no_of_gc_workers, min_size(), max_size()));\n+}\n+\n+void G1EvacStats::adjust_desired_plab_size() {\n+  log_plab_allocation();\n+\n+  if (ResizePLAB) {\n+    assert(is_object_aligned(max_size()) && min_size() <= max_size(),\n+           \"PLAB clipping computation may be incorrect\");\n+\n+    assert(_allocated != 0 || _unused == 0,\n+           \"Inconsistency in PLAB stats: \"\n+           \"_allocated: %zu, \"\n+           \"_wasted: %zu, \"\n+           \"_unused: %zu, \"\n+           \"_undo_wasted: %zu\",\n+           _allocated, _wasted, _unused, _undo_wasted);\n@@ -103,1 +147,10 @@\n-G1EvacStats::~G1EvacStats() { }\n+    size_t plab_size = compute_desired_plab_size();\n+    \/\/ Take historical weighted average\n+    _net_plab_size_filter.sample(plab_size);\n+    _desired_net_plab_size = MAX2(min_size(), (size_t)_net_plab_size_filter.average());\n+\n+    log_sizing(plab_size, _desired_net_plab_size);\n+  }\n+  \/\/ Clear accumulators for next round\n+  reset();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacStats.cpp","additions":64,"deletions":11,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/gcUtil.hpp\"\n@@ -30,1 +31,2 @@\n-\/\/ Records various memory allocation statistics gathered during evacuation.\n+\/\/ Records various memory allocation statistics gathered during evacuation. All sizes\n+\/\/ are in HeapWords.\n@@ -32,1 +34,5 @@\n- private:\n+  size_t _default_plab_size;\n+  size_t _desired_net_plab_size; \/\/ Output of filter (below), suitably trimmed and quantized\n+  AdaptiveWeightedAverage\n+         _net_plab_size_filter;  \/\/ Integrator with decay\n+\n@@ -54,1 +60,2 @@\n-  virtual void log_plab_allocation();\n+  void log_plab_allocation();\n+  void log_sizing(size_t calculated_words, size_t net_desired_words);\n@@ -56,1 +63,1 @@\n-  virtual size_t compute_desired_plab_sz();\n+  size_t compute_desired_plab_size() const;\n@@ -58,1 +65,1 @@\n- public:\n+public:\n@@ -61,1 +68,7 @@\n-  ~G1EvacStats();\n+  \/\/ Calculates plab size for current number of gc worker threads.\n+  size_t desired_plab_size(uint no_of_gc_workers) const;\n+\n+  \/\/ Computes the new desired PLAB size assuming one gc worker thread, updating\n+  \/\/ _desired_plab_sz, and clearing statistics for the next GC.\n+  \/\/ Should be called at the end of a GC pause.\n+  void adjust_desired_plab_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacStats.hpp","additions":19,"deletions":6,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -105,78 +105,0 @@\n-\n-void PLABStats::log_plab_allocation() {\n-  log_debug(gc, plab)(\"%s PLAB allocation: \"\n-                      \"allocated: \" SIZE_FORMAT \"B, \"\n-                      \"wasted: \" SIZE_FORMAT \"B, \"\n-                      \"unused: \" SIZE_FORMAT \"B, \"\n-                      \"used: \" SIZE_FORMAT \"B, \"\n-                      \"undo waste: \" SIZE_FORMAT \"B, \",\n-                      _description,\n-                      _allocated * HeapWordSize,\n-                      _wasted * HeapWordSize,\n-                      _unused * HeapWordSize,\n-                      used() * HeapWordSize,\n-                      _undo_wasted * HeapWordSize);\n-}\n-\n-void PLABStats::log_sizing(size_t calculated_words, size_t net_desired_words) {\n-  log_debug(gc, plab)(\"%s sizing: \"\n-                      \"calculated: \" SIZE_FORMAT \"B, \"\n-                      \"actual: \" SIZE_FORMAT \"B\",\n-                      _description,\n-                      calculated_words * HeapWordSize,\n-                      net_desired_words * HeapWordSize);\n-}\n-\n-\/\/ Calculates plab size for current number of gc worker threads.\n-size_t PLABStats::desired_plab_sz(uint no_of_gc_workers) {\n-  if (!ResizePLAB) {\n-      return _default_plab_sz;\n-  }\n-  return align_object_size(clamp(_desired_net_plab_sz \/ no_of_gc_workers, min_size(), max_size()));\n-}\n-\n-\/\/ Compute desired plab size for one gc worker thread and latch result for later\n-\/\/ use. This should be called once at the end of parallel\n-\/\/ scavenge; it clears the sensor accumulators.\n-void PLABStats::adjust_desired_plab_sz() {\n-  log_plab_allocation();\n-\n-  if (!ResizePLAB) {\n-    \/\/ Clear accumulators for next round.\n-    reset();\n-    return;\n-  }\n-\n-  assert(is_object_aligned(max_size()) && min_size() <= max_size(),\n-         \"PLAB clipping computation may be incorrect\");\n-\n-  assert(_allocated != 0 || _unused == 0,\n-         \"Inconsistency in PLAB stats: \"\n-         \"_allocated: \" SIZE_FORMAT \", \"\n-         \"_wasted: \" SIZE_FORMAT \", \"\n-         \"_unused: \" SIZE_FORMAT \", \"\n-         \"_undo_wasted: \" SIZE_FORMAT,\n-         _allocated, _wasted, _unused, _undo_wasted);\n-\n-  size_t plab_sz = compute_desired_plab_sz();\n-  \/\/ Take historical weighted average\n-  _filter.sample(plab_sz);\n-  _desired_net_plab_sz = MAX2(min_size(), (size_t)_filter.average());\n-\n-  log_sizing(plab_sz, _desired_net_plab_sz);\n-  \/\/ Clear accumulators for next round\n-  reset();\n-}\n-\n-size_t PLABStats::compute_desired_plab_sz() {\n-  size_t allocated      = MAX2(_allocated, size_t(1));\n-  double wasted_frac    = (double)_unused \/ (double)allocated;\n-  size_t target_refills = (size_t)((wasted_frac * TargetSurvivorRatio) \/ TargetPLABWastePct);\n-  if (target_refills == 0) {\n-    target_refills = 1;\n-  }\n-  size_t used = allocated - _wasted - _unused;\n-  \/\/ Assumed to have 1 gc worker thread\n-  size_t recent_plab_sz = used \/ target_refills;\n-  return recent_plab_sz;\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.cpp","additions":0,"deletions":78,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"gc\/shared\/gcUtil.hpp\"\n@@ -144,1 +143,1 @@\n- protected:\n+protected:\n@@ -151,4 +150,0 @@\n-  size_t _default_plab_sz;\n-  size_t _desired_net_plab_sz;\/\/ Output of filter (below), suitably trimmed and quantized\n-  AdaptiveWeightedAverage\n-         _filter;             \/\/ Integrator with decay\n@@ -163,8 +158,2 @@\n-  virtual void log_plab_allocation();\n-  virtual void log_sizing(size_t calculated, size_t net_desired);\n-\n-  \/\/ helper for adjust_desired_plab_sz().\n-  virtual size_t compute_desired_plab_sz();\n-\n- public:\n-  PLABStats(const char* description, size_t default_per_thread_plab_size, size_t desired_net_plab_sz, unsigned wt) :\n+public:\n+  PLABStats(const char* description) :\n@@ -175,4 +164,1 @@\n-    _unused(0),\n-    _default_plab_sz(default_per_thread_plab_size),\n-    _desired_net_plab_sz(desired_net_plab_sz),\n-    _filter(wt)\n+    _unused(0)\n@@ -197,7 +183,0 @@\n-  \/\/ Calculates plab size for current number of gc worker threads.\n-  size_t desired_plab_sz(uint no_of_gc_workers);\n-\n-  \/\/ Updates the current desired PLAB size. Computes the new desired PLAB size with one gc worker thread,\n-  \/\/ updates _desired_plab_sz and clears sensor accumulators.\n-  void adjust_desired_plab_sz();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/plab.hpp","additions":4,"deletions":25,"binary":false,"changes":29,"status":"modified"}]}