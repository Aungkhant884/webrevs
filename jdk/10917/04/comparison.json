{"files":[{"patch":"@@ -126,4 +126,4 @@\n-  assert_cond(method != NULL && caller != NULL && interpreter_frame != NULL);\n-  int max_locals = method->max_locals() * Interpreter::stackElementWords;\n-  int extra_locals = (method->max_locals() - method->size_of_parameters()) *\n-    Interpreter::stackElementWords;\n+\n+  const int max_locals = method->max_locals() * Interpreter::stackElementWords;\n+  const int params = method->size_of_parameters() * Interpreter::stackElementWords;\n+  const int extra_locals = max_locals - params;\n@@ -139,6 +139,3 @@\n-  intptr_t* locals = NULL;\n-  if (caller->is_interpreted_frame()) {\n-    locals = caller->interpreter_frame_last_sp() + caller_actual_parameters - 1;\n-  } else {\n-    locals = interpreter_frame->sender_sp() + max_locals - 1;\n-  }\n+  intptr_t* const locals = caller->is_interpreted_frame()\n+    ? caller->interpreter_frame_last_sp() + caller_actual_parameters - 1\n+    : interpreter_frame->sender_sp() + max_locals - 1;\n@@ -179,5 +176,2 @@\n-  if (extra_locals != 0 &&\n-      interpreter_frame->sender_sp() ==\n-      interpreter_frame->interpreter_frame_sender_sp()) {\n-    interpreter_frame->set_interpreter_frame_sender_sp(caller->sp() +\n-                                                       extra_locals);\n+  if (extra_locals != 0 && interpreter_frame->sender_sp() == interpreter_frame->interpreter_frame_sender_sp()) {\n+    interpreter_frame->set_interpreter_frame_sender_sp(caller->sp() + extra_locals);\n@@ -186,4 +180,2 @@\n-  *interpreter_frame->interpreter_frame_cache_addr() =\n-    method->constants()->cache();\n-  *interpreter_frame->interpreter_frame_mirror_addr() =\n-    method->method_holder()->java_mirror();\n+  *interpreter_frame->interpreter_frame_cache_addr() = method->constants()->cache();\n+  *interpreter_frame->interpreter_frame_mirror_addr() = method->method_holder()->java_mirror();\n","filename":"src\/hotspot\/cpu\/riscv\/abstractInterpreter_riscv.cpp","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -1362,0 +1362,1 @@\n+  __ post_call_nop();\n@@ -1371,0 +1372,1 @@\n+  __ post_call_nop();\n@@ -1855,0 +1857,1 @@\n+  __ post_call_nop();\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  \/\/ done\n@@ -107,0 +108,1 @@\n+  increment(Address(xthread, JavaThread::held_monitor_count_offset()));\n@@ -135,0 +137,1 @@\n+  \/\/ done\n@@ -136,0 +139,1 @@\n+  decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/compile.hpp\"\n@@ -1681,0 +1682,10 @@\n+\n+bool C2_MacroAssembler::in_scratch_emit_size() {\n+  if (ciEnv::current()->task() != NULL) {\n+    PhaseOutput* phase_output = Compile::current()->output();\n+    if (phase_output != NULL && phase_output->in_scratch_emit_size()) {\n+      return true;\n+    }\n+  }\n+  return MacroAssembler::in_scratch_emit_size();\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,3 @@\n+  \/\/ Return true if the phase output is in the scratch emit size mode.\n+  virtual bool in_scratch_emit_size() override;\n+\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -30,1 +30,4 @@\n-\/\/ TODO: Implement\n+#include \"code\/codeCache.hpp\"\n+#include \"oops\/method.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n@@ -33,2 +36,4 @@\n-  Unimplemented();\n-  return frame();\n+  static CodeBlob* cb = CodeCache::find_blob_fast(entry_pc());\n+  assert(cb != nullptr, \"\");\n+  assert(cb->as_compiled_method()->method()->is_continuation_enter_intrinsic(), \"\");\n+  return frame(entry_sp(), entry_sp(), entry_fp(), entry_pc(), cb);\n@@ -38,2 +43,1 @@\n-  Unimplemented();\n-  return nullptr;\n+  return (intptr_t*)((address)this + size()) + 2;\n@@ -43,1 +47,2 @@\n-  Unimplemented();\n+  intptr_t** fp = (intptr_t**)(bottom_sender_sp() - 2);\n+  frame::update_map_with_saved_link(map, fp);\n","filename":"src\/hotspot\/cpu\/riscv\/continuationEntry_riscv.inline.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"code\/codeBlob.inline.hpp\"\n@@ -33,2 +34,9 @@\n-inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n-  Unimplemented();\n+inline void patch_callee_link(const frame& f, intptr_t* fp) {\n+  DEBUG_ONLY(intptr_t* orig = *ContinuationHelper::Frame::callee_link_address(f));\n+  *ContinuationHelper::Frame::callee_link_address(f) = fp;\n+}\n+\n+inline void patch_callee_link_relative(const frame& f, intptr_t* fp) {\n+  intptr_t* la = (intptr_t*)ContinuationHelper::Frame::callee_link_address(f);\n+  intptr_t new_value = fp - la;\n+  *la = new_value;\n@@ -37,0 +45,11 @@\n+\/\/\/\/\/\/ Freeze\n+\n+\/\/ Fast path\n+\n+inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n+  \/\/ copy the spilled fp from the heap to the stack\n+  *(frame_sp - 2) = *(heap_sp - 2);\n+}\n+\n+\/\/ Slow path\n+\n@@ -39,2 +58,17 @@\n-  Unimplemented();\n-  return frame();\n+  assert(FKind::is_instance(f), \"\");\n+  if (FKind::interpreted) {\n+    return frame(f.sender_sp(), f.interpreter_frame_sender_sp(), f.link(), f.sender_pc());\n+  }\n+\n+  intptr_t** link_addr = link_address<FKind>(f);\n+  intptr_t* sender_sp = (intptr_t*)(link_addr + 2); \/\/  f.unextended_sp() + (fsize\/wordSize); \/\/\n+  address sender_pc = (address) *(sender_sp - 1);\n+  assert(sender_sp != f.sp(), \"must have changed\");\n+\n+  int slot = 0;\n+  CodeBlob* sender_cb = CodeCache::find_blob_and_oopmap(sender_pc, slot);\n+  return sender_cb != nullptr\n+    ? frame(sender_sp, sender_sp, *link_addr, sender_pc, sender_cb,\n+            slot == -1 ? nullptr : sender_cb->oop_map_for_slot(slot, sender_pc),\n+            false \/* on_heap ? *\/)\n+    : frame(sender_sp, sender_sp, *link_addr, sender_pc);\n@@ -44,2 +78,42 @@\n-  Unimplemented();\n-  return frame();\n+  assert(FKind::is_instance(f), \"\");\n+  assert(!caller.is_interpreted_frame()\n+    || caller.unextended_sp() == (intptr_t*)caller.at(frame::interpreter_frame_last_sp_offset), \"\");\n+\n+  intptr_t *sp, *fp; \/\/ sp is really our unextended_sp\n+  if (FKind::interpreted) {\n+    assert((intptr_t*)f.at(frame::interpreter_frame_last_sp_offset) == nullptr\n+      || f.unextended_sp() == (intptr_t*)f.at(frame::interpreter_frame_last_sp_offset), \"\");\n+    int locals = f.interpreter_frame_method()->max_locals();\n+    \/\/ If the caller.is_empty(), i.e. we're freezing into an empty chunk, then we set\n+    \/\/ the chunk's argsize in finalize_freeze and make room for it above the unextended_sp\n+    bool overlap_caller = caller.is_interpreted_frame() || caller.is_empty();\n+    fp = caller.unextended_sp() - (locals + frame::sender_sp_offset) + (overlap_caller ? ContinuationHelper::InterpretedFrame::stack_argsize(f) : 0);\n+    sp = fp - (f.fp() - f.unextended_sp());\n+    assert(sp <= fp, \"\");\n+    assert(fp <= caller.unextended_sp(), \"\");\n+    caller.set_sp(fp + frame::sender_sp_offset);\n+\n+    assert(_cont.tail()->is_in_chunk(sp), \"\");\n+\n+    frame hf(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n+    *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + locals - 1;\n+    return hf;\n+  } else {\n+    \/\/ We need to re-read fp out of the frame because it may be an oop and we might have\n+    \/\/ had a safepoint in finalize_freeze, after constructing f.\n+    fp = *(intptr_t**)(f.sp() - 2);\n+\n+    int fsize = FKind::size(f);\n+    sp = caller.unextended_sp() - fsize;\n+    if (caller.is_interpreted_frame()) {\n+      \/\/ If the caller is interpreted, our stackargs are not supposed to overlap with it\n+      \/\/ so we make more room by moving sp down by argsize\n+      int argsize = FKind::stack_argsize(f);\n+      sp -= argsize;\n+    }\n+    caller.set_sp(sp + fsize);\n+\n+    assert(_cont.tail()->is_in_chunk(sp), \"\");\n+\n+    return frame(sp, sp, fp, f.pc(), nullptr, nullptr, true \/* on_heap *\/);\n+  }\n@@ -49,1 +123,12 @@\n-  Unimplemented();\n+  assert((f.at(frame::interpreter_frame_last_sp_offset) != 0) || (f.unextended_sp() == f.sp()), \"\");\n+  intptr_t* real_unextended_sp = (intptr_t*)f.at(frame::interpreter_frame_last_sp_offset);\n+  if (real_unextended_sp != nullptr) {\n+    f.set_unextended_sp(real_unextended_sp); \/\/ can be null at a safepoint\n+  }\n+}\n+\n+static inline void relativize_one(intptr_t* const vfp, intptr_t* const hfp, int offset) {\n+  assert(*(hfp + offset) == *(vfp + offset), \"\");\n+  intptr_t* addr = hfp + offset;\n+  intptr_t value = *(intptr_t**)addr - vfp;\n+  *addr = value;\n@@ -53,1 +138,40 @@\n-  Unimplemented();\n+  intptr_t* vfp = f.fp();\n+  intptr_t* hfp = hf.fp();\n+  assert(hfp == hf.unextended_sp() + (f.fp() - f.unextended_sp()), \"\");\n+  assert((f.at(frame::interpreter_frame_last_sp_offset) != 0)\n+    || (f.unextended_sp() == f.sp()), \"\");\n+  assert(f.fp() > (intptr_t*)f.at(frame::interpreter_frame_initial_sp_offset), \"\");\n+\n+  \/\/ On RISCV, we may insert padding between the locals and the rest of the frame\n+  \/\/ (see TemplateInterpreterGenerator::generate_normal_entry, and AbstractInterpreter::layout_activation)\n+  \/\/ so we compute locals \"from scratch\" rather than relativizing the value in the stack frame, which might include padding,\n+  \/\/ since we don't freeze the padding word (see recurse_freeze_interpreted_frame).\n+\n+  \/\/ at(frame::interpreter_frame_last_sp_offset) can be NULL at safepoint preempts\n+  *hf.addr_at(frame::interpreter_frame_last_sp_offset) = hf.unextended_sp() - hf.fp();\n+  *hf.addr_at(frame::interpreter_frame_locals_offset) = frame::sender_sp_offset + f.interpreter_frame_method()->max_locals() - 1;\n+\n+  relativize_one(vfp, hfp, frame::interpreter_frame_initial_sp_offset); \/\/ == block_top == block_bottom\n+  relativize_one(vfp, hfp, frame::interpreter_frame_extended_sp_offset);\n+\n+  assert((hf.fp() - hf.unextended_sp()) == (f.fp() - f.unextended_sp()), \"\");\n+  assert(hf.unextended_sp() == (intptr_t*)hf.at(frame::interpreter_frame_last_sp_offset), \"\");\n+  assert(hf.unextended_sp() <= (intptr_t*)hf.at(frame::interpreter_frame_initial_sp_offset), \"\");\n+  assert(hf.fp()            >  (intptr_t*)hf.at(frame::interpreter_frame_initial_sp_offset), \"\");\n+#ifdef ASSERT\n+  if (f.interpreter_frame_method()->max_locals() > 0) {\n+    assert(hf.fp()          <= (intptr_t*)hf.at(frame::interpreter_frame_locals_offset), \"\");\n+  }\n+#endif\n+}\n+\n+inline void FreezeBase::set_top_frame_metadata_pd(const frame& hf) {\n+  stackChunkOop chunk = _cont.tail();\n+  assert(chunk->is_in_chunk(hf.sp() - 1), \"\");\n+  assert(chunk->is_in_chunk(hf.sp() - 2), \"\");\n+\n+  *(hf.sp() - 1) = (intptr_t)hf.pc();\n+\n+  intptr_t* fp_addr = hf.sp() - 2;\n+  *fp_addr = hf.is_interpreted_frame() ? (intptr_t)(hf.fp() - fp_addr)\n+                                       : (intptr_t)hf.fp();\n@@ -57,1 +181,9 @@\n-  Unimplemented();\n+  if (caller.is_interpreted_frame()) {\n+    assert(!caller.is_empty(), \"\");\n+    patch_callee_link_relative(caller, caller.fp());\n+  } else {\n+    \/\/ If we're the bottom-most frame frozen in this freeze, the caller might have stayed frozen in the chunk,\n+    \/\/ and its oop-containing fp fixed. We've now just overwritten it, so we must patch it back to its value\n+    \/\/ as read from the chunk.\n+    patch_callee_link(caller, caller.fp());\n+  }\n@@ -60,2 +192,8 @@\n-inline void FreezeBase::patch_stack_pd(intptr_t* frame_sp, intptr_t* heap_sp) {\n-  Unimplemented();\n+\/\/\/\/\/\/\/\/ Thaw\n+\n+\/\/ Fast path\n+\n+inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n+  size <<= LogBytesPerWord;\n+  Prefetch::read(start, size);\n+  Prefetch::read(start, size - 64);\n@@ -64,0 +202,7 @@\n+void ThawBase::patch_chunk_pd(intptr_t* sp) {\n+  intptr_t* fp = _cont.entryFP();\n+  *(intptr_t**)(sp - 2) = fp;\n+}\n+\n+\/\/ Slow path\n+\n@@ -65,2 +210,2 @@\n-  Unimplemented();\n-  return frame();\n+  intptr_t* sp = _cont.entrySP();\n+  return frame(sp, sp, _cont.entryFP(), _cont.entryPC()); \/\/ TODO PERF: This finds code blob and computes deopt state\n@@ -70,3 +215,2 @@\n-  Unimplemented();\n-  return frame();\n-}\n+  assert(FKind::is_instance(hf), \"\");\n+  \/\/ The values in the returned frame object will be written into the callee's stack in patch.\n@@ -74,3 +218,32 @@\n-inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n-  Unimplemented();\n-}\n+  if (FKind::interpreted) {\n+    intptr_t* heap_sp = hf.unextended_sp();\n+    \/\/ If caller is interpreted it already made room for the callee arguments\n+    int overlap = caller.is_interpreted_frame() ? ContinuationHelper::InterpretedFrame::stack_argsize(hf) : 0;\n+    const int fsize = ContinuationHelper::InterpretedFrame::frame_bottom(hf) - hf.unextended_sp() - overlap;\n+    const int locals = hf.interpreter_frame_method()->max_locals();\n+    intptr_t* frame_sp = caller.unextended_sp() - fsize;\n+    intptr_t* fp = frame_sp + (hf.fp() - heap_sp);\n+    int padding = 0;\n+    if ((intptr_t)fp % frame::frame_alignment != 0) {\n+      fp--;\n+      frame_sp--;\n+      padding++;\n+      log_develop_trace(continuations)(\"Adding internal interpreted frame alignment\");\n+    }\n+    DEBUG_ONLY(intptr_t* unextended_sp = fp + *hf.addr_at(frame::interpreter_frame_last_sp_offset);)\n+    assert(frame_sp == unextended_sp, \"\");\n+    caller.set_sp(fp + frame::sender_sp_offset);\n+    frame f(frame_sp, frame_sp, fp, hf.pc());\n+    \/\/ it's set again later in set_interpreter_frame_bottom, but we need to set the locals now so that\n+    \/\/ we could call ContinuationHelper::InterpretedFrame::frame_bottom\n+    intptr_t offset = *hf.addr_at(frame::interpreter_frame_locals_offset);\n+    assert((int)offset == frame::sender_sp_offset + locals - 1, \"\");\n+    \/\/ derelativize locals\n+    *(intptr_t**)f.addr_at(frame::interpreter_frame_locals_offset) = fp + padding + offset;\n+    assert((intptr_t)f.fp() % frame::frame_alignment == 0, \"\");\n+    return f;\n+  } else {\n+    int fsize = FKind::size(hf);\n+    intptr_t* frame_sp = caller.unextended_sp() - fsize;\n+    if (bottom || caller.is_interpreted_frame()) {\n+      int argsize = hf.compiled_frame_stack_argsize();\n@@ -78,2 +251,21 @@\n-inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n-  Unimplemented();\n+      fsize += argsize;\n+      frame_sp -= argsize;\n+      caller.set_sp(caller.sp() - argsize);\n+      assert(caller.sp() == frame_sp + (fsize-argsize), \"\");\n+\n+      frame_sp = align(hf, frame_sp, caller, bottom);\n+    }\n+\n+    assert(hf.cb() != nullptr, \"\");\n+    assert(hf.oop_map() != nullptr, \"\");\n+    intptr_t* fp;\n+    if (PreserveFramePointer) {\n+      \/\/ we need to recreate a \"real\" frame pointer, pointing into the stack\n+      fp = frame_sp + FKind::size(hf) - 2;\n+    } else {\n+      fp = FKind::stub\n+        ? frame_sp + fsize - 2 \/\/ On RISCV, this value is used for the safepoint stub\n+        : *(intptr_t**)(hf.sp() - 2); \/\/ we need to re-read fp because it may be an oop and we might have fixed the frame.\n+    }\n+    return frame(frame_sp, frame_sp, fp, hf.pc(), hf.cb(), hf.oop_map(), false); \/\/ TODO PERF : this computes deopt state; is it necessary?\n+  }\n@@ -83,2 +275,10 @@\n-  Unimplemented();\n-  return NULL;\n+#ifdef _LP64\n+  if (((intptr_t)frame_sp & 0xf) != 0) {\n+    assert(caller.is_interpreted_frame() || (bottom && hf.compiled_frame_stack_argsize() % 2 != 0), \"\");\n+    frame_sp--;\n+    caller.set_sp(caller.sp() - 1);\n+  }\n+  assert(is_aligned(frame_sp, frame::frame_alignment), \"\");\n+#endif\n+\n+  return frame_sp;\n@@ -88,1 +288,1 @@\n-  Unimplemented();\n+  patch_callee_link(caller, caller.fp());\n@@ -91,2 +291,3 @@\n-void ThawBase::patch_chunk_pd(intptr_t* sp) {\n-  Unimplemented();\n+static inline void derelativize_one(intptr_t* const fp, int offset) {\n+  intptr_t* addr = fp + offset;\n+  *addr = (intptr_t)(fp + *addr);\n@@ -95,2 +296,10 @@\n-inline void ThawBase::prefetch_chunk_pd(void* start, int size) {\n-  Unimplemented();\n+inline void ThawBase::derelativize_interpreted_frame_metadata(const frame& hf, const frame& f) {\n+  intptr_t* vfp = f.fp();\n+\n+  derelativize_one(vfp, frame::interpreter_frame_last_sp_offset);\n+  derelativize_one(vfp, frame::interpreter_frame_initial_sp_offset);\n+  derelativize_one(vfp, frame::interpreter_frame_extended_sp_offset);\n+}\n+\n+inline void ThawBase::set_interpreter_frame_bottom(const frame& f, intptr_t* bottom) {\n+  *(intptr_t**)f.addr_at(frame::interpreter_frame_locals_offset) = bottom - 1;\n","filename":"src\/hotspot\/cpu\/riscv\/continuationFreezeThaw_riscv.inline.hpp","additions":237,"deletions":28,"binary":false,"changes":265,"status":"modified"},{"patch":"@@ -30,0 +30,5 @@\n+#include \"runtime\/continuationEntry.inline.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/registerMap.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n@@ -32,2 +37,4 @@\n-  Unimplemented();\n-  return NULL;\n+  assert(FKind::is_instance(f), \"\");\n+  return FKind::interpreted\n+            ? (intptr_t**)(f.fp() + frame::link_offset)\n+            : (intptr_t**)(f.unextended_sp() + f.cb()->frame_size() - 2);\n@@ -37,1 +44,3 @@\n-  Unimplemented();\n+#ifdef _LP64\n+  return size & 1;\n+#else\n@@ -39,0 +48,1 @@\n+#endif\n@@ -42,2 +52,4 @@\n-  Unimplemented();\n-  return NULL;\n+#ifdef _LP64\n+  sp = align_down(sp, frame::frame_alignment);\n+#endif\n+  return sp;\n@@ -48,1 +60,1 @@\n-  Unimplemented();\n+  frame::update_map_with_saved_link(map, link_address<FKind>(f));\n@@ -52,1 +64,1 @@\n-  Unimplemented();\n+  frame::update_map_with_saved_link(map, ContinuationHelper::Frame::callee_link_address(f));\n@@ -56,1 +68,1 @@\n-  Unimplemented();\n+  *(intptr_t**)(f.sp() - 2) = f.fp();\n@@ -59,3 +71,2 @@\n-\n-inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* cont) {\n-  Unimplemented();\n+inline void ContinuationHelper::set_anchor_to_entry_pd(JavaFrameAnchor* anchor, ContinuationEntry* entry) {\n+  anchor->set_last_Java_fp(entry->entry_fp());\n@@ -66,1 +77,2 @@\n-  Unimplemented();\n+  intptr_t* fp = *(intptr_t**)(sp - 2);\n+  anchor->set_last_Java_fp(fp);\n@@ -70,2 +82,6 @@\n-  Unimplemented();\n-  return false;\n+  intptr_t* sp = f.sp();\n+  address pc = *(address*)(sp - frame::sender_sp_ret_address_offset());\n+  intptr_t* fp = *(intptr_t**)(sp - 2);\n+  assert(f.raw_pc() == pc, \"f.ra_pc: \" INTPTR_FORMAT \" actual: \" INTPTR_FORMAT, p2i(f.raw_pc()), p2i(pc));\n+  assert(f.fp() == fp, \"f.fp: \" INTPTR_FORMAT \" actual: \" INTPTR_FORMAT, p2i(f.fp()), p2i(fp));\n+  return f.raw_pc() == pc && f.fp() == fp;\n@@ -76,2 +92,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (intptr_t**)(f.sp() - 2);\n@@ -80,4 +95,2 @@\n-template<typename FKind>\n-static inline intptr_t* real_fp(const frame& f) {\n-  Unimplemented();\n-  return NULL;\n+inline address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n+  return (address*)(f.real_fp() - 1);\n@@ -87,2 +100,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (address*)(f.fp() + frame::return_addr_offset);\n@@ -92,5 +104,3 @@\n-  Unimplemented();\n-}\n-\n-inline address* ContinuationHelper::Frame::return_pc_address(const frame& f) {\n-  return (address*)(f.real_fp() - 1);\n+  assert(f.is_interpreted_frame(), \"\");\n+  intptr_t* la = f.addr_at(frame::interpreter_frame_sender_sp_offset);\n+  *la = f.is_heap_frame() ? (intptr_t)(sp - f.fp()) : (intptr_t)sp;\n@@ -100,2 +110,2 @@\n-  Unimplemented();\n-  return NULL;\n+  address* pc_addr = &(((address*) f.sp())[-1]);\n+  return *pc_addr;\n@@ -105,1 +115,2 @@\n-  Unimplemented();\n+  address* pc_addr = &(((address*) f.sp())[-1]);\n+  *pc_addr = pc;\n@@ -109,2 +120,9 @@\n-  Unimplemented();\n-  return NULL;\n+  \/\/ interpreter_frame_last_sp_offset, points to unextended_sp includes arguments in the frame\n+  \/\/ interpreter_frame_initial_sp_offset excludes expression stack slots\n+  int expression_stack_sz = expression_stack_size(f, mask);\n+  intptr_t* res = *(intptr_t**)f.addr_at(frame::interpreter_frame_initial_sp_offset) - expression_stack_sz;\n+  assert(res == (intptr_t*)f.interpreter_frame_monitor_end() - expression_stack_sz, \"\");\n+  assert(res >= f.unextended_sp(),\n+    \"res: \" INTPTR_FORMAT \" initial_sp: \" INTPTR_FORMAT \" last_sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" expression_stack_size: %d\",\n+    p2i(res), p2i(f.addr_at(frame::interpreter_frame_initial_sp_offset)), f.at(frame::interpreter_frame_last_sp_offset), p2i(f.unextended_sp()), expression_stack_sz);\n+  return res;\n@@ -114,2 +132,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return (intptr_t*)f.at(frame::interpreter_frame_locals_offset) + 1; \/\/ exclusive, so we add 1 word\n@@ -119,2 +136,1 @@\n-  Unimplemented();\n-  return NULL;\n+  return f.unextended_sp() + (callee_interpreted ? callee_argsize : 0);\n","filename":"src\/hotspot\/cpu\/riscv\/continuationHelper_riscv.inline.hpp","additions":52,"deletions":36,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -160,0 +160,6 @@\n+    if (Continuation::is_return_barrier_entry(sender_pc)) {\n+      \/\/ If our sender_pc is the return barrier, then our \"real\" sender is the continuation entry\n+      frame s = Continuation::continuation_bottom_sender(thread, *this, sender_sp);\n+      sender_sp = s.sp();\n+      sender_pc = s.pc();\n+    }\n@@ -205,3 +211,1 @@\n-      bool jcw_safe = (jcw < thread->stack_base()) && (jcw > (address)sender.fp());\n-\n-      return jcw_safe;\n+      return thread->is_in_stack_range_excl(jcw, (address)sender.fp());\n@@ -257,0 +261,1 @@\n+  address pc_old = *pc_addr;\n@@ -260,1 +265,1 @@\n-                  p2i(pc_addr), p2i(*pc_addr), p2i(pc));\n+                  p2i(pc_addr), p2i(pc_old), p2i(pc));\n@@ -263,0 +268,2 @@\n+  assert(!Continuation::is_return_barrier_entry(pc_old), \"return barrier\");\n+\n@@ -265,1 +272,1 @@\n-  assert(_pc == *pc_addr || pc == *pc_addr || *pc_addr == 0, \"must be\");\n+  assert(_pc == pc_old || pc == pc_old || pc_old == 0, \"must be\");\n@@ -279,4 +286,0 @@\n-bool frame::is_interpreted_frame() const  {\n-  return Interpreter::contains(pc());\n-}\n-\n@@ -309,1 +312,1 @@\n-  BasicObjectLock* result = (BasicObjectLock*) *addr_at(interpreter_frame_monitor_block_top_offset);\n+  BasicObjectLock* result = (BasicObjectLock*) at(interpreter_frame_monitor_block_top_offset);\n@@ -420,0 +423,8 @@\n+  if (Continuation::is_return_barrier_entry(sender_pc())) {\n+    if (map->walk_cont()) { \/\/ about to walk into an h-stack\n+      return Continuation::top_frame(*this, map);\n+    } else {\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, sender_sp);\n+    }\n+  }\n+\n@@ -472,3 +483,5 @@\n-  address locals = (address) *interpreter_frame_locals_addr();\n-  if (locals > thread->stack_base() || locals < (address) fp()) {\n-    return false;\n+  if (m->max_locals() > 0) {\n+    address locals = (address) *interpreter_frame_locals_addr();\n+    if (!thread->is_in_stack_range_incl(locals, (address)fp())) {\n+      return false;\n+    }\n@@ -553,0 +566,16 @@\n+\n+  if (is_java_frame() || Continuation::is_continuation_enterSpecial(*this)) {\n+    intptr_t* ret_pc_loc;\n+    intptr_t* fp_loc;\n+    if (is_interpreted_frame()) {\n+      ret_pc_loc = fp() + return_addr_offset;\n+      fp_loc = fp();\n+    } else {\n+      ret_pc_loc = real_fp() - 1;\n+      fp_loc = real_fp() - 2;\n+    }\n+    address ret_pc = *(address*)ret_pc_loc;\n+    values.describe(frame_no, ret_pc_loc,\n+      Continuation::is_return_barrier_entry(ret_pc) ? \"return address (return barrier)\" : \"return address\");\n+    values.describe(-1, fp_loc, \"saved fp\", 0); \/\/ \"unowned\" as value belongs to sender\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":42,"deletions":13,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -141,1 +141,1 @@\n-    metadata_words                                   = sender_sp_offset,\n+    metadata_words                                   =  2,\n@@ -158,1 +158,4 @@\n-  intptr_t*   _fp; \/\/ frame pointer\n+  union {\n+    intptr_t*  _fp; \/\/ frame pointer\n+    int _offset_fp; \/\/ relative frame pointer for use in stack-chunk frames\n+  };\n@@ -166,1 +169,5 @@\n-  intptr_t*     _unextended_sp;\n+  union {\n+    intptr_t* _unextended_sp;\n+    int _offset_unextended_sp; \/\/ for use in stack-chunk frames\n+  };\n+\n@@ -175,1 +182,1 @@\n-  static void verify_deopt_original_pc(   CompiledMethod* nm, intptr_t* unextended_sp);\n+  static void verify_deopt_original_pc(CompiledMethod* nm, intptr_t* unextended_sp);\n@@ -187,0 +194,4 @@\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb);\n+  \/\/ used for fast frame construction by continuations\n+  frame(intptr_t* sp, intptr_t* unextended_sp, intptr_t* fp, address pc, CodeBlob* cb, const ImmutableOopMap* oop_map, bool on_heap);\n+\n@@ -194,1 +205,5 @@\n-  intptr_t* fp() const { return _fp; }\n+\n+  intptr_t* fp() const          { assert_absolute(); return _fp; }\n+  void set_fp(intptr_t* newfp)  { _fp = newfp; }\n+  int offset_fp() const         { assert_offset(); return _offset_fp; }\n+  void set_offset_fp(int value) { assert_on_heap(); _offset_fp = value; }\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.hpp","additions":20,"deletions":5,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-#include \"code\/codeCache.hpp\"\n+#include \"code\/codeBlob.inline.hpp\"\n+#include \"code\/codeCache.inline.hpp\"\n@@ -32,0 +33,2 @@\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"interpreter\/oopMapCache.hpp\"\n@@ -89,0 +92,42 @@\n+inline frame::frame(intptr_t* ptr_sp, intptr_t* unextended_sp, intptr_t* ptr_fp, address pc, CodeBlob* cb) {\n+  intptr_t a = intptr_t(ptr_sp);\n+  intptr_t b = intptr_t(ptr_fp);\n+  _sp = ptr_sp;\n+  _unextended_sp = unextended_sp;\n+  _fp = ptr_fp;\n+  _pc = pc;\n+  assert(pc != NULL, \"no pc?\");\n+  _cb = cb;\n+  _oop_map = NULL;\n+  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT, p2i(pc));\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n+  setup(pc);\n+}\n+\n+inline frame::frame(intptr_t* ptr_sp, intptr_t* unextended_sp, intptr_t* ptr_fp, address pc, CodeBlob* cb,\n+                    const ImmutableOopMap* oop_map, bool on_heap) {\n+  _sp = ptr_sp;\n+  _unextended_sp = unextended_sp;\n+  _fp = ptr_fp;\n+  _pc = pc;\n+  _cb = cb;\n+  _oop_map = oop_map;\n+  _deopt_state = not_deoptimized;\n+  _on_heap = on_heap;\n+  DEBUG_ONLY(_frame_index = -1;)\n+\n+  \/\/ In thaw, non-heap frames use this constructor to pass oop_map.  I don't know why.\n+  assert(_on_heap || _cb != nullptr, \"these frames are always heap frames\");\n+  if (cb != NULL) {\n+    setup(pc);\n+  }\n+#ifdef ASSERT\n+  \/\/ The following assertion has been disabled because it would sometime trap for Continuation.run,\n+  \/\/ which is not *in* a continuation and therefore does not clear the _cont_fastpath flag, but this\n+  \/\/ is benign even in fast mode (see Freeze::setup_jump)\n+  \/\/ We might freeze deoptimized frame in slow mode\n+  \/\/ assert(_pc == pc && _deopt_state == not_deoptimized, \"\");\n+#endif\n+}\n+\n@@ -97,1 +142,2 @@\n-  _cb = CodeCache::find_blob(pc);\n+  _cb = CodeCache::find_blob_fast(pc);\n+  assert(_cb != NULL, \"pc: \" INTPTR_FORMAT \" sp: \" INTPTR_FORMAT \" unextended_sp: \" INTPTR_FORMAT \" fp: \" INTPTR_FORMAT, p2i(pc), p2i(ptr_sp), p2i(unextended_sp), p2i(ptr_fp));\n@@ -105,3 +151,1 @@\n-inline frame::frame(intptr_t* ptr_sp) {\n-  Unimplemented();\n-}\n+inline frame::frame(intptr_t* ptr_sp) : frame(ptr_sp, ptr_sp, *(intptr_t**)(ptr_sp - 2), *(address*)(ptr_sp - 1)) {}\n@@ -116,0 +160,2 @@\n+  _on_heap = false;\n+  DEBUG_ONLY(_frame_index = -1;)\n@@ -135,3 +181,0 @@\n-\n-  _on_heap = false;\n-  DEBUG_ONLY(_frame_index = -1;)\n@@ -167,14 +210,4 @@\n-inline intptr_t* frame::unextended_sp() const     { return _unextended_sp; }\n-\n-inline void frame::set_unextended_sp(intptr_t* value) {\n-  Unimplemented();\n-}\n-\n-inline int frame::offset_unextended_sp() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void frame::set_offset_unextended_sp(int value) {\n-  Unimplemented();\n-}\n+inline intptr_t* frame::unextended_sp() const          { assert_absolute(); return _unextended_sp; }\n+inline void frame::set_unextended_sp(intptr_t* value)  { _unextended_sp = value; }\n+inline int frame::offset_unextended_sp() const         { assert_offset(); return _offset_unextended_sp; }\n+inline void frame::set_offset_unextended_sp(int value) { assert_on_heap(); _offset_unextended_sp = value; }\n@@ -201,0 +234,12 @@\n+inline int frame::compiled_frame_stack_argsize() const {\n+  assert(cb()->is_compiled(), \"\");\n+  return (cb()->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord;\n+}\n+\n+inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n+  assert(mask != NULL, \"\");\n+  Method* m = interpreter_frame_method();\n+  int   bci = interpreter_frame_bci();\n+  m->mask_for(bci, mask); \/\/ OopMapCache::compute_one_oop_map(m, bci, mask);\n+}\n+\n@@ -269,1 +314,1 @@\n-  return monitor_end-1;\n+  return monitor_end - 1;\n@@ -293,0 +338,8 @@\n+inline bool frame::is_interpreted_frame() const {\n+  return Interpreter::contains(pc());\n+}\n+\n+inline int frame::sender_sp_ret_address_offset() {\n+  return frame::sender_sp_offset - frame::return_addr_offset;\n+}\n+\n@@ -296,0 +349,5 @@\n+    NativePostCallNop* nop = nativePostCallNop_at(_pc);\n+    if (nop != NULL && nop->displacement() != 0) {\n+      int slot = ((nop->displacement() >> 24) & 0xff);\n+      return _cb->oop_map_for_slot(slot, _pc);\n+    }\n@@ -302,14 +360,0 @@\n-inline int frame::compiled_frame_stack_argsize() const {\n-  Unimplemented();\n-  return 0;\n-}\n-\n-inline void frame::interpreted_frame_oop_map(InterpreterOopMap* mask) const {\n-  Unimplemented();\n-}\n-\n-inline int frame::sender_sp_ret_address_offset() {\n-  Unimplemented();\n-  return 0;\n-}\n-\n@@ -321,1 +365,1 @@\n-  if (map->process_frames()) {\n+  if (map->process_frames() && !map->in_cont()) {\n@@ -336,0 +380,4 @@\n+  if (map->in_cont()) { \/\/ already in an h-stack\n+    return map->stack_chunk()->sender(*this, map);\n+  }\n+\n@@ -339,0 +387,1 @@\n+\n@@ -342,1 +391,0 @@\n-  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n@@ -344,2 +392,1 @@\n-  \/\/ This test looks odd: why is it not is_compiled_frame() ?  That's\n-  \/\/ because stubs also have OOP maps.\n+  assert(_cb == CodeCache::find_blob(pc()),\"Must be the same\");\n@@ -352,0 +399,4 @@\n+\n+  \/\/ Native code may or may not have signed the return address, we have no way to be sure\n+  \/\/ or what signing methods they used. Instead, just ensure the stripped value is used.\n+\n@@ -364,1 +415,0 @@\n-  intptr_t* unextended_sp = l_sender_sp;\n@@ -376,3 +426,9 @@\n-    map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n-    if (_cb->oop_maps() != NULL) {\n-      OopMapSet::update_register_map(this, map);\n+    if (!_cb->is_compiled()) { \/\/ compiled frames do not use callee-saved registers\n+      map->set_include_argument_oops(_cb->caller_must_gc_arguments(map->thread()));\n+      if (oop_map() != NULL) {\n+        _oop_map->update_register_map(this, map);\n+      }\n+    } else {\n+      assert(!_cb->caller_must_gc_arguments(map->thread()), \"\");\n+      assert(!map->include_argument_oops(), \"\");\n+      assert(oop_map() == NULL || !oop_map()->has_any(OopMapValue::callee_saved_value), \"callee-saved value in compiled frame\");\n@@ -388,0 +444,9 @@\n+  if (Continuation::is_return_barrier_entry(sender_pc)) {\n+    if (map->walk_cont()) { \/\/ about to walk into an h-stack\n+      return Continuation::top_frame(*this, map);\n+    } else {\n+      return Continuation::continuation_bottom_sender(map->thread(), *this, l_sender_sp);\n+    }\n+  }\n+\n+  intptr_t* unextended_sp = l_sender_sp;\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.inline.hpp","additions":110,"deletions":45,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -46,0 +46,2 @@\n+#define SUPPORT_MONITOR_COUNT\n+\n","filename":"src\/hotspot\/cpu\/riscv\/globalDefinitions_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-define_pd_global(bool, VMContinuations, false);\n+define_pd_global(bool, VMContinuations, true);\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -789,1 +789,1 @@\n-    Label done;\n+    Label count, done;\n@@ -822,1 +822,1 @@\n-    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, t0, done, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, lock_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n@@ -839,1 +839,1 @@\n-    beqz(swap_reg, done);\n+    beqz(swap_reg, count);\n@@ -848,0 +848,5 @@\n+    j(done);\n+\n+    bind(count);\n+    increment(Address(xthread, JavaThread::held_monitor_count_offset()));\n+\n@@ -871,1 +876,1 @@\n-    Label done;\n+    Label count, done;\n@@ -894,1 +899,1 @@\n-    beqz(header_reg, done);\n+    beqz(header_reg, count);\n@@ -897,1 +902,1 @@\n-    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, t0, done, \/*fallthrough*\/NULL);\n+    cmpxchg_obj_header(swap_reg, header_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n@@ -903,0 +908,5 @@\n+    j(done);\n+\n+    bind(count);\n+    decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n+\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  void set_last_Java_fp(intptr_t* fp)            { _last_Java_fp = fp; }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/javaFrameAnchor_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,0 +88,18 @@\n+void MacroAssembler::push_cont_fastpath(Register java_thread) {\n+  if (!Continuations::enabled()) return;\n+  Label done;\n+  ld(t0, Address(java_thread, JavaThread::cont_fastpath_offset()));\n+  bleu(sp, t0, done);\n+  sd(sp, Address(java_thread, JavaThread::cont_fastpath_offset()));\n+  bind(done);\n+}\n+\n+void MacroAssembler::pop_cont_fastpath(Register java_thread) {\n+  if (!Continuations::enabled()) return;\n+  Label done;\n+  ld(t0, Address(java_thread, JavaThread::cont_fastpath_offset()));\n+  bltu(sp, t0, done);\n+  sd(zr, Address(java_thread, JavaThread::cont_fastpath_offset()));\n+  bind(done);\n+}\n+\n@@ -189,0 +207,9 @@\n+void MacroAssembler::post_call_nop() {\n+  if (!Continuations::enabled()) {\n+    return;\n+  }\n+  relocate(post_call_nop_Relocation::spec(), [&] {\n+    nop();\n+  });\n+}\n+\n@@ -569,1 +596,1 @@\n-  \/\/ Jump to the entry point of the i2c stub.\n+  \/\/ Jump to the entry point of the c2i stub.\n@@ -3143,1 +3170,1 @@\n-\/\/ Maybe emit a call via a trampoline.  If the code cache is small\n+\/\/ Maybe emit a call via a trampoline. If the code cache is small\n@@ -3146,1 +3173,0 @@\n-  assert(JavaThread::current()->is_Compiler_thread(), \"just checking\");\n@@ -3156,10 +3182,1 @@\n-    bool in_scratch_emit_size = false;\n-#ifdef COMPILER2\n-    \/\/ We don't want to emit a trampoline if C2 is generating dummy\n-    \/\/ code during its branch shortening phase.\n-    CompileTask* task = ciEnv::current()->task();\n-    in_scratch_emit_size =\n-      (task != NULL && is_c2_compile(task->comp_level()) &&\n-       Compile::current()->output()->in_scratch_emit_size());\n-#endif\n-    if (!in_scratch_emit_size) {\n+    if (!in_scratch_emit_size()) {\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":30,"deletions":13,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+  \/\/ nop\n+  void post_call_nop();\n+\n@@ -387,0 +390,6 @@\n+\n+  \/\/ Return whether code is emitted to a scratch blob.\n+  virtual bool in_scratch_emit_size() {\n+    return false;\n+  }\n+\n@@ -575,0 +584,3 @@\n+  void push_cont_fastpath(Register java_thread);\n+  void pop_cont_fastpath(Register java_thread);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -441,0 +441,21 @@\n+\n+void NativePostCallNop::make_deopt() {\n+  MacroAssembler::assert_alignment(addr_at(0));\n+  NativeDeoptInstruction::insert(addr_at(0));\n+}\n+\n+void NativePostCallNop::patch(jint diff) {\n+  \/\/ unsupported for now\n+}\n+\n+void NativeDeoptInstruction::verify() {\n+}\n+\n+\/\/ Inserts an undefined instruction at a given pc\n+void NativeDeoptInstruction::insert(address code_pos) {\n+  \/\/ 0xc0201073 encodes CSRRW x0, instret, x0\n+  uint32_t insn = 0xc0201073;\n+  uint32_t *pos = (uint32_t *) code_pos;\n+  *pos = insn;\n+  ICache::invalidate_range(code_pos, 4);\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+\/\/ - - NativePostCallNop\n+\/\/ - - NativeDeoptInstruction\n@@ -559,2 +561,2 @@\n-  void patch(jint diff) { Unimplemented(); }\n-  void make_deopt() { Unimplemented(); }\n+  void patch(jint diff);\n+  void make_deopt();\n@@ -571,0 +573,6 @@\n+inline NativePostCallNop* nativePostCallNop_unsafe_at(address address) {\n+  NativePostCallNop* nop = (NativePostCallNop*) address;\n+  assert(nop->check(), \"\");\n+  return nop;\n+}\n+\n@@ -572,3 +580,8 @@\n-public:\n-  address instruction_address() const       { Unimplemented(); return NULL; }\n-  address next_instruction_address() const  { Unimplemented(); return NULL; }\n+ public:\n+  enum {\n+    instruction_size            =    4,\n+    instruction_offset          =    0,\n+  };\n+\n+  address instruction_address() const       { return addr_at(instruction_offset); }\n+  address next_instruction_address() const  { return addr_at(instruction_size); }\n@@ -576,1 +589,1 @@\n-  void  verify() { Unimplemented(); }\n+  void verify();\n@@ -579,3 +592,4 @@\n-    if (!Continuations::enabled()) return false;\n-    Unimplemented();\n-    return false;\n+    assert(instr != NULL, \"\");\n+    uint32_t value = *(uint32_t *) instr;\n+    \/\/ 0xc0201073 encodes CSRRW x0, instret, x0\n+    return value == 0xc0201073;\n@@ -585,3 +599,1 @@\n-  static void insert(address code_pos) {\n-    Unimplemented();\n-  }\n+  static void insert(address code_pos);\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.hpp","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2309,0 +2309,2 @@\n+\n+    __ post_call_nop();\n@@ -2320,0 +2322,2 @@\n+\n+    __ post_call_nop();\n@@ -2346,0 +2350,1 @@\n+      __ post_call_nop();\n@@ -2355,0 +2360,1 @@\n+      __ post_call_nop();\n@@ -2369,0 +2375,1 @@\n+    Label no_count;\n@@ -2447,1 +2454,1 @@\n-    __ add(tmp, tmp, 1u);\n+    __ add(tmp, tmp, 1);\n@@ -2451,0 +2458,8 @@\n+\n+    __ bnez(flag, no_count);\n+\n+    __ ld(tmp, Address(xthread, JavaThread::held_monitor_count_offset()));\n+    __ add(tmp, tmp, 1);\n+    __ sd(tmp, Address(xthread, JavaThread::held_monitor_count_offset()));\n+\n+    __ bind(no_count);\n@@ -2463,0 +2478,1 @@\n+    Label no_count;\n@@ -2521,0 +2537,8 @@\n+\n+    __ bnez(flag, no_count);\n+\n+    __ ld(tmp, Address(xthread, JavaThread::held_monitor_count_offset()));\n+    __ sub(tmp, tmp, 1);\n+    __ sd(tmp, Address(xthread, JavaThread::held_monitor_count_offset()));\n+\n+    __ bind(no_count);\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"code\/compiledIC.hpp\"\n@@ -42,0 +43,1 @@\n+#include \"oops\/method.inline.hpp\"\n@@ -43,0 +45,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -591,0 +595,2 @@\n+  __ push_cont_fastpath(xthread); \/\/ Set JavaThread::_cont_fastpath to the sp of the oldest interpreted frame we know about\n+\n@@ -860,0 +866,240 @@\n+\/\/ on exit, sp points to the ContinuationEntry\n+static OopMap* continuation_enter_setup(MacroAssembler* masm, int& stack_slots) {\n+  assert(ContinuationEntry::size() % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::cont_offset())  % VMRegImpl::stack_slot_size == 0, \"\");\n+  assert(in_bytes(ContinuationEntry::chunk_offset()) % VMRegImpl::stack_slot_size == 0, \"\");\n+\n+  stack_slots += (int)ContinuationEntry::size() \/ wordSize;\n+  __ sub(sp, sp, (int)ContinuationEntry::size()); \/\/ place Continuation metadata\n+\n+  OopMap* map = new OopMap(((int)ContinuationEntry::size() + wordSize) \/ VMRegImpl::stack_slot_size, 0 \/* arg_slots*\/);\n+  ContinuationEntry::setup_oopmap(map);\n+\n+  __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+  __ sd(t0, Address(sp, ContinuationEntry::parent_offset()));\n+  __ sd(sp, Address(xthread, JavaThread::cont_entry_offset()));\n+\n+  return map;\n+}\n+\n+\/\/ on entry c_rarg1 points to the continuation\n+\/\/          sp points to ContinuationEntry\n+\/\/          c_rarg3 -- isVirtualThread\n+static void fill_continuation_entry(MacroAssembler* masm) {\n+#ifdef ASSERT\n+  __ mvw(t0, ContinuationEntry::cookie_value());\n+  __ sw(t0, Address(sp, ContinuationEntry::cookie_offset()));\n+#endif\n+\n+  __ sd(c_rarg1, Address(sp, ContinuationEntry::cont_offset()));\n+  __ sw(c_rarg3, Address(sp, ContinuationEntry::flags_offset()));\n+  __ sd(zr,      Address(sp, ContinuationEntry::chunk_offset()));\n+  __ sw(zr,      Address(sp, ContinuationEntry::argsize_offset()));\n+  __ sw(zr,      Address(sp, ContinuationEntry::pin_count_offset()));\n+\n+  __ ld(t0, Address(xthread, JavaThread::cont_fastpath_offset()));\n+  __ sd(t0, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ ld(t0, Address(xthread, JavaThread::held_monitor_count_offset()));\n+  __ sd(t0, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n+\n+  __ sd(zr, Address(xthread, JavaThread::cont_fastpath_offset()));\n+  __ sd(zr, Address(xthread, JavaThread::held_monitor_count_offset()));\n+}\n+\n+\/\/ on entry, sp points to the ContinuationEntry\n+\/\/ on exit, fp points to the spilled fp + 2 * wordSize in the entry frame\n+static void continuation_enter_cleanup(MacroAssembler* masm) {\n+#ifndef PRODUCT\n+  Label OK;\n+  __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+  __ beq(sp, t0, OK);\n+  __ stop(\"incorrect sp\");\n+  __ bind(OK);\n+#endif\n+\n+  __ ld(t0, Address(sp, ContinuationEntry::parent_cont_fastpath_offset()));\n+  __ sd(t0, Address(xthread, JavaThread::cont_fastpath_offset()));\n+  __ ld(t0, Address(sp, ContinuationEntry::parent_held_monitor_count_offset()));\n+  __ sd(t0, Address(xthread, JavaThread::held_monitor_count_offset()));\n+\n+  __ ld(t0, Address(sp, ContinuationEntry::parent_offset()));\n+  __ sd(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+  __ add(fp, sp, (int)ContinuationEntry::size() + 2 * wordSize \/* 2 extra words to match up with leave() *\/);\n+}\n+\n+\/\/ enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread)\n+\/\/ On entry: c_rarg1 -- the continuation object\n+\/\/           c_rarg2 -- isContinue\n+\/\/           c_rarg3 -- isVirtualThread\n+static void gen_continuation_enter(MacroAssembler* masm,\n+                                   const methodHandle& method,\n+                                   const BasicType* sig_bt,\n+                                   const VMRegPair* regs,\n+                                   int& exception_offset,\n+                                   OopMapSet*oop_maps,\n+                                   int& frame_complete,\n+                                   int& stack_slots,\n+                                   int& interpreted_entry_offset,\n+                                   int& compiled_entry_offset) {\n+  \/\/ verify_oop_args(masm, method, sig_bt, regs);\n+  Address resolve(SharedRuntime::get_resolve_static_call_stub(), relocInfo::static_call_type);\n+\n+  address start = __ pc();\n+\n+  Label call_thaw, exit;\n+\n+  \/\/ i2i entry used at interp_only_mode only\n+  interpreted_entry_offset = __ pc() - start;\n+  {\n+#ifdef ASSERT\n+    Label is_interp_only;\n+    __ lw(t0, Address(xthread, JavaThread::interp_only_mode_offset()));\n+    __ bnez(t0, is_interp_only);\n+    __ stop(\"enterSpecial interpreter entry called when not in interp_only_mode\");\n+    __ bind(is_interp_only);\n+#endif\n+\n+    \/\/ Read interpreter arguments into registers (this is an ad-hoc i2c adapter)\n+    __ ld(c_rarg1, Address(esp, Interpreter::stackElementSize * 2));\n+    __ ld(c_rarg2, Address(esp, Interpreter::stackElementSize * 1));\n+    __ ld(c_rarg3, Address(esp, Interpreter::stackElementSize * 0));\n+    __ push_cont_fastpath(xthread);\n+\n+    __ enter();\n+    stack_slots = 2; \/\/ will be adjusted in setup\n+    OopMap* map = continuation_enter_setup(masm, stack_slots);\n+    \/\/ The frame is complete here, but we only record it for the compiled entry, so the frame would appear unsafe,\n+    \/\/ but that's okay because at the very worst we'll miss an async sample, but we're in interp_only_mode anyway.\n+\n+    fill_continuation_entry(masm);\n+\n+    __ bnez(c_rarg2, call_thaw);\n+\n+    \/\/ Make sure the call is patchable\n+    __ align(NativeInstruction::instruction_size);\n+\n+    const address tr_call = __ trampoline_call(resolve);\n+\n+    oop_maps->add_gc_map(__ pc() - start, map);\n+    __ post_call_nop();\n+\n+    __ j(exit);\n+\n+    CodeBuffer* cbuf = masm->code_section()->outer();\n+    CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+  }\n+\n+  \/\/ compiled entry\n+  __ align(CodeEntryAlignment);\n+  compiled_entry_offset = __ pc() - start;\n+\n+  __ enter();\n+  stack_slots = 2; \/\/ will be adjusted in setup\n+  OopMap* map = continuation_enter_setup(masm, stack_slots);\n+  frame_complete = __ pc() - start;\n+\n+  fill_continuation_entry(masm);\n+\n+  __ bnez(c_rarg2, call_thaw);\n+\n+  \/\/ Make sure the call is patchable\n+  __ align(NativeInstruction::instruction_size);\n+\n+  const address tr_call = __ trampoline_call(resolve);\n+\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+  __ post_call_nop();\n+\n+  __ j(exit);\n+\n+  __ bind(call_thaw);\n+\n+  __ rt_call(CAST_FROM_FN_PTR(address, StubRoutines::cont_thaw()));\n+  oop_maps->add_gc_map(__ pc() - start, map->deep_copy());\n+  ContinuationEntry::_return_pc_offset = __ pc() - start;\n+  __ post_call_nop();\n+\n+  __ bind(exit);\n+  continuation_enter_cleanup(masm);\n+  __ leave();\n+  __ ret();\n+\n+  \/\/ exception handling\n+  exception_offset = __ pc() - start;\n+  {\n+    __ mv(x9, x10); \/\/ save return value contaning the exception oop in callee-saved x9\n+\n+    continuation_enter_cleanup(masm);\n+\n+    __ ld(c_rarg1, Address(fp, -1 * wordSize)); \/\/ return address\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), xthread, c_rarg1);\n+\n+    \/\/ see OptoRuntime::generate_exception_blob: x10 -- exception oop, x13 -- exception pc\n+\n+    __ mv(x11, x10); \/\/ the exception handler\n+    __ mv(x10, x9); \/\/ restore return value contaning the exception oop\n+    __ verify_oop(x10);\n+\n+    __ leave();\n+    __ mv(x13, ra);\n+    __ jr(x11); \/\/ the exception handler\n+  }\n+\n+  CodeBuffer* cbuf = masm->code_section()->outer();\n+  CompiledStaticCall::emit_to_interp_stub(*cbuf, tr_call);\n+}\n+\n+static void gen_continuation_yield(MacroAssembler* masm,\n+                                   const methodHandle& method,\n+                                   const BasicType* sig_bt,\n+                                   const VMRegPair* regs,\n+                                   OopMapSet* oop_maps,\n+                                   int& frame_complete,\n+                                   int& stack_slots,\n+                                   int& compiled_entry_offset) {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+  \/\/ assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  stack_slots = framesize \/ VMRegImpl::slots_per_word;\n+  assert(stack_slots == 2, \"recheck layout\");\n+\n+  address start = __ pc();\n+\n+  compiled_entry_offset = __ pc() - start;\n+  __ enter();\n+\n+  __ mv(c_rarg1, sp);\n+\n+  frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+\n+  __ post_call_nop(); \/\/ this must be exactly after the pc value that is pushed into the frame info, we use this nop for fast CodeBlob lookup\n+\n+  __ mv(c_rarg0, xthread);\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  __ call_VM_leaf(Continuation::freeze_entry(), 2);\n+  __ reset_last_Java_frame(true);\n+\n+  Label pinned;\n+\n+  __ bnez(x10, pinned);\n+\n+  \/\/ We've succeeded, set sp to the ContinuationEntry\n+  __ ld(sp, Address(xthread, JavaThread::cont_entry_offset()));\n+  continuation_enter_cleanup(masm);\n+\n+  __ bind(pinned); \/\/ pinned -- return to caller\n+\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+}\n+\n@@ -956,0 +1202,65 @@\n+  if (method->is_continuation_native_intrinsic()) {\n+    int exception_offset = -1;\n+    OopMapSet* oop_maps = new OopMapSet();\n+    int frame_complete = -1;\n+    int stack_slots = -1;\n+    int interpreted_entry_offset = -1;\n+    int vep_offset = -1;\n+    if (method->is_continuation_enter_intrinsic()) {\n+      gen_continuation_enter(masm,\n+                             method,\n+                             in_sig_bt,\n+                             in_regs,\n+                             exception_offset,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             interpreted_entry_offset,\n+                             vep_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      gen_continuation_yield(masm,\n+                             method,\n+                             in_sig_bt,\n+                             in_regs,\n+                             oop_maps,\n+                             frame_complete,\n+                             stack_slots,\n+                             vep_offset);\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n+\n+#ifdef ASSERT\n+    if (method->is_continuation_enter_intrinsic()) {\n+      assert(interpreted_entry_offset != -1, \"Must be set\");\n+      assert(exception_offset != -1,         \"Must be set\");\n+    } else {\n+      assert(interpreted_entry_offset == -1, \"Must be unset\");\n+      assert(exception_offset == -1,         \"Must be unset\");\n+    }\n+    assert(frame_complete != -1,    \"Must be set\");\n+    assert(stack_slots != -1,       \"Must be set\");\n+    assert(vep_offset != -1,        \"Must be set\");\n+#endif\n+\n+    __ flush();\n+    nmethod* nm = nmethod::new_native_nmethod(method,\n+                                              compile_id,\n+                                              masm->code(),\n+                                              vep_offset,\n+                                              frame_complete,\n+                                              stack_slots,\n+                                              in_ByteSize(-1),\n+                                              in_ByteSize(-1),\n+                                              oop_maps,\n+                                              exception_offset);\n+    if (method->is_continuation_enter_intrinsic()) {\n+      ContinuationEntry::set_enter_code(nm, interpreted_entry_offset);\n+    } else if (method->is_continuation_yield_intrinsic()) {\n+      _cont_doYield_stub = nm;\n+    } else {\n+      guarantee(false, \"Unknown Continuation native intrinsic\");\n+    }\n+    return nm;\n+  }\n+\n@@ -1329,0 +1640,1 @@\n+    Label count;\n@@ -1351,4 +1663,1 @@\n-      {\n-        Label here;\n-        __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, lock_done, \/*fallthrough*\/NULL);\n-      }\n+      __ cmpxchg_obj_header(x10, lock_reg, obj_reg, t0, count, \/*fallthrough*\/NULL);\n@@ -1375,0 +1684,3 @@\n+    __ bind(count);\n+    __ increment(Address(xthread, JavaThread::held_monitor_count_offset()));\n+\n@@ -1460,1 +1772,1 @@\n-    Label done;\n+    Label done, not_recursive;\n@@ -1465,1 +1777,3 @@\n-      __ beqz(t0, done);\n+      __ bnez(t0, not_recursive);\n+      __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n+      __ j(done);\n@@ -1468,0 +1782,1 @@\n+    __ bind(not_recursive);\n@@ -1481,3 +1796,4 @@\n-      Label succeed;\n-      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, succeed, &slow_path_unlock);\n-      __ bind(succeed);\n+      Label count;\n+      __ cmpxchg_obj_header(x10, old_hdr, obj_reg, t0, count, &slow_path_unlock);\n+      __ bind(count);\n+      __ decrement(Address(xthread, JavaThread::held_monitor_count_offset()));\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":325,"deletions":9,"binary":false,"changes":334,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-\/\/ Java frames don't have callee saved registers (except for rfp), so we can use a smaller RegisterMap\n+\/\/ Java frames don't have callee saved registers (except for fp), so we can use a smaller RegisterMap\n@@ -36,2 +36,2 @@\n-  static void assert_is_rfp(VMReg r) NOT_DEBUG_RETURN\n-                                     DEBUG_ONLY({ Unimplemented(); })\n+  static void assert_is_fp(VMReg r) NOT_DEBUG_RETURN\n+                                    DEBUG_ONLY({ assert (r == fp->as_VMReg() || r == fp->as_VMReg()->next(), \"Reg: %s\", r->name()); })\n@@ -45,1 +45,3 @@\n-    Unimplemented();\n+    map->clear();\n+    map->set_include_argument_oops(this->include_argument_oops());\n+    frame::update_map_with_saved_link(map, (intptr_t**)sp - 2);\n@@ -52,1 +54,6 @@\n-    Unimplemented();\n+  #ifdef ASSERT\n+    for(int i = 0; i < RegisterMap::reg_count; i++) {\n+      VMReg r = VMRegImpl::as_VMReg(i);\n+      if (map->location(r, (intptr_t*)nullptr) != nullptr) assert_is_fp(r);\n+    }\n+  #endif\n@@ -56,2 +63,2 @@\n-    Unimplemented();\n-    return NULL;\n+    assert_is_fp(reg);\n+    return (address)(sp - 2);\n@@ -60,1 +67,1 @@\n-  inline void set_location(VMReg reg, address loc) { assert_is_rfp(reg); }\n+  inline void set_location(VMReg reg, address loc) { assert_is_fp(reg); }\n@@ -78,4 +85,1 @@\n-  VMReg find_register_spilled_here(void* p, intptr_t* sp) {\n-    Unimplemented();\n-    return NULL;\n-  }\n+  VMReg find_register_spilled_here(void* p, intptr_t* sp) { return fp->as_VMReg(); }\n","filename":"src\/hotspot\/cpu\/riscv\/smallRegisterMap_riscv.inline.hpp","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -35,2 +35,5 @@\n-  Unimplemented();\n-  return true;\n+  assert(!is_done(), \"\");\n+  intptr_t* p = (intptr_t*)p0;\n+  int argsize = is_compiled() ? (_cb->as_compiled_method()->method()->num_stack_arg_slots() * VMRegImpl::stack_slot_size) >> LogBytesPerWord : 0;\n+  int frame_size = _cb->frame_size() + argsize;\n+  return p == sp() - 2 || ((p - unextended_sp()) >= 0 && (p - unextended_sp()) < frame_size);\n@@ -42,2 +45,5 @@\n-  Unimplemented();\n-  return frame();\n+  if (is_done()) {\n+    return frame(_sp, _sp, nullptr, nullptr, nullptr, nullptr, true);\n+  } else {\n+    return frame(sp(), unextended_sp(), fp(), pc(), cb(), _oopmap, true);\n+  }\n@@ -48,2 +54,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert(!is_done(), \"\");\n+  return *(address*)(_sp - 1);\n@@ -54,2 +60,4 @@\n-  Unimplemented();\n-  return NULL;\n+  intptr_t* fp_addr = _sp - 2;\n+  return (frame_kind == ChunkFrames::Mixed && is_interpreted())\n+    ? fp_addr + *fp_addr \/\/ derelativize\n+    : *(intptr_t**)fp_addr;\n@@ -60,2 +68,3 @@\n-  Unimplemented();\n-  return NULL;\n+  intptr_t* fp = this->fp();\n+  assert(fp != nullptr, \"\");\n+  return fp + fp[offset];\n@@ -66,2 +75,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  return derelativize(frame::interpreter_frame_last_sp_offset);\n@@ -72,2 +81,2 @@\n-  Unimplemented();\n-  return NULL;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  return (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) ? _end : fp() + frame::sender_sp_offset;\n@@ -78,1 +87,9 @@\n-  Unimplemented();\n+  assert_is_interpreted_and_frame_type_mixed();\n+  if (derelativize(frame::interpreter_frame_locals_offset) + 1 >= _end) {\n+    _unextended_sp = _end;\n+    _sp = _end;\n+  } else {\n+    intptr_t* fp = this->fp();\n+    _unextended_sp = fp + fp[frame::interpreter_frame_sender_sp_offset];\n+    _sp = fp + frame::sender_sp_offset;\n+  }\n@@ -83,2 +100,5 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+\n+  intptr_t* top = unextended_sp(); \/\/ later subtract argsize if callee is interpreted\n+  intptr_t* bottom = derelativize(frame::interpreter_frame_locals_offset) + 1; \/\/ the sender's unextended sp: derelativize(frame::interpreter_frame_sender_sp_offset);\n+  return (int)(bottom - top);\n@@ -89,2 +109,3 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  int diff = (int)(derelativize(frame::interpreter_frame_locals_offset) - derelativize(frame::interpreter_frame_sender_sp_offset) + 1);\n+  return diff;\n@@ -95,2 +116,9 @@\n-  Unimplemented();\n-  return 0;\n+  assert_is_interpreted_and_frame_type_mixed();\n+  ResourceMark rm;\n+  InterpreterOopMap mask;\n+  frame f = to_frame();\n+  f.interpreted_frame_oop_map(&mask);\n+  return mask.num_oops()\n+        + 1 \/\/ for the mirror oop\n+        + ((intptr_t*)f.interpreter_frame_monitor_begin()\n+            - (intptr_t*)f.interpreter_frame_monitor_end()) \/ BasicObjectLock::size();\n@@ -102,1 +130,3 @@\n-  Unimplemented();\n+  if (map->update_map()) {\n+    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)2 : (intptr_t**)(_sp - 2));\n+  }\n@@ -108,1 +138,3 @@\n-  Unimplemented();\n+  if (map->update_map()) {\n+    frame::update_map_with_saved_link(map, map->in_cont() ? (intptr_t**)2 : (intptr_t**)(_sp - 2));\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkFrameStream_riscv.inline.hpp","additions":55,"deletions":23,"binary":false,"changes":78,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+#include \"runtime\/frame.inline.hpp\"\n+\n@@ -29,1 +31,3 @@\n-  Unimplemented();\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_offset_fp(relativize_address(fr.fp()));\n+  }\n@@ -33,1 +37,3 @@\n-  Unimplemented();\n+  if (fr.is_interpreted_frame()) {\n+    fr.set_fp(derelativize_address(fr.offset_fp()));\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/stackChunkOop_riscv.inline.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -41,0 +41,2 @@\n+#include \"runtime\/continuation.hpp\"\n+#include \"runtime\/continuationEntry.inline.hpp\"\n@@ -389,0 +391,2 @@\n+    __ pop_cont_fastpath(xthread);\n+\n@@ -3773,1 +3777,0 @@\n-\n@@ -3785,0 +3788,113 @@\n+#undef __\n+#define __ _masm->\n+\n+  address generate_cont_thaw(Continuation::thaw_kind kind) {\n+    bool return_barrier = Continuation::is_thaw_return_barrier(kind);\n+    bool return_barrier_exception = Continuation::is_thaw_return_barrier_exception(kind);\n+\n+    address start = __ pc();\n+\n+    if (return_barrier) {\n+      __ ld(sp, Address(xthread, JavaThread::cont_entry_offset()));\n+    }\n+\n+#ifndef PRODUCT\n+    {\n+      Label OK;\n+      __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+      __ beq(sp, t0, OK);\n+      __ stop(\"incorrect sp\");\n+      __ bind(OK);\n+    }\n+#endif\n+\n+    if (return_barrier) {\n+      \/\/ preserve possible return value from a method returning to the return barrier\n+      __ sub(sp, sp, 2 * wordSize);\n+      __ fsd(f10, Address(sp, 0 * wordSize));\n+      __ sd(x10, Address(sp, 1 * wordSize));\n+    }\n+\n+    __ mvw(c_rarg1, (return_barrier ? 1 : 0));\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, Continuation::prepare_thaw), xthread, c_rarg1);\n+    __ mv(t1, x10); \/\/ x10 contains the size of the frames to thaw, 0 if overflow or no more frames\n+\n+    if (return_barrier) {\n+      \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+      __ ld(x10, Address(sp, 1 * wordSize));\n+      __ fld(f10, Address(sp, 0 * wordSize));\n+      __ add(sp, sp, 2 * wordSize);\n+    }\n+\n+#ifndef PRODUCT\n+    {\n+      Label OK;\n+      __ ld(t0, Address(xthread, JavaThread::cont_entry_offset()));\n+      __ beq(sp, t0, OK);\n+      __ stop(\"incorrect sp\");\n+      __ bind(OK);\n+    }\n+#endif\n+\n+    Label thaw_success;\n+    \/\/ t1 contains the size of the frames to thaw, 0 if overflow or no more frames\n+    __ bnez(t1, thaw_success);\n+    __ la(t0, ExternalAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ jr(t0);\n+    __ bind(thaw_success);\n+\n+    \/\/ make room for the thawed frames\n+    __ sub(t0, sp, t1);\n+    __ andi(sp, t0, -16); \/\/ align\n+\n+    if (return_barrier) {\n+      \/\/ save original return value -- again\n+      __ sub(sp, sp, 2 * wordSize);\n+      __ fsd(f10, Address(sp, 0 * wordSize));\n+      __ sd(x10, Address(sp, 1 * wordSize));\n+    }\n+\n+    \/\/ If we want, we can templatize thaw by kind, and have three different entries\n+    __ mvw(c_rarg1, (uint32_t)kind);\n+\n+    __ call_VM_leaf(Continuation::thaw_entry(), xthread, c_rarg1);\n+    __ mv(t1, x10); \/\/ x10 is the sp of the yielding frame\n+\n+    if (return_barrier) {\n+      \/\/ restore return value (no safepoint in the call to thaw, so even an oop return value should be OK)\n+      __ ld(x10, Address(sp, 1 * wordSize));\n+      __ fld(f10, Address(sp, 0 * wordSize));\n+      __ add(sp, sp, 2 * wordSize);\n+    } else {\n+      __ mv(x10, zr); \/\/ return 0 (success) from doYield\n+    }\n+\n+    \/\/ we're now on the yield frame (which is in an address above us b\/c sp has been pushed down)\n+    __ mv(fp, t1);\n+    __ sub(sp, t1, 2 * wordSize); \/\/ now pointing to fp spill\n+\n+    if (return_barrier_exception) {\n+      __ ld(c_rarg1, Address(fp, -1 * wordSize)); \/\/ return address\n+      __ verify_oop(x10);\n+      __ mv(x9, x10); \/\/ save return value contaning the exception oop in callee-saved x9\n+\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::exception_handler_for_return_address), xthread, c_rarg1);\n+\n+      \/\/ see OptoRuntime::generate_exception_blob: x10 -- exception oop, x13 -- exception pc\n+\n+      __ mv(x11, x10); \/\/ the exception handler\n+      __ mv(x10, x9); \/\/ restore return value contaning the exception oop\n+      __ verify_oop(x10);\n+\n+      __ leave();\n+      __ mv(x13, ra);\n+      __ jr(x11); \/\/ the exception handler\n+    } else {\n+      \/\/ We're \"returning\" into the topmost thawed frame; see Thaw::push_return_frame\n+      __ leave();\n+      __ ret();\n+    }\n+\n+    return start;\n+  }\n+\n@@ -3787,2 +3903,5 @@\n-    Unimplemented();\n-    return nullptr;\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"Cont thaw\");\n+    address start = __ pc();\n+    generate_cont_thaw(Continuation::thaw_top);\n+    return start;\n@@ -3793,2 +3912,8 @@\n-    Unimplemented();\n-    return nullptr;\n+\n+    \/\/ TODO: will probably need multiple return barriers depending on return type\n+    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier\");\n+    address start = __ pc();\n+\n+    generate_cont_thaw(Continuation::thaw_return_barrier);\n+\n+    return start;\n@@ -3799,2 +3924,7 @@\n-    Unimplemented();\n-    return nullptr;\n+\n+    StubCodeMark mark(this, \"StubRoutines\", \"cont return barrier exception handler\");\n+    address start = __ pc();\n+\n+    generate_cont_thaw(Continuation::thaw_return_barrier_exception);\n+\n+    return start;\n@@ -3805,3 +3935,0 @@\n-#undef __\n-#define __ _masm->\n-\n@@ -3862,2 +3989,0 @@\n-#undef __\n-\n@@ -3866,0 +3991,2 @@\n+#undef __\n+\n@@ -3902,2 +4029,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub == nullptr ? nullptr\n-                                                    : StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n@@ -3909,1 +4035,1 @@\n-      StubRoutines::_verify_oop_subroutine_entry   = generate_verify_oop();\n+      StubRoutines::_verify_oop_subroutine_entry = generate_verify_oop();\n@@ -3911,0 +4037,1 @@\n+\n@@ -3984,2 +4111,0 @@\n-\n-  ~StubGenerator() {}\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":142,"deletions":17,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -522,0 +522,1 @@\n+  __ push_cont_fastpath(xthread);\n@@ -523,0 +524,1 @@\n+  __ pop_cont_fastpath(xthread);\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -138,2 +138,2 @@\n-#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n-  HeapWord* start = (HeapWord*)start_address() + sp() - frame::sender_sp_offset;\n+#if (defined(X86) || defined(AARCH64) || defined(RISCV64)) && !defined(ZERO)\n+  HeapWord* start = (HeapWord*)start_address() + sp() - frame::metadata_words;\n@@ -327,1 +327,1 @@\n-#if !defined(AMD64) || !defined(AARCH64) || defined(ZERO)\n+#if !defined(AMD64) || !defined(AARCH64) || !defined(RISCV64) || defined(ZERO)\n@@ -346,1 +346,1 @@\n-#if !defined(AMD64) || !defined(AARCH64) || defined(ZERO)\n+#if !defined(AMD64) || !defined(AARCH64) || !defined(RISCV64) || defined(ZERO)\n","filename":"src\/hotspot\/share\/oops\/stackChunkOop.inline.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -242,1 +242,1 @@\n-#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n+#if (defined(X86) || defined(AARCH64) || defined(RISCV64)) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/runtime\/continuation.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -769,1 +769,1 @@\n-#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n+#if (defined(X86) || defined(AARCH64) || defined(RISCV64)) && !defined(ZERO)\n@@ -1050,1 +1050,1 @@\n-  const int fsize = f.fp() + frame::metadata_words + locals - stack_frame_top;\n+  const int fsize = f.fp() NOT_RISCV64(+ frame::metadata_words) + locals - stack_frame_top;\n@@ -1491,1 +1491,1 @@\n-#if (defined(X86) || defined(AARCH64)) && !defined(ZERO)\n+#if (defined(X86) || defined(AARCH64) || defined(RISCV64)) && !defined(ZERO)\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3123,1 +3123,1 @@\n-        buffer.initialize_stubs_size(128);\n+        buffer.initialize_stubs_size(192);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}