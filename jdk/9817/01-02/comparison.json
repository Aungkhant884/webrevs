{"files":[{"patch":"@@ -43,15 +43,0 @@\n-class OopKeepaliveClosure : public OopClosure {\n-  CollectedHeap* _heap;\n-\n-public:\n-  OopKeepaliveClosure()\n-    : _heap(Universe::heap()) {}\n-\n-  virtual void do_oop(oop* p) {\n-    oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n-    _heap->keep_alive(obj);\n-  }\n-\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-\n@@ -79,0 +64,17 @@\n+  class OopKeepAliveClosure : public OopClosure {\n+  public:\n+    OopKeepAliveClosure() {}\n+\n+    virtual void do_oop(oop* p) {\n+      \/\/ Loads on nmethod oops are phantom strength. The intend of the load\n+      \/\/ is to just read the oop, and then explicitly keep it alive w.r.t.\n+      \/\/ concurrent marking. Using the keep alive side effects of a normal\n+      \/\/ phantom load is less explicit, and doesn't actually do anything\n+      \/\/ unless the returned value is used as an oop.\n+      oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      Universe::heap()->keep_alive(obj);\n+    }\n+\n+    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+  };\n+\n@@ -81,1 +83,1 @@\n-  OopKeepaliveClosure cl;\n+  OopKeepAliveClosure cl;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"}]}