{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -41,8 +43,0 @@\n-class LoadPhantomOopClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(p);\n-  }\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-\n@@ -70,0 +64,15 @@\n+  class OopKeepAliveClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      \/\/ Loads on nmethod oops are phantom strength. The intend of the load\n+      \/\/ is to just read the oop, and then explicitly keep it alive w.r.t.\n+      \/\/ concurrent marking. Using the keep alive side effects of a normal\n+      \/\/ phantom load is less explicit, and doesn't actually do anything\n+      \/\/ unless the returned value is used as an oop.\n+      oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      Universe::heap()->keep_alive(obj);\n+    }\n+\n+    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+  };\n+\n@@ -71,3 +80,2 @@\n-  \/\/ SATB GC, then it is important that this code marks them live. This is done\n-  \/\/ by the phantom load.\n-  LoadPhantomOopClosure cl;\n+  \/\/ SATB GC, then it is important that this code marks them live.\n+  OopKeepAliveClosure cl;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"}]}