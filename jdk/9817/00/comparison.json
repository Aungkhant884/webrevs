{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -41,1 +43,4 @@\n-class LoadPhantomOopClosure : public OopClosure {\n+class OopKeepaliveClosure : public OopClosure {\n+private:\n+  CollectedHeap* _heap;\n+\n@@ -43,0 +48,3 @@\n+  OopKeepaliveClosure()\n+    : _heap(Universe::heap()) {}\n+\n@@ -44,1 +52,2 @@\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(p);\n+    oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+    _heap->keep_alive(obj);\n@@ -46,0 +55,1 @@\n+\n@@ -71,3 +81,2 @@\n-  \/\/ SATB GC, then it is important that this code marks them live. This is done\n-  \/\/ by the phantom load.\n-  LoadPhantomOopClosure cl;\n+  \/\/ SATB GC, then it is important that this code marks them live.\n+  OopKeepaliveClosure cl;\n@@ -108,0 +117,6 @@\n+  \/\/ We wrap around at INT_MAX. That means that we assume nmethods won't have ABA\n+  \/\/ problems in their nmethod disarm values after INT_MAX - 1 GCs. Every time a GC\n+  \/\/ completes, ABA problems are removed, but if a concurrent GC is started and then\n+  \/\/ aborted N times, that is when there could be ABA problems. If there are anything\n+  \/\/ close to INT_MAX - 1 GCs starting without being able to finish, something is\n+  \/\/ seriously wrong.\n@@ -109,1 +124,1 @@\n-  if (_current_phase == 4) {\n+  if (_current_phase == INT_MAX) {\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"}]}