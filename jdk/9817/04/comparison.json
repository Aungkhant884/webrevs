{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/collectedHeap.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -41,8 +43,0 @@\n-class LoadPhantomOopClosure : public OopClosure {\n-public:\n-  virtual void do_oop(oop* p) {\n-    NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(p);\n-  }\n-  virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n-};\n-\n@@ -70,0 +64,17 @@\n+  class OopKeepAliveClosure : public OopClosure {\n+  public:\n+    virtual void do_oop(oop* p) {\n+      \/\/ Loads on nmethod oops are phantom strength.\n+      \/\/\n+      \/\/ Note that we could have used NativeAccess<ON_PHANTOM_OOP_REF>::oop_load(p),\n+      \/\/ but that would have *required* us to convert the returned LoadOopProxy to an oop,\n+      \/\/ or else keep alive load barrier will never be called. It's the LoadOopProxy-to-oop\n+      \/\/ conversion that performs the load barriers. This is too subtle, so we instead\n+      \/\/ perform an explicit keep alive call.\n+      oop obj = NativeAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      Universe::heap()->keep_alive(obj);\n+    }\n+\n+    virtual void do_oop(narrowOop* p) { ShouldNotReachHere(); }\n+  };\n+\n@@ -71,3 +82,2 @@\n-  \/\/ SATB GC, then it is important that this code marks them live. This is done\n-  \/\/ by the phantom load.\n-  LoadPhantomOopClosure cl;\n+  \/\/ SATB GC, then it is important that this code marks them live.\n+  OopKeepAliveClosure cl;\n","filename":"src\/hotspot\/share\/gc\/shared\/barrierSetNMethod.cpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"}]}