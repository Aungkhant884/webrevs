{"files":[{"patch":"@@ -4920,18 +4920,1 @@\n-        JVMState* old_jvms = alloc->jvms()->clone_shallow(C);\n-        uint size = alloc->req();\n-        SafePointNode* sfpt = new SafePointNode(size, old_jvms);\n-        old_jvms->set_map(sfpt);\n-        for (uint i = 0; i < size; i++) {\n-          sfpt->init_req(i, alloc->in(i));\n-        }\n-        \/\/ re-push array length for deoptimization\n-        sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n-        old_jvms->set_sp(old_jvms->sp()+1);\n-        old_jvms->set_monoff(old_jvms->monoff()+1);\n-        old_jvms->set_scloff(old_jvms->scloff()+1);\n-        old_jvms->set_endoff(old_jvms->endoff()+1);\n-        old_jvms->set_should_reexecute(true);\n-\n-        sfpt->set_i_o(map()->i_o());\n-        sfpt->set_memory(map()->memory());\n-        sfpt->set_control(map()->control());\n+        SafePointNode* sfpt = create_safepoint_with_state_before_array_allocation(alloc);\n@@ -4952,0 +4935,24 @@\n+\/\/ Clone the JVMState of the array allocation and create a new safepoint with it. Re-push the array length to the stack\n+\/\/ such that uncommon traps can be emitted to re-execute the array allocation in the interpreter.\n+SafePointNode* LibraryCallKit::create_safepoint_with_state_before_array_allocation(const AllocateArrayNode* alloc) const {\n+  JVMState* old_jvms = alloc->jvms()->clone_shallow(C);\n+  uint size = alloc->req();\n+  SafePointNode* sfpt = new SafePointNode(size, old_jvms);\n+  old_jvms->set_map(sfpt);\n+  for (uint i = 0; i < size; i++) {\n+    sfpt->init_req(i, alloc->in(i));\n+  }\n+  \/\/ re-push array length for deoptimization\n+  sfpt->ins_req(old_jvms->stkoff() + old_jvms->sp(), alloc->in(AllocateNode::ALength));\n+  old_jvms->set_sp(old_jvms->sp()+1);\n+  old_jvms->set_monoff(old_jvms->monoff()+1);\n+  old_jvms->set_scloff(old_jvms->scloff()+1);\n+  old_jvms->set_endoff(old_jvms->endoff()+1);\n+  old_jvms->set_should_reexecute(true);\n+\n+  sfpt->set_i_o(map()->i_o());\n+  sfpt->set_memory(map()->memory());\n+  sfpt->set_control(map()->control());\n+  return sfpt;\n+}\n+\n@@ -4959,1 +4966,1 @@\n-void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms,\n+void LibraryCallKit::arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms_before_guards,\n@@ -4961,1 +4968,3 @@\n-  if (saved_jvms != NULL && !stopped()) {\n+  if (saved_jvms_before_guards != NULL && !stopped()) {\n+    replace_unrelated_uncommon_traps_with_alloc_state(alloc, saved_jvms_before_guards);\n+\n@@ -4964,3 +4973,3 @@\n-    saved_jvms->map()->set_control(map()->control());\n-    assert(saved_jvms->map()->memory() == map()->memory(), \"memory state changed?\");\n-    assert(saved_jvms->map()->i_o() == map()->i_o(), \"IO state changed?\");\n+    saved_jvms_before_guards->map()->set_control(map()->control());\n+    assert(saved_jvms_before_guards->map()->memory() == map()->memory(), \"memory state changed?\");\n+    assert(saved_jvms_before_guards->map()->i_o() == map()->i_o(), \"IO state changed?\");\n@@ -4969,2 +4978,2 @@\n-    map()->replaced_nodes().apply(saved_jvms->map(), new_idx);\n-    set_jvms(saved_jvms);\n+    map()->replaced_nodes().apply(saved_jvms_before_guards->map(), new_idx);\n+    set_jvms(saved_jvms_before_guards);\n@@ -5046,0 +5055,52 @@\n+\/\/ Unrelated UCTs between the array allocation and the array copy, which are considered safe by tightly_coupled_allocation(),\n+\/\/ need to be replaced by an UCT with a state before the array allocation (including the array length). This is necessary\n+\/\/ because we could hit one of these UCTs (which are executed before the emitted array copy guards and the actual array\n+\/\/ allocation which is moved down in arraycopy_move_allocation_here()). When later resuming execution in the interpreter,\n+\/\/ we would have wrongly skipped the array allocation. To prevent this, we resume execution at the array allocation in\n+\/\/ the interpreter similar to what we are doing for the newly emitted guards for the array copy.\n+void LibraryCallKit::replace_unrelated_uncommon_traps_with_alloc_state(AllocateArrayNode* alloc,\n+                                                                       JVMState* saved_jvms_before_guards) {\n+  if (saved_jvms_before_guards->map()->control()->is_IfProj()) {\n+    \/\/ There is at least one unrelated uncommon trap which needs to be replaced.\n+    SafePointNode* sfpt = create_safepoint_with_state_before_array_allocation(alloc);\n+\n+    JVMState* saved_jvms = jvms();\n+    const int saved_reexecute_sp = _reexecute_sp;\n+    set_jvms(sfpt->jvms());\n+    _reexecute_sp = jvms()->sp();\n+\n+    replace_unrelated_uncommon_traps_with_alloc_state(saved_jvms_before_guards);\n+\n+    \/\/ Restore state\n+    set_jvms(saved_jvms);\n+    _reexecute_sp = saved_reexecute_sp;\n+  }\n+}\n+\n+\/\/ Replace the unrelated uncommon traps with new uncommon trap nodes by reusing the action and reason. The new uncommon\n+\/\/ traps will have the state of the array allocation. Let the old uncommon trap nodes die.\n+void LibraryCallKit::replace_unrelated_uncommon_traps_with_alloc_state(JVMState* saved_jvms_before_guards) {\n+  Node* if_proj = saved_jvms_before_guards->map()->control(); \/\/ Start the search right before the newly emitted guards\n+  while (if_proj->is_IfProj()) {\n+    CallStaticJavaNode* uncommon_trap = get_uncommon_trap_from_success_proj(if_proj);\n+    if (uncommon_trap != nullptr) {\n+      create_new_uncommon_trap(uncommon_trap);\n+    }\n+    assert(if_proj->in(0)->is_If(), \"must be If\");\n+    if_proj = if_proj->in(0)->in(0);\n+  }\n+  assert(if_proj->is_Proj() && if_proj->in(0)->is_Initialize(),\n+         \"must have reached control projection of init node\");\n+}\n+\n+void LibraryCallKit::create_new_uncommon_trap(CallStaticJavaNode* uncommon_trap_call) {\n+  const int trap_request = uncommon_trap_call->uncommon_trap_request();\n+  assert(trap_request != 0, \"no valid UCT trap request\");\n+  PreserveJVMState pjvms(this);\n+  set_control(uncommon_trap_call->in(0));\n+  uncommon_trap(Deoptimization::trap_request_reason(trap_request),\n+                Deoptimization::trap_request_action(trap_request));\n+  assert(stopped(), \"Should be stopped\");\n+  _gvn.hash_delete(uncommon_trap_call);\n+  uncommon_trap_call->set_req(0, top()); \/\/ not used anymore, kill it\n+}\n@@ -5066,1 +5127,1 @@\n-  JVMState* saved_jvms = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);\n+  JVMState* saved_jvms_before_guards = arraycopy_restore_alloc_state(alloc, saved_reexecute_sp);\n@@ -5069,3 +5130,3 @@\n-  \/\/ if saved_jvms != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n-  \/\/ if saved_jvms == NULL and alloc != NULL, we can't emit any guards\n-  bool can_emit_guards = (alloc == NULL || saved_jvms != NULL);\n+  \/\/ if saved_jvms_before_guards != NULL (then alloc != NULL) then we can handle guards and a tightly coupled allocation\n+  \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we can't emit any guards\n+  bool can_emit_guards = (alloc == NULL || saved_jvms_before_guards != NULL);\n@@ -5087,1 +5148,1 @@\n-  src  = saved_jvms != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src,  T_ARRAY);\n+  src  = saved_jvms_before_guards != NULL ? null_check_oop(src, &null_ctl, true, true) : null_check(src, T_ARRAY);\n@@ -5092,1 +5153,1 @@\n-    \/\/ if saved_jvms == NULL and alloc != NULL, we don't emit any\n+    \/\/ if saved_jvms_before_guards == NULL and alloc != NULL, we don't emit any\n@@ -5206,1 +5267,1 @@\n-  if (saved_jvms != NULL) {\n+  if (saved_jvms_before_guards != NULL) {\n@@ -5278,0 +5339,1 @@\n+    arraycopy_move_allocation_here(alloc, dest, saved_jvms_before_guards, saved_reexecute_sp, new_idx);\n@@ -5280,2 +5342,0 @@\n-  arraycopy_move_allocation_here(alloc, dest, saved_jvms, saved_reexecute_sp, new_idx);\n-\n@@ -5346,20 +5406,8 @@\n-    if ((ctl->is_IfFalse() || ctl->is_IfTrue()) && ctl->in(0)->is_If()) {\n-      IfNode* iff = ctl->in(0)->as_If();\n-      Node* not_ctl = iff->proj_out_or_null(1 - ctl->as_Proj()->_con);\n-      assert(not_ctl != NULL && not_ctl != ctl, \"found alternate\");\n-      \/\/ One more try:  Various low-level checks bottom out in\n-      \/\/ uncommon traps.  If the debug-info of the trap omits\n-      \/\/ any reference to the allocation, as we've already\n-      \/\/ observed, then there can be no objection to the trap.\n-      bool found_trap = false;\n-      for (DUIterator_Fast jmax, j = not_ctl->fast_outs(jmax); j < jmax; j++) {\n-        Node* obs = not_ctl->fast_out(j);\n-        if (obs->in(0) == not_ctl && obs->is_Call() &&\n-            (obs->as_Call()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n-          found_trap = true; break;\n-        }\n-      }\n-      if (found_trap) {\n-        ctl = iff->in(0);       \/\/ This test feeds a harmless uncommon trap.\n-        continue;\n-      }\n+    \/\/ Various low-level checks bottom out in uncommon traps. These\n+    \/\/ are considered safe since we've already checked above that\n+    \/\/ there is no unexpected observer of this allocation.\n+    if (get_uncommon_trap_from_success_proj(ctl) != nullptr) {\n+      assert(ctl->in(0)->is_If(), \"must be If\");\n+      ctl = ctl->in(0)->in(0);\n+    } else {\n+      return nullptr;\n@@ -5367,1 +5415,0 @@\n-    return NULL;\n@@ -5378,0 +5425,14 @@\n+CallStaticJavaNode* LibraryCallKit::get_uncommon_trap_from_success_proj(Node* node) {\n+  if (node->is_IfProj()) {\n+    Node* other_proj = node->as_IfProj()->other_if_proj();\n+    for (DUIterator_Fast jmax, j = other_proj->fast_outs(jmax); j < jmax; j++) {\n+      Node* obs = other_proj->fast_out(j);\n+      if (obs->in(0) == other_proj && obs->is_CallStaticJava() &&\n+          (obs->as_CallStaticJava()->entry_point() == SharedRuntime::uncommon_trap_blob()->entry_point())) {\n+        return obs->as_CallStaticJava();\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":116,"deletions":55,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -269,0 +269,5 @@\n+  static CallStaticJavaNode* get_uncommon_trap_from_success_proj(Node* node);\n+  SafePointNode* create_safepoint_with_state_before_array_allocation(const AllocateArrayNode* alloc) const;\n+  void replace_unrelated_uncommon_traps_with_alloc_state(AllocateArrayNode* alloc, JVMState* saved_jvms_before_guards);\n+  void replace_unrelated_uncommon_traps_with_alloc_state(JVMState* saved_jvms_before_guards);\n+  void create_new_uncommon_trap(CallStaticJavaNode* uncommon_trap_call);\n@@ -270,1 +275,1 @@\n-  void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms, int saved_reexecute_sp,\n+  void arraycopy_move_allocation_here(AllocateArrayNode* alloc, Node* dest, JVMState* saved_jvms_before_guards, int saved_reexecute_sp,\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,314 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8297730\n+ * @summary Test taking UCT between array allocation and array copy to report correct exception.\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation\n+ *                   -XX:CompileCommand=compileonly,compiler.arraycopy.TestArrayCopyIntrinsicWithUCT::test*\n+ *                   compiler.arraycopy.TestArrayCopyIntrinsicWithUCT\n+ *\/\n+\n+package compiler.arraycopy;\n+\n+import jdk.test.lib.Asserts;\n+\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+\n+public class TestArrayCopyIntrinsicWithUCT {\n+    static int zero = 0;\n+    static int zero2 = 0;\n+    static int minusOne = -1;\n+    static int iFld;\n+    static int iFld2;\n+    static boolean flag;\n+    static byte[] byArrNull = null;\n+    static A aFld = null;\n+\n+    static public void main(String[] args) {\n+        System.out.println(\"Start\"); \/\/ Ensure loaded.\n+        new A(); \/\/ Ensure loaded\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSize);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSize2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeFldSize);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeFldSize2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeStore);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeStore2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero3);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero4);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero5);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero6);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZero7);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld2);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld3);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld4);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld5);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld6);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroFld7);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeDivZeroNullPointer);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeSizeComplex);\n+        runNegativeSize(TestArrayCopyIntrinsicWithUCT::testNegativeControlFlowNotAllowed);\n+        flag = false;\n+        runNegativeSizeHalf();\n+        runNegativeSizeHalf();\n+    }\n+\n+    static void runNegativeSize(Supplier<byte[]> testMethod) {\n+        try {\n+            testMethod.get();\n+            Asserts.fail(\"should throw exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static void runNegativeSize(Function<byte[], byte[]> testMethod) {\n+        try {\n+            testMethod.apply(null);\n+            Asserts.fail(\"should throw exception\");\n+        } catch (NegativeArraySizeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static byte[] testNegativeSize(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = byArr.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSize2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = byArrNull.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeFldSize(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = byArr.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+\n+    static byte[] testNegativeFldSize2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = byArrNull.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeStore(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        iFld++; \/\/ Since we have a store here, we do not move the allocation down\n+        int len = byArr.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeStore2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        iFld++; \/\/ Since we have a store here, we do not move the allocation down\n+        int len = byArrNull.length; \/\/ null check trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero3(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero4(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero5(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero6(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZero7(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = 8 \/ zero \/ zero2; \/\/ 2 div by zero traps would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld2() {\n+        byte[] byArr = new byte[8];\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld3(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld4(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld5(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, iFld2);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld6(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroFld7(byte[] byArr) {\n+        byte[] b = new byte[-1]; \/\/ throws NegativeArraySizeException\n+        int len = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeDivZeroNullPointer(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int x = minusOne \/ zero \/ zero2; \/\/ div by zero trap would fail\n+        int len = byArr.length;\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        iFld = x;\n+        return b;\n+    }\n+\n+    static byte[] testNegativeSizeComplex(byte[] byArr) {\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        int x = minusOne \/ zero; \/\/ div by zero trap would fail\n+        int y = aFld.i;\n+        int len = byArr.length;\n+        x = x + aFld.i2 \/ zero2;\n+        System.arraycopy(byArr, 0, b, 0, x);\n+        iFld = x + y;\n+        return b;\n+    }\n+\n+    \/\/ Optimization not applied because of additional control flow that is not considered safe.\n+    static byte[] testNegativeControlFlowNotAllowed(byte[] byArr) {\n+        int x = 23;\n+        byte[] b = new byte[minusOne]; \/\/ throws NegativeArraySizeException\n+        if (flag) {\n+            x = 34;\n+        }\n+        int len = x \/ zero;\n+        System.arraycopy(byArr, 0, b, 0, 8);\n+        iFld = len;\n+        return b;\n+    }\n+\n+    static void runNegativeSizeHalf() {\n+        try {\n+            testNegativeSizeHalf(null);\n+            Asserts.fail(\"should throw exception\");\n+        } catch (NegativeArraySizeException e) {\n+            Asserts.assertTrue(flag, \"wrongly caught NegativeArraySizeException\");\n+        } catch (NullPointerException e) {\n+            Asserts.assertFalse(flag, \"wrongly caught NullPointerException\");\n+        }\n+        flag = !flag;\n+    }\n+\n+    static byte[] testNegativeSizeHalf(byte[] byArr) {\n+        int size = flag ? -1 : 1;\n+        byte[] b = new byte[size]; \/\/ throws NegativeArraySizeException if size == -1\n+        int len = byArr.length; \/\/ throws NullPointerException if size == 1\n+        System.arraycopy(byArr, 0, b, 0, len);\n+        return b;\n+    }\n+}\n+\n+class A {\n+    int i, i2;\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/arraycopy\/TestArrayCopyIntrinsicWithUCT.java","additions":314,"deletions":0,"binary":false,"changes":314,"status":"added"}]}