{"files":[{"patch":"@@ -40,0 +40,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -459,0 +460,1 @@\n+  TrimNative::PauseMark trim_native_pause(\"stringtable\");\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -740,0 +741,1 @@\n+  TrimNative::PauseMark trim_native_pause(\"symboltable\");\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,0 +94,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -917,0 +918,2 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n@@ -2552,0 +2555,1 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1237,0 +1238,2 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n@@ -1451,0 +1454,2 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -181,0 +181,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1712,0 +1713,3 @@\n+  \/\/ Pause native trimming for the duration of the GC\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -693,2 +693,13 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, TrimNativeHeap, false, EXPERIMENTAL,                        \\\n+          \"GC will attempt to trim the native heap periodically. By \"       \\\n+          \"default, the interval time is 60 seconds, but can be \"           \\\n+          \"changed using TrimNativeHeapInterval.\")                          \\\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 60, EXPERIMENTAL,                   \\\n+          \"If TrimNativeHeap is enabled: interval, in seconds, in which \"   \\\n+          \"the GC will attempt to trim the native heap.\")                   \\\n+          range(1, UINT_MAX)                                                \\\n+                                                                            \\\n+          \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -445,0 +446,2 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questioSns.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class NativeTrimmerThread : public ConcurrentGCThread {\n+\n+  Monitor* _lock;\n+\n+  int64_t _next_trim_time;\n+\n+  \/\/ Pausing\n+  int _pausers;\n+  int64_t _next_trim_time_saved;\n+\n+  static const int64_t never = INT64_MAX;\n+\n+  static int64_t now() { return os::javaTimeMillis(); }\n+\n+  void run_service() override {\n+\n+    log_info(gc, trim)(\"NativeTrimmer start.\");\n+\n+    int64_t ntt = 0;\n+    int64_t tnow = 0;\n+\n+    for (;;) {\n+      \/\/ 1 - Wait for _next_trim_time. Handle spurious wakeups and shutdown.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        do {\n+          tnow = now();\n+          ntt = _next_trim_time;\n+          if (ntt == never) {\n+            ml.wait(0); \/\/ infinite sleep\n+          } else if (ntt > tnow) {\n+            ml.wait(ntt - tnow); \/\/ sleep till next point\n+          }\n+          if (should_terminate()) {\n+            log_info(gc, trim)(\"NativeTrimmer stop.\");\n+            return;\n+          }\n+          tnow = now();\n+          ntt = _next_trim_time;\n+        } while (ntt > tnow);\n+      }\n+\n+      \/\/ 2 - Trim outside of lock protection.\n+      execute_trim_and_log();\n+\n+      \/\/ 3 - Update _next_trim_time; but give concurrent setters preference.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        tnow = now();\n+        int64_t ntt2 = _next_trim_time;\n+\n+        if (ntt2 == ntt) { \/\/ not changed concurrently?\n+          _next_trim_time = tnow + (TrimNativeHeapInterval * 1000);\n+        }\n+      } \/\/ Mutex scope\n+    }\n+  }\n+\n+  void stop_service() override {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  void execute_trim_and_log() const {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+    const int64_t tnow = now();\n+    os::size_change_t sc;\n+    Ticks start = Ticks::now();\n+    log_debug(gc, trim)(\"Trim native heap started...\");\n+    if (os::trim_native_heap(&sc)) {\n+      Tickspan trim_time = (Ticks::now() - start);\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_info(gc, trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                           trim_time.seconds() * 1000);\n+      } else {\n+        log_info(gc, trim)(\"Trim native heap (no details)\");\n+      }\n+    }\n+  }\n+\n+public:\n+\n+  NativeTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _next_trim_time(0),\n+    _pausers(0),\n+    _next_trim_time_saved(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    _next_trim_time = now() + TrimNativeHeapInterval * 1000;\n+    create_and_start();\n+  }\n+\n+  void pause(const char* reason) {\n+    assert(TrimNativeHeap, \"Only call if enabled\");\n+    assert(TrimNativeHeapInterval > 0, \"Only call if periodic trimming is enabled\");\n+    int lvl = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      if (_pausers == 0) {\n+        _next_trim_time_saved = _next_trim_time;\n+        _next_trim_time = never;\n+      }\n+      lvl = ++_pausers;\n+      \/\/ No need to wakeup trimmer\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer pause (%s) (%d)\", reason, lvl);\n+  }\n+\n+  void unpause(const char* reason) {\n+    assert(TrimNativeHeap, \"Only call if enabled\");\n+    assert(TrimNativeHeapInterval > 0, \"Only call if periodic trimming is enabled\");\n+    int lvl = 0;\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      lvl = _pausers--;\n+      if (_pausers == 0) {\n+        _next_trim_time = _next_trim_time_saved;\n+        _next_trim_time_saved = 0;\n+        ml.notify_all();\n+      }\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer unpause (%s) (%d)\", reason, lvl);\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmerThread* g_trimmer_thread = nullptr;\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void TrimNative::initialize() {\n+  if (TrimNativeHeap) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeap, false);\n+      log_info(gc, trim)(\"Native trim not supported on this platform.\");\n+      return;\n+    }\n+    g_trimmer_thread = new NativeTrimmerThread();\n+    log_info(gc, trim)(\"Periodic native trim enabled (interval: %u seconds)\", TrimNativeHeapInterval);\n+  }\n+}\n+\n+void TrimNative::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void TrimNative::pause_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->pause(reason);\n+  }\n+}\n+\n+void TrimNative::unpause_periodic_trim(const char* reason) {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->unpause(reason);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNative.cpp","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_TRIMNATIVE_HPP\n+#define SHARE_GC_SHARED_TRIMNATIVE_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+\n+class TrimNative : public AllStatic {\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void pause_periodic_trim(const char* reason);\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void unpause_periodic_trim(const char* reason);\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct PauseMark {\n+    const char* const _reason;\n+    PauseMark(const char* reason = \"unknown\") : _reason(reason) {\n+      if (TrimNativeHeap) {\n+        pause_periodic_trim(_reason);\n+      }\n+    }\n+    ~PauseMark()  {\n+      if (TrimNativeHeap) {\n+        unpause_periodic_trim(_reason);\n+      }\n+    }\n+  };\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_TRIMNATIVE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNative.hpp","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -287,0 +288,1 @@\n+\n@@ -425,0 +427,1 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n@@ -439,0 +442,1 @@\n+  TrimNative::PauseMark trim_native_pause(\"gc\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  f(conc_trim,                                      \"Concurrent Trim\")                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -117,0 +118,2 @@\n+    TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n","filename":"src\/hotspot\/share\/gc\/x\/xDriver.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -434,0 +435,2 @@\n+    TrimNative::PauseMark trim_native_pause(\"gc\");\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -199,0 +199,1 @@\n+  LOG_TAG(trim) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -55,1 +56,1 @@\n-  static const int _num_pools = 4;\n+  static constexpr int _num_pools = 4;\n@@ -83,1 +84,0 @@\n-    ThreadCritical tc;\n@@ -94,0 +94,10 @@\n+  bool empty() const {\n+    return _first == nullptr;\n+  }\n+\n+  static bool needs_cleaning() {\n+    STATIC_ASSERT(_num_pools == 4);\n+    return !_pools[0].empty() || !_pools[1].empty() ||\n+           !_pools[2].empty() || !_pools[3].empty();\n+  }\n+\n@@ -95,2 +105,6 @@\n-    for (int i = 0; i < _num_pools; i++) {\n-      _pools[i].prune();\n+    ThreadCritical tc;\n+    if (needs_cleaning()) {\n+      TrimNative::PauseMark trim_native_pause(\"chunk pool cleaner\");\n+      for (int i = 0; i < _num_pools; i++) {\n+        _pools[i].prune();\n+      }\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1058,0 +1059,5 @@\n+\n+  if (TrimNativeHeap) {\n+    TrimNative::initialize();\n+  }\n+\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -482,0 +483,2 @@\n+  TrimNative::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1649,0 +1650,1 @@\n+  TrimNative::PauseMark trim_native_pause(\"monitor deletion\");\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023 Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * @test id=serial\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test -XX:+UseSerialGC\n+ *\/\n+\n+\/*\n+ * @test id=parallel\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test -XX:+UseParallelGC\n+ *\/\n+\n+\/*\n+ * @test id=shenandoah\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test -XX:+UseShenandoahGC\n+ *\/\n+\n+\/*\n+ * @test id=Znongen\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test -XX:+UseZGC -XX:-ZGenerational\n+ *\/\n+\n+\/*\n+ * @test id=Zgen\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test -XX:+UseZGC -XX:+ZGenerational\n+ *\/\n+\n+\/\/ Other tests\n+\n+\/*\n+ * @test id=testOffByDefault\n+ * @summary Test that -GCTrimNative disables the feature\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testOffByDefault\n+ *\/\n+\n+\/*\n+ * @test id=testOffExplicit\n+ * @summary Test that GCTrimNative is off by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testOffExplicit\n+ *\/\n+\n+\/*\n+ * @test id=testOffOnNonCompliantPlatforms\n+ * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative testOffOnNonCompliantPlatforms\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Array;\n+import java.rmi.RemoteException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 16;\n+    static final int totalAllocationsSize = 16 * 1024 * 1024; \/\/ 16 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    private static OutputAnalyzer runTestWithOptions(String[] extraOptions) throws IOException {\n+\n+        List<String> allOptions = new ArrayList<String>();\n+        allOptions.addAll(Arrays.asList(extraOptions));\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:-ExplicitGCInvokesConcurrent\"); \/\/ Invoke explicit GC on System.gc\n+        allOptions.add(\"-Xlog:gc+trim=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        allOptions.add(TestTrimNative.class.getName());\n+        allOptions.add(\"RUN\");\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(allOptions.toArray(new String[0]));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+    }\n+\n+    private static void checkExpectedLogMessages(OutputAnalyzer output, boolean expectEnabled,\n+                                                 int expectedInterval) {\n+        if (expectEnabled) {\n+            output.shouldContain(\"Periodic native trim enabled (interval: \" + expectedInterval + \" seconds\");\n+            output.shouldContain(\"NativeTrimmer start\");\n+            output.shouldContain(\"NativeTrimmer stop\");\n+        } else {\n+            output.shouldNotContain(\"Native trim\");\n+        }\n+    }\n+\n+    \/**\n+     * Given JVM output, look for one or more log lines that describes a successful negative trim. The total amount\n+     * of trims should be matching about what the test program allocated.\n+     * @param output\n+     * @param minTrimsExpected min number of periodic trim lines expected in UL log\n+     * @param maxTrimsExpected min number of periodic trim lines expected in UL log\n+     *\/\n+    private static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minTrimsExpected,\n+                                                          int maxTrimsExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[gc,trim\\\\] Trim native heap: RSS\\\\+Swap: (\\\\d+)([BKMG])->(\\\\d+)([BKMG]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                System.out.println(\"Parsed Trim Line. rss1: \" + rss1 + \" rss2: \" + rss2);\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxTrimsExpected) {\n+                throw new RuntimeException(\"Abnormal high number of periodic trim attempts found (more than \" + maxTrimsExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minTrimsExpected) {\n+            throw new RuntimeException(\"We found fewer (periodic) trim lines in UL log than expected (expected at least \" + minTrimsExpected +\n+                    \", found \" + numTrimsFound + \").\");\n+        }\n+        \/\/ This is very fuzzy. Test program malloced X bytes, then freed them again and trimmed. But the log line prints change in RSS.\n+        \/\/ Which, of course, is influenced by a lot of other factors. But we expect to see *some* reasonable reduction in RSS\n+        \/\/ due to trimming.\n+        float fudge = 0.5f;\n+        \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+        \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+        \/\/ this test, we just reduce the fudge factor.\n+        if (Platform.isPPC()) { \/\/ le and be both\n+            fudge = 0.01f;\n+        }\n+        long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+        if (rssReductionTotal < expectedMinimalReduction) {\n+            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                    \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+        }\n+    }\n+\n+    static private final void runTest(String[] VMargs) throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:+TrimNativeHeap\",\n+                               \"-XX:TrimNativeHeapInterval=1\"\n+                }\n+        );\n+\n+        checkExpectedLogMessages(output, true, 1);\n+\n+        \/\/ We expect to see at least one GC-related trimming pause\n+        output.shouldMatch(\"NativeTrimmer pause.*(gc)\");\n+        output.shouldMatch(\"NativeTrimmer unpause.*(gc)\");\n+\n+        parseOutputAndLookForNegativeTrim(output,0, \/*  minTrimsExpected *\/ 10  \/*  maxTrimsExpected *\/);\n+    }\n+\n+    \/\/ Test that a high trim interval effectively disables trimming\n+    static private final void testHighTrimInterval() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:+TrimNativeHeap\",\n+                               \"-XX:TrimNativeHeapInterval=3600\"\n+                });\n+        checkExpectedLogMessages(output, true, 3600);\n+        parseOutputAndLookForNegativeTrim(output,0, \/*  minTrimsExpected *\/ 0  \/*  maxTrimsExpected *\/);\n+    }\n+\n+    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n+    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:+TrimNativeHeap\"\n+                });\n+        checkExpectedLogMessages(output, false, 0);\n+    }\n+\n+    \/\/ Test trim native is disabled if explicitly switched off\n+    static private final void testOffExplicit() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+UnlockExperimentalVMOptions\",\n+                               \"-XX:-TrimNativeHeap\"\n+                });\n+        checkExpectedLogMessages(output, false, 0);\n+    }\n+\n+    \/\/ Test trim native is disabled if explicitly switched off\n+    static private final void testOffByDefault() throws IOException {\n+        OutputAnalyzer output = runTestWithOptions (new String[] { });\n+        checkExpectedLogMessages(output, false, 0);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        if (args[0].equals(\"RUN\")) {\n+\n+            System.out.println(\"Will spike now...\");\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n+                Unsafe.getUnsafe().putByte(ptrs[i], (byte)0);\n+                Unsafe.getUnsafe().putByte(ptrs[i] + szAllocations \/ 2, (byte)0);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            \/\/ Do a system GC. Native trimming should be paused in that time.\n+            System.out.println(\"GC...\");\n+            System.gc();\n+\n+            \/\/ give GC time to react\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(3000);\n+            System.out.println(\"Done.\");\n+\n+            return;\n+\n+        } else if (args[0].equals(\"test\")) {\n+            runTest(Arrays.copyOfRange(args, 1, args.length));\n+        } else if (args[0].equals(\"testOffOnNonCompliantPlatforms\")) {\n+            testOffOnNonCompliantPlatforms();\n+        } else if (args[0].equals(\"testOffExplicit\")) {\n+            testOffExplicit();\n+        } else if (args[0].equals(\"testOffByDefault\")) {\n+            testOffByDefault();\n+        } else {\n+            throw new RuntimeException(\"Invalid test \" + args[0]);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestTrimNative.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.test.lib.Platform;\n@@ -34,1 +35,1 @@\n- * @requires (os.family==\"linux\") & !vm.musl\n+ * @requires os.family == \"linux\"\n@@ -45,1 +46,5 @@\n-        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n+        if (Platform.isMusl()) {\n+            output.shouldContain(\"Not available\");\n+        } else {\n+            output.shouldMatch(\"Trim native heap: RSS\\\\+Swap: \\\\d+[BKMG]->\\\\d+[BKMG] \\\\(-\\\\d+[BKMG]\\\\)\");\n+        }\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}