{"files":[{"patch":"@@ -21,1 +21,1 @@\n- * questions.\n+ * questioSns.\n@@ -30,0 +30,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -43,1 +44,1 @@\n-  const uint64_t _time;\n+  int64_t _time;\n@@ -45,3 +46,3 @@\n-  const uint64_t _duration;\n-  \/\/ memory relief\n-  const os::size_change_t _size_change;\n+  int64_t _duration;\n+  \/\/ rss\n+  size_t _rss_before, _rss_after;\n@@ -50,7 +51,16 @@\n-  TrimResult(uint64_t t, uint64_t d, os::size_change_t size_change) :\n-    _time(t), _duration(d), _size_change(size_change) {}\n-  TrimResult(const TrimResult& other) :\n-    _time(other._time), _duration(other._duration), _size_change(other._size_change) {}\n-  uint64_t time() const { return _time; }\n-  uint64_t duration() const { return _duration; }\n-  const os::size_change_t& size_change() const { return _size_change; }\n+\n+  TrimResult() : _time(-1), _duration(0), _rss_before(0), _rss_after(0) {}\n+\n+  TrimResult(int64_t t, int64_t d, size_t rss1, size_t rss2) :\n+    _time(t), _duration(d), _rss_before(rss1), _rss_after(rss2)\n+  {}\n+\n+  int64_t time() const { return _time; }\n+  int64_t duration() const { return _duration; }\n+  size_t rss_before() const { return _rss_before; }\n+  size_t rss_after() const { return _rss_before; }\n+\n+  bool is_valid() const {\n+    return _time >= 0 && _duration >= 0 &&\n+        _rss_before != 0 && _rss_after != 0;\n+  }\n@@ -60,2 +70,2 @@\n-    return checked_cast<ssize_t>(_size_change.before) -\n-           checked_cast<ssize_t>(_size_change.after);\n+    return checked_cast<ssize_t>(_rss_before) -\n+           checked_cast<ssize_t>(_rss_after);\n@@ -64,0 +74,5 @@\n+  void print_on(outputStream* st) const {\n+    st->print(\"time: \" INT64_FORMAT \", duration \" INT64_FORMAT\n+              \", rss1: \" SIZE_FORMAT \", rss2: \" SIZE_FORMAT \" (\" SSIZE_FORMAT \")\",\n+              _time, _duration, _rss_before, _rss_after, size_reduction());\n+  }\n@@ -68,1 +83,0 @@\n-\n@@ -71,1 +85,3 @@\n-  \/\/ Size changes for the last n trims, young to old\n+  \/\/ Note: history may contain invalid results; for one, it is\n+  \/\/ initialized with invalid results to keep iterating simple;\n+  \/\/ also invalid results can happen if measuring rss goes wrong.\n@@ -73,7 +89,1 @@\n-  int _num;\n-\n-  void push_elements() {\n-    for (int i = _max - 1; i > 0; i--) {\n-      _histo[i] = _histo[i - 1];\n-    }\n-  }\n+  int _pos; \/\/ position of next write\n@@ -83,3 +93,1 @@\n-  TrimHistory() : _num(0) {}\n-\n-  void reset() { _num = 0; }\n+  TrimHistory() : _pos(0) {}\n@@ -88,4 +96,3 @@\n-    push_elements();\n-    _histo[0] = result;\n-    if (_num < _max) {\n-      _num++;\n+    _histo[_pos] = result;\n+    if (++_pos == _max) {\n+      _pos = 0;\n@@ -95,46 +102,7 @@\n-  \/\/ Small heuristic to check if periodic trimming has been fruitful so far.\n-  \/\/ If this heuristic finds trimming to be harmful, we will inject one longer\n-  \/\/ trim interval (standard interval * GCTrimNativeStepDownFactor).\n-  \/\/\n-  \/\/ Trimming costs are the trim itself plus the re-aquisition costs of memory should the\n-  \/\/ released memory be malloced again. Trimming gains are the memory reduction over time.\n-  \/\/ Lasting gains are good; gains that don't last are not.\n-  \/\/\n-  \/\/ There are roughly three usage pattern:\n-  \/\/ - rare malloc spikes interspersed with long idle periods. Trimming is beneficial\n-  \/\/   since the relieved memory pressure holds for a long time.\n-  \/\/ - a constant low-intensity malloc drone. Trimming does not help much here but its\n-  \/\/   harmless too since trimming is cheap if it does not recover much.\n-  \/\/ - frequent malloc spikes with short idle periods; trimmed memory will be re-aquired\n-  \/\/   after only a short relief; here, trimming could be harmful since we pay a lot for\n-  \/\/   not much relief. We want to alleviate these scenarios.\n-  \/\/\n-  \/\/ Putting numbers on these things is difficult though. We cannot observe malloc\n-  \/\/ load directly, only RSS. For every trim we know the RSS reduction (from, to). So\n-  \/\/ for subsequent trims we also can glean from (<next sample>.from) whether RSS bounced\n-  \/\/ back. But that is quite vague since RSS may have been influenced by a ton of other\n-  \/\/ developments, especially for longer trim intervals.\n-  \/\/\n-  \/\/ Therefore this heuristic may produce false positives and negatives. We try to err on\n-  \/\/ the side of too much trimming here and to identify only situations that are clearly\n-  \/\/ harmful. Note that the GCTrimNativeStepDownFactor (4) is gentle enough for wrong\n-  \/\/ heuristic results not to be too harmful.\n-  bool recommend_pause() {\n-    if (_num < _max \/ 2) {\n-      return false; \/\/ not enough data;\n-    }\n-    int num_significant_trims = 0;\n-    int num_bouncebacks = 0;\n-    for (int i = _num - 1; i > 0; i--) { \/\/ oldest to youngest\n-      const ssize_t sz_before = checked_cast<ssize_t>(_histo[i].size_change().before);\n-      const ssize_t sz_after = checked_cast<ssize_t>(_histo[i].after);\n-      const ssize_t gains = sz_before - sz_after;\n-      if (gains > (ssize_t)MIN2(32 * M, _histo[i].before \/ 10)) { \/\/ considered significant\n-        num_significant_trims++;\n-        const ssize_t sz_before_next = checked_cast<ssize_t>(_histo[i - 1].before);\n-        const ssize_t bounceback = sz_before_next - sz_after;\n-        \/\/ We consider it to have bounced back if RSS for the followup sample returns to\n-        \/\/ within at least -2% of post-trim-RSS.\n-        if (bounceback >= (gains - (gains \/ 50))) {\n-          num_bouncebacks++;\n-        }\n+  template <class Functor>\n+  void iterate_oldest_to_youngest(Functor f) const {\n+    int idx = _pos;\n+    do {\n+      f(_histo + idx);\n+      if (++idx == _max) {\n+        idx = 0;\n@@ -142,5 +110,1 @@\n-    }\n-    log_trace(gc, trim)(\"Last %d trims yielded significant gains; %d showed bounceback.\",\n-                        num_significant_trims, num_bouncebacks);\n-    return (num_significant_trims >= (_max \/ 2) &&\n-            num_significant_trims == num_bouncebacks);\n+    } while (idx != _pos);\n@@ -148,0 +112,1 @@\n+\n@@ -200,2 +165,1 @@\n-      os::size_change_t sc;\n-      bool have_trim_results = execute_trim_and_log(&sc);\n+      TrimResult result = execute_trim_and_log();\n@@ -213,1 +177,1 @@\n-            \/\/ Feed trim data into history; then, if it recommends stepping down the trim interval,\n+            \/\/ Feed trim data into history and examine history.\n@@ -215,11 +179,2 @@\n-            bool long_pause = false;\n-            if (have_trim_results) {\n-              _trim_history.add(&sc);\n-              long_pause = _trim_history.recommend_pause();\n-            } else {\n-              \/\/ Sample was invalid, we lost it and hence history is torn: reset history and start from\n-              \/\/ scratch next time.\n-              _trim_history.reset();\n-            }\n-\n-            if (long_pause) {\n+            _trim_history.add(result);\n+            if (recommend_pause()) {\n@@ -227,1 +182,0 @@\n-              _trim_history.reset();\n@@ -232,1 +186,0 @@\n-\n@@ -240,1 +193,0 @@\n-\n@@ -250,1 +202,1 @@\n-  bool execute_trim_and_log(os::size_change_t* sc) {\n+  TrimResult execute_trim_and_log() {\n@@ -254,1 +206,1 @@\n-      return false;\n+      return TrimResult();\n@@ -256,0 +208,2 @@\n+    const int64_t tnow = now();\n+    os::size_change_t sc;\n@@ -257,1 +211,1 @@\n-    if (os::trim_native_heap(sc)) {\n+    if (os::trim_native_heap(&sc)) {\n@@ -259,3 +213,3 @@\n-      if (sc->after != SIZE_MAX) {\n-        const size_t delta = sc->after < sc->before ? (sc->before - sc->after) : (sc->after - sc->before);\n-        const char sign = sc->after < sc->before ? '-' : '+';\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n@@ -263,1 +217,1 @@\n-                           PROPERFMTARGS(sc->before), PROPERFMTARGS(sc->after), sign, PROPERFMTARGS(delta),\n+                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n@@ -265,1 +219,1 @@\n-        return true;\n+        return TrimResult(tnow, now() - tnow, sc.before, sc.after);\n@@ -270,0 +224,80 @@\n+    return TrimResult();\n+  }\n+\n+  \/\/\/\/\/\/ Heuristics \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  \/\/ Small heuristic to check if periodic trimming has been fruitful so far.\n+  \/\/ If this heuristic finds trimming to be harmful, we will inject one longer\n+  \/\/ trim interval (GCTrimNativeIntervalMax).\n+  \/\/\n+  \/\/ Trimming costs are the trim itself plus the re-aquisition costs of memory should the\n+  \/\/ released memory be malloced again. Trimming gains are the memory reduction over time.\n+  \/\/ Lasting gains are good; gains that don't last are not.\n+  \/\/\n+  \/\/ There are roughly three usage pattern:\n+  \/\/ - rare malloc spikes interspersed with long idle periods. Trimming is beneficial\n+  \/\/   since the relieved memory pressure holds for a long time.\n+  \/\/ - a constant low-intensity malloc drone. Trimming does not help much here but its\n+  \/\/   harmless too since trimming is cheap if it does not recover much.\n+  \/\/ - frequent malloc spikes with short idle periods; trimmed memory will be re-aquired\n+  \/\/   after only a short relief; here, trimming could be harmful since we pay a lot for\n+  \/\/   not much relief. We want to alleviate these scenarios.\n+  \/\/\n+  \/\/ Putting numbers on these things is difficult though. We cannot observe malloc\n+  \/\/ load directly, only RSS. For every trim we know the RSS reduction (from, to). So\n+  \/\/ for subsequent trims we also can glean from (<next sample>.from) whether RSS bounced\n+  \/\/ back. But that is quite vague since RSS may have been influenced by a ton of other\n+  \/\/ developments, especially for longer trim intervals.\n+  \/\/\n+  \/\/ Therefore this heuristic may produce false positives and negatives. We try to err on\n+  \/\/ the side of too much trimming here and to identify only situations that are clearly\n+  \/\/ harmful. Note that the GCTrimNativeIntervalMax default (4 * GCTrimNativeInterval)\n+  \/\/ is gentle enough for wrong heuristic results to not be too punative.\n+\n+  \/\/ Given two results of subsequent trims, return the lasting gain of the\n+  \/\/ first trim, in bytes. Negative numbers mean a loss.\n+  static ssize_t calc_lasting_gain(const TrimResult& s1, const TrimResult& s2) {\n+    ssize_t gain = s1.size_reduction();\n+    ssize_t loss = checked_cast<ssize_t>(s2.rss_before()) -\n+                   checked_cast<ssize_t>(s1.rss_after());\n+    return gain - loss;\n+  }\n+\n+  \/\/ Given two results of subsequent trims, return the interval time\n+  \/\/ between them. This includes the trim time itself.\n+  static int64_t interval_time(const TrimResult& s1, const TrimResult& s2) {\n+    return s2.time() - s1.time();\n+  }\n+\n+  \/\/ Given two results of subsequent trims, returns true if the first trim is considered\n+  \/\/ \"bad\" - a trim that had been not worth the cost.\n+  static bool is_bad_trim(const TrimResult& s1, const TrimResult& s2) {\n+    assert(s1.is_valid() && s2.is_valid(), \"Sanity\");\n+    const int64_t tinterval = interval_time(s1, s2);\n+    assert(tinterval >= 0, \"negative interval? \" INT64_FORMAT, tinterval);\n+    if (tinterval <= 0) {\n+      return false;\n+    }\n+    assert(tinterval >= s1.duration(), \"trim duration cannot be larger than trim interval (\"\n+           INT64_FORMAT \", \" INT64_FORMAT \")\", tinterval, s1.duration());\n+\n+    \/\/ Cost: ratio of trim time to total interval time (which contains trim time)\n+    const double ratio_trim_time_to_interval_time =\n+        (double)s1.duration() \/ (double)tinterval;\n+    assert(ratio_trim_time_to_interval_time >= 0, \"Sanity\");\n+\n+    \/\/ Any ratio of less than 1% trim time to interval time we regard as harmless\n+    \/\/ (e.g. less than 10ms for 1second of interval)\n+    if (ratio_trim_time_to_interval_time < 0.01) {\n+      return false;\n+    }\n+\n+    \/\/ Benefit: Ratio of lasting size reduction to RSS before the first trim.\n+    const double rss_gain_ratio = (double)calc_lasting_gain(s1, s2) \/ s1.rss_before();\n+\n+    \/\/ We consider paying 1% (or more) time-per-interval for\n+    \/\/ 1% (or less, maybe even negative) rss size reduction as bad.\n+    bool bad = ratio_trim_time_to_interval_time > rss_gain_ratio;\n+\n+tty->print_cr(\"%s\", bad ? \"BAD\" : \"\");\n+\n@@ -273,0 +307,28 @@\n+  bool recommend_pause() {\n+    struct { int trims, bad, ignored; } counts = { 0, 0, 0 };\n+    const TrimResult* previous = nullptr;\n+    auto trim_evaluater = [&counts, &previous] (const TrimResult* r) {\n+\n+tty->print(\"??  \");\n+r->print_on(tty);\n+\n+      if (!r->is_valid() || previous == nullptr || !previous->is_valid()) {\n+        \/\/ Note: we always ignore the very youngest trim, since we don't know the\n+        \/\/ RSS bounce back to the next trim yet.\n+        counts.ignored++;\n+      } else {\n+        counts.trims++;\n+        if (is_bad_trim(*previous, *r)) {\n+          counts.bad++;\n+        }\n+      }\n+\n+tty->cr();\n+      previous = r;\n+    };\n+    _trim_history.iterate_oldest_to_youngest(trim_evaluater);\n+    log_trace(gc, trim)(\"Heuristics: trims: %d, bad trims: %d, ignored: %d\",\n+                        counts.trims, counts.bad, counts.ignored);\n+    return counts.ignored <= 1 && counts.bad == counts.trims;\n+  }\n+\n@@ -296,1 +358,0 @@\n-      _trim_history.reset();\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.cpp","additions":168,"deletions":107,"binary":false,"changes":275,"status":"modified"}]}