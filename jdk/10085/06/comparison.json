{"files":[{"patch":"@@ -57,0 +57,1 @@\n+inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5418,0 +5418,29 @@\n+\n+static const size_t retain_size = 2 * M;\n+\n+bool os::should_trim_native_heap() {\n+#ifdef __GLIBC__\n+  bool rc = true;\n+  \/\/ We try, using mallinfo, to predict whether a malloc_trim(3) will be beneficial.\n+  \/\/\n+  \/\/ \"mallinfo::keepcost\" is no help even if manpage claims this to be the projected\n+  \/\/ trim size. In practice it is just a very small value with no relation to the actual\n+  \/\/ effect trimming will have.\n+  \/\/\n+  \/\/ Our best bet is \"mallinfo::fordblks\", the total chunk size of free blocks. Since\n+  \/\/ only free blocks can be trimmed, a very low bar is to require their combined size\n+  \/\/ to be higher than our retain size. Note, however, that \"mallinfo::fordblks\" includes\n+  \/\/ already-trimmed blocks, since glibc trims by calling madvice(MADV_DONT_NEED) on free\n+  \/\/ chunks but does not update its bookkeeping.\n+  \/\/\n+  \/\/ In the end we want to prevent obvious bogus attempts to trim, and for that fordblks\n+  \/\/ is good enough.\n+  os::Linux::glibc_mallinfo mi;\n+  bool possibly_wrapped;\n+  os::Linux::get_mallinfo(&mi, &possibly_wrapped);\n+  \/\/ If we cannot say for sure because we use an older glibc, assume trimming makes sense.\n+  return possibly_wrapped ? true : retain_size < mi.fordblks;\n+#else\n+  return false; \/\/ musl\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -1079,0 +1080,2 @@\n+  GCTrimNative::PauseThenTrimMark trim_pause_mark;\n+\n@@ -1753,0 +1756,1 @@\n+  GCTrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -176,0 +177,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -193,0 +194,2 @@\n+\n+  GCTrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -1713,0 +1714,3 @@\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::PauseThenTrimMark trim_native_pause;\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+\/\/ A class holding trim results for a single trim operation.\n+class TrimResult {\n+\n+  \/\/ time (ms) trim happened (javaTimeMillis)\n+  const uint64_t _time;\n+  \/\/ time (ms) trim itself took.\n+  const uint64_t _duration;\n+  \/\/ memory relief\n+  const os::size_change_t _size_change;\n+\n+public:\n+  TrimResult(uint64_t t, uint64_t d, os::size_change_t size_change) :\n+    _time(t), _duration(d), _size_change(size_change) {}\n+  TrimResult(const TrimResult& other) :\n+    _time(other._time), _duration(other._duration), _size_change(other._size_change) {}\n+  uint64_t time() const { return _time; }\n+  uint64_t duration() const { return _duration; }\n+  const os::size_change_t& size_change() const { return _size_change; }\n+\n+  \/\/ Returns size reduction; positive if memory was reduced\n+  ssize_t size_reduction() const {\n+    return checked_cast<ssize_t>(_size_change.before) -\n+           checked_cast<ssize_t>(_size_change.after);\n+  }\n+\n+};\n+\n+\/\/ A FIFO of the last n trim results\n+class TrimHistory {\n+\n+  static const int _max = 4;\n+\n+  \/\/ Size changes for the last n trims, young to old\n+  TrimResult _histo[_max];\n+  int _num;\n+\n+  void push_elements() {\n+    for (int i = _max - 1; i > 0; i--) {\n+      _histo[i] = _histo[i - 1];\n+    }\n+  }\n+\n+public:\n+\n+  TrimHistory() : _num(0) {}\n+\n+  void reset() { _num = 0; }\n+\n+  void add(const TrimResult& result) {\n+    push_elements();\n+    _histo[0] = result;\n+    if (_num < _max) {\n+      _num++;\n+    }\n+  }\n+\n+  \/\/ Small heuristic to check if periodic trimming has been fruitful so far.\n+  \/\/ If this heuristic finds trimming to be harmful, we will inject one longer\n+  \/\/ trim interval (standard interval * GCTrimNativeStepDownFactor).\n+  \/\/\n+  \/\/ Trimming costs are the trim itself plus the re-aquisition costs of memory should the\n+  \/\/ released memory be malloced again. Trimming gains are the memory reduction over time.\n+  \/\/ Lasting gains are good; gains that don't last are not.\n+  \/\/\n+  \/\/ There are roughly three usage pattern:\n+  \/\/ - rare malloc spikes interspersed with long idle periods. Trimming is beneficial\n+  \/\/   since the relieved memory pressure holds for a long time.\n+  \/\/ - a constant low-intensity malloc drone. Trimming does not help much here but its\n+  \/\/   harmless too since trimming is cheap if it does not recover much.\n+  \/\/ - frequent malloc spikes with short idle periods; trimmed memory will be re-aquired\n+  \/\/   after only a short relief; here, trimming could be harmful since we pay a lot for\n+  \/\/   not much relief. We want to alleviate these scenarios.\n+  \/\/\n+  \/\/ Putting numbers on these things is difficult though. We cannot observe malloc\n+  \/\/ load directly, only RSS. For every trim we know the RSS reduction (from, to). So\n+  \/\/ for subsequent trims we also can glean from (<next sample>.from) whether RSS bounced\n+  \/\/ back. But that is quite vague since RSS may have been influenced by a ton of other\n+  \/\/ developments, especially for longer trim intervals.\n+  \/\/\n+  \/\/ Therefore this heuristic may produce false positives and negatives. We try to err on\n+  \/\/ the side of too much trimming here and to identify only situations that are clearly\n+  \/\/ harmful. Note that the GCTrimNativeStepDownFactor (4) is gentle enough for wrong\n+  \/\/ heuristic results not to be too harmful.\n+  bool recommend_pause() {\n+    if (_num < _max \/ 2) {\n+      return false; \/\/ not enough data;\n+    }\n+    int num_significant_trims = 0;\n+    int num_bouncebacks = 0;\n+    for (int i = _num - 1; i > 0; i--) { \/\/ oldest to youngest\n+      const ssize_t sz_before = checked_cast<ssize_t>(_histo[i].size_change().before);\n+      const ssize_t sz_after = checked_cast<ssize_t>(_histo[i].after);\n+      const ssize_t gains = sz_before - sz_after;\n+      if (gains > (ssize_t)MIN2(32 * M, _histo[i].before \/ 10)) { \/\/ considered significant\n+        num_significant_trims++;\n+        const ssize_t sz_before_next = checked_cast<ssize_t>(_histo[i - 1].before);\n+        const ssize_t bounceback = sz_before_next - sz_after;\n+        \/\/ We consider it to have bounced back if RSS for the followup sample returns to\n+        \/\/ within at least -2% of post-trim-RSS.\n+        if (bounceback >= (gains - (gains \/ 50))) {\n+          num_bouncebacks++;\n+        }\n+      }\n+    }\n+    log_trace(gc, trim)(\"Last %d trims yielded significant gains; %d showed bounceback.\",\n+                        num_significant_trims, num_bouncebacks);\n+    return (num_significant_trims >= (_max \/ 2) &&\n+            num_significant_trims == num_bouncebacks);\n+  }\n+};\n+\n+class NativeTrimmer : public ConcurrentGCThread {\n+\n+  Monitor* _lock;\n+\n+  \/\/ Periodic trimming state\n+  const int64_t _interval_ms;\n+  const int64_t _max_interval_ms;\n+  const bool _periodic_trim_enabled;\n+\n+  int64_t _next_trim_time;\n+  int64_t _next_trim_time_saved; \/\/ for pause\n+\n+  TrimHistory _trim_history;\n+\n+  static const int64_t never = INT64_MAX;\n+\n+  static int64_t now() { return os::javaTimeMillis(); }\n+\n+  void run_service() override {\n+\n+    assert(GCTrimNativeHeap, \"Sanity\");\n+    assert(os::can_trim_native_heap(), \"Sanity\");\n+\n+    log_info(gc, trim)(\"NativeTrimmer start.\");\n+\n+    int64_t ntt = 0;\n+    int64_t tnow = 0;\n+\n+    for (;;) {\n+      \/\/ 1 - Wait for the next trim point\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        do {\n+          tnow = now();\n+          ntt = _next_trim_time;\n+          if (ntt == never) {\n+            ml.wait(0); \/\/ infinite sleep\n+          } else if (ntt > tnow) {\n+            ml.wait(ntt - tnow); \/\/ sleep till next point\n+          }\n+          if (should_terminate()) {\n+            log_info(gc, trim)(\"NativeTrimmer stop.\");\n+            return;\n+          }\n+          tnow = now();\n+          ntt = _next_trim_time;\n+        } while (ntt > tnow);\n+      }\n+\n+      \/\/ 2 - Trim\n+      os::size_change_t sc;\n+      bool have_trim_results = execute_trim_and_log(&sc);\n+\n+      \/\/ 3 - Update next trim time\n+      \/\/ Note: outside setters have preference -  if we paused\/unpaused\/scheduled trim concurrently while the last trim\n+      \/\/ was in progress, we do that. Note that if this causes two back-to-back trims, that is harmless since usually\n+      \/\/ the second trim is cheap.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        tnow = now();\n+        int64_t ntt2 = _next_trim_time;\n+        if (ntt2 == ntt) { \/\/ not changed concurrently?\n+          if (_periodic_trim_enabled) {\n+            \/\/ Feed trim data into history; then, if it recommends stepping down the trim interval,\n+            \/\/ do that.\n+            bool long_pause = false;\n+            if (have_trim_results) {\n+              _trim_history.add(&sc);\n+              long_pause = _trim_history.recommend_pause();\n+            } else {\n+              \/\/ Sample was invalid, we lost it and hence history is torn: reset history and start from\n+              \/\/ scratch next time.\n+              _trim_history.reset();\n+            }\n+\n+            if (long_pause) {\n+              log_debug(gc, trim)(\"NativeTrimmer: long pause (\" INT64_FORMAT \" ms)\", _max_interval_ms);\n+              _trim_history.reset();\n+              _next_trim_time = tnow + _max_interval_ms;\n+            } else {\n+              _next_trim_time = tnow + _interval_ms;\n+            }\n+\n+          } else {\n+            \/\/ periodic trim disabled\n+            _next_trim_time = never;\n+          }\n+        }\n+      } \/\/ Mutex scope\n+    }\n+\n+  }\n+\n+  void stop_service() override {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  \/\/ Return true if trim succeeded *and* we have valid size change data.\n+  bool execute_trim_and_log(os::size_change_t* sc) {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+    if (!os::should_trim_native_heap()) {\n+      log_trace(gc, trim)(\"Trim native heap: not necessary\");\n+      return false;\n+    }\n+    Ticks start = Ticks::now();\n+    if (os::trim_native_heap(sc)) {\n+      Tickspan trim_time = (Ticks::now() - start);\n+      if (sc->after != SIZE_MAX) {\n+        const size_t delta = sc->after < sc->before ? (sc->before - sc->after) : (sc->after - sc->before);\n+        const char sign = sc->after < sc->before ? '-' : '+';\n+        log_info(gc, trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                           PROPERFMTARGS(sc->before), PROPERFMTARGS(sc->after), sign, PROPERFMTARGS(delta),\n+                           trim_time.seconds() * 1000);\n+        return true;\n+      } else {\n+        log_info(gc, trim)(\"Trim native heap (no details)\");\n+      }\n+    }\n+    return false;\n+  }\n+\n+public:\n+\n+  NativeTrimmer() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _interval_ms(GCTrimNativeHeapInterval * 1000),\n+    _max_interval_ms(GCTrimNativeHeapIntervalMax * 1000),\n+    _periodic_trim_enabled(GCTrimNativeHeapInterval > 0),\n+    _next_trim_time(0),\n+    _next_trim_time_saved(0)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    _next_trim_time = _periodic_trim_enabled ? (now() + _interval_ms) : never;\n+    create_and_start();\n+  }\n+\n+  void pause() {\n+    if (!_periodic_trim_enabled) {\n+      return;\n+    }\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time_saved = _next_trim_time;\n+      _next_trim_time = never;\n+      _trim_history.reset();\n+      ml.notify_all();\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer pause\");\n+  }\n+\n+  void unpause() {\n+    if (!_periodic_trim_enabled) {\n+      return;\n+    }\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time = _next_trim_time_saved;\n+      ml.notify_all();\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer unpause\");\n+  }\n+\n+  void schedule_trim() {\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time = 0;\n+      ml.notify_all();\n+    }\n+    if (_periodic_trim_enabled) {\n+      log_debug(gc, trim)(\"NativeTrimmer unpause+trim\");\n+    } else {\n+      log_debug(gc, trim)(\"NativeTrimmer trim\");\n+    }\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmer* g_trimmer_thread = nullptr;\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void GCTrimNative::initialize() {\n+\n+  if (GCTrimNativeHeap) {\n+\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(GCTrimNativeHeap, false);\n+      log_info(gc, trim)(\"GCTrimNativeHeap disabled - trim-native not supported on this platform.\");\n+      return;\n+    }\n+\n+    log_info(gc, trim)(\"Native trim enabled.\");\n+\n+    if (GCTrimNativeHeapInterval > 0) { \/\/ periodic trimming enabled\n+      assert(GCTrimNativeHeapIntervalMax == 0 ||\n+             GCTrimNativeHeapIntervalMax > GCTrimNativeHeapInterval, \"Sanity\"); \/\/ see flag constraint\n+      if (GCTrimNativeHeapIntervalMax == 0) { \/\/ default\n+       FLAG_SET_ERGO(GCTrimNativeHeapIntervalMax, GCTrimNativeHeapInterval * 4);\n+      }\n+      log_info(gc, trim)(\"Periodic native trim enabled (interval: %u seconds, step-down-interval: %u seconds).\",\n+                          GCTrimNativeHeapInterval, GCTrimNativeHeapIntervalMax);\n+    } else {\n+      log_info(gc, trim)(\"Periodic native trim disabled (we trim at full gc only).\");\n+    }\n+\n+    g_trimmer_thread = new NativeTrimmer();\n+  }\n+}\n+\n+void GCTrimNative::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void GCTrimNative::pause_periodic_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->pause();\n+  }\n+}\n+\n+void GCTrimNative::unpause_periodic_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->unpause();\n+  }\n+}\n+\n+void GCTrimNative::schedule_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->schedule_trim();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.cpp","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n+#define SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class GCTrimNative : public AllStatic {\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  \/\/ Pause\/unpause periodic trim\n+  static void pause_periodic_trim();\n+  static void unpause_periodic_trim();\n+\n+  \/\/ Schedule an explicit trim now. If periodic trims are enabled and have been paused,\n+  \/\/ they are unpaused.\n+  static void schedule_trim();\n+\n+  struct PauseMark {\n+    PauseMark()   { GCTrimNative::pause_periodic_trim(); }\n+    ~PauseMark()  { GCTrimNative::unpause_periodic_trim(); }\n+  };\n+\n+  struct PauseThenTrimMark {\n+    PauseThenTrimMark()   { GCTrimNative::pause_periodic_trim(); }\n+    ~PauseThenTrimMark()  { GCTrimNative::schedule_trim(); }\n+  };\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.hpp","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -693,2 +693,23 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, GCTrimNativeHeap, false, EXPERIMENTAL,                      \\\n+          \"GC will attempt to trim the native heap periodically and \"       \\\n+          \"after full GCs.\")                                                \\\n+                                                                            \\\n+  product(uint, GCTrimNativeHeapInterval, 30, EXPERIMENTAL,                 \\\n+          \"If GCTrimNativeHeap is enabled: interval, in seconds, in which \" \\\n+          \"the VM will attempt to trim the native heap. This is a lower \"   \\\n+          \"bound; the JVM may increase the interval time up to \"            \\\n+          \"GCTrimNativeHeapIntervalMax.\"                                    \\\n+          \"A value of 0 disables periodic trimming altogether while \"       \\\n+          \"leaving trimming after full gc enabled.\")                        \\\n+          range(0, (24 * 60 * 60))                                          \\\n+                                                                            \\\n+  product(uint, GCTrimNativeHeapIntervalMax, 0, EXPERIMENTAL,               \\\n+          \"If GCTrimNativeHeap is enabled and GCTrimNativeHeapInterval is \" \\\n+          \"not 0: upper bound for the interval time, in seconds, in which \" \\\n+          \"the VM will attempt to trim the native heap.\")                   \\\n+          range(0, max_juint)                                               \\\n+          constraint(GCTrimNativeHeapIntervalMaxFunc,AtParse)               \\\n+                                                                            \\\n+          \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -204,0 +205,2 @@\n+\n+  GCTrimNative::initialize();\n@@ -509,0 +512,2 @@\n+  GCTrimNative::PauseThenTrimMark trim_native_pause;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -439,0 +439,11 @@\n+JVMFlag::Error GCTrimNativeHeapIntervalMaxFunc(uint value, bool verbose) {\n+  if (GCTrimNativeHeap && value < GCTrimNativeHeapInterval) {\n+    JVMFlag::printError(verbose,\n+                        \"GCTrimNativeHeapIntervalMax ( %u ) must be \"\n+                        \"greater than or equal to GCTrimNativeHeapInterval ( %u )\\n\",\n+                        value, GCTrimNativeHeapInterval);\n+    return JVMFlag::VIOLATES_CONSTRAINT;\n+  } else {\n+    return JVMFlag::SUCCESS;\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n- f(uint, GCCardSizeInBytesConstraintFunc)\n+ f(uint, GCCardSizeInBytesConstraintFunc)                      \\\n+ f(uint, GCTrimNativeHeapIntervalMaxFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -48,0 +49,2 @@\n+#include \"utilities\/events.hpp\"\n+\n@@ -425,0 +428,1 @@\n+  GCTrimNative::PauseThenTrimMark trim_pause_mark;\n@@ -439,0 +443,1 @@\n+  GCTrimNative::PauseMark trim_pause_mark;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -628,0 +629,2 @@\n+\n+  GCTrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  f(conc_trim,                                      \"Concurrent Trim\")                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -77,0 +78,2 @@\n+  GCTrimNative::initialize();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -268,0 +269,1 @@\n+  GCTrimNative::PauseMark trim_native_pause;\n@@ -482,0 +484,1 @@\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  LOG_TAG(trim) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -453,0 +454,2 @@\n+  GCTrimNative::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -445,0 +445,3 @@\n+  \/\/ Does the platform recommend trimming?\n+  static bool should_trim_native_heap();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,519 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * All these tests test the trim-native feature for all GCs.\n+ * Trim-native is the ability to trim the C-heap as part of the GC cycle.\n+ * This feature is controlled by -XX:+GCTrimNativeHeap (by default off).\n+ * Trimming happens on full gc for all gcs. Shenandoah and G1 also support\n+ * concurrent trimming (Shenandoah supports this without any ties to java\n+ * heap occupancy).\n+ *\n+ *\/\n+\n+\/\/\/\/ full gc tests \/\/\/\/\/\n+\n+\/*\n+ * @test id=fullgc-serial\n+ * @summary Test that GCTrimNativeHeap works with Serial\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc serial\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-parallel\n+ * @summary Test that GCTrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc parallel\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-shenandoah\n+ * @summary Test that GCTrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-g1\n+ * @summary Test that GCTrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc g1\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-z\n+ * @summary Test that GCTrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc z\n+ *\/\n+\n+\/\/\/\/ auto mode tests \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-parallel\n+ * @summary Test that GCTrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-shenandoah\n+ * @summary Test that GCTrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-g1\n+ * @summary Test that GCTrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-z\n+ * @summary Test that GCTrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto z\n+ *\/\n+\n+\/\/\/\/ test-auto-high-interval interval test \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-high-interval-parallel\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-g1\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-shenandoah\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-z\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval z\n+ *\/\n+\n+\/\/\/\/ test-auto-interval-0 test \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-zero-interval-parallel\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-g1\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-shenandoah\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-z\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval z\n+ *\/\n+\n+\/\/ Other tests\n+\n+\/*\n+ * @test id=off-explicit\n+ * @summary Test that -GCTrimNative disables the feature\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-explicit\n+ *\/\n+\n+\/*\n+ * @test id=off-by-default\n+ * @summary Test that GCTrimNative is off by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-by-default\n+ *\/\n+\n+\/*\n+ * @test id=off-on-other-platforms\n+ * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-on-other-platforms\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 16;\n+    static final int totalAllocationsSize = 16 * 1024 * 1024; \/\/ 16 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    enum GC {\n+        serial, parallel, g1, shenandoah, z;\n+        String getSwitchName() {\n+            String s = name();\n+            return \"-XX:+Use\" + s.substring(0, 1).toUpperCase() + s.substring(1) + \"GC\";\n+        }\n+        boolean isZ() { return this == GC.z; }\n+        boolean isSerial() { return this == GC.serial; }\n+        boolean isParallel() { return this == GC.parallel; }\n+        boolean isG1() { return this == GC.g1; }\n+        boolean isShenandoah() { return this == GC.shenandoah; }\n+    }\n+\n+    static private final OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] testArgs) throws IOException {\n+\n+        List<String> allOptions = new ArrayList<String>();\n+        allOptions.add(\"-XX:+UnlockExperimentalVMOptions\");\n+        allOptions.addAll(Arrays.asList(extraOptions));\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-Xlog:gc+trim=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        allOptions.add(TestTrimNative.class.getName());\n+        allOptions.add(\"RUN\");\n+        allOptions.addAll(Arrays.asList(testArgs));\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(allOptions.toArray(new String[0]));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+\n+    }\n+\n+    \/**\n+     * Given JVM output, look for a log line that describes a successful negative trim in the megabyte range\n+     * like this:\n+     * \"[2.053s][debug][gc,trim] Trim native heap (retain size: 5120K): RSS+Swap: 271M->223M (-49112K), 2.834ms\"\n+     * (Note: we use the \"properXXX\" print routines, therefore units can differ)\n+     * Check that the sum of all trim log lines comes to a total RSS reduction in the MB range\n+     * @param output\n+     * @param minExpected min number of trim lines expected in UL log\n+     * @param maxExpected max number of trim lines expected in UL log\n+     *\/\n+    private final static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minExpected, int maxExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[gc,trim\\\\] Trim native heap.*RSS\\\\+Swap: (\\\\d+)([KMB])->(\\\\d+)([KMB]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                System.out.println(\"Parsed Trim Line. rss1: \" + rss1 + \" rss2: \" + rss2);\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxExpected) {\n+                throw new RuntimeException(\"Abnormal high number of trim attempts found (more than \" + maxExpected +\n+                        \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minExpected) {\n+            throw new RuntimeException(\"We found fewer trim lines in UL log than expected (expected \" + minExpected +\n+                    \", found \" + numTrimsFound + \".\");\n+        }\n+        \/\/ This is very fuzzy. We malloced X, free'd X, trimmed, measured the combined effect of all reductions.\n+        \/\/ This does not take into effect mallocs or frees that may happen concurrently. But we expect to see *some*\n+        \/\/ reduction somewhere. Test with a fudge factor.\n+        float fudge = 0.7f;\n+        \/\/ On ppc, we see a vastly diminished return (~3M reduction instead of ~200), I suspect because of the underlying\n+        \/\/ 64k pages lead to a different geometry. Manual tests with larger reclaim sizes show that autotrim works. For\n+        \/\/ this test, we just reduce the fudge factor.\n+        if (Platform.isPPC()) { \/\/ le and be both\n+            fudge = 0.01f;\n+        }\n+        long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+        if (rssReductionTotal < expectedMinimalReduction) {\n+            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                    \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+        }\n+    }\n+\n+    \/\/ Test that we trim on full gc\n+    static private final void testWithFullGC(GC gc) throws IOException {\n+        System.out.println(\"testWithFullGC\");\n+        int sleeptime_secs = 2;\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, String.valueOf(sleeptime_secs * 1000) \/* ms after peak *\/ }\n+        );\n+        output.shouldContain(\"Native trim enabled.\");\n+        output.shouldContain(\"Periodic native trim enabled (interval: 30 seconds, step-down-interval: 120 seconds).\");\n+        output.shouldContain(\"NativeTrimmer start\");\n+        output.shouldContain(\"NativeTrimmer pause\");\n+        output.shouldContain(\"NativeTrimmer unpause+trim\");\n+        output.shouldContain(\"NativeTrimmer stop\");\n+        \/\/ With default interval time of 30 seconds, auto trimming should never kick in, so the only\n+        \/\/ log line we expect to see is the one from the full-gc induced trim.\n+        parseOutputAndLookForNegativeTrim(output, 1, 1);\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=1 causes a trim-native automatically, without GC (for now, shenandoah only)\n+    static private final void testAuto(GC gc) throws IOException {\n+        System.out.println(\"testAuto\");\n+        long t1 = System.currentTimeMillis();\n+        int sleeptime_secs = 4;\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=1\" },\n+                new String[] { \"false\" \/* full gc *\/, String.valueOf(sleeptime_secs * 1000) \/* ms after peak *\/ }\n+        );\n+        long t2 = System.currentTimeMillis();\n+        int runtime_s = (int)((t2 - t1) \/ 1000);\n+        output.shouldContain(\"Native trim enabled.\");\n+        output.shouldContain(\"Periodic native trim enabled (interval: 1 seconds, step-down-interval: 4 seconds).\");\n+        \/\/ With an interval time of 1 second and a runtime of 6..x seconds we expect to see x log lines (+- fudge factor).\n+        parseOutputAndLookForNegativeTrim(output, runtime_s - 4, runtime_s);\n+    }\n+\n+    \/\/ Test that trim-native correctly honors interval\n+    static private final void testAutoWithHighInterval(GC gc) throws IOException {\n+        \/\/ We pass a high interval than the expected test runtime. We expect no trims.\n+        System.out.println(\"testAutoWithHighInterval\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=12\" },\n+                new String[] { \"false\" \/* full gc *\/, \"6000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldContain(\"Native trim enabled.\");\n+        output.shouldContain(\"Periodic native trim enabled (interval: 12 seconds, step-down-interval: 48 seconds).\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    static private final void testAutoWithZeroInterval(GC gc) throws IOException {\n+        System.out.println(\"testAutoWithZeroInterval\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=0\" },\n+                new String[] { \"false\" \/* full gc *\/, \"4000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldContain(\"Native trim enabled.\");\n+        output.shouldContain(\"Periodic native trim disabled\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n+    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffOnNonCompliantPlatforms\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldContain(\"GCTrimNativeHeap disabled\");\n+        output.shouldNotContain(\"Native trim enabled.\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=0 switches trim-native off\n+    static private final void testOffExplicit() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffExplicit\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:-GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Native trim enabled.\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native is disabled by default\n+    static private final void testOffByDefault() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffByDefault\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Native trim enabled.\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        if (args[0].equals(\"RUN\")) {\n+            boolean doFullGC = Boolean.parseBoolean(args[1]);\n+\n+            System.out.println(\"Will spike now...\");\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n+                Unsafe.getUnsafe().putByte(ptrs[i], (byte)0);\n+                Unsafe.getUnsafe().putByte(ptrs[i] + szAllocations \/ 2, (byte)0);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            if (doFullGC) {\n+                System.out.println(\"GC...\");\n+                System.gc();\n+            }\n+\n+            \/\/ give GC time to react\n+            int time = Integer.parseInt(args[2]);\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(time);\n+            System.out.println(\"Done.\");\n+\n+            return;\n+\n+        } else if (args[0].equals(\"test-fullgc\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testWithFullGC(gc);\n+        } else if (args[0].equals(\"test-auto\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAuto(gc);\n+        } else if (args[0].equals(\"test-auto-high-interval\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAutoWithHighInterval(gc);\n+        } else if (args[0].equals(\"test-auto-zero-interval\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAutoWithZeroInterval(gc);\n+        } else if (args[0].equals(\"test-off-explicit\")) {\n+            testOffExplicit();\n+        } else if (args[0].equals(\"test-off-by-default\")) {\n+            testOffByDefault();\n+        } else if (args[0].equals(\"test-off-on-other-platforms\")) {\n+            testOffOnNonCompliantPlatforms();\n+        } else {\n+            throw new RuntimeException(\"Invalid test \" + args[0]);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestTrimNative.java","additions":519,"deletions":0,"binary":false,"changes":519,"status":"added"}]}