{"files":[{"patch":"@@ -57,0 +57,1 @@\n+inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5420,0 +5420,29 @@\n+\n+static const size_t retain_size = 2 * M;\n+\n+bool os::should_trim_native_heap() {\n+#ifdef __GLIBC__\n+  bool rc = true;\n+  \/\/ We try, using mallinfo, to predict whether a malloc_trim(3) will be beneficial.\n+  \/\/\n+  \/\/ \"mallinfo::keepcost\" is no help even if manpage claims this to be the projected\n+  \/\/ trim size. In practice it is just a very small value with no relation to the actual\n+  \/\/ effect trimming will have.\n+  \/\/\n+  \/\/ Our best bet is \"mallinfo::fordblks\", the total chunk size of free blocks. Since\n+  \/\/ only free blocks can be trimmed, a very low bar is to require their combined size\n+  \/\/ to be higher than our retain size. Note, however, that \"mallinfo::fordblks\" includes\n+  \/\/ already-trimmed blocks, since glibc trims by calling madvice(MADV_DONT_NEED) on free\n+  \/\/ chunks but does not update its bookkeeping.\n+  \/\/\n+  \/\/ In the end we want to prevent obvious bogus attempts to trim, and for that fordblks\n+  \/\/ is good enough.\n+  os::Linux::glibc_mallinfo mi;\n+  bool possibly_wrapped;\n+  os::Linux::get_mallinfo(&mi, &possibly_wrapped);\n+  \/\/ If we cannot say for sure because we use an older glibc, assume trimming makes sense.\n+  return possibly_wrapped ? true : retain_size < mi.fordblks;\n+#else\n+  return false; \/\/ musl\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -1756,0 +1757,1 @@\n+  GCTrimNative::initialize(true);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -176,0 +177,4 @@\n+\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::pause_periodic_trim();\n+\n@@ -240,0 +245,2 @@\n+\n+  GCTrimNative::schedule_trim();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -193,0 +194,2 @@\n+\n+  GCTrimNative::initialize(true);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -1715,0 +1716,3 @@\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::pause_periodic_trim();\n+\n@@ -1872,0 +1876,2 @@\n+    GCTrimNative::schedule_trim();\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+bool GCTrimNative::_async_mode = false;\n+double GCTrimNative::_next_trim_not_before = 0;\n+\n+\/\/ GCTrimNative works in two modes:\n+\/\/\n+\/\/ - async mode, where GCTrimNative runs a trimmer thread on behalf of the GC.\n+\/\/   The trimmer thread will be doing all the trims, both periodically and\n+\/\/   triggered from outside via GCTrimNative::schedule_trim().\n+\/\/\n+\/\/ - synchronous mode, where the GC does the trimming itself in its own thread,\n+\/\/   via GCTrimNative::should_trim() and GCTrimNative::execute_trim().\n+\/\/\n+\/\/ The mode is set as argument to GCTrimNative::initialize().\n+\n+class NativeTrimmer : public ConcurrentGCThread {\n+\n+  Monitor* _lock;\n+  volatile bool _paused;\n+  static NativeTrimmer* _the_trimmer;\n+\n+protected:\n+\n+  virtual void run_service() {\n+    assert(GCTrimNativeHeap, \"Sanity\");\n+    assert(os::can_trim_native_heap(), \"Sanity\");\n+\n+    log_info(gc, trim)(\"NativeTrimmer started.\");\n+\n+    \/\/ Note: GCTrimNativeHeapInterval=0 -> zero wait time -> indefinite waits, disabling periodic trim\n+    const int64_t delay_ms = GCTrimNativeHeapInterval * 1000;\n+    for (;;) {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      ml.wait(delay_ms);\n+      if (should_terminate()) {\n+        log_info(gc, trim)(\"NativeTrimmer stopped.\");\n+        break;\n+      }\n+      bool paused = Atomic::load(&_paused);\n+      if (!paused && os::should_trim_native_heap()) {\n+        GCTrimNative::do_trim();\n+      }\n+    }\n+  }\n+\n+  void wakeup() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+\n+  void pause() {\n+    Atomic::store(&_paused, true);\n+    log_debug(gc, trim)(\"NativeTrimmer paused\");\n+  }\n+\n+  void unpause() {\n+    Atomic::store(&_paused, false);\n+    log_debug(gc, trim)(\"NativeTrimmer unpaused\");\n+  }\n+\n+  virtual void stop_service() {\n+    wakeup();\n+  }\n+\n+public:\n+\n+  NativeTrimmer() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _paused(false)\n+  {}\n+\n+  static bool is_enabled() {\n+    return _the_trimmer != nullptr;\n+  }\n+\n+  static void start_trimmer() {\n+    _the_trimmer = new NativeTrimmer();\n+    _the_trimmer->create_and_start(NormPriority);\n+  }\n+\n+  static void stop_trimmer() {\n+    _the_trimmer->stop();\n+  }\n+\n+  static void pause_periodic_trim() {\n+    _the_trimmer->pause();\n+  }\n+\n+  static void unpause_periodic_trim() {\n+    _the_trimmer->unpause();\n+  }\n+\n+  static void schedule_trim_now() {\n+    _the_trimmer->unpause();\n+    _the_trimmer->wakeup();\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+NativeTrimmer* NativeTrimmer::_the_trimmer = nullptr;\n+\n+void GCTrimNative::do_trim() {\n+  Ticks start = Ticks::now();\n+  os::size_change_t sc;\n+  if (os::trim_native_heap(&sc)) {\n+    Tickspan trim_time = (Ticks::now() - start);\n+    if (sc.after != SIZE_MAX) {\n+      const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+      const char sign = sc.after < sc.before ? '-' : '+';\n+      log_info(gc, trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                         PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                         trim_time.seconds() * 1000);\n+    } else {\n+      log_info(gc, trim)(\"Trim native heap (no details)\");\n+    }\n+  }\n+}\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void GCTrimNative::initialize(bool async_mode) {\n+\n+  if (GCTrimNativeHeap) {\n+\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(GCTrimNativeHeap, false);\n+      log_info(gc, trim)(\"GCTrimNativeHeap disabled - trim-native not supported on this platform.\");\n+      return;\n+    }\n+\n+    log_debug(gc, trim)(\"GCTrimNativeHeap enabled.\");\n+\n+    _async_mode = async_mode;\n+\n+    \/\/ If we are to run the trimmer on behalf of the GC:\n+    if (_async_mode) {\n+      NativeTrimmer::start_trimmer();\n+    }\n+\n+    _next_trim_not_before = GCTrimNativeHeapInterval;\n+  }\n+}\n+\n+void GCTrimNative::cleanup() {\n+  if (GCTrimNativeHeap) {\n+    if (_async_mode) {\n+      NativeTrimmer::stop_trimmer();\n+    }\n+  }\n+}\n+\n+bool GCTrimNative::should_trim(bool ignore_delay) {\n+  return\n+      GCTrimNativeHeap && os::can_trim_native_heap() &&\n+      (ignore_delay || (GCTrimNativeHeapInterval > 0 && os::elapsedTime() > _next_trim_not_before)) &&\n+      os::should_trim_native_heap();\n+}\n+\n+void GCTrimNative::execute_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(!_async_mode, \"Only call for non-async mode\");\n+    do_trim();\n+    _next_trim_not_before = os::elapsedTime() + GCTrimNativeHeapInterval;\n+  }\n+}\n+\n+void GCTrimNative::pause_periodic_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(_async_mode, \"Only call for async mode\");\n+    NativeTrimmer::pause_periodic_trim();\n+  }\n+}\n+\n+void GCTrimNative::unpause_periodic_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(_async_mode, \"Only call for async mode\");\n+    NativeTrimmer::unpause_periodic_trim();\n+  }\n+}\n+\n+void GCTrimNative::schedule_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(_async_mode, \"Only call for async mode\");\n+    NativeTrimmer::schedule_trim_now();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.cpp","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n+#define SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class NativeTrimmer;\n+\n+class GCTrimNative : public AllStatic {\n+  friend class NativeTrimmer;\n+\n+  static bool _async_mode;\n+  static double _next_trim_not_before;\n+\n+  static void do_trim();\n+\n+public:\n+\n+  static void initialize(bool async_mode);\n+  static void cleanup();\n+\n+  \/\/ Returns true if:\n+  \/\/ - trimming is enabled and possible\n+  \/\/ - trimming may have an actual effect (guess)\n+  \/\/ - delay timer has expired (unless ignore_delay is true)\n+  static bool should_trim(bool ignore_delay);\n+\n+  \/\/ Execute trim-native in this thread\n+  static void execute_trim();\n+\n+  \/\/ Pause\/unpause periodic trim\n+  static void pause_periodic_trim();\n+  static void unpause_periodic_trim();\n+\n+  \/\/ Schedule an explicit trim now; if periodic trims had been\n+  \/\/ paused, they are unpaused.\n+  static void schedule_trim();\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -693,2 +693,14 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, GCTrimNativeHeap, false, EXPERIMENTAL,                      \\\n+          \"GC will attempt to trim the native heap periodically and at \"    \\\n+          \"full GCs.\")                                                      \\\n+                                                                            \\\n+  product(uint, GCTrimNativeHeapInterval, 60, EXPERIMENTAL,                 \\\n+          \"If GCTrimNativeHeap is enabled: interval time, in seconds, in \"  \\\n+          \"which the VM will attempt to trim the native heap. A value of \"  \\\n+          \"0 disables periodic trimming while leaving trimming at full gc \" \\\n+          \"enabled.\")                                                       \\\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+          \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -204,0 +205,2 @@\n+\n+  GCTrimNative::initialize(false); \/\/ false since we will call trim inside the collecting thread\n@@ -632,0 +635,5 @@\n+    \/\/ Trim the native heap, without a delay since this is a full gc\n+    if (GCTrimNative::should_trim(true)) {\n+      GCTrimNative::execute_trim();\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -48,0 +49,2 @@\n+#include \"utilities\/events.hpp\"\n+\n@@ -314,0 +317,8 @@\n+    if (GCTrimNative::should_trim(explicit_gc_requested)) {\n+      static const char *msg = \"Concurrent trim-native\";\n+      ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_trim, false);\n+      EventMark em(\"%s\", msg);\n+      GCTrimNative::execute_trim();\n+      heap->phase_timings()->flush_cycle_to_global();\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -628,0 +629,2 @@\n+\n+  GCTrimNative::initialize(false); \/\/ false since this is taken care of inside the service thread\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  f(conc_trim,                                      \"Concurrent Trim\")                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -77,0 +78,2 @@\n+  GCTrimNative::initialize(true);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -450,0 +451,2 @@\n+  pause_native_trim();\n+\n@@ -482,0 +485,18 @@\n+\n+  resume_native_trim(request.cause());\n+\n+}\n+\n+void ZDriver::pause_native_trim() {\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::pause_periodic_trim();\n+}\n+\n+void ZDriver::resume_native_trim(GCCause::Cause cause) {\n+  bool schedule_trim_now =\n+      cause == GCCause::_z_high_usage || GCCause::is_user_requested_gc(cause);\n+  if (schedule_trim_now) {\n+    GCTrimNative::schedule_trim();\n+  } else {\n+    GCTrimNative::unpause_periodic_trim();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+  void pause_native_trim();\n+  void resume_native_trim(GCCause::Cause cause);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  LOG_TAG(trim) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -453,0 +454,2 @@\n+  GCTrimNative::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -446,0 +446,3 @@\n+  \/\/ Does the platform recommend trimming?\n+  static bool should_trim_native_heap();\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,513 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * All these tests test the trim-native feature for all GCs.\n+ * Trim-native is the ability to trim the C-heap as part of the GC cycle.\n+ * This feature is controlled by -XX:+GCTrimNativeHeap (by default off).\n+ * Trimming happens on full gc for all gcs. Shenandoah and G1 also support\n+ * concurrent trimming (Shenandoah supports this without any ties to java\n+ * heap occupancy).\n+ *\n+ *\/\n+\n+\/\/\/\/ full gc tests \/\/\/\/\/\n+\n+\/*\n+ * @test id=fullgc-serial\n+ * @summary Test that GCTrimNativeHeap works with Serial\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc serial\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-parallel\n+ * @summary Test that GCTrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc parallel\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-shenandoah\n+ * @summary Test that GCTrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-g1\n+ * @summary Test that GCTrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc g1\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-z\n+ * @summary Test that GCTrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc z\n+ *\/\n+\n+\/\/\/\/ auto mode tests \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-parallel\n+ * @summary Test that GCTrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-shenandoah\n+ * @summary Test that GCTrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-g1\n+ * @summary Test that GCTrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-z\n+ * @summary Test that GCTrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto z\n+ *\/\n+\n+\/\/\/\/ test-auto-high-interval interval test \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-high-interval-parallel\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-g1\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-shenandoah\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-z\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval z\n+ *\/\n+\n+\/\/\/\/ test-auto-interval-0 test \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-zero-interval-parallel\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-g1\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-shenandoah\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-z\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval z\n+ *\/\n+\n+\/\/ Other tests\n+\n+\/*\n+ * @test id=off-explicit\n+ * @summary Test that -GCTrimNative disables the feature\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-explicit\n+ *\/\n+\n+\/*\n+ * @test id=off-by-default\n+ * @summary Test that GCTrimNative is off by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-by-default\n+ *\/\n+\n+\/*\n+ * @test id=off-on-other-platforms\n+ * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-on-other-platforms\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 4 MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int szAllocations = 16;\n+    static final int totalAllocationsSize = 16 * 1024 * 1024; \/\/ 16 MB total\n+    static final int numAllocations = totalAllocationsSize \/ szAllocations;\n+\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    enum GC {\n+        serial, parallel, g1, shenandoah, z;\n+        String getSwitchName() {\n+            String s = name();\n+            return \"-XX:+Use\" + s.substring(0, 1).toUpperCase() + s.substring(1) + \"GC\";\n+        }\n+        boolean isZ() { return this == GC.z; }\n+        boolean isSerial() { return this == GC.serial; }\n+        boolean isParallel() { return this == GC.parallel; }\n+        boolean isG1() { return this == GC.g1; }\n+        boolean isShenandoah() { return this == GC.shenandoah; }\n+    }\n+\n+    static private boolean usesNativeTrimmer(GC gc) {\n+        return gc.isG1() || gc.isParallel() || gc.isZ();\n+    }\n+\n+    static private final OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] testArgs) throws IOException {\n+\n+        List<String> allOptions = new ArrayList<String>();\n+        allOptions.add(\"-XX:+UnlockExperimentalVMOptions\");\n+        allOptions.addAll(Arrays.asList(extraOptions));\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-Xlog:gc+trim=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        allOptions.add(TestTrimNative.class.getName());\n+        allOptions.add(\"RUN\");\n+        allOptions.addAll(Arrays.asList(testArgs));\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(allOptions.toArray(new String[0]));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+\n+    }\n+\n+    \/**\n+     * Given JVM output, look for a log line that describes a successful negative trim in the megabyte range\n+     * like this:\n+     * \"[2.053s][debug][gc,trim] Trim native heap (retain size: 5120K): RSS+Swap: 271M->223M (-49112K), 2.834ms\"\n+     * (Note: we use the \"properXXX\" print routines, therefore units can differ)\n+     * Check that the sum of all trim log lines comes to a total RSS reduction in the MB range\n+     * @param output\n+     * @param minExpected min number of trim lines expected in UL log\n+     * @param maxExpected max number of trim lines expected in UL log\n+     *\/\n+    private final static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minExpected, int maxExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[gc,trim\\\\] Trim native heap.*RSS\\\\+Swap: (\\\\d+)([KMB])->(\\\\d+)([KMB]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                System.out.println(\"Parsed Trim Line. rss1: \" + rss1 + \" rss2: \" + rss2);\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxExpected) {\n+                throw new RuntimeException(\"Abnormal high number of trim attempts found (more than \" + maxExpected +\n+                                            \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minExpected) {\n+            throw new RuntimeException(\"We found fewer trim lines in UL log than expected (expected \" + minExpected +\n+                    \", found \" + numTrimsFound + \".\");\n+        }\n+        \/\/ This is very fuzzy. We malloced X, free'd X, trimmed, measured the combined effect of all reductions.\n+        \/\/ This does not take into effect mallocs or frees that may happen concurrently. But we expect to see *some*\n+        \/\/ reduction somewhere. Test with a fudge factor.\n+        float fudge = 0.8f;\n+        long expectedMinimalReduction = (long) (totalAllocationsSize * fudge);\n+        if (rssReductionTotal < expectedMinimalReduction) {\n+            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log. Expected (with fudge)\" +\n+                                       \" to see at least a combined reduction of \" + expectedMinimalReduction + \".\");\n+        }\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=1 causes a trim-native on full gc\n+    static private final void testWithFullGC(GC gc) throws IOException {\n+        System.out.println(\"testWithFullGC\");\n+        int sleeptime_secs = 2;\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, String.valueOf(sleeptime_secs * 1000) \/* ms after peak *\/ }\n+        );\n+        \/\/ With default interval time of 30 seconds, auto trimming should never kick in, so the only\n+        \/\/ log line we expect to see is the one from the full-gc induced trim.\n+        parseOutputAndLookForNegativeTrim(output, 1, 1);\n+        \/\/ For GCs that use the NativeTrimmer, we want to see the NativeTrimmer paused during the GC, as well as\n+        \/\/ started and shut down properly.\n+        if (usesNativeTrimmer(gc)) {\n+            output.shouldContain(\"NativeTrimmer started\");\n+            output.shouldContain(\"NativeTrimmer paused\");\n+            output.shouldContain(\"NativeTrimmer unpaused\");\n+            output.shouldContain(\"NativeTrimmer stopped\");\n+        } else {\n+            output.shouldNotContain(\"NativeTrimmer\");\n+        }\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=1 causes a trim-native automatically, without GC (for now, shenandoah only)\n+    static private final void testAuto(GC gc) throws IOException {\n+        System.out.println(\"testAuto\");\n+        long t1 = System.currentTimeMillis();\n+        int sleeptime_secs = 4;\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=1\" },\n+                new String[] { \"false\" \/* full gc *\/, String.valueOf(sleeptime_secs * 1000) \/* ms after peak *\/ }\n+        );\n+        long t2 = System.currentTimeMillis();\n+        int runtime_s = (int)((t2 - t1) \/ 1000);\n+        \/\/ With an interval time of 1 second and a runtime of 6..x seconds we expect to see x log lines (+- fudge factor).\n+        parseOutputAndLookForNegativeTrim(output, runtime_s - 4, runtime_s + 2);\n+    }\n+\n+    \/\/ Test that trim-native correctly honors interval\n+    static private final void testAutoWithHighInterval(GC gc) throws IOException {\n+        \/\/ We pass a very high interval. This should disable the feature for this short-lived test, we should see no trim\n+        System.out.println(\"testAutoWithHighInterval\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=30\" },\n+                new String[] { \"false\" \/* full gc *\/, \"6000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native correctly honors interval\n+    static private final void testAutoWithZeroInterval(GC gc) throws IOException {\n+        \/\/ We pass a very high interval. This should disable the feature for this short-lived test, we should see no trim\n+        System.out.println(\"testAutoWithHighInterval\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=0\" },\n+                new String[] { \"false\" \/* full gc *\/, \"6000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n+    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffOnNonCompliantPlatforms\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldContain(\"GCTrimNativeHeap disabled\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=0 switches trim-native off\n+    static private final void testOffExplicit() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffExplicit\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:-GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native is disabled by default\n+    static private final void testOffByDefault() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffByDefault\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        if (args[0].equals(\"RUN\")) {\n+            boolean doFullGC = Boolean.parseBoolean(args[1]);\n+\n+            System.out.println(\"Will spike now...\");\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n+                Unsafe.getUnsafe().putByte(ptrs[i], (byte)0);\n+                Unsafe.getUnsafe().putByte(ptrs[i] + szAllocations \/ 2, (byte)0);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            if (doFullGC) {\n+                System.out.println(\"GC...\");\n+                System.gc();\n+            }\n+\n+            \/\/ give GC time to react\n+            int time = Integer.parseInt(args[2]);\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(time);\n+            System.out.println(\"Done.\");\n+\n+            return;\n+\n+        } else if (args[0].equals(\"test-fullgc\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testWithFullGC(gc);\n+        } else if (args[0].equals(\"test-auto\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAuto(gc);\n+        } else if (args[0].equals(\"test-auto-high-interval\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAutoWithHighInterval(gc);\n+        } else if (args[0].equals(\"test-auto-zero-interval\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAutoWithZeroInterval(gc);\n+        } else if (args[0].equals(\"test-off-explicit\")) {\n+            testOffExplicit();\n+        } else if (args[0].equals(\"test-off-by-default\")) {\n+            testOffByDefault();\n+        } else if (args[0].equals(\"test-off-on-other-platforms\")) {\n+            testOffOnNonCompliantPlatforms();\n+        } else {\n+            throw new RuntimeException(\"Invalid test \" + args[0]);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestTrimNative.java","additions":513,"deletions":0,"binary":false,"changes":513,"status":"added"}]}