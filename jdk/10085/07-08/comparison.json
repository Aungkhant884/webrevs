{"files":[{"patch":"@@ -57,1 +57,0 @@\n-inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5418,29 +5418,0 @@\n-\n-static const size_t retain_size = 2 * M;\n-\n-bool os::should_trim_native_heap() {\n-#ifdef __GLIBC__\n-  bool rc = true;\n-  \/\/ We try, using mallinfo, to predict whether a malloc_trim(3) will be beneficial.\n-  \/\/\n-  \/\/ \"mallinfo::keepcost\" is no help even if manpage claims this to be the projected\n-  \/\/ trim size. In practice it is just a very small value with no relation to the actual\n-  \/\/ effect trimming will have.\n-  \/\/\n-  \/\/ Our best bet is \"mallinfo::fordblks\", the total chunk size of free blocks. Since\n-  \/\/ only free blocks can be trimmed, a very low bar is to require their combined size\n-  \/\/ to be higher than our retain size. Note, however, that \"mallinfo::fordblks\" includes\n-  \/\/ already-trimmed blocks, since glibc trims by calling madvice(MADV_DONT_NEED) on free\n-  \/\/ chunks but does not update its bookkeeping.\n-  \/\/\n-  \/\/ In the end we want to prevent obvious bogus attempts to trim, and for that fordblks\n-  \/\/ is good enough.\n-  os::Linux::glibc_mallinfo mi;\n-  bool possibly_wrapped;\n-  os::Linux::get_mallinfo(&mi, &possibly_wrapped);\n-  \/\/ If we cannot say for sure because we use an older glibc, assume trimming makes sense.\n-  return possibly_wrapped ? true : retain_size < mi.fordblks;\n-#else\n-  return false; \/\/ musl\n-#endif\n-}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-inline bool os::should_trim_native_heap() { return false; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.inline.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,1 +85,0 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -96,0 +95,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1080,2 +1080,0 @@\n-  GCTrimNative::PauseThenTrimMark trim_pause_mark;\n-\n@@ -1756,1 +1754,1 @@\n-  GCTrimNative::initialize();\n+  TrimNative::initialize();\n@@ -2793,0 +2791,1 @@\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1232,0 +1233,2 @@\n+  TrimNative::PauseMark trim_native_pause;\n+\n@@ -1448,0 +1451,2 @@\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n","filename":"src\/hotspot\/share\/gc\/g1\/g1VMOperations.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -195,1 +195,1 @@\n-  GCTrimNative::initialize();\n+  TrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,1 +52,1 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -1715,1 +1715,1 @@\n-  GCTrimNative::PauseThenTrimMark trim_native_pause;\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,444 +0,0 @@\n-\/*\n- * Copyright (c) 2023 SAP SE. All rights reserved.\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questioSns.\n- *\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/shared\/concurrentGCThread.hpp\"\n-#include \"gc\/shared\/gc_globals.hpp\"\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"runtime\/atomic.hpp\"\n-#include \"runtime\/globals_extension.hpp\"\n-#include \"runtime\/mutex.hpp\"\n-#include \"runtime\/mutexLocker.hpp\"\n-#include \"runtime\/os.inline.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/ticks.hpp\"\n-\n-\/\/ A class holding trim results for a single trim operation.\n-class TrimResult {\n-\n-  \/\/ time (ms) trim happened (javaTimeMillis)\n-  int64_t _time;\n-  \/\/ time (ms) trim itself took.\n-  int64_t _duration;\n-  \/\/ rss\n-  size_t _rss_before, _rss_after;\n-\n-public:\n-\n-  TrimResult() : _time(-1), _duration(0), _rss_before(0), _rss_after(0) {}\n-\n-  TrimResult(int64_t t, int64_t d, size_t rss1, size_t rss2) :\n-    _time(t), _duration(d), _rss_before(rss1), _rss_after(rss2)\n-  {}\n-\n-  int64_t time() const { return _time; }\n-  int64_t duration() const { return _duration; }\n-  size_t rss_before() const { return _rss_before; }\n-  size_t rss_after() const { return _rss_before; }\n-\n-  bool is_valid() const {\n-    return _time >= 0 && _duration >= 0 &&\n-        _rss_before != 0 && _rss_after != 0;\n-  }\n-\n-  \/\/ Returns size reduction; positive if memory was reduced\n-  ssize_t size_reduction() const {\n-    return checked_cast<ssize_t>(_rss_before) -\n-           checked_cast<ssize_t>(_rss_after);\n-  }\n-\n-  void print_on(outputStream* st) const {\n-    st->print(\"time: \" INT64_FORMAT \", duration \" INT64_FORMAT\n-              \", rss1: \" SIZE_FORMAT \", rss2: \" SIZE_FORMAT \" (\" SSIZE_FORMAT \")\",\n-              _time, _duration, _rss_before, _rss_after, size_reduction());\n-  }\n-};\n-\n-\/\/ A FIFO of the last n trim results\n-class TrimHistory {\n-  static const int _max = 4;\n-\n-  \/\/ Note: history may contain invalid results; for one, it is\n-  \/\/ initialized with invalid results to keep iterating simple;\n-  \/\/ also invalid results can happen if measuring rss goes wrong.\n-  TrimResult _histo[_max];\n-  int _pos; \/\/ position of next write\n-\n-public:\n-\n-  TrimHistory() : _pos(0) {}\n-\n-  void add(const TrimResult& result) {\n-    _histo[_pos] = result;\n-    if (++_pos == _max) {\n-      _pos = 0;\n-    }\n-  }\n-\n-  template <class Functor>\n-  void iterate_oldest_to_youngest(Functor f) const {\n-    int idx = _pos;\n-    do {\n-      f(_histo + idx);\n-      if (++idx == _max) {\n-        idx = 0;\n-      }\n-    } while (idx != _pos);\n-  }\n-\n-};\n-\n-class NativeTrimmer : public ConcurrentGCThread {\n-\n-  Monitor* _lock;\n-\n-  \/\/ Periodic trimming state\n-  const int64_t _interval_ms;\n-  const int64_t _max_interval_ms;\n-  const bool _periodic_trim_enabled;\n-\n-  int64_t _next_trim_time;\n-  int64_t _next_trim_time_saved; \/\/ for pause\n-\n-  TrimHistory _trim_history;\n-\n-  static const int64_t never = INT64_MAX;\n-\n-  static int64_t now() { return os::javaTimeMillis(); }\n-\n-  void run_service() override {\n-\n-    assert(GCTrimNativeHeap, \"Sanity\");\n-    assert(os::can_trim_native_heap(), \"Sanity\");\n-\n-    log_info(gc, trim)(\"NativeTrimmer start.\");\n-\n-    int64_t ntt = 0;\n-    int64_t tnow = 0;\n-\n-    for (;;) {\n-      \/\/ 1 - Wait for the next trim point\n-      {\n-        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-        do {\n-          tnow = now();\n-          ntt = _next_trim_time;\n-          if (ntt == never) {\n-            ml.wait(0); \/\/ infinite sleep\n-          } else if (ntt > tnow) {\n-            ml.wait(ntt - tnow); \/\/ sleep till next point\n-          }\n-          if (should_terminate()) {\n-            log_info(gc, trim)(\"NativeTrimmer stop.\");\n-            return;\n-          }\n-          tnow = now();\n-          ntt = _next_trim_time;\n-        } while (ntt > tnow);\n-      }\n-\n-      \/\/ 2 - Trim\n-      TrimResult result = execute_trim_and_log();\n-\n-      \/\/ 3 - Update next trim time\n-      \/\/ Note: outside setters have preference -  if we paused\/unpaused\/scheduled trim concurrently while the last trim\n-      \/\/ was in progress, we do that. Note that if this causes two back-to-back trims, that is harmless since usually\n-      \/\/ the second trim is cheap.\n-      {\n-        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-        tnow = now();\n-        int64_t ntt2 = _next_trim_time;\n-        if (ntt2 == ntt) { \/\/ not changed concurrently?\n-          if (_periodic_trim_enabled) {\n-            \/\/ Feed trim data into history and examine history.\n-            \/\/ do that.\n-            _trim_history.add(result);\n-            if (recommend_pause()) {\n-              log_debug(gc, trim)(\"NativeTrimmer: long pause (\" INT64_FORMAT \" ms)\", _max_interval_ms);\n-              _next_trim_time = tnow + _max_interval_ms;\n-            } else {\n-              _next_trim_time = tnow + _interval_ms;\n-            }\n-          } else {\n-            \/\/ periodic trim disabled\n-            _next_trim_time = never;\n-          }\n-        }\n-      } \/\/ Mutex scope\n-    }\n-  }\n-\n-  void stop_service() override {\n-    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-    ml.notify_all();\n-  }\n-\n-  \/\/ Execute the native trim, log results.\n-  \/\/ Return true if trim succeeded *and* we have valid size change data.\n-  TrimResult execute_trim_and_log() {\n-    assert(os::can_trim_native_heap(), \"Unexpected\");\n-    if (!os::should_trim_native_heap()) {\n-      log_trace(gc, trim)(\"Trim native heap: not necessary\");\n-      return TrimResult();\n-    }\n-    const int64_t tnow = now();\n-    os::size_change_t sc;\n-    Ticks start = Ticks::now();\n-    if (os::trim_native_heap(&sc)) {\n-      Tickspan trim_time = (Ticks::now() - start);\n-      if (sc.after != SIZE_MAX) {\n-        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n-        const char sign = sc.after < sc.before ? '-' : '+';\n-        log_info(gc, trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n-                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n-                           trim_time.seconds() * 1000);\n-        return TrimResult(tnow, now() - tnow, sc.before, sc.after);\n-      } else {\n-        log_info(gc, trim)(\"Trim native heap (no details)\");\n-      }\n-    }\n-    return TrimResult();\n-  }\n-\n-  \/\/\/\/\/\/ Heuristics \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n-  \/\/ Small heuristic to check if periodic trimming has been fruitful so far.\n-  \/\/ If this heuristic finds trimming to be harmful, we will inject one longer\n-  \/\/ trim interval (GCTrimNativeIntervalMax).\n-  \/\/\n-  \/\/ Trimming costs are the trim itself plus the re-aquisition costs of memory should the\n-  \/\/ released memory be malloced again. Trimming gains are the memory reduction over time.\n-  \/\/ Lasting gains are good; gains that don't last are not.\n-  \/\/\n-  \/\/ There are roughly three usage pattern:\n-  \/\/ - rare malloc spikes interspersed with long idle periods. Trimming is beneficial\n-  \/\/   since the relieved memory pressure holds for a long time.\n-  \/\/ - a constant low-intensity malloc drone. Trimming does not help much here but its\n-  \/\/   harmless too since trimming is cheap if it does not recover much.\n-  \/\/ - frequent malloc spikes with short idle periods; trimmed memory will be re-aquired\n-  \/\/   after only a short relief; here, trimming could be harmful since we pay a lot for\n-  \/\/   not much relief. We want to alleviate these scenarios.\n-  \/\/\n-  \/\/ Putting numbers on these things is difficult though. We cannot observe malloc\n-  \/\/ load directly, only RSS. For every trim we know the RSS reduction (from, to). So\n-  \/\/ for subsequent trims we also can glean from (<next sample>.from) whether RSS bounced\n-  \/\/ back. But that is quite vague since RSS may have been influenced by a ton of other\n-  \/\/ developments, especially for longer trim intervals.\n-  \/\/\n-  \/\/ Therefore this heuristic may produce false positives and negatives. We try to err on\n-  \/\/ the side of too much trimming here and to identify only situations that are clearly\n-  \/\/ harmful. Note that the GCTrimNativeIntervalMax default (4 * GCTrimNativeInterval)\n-  \/\/ is gentle enough for wrong heuristic results to not be too punative.\n-\n-  \/\/ Given two results of subsequent trims, return the lasting gain of the\n-  \/\/ first trim, in bytes. Negative numbers mean a loss.\n-  static ssize_t calc_lasting_gain(const TrimResult& s1, const TrimResult& s2) {\n-    ssize_t gain = s1.size_reduction();\n-    ssize_t loss = checked_cast<ssize_t>(s2.rss_before()) -\n-                   checked_cast<ssize_t>(s1.rss_after());\n-    return gain - loss;\n-  }\n-\n-  \/\/ Given two results of subsequent trims, return the interval time\n-  \/\/ between them. This includes the trim time itself.\n-  static int64_t interval_time(const TrimResult& s1, const TrimResult& s2) {\n-    return s2.time() - s1.time();\n-  }\n-\n-  \/\/ Given two results of subsequent trims, returns true if the first trim is considered\n-  \/\/ \"bad\" - a trim that had been not worth the cost.\n-  static bool is_bad_trim(const TrimResult& s1, const TrimResult& s2) {\n-    assert(s1.is_valid() && s2.is_valid(), \"Sanity\");\n-    const int64_t tinterval = interval_time(s1, s2);\n-    assert(tinterval >= 0, \"negative interval? \" INT64_FORMAT, tinterval);\n-    if (tinterval <= 0) {\n-      return false;\n-    }\n-    assert(tinterval >= s1.duration(), \"trim duration cannot be larger than trim interval (\"\n-           INT64_FORMAT \", \" INT64_FORMAT \")\", tinterval, s1.duration());\n-\n-    \/\/ Cost: ratio of trim time to total interval time (which contains trim time)\n-    const double ratio_trim_time_to_interval_time =\n-        (double)s1.duration() \/ (double)tinterval;\n-    assert(ratio_trim_time_to_interval_time >= 0, \"Sanity\");\n-\n-    \/\/ Any ratio of less than 1% trim time to interval time we regard as harmless\n-    \/\/ (e.g. less than 10ms for 1second of interval)\n-    if (ratio_trim_time_to_interval_time < 0.01) {\n-      return false;\n-    }\n-\n-    \/\/ Benefit: Ratio of lasting size reduction to RSS before the first trim.\n-    const double rss_gain_ratio = (double)calc_lasting_gain(s1, s2) \/ s1.rss_before();\n-\n-    \/\/ We consider paying 1% (or more) time-per-interval for\n-    \/\/ 1% (or less, maybe even negative) rss size reduction as bad.\n-    bool bad = ratio_trim_time_to_interval_time > rss_gain_ratio;\n-\n-tty->print_cr(\"%s\", bad ? \"BAD\" : \"\");\n-\n-    return false;\n-  }\n-\n-  bool recommend_pause() {\n-    struct { int trims, bad, ignored; } counts = { 0, 0, 0 };\n-    const TrimResult* previous = nullptr;\n-    auto trim_evaluater = [&counts, &previous] (const TrimResult* r) {\n-\n-tty->print(\"??  \");\n-r->print_on(tty);\n-\n-      if (!r->is_valid() || previous == nullptr || !previous->is_valid()) {\n-        \/\/ Note: we always ignore the very youngest trim, since we don't know the\n-        \/\/ RSS bounce back to the next trim yet.\n-        counts.ignored++;\n-      } else {\n-        counts.trims++;\n-        if (is_bad_trim(*previous, *r)) {\n-          counts.bad++;\n-        }\n-      }\n-\n-tty->cr();\n-      previous = r;\n-    };\n-    _trim_history.iterate_oldest_to_youngest(trim_evaluater);\n-    log_trace(gc, trim)(\"Heuristics: trims: %d, bad trims: %d, ignored: %d\",\n-                        counts.trims, counts.bad, counts.ignored);\n-    return counts.ignored <= 1 && counts.bad == counts.trims;\n-  }\n-\n-public:\n-\n-  NativeTrimmer() :\n-    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n-    _interval_ms(GCTrimNativeHeapInterval * 1000),\n-    _max_interval_ms(GCTrimNativeHeapIntervalMax * 1000),\n-    _periodic_trim_enabled(GCTrimNativeHeapInterval > 0),\n-    _next_trim_time(0),\n-    _next_trim_time_saved(0)\n-  {\n-    set_name(\"Native Heap Trimmer\");\n-    _next_trim_time = _periodic_trim_enabled ? (now() + _interval_ms) : never;\n-    create_and_start();\n-  }\n-\n-  void pause() {\n-    if (!_periodic_trim_enabled) {\n-      return;\n-    }\n-    {\n-      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-      _next_trim_time_saved = _next_trim_time;\n-      _next_trim_time = never;\n-      ml.notify_all();\n-    }\n-    log_debug(gc, trim)(\"NativeTrimmer pause\");\n-  }\n-\n-  void unpause() {\n-    if (!_periodic_trim_enabled) {\n-      return;\n-    }\n-    {\n-      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-      _next_trim_time = _next_trim_time_saved;\n-      ml.notify_all();\n-    }\n-    log_debug(gc, trim)(\"NativeTrimmer unpause\");\n-  }\n-\n-  void schedule_trim() {\n-    {\n-      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n-      _next_trim_time = 0;\n-      ml.notify_all();\n-    }\n-    if (_periodic_trim_enabled) {\n-      log_debug(gc, trim)(\"NativeTrimmer unpause+trim\");\n-    } else {\n-      log_debug(gc, trim)(\"NativeTrimmer trim\");\n-    }\n-  }\n-\n-}; \/\/ NativeTrimmer\n-\n-static NativeTrimmer* g_trimmer_thread = nullptr;\n-\n-\/\/\/ GCTrimNative outside facing methods\n-\n-void GCTrimNative::initialize() {\n-\n-  if (GCTrimNativeHeap) {\n-\n-    if (!os::can_trim_native_heap()) {\n-      FLAG_SET_ERGO(GCTrimNativeHeap, false);\n-      log_info(gc, trim)(\"GCTrimNativeHeap disabled - trim-native not supported on this platform.\");\n-      return;\n-    }\n-\n-    log_info(gc, trim)(\"Native trim enabled.\");\n-\n-    if (GCTrimNativeHeapInterval > 0) { \/\/ periodic trimming enabled\n-      assert(GCTrimNativeHeapIntervalMax == 0 ||\n-             GCTrimNativeHeapIntervalMax > GCTrimNativeHeapInterval, \"Sanity\"); \/\/ see flag constraint\n-      if (GCTrimNativeHeapIntervalMax == 0) { \/\/ default\n-       FLAG_SET_ERGO(GCTrimNativeHeapIntervalMax, GCTrimNativeHeapInterval * 4);\n-      }\n-      log_info(gc, trim)(\"Periodic native trim enabled (interval: %u seconds, step-down-interval: %u seconds).\",\n-                          GCTrimNativeHeapInterval, GCTrimNativeHeapIntervalMax);\n-    } else {\n-      log_info(gc, trim)(\"Periodic native trim disabled (we trim at full gc only).\");\n-    }\n-\n-    g_trimmer_thread = new NativeTrimmer();\n-  }\n-}\n-\n-void GCTrimNative::cleanup() {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->stop();\n-  }\n-}\n-\n-void GCTrimNative::pause_periodic_trim() {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->pause();\n-  }\n-}\n-\n-void GCTrimNative::unpause_periodic_trim() {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->unpause();\n-  }\n-}\n-\n-void GCTrimNative::schedule_trim() {\n-  if (g_trimmer_thread != nullptr) {\n-    g_trimmer_thread->schedule_trim();\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.cpp","additions":0,"deletions":444,"binary":false,"changes":444,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2022 SAP SE. All rights reserved.\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n-#define SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n-\n-#include \"memory\/allStatic.hpp\"\n-\n-class GCTrimNative : public AllStatic {\n-public:\n-\n-  static void initialize();\n-  static void cleanup();\n-\n-  \/\/ Pause\/unpause periodic trim\n-  static void pause_periodic_trim();\n-  static void unpause_periodic_trim();\n-\n-  \/\/ Schedule an explicit trim now. If periodic trims are enabled and have been paused,\n-  \/\/ they are unpaused.\n-  static void schedule_trim();\n-\n-  struct PauseMark {\n-    PauseMark()   { GCTrimNative::pause_periodic_trim(); }\n-    ~PauseMark()  { GCTrimNative::unpause_periodic_trim(); }\n-  };\n-\n-  struct PauseThenTrimMark {\n-    PauseThenTrimMark()   { GCTrimNative::pause_periodic_trim(); }\n-    ~PauseThenTrimMark()  { GCTrimNative::schedule_trim(); }\n-  };\n-\n-};\n-\n-#endif \/\/ SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.hpp","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -695,1 +695,1 @@\n-  product(bool, GCTrimNativeHeap, false, EXPERIMENTAL,                      \\\n+  product(bool, TrimNativeHeap, false, EXPERIMENTAL,                        \\\n@@ -697,9 +697,9 @@\n-          \"after full GCs.\")                                                \\\n-                                                                            \\\n-  product(uint, GCTrimNativeHeapInterval, 30, EXPERIMENTAL,                 \\\n-          \"If GCTrimNativeHeap is enabled: interval, in seconds, in which \" \\\n-          \"the VM will attempt to trim the native heap. This is a lower \"   \\\n-          \"bound; the JVM may increase the interval time up to \"            \\\n-          \"GCTrimNativeHeapIntervalMax.\"                                    \\\n-          \"A value of 0 disables periodic trimming altogether while \"       \\\n-          \"leaving trimming after full gc enabled.\")                        \\\n+          \"at the end of a GC cycle.\")                                      \\\n+                                                                            \\\n+  product(uint, TrimNativeHeapInterval, 5, EXPERIMENTAL,                    \\\n+          \"If TrimNativeHeap is enabled: interval, in seconds, in which \"   \\\n+          \"the GC will attempt to trim the native heap. If \"                \\\n+          \"TrimNativeHeapAdaptiveStepDown is enabled, the JVM may lower \"   \\\n+          \"the frequency of trimming.\"                                      \\\n+          \"A value of 0 disables periodic trimming altogether while still \" \\\n+          \"trimming after a GC cycle.\")                                     \\\n@@ -708,6 +708,3 @@\n-  product(uint, GCTrimNativeHeapIntervalMax, 0, EXPERIMENTAL,               \\\n-          \"If GCTrimNativeHeap is enabled and GCTrimNativeHeapInterval is \" \\\n-          \"not 0: upper bound for the interval time, in seconds, in which \" \\\n-          \"the VM will attempt to trim the native heap.\")                   \\\n-          range(0, max_juint)                                               \\\n-          constraint(GCTrimNativeHeapIntervalMaxFunc,AtParse)               \\\n+  product(bool, TrimNativeHeapAdaptiveStepDown, false, EXPERIMENTAL,        \\\n+          \"If TrimNativeHeap and periodic trimming are enabled: if true, \"  \\\n+          \"the GC may step down trimming frequency if needed. \")            \\\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -206,1 +206,1 @@\n-  GCTrimNative::initialize();\n+  TrimNative::initialize();\n@@ -512,1 +512,1 @@\n-  GCTrimNative::PauseThenTrimMark trim_native_pause;\n+  TrimNative::PauseThenTrimMark trim_native_pause;\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -439,11 +439,0 @@\n-JVMFlag::Error GCTrimNativeHeapIntervalMaxFunc(uint value, bool verbose) {\n-  if (GCTrimNativeHeap && value < GCTrimNativeHeapInterval) {\n-    JVMFlag::printError(verbose,\n-                        \"GCTrimNativeHeapIntervalMax ( %u ) must be \"\n-                        \"greater than or equal to GCTrimNativeHeapInterval ( %u )\\n\",\n-                        value, GCTrimNativeHeapInterval);\n-    return JVMFlag::VIOLATES_CONSTRAINT;\n-  } else {\n-    return JVMFlag::SUCCESS;\n-  }\n-}\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,2 +70,1 @@\n- f(uint, GCCardSizeInBytesConstraintFunc)                      \\\n- f(uint, GCTrimNativeHeapIntervalMaxFunc)\n+ f(uint, GCCardSizeInBytesConstraintFunc)\n","filename":"src\/hotspot\/share\/gc\/shared\/jvmFlagConstraintsGC.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questioSns.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n+#include \"gc\/shared\/trimNativeStepDown.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.inline.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+class NativeTrimmerThread : public ConcurrentGCThread {\n+\n+  Monitor* _lock;\n+\n+  \/\/ Periodic trimming state\n+  const int64_t _interval_ms;\n+  const bool _periodic_trim_enabled;\n+  const bool _adaptive_stepdown_enabled;\n+\n+  int64_t _next_trim_time;\n+  int64_t _next_trim_time_saved; \/\/ for pause\n+\n+  \/\/ Adaptive step-down\n+  TrimNativeStepDownControl _stepdown_control;\n+  static const int _min_stepdown_factor = 2; \/\/ 2 * interval length\n+  static const int _max_stepdown_factor = 8; \/\/ 8 * interval length\n+  static const int64_t _stepdown_factor_reset_after = 60 * 1000;\n+  int64_t _last_stepdown_time;\n+  int _last_stepdown_factor;\n+\n+  void update_stepdown_factor(int64_t tnow) {\n+    if (tnow > (_last_stepdown_time + _stepdown_factor_reset_after)) {\n+      _last_stepdown_factor = _min_stepdown_factor;\n+    } else {\n+      _last_stepdown_factor = MIN2(_last_stepdown_factor + 1, _max_stepdown_factor);\n+    }\n+  }\n+\n+  static const int64_t never = INT64_MAX;\n+\n+  static int64_t now() { return os::javaTimeMillis(); }\n+\n+  void run_service() override {\n+\n+    log_info(gc, trim)(\"NativeTrimmer start.\");\n+\n+    int64_t ntt = 0;\n+    int64_t tnow = 0;\n+\n+    for (;;) {\n+      \/\/ 1 - Wait for _next_trim_time. Handle spurious wakeups and shutdown.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        do {\n+          tnow = now();\n+          ntt = _next_trim_time;\n+          if (ntt == never) {\n+            ml.wait(0); \/\/ infinite sleep\n+          } else if (ntt > tnow) {\n+            ml.wait(ntt - tnow); \/\/ sleep till next point\n+          }\n+          if (should_terminate()) {\n+            log_info(gc, trim)(\"NativeTrimmer stop.\");\n+            return;\n+          }\n+          tnow = now();\n+          ntt = _next_trim_time;\n+        } while (ntt > tnow);\n+      }\n+\n+      \/\/ 2 - Trimming happens outside of lock protection. GC threads can issue new commands\n+      \/\/     concurrently.\n+      TrimResult result = execute_trim_and_log();\n+\n+      \/\/ 3 - Update _next_trim_time; but give concurrent setters preference.\n+      {\n+        MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+        tnow = now();\n+        int64_t ntt2 = _next_trim_time;\n+\n+        if (ntt2 == ntt) { \/\/ not changed concurrently?\n+\n+          if (_periodic_trim_enabled) {\n+            int64_t interval_length = _interval_ms;\n+\n+            \/\/ Handle adaptive stepdown. If heuristic recommends step-down, we prolong the\n+            \/\/ wait interval by a factor that gets progressively larger with subsequent step-downs.\n+            \/\/ Factor is capped and gets reset after a while.\n+            if (_adaptive_stepdown_enabled) {\n+              _stepdown_control.feed(result);\n+\n+              if (_stepdown_control.recommend_step_down()) {\n+                _last_stepdown_factor =\n+                    \/\/ increase or reset step-down factor depending on how many step-downs we had and\n+                    \/\/ how long they are ago.\n+                    (tnow > (_last_stepdown_time + _stepdown_factor_reset_after)) ?\n+                    _min_stepdown_factor :\n+                    MIN2(_last_stepdown_factor + 1, _max_stepdown_factor);\n+\n+                _last_stepdown_time = tnow;\n+                interval_length = _interval_ms * _last_stepdown_factor;\n+                log_debug(gc, trim)(\"NativeTrimmer: long pause (\" INT64_FORMAT \" ms)\", interval_length);\n+              }\n+            }\n+            _next_trim_time = tnow + interval_length;\n+\n+          } else {\n+            \/\/ periodic trim disabled\n+            _next_trim_time = never;\n+          }\n+        }\n+      } \/\/ Mutex scope\n+    }\n+  }\n+\n+  void stop_service() override {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+\n+  \/\/ Execute the native trim, log results.\n+  \/\/ Return true if trim succeeded *and* we have valid size change data.\n+  TrimResult execute_trim_and_log() const {\n+    assert(os::can_trim_native_heap(), \"Unexpected\");\n+    const int64_t tnow = now();\n+    os::size_change_t sc;\n+    Ticks start = Ticks::now();\n+    log_debug(gc, trim)(\"Trim native heap started...\");\n+    if (os::trim_native_heap(&sc)) {\n+      Tickspan trim_time = (Ticks::now() - start);\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        log_info(gc, trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                           PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                           trim_time.seconds() * 1000);\n+        return TrimResult(tnow, now() - tnow, sc.before, sc.after);\n+      } else {\n+        log_info(gc, trim)(\"Trim native heap (no details)\");\n+      }\n+    }\n+    return TrimResult();\n+  }\n+\n+public:\n+\n+  NativeTrimmerThread() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _interval_ms(TrimNativeHeapInterval * 1000),\n+    _periodic_trim_enabled(TrimNativeHeapInterval > 0),\n+    _adaptive_stepdown_enabled(TrimNativeHeapAdaptiveStepDown),\n+    _next_trim_time(0),\n+    _next_trim_time_saved(0),\n+    _last_stepdown_time(0),\n+    _last_stepdown_factor(_min_stepdown_factor)\n+  {\n+    set_name(\"Native Heap Trimmer\");\n+    _next_trim_time = _periodic_trim_enabled ? (now() + _interval_ms) : never;\n+    create_and_start();\n+  }\n+\n+  void pause() {\n+    if (!_periodic_trim_enabled) {\n+      return;\n+    }\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time_saved = _next_trim_time;\n+      _next_trim_time = never;\n+      ml.notify_all();\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer pause\");\n+  }\n+\n+  void unpause() {\n+    if (!_periodic_trim_enabled) {\n+      return;\n+    }\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time = _next_trim_time_saved;\n+      ml.notify_all();\n+    }\n+    log_debug(gc, trim)(\"NativeTrimmer unpause\");\n+  }\n+\n+  void unpause_and_trim() {\n+    {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      _next_trim_time = 0;\n+      ml.notify_all();\n+    }\n+    if (_periodic_trim_enabled) {\n+      log_debug(gc, trim)(\"NativeTrimmer unpause+trim\");\n+    } else {\n+      log_debug(gc, trim)(\"NativeTrimmer trim\");\n+    }\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+static NativeTrimmerThread* g_trimmer_thread = nullptr;\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void TrimNative::initialize() {\n+  if (TrimNativeHeap) {\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(TrimNativeHeap, false);\n+      log_info(gc, trim)(\"Native trim not supported on this platform.\");\n+      return;\n+    }\n+\n+    log_info(gc, trim)(\"Native trim enabled.\");\n+\n+    if (TrimNativeHeapInterval == 0) {\n+      if (TrimNativeHeapAdaptiveStepDown) {\n+        FLAG_SET_ERGO(TrimNativeHeapAdaptiveStepDown, false);\n+      }\n+      log_info(gc, trim)(\"Periodic trimming disabled.\");\n+    } else {\n+      log_info(gc, trim)(\"Periodic native trim enabled (interval: %u seconds, dynamic step-down %s\",\n+                         TrimNativeHeapInterval, (TrimNativeHeapAdaptiveStepDown ? \"enabled\" : \"disabled\"));\n+    }\n+    g_trimmer_thread = new NativeTrimmerThread();\n+  }\n+}\n+\n+void TrimNative::cleanup() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->stop();\n+  }\n+}\n+\n+void TrimNative::pause_periodic_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->pause();\n+  }\n+}\n+\n+void TrimNative::unpause_periodic_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->unpause();\n+  }\n+}\n+\n+void TrimNative::schedule_trim() {\n+  if (g_trimmer_thread != nullptr) {\n+    g_trimmer_thread->unpause_and_trim();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNative.cpp","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_TRIMNATIVE_HPP\n+#define SHARE_GC_SHARED_TRIMNATIVE_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class TrimNative : public AllStatic {\n+public:\n+\n+  static void initialize();\n+  static void cleanup();\n+\n+  \/\/ Pause periodic trim (if enabled).\n+  static void pause_periodic_trim();\n+\n+  \/\/ Unpause periodic trim (if enabled).\n+  static void unpause_periodic_trim();\n+\n+  \/\/ Schedule an explicit trim now.\n+  \/\/ If periodic trims are enabled and had been paused, they are unpaused\n+  \/\/ and the interval is reset.\n+  static void schedule_trim();\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ resume periodic trimming.\n+  struct PauseMark {\n+    PauseMark()   { pause_periodic_trim(); }\n+    ~PauseMark()  { unpause_periodic_trim(); }\n+  };\n+\n+  \/\/ Pause periodic trimming while in scope; when leaving scope,\n+  \/\/ trim immediately and resume periodic trimming with a new interval.\n+  struct PauseThenTrimMark {\n+    PauseThenTrimMark()   { pause_periodic_trim(); }\n+    ~PauseThenTrimMark()  { schedule_trim(); }\n+  };\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_TRIMNATIVE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNative.hpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questioSns.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/trimNativeStepDown.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void TrimResult::print_on(outputStream* st) const {\n+  st->print(\"time: \" INT64_FORMAT \", duration \" INT64_FORMAT\n+            \", rss1: \" SIZE_FORMAT \", rss2: \" SIZE_FORMAT \" (\" SSIZE_FORMAT \")\",\n+            _time, _duration, _rss_before, _rss_after, size_reduction());\n+}\n+\n+\/\/ Given two results of subsequent trims, returns true if the first trim is considered\n+\/\/ \"bad\" - a trim that had been not worth the cost.\n+bool TrimNativeStepDownControl::is_bad_trim(const TrimResult& r, const TrimResult& r_followup) {\n+  assert(r.is_valid() && r_followup.is_valid(), \"Sanity\");\n+\n+  const int64_t tinterval = r.interval_time(r_followup);\n+  assert(tinterval >= 0, \"negative interval? \" INT64_FORMAT, tinterval);\n+  if (tinterval == 0) {\n+    return false;\n+  }\n+  assert(tinterval >= r.duration(), \"trim duration cannot be larger than trim interval (\"\n+         INT64_FORMAT \", \" INT64_FORMAT \")\", tinterval, r.duration());\n+\n+  \/\/ Cost: ratio of trim time to total interval time (which contains trim time)\n+  const double ratio_trim_time_to_interval_time =\n+      (double)r.duration() \/ (double)tinterval;\n+  assert(ratio_trim_time_to_interval_time >= 0, \"Sanity\");\n+\n+  \/\/ Any ratio of less than 1% trim time to interval time we regard as harmless\n+  \/\/ (e.g. less than 10ms for 1second of interval)\n+  if (ratio_trim_time_to_interval_time < 0.01) {\n+    return false;\n+  }\n+\n+  \/\/ Benefit: Ratio of lasting size reduction to RSS before the first trim.\n+  const double rss_gain_ratio = (double)r.calc_lasting_gain(r_followup) \/ (double)r.rss_before();\n+\n+  \/\/ We consider paying 1% (or more) time-per-interval for\n+  \/\/ 1% (or less, maybe even negative) rss size reduction as bad.\n+  bool bad = ratio_trim_time_to_interval_time > rss_gain_ratio;\n+\n+  return false;\n+}\n+\n+bool TrimNativeStepDownControl::recommend_step_down() const {\n+  struct { int trims, bad, ignored; } counts = { 0, 0, 0 };\n+\n+  const TrimResult* previous = nullptr;\n+  auto trim_evaluater = [&counts, &previous] (const TrimResult* r) {\n+tty->print(\"??  \");\n+r->print_on(tty);\n+    if (!r->is_valid() || previous == nullptr || !previous->is_valid()) {\n+      \/\/ Note: we ignore:\n+      \/\/ - the very youngest trim, since we don't know the\n+      \/\/   RSS bounce back to the next trim yet.\n+      \/\/ - invalid trim results\n+      counts.ignored++;\n+    } else {\n+      counts.trims++;\n+      if (is_bad_trim(*previous, *r)) {\n+        counts.bad++;\n+      }\n+    }\n+tty->cr();\n+    previous = r;\n+  };\n+  _history.iterate_oldest_to_youngest(trim_evaluater);\n+\n+  log_trace(gc, trim)(\"Heuristic says: trims: %d, bad trims: %d, ignored: %d\",\n+                      counts.trims, counts.bad, counts.ignored);\n+\n+  \/\/ If all trims in the history had been bad (excluding the youngest, for which we cannot\n+  \/\/ evaluate the lasting gains yet), step down.\n+  return counts.ignored <= 1 && counts.bad == counts.trims;\n+}\n+\n+void TrimNativeStepDownControl::feed(const TrimResult& r) {\n+  _history.add(r);\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNativeStepDown.cpp","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_TRIMNATIVESTEPDOWN_HPP\n+#define SHARE_GC_SHARED_TRIMNATIVESTEPDOWN_HPP\n+\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/\/\/\/\/\/ Support for TrimNativeHeapAdaptiveStepDown \/\/\/\/\/\/\n+\/\/\n+\/\/ Small heuristic to check if periodic trimming has been fruitful so far.\n+\/\/ If this heuristic finds trimming to be harmful, we will inject one longer\n+\/\/ trim interval (GCTrimNativeIntervalMax).\n+\/\/\n+\/\/ Trimming costs are the trim itself plus the re-aquisition costs of memory should the\n+\/\/ released memory be malloced again. Trimming gains are the memory reduction over time.\n+\/\/ Lasting gains are good; gains that don't last are not.\n+\/\/\n+\/\/ There are roughly three usage pattern:\n+\/\/ - rare malloc spikes interspersed with long idle periods. Trimming is beneficial\n+\/\/   since the relieved memory pressure holds for a long time.\n+\/\/ - a constant low-intensity malloc drone. Trimming does not help much here but its\n+\/\/   harmless too since trimming is cheap if it does not recover much.\n+\/\/ - frequent malloc spikes with short idle periods; trimmed memory will be re-aquired\n+\/\/   after only a short relief; here, trimming could be harmful since we pay a lot for\n+\/\/   not much relief. We want to alleviate these scenarios.\n+\/\/\n+\/\/ Putting numbers on these things is difficult though. We cannot observe malloc\n+\/\/ load directly, only RSS. For every trim we know the RSS reduction (from, to). So\n+\/\/ for subsequent trims we also can glean from (<next sample>.from) whether RSS bounced\n+\/\/ back. But that is quite vague since RSS may have been influenced by a ton of other\n+\/\/ developments, especially for longer trim intervals.\n+\/\/\n+\/\/ Therefore this heuristic may produce false positives and negatives. We try to err on\n+\/\/ the side of too much trimming here and to identify only situations that are clearly\n+\/\/ harmful. Note that the GCTrimNativeIntervalMax default (4 * GCTrimNativeInterval)\n+\/\/ is gentle enough for wrong heuristic results to not be too punative.\n+\n+\n+\/\/ A class holding results for a single trim operation.\n+class TrimResult {\n+\n+  \/\/ time (ms) trim happened (javaTimeMillis)\n+  int64_t _time;\n+  \/\/ time (ms) trim itself took.\n+  int64_t _duration;\n+  \/\/ rss\n+  size_t _rss_before, _rss_after;\n+\n+public:\n+\n+  TrimResult() : _time(-1), _duration(0), _rss_before(0), _rss_after(0) {}\n+\n+  TrimResult(int64_t t, int64_t d, size_t rss1, size_t rss2) :\n+    _time(t), _duration(d), _rss_before(rss1), _rss_after(rss2)\n+  {}\n+\n+  int64_t time() const { return _time; }\n+  int64_t duration() const { return _duration; }\n+  size_t rss_before() const { return _rss_before; }\n+  size_t rss_after() const { return _rss_before; }\n+\n+  bool is_valid() const {\n+    return _time >= 0 && _duration >= 0 &&\n+        _rss_before != 0 && _rss_after != 0;\n+  }\n+\n+  \/\/ Returns size reduction; positive if memory was reduced\n+  ssize_t size_reduction() const {\n+    return checked_cast<ssize_t>(_rss_before) -\n+           checked_cast<ssize_t>(_rss_after);\n+  }\n+\n+  \/\/ Return the lasting gain compared with a follow-up trim. Negative numbers mean a loss.\n+  ssize_t calc_lasting_gain(const TrimResult& followup_trim) const {\n+    ssize_t gain = size_reduction();\n+    ssize_t loss = checked_cast<ssize_t>(followup_trim.rss_before()) -\n+                   checked_cast<ssize_t>(rss_after());\n+    return gain - loss;\n+  }\n+\n+  \/\/ Return the interval time between this result and a follow-up trim.\n+  int64_t interval_time(const TrimResult& followup_trim) const {\n+    return followup_trim.time() - time();\n+  }\n+\n+  void print_on(outputStream* st) const;\n+\n+};\n+\n+class TrimNativeStepDownControl {\n+\n+  static const int _trim_history_length = 4;\n+\n+  \/\/ A FIFO of the last n trim results\n+  class TrimHistory {\n+    static const int _max = _trim_history_length;\n+\n+    \/\/ Note: history may contain invalid results; for one, it is\n+    \/\/ initialized with invalid results to keep iterating simple;\n+    \/\/ also invalid results can happen if measuring rss goes wrong.\n+    TrimResult _histo[_max];\n+    int _pos; \/\/ position of next write\n+\n+  public:\n+\n+    TrimHistory() : _pos(0) {}\n+\n+    void add(const TrimResult& result) {\n+      _histo[_pos] = result;\n+      if (++_pos == _max) {\n+        _pos = 0;\n+      }\n+    }\n+\n+    template <class Functor>\n+    void iterate_oldest_to_youngest(Functor f) const {\n+      int idx = _pos;\n+      do {\n+        f(_histo + idx);\n+        if (++idx == _max) {\n+          idx = 0;\n+        }\n+      } while (idx != _pos);\n+    }\n+  };\n+\n+  TrimHistory _history;\n+\n+  static bool is_bad_trim(const TrimResult& r, const TrimResult& r_followup);\n+\n+public:\n+\n+  \/\/ Feed a new trim result into control. It will be added to the history,\n+  \/\/ replacing the oldest result.\n+  \/\/ Adding invalid results is allowed; they will be ignored by the heuristics.\n+  void feed(const TrimResult& r);\n+\n+  \/\/ Returns true if Heuristic recommends stepping down the trim interval\n+  bool recommend_step_down() const;\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_TRIMNATIVESTEPDOWN_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/trimNativeStepDown.hpp","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -43,1 +43,1 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -286,0 +286,3 @@\n+      \/\/ Expedite next native trim. This also trims if periodic trims are disabled.\n+      TrimNative::schedule_trim();\n+\n@@ -290,0 +293,1 @@\n+\n@@ -428,1 +432,1 @@\n-  GCTrimNative::PauseThenTrimMark trim_pause_mark;\n+  TrimNative::PauseMark trim_pause_mark;\n@@ -443,1 +447,1 @@\n-  GCTrimNative::PauseMark trim_pause_mark;\n+  TrimNative::PauseMark trim_pause_mark;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -38,0 +37,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -630,1 +630,1 @@\n-  GCTrimNative::initialize();\n+  TrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -30,0 +29,1 @@\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -78,1 +78,1 @@\n-  GCTrimNative::initialize();\n+  TrimNative::initialize();\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -269,1 +269,1 @@\n-  GCTrimNative::PauseMark trim_native_pause;\n+  TrimNative::PauseMark trim_native_pause;\n@@ -324,0 +324,1 @@\n+  TrimNative::PauseMark trim_native_pause;\n@@ -433,0 +434,3 @@\n+\n+    \/\/ Expedite next native trim. This also trims if periodic trims are disabled.\n+    TrimNative::schedule_trim();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"gc\/shared\/trimNative.hpp\"\n@@ -454,1 +454,1 @@\n-  GCTrimNative::cleanup();\n+  TrimNative::cleanup();\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -445,3 +445,0 @@\n-  \/\/ Does the platform recommend trimming?\n-  static bool should_trim_native_heap();\n-\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"}]}