{"files":[{"patch":"@@ -2989,0 +2989,5 @@\n+\n+\/\/ stubbed-out trim-native support\n+bool os::can_trim_native_heap() { return false; }\n+bool os::should_trim_native_heap() { return false; }\n+bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2448,0 +2448,5 @@\n+\n+\/\/ stubbed-out trim-native support\n+bool os::can_trim_native_heap() { return false; }\n+bool os::should_trim_native_heap() { return false; }\n+bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -172,2 +172,22 @@\n-os::Linux::mallinfo_func_t os::Linux::_mallinfo = NULL;\n-os::Linux::mallinfo2_func_t os::Linux::_mallinfo2 = NULL;\n+\/\/ We want to be runnable with both old and new glibcs.\n+\/\/ Old glibcs offer mallinfo(). New glibcs deprecate mallinfo() and offer mallinfo2()\n+\/\/ as replacement. Future glibc's may remove the deprecated mallinfo().\n+\/\/ Therefore we may have one, both, or possibly neither (?). Code should tolerate all\n+\/\/ cases, which is why we resolve the functions dynamically. Outside code should use\n+\/\/ the Linux::get_mallinfo() utility function which exists to hide this mess.\n+struct glibc_mallinfo {\n+  int arena;\n+  int ordblks;\n+  int smblks;\n+  int hblks;\n+  int hblkhd;\n+  int usmblks;\n+  int fsmblks;\n+  int uordblks;\n+  int fordblks;\n+  int keepcost;\n+};\n+typedef struct glibc_mallinfo (*mallinfo_func_t)(void);\n+typedef struct os::Linux::glibc_mallinfo2 (*mallinfo2_func_t)(void);\n+static mallinfo_func_t g_mallinfo = NULL;\n+static mallinfo2_func_t g_mallinfo2 = NULL;\n@@ -2175,16 +2195,12 @@\n-  if (_mallinfo2 != NULL) {\n-    struct glibc_mallinfo2 mi = _mallinfo2();\n-    total_allocated = mi.uordblks + mi.hblkhd;\n-    free_retained = mi.fordblks;\n-  } else if (_mallinfo != NULL) {\n-    \/\/ mallinfo is an old API. Member names mean next to nothing and, beyond that, are 32-bit signed.\n-    \/\/ So for larger footprints the values may have wrapped around. We try to detect this here: if the\n-    \/\/ process whole resident set size is smaller than 4G, malloc footprint has to be less than that\n-    \/\/ and the numbers are reliable.\n-    struct glibc_mallinfo mi = _mallinfo();\n-    total_allocated = (size_t)(unsigned)mi.uordblks + (size_t)(unsigned)mi.hblkhd;\n-    free_retained = (size_t)(unsigned)mi.fordblks;\n-    \/\/ Since mallinfo members are int, glibc values may have wrapped. Warn about this.\n-    might_have_wrapped = (info.vmrss * K) > UINT_MAX && (info.vmrss * K) > (total_allocated + UINT_MAX);\n-  }\n-  if (_mallinfo2 != NULL || _mallinfo != NULL) {\n+  glibc_mallinfo2 mi;\n+  mallinfo_retval_t mirc = os::Linux::get_mallinfo(&mi);\n+  if (mirc != mallinfo_retval_t::error) {\n+    size_t total_allocated = mi.uordblks + mi.hblkhd;\n+    size_t free_retained = mi.fordblks;\n+#ifdef _LP64\n+    \/\/ If all we had is old mallinf(3), the values may have wrapped. Since that can confuse readers\n+    \/\/ of this output, print a hint.\n+    \/\/ We do this by checking virtual size of the process: if that is <4g, we could not have wrapped.\n+    might_have_wrapped = (mirc == mallinfo_retval_t::ok_but_possibly_wrapped) &&\n+                         ((info.vmsize * K) > UINT_MAX);\n+#endif\n@@ -4346,2 +4362,2 @@\n-  Linux::_mallinfo = CAST_TO_FN_PTR(Linux::mallinfo_func_t, dlsym(RTLD_DEFAULT, \"mallinfo\"));\n-  Linux::_mallinfo2 = CAST_TO_FN_PTR(Linux::mallinfo2_func_t, dlsym(RTLD_DEFAULT, \"mallinfo2\"));\n+  g_mallinfo = CAST_TO_FN_PTR(mallinfo_func_t, dlsym(RTLD_DEFAULT, \"mallinfo\"));\n+  g_mallinfo2 = CAST_TO_FN_PTR(mallinfo2_func_t, dlsym(RTLD_DEFAULT, \"mallinfo2\"));\n@@ -5404,0 +5420,92 @@\n+\n+#ifdef __GLIBC__\n+os::Linux::mallinfo_retval_t os::Linux::get_mallinfo(glibc_mallinfo2* out) {\n+  if (g_mallinfo2) {\n+    glibc_mallinfo2 mi = g_mallinfo2();\n+    *out = mi;\n+    return mallinfo_retval_t::ok;\n+  } else if (g_mallinfo) {\n+    \/\/ mallinfo() returns 32-bit values. Not perfect but still useful if\n+    \/\/ process virt size < 4g\n+    glibc_mallinfo mi = g_mallinfo();\n+    out->arena = (int) mi.arena;\n+    out->ordblks = (int) mi.ordblks;\n+    out->smblks = (int) mi.smblks;\n+    out->hblks = (int) mi.hblks;\n+    out->hblkhd = (int) mi.hblkhd;\n+    out->usmblks = (int) mi.usmblks;\n+    out->fsmblks = (int) mi.fsmblks;\n+    out->uordblks = (int) mi.uordblks;\n+    out->fordblks = (int) mi.fordblks;\n+    out->keepcost = (int) mi.keepcost;\n+    return mallinfo_retval_t::ok_but_possibly_wrapped;\n+  }\n+  return mallinfo_retval_t::ok;\n+}\n+#endif \/\/ __GLIBC__\n+\n+\/\/ Trim-native support\n+bool os::can_trim_native_heap() {\n+#ifdef __GLIBC__\n+  return true;\n+#else\n+  return false; \/\/ musl\n+#endif\n+}\n+\n+static const size_t retain_size = 2 * M;\n+\n+bool os::should_trim_native_heap() {\n+#ifdef __GLIBC__\n+  bool rc = true;\n+  \/\/ We try, using mallinfo, to predict whether a malloc_trim(3) will be beneficial.\n+  \/\/\n+  \/\/ \"mallinfo::keepcost\" is no help even if manpage claims this to be the projected\n+  \/\/ trim size. In practice it is just a very small value with no relation to the actual\n+  \/\/ effect trimming will have.\n+  \/\/\n+  \/\/ Our best bet is \"mallinfo::fordblks\", the total chunk size of free blocks. Since\n+  \/\/ only free blocks can be trimmed, a very low bar is to require their combined size\n+  \/\/ to be higher than our retain size. Note, however, that \"mallinfo::fordblks\" includes\n+  \/\/ already-trimmed blocks, since glibc trims by calling madvice(MADV_DONT_NEED) on free\n+  \/\/ chunks but does not update its bookkeeping.\n+  \/\/\n+  \/\/ In the end we want to prevent obvious bogus attempts to trim, and for that fordblks\n+  \/\/ is good enough.\n+  os::Linux::glibc_mallinfo2 mi;\n+  os::Linux::mallinfo_retval_t mirc = os::Linux::get_mallinfo(&mi);\n+  const size_t total_free = mi.fordblks;\n+  if (mirc == os::Linux::mallinfo_retval_t::ok) {\n+    rc = retain_size < total_free;\n+  }\n+  return rc;\n+#else\n+  return false; \/\/ musl\n+#endif\n+}\n+\n+bool os::trim_native_heap(os::size_change_t* rss_change) {\n+#ifdef __GLIBC__\n+  os::Linux::meminfo_t info1;\n+  os::Linux::meminfo_t info2;\n+\n+  bool have_info1 = os::Linux::query_process_memory_info(&info1);\n+  ::malloc_trim(retain_size);\n+  bool have_info2 = have_info1 && os::Linux::query_process_memory_info(&info2);\n+\n+  ssize_t delta = (ssize_t) -1;\n+  if (have_info1 && have_info2 &&\n+    info1.vmrss != -1 && info2.vmrss != -1 &&\n+    info1.vmswap != -1 && info2.vmswap != -1) {\n+    \/\/ Note: query_process_memory_info returns values in K\n+    rss_change->before = (info1.vmrss + info1.vmswap) * K;\n+    rss_change->after = (info2.vmrss + info2.vmswap) * K;\n+  } else {\n+    rss_change->after = rss_change->before = SIZE_MAX;\n+  }\n+\n+  return true;\n+#else\n+  return false; \/\/ musl\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":128,"deletions":20,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -175,1 +175,1 @@\n-  \/\/ Output structure for query_process_memory_info()\n+  \/\/ Output structure for query_process_memory_info() (all values in KB)\n@@ -268,34 +268,0 @@\n-#ifdef __GLIBC__\n-  struct glibc_mallinfo {\n-    int arena;\n-    int ordblks;\n-    int smblks;\n-    int hblks;\n-    int hblkhd;\n-    int usmblks;\n-    int fsmblks;\n-    int uordblks;\n-    int fordblks;\n-    int keepcost;\n-  };\n-\n-  struct glibc_mallinfo2 {\n-    size_t arena;\n-    size_t ordblks;\n-    size_t smblks;\n-    size_t hblks;\n-    size_t hblkhd;\n-    size_t usmblks;\n-    size_t fsmblks;\n-    size_t uordblks;\n-    size_t fordblks;\n-    size_t keepcost;\n-  };\n-\n-  typedef struct glibc_mallinfo (*mallinfo_func_t)(void);\n-  typedef struct glibc_mallinfo2 (*mallinfo2_func_t)(void);\n-\n-  static mallinfo_func_t _mallinfo;\n-  static mallinfo2_func_t _mallinfo2;\n-#endif\n-\n@@ -429,0 +395,20 @@\n+\n+#ifdef __GLIBC__\n+  struct glibc_mallinfo2 {\n+    size_t arena;\n+    size_t ordblks;\n+    size_t smblks;\n+    size_t hblks;\n+    size_t hblkhd;\n+    size_t usmblks;\n+    size_t fsmblks;\n+    size_t uordblks;\n+    size_t fordblks;\n+    size_t keepcost;\n+  };\n+  enum class mallinfo_retval_t { ok, error, ok_but_possibly_wrapped };\n+  \/\/ get_mallinfo() is a wrapper for mallinfo\/mallinfo2. It will prefer mallinfo2() if found.\n+  \/\/ If we only have mallinfo(), values may be 32-bit truncated, which is signaled via\n+  \/\/ \"ok_but_possibly_wrapped\".\n+  static mallinfo_retval_t get_mallinfo(glibc_mallinfo2* out);\n+#endif\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":21,"deletions":35,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n@@ -27,2 +27,0 @@\n-#include \"logging\/log.hpp\"\n-#include \"os_linux.hpp\"\n@@ -30,0 +28,1 @@\n+#include \"trimCHeapDCmd.hpp\"\n@@ -32,1 +31,1 @@\n-#include \"trimCHeapDCmd.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,32 +36,12 @@\n-#ifdef __GLIBC__\n-  stringStream ss_report(1024); \/\/ Note: before calling trim\n-\n-  os::Linux::meminfo_t info1;\n-  os::Linux::meminfo_t info2;\n-  \/\/ Query memory before...\n-  bool have_info1 = os::Linux::query_process_memory_info(&info1);\n-\n-  _output->print_cr(\"Attempting trim...\");\n-  ::malloc_trim(0);\n-  _output->print_cr(\"Done.\");\n-\n-  \/\/ ...and after trim.\n-  bool have_info2 = os::Linux::query_process_memory_info(&info2);\n-\n-  \/\/ Print report both to output stream as well to UL\n-  bool wrote_something = false;\n-  if (have_info1 && have_info2) {\n-    if (info1.vmsize != -1 && info2.vmsize != -1) {\n-      ss_report.print_cr(\"Virtual size before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n-                         info1.vmsize, info2.vmsize, (info2.vmsize - info1.vmsize));\n-      wrote_something = true;\n-    }\n-    if (info1.vmrss != -1 && info2.vmrss != -1) {\n-      ss_report.print_cr(\"RSS before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n-                         info1.vmrss, info2.vmrss, (info2.vmrss - info1.vmrss));\n-      wrote_something = true;\n-    }\n-    if (info1.vmswap != -1 && info2.vmswap != -1) {\n-      ss_report.print_cr(\"Swap before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n-                         info1.vmswap, info2.vmswap, (info2.vmswap - info1.vmswap));\n-      wrote_something = true;\n+  if (os::can_trim_native_heap()) {\n+    os::size_change_t sc;\n+    if (os::trim_native_heap(&sc)) {\n+      _output->print(\"Trim native heap: \");\n+      if (sc.after != SIZE_MAX) {\n+        const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+        const char sign = sc.after < sc.before ? '-' : '+';\n+        _output->print_cr(\"RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \")\",\n+                          PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta));\n+      } else {\n+        _output->print_cr(\"(no details available).\");\n+      }\n@@ -70,0 +49,2 @@\n+  } else {\n+    _output->print_cr(\"Not available.\");\n@@ -71,9 +52,0 @@\n-  if (!wrote_something) {\n-    ss_report.print_raw(\"No details available.\");\n-  }\n-\n-  _output->print_raw(ss_report.base());\n-  log_info(os)(\"malloc_trim:\\n%s\", ss_report.base());\n-#else\n-  _output->print_cr(\"Not available.\");\n-#endif\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":17,"deletions":45,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -5948,0 +5948,5 @@\n+\n+\/\/ stubbed-out trim-native support\n+bool os::can_trim_native_heap() { return false; }\n+bool os::should_trim_native_heap() { return false; }\n+bool os::trim_native_heap(os::size_change_t* rss_change) { return false; }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -85,0 +85,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -1768,0 +1769,1 @@\n+  GCTrimNative::initialize(true);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -174,0 +175,4 @@\n+\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::pause_periodic_trim();\n+\n@@ -235,0 +240,2 @@\n+\n+  GCTrimNative::schedule_trim();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -193,0 +194,2 @@\n+\n+  GCTrimNative::initialize(true);\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -1713,0 +1714,3 @@\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::pause_periodic_trim();\n+\n@@ -1870,0 +1874,2 @@\n+    GCTrimNative::schedule_trim();\n+\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/concurrentGCThread.hpp\"\n+#include \"gc\/shared\/gc_globals.hpp\"\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/mutex.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/ticks.hpp\"\n+\n+bool GCTrimNative::_async_mode = false;\n+double GCTrimNative::_next_trim_not_before = 0;\n+\n+\/\/ GCTrimNative works in two modes:\n+\/\/\n+\/\/ - async mode, where GCTrimNative runs a trimmer thread on behalf of the GC.\n+\/\/   The trimmer thread will be doing all the trims, both periodically and\n+\/\/   triggered from outside via GCTrimNative::schedule_trim().\n+\/\/\n+\/\/ - synchronous mode, where the GC does the trimming itself in its own thread,\n+\/\/   via GCTrimNative::should_trim() and GCTrimNative::execute_trim().\n+\/\/\n+\/\/ The mode is set as argument to GCTrimNative::initialize().\n+\n+class NativeTrimmer : public ConcurrentGCThread {\n+\n+  Monitor* _lock;\n+  volatile bool _paused;\n+  static NativeTrimmer* _the_trimmer;\n+\n+protected:\n+\n+  virtual void run_service() {\n+    assert(GCTrimNativeHeap, \"Sanity\");\n+    assert(os::can_trim_native_heap(), \"Sanity\");\n+\n+    log_info(gc, trim)(\"NativeTrimmer started.\");\n+\n+    \/\/ Note: GCTrimNativeHeapInterval=0 -> zero wait time -> indefinite waits, disabling periodic trim\n+    const int64_t delay_ms = GCTrimNativeHeapInterval * 1000;\n+    for (;;) {\n+      MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+      ml.wait(delay_ms);\n+      if (should_terminate()) {\n+        log_info(gc, trim)(\"NativeTrimmer stopped.\");\n+        break;\n+      }\n+      bool paused = Atomic::load(&_paused);\n+      if (!paused && os::should_trim_native_heap()) {\n+        GCTrimNative::do_trim();\n+      }\n+    }\n+  }\n+\n+  void wakeup() {\n+    MonitorLocker ml(_lock, Mutex::_no_safepoint_check_flag);\n+    ml.notify_all();\n+  }\n+\n+  void pause() {\n+    Atomic::store(&_paused, true);\n+    log_debug(gc, trim)(\"NativeTrimmer paused\");\n+  }\n+\n+  void unpause() {\n+    Atomic::store(&_paused, false);\n+    log_debug(gc, trim)(\"NativeTrimmer unpaused\");\n+  }\n+\n+  virtual void stop_service() {\n+    wakeup();\n+  }\n+\n+public:\n+\n+  NativeTrimmer() :\n+    _lock(new (std::nothrow) PaddedMonitor(Mutex::nosafepoint, \"NativeTrimmer_lock\")),\n+    _paused(false)\n+  {}\n+\n+  static bool is_enabled() {\n+    return _the_trimmer != nullptr;\n+  }\n+\n+  static void start_trimmer() {\n+    _the_trimmer = new NativeTrimmer();\n+    _the_trimmer->create_and_start(NormPriority);\n+  }\n+\n+  static void stop_trimmer() {\n+    _the_trimmer->stop();\n+  }\n+\n+  static void pause_periodic_trim() {\n+    _the_trimmer->pause();\n+  }\n+\n+  static void unpause_periodic_trim() {\n+    _the_trimmer->unpause();\n+  }\n+\n+  static void schedule_trim_now() {\n+    _the_trimmer->unpause();\n+    _the_trimmer->wakeup();\n+  }\n+\n+}; \/\/ NativeTrimmer\n+\n+NativeTrimmer* NativeTrimmer::_the_trimmer = nullptr;\n+\n+void GCTrimNative::do_trim() {\n+  Ticks start = Ticks::now();\n+  os::size_change_t sc;\n+  if (os::trim_native_heap(&sc)) {\n+    Tickspan trim_time = (Ticks::now() - start);\n+    if (sc.after != SIZE_MAX) {\n+      const size_t delta = sc.after < sc.before ? (sc.before - sc.after) : (sc.after - sc.before);\n+      const char sign = sc.after < sc.before ? '-' : '+';\n+      log_info(gc, trim)(\"Trim native heap: RSS+Swap: \" PROPERFMT \"->\" PROPERFMT \" (%c\" PROPERFMT \"), %1.3fms\",\n+                         PROPERFMTARGS(sc.before), PROPERFMTARGS(sc.after), sign, PROPERFMTARGS(delta),\n+                         trim_time.seconds() * 1000);\n+    } else {\n+      log_info(gc, trim)(\"Trim native heap (no details)\");\n+    }\n+  }\n+}\n+\n+\/\/\/ GCTrimNative outside facing methods\n+\n+void GCTrimNative::initialize(bool async_mode) {\n+\n+  if (GCTrimNativeHeap) {\n+\n+    if (!os::can_trim_native_heap()) {\n+      FLAG_SET_ERGO(GCTrimNativeHeap, false);\n+      log_info(gc, trim)(\"GCTrimNativeHeap disabled - trim-native not supported on this platform.\");\n+      return;\n+    }\n+\n+    log_debug(gc, trim)(\"GCTrimNativeHeap enabled.\");\n+\n+    _async_mode = async_mode;\n+\n+    \/\/ If we are to run the trimmer on behalf of the GC:\n+    if (_async_mode) {\n+      NativeTrimmer::start_trimmer();\n+    }\n+\n+    _next_trim_not_before = GCTrimNativeHeapInterval;\n+  }\n+}\n+\n+void GCTrimNative::cleanup() {\n+  if (GCTrimNativeHeap) {\n+    if (_async_mode) {\n+      NativeTrimmer::stop_trimmer();\n+    }\n+  }\n+}\n+\n+bool GCTrimNative::should_trim(bool ignore_delay) {\n+  return\n+      GCTrimNativeHeap && os::can_trim_native_heap() &&\n+      (ignore_delay || (GCTrimNativeHeapInterval > 0 && os::elapsedTime() > _next_trim_not_before)) &&\n+      os::should_trim_native_heap();\n+}\n+\n+void GCTrimNative::execute_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(!_async_mode, \"Only call for non-async mode\");\n+    do_trim();\n+    _next_trim_not_before = os::elapsedTime() + GCTrimNativeHeapInterval;\n+  }\n+}\n+\n+void GCTrimNative::pause_periodic_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(_async_mode, \"Only call for async mode\");\n+    NativeTrimmer::pause_periodic_trim();\n+  }\n+}\n+\n+void GCTrimNative::unpause_periodic_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(_async_mode, \"Only call for async mode\");\n+    NativeTrimmer::unpause_periodic_trim();\n+  }\n+}\n+\n+void GCTrimNative::schedule_trim() {\n+  if (GCTrimNativeHeap) {\n+    assert(_async_mode, \"Only call for async mode\");\n+    NativeTrimmer::schedule_trim_now();\n+  }\n+}\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.cpp","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,65 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n+#define SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+class NativeTrimmer;\n+\n+class GCTrimNative : public AllStatic {\n+  friend class NativeTrimmer;\n+\n+  static bool _async_mode;\n+  static double _next_trim_not_before;\n+\n+  static void do_trim();\n+\n+public:\n+\n+  static void initialize(bool async_mode);\n+  static void cleanup();\n+\n+  \/\/ Returns true if:\n+  \/\/ - trimming is enabled and possible\n+  \/\/ - trimming may have an actual effect (guess)\n+  \/\/ - delay timer has expired (unless ignore_delay is true)\n+  static bool should_trim(bool ignore_delay);\n+\n+  \/\/ Execute trim-native in this thread\n+  static void execute_trim();\n+\n+  \/\/ Pause\/unpause periodic trim\n+  static void pause_periodic_trim();\n+  static void unpause_periodic_trim();\n+\n+  \/\/ Schedule an explicit trim now; if periodic trims had been\n+  \/\/ paused, they are unpaused.\n+  static void schedule_trim();\n+\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_GCTRIMNATIVEHEAP_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTrimNativeHeap.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"added"},{"patch":"@@ -693,2 +693,14 @@\n-          constraint(GCCardSizeInBytesConstraintFunc,AtParse)\n-  \/\/ end of GC_FLAGS\n+          constraint(GCCardSizeInBytesConstraintFunc,AtParse)               \\\n+                                                                            \\\n+  product(bool, GCTrimNativeHeap, false, EXPERIMENTAL,                      \\\n+          \"GC will attempt to trim the native heap periodically and at \"    \\\n+          \"full GCs.\")                                                      \\\n+                                                                            \\\n+  product(uint, GCTrimNativeHeapInterval, 60, EXPERIMENTAL,                 \\\n+          \"If GCTrimNativeHeap is enabled: interval time, in seconds, in \"  \\\n+          \"which the VM will attempt to trim the native heap. A value of \"  \\\n+          \"0 disables periodic trimming while leaving trimming at full gc \" \\\n+          \"enabled.\")                                                       \\\n+          range(0, max_juint)                                               \\\n+                                                                            \\\n+          \/\/ end of GC_FLAGS\n","filename":"src\/hotspot\/share\/gc\/shared\/gc_globals.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -210,0 +211,2 @@\n+\n+  GCTrimNative::initialize(false); \/\/ false since we will call trim inside the collecting thread\n@@ -634,0 +637,5 @@\n+    \/\/ Trim the native heap, without a delay since this is a full gc\n+    if (GCTrimNative::should_trim(true)) {\n+      GCTrimNative::execute_trim();\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -48,0 +49,2 @@\n+#include \"utilities\/events.hpp\"\n+\n@@ -314,0 +317,8 @@\n+    if (GCTrimNative::should_trim(explicit_gc_requested)) {\n+      static const char *msg = \"Concurrent trim-native\";\n+      ShenandoahConcurrentPhase gc_phase(msg, ShenandoahPhaseTimings::conc_trim, false);\n+      EventMark em(\"%s\", msg);\n+      GCTrimNative::execute_trim();\n+      heap->phase_timings()->flush_cycle_to_global();\n+    }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -627,0 +628,2 @@\n+\n+  GCTrimNative::initialize(false); \/\/ false since this is taken care of inside the service thread\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  f(conc_trim,                                      \"Concurrent Trim\")                 \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -76,0 +77,2 @@\n+  GCTrimNative::initialize(true);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zCollectedHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"gc\/shared\/gcVMOperations.hpp\"\n@@ -29,0 +28,2 @@\n+#include \"gc\/shared\/gcVMOperations.hpp\"\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -451,0 +452,2 @@\n+  pause_native_trim();\n+\n@@ -483,0 +486,18 @@\n+\n+  resume_native_trim(request.cause());\n+\n+}\n+\n+void ZDriver::pause_native_trim() {\n+  \/\/ Pause native trimming for the duration of the GC\n+  GCTrimNative::pause_periodic_trim();\n+}\n+\n+void ZDriver::resume_native_trim(GCCause::Cause cause) {\n+  bool schedule_trim_now =\n+      cause == GCCause::_z_high_usage || GCCause::is_user_requested_gc(cause);\n+  if (schedule_trim_now) {\n+    GCTrimNative::schedule_trim();\n+  } else {\n+    GCTrimNative::unpause_periodic_trim();\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+  void pause_native_trim();\n+  void resume_native_trim(GCCause::Cause cause);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,0 +195,1 @@\n+  LOG_TAG(trim) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shared\/gcTrimNativeHeap.hpp\"\n@@ -452,0 +453,2 @@\n+  GCTrimNative::cleanup();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -443,0 +443,11 @@\n+  \/\/ Does the platform support trimming the native heap?\n+  static bool can_trim_native_heap();\n+\n+  \/\/ Does the platform recommend trimming?\n+  static bool should_trim_native_heap();\n+\n+  \/\/ Trim the C-heap. Returns RSS size change and optionally return the rss size change.\n+  \/\/ If trim was done but size change could not be obtained, SIZE_MAX is returned for after size.\n+  struct size_change_t { size_t before; size_t after; };\n+  static bool trim_native_heap(size_change_t* rss_change);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -355,0 +355,3 @@\n+#define PROPERFMT             SIZE_FORMAT \"%s\"\n+#define PROPERFMTARGS(S)      byte_size_in_proper_unit(S), proper_unit_for_byte_size(S)\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright (c) 2022 SAP SE. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * All these tests test the trim-native feature for all GCs.\n+ * Trim-native is the ability to trim the C-heap as part of the GC cycle.\n+ * This feature is controlled by -XX:+GCTrimNativeHeap (by default off).\n+ * Trimming happens on full gc for all gcs. Shenandoah and G1 also support\n+ * concurrent trimming (Shenandoah supports this without any ties to java\n+ * heap occupancy).\n+ *\n+ *\/\n+\n+\/\/\/\/ full gc tests \/\/\/\/\/\n+\n+\/*\n+ * @test id=fullgc-serial\n+ * @summary Test that GCTrimNativeHeap works with Serial\n+ * @requires vm.gc.Serial\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc serial\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-parallel\n+ * @summary Test that GCTrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc parallel\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-shenandoah\n+ * @summary Test that GCTrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-g1\n+ * @summary Test that GCTrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc g1\n+ *\/\n+\n+\/*\n+ * @test id=fullgc-z\n+ * @summary Test that GCTrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-fullgc z\n+ *\/\n+\n+\/\/\/\/ auto mode tests \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-parallel\n+ * @summary Test that GCTrimNativeHeap works with Parallel\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-shenandoah\n+ * @summary Test that GCTrimNativeHeap works with Shenandoah\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-g1\n+ * @summary Test that GCTrimNativeHeap works with G1\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-z\n+ * @summary Test that GCTrimNativeHeap works with Z\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto z\n+ *\/\n+\n+\/\/\/\/ test-auto-high-interval interval test \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-high-interval-parallel\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-g1\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-shenandoah\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-high-interval-z\n+ * @summary Test that a high GCTrimNativeHeapInterval effectively disables automatic trimming\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-high-interval z\n+ *\/\n+\n+\/\/\/\/ test-auto-interval-0 test \/\/\/\/\/\n+\n+\/\/ Note: not serial, since it does not do periodic trimming, only trimming on full gc\n+\n+\/*\n+ * @test id=auto-zero-interval-parallel\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Parallel\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval parallel\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-g1\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.G1\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval g1\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-shenandoah\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Shenandoah\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval shenandoah\n+ *\/\n+\n+\/*\n+ * @test id=auto-zero-interval-z\n+ * @summary Test that a GCTrimNativeHeapInterval=0 disables periodic trimming\n+ * @requires vm.gc.Z\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-auto-zero-interval z\n+ *\/\n+\n+\/\/ Other tests\n+\n+\/*\n+ * @test id=off-explicit\n+ * @summary Test that -GCTrimNative disables the feature\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-explicit\n+ *\/\n+\n+\/*\n+ * @test id=off-by-default\n+ * @summary Test that GCTrimNative is off by default\n+ * @requires (os.family==\"linux\") & !vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-by-default\n+ *\/\n+\n+\/*\n+ * @test id=off-on-other-platforms\n+ * @summary Test that GCTrimNative is off on unsupportive platforms\n+ * @requires (os.family!=\"linux\") | vm.musl\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib\n+ * @run driver gc.TestTrimNative test-off-on-other-platforms\n+ *\/\n+\n+import jdk.internal.misc.Unsafe;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.io.IOException;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class TestTrimNative {\n+\n+    \/\/ Actual RSS increase is a lot larger than 16MB. Depends on glibc overhead, and NMT malloc headers in debug VMs.\n+    \/\/ We need small-grained allocations to make sure they actually increase RSS (all touched) and to see the\n+    \/\/ glibc-retaining-memory effect.\n+    static final int numAllocations = 1024 * 1024;\n+    static final int szAllocations = 16;\n+    static long[] ptrs = new long[numAllocations];\n+\n+    enum Unit {\n+        B(1), K(1024), M(1024*1024), G(1024*1024*1024);\n+        public final long size;\n+        Unit(long size) { this.size = size; }\n+    }\n+\n+    enum GC {\n+        serial, parallel, g1, shenandoah, z;\n+        String getSwitchName() {\n+            String s = name();\n+            return \"-XX:+Use\" + s.substring(0, 1).toUpperCase() + s.substring(1) + \"GC\";\n+        }\n+        boolean isZ() { return this == GC.z; }\n+        boolean isSerial() { return this == GC.serial; }\n+        boolean isParallel() { return this == GC.parallel; }\n+        boolean isG1() { return this == GC.g1; }\n+        boolean isShenandoah() { return this == GC.shenandoah; }\n+    }\n+\n+    static private boolean usesNativeTrimmer(GC gc) {\n+        return gc.isG1() || gc.isParallel() || gc.isZ();\n+    }\n+\n+    static private final OutputAnalyzer runTestWithOptions(String[] extraOptions, String[] testArgs) throws IOException {\n+\n+        List<String> allOptions = new ArrayList<String>();\n+        allOptions.add(\"-XX:+UnlockExperimentalVMOptions\");\n+        allOptions.addAll(Arrays.asList(extraOptions));\n+        allOptions.add(\"-Xmx128m\");\n+        allOptions.add(\"-Xms128m\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-XX:+AlwaysPreTouch\"); \/\/ Stabilize RSS\n+        allOptions.add(\"-Xlog:gc+trim=debug\");\n+        allOptions.add(\"--add-exports=java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        allOptions.add(TestTrimNative.class.getName());\n+        allOptions.add(\"RUN\");\n+        allOptions.addAll(Arrays.asList(testArgs));\n+        ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(allOptions.toArray(new String[0]));\n+        OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+        output.shouldHaveExitValue(0);\n+        return output;\n+\n+    }\n+\n+    \/**\n+     * Given JVM output, look for a log line that describes a successful negative trim in the megabyte range\n+     * like this:\n+     * \"[2.053s][debug][gc,trim] Trim native heap (retain size: 5120K): RSS+Swap: 271M->223M (-49112K), 2.834ms\"\n+     * (Note: we use the \"properXXX\" print routines, therefore units can differ)\n+     * Check that the sum of all trim log lines comes to a total RSS reduction in the MB range\n+     * @param output\n+     * @param minExpected min number of trim lines expected in UL log\n+     * @param maxExpected max number of trim lines expected in UL log\n+     *\/\n+    private final static void parseOutputAndLookForNegativeTrim(OutputAnalyzer output, int minExpected, int maxExpected) {\n+        output.reportDiagnosticSummary();\n+        List<String> lines = output.asLines();\n+        Pattern pat = Pattern.compile(\".*\\\\[gc,trim\\\\] Trim native heap.*RSS\\\\+Swap: (\\\\d+)([KMB])->(\\\\d+)([KMB]).*\");\n+        int numTrimsFound = 0;\n+        long rssReductionTotal = 0;\n+        for (String line : lines) {\n+            Matcher mat = pat.matcher(line);\n+            if (mat.matches()) {\n+                long rss1 = Long.parseLong(mat.group(1)) * Unit.valueOf(mat.group(2)).size;\n+                long rss2 = Long.parseLong(mat.group(3)) * Unit.valueOf(mat.group(4)).size;\n+                if (rss1 > rss2) {\n+                    rssReductionTotal += (rss1 - rss2);\n+                    System.out.println(\"rss1: \" + rss1 + \" rss2 \" + rss2);\n+                }\n+                numTrimsFound ++;\n+            }\n+            if (numTrimsFound > maxExpected) {\n+                throw new RuntimeException(\"Abnormal high number of trim attempts found (more than \" + maxExpected +\n+                                            \"). Does the interval setting not work?\");\n+            }\n+        }\n+        if (numTrimsFound < minExpected) {\n+            throw new RuntimeException(\"We found fewer trim lines in UL log than expected (expected \" + minExpected +\n+                    \", found \" + numTrimsFound + \".\");\n+        }\n+        if (rssReductionTotal < (numAllocations * szAllocations)) {\n+            throw new RuntimeException(\"We did not see the expected RSS reduction in the UL log.\");\n+        }\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=1 causes a trim-native on full gc\n+    static private final void testWithFullGC(GC gc) throws IOException {\n+        System.out.println(\"testWithFullGC\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"3000\" \/* ms after peak *\/ }\n+        );\n+        \/\/ With default interval time of 30 seconds, auto trimming should never kick in, so the only\n+        \/\/ log line we expect to see is the one from the full-gc induced trim.\n+        parseOutputAndLookForNegativeTrim(output, 1, 1);\n+        \/\/ For GCs that use the NativeTrimmer, we want to see the NativeTrimmer paused during the GC, as well as\n+        \/\/ started and shut down properly.\n+        if (usesNativeTrimmer(gc)) {\n+            output.shouldContain(\"NativeTrimmer started\");\n+            output.shouldContain(\"NativeTrimmer paused\");\n+            output.shouldContain(\"NativeTrimmer unpaused\");\n+            output.shouldContain(\"NativeTrimmer stopped\");\n+        } else {\n+            output.shouldNotContain(\"NativeTrimmer\");\n+        }\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=1 causes a trim-native automatically, without GC (for now, shenandoah only)\n+    static private final void testAuto(GC gc) throws IOException {\n+        System.out.println(\"testAuto\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=1\" },\n+                new String[] { \"false\" \/* full gc *\/, \"6000\" \/* ms after peak *\/ }\n+        );\n+        \/\/ With an interval time of 1 second and a runtime of 6 seconds we expect to see 6 log lines (+ fudge factor).\n+        parseOutputAndLookForNegativeTrim(output, 5, 7);\n+    }\n+\n+    \/\/ Test that trim-native correctly honors interval\n+    static private final void testAutoWithHighInterval(GC gc) throws IOException {\n+        \/\/ We pass a very high interval. This should disable the feature for this short-lived test, we should see no trim\n+        System.out.println(\"testAutoWithHighInterval\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=30\" },\n+                new String[] { \"false\" \/* full gc *\/, \"6000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native correctly honors interval\n+    static private final void testAutoWithZeroInterval(GC gc) throws IOException {\n+        \/\/ We pass a very high interval. This should disable the feature for this short-lived test, we should see no trim\n+        System.out.println(\"testAutoWithHighInterval\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { gc.getSwitchName(), \"-XX:+GCTrimNativeHeap\", \"-XX:GCTrimNativeHeapInterval=0\" },\n+                new String[] { \"false\" \/* full gc *\/, \"6000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native gets disabled on platforms that don't support it.\n+    static private final void testOffOnNonCompliantPlatforms() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffOnNonCompliantPlatforms\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:+GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldContain(\"GCTrimNativeHeap disabled\");\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that GCTrimNativeHeap=0 switches trim-native off\n+    static private final void testOffExplicit() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffExplicit\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { \"-XX:-GCTrimNativeHeap\" },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    \/\/ Test that trim-native is disabled by default\n+    static private final void testOffByDefault() throws IOException {\n+        \/\/ Logic is shared, so no need to test with every GC. Just use the default GC.\n+        System.out.println(\"testOffByDefault\");\n+        OutputAnalyzer output = runTestWithOptions (\n+                new String[] { },\n+                new String[] { \"true\" \/* full gc *\/, \"2000\" \/* ms after peak *\/ }\n+        );\n+        output.shouldNotContain(\"Trim native heap\");\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (args.length == 0) {\n+            throw new RuntimeException(\"Argument error\");\n+        }\n+\n+        if (args[0].equals(\"RUN\")) {\n+            boolean doFullGC = Boolean.parseBoolean(args[1]);\n+\n+            System.out.println(\"Will spike now...\");\n+            for (int i = 0; i < numAllocations; i++) {\n+                ptrs[i] = Unsafe.getUnsafe().allocateMemory(szAllocations);\n+            }\n+            for (int i = 0; i < numAllocations; i++) {\n+                Unsafe.getUnsafe().freeMemory(ptrs[i]);\n+            }\n+            System.out.println(\"Done spiking.\");\n+\n+            if (doFullGC) {\n+                System.out.println(\"GC...\");\n+                System.gc();\n+            }\n+\n+            \/\/ give GC time to react\n+            int time = Integer.parseInt(args[2]);\n+            System.out.println(\"Sleeping...\");\n+            Thread.sleep(time);\n+            System.out.println(\"Done.\");\n+\n+            return;\n+\n+        } else if (args[0].equals(\"test-fullgc\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testWithFullGC(gc);\n+        } else if (args[0].equals(\"test-auto\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAuto(gc);\n+        } else if (args[0].equals(\"test-auto-high-interval\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAutoWithHighInterval(gc);\n+        } else if (args[0].equals(\"test-auto-zero-interval\")) {\n+            final GC gc = GC.valueOf(args[1]);\n+            testAutoWithZeroInterval(gc);\n+        } else if (args[0].equals(\"test-off-explicit\")) {\n+            testOffExplicit();\n+        } else if (args[0].equals(\"test-off-by-default\")) {\n+            testOffByDefault();\n+        } else if (args[0].equals(\"test-off-on-other-platforms\")) {\n+            testOffOnNonCompliantPlatforms();\n+        } else {\n+            throw new RuntimeException(\"Invalid test \" + args[0]);\n+        }\n+\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestTrimNative.java","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -34,1 +34,1 @@\n- * @requires os.family == \"linux\"\n+ * @requires (os.family==\"linux\") & !vm.musl\n@@ -45,4 +45,1 @@\n-        output.shouldMatch(\"(Done|Not available)\"); \/\/ Not available could happen on Linux + non-glibc (eg. muslc)\n-        if (output.firstMatch(\"Done\") != null) {\n-            output.shouldMatch(\"(Virtual size before|RSS before|Swap before|No details available)\");\n-        }\n+        output.shouldMatch(\".*Trim native heap: RSS\\\\+Swap: \\\\d+[BKM]->\\\\d+[BKM].*\");\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"}]}