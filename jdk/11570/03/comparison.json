{"files":[{"patch":"@@ -11087,1 +11087,0 @@\n-\n@@ -12903,0 +12902,1 @@\n+\n@@ -12974,1 +12974,0 @@\n-\n@@ -13688,0 +13687,292 @@\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm0_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_le(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr le\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_imm1_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csincw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::LT);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmovI_reg_immM1_ge(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr ge\\t\"  %}\n+\n+  ins_encode %{\n+    __ csinvw($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::GE);\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_le(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MinI src imm));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct minI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MinI imm src));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_lt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm0(iRegINoSp dst, iRegIorL2I src, immI0 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm0_reg(iRegINoSp dst, immI0 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm0_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_imm1(iRegINoSp dst, iRegIorL2I src, immI_1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_imm1_reg(iRegINoSp dst, immI_1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_imm1_gt(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_reg_immM1(iRegINoSp dst, iRegIorL2I src, immI_M1 imm)\n+%{\n+  match(Set dst (MaxI src imm));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n+\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct maxI_immM1_reg(iRegINoSp dst, immI_M1 imm, iRegIorL2I src)\n+%{\n+  match(Set dst (MaxI imm src));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src);\n+    cmovI_reg_immM1_ge(dst, src, cr);\n+  %}\n+%}\n+\n@@ -15698,3 +15989,1 @@\n-instruct cmovI_reg_reg_lt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n+\/\/ Like compI_reg_reg or compI_reg_immI0 but without match rule and second zero parameter.\n@@ -15702,2 +15991,5 @@\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 lt\\t\"  %}\n+instruct compI_reg_imm0(rFlagsReg cr, iRegI src)\n+%{\n+  effect(DEF cr, USE src);\n+  ins_cost(INSN_COST);\n+  format %{ \"cmpw $src, 0\" %}\n@@ -15706,4 +15998,1 @@\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::LT);\n+    __ cmpw($src$$Register, 0);\n@@ -15711,2 +16000,1 @@\n-\n-  ins_pipe(icond_reg_reg);\n+  ins_pipe(icmp_reg_imm);\n@@ -15715,1 +16003,1 @@\n-instruct minI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct minI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15725,19 +16013,0 @@\n-\n-%}\n-\/\/ FROM HERE\n-\n-instruct cmovI_reg_reg_gt(iRegINoSp dst, iRegI src1, iRegI src2, rFlagsReg cr)\n-%{\n-  effect( DEF dst, USE src1, USE src2, USE cr );\n-\n-  ins_cost(INSN_COST * 2);\n-  format %{ \"cselw $dst, $src1, $src2 gt\\t\"  %}\n-\n-  ins_encode %{\n-    __ cselw(as_Register($dst$$reg),\n-             as_Register($src1$$reg),\n-             as_Register($src2$$reg),\n-             Assembler::GT);\n-  %}\n-\n-  ins_pipe(icond_reg_reg);\n@@ -15746,1 +16015,1 @@\n-instruct maxI_rReg(iRegINoSp dst, iRegI src1, iRegI src2)\n+instruct maxI_reg_reg(iRegINoSp dst, iRegIorL2I src1, iRegIorL2I src2)\n@@ -15750,0 +16019,1 @@\n+\n@@ -15757,0 +16027,1 @@\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":305,"deletions":34,"binary":false,"changes":339,"status":"modified"},{"patch":"@@ -30,2 +30,4 @@\n-dnl\n-define(`ORL2I', `ifelse($1,I,orL2I)')\n+\n+define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl\n+define(`downcase', `translit(`$*', `A-Z', `a-z')')dnl\n+define(`ORL2I', `ifelse($1,I,orL2I)')dnl\n@@ -192,1 +194,1 @@\n-define(`EXTEND', `($2$1 (LShift$1 $3 $4) $5)') dnl\n+define(`EXTEND', `($2$1 (LShift$1 $3 $4) $5)')dnl\n@@ -215,1 +217,1 @@\n-')\n+')dnl\n@@ -339,1 +341,1 @@\n-\/\/ Rotations dnl\n+\/\/ Rotations\n@@ -542,0 +544,74 @@\n+define(`CMOV_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmov$1_reg_reg_$3(iReg$1NoSp dst, iReg$1 src1, iReg$1 src2, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE src2, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"$2 $dst, $src1, $src2 $3\\t\"  %}\n+\n+  ins_encode %{\n+    __ $2($dst$$Register,\n+             $src1$$Register,\n+             $src2$$Register,\n+             Assembler::upcase($3));\n+  %}\n+  ins_pipe(icond_reg_reg);\n+%}\n+')dnl\n+CMOV_INSN(I, cselw, lt)\n+CMOV_INSN(I, cselw, gt)\n+dnl\n+define(`CMOV_DRAW_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+instruct cmov$1_reg_imm$2_$4(iReg$1NoSp dst, iReg$1 src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"$3 $dst, $src1, zr $4\\t\"  %}\n+\n+  ins_encode %{\n+    __ $3($dst$$Register,\n+             $src1$$Register,\n+             zr,\n+             Assembler::upcase($4));\n+  %}\n+  ins_pipe(icond_reg);\n+%}\n+')dnl\n+CMOV_DRAW_INSN(I, 0, cselw, lt)\n+CMOV_DRAW_INSN(I, 0, cselw, gt)\n+CMOV_DRAW_INSN(I, 1, csincw, le)\n+CMOV_DRAW_INSN(I, 1, csincw, gt)\n+CMOV_DRAW_INSN(I, M1, csinvw, lt)\n+CMOV_DRAW_INSN(I, M1, csinvw, ge)\n+dnl\n+define(`MINMAX_DRAW_INSN', `\/\/ This pattern is automatically generated from aarch64_ad.m4\n+\/\/ DO NOT EDIT ANYTHING IN THIS SECTION OF THE FILE\n+ifelse($6,,\n+instruct downcase($1)$2_reg_imm$4(iReg$2NoSp dst, iReg$2`'ORL2I($2) src, imm$2$3$4 imm),\n+instruct downcase($1)$2_imm$4_reg(iReg$2NoSp dst, imm$2$3$4 imm, iReg$2`'ORL2I($2) src))\n+%{\n+  ifelse($6,,\n+  match(Set dst ($1$2 src imm));,\n+  match(Set dst ($1$2 imm src));)\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    comp$2_reg_imm0(cr, src);\n+    cmov$2_reg_imm$4_$5(dst, src, cr);\n+  %}\n+%}\n+')dnl\n+MINMAX_DRAW_INSN(Min, I,  , 0, lt)\n+MINMAX_DRAW_INSN(Min, I,  , 0, lt, rev)\n+MINMAX_DRAW_INSN(Min, I, _, 1, le)\n+MINMAX_DRAW_INSN(Min, I, _, 1, le, rev)\n+MINMAX_DRAW_INSN(Min, I, _, M1, lt)\n+MINMAX_DRAW_INSN(Min, I, _, M1, lt, rev)\n+dnl\n+MINMAX_DRAW_INSN(Max, I,  , 0, gt)\n+MINMAX_DRAW_INSN(Max, I,  , 0, gt, rev)\n+MINMAX_DRAW_INSN(Max, I, _, 1, gt)\n+MINMAX_DRAW_INSN(Max, I, _, 1, gt, rev)\n+MINMAX_DRAW_INSN(Max, I, _, M1, ge)\n+MINMAX_DRAW_INSN(Max, I, _, M1, ge, rev)\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_ad.m4","additions":81,"deletions":5,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8153837\n+* @summary Test integer min and max intrinsics\n+* @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+* @library \/test\/lib \/\n+* @modules java.base\/jdk.internal.misc\n+*\n+* @build jdk.test.whitebox.WhiteBox\n+* @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+*\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+*                   -server -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+*                   compiler.intrinsics.math.TestMinMaxIntrinsics\n+*\/\n+\n+package compiler.intrinsics.math;\n+\n+import java.lang.reflect.Method;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.IntBinaryOperator;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static jdk.test.lib.Asserts.assertEQ;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+public class TestMinMaxIntrinsics {\n+\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static int[] intCases = { Integer.MIN_VALUE, -2, -1, 0, 1, 2, Integer.MAX_VALUE };\n+    public static long im3l = Integer.MIN_VALUE * 3L;\n+\n+    static void test(IntUnaryOperator std, IntUnaryOperator alt) throws ReflectiveOperationException {\n+        for (int a : intCases) {\n+            assertEQ(std.applyAsInt(a), alt.applyAsInt(a), String.format(\"Failed on %d\", a));\n+        }\n+        var method = alt.getClass().getDeclaredMethod(\"applyAsInt\", int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method));\n+        for (int a : intCases) {\n+            assertEQ(std.applyAsInt(a), alt.applyAsInt(a), String.format(\"Failed on %d\", a));\n+        }\n+    }\n+\n+    static void test(IntBinaryOperator std, IntBinaryOperator alt) throws ReflectiveOperationException {\n+        for (int a : intCases) {\n+            for (int b : intCases) {\n+                assertEQ(std.applyAsInt(a, b), alt.applyAsInt(a, b), String.format(\"Failed on %d, %d\", a, b));\n+            }\n+        }\n+        var method = alt.getClass().getDeclaredMethod(\"applyAsInt\", int.class, int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method));\n+        for (int a : intCases) {\n+            for (int b : intCases) {\n+                assertEQ(std.applyAsInt(a, b), alt.applyAsInt(a, b), String.format(\"Failed on %d, %d\", a, b));\n+            }\n+        }\n+    }\n+\n+    static int maxL2I(long a, int b) {\n+        return Math.max((int) a, b);\n+    }\n+\n+    static void testL2I() throws NoSuchMethodException {\n+        assertEQ(0, maxL2I(im3l, 0));\n+        var method = TestMinMaxIntrinsics.class.getDeclaredMethod(\"maxL2I\", long.class, int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method));\n+        assertEQ(0, maxL2I(im3l, 0));\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        test(a -> (a <= 0) ? a : 0, a -> Math.min(a, 0));\n+        test(a -> (a <= 1) ? a : 1, a -> Math.min(a, 1));\n+        test(a -> (a <= -1) ? a : -1, a -> Math.min(a, -1));\n+\n+        test(a -> (0 >= a) ? 0 : a, a -> Math.max(0, a));\n+        test(a -> (1 >= a) ? 1 : a, a -> Math.max(1, a));\n+        test(a -> (-1 >= a) ? -1 : a, a -> Math.max(-1, a));\n+\n+        test((a, b) -> (a <= b) ? a : b, (a, b) -> Math.min(a, b));\n+        test((a, b) -> (a >= b) ? a : b, (a, b) -> Math.max(a, b));\n+\n+        testL2I();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxIntrinsics.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"}]}