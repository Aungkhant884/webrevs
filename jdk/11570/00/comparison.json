{"files":[{"patch":"@@ -15690,0 +15690,15 @@\n+\/\/ Like compI_reg_reg or compI_reg_immI0 but without match rule and second zero parameter.\n+instruct compI_reg_imm0(rFlagsReg cr, iRegI src1)\n+%{\n+  effect(DEF cr, USE src1);\n+\n+  ins_cost(INSN_COST);\n+  format %{ \"cmpw $src1, 0\" %}\n+\n+  ins_encode %{\n+    __ cmpw(as_Register($src1$$reg), 0);\n+  %}\n+\n+  ins_pipe(icmp_reg_imm);\n+%}\n+\n@@ -15707,0 +15722,49 @@\n+instruct cmovI_reg_imm0_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr lt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw(as_Register($dst$$reg),\n+             as_Register($src1$$reg),\n+             zr,\n+             Assembler::LT);\n+  %}\n+\n+  ins_pipe(icond_reg);\n+%}\n+\n+instruct cmovI_reg_imm1_le(iRegINoSp dst, iRegI src1, rFlagsReg cr) %{\n+  effect(DEF dst, USE src1, USE cr);\n+\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr le\\t# signed, int\"  %}\n+\n+  ins_encode %{\n+    __ csincw(as_Register($dst$$reg),\n+             as_Register($src1$$reg),\n+             zr,\n+             Assembler::LE);\n+  %}\n+\n+  ins_pipe(icond_reg);\n+%}\n+\n+instruct cmovI_reg_immM1_lt(iRegINoSp dst, iRegI src1, rFlagsReg cr) %{\n+  effect(DEF dst, USE src1, USE cr);\n+\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr lt\\t# signed, int\"  %}\n+\n+  ins_encode %{\n+    __ csinvw(as_Register($dst$$reg),\n+             as_Register($src1$$reg),\n+             zr,\n+             Assembler::LT);\n+  %}\n+\n+  ins_pipe(icond_reg);\n+%}\n+\n@@ -15719,0 +15783,34 @@\n+\n+instruct minI_imm0_rReg(iRegINoSp dst, immI0 zero, iRegI src2)\n+%{\n+  match(Set dst (MinI zero src2));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src2);\n+    cmovI_reg_imm0_lt(dst, src2, cr);\n+  %}\n+%}\n+\n+instruct minI_imm1_rReg(iRegINoSp dst, immI_1 one, iRegI src2)\n+%{\n+  match(Set dst (MinI one src2));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src2);\n+    cmovI_reg_imm1_le(dst, src2, cr);\n+  %}\n+%}\n+\n+instruct minI_immM1_rReg(iRegINoSp dst, immI_M1 m1, iRegI src2)\n+%{\n+  match(Set dst (MinI m1 src2));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src2);\n+    cmovI_reg_immM1_lt(dst, src2, cr);\n+  %}\n+%}\n+\n@@ -15738,0 +15836,49 @@\n+instruct cmovI_reg_imm0_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr)\n+%{\n+  effect(DEF dst, USE src1, USE cr);\n+\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"cselw $dst, $src1, zr gt\\t\"  %}\n+\n+  ins_encode %{\n+    __ cselw(as_Register($dst$$reg),\n+             as_Register($src1$$reg),\n+             zr,\n+             Assembler::GT);\n+  %}\n+\n+  ins_pipe(icond_reg);\n+%}\n+\n+instruct cmovI_reg_imm1_gt(iRegINoSp dst, iRegI src1, rFlagsReg cr) %{\n+  effect(DEF dst, USE src1, USE cr);\n+\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csincw $dst, $src1, zr gt\\t# signed, int\"  %}\n+\n+  ins_encode %{\n+    __ csincw(as_Register($dst$$reg),\n+             as_Register($src1$$reg),\n+             zr,\n+             Assembler::GT);\n+  %}\n+\n+  ins_pipe(icond_reg);\n+%}\n+\n+instruct cmovI_reg_immM1_ge(iRegINoSp dst, iRegI src1, rFlagsReg cr) %{\n+  effect(DEF dst, USE src1, USE cr);\n+\n+  ins_cost(INSN_COST * 2);\n+  format %{ \"csinvw $dst, $src1, zr gt\\t# signed, int\"  %}\n+\n+  ins_encode %{\n+    __ csinvw(as_Register($dst$$reg),\n+             as_Register($src1$$reg),\n+             zr,\n+             Assembler::GE);\n+  %}\n+\n+  ins_pipe(icond_reg);\n+%}\n+\n@@ -15749,0 +15896,34 @@\n+instruct maxI_imm0_rReg(iRegINoSp dst, immI0 zero, iRegI src2)\n+%{\n+  match(Set dst (MaxI zero src2));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src2);\n+    cmovI_reg_imm0_gt(dst, src2, cr);\n+  %}\n+%}\n+\n+instruct maxI_imm1_rReg(iRegINoSp dst, immI_1 one, iRegI src2)\n+%{\n+  match(Set dst (MaxI one src2));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src2);\n+    cmovI_reg_imm1_gt(dst, src2, cr);\n+  %}\n+%}\n+\n+instruct maxI_immM1_rReg(iRegINoSp dst, immI_M1 m1, iRegI src2)\n+%{\n+  match(Set dst (MaxI m1 src2));\n+  ins_cost(INSN_COST * 2);\n+  expand %{\n+    rFlagsReg cr;\n+    compI_reg_imm0(cr, src2);\n+    cmovI_reg_immM1_ge(dst, src2, cr);\n+  %}\n+%}\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":181,"deletions":0,"binary":false,"changes":181,"status":"modified"},{"patch":"@@ -1127,3 +1127,14 @@\n-  if (x->_idx > y->_idx && r->Opcode() != Op_MaxI) {\n-    swap_edges(1, 2);\n-    return this;\n+  if (r->Opcode() != Op_MaxI) {\n+    if (!l->is_Con()) {\n+      if (r->is_Con()) {\n+        \/\/ Convert \"max(x, con)\" into \"max(con, x)\".\n+        swap_edges(1, 2);\n+        return this;\n+      } else {\n+        \/\/ Otherwise, sort inputs.\n+        if (x->_idx > y->_idx) {\n+          swap_edges(1, 2);\n+          return this;\n+        }\n+      }\n+    }\n@@ -1210,3 +1221,14 @@\n-  if( x->_idx > y->_idx && r->Opcode() != Op_MinI ) {\n-    swap_edges(1, 2);\n-    return this;\n+  if (r->Opcode() != Op_MinI) {\n+    if (!l->is_Con()) {\n+      if (r->is_Con()) {\n+        \/\/ Convert \"min(x, con)\" into \"min(con, x)\".\n+        swap_edges(1, 2);\n+        return this;\n+      } else {\n+        \/\/ Otherwise, sort inputs.\n+        if (x->_idx > y->_idx) {\n+          swap_edges(1, 2);\n+          return this;\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":28,"deletions":6,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2022, BELLSOFT. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+* @test\n+* @bug 8153837\n+* @summary Test integer min and max intrinsics\n+* @requires vm.flavor == \"server\" & (vm.opt.TieredStopAtLevel == null | vm.opt.TieredStopAtLevel == 4)\n+* @library \/test\/lib \/\n+* @modules java.base\/jdk.internal.misc\n+*\n+* @build jdk.test.whitebox.WhiteBox\n+* @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+*\n+* @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI\n+*                   -server -XX:-BackgroundCompilation -XX:-UseOnStackReplacement\n+*                   compiler.intrinsics.math.TestMinMaxIntrinsics\n+*\/\n+\n+package compiler.intrinsics.math;\n+\n+import java.lang.reflect.Method;\n+import java.util.function.IntUnaryOperator;\n+import java.util.function.IntBinaryOperator;\n+import jdk.test.whitebox.WhiteBox;\n+\n+import static jdk.test.lib.Asserts.assertEQ;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static compiler.whitebox.CompilerWhiteBoxTest.COMP_LEVEL_FULL_OPTIMIZATION;\n+\n+public class TestMinMaxIntrinsics {\n+\n+    static WhiteBox wb = WhiteBox.getWhiteBox();\n+    static int[] intCases = { Integer.MIN_VALUE, -2, -1, 0, 1, 2, Integer.MAX_VALUE };\n+\n+    static void test(IntUnaryOperator std, IntUnaryOperator alt) throws ReflectiveOperationException {\n+        assertEQ(std.applyAsInt(0), alt.applyAsInt(0), \"Basic check\");\n+        var method = alt.getClass().getDeclaredMethod(\"applyAsInt\", int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method), \"Should be compiled\");\n+        for (int a : intCases) {\n+            assertEQ(std.applyAsInt(a), alt.applyAsInt(a), String.format(\"Failed on %d\", a));\n+        }\n+    }\n+\n+    static void test(IntBinaryOperator std, IntBinaryOperator alt) throws ReflectiveOperationException {\n+        assertEQ(std.applyAsInt(0, 0), alt.applyAsInt(0, 0), \"Basic check\");\n+        var method = alt.getClass().getDeclaredMethod(\"applyAsInt\", int.class, int.class);\n+        wb.enqueueMethodForCompilation(method, COMP_LEVEL_FULL_OPTIMIZATION);\n+        assertTrue(wb.isMethodCompiled(method), \"Should be compiled\");\n+        for (int a : intCases) {\n+            for (int b : intCases) {\n+                assertEQ(std.applyAsInt(a, b), alt.applyAsInt(a, b), String.format(\"Failed on %d, %d\", a, b));\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        test(a -> (a <= 0) ? a : 0, a -> Math.min(a, 0));\n+        test(a -> (a <= 1) ? a : 1, a -> Math.min(a, 1));\n+        test(a -> (a <= -1) ? a : -1, a -> Math.min(a, -1));\n+\n+        test(a -> (a >= 0) ? a : 0, a -> Math.max(a, 0));\n+        test(a -> (a >= 1) ? a : 1, a -> Math.max(a, 1));\n+        test(a -> (a >= -1) ? a : -1, a -> Math.max(a, -1));\n+\n+        test((a, b) -> (a <= b) ? a : b, (a, b) -> Math.min(a, b));\n+        test((a, b) -> (a >= b) ? a : b, (a, b) -> Math.max(a, b));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/math\/TestMinMaxIntrinsics.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"}]}