{"files":[{"patch":"@@ -617,1 +617,0 @@\n-    GrowableArray<const char*>* c2_phase_names = new GrowableArray<const char*>(PHASE_NUM_TYPES);\n@@ -619,1 +618,1 @@\n-      const char* phase_name = CompilerPhaseTypeHelper::to_string((CompilerPhaseType) i);\n+      const char* phase_name = CompilerPhaseTypeHelper::to_description((CompilerPhaseType) i);\n","filename":"src\/hotspot\/share\/compiler\/compileBroker.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"opto\/phasetype.hpp\"\n@@ -265,0 +266,1 @@\n+  _ideal_phase_name_mask = 0;\n@@ -384,0 +386,18 @@\n+    \/\/ Parse PrintIdealPhaseName and create an efficient lookup mask\n+#ifndef PRODUCT\n+#ifdef COMPILER2\n+    if (!_modified[PrintIdealPhaseIndex]) {\n+      \/\/ Parse ccstr and create mask\n+      ccstrlist option;\n+      if (CompilerOracle::has_option_value(method, CompileCommand::PrintIdealPhase, option)) {\n+        uint64_t mask = 0;\n+        PhaseNameValidator validator(option, mask);\n+        if (validator.is_valid()) {\n+          assert(mask != 0, \"Must be set\");\n+          set.cloned()->_ideal_phase_name_mask = mask;\n+        }\n+      }\n+    }\n+#endif\n+#endif\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+NOT_PRODUCT(cflags(PrintIdealPhase,     ccstrlist, \"\", PrintIdealPhase)) \\\n@@ -111,0 +112,1 @@\n+  uint64_t _ideal_phase_name_mask;\n@@ -140,1 +142,0 @@\n-\n@@ -153,0 +154,3 @@\n+  void set_ideal_phase_mask(uint64_t mask) { _ideal_phase_name_mask = mask; };\n+  uint64_t ideal_phase_mask() { return _ideal_phase_name_mask; };\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"opto\/phasetype.hpp\"\n@@ -686,0 +687,15 @@\n+#ifndef PRODUCT\n+      else if (option == CompileCommand::PrintIdealPhase) {\n+        uint64_t mask = 0;\n+        PhaseNameValidator validator(value, mask);\n+\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized phase name in %s: %s\", option2name(option), validator.what());\n+        }\n+      } else if (option == CompileCommand::TestOptionList) {\n+        \/\/ all values are ok\n+      }\n+#endif\n+      else {\n+        assert(false, \"Ccstrlist type option missing validator\");\n+      }\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -82,3 +82,4 @@\n-  option(PrintIdeal, \"PrintIdeal\", Bool)  \\\n-  option(PrintIdealLevel, \"PrintIdealLevel\", Uintx) \\\n-  option(IGVPrintLevel, \"IGVPrintLevel\", Intx) \\\n+NOT_PRODUCT(option(PrintIdeal, \"PrintIdeal\", Bool))  \\\n+NOT_PRODUCT(option(PrintIdealLevel, \"PrintIdealLevel\", Uintx)) \\\n+NOT_PRODUCT(option(PrintIdealPhase, \"PrintIdealPhase\", Ccstrlist)) \\\n+NOT_PRODUCT(option(IGVPrintLevel, \"IGVPrintLevel\", Intx)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"opto\/phasetype.hpp\"\n@@ -337,0 +338,9 @@\n+        } else if (strncmp(option_key->name, \"PrintIdealPhase\", 15) == 0) {\n+          uint64_t mask = 0;\n+          PhaseNameValidator validator(s, mask);\n+\n+          if (!validator.is_valid()) {\n+            error(VALUE_ERROR, \"Unrecognized phase name detected in PrintIdealPhase: %s\", validator.what());\n+            return false;\n+          }\n+          set->set_ideal_phase_mask(mask);\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4836,1 +4836,1 @@\n-  ss.print_raw(CompilerPhaseTypeHelper::to_string(cpt));\n+  ss.print_raw(CompilerPhaseTypeHelper::to_name(cpt));\n@@ -4845,2 +4845,2 @@\n-  if (should_print_ideal(level)) {\n-    print_ideal_ir(name);\n+  if (should_print_ideal(level) || should_print_phase(cpt)) {\n+    print_ideal_ir(CompilerPhaseTypeHelper::to_name(cpt));\n@@ -4876,0 +4876,9 @@\n+bool Compile::should_print_phase(CompilerPhaseType cpt) {\n+#ifndef PRODUCT\n+  if ((_directive->ideal_phase_mask() & CompilerPhaseTypeHelper::to_bitmask(cpt)) != 0) {\n+    return true;\n+  }\n+#endif\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -657,0 +657,1 @@\n+  bool should_print_phase(CompilerPhaseType cpt);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,0 +28,44 @@\n+#define COMPILER_PHASES(flags) \\\n+  flags(BEFORE_STRINGOPTS,            \"Before StringOpts\") \\\n+  flags(AFTER_STRINGOPTS,             \"After StringOpts\") \\\n+  flags(BEFORE_REMOVEUSELESS,         \"Before RemoveUseless\") \\\n+  flags(AFTER_PARSING,                \"After Parsing\") \\\n+  flags(ITER_GVN1,                    \"Iter GVN 1\") \\\n+  flags(EXPAND_VUNBOX,                \"Expand VectorUnbox\") \\\n+  flags(SCALARIZE_VBOX,               \"Scalarize VectorBox\") \\\n+  flags(INLINE_VECTOR_REBOX,          \"Inline Vector Rebox Calls\") \\\n+  flags(EXPAND_VBOX,                  \"Expand VectorBox\") \\\n+  flags(ELIMINATE_VBOX_ALLOC,         \"Eliminate VectorBoxAllocate\") \\\n+  flags(PHASEIDEAL_BEFORE_EA,         \"PhaseIdealLoop before EA\") \\\n+  flags(ITER_GVN_AFTER_VECTOR,        \"Iter GVN after vector box elimination\") \\\n+  flags(ITER_GVN_BEFORE_EA,           \"Iter GVN before EA\") \\\n+  flags(ITER_GVN_AFTER_EA,            \"Iter GVN after EA\") \\\n+  flags(ITER_GVN_AFTER_ELIMINATION,   \"Iter GVN after eliminating allocations and locks\") \\\n+  flags(PHASEIDEALLOOP1,              \"PhaseIdealLoop 1\") \\\n+  flags(PHASEIDEALLOOP2,              \"PhaseIdealLoop 2\") \\\n+  flags(PHASEIDEALLOOP3,              \"PhaseIdealLoop 3\") \\\n+  flags(CCP1,                         \"PhaseCCP 1\") \\\n+  flags(ITER_GVN2,                    \"Iter GVN 2\") \\\n+  flags(PHASEIDEALLOOP_ITERATIONS,    \"PhaseIdealLoop iterations\") \\\n+  flags(OPTIMIZE_FINISHED,            \"Optimize finished\") \\\n+  flags(GLOBAL_CODE_MOTION,           \"Global code motion\") \\\n+  flags(FINAL_CODE,                   \"Final Code\") \\\n+  flags(AFTER_EA,                     \"After Escape Analysis\") \\\n+  flags(BEFORE_CLOOPS,                \"Before CountedLoop\") \\\n+  flags(AFTER_CLOOPS,                 \"After CountedLoop\") \\\n+  flags(BEFORE_BEAUTIFY_LOOPS,        \"Before beautify loops\") \\\n+  flags(AFTER_BEAUTIFY_LOOPS,         \"After beautify loops\") \\\n+  flags(BEFORE_MATCHING,              \"Before matching\") \\\n+  flags(MATCHING,                     \"After matching\") \\\n+  flags(INCREMENTAL_INLINE,           \"Incremental Inline\") \\\n+  flags(INCREMENTAL_INLINE_STEP,      \"Incremental Inline Step\") \\\n+  flags(INCREMENTAL_INLINE_CLEANUP,   \"Incremental Inline Cleanup\") \\\n+  flags(INCREMENTAL_BOXING_INLINE,    \"Incremental Boxing Inline\") \\\n+  flags(CALL_CATCH_CLEANUP,           \"Call catch cleanup\") \\\n+  flags(MACRO_EXPANSION,              \"Macro expand\") \\\n+  flags(BARRIER_EXPANSION,            \"Barrier expand\") \\\n+  flags(END,                          \"End\") \\\n+  flags(FAILURE,                      \"Failure\") \\\n+  flags(DEBUG,                        \"Debug\")\n+\n+#define table_entry(name, description) PHASE_##name,\n@@ -29,45 +73,16 @@\n-  PHASE_BEFORE_STRINGOPTS,\n-  PHASE_AFTER_STRINGOPTS,\n-  PHASE_BEFORE_REMOVEUSELESS,\n-  PHASE_AFTER_PARSING,\n-  PHASE_ITER_GVN1,\n-  PHASE_EXPAND_VUNBOX,\n-  PHASE_SCALARIZE_VBOX,\n-  PHASE_INLINE_VECTOR_REBOX,\n-  PHASE_EXPAND_VBOX,\n-  PHASE_ELIMINATE_VBOX_ALLOC,\n-  PHASE_PHASEIDEAL_BEFORE_EA,\n-  PHASE_ITER_GVN_AFTER_VECTOR,\n-  PHASE_ITER_GVN_BEFORE_EA,\n-  PHASE_ITER_GVN_AFTER_EA,\n-  PHASE_ITER_GVN_AFTER_ELIMINATION,\n-  PHASE_PHASEIDEALLOOP1,\n-  PHASE_PHASEIDEALLOOP2,\n-  PHASE_PHASEIDEALLOOP3,\n-  PHASE_CCP1,\n-  PHASE_ITER_GVN2,\n-  PHASE_PHASEIDEALLOOP_ITERATIONS,\n-  PHASE_OPTIMIZE_FINISHED,\n-  PHASE_GLOBAL_CODE_MOTION,\n-  PHASE_FINAL_CODE,\n-  PHASE_AFTER_EA,\n-  PHASE_BEFORE_CLOOPS,\n-  PHASE_AFTER_CLOOPS,\n-  PHASE_BEFORE_BEAUTIFY_LOOPS,\n-  PHASE_AFTER_BEAUTIFY_LOOPS,\n-  PHASE_BEFORE_MATCHING,\n-  PHASE_MATCHING,\n-  PHASE_INCREMENTAL_INLINE,\n-  PHASE_INCREMENTAL_INLINE_STEP,\n-  PHASE_INCREMENTAL_INLINE_CLEANUP,\n-  PHASE_INCREMENTAL_BOXING_INLINE,\n-  PHASE_CALL_CATCH_CLEANUP,\n-  PHASE_INSERT_BARRIER,\n-  PHASE_MACRO_EXPANSION,\n-  PHASE_BARRIER_EXPANSION,\n-  PHASE_ADD_UNSAFE_BARRIER,\n-  PHASE_END,\n-  PHASE_FAILURE,\n-  PHASE_DEBUG,\n-\n-  PHASE_NUM_TYPES\n+  COMPILER_PHASES(table_entry)\n+  PHASE_NUM_TYPES,\n+  PHASE_NONE\n+};\n+#undef table_entry\n+\n+static const char* phase_descriptions[] = {\n+#define array_of_labels(name, description) description,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n+};\n+\n+static const char* phase_names[] = {\n+#define array_of_labels(name, description) #name,\n+       COMPILER_PHASES(array_of_labels)\n+#undef array_of_labels\n@@ -78,48 +93,55 @@\n-  static const char* to_string(CompilerPhaseType cpt) {\n-    switch (cpt) {\n-      case PHASE_BEFORE_STRINGOPTS:          return \"Before StringOpts\";\n-      case PHASE_AFTER_STRINGOPTS:           return \"After StringOpts\";\n-      case PHASE_BEFORE_REMOVEUSELESS:       return \"Before RemoveUseless\";\n-      case PHASE_AFTER_PARSING:              return \"After Parsing\";\n-      case PHASE_ITER_GVN1:                  return \"Iter GVN 1\";\n-      case PHASE_EXPAND_VUNBOX:              return \"Expand VectorUnbox\";\n-      case PHASE_SCALARIZE_VBOX:             return \"Scalarize VectorBox\";\n-      case PHASE_INLINE_VECTOR_REBOX:        return \"Inline Vector Rebox Calls\";\n-      case PHASE_EXPAND_VBOX:                return \"Expand VectorBox\";\n-      case PHASE_ELIMINATE_VBOX_ALLOC:       return \"Eliminate VectorBoxAllocate\";\n-      case PHASE_PHASEIDEAL_BEFORE_EA:       return \"PhaseIdealLoop before EA\";\n-      case PHASE_ITER_GVN_AFTER_VECTOR:      return \"Iter GVN after vector box elimination\";\n-      case PHASE_ITER_GVN_BEFORE_EA:         return \"Iter GVN before EA\";\n-      case PHASE_ITER_GVN_AFTER_EA:          return \"Iter GVN after EA\";\n-      case PHASE_ITER_GVN_AFTER_ELIMINATION: return \"Iter GVN after eliminating allocations and locks\";\n-      case PHASE_PHASEIDEALLOOP1:            return \"PhaseIdealLoop 1\";\n-      case PHASE_PHASEIDEALLOOP2:            return \"PhaseIdealLoop 2\";\n-      case PHASE_PHASEIDEALLOOP3:            return \"PhaseIdealLoop 3\";\n-      case PHASE_CCP1:                       return \"PhaseCCP 1\";\n-      case PHASE_ITER_GVN2:                  return \"Iter GVN 2\";\n-      case PHASE_PHASEIDEALLOOP_ITERATIONS:  return \"PhaseIdealLoop iterations\";\n-      case PHASE_OPTIMIZE_FINISHED:          return \"Optimize finished\";\n-      case PHASE_GLOBAL_CODE_MOTION:         return \"Global code motion\";\n-      case PHASE_FINAL_CODE:                 return \"Final Code\";\n-      case PHASE_AFTER_EA:                   return \"After Escape Analysis\";\n-      case PHASE_BEFORE_CLOOPS:              return \"Before CountedLoop\";\n-      case PHASE_AFTER_CLOOPS:               return \"After CountedLoop\";\n-      case PHASE_BEFORE_BEAUTIFY_LOOPS:      return \"Before beautify loops\";\n-      case PHASE_AFTER_BEAUTIFY_LOOPS:       return \"After beautify loops\";\n-      case PHASE_BEFORE_MATCHING:            return \"Before matching\";\n-      case PHASE_MATCHING:                   return \"After matching\";\n-      case PHASE_INCREMENTAL_INLINE:         return \"Incremental Inline\";\n-      case PHASE_INCREMENTAL_INLINE_STEP:    return \"Incremental Inline Step\";\n-      case PHASE_INCREMENTAL_INLINE_CLEANUP: return \"Incremental Inline Cleanup\";\n-      case PHASE_INCREMENTAL_BOXING_INLINE:  return \"Incremental Boxing Inline\";\n-      case PHASE_CALL_CATCH_CLEANUP:         return \"Call catch cleanup\";\n-      case PHASE_INSERT_BARRIER:             return \"Insert barrier\";\n-      case PHASE_MACRO_EXPANSION:            return \"Macro expand\";\n-      case PHASE_BARRIER_EXPANSION:          return \"Barrier expand\";\n-      case PHASE_ADD_UNSAFE_BARRIER:         return \"Add barrier to unsafe op\";\n-      case PHASE_END:                        return \"End\";\n-      case PHASE_FAILURE:                    return \"Failure\";\n-      case PHASE_DEBUG:                      return \"Debug\";\n-      default:\n-        ShouldNotReachHere();\n-        return NULL;\n+  static const char* to_name(CompilerPhaseType cpt) {\n+    return phase_names[cpt];\n+  }\n+  static const char* to_description(CompilerPhaseType cpt) {\n+    return phase_descriptions[cpt];\n+  }\n+  static int to_bitmask(CompilerPhaseType cpt) {\n+    return (1 << cpt);\n+  }\n+};\n+\n+static CompilerPhaseType find_phase(const char* str) {\n+  for (int i = 0; i < PHASE_NUM_TYPES; i++) {\n+    if (strcmp(phase_names[i], str) == 0) {\n+      return (CompilerPhaseType)i;\n+    }\n+  }\n+  return PHASE_NONE;\n+}\n+\n+class PhaseNameIter {\n+ private:\n+  char* _token;\n+  char* _saved_ptr;\n+  char* _list;\n+\n+ public:\n+  PhaseNameIter(ccstrlist option) {\n+    _list = (char*) canonicalize(option);\n+    _saved_ptr = _list;\n+    _token = strtok_r(_saved_ptr, \",\", &_saved_ptr);\n+  }\n+\n+  ~PhaseNameIter() {\n+    FREE_C_HEAP_ARRAY(char, _list);\n+  }\n+\n+  const char* operator*() const { return _token; }\n+\n+  PhaseNameIter& operator++() {\n+    _token = strtok_r(NULL, \",\", &_saved_ptr);\n+    return *this;\n+  }\n+\n+  ccstrlist canonicalize(ccstrlist option_value) {\n+    char* canonicalized_list = NEW_C_HEAP_ARRAY(char, strlen(option_value) + 1, mtCompiler);\n+    int i = 0;\n+    char current;\n+    while ((current = option_value[i]) != '\\0') {\n+      if (current == '\\n' || current == ' ') {\n+        canonicalized_list[i] = ',';\n+      } else {\n+        canonicalized_list[i] = current;\n+      }\n+      i++;\n@@ -127,0 +149,40 @@\n+    canonicalized_list[i] = '\\0';\n+    return canonicalized_list;\n+  }\n+};\n+\n+class PhaseNameValidator {\n+ private:\n+  bool _valid;\n+  char* _bad;\n+\n+ public:\n+  PhaseNameValidator(ccstrlist option, uint64_t& mask) : _valid(true), _bad(nullptr) {\n+    for (PhaseNameIter iter(option); *iter != NULL && _valid; ++iter) {\n+\n+      CompilerPhaseType cpt = find_phase(*iter);\n+      if (PHASE_NONE == cpt) {\n+        const size_t len = MIN2<size_t>(strlen(*iter), 63) + 1;  \/\/ cap len to a value we know is enough for all phase descriptions\n+        _bad = NEW_C_HEAP_ARRAY(char, len, mtCompiler);\n+        \/\/ strncpy always writes len characters. If the source string is shorter, the function fills the remaining bytes with NULLs.\n+        strncpy(_bad, *iter, len);\n+        _valid = false;\n+      } else {\n+        assert(cpt < 64, \"out of bounds\");\n+        mask |= CompilerPhaseTypeHelper::to_bitmask(cpt);\n+      }\n+    }\n+  }\n+\n+  ~PhaseNameValidator() {\n+    if (_bad != NULL) {\n+      FREE_C_HEAP_ARRAY(char, _bad);\n+    }\n+  }\n+\n+  bool is_valid() const {\n+    return _valid;\n+  }\n+\n+  const char* what() const {\n+    return _bad;\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":155,"deletions":93,"binary":false,"changes":248,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test PrintIdealPhaseTest\n+ * @summary Checks that -XX:CompileCommand=PrintIdealPhase,... works\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @requires vm.debug == true & vm.compiler2.enabled\n+ * @run driver compiler.oracle.PrintIdealPhaseTest\n+ *\/\n+\n+package compiler.oracle;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class PrintIdealPhaseTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        new PrintIdealPhaseTest();\n+    }\n+\n+    PrintIdealPhaseTest() throws Exception {\n+        \/\/ The Phases specified here will be exchanged for the enum Phase in compiler.lib.ir_framework when it's done\n+\n+        \/\/ Test -XX:CompileCommand=PrintIdealPhase,*::test,CCP1\n+        List<String> expectedPhases = new ArrayList<String>();\n+        expectedPhases.add(\"CCP1\");\n+        runTest(\"CCP1\", expectedPhases, \"hotspot_log_1.log\", true);\n+        runTest(\"FISH\", expectedPhases, \"hotspot_log_1f.log\", false);\n+\n+        \/\/ Test -XX:CompileCommand=PrintIdealPhase,*::test,MATCHING\n+        expectedPhases.clear();\n+        expectedPhases.add(\"MATCHING\");\n+        runTest(\"MATCHING\", expectedPhases, \"hotspot_log_2.log\", true);\n+\n+        \/\/ Test -XX:CompileCommand=PrintIdealPhase,*::test,CCP_1,AFTER_MATCHING\n+        expectedPhases.add(\"CCP1\");\n+        runTest(\"MATCHING,CCP1\", expectedPhases, \"hotspot_log_3.log\", true);\n+    }\n+\n+    private void runTest(String cmdPhases, List<String> expectedPhases, String logFile, boolean valid) throws Exception {\n+        List<String> options = new ArrayList<String>();\n+        options.add(\"-Xbatch\");\n+        options.add(\"-XX:+PrintCompilation\");\n+        options.add(\"-XX:LogFile=\"+logFile);\n+        options.add(\"-XX:+IgnoreUnrecognizedVMOptions\");\n+        options.add(\"-XX:CompileCommand=PrintIdealPhase,\" + getTestClass() + \"::test,\" + cmdPhases);\n+        options.add(getTestClass());\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJvm(options);\n+        if (valid) {\n+            oa.shouldHaveExitValue(0)\n+            .shouldContain(\"CompileCommand: PrintIdealPhase compiler\/oracle\/PrintIdealPhaseTest$TestMain.test const char* PrintIdealPhase = '\"+cmdPhases.replace(',', ' ')+\"'\")\n+            .shouldNotContain(\"CompileCommand: An error occurred during parsing\")\n+            .shouldNotContain(\"Error: Unrecognized phase name in PrintIdealPhase:\")\n+            .shouldNotContain(\"# A fatal error has been detected by the Java Runtime Environment\");\n+\n+             \/\/ Check that all the expected phases matches what can be found in the compilation log file\n+             HashSet<String> loggedPhases = parseLogFile(logFile);\n+             System.out.println(\"Logged phases:\");\n+             for (String loggedPhase : loggedPhases) {\n+                 System.out.println(\"loggedPhase: \"+ loggedPhase);\n+             }\n+             for (String expectedPhase : expectedPhases) {\n+                 System.out.println(\"Looking for phase: \" + expectedPhase);\n+\n+                 Asserts.assertTrue(loggedPhases.contains(expectedPhase), \"Must find specified phase: \" + expectedPhase);\n+                 loggedPhases.remove(expectedPhase);\n+             }\n+             Asserts.assertTrue(loggedPhases.isEmpty(), \"Expect no other phases\");\n+        } else {\n+            \/\/ Check that we don't pass even though bad phase names where given\n+            oa.shouldHaveExitValue(0)\n+            .shouldContain(\"CompileCommand: An error occurred during parsing\")\n+            .shouldContain(\"Error: Unrecognized phase name in PrintIdealPhase:\");\n+        }\n+    }\n+\n+    private HashSet<String> parseLogFile(String logFile) {\n+        String printIdealTag = \"<ideal\";\n+        Pattern compilePhasePattern = Pattern.compile(\"compile_phase='([a-zA-Z0-9 ]+)'\");\n+        HashSet<String> phasesFound = new HashSet<>();\n+\n+        try (var br = Files.newBufferedReader(Paths.get(logFile))) {\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                if (line.startsWith(printIdealTag)) {\n+                    Matcher matcher = compilePhasePattern.matcher(line);\n+                    if (matcher.find()) {\n+                        phasesFound.add(matcher.group(1));\n+                    } else {\n+                        throw new Error(\"Failed to match compile_phase in file: \" + logFile);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new Error(\"Failed to read \" + logFile + \" data: \" + e, e);\n+        }\n+        return phasesFound;\n+    }\n+\n+    \/\/ Test class that is invoked by the sub process\n+    public String getTestClass() {\n+        return TestMain.class.getName();\n+    }\n+\n+    public static class TestMain {\n+        public static void main(String[] args) {\n+            for (int i = 0; i < 20_000; i++) {\n+                test(i);\n+            }\n+        }\n+\n+        static void test(int i) {\n+            if ((i % 1000) == 0) {\n+                System.out.println(\"Hello World!\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/oracle\/PrintIdealPhaseTest.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"}]}