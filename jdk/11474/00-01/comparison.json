{"files":[{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240275\n+ * @library \/test\/lib\n+ * @run main\/othervm KeepAliveStreamFinalizer\n+ * @summary HttpsURLConnection: connection must not be reused after finalization\n+ *\/\n+\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+\n+public class KeepAliveStreamFinalizer {\n+\n+    static Server server;\n+    private static volatile String failureReason;\n+\n+    static class Server extends Thread {\n+        final ServerSocket srv;\n+        static final byte[] requestEnd = new byte[] {'\\r', '\\n', '\\r', '\\n'};\n+\n+        Server(ServerSocket s) {\n+            srv = s;\n+        }\n+\n+        boolean readOneRequest(InputStream is) throws IOException {\n+            int requestEndCount = 0, r;\n+            while ((r = is.read()) != -1) {\n+                if (r == requestEnd[requestEndCount]) {\n+                    requestEndCount++;\n+                    if (requestEndCount == 4) {\n+                        return true;\n+                    }\n+                } else {\n+                    requestEndCount = 0;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void run() {\n+            try {\n+                while (true) {\n+                    Socket ss = srv.accept();\n+                    Thread t1 = new Thread(new Runnable() {\n+                        public void run() {\n+                            try {\n+                                InputStream in = ss.getInputStream();\n+                                OutputStream out = ss.getOutputStream();\n+                                while (readOneRequest(in)) {\n+                                    out.write(\"HTTP\/1.1 200 OK\\r\\nConnection: Keep-Alive\\r\\nContent-Length: 1\\r\\n\\r\\na\".getBytes());\n+                                    out.flush();\n+                                }\n+                                in.close();\n+                                out.close();\n+                                ss.close();\n+                            } catch (Exception e) {\n+                                e.printStackTrace();\n+                            }\n+                        }\n+                    });\n+                    t1.setDaemon(true);\n+                    t1.start();\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress address = startHttpServer();\n+        clientHttpCalls(address);\n+        if (failureReason != null) {\n+            throw new RuntimeException(failureReason);\n+        }\n+    }\n+\n+    public static InetSocketAddress startHttpServer() throws Exception {\n+        InetAddress localHost = InetAddress.getLoopbackAddress();\n+        InetSocketAddress address = new InetSocketAddress(localHost, 0);\n+        ServerSocket serverSocket = new ServerSocket();\n+        serverSocket.bind(address);\n+        server = new Server(serverSocket);\n+        server.setDaemon(true);\n+        server.start();\n+        return (InetSocketAddress) serverSocket.getLocalSocketAddress();\n+    }\n+\n+    public static void doRequest(URL url) throws IOException {\n+        HttpsURLConnection c = (HttpsURLConnection)url.openConnection();\n+        c.setRequestMethod(\"POST\");\n+        c.setDoOutput(true);\n+        OutputStreamWriter out = new OutputStreamWriter(c.getOutputStream());\n+        out.write(\"test\");\n+        out.close();\n+        int responseCode = c.getResponseCode();\n+        \/\/ Fully reading the body causes the HttpsClient to be added to the KeepAliveCache immediately,\n+        \/\/ which avoids this issue since GC will not finalize the HttpsClient.\n+    }\n+\n+    public static void clientHttpCalls(InetSocketAddress address) throws Exception {\n+        try {\n+            System.out.println(\"http server listen on: \" + address.getPort());\n+            String hostAddr = address.getAddress().getHostAddress();\n+            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n+            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + address.getPort() + \"\/\";\n+\n+            URL testUrl = new URL(baseURLStr);\n+\n+            \/\/ CheckFinalizeSocketFactory is not a real SSLSocketFactory;\n+            \/\/ it produces regular non-SSL sockets. Effectively, the request\n+            \/\/ is made over http.\n+            HttpsURLConnection.setDefaultSSLSocketFactory(new CheckFinalizeSocketFactory());\n+            \/\/ now perform up to 3 requests; with the broken KeepAliveStream finalizer,\n+            \/\/ the second request usually attempts to use a finalized socket\n+            for (int i = 0; i < 3; i++) {\n+                System.out.println(\"Request #\" + (i + 1));\n+                doRequest(testUrl);\n+                System.gc();\n+                Thread.sleep(100);\n+                if (failureReason != null) break;\n+            }\n+        } finally {\n+            server.srv.close();\n+        }\n+    }\n+\n+    static class CheckFinalizeSocket extends SSLSocket {\n+        private volatile boolean finalized;\n+        public void finalize() throws Throwable {\n+            System.out.println(\"In finalize\");\n+            super.finalize();\n+            finalized = true;\n+        }\n+\n+        @Override\n+        public InputStream getInputStream() throws IOException {\n+            if (finalized) {\n+                System.out.println(failureReason = \"getInputStream called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            return super.getInputStream();\n+        }\n+\n+        @Override\n+        public OutputStream getOutputStream() throws IOException {\n+            if (finalized) {\n+                System.out.println(failureReason = \"getOutputStream called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            return super.getOutputStream();\n+        }\n+\n+        @Override\n+        public synchronized void close() throws IOException {\n+            if (finalized) {\n+                System.out.println(failureReason = \"close called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            super.close();\n+        }\n+\n+        \/\/ required abstract method overrides\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) { }\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) { }\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+        @Override\n+        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void startHandshake() throws IOException { }\n+        @Override\n+        public void setUseClientMode(boolean mode) { }\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+        @Override\n+        public void setNeedClientAuth(boolean need) { }\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setWantClientAuth(boolean want) { }\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) { }\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return false;\n+        }\n+    }\n+\n+    static class CheckFinalizeSocketFactory extends SSLSocketFactory {\n+\n+        @Override\n+        public Socket createSocket() throws IOException {\n+            return new CheckFinalizeSocket();\n+        }\n+        \/\/ required abstract method overrides\n+        @Override\n+        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public String[] getDefaultCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamFinalizer.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"}]}