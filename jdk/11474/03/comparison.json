{"files":[{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.util.EventObject;\n-import java.net.URL;\n-\n-\/**\n- * ProgressEvent represents an progress event in monitering network input stream.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-@SuppressWarnings(\"serial\")  \/\/ never serialized\n-public class ProgressEvent extends EventObject  {\n-    \/\/ URL of the stream\n-    private URL url;\n-    \/\/ content type of the stream\n-    private String contentType;\n-    \/\/ method associated with URL\n-    private String method;\n-    \/\/ bytes read\n-    private long progress;\n-    \/\/ bytes expected\n-    private long expected;\n-    \/\/ the last thing to happen\n-    private ProgressSource.State state;\n-\n-    \/**\n-     * Construct a ProgressEvent object.\n-     *\/\n-    public ProgressEvent(ProgressSource source, URL url, String method, String contentType, ProgressSource.State state, long progress, long expected) {\n-        super(source);\n-        this.url = url;\n-        this.method = method;\n-        this.contentType = contentType;\n-        this.progress = progress;\n-        this.expected = expected;\n-        this.state = state;\n-    }\n-\n-    \/**\n-     * Return URL related to the progress.\n-     *\/\n-    public URL getURL()\n-    {\n-        return url;\n-    }\n-\n-    \/**\n-     * Return method associated with URL.\n-     *\/\n-    public String getMethod()\n-    {\n-        return method;\n-    }\n-\n-    \/**\n-     * Return content type of the URL.\n-     *\/\n-    public String getContentType()\n-    {\n-        return contentType;\n-    }\n-\n-    \/**\n-     * Return current progress value.\n-     *\/\n-    public long getProgress()\n-    {\n-        return progress;\n-    }\n-\n-    \/**\n-     * Return expected maximum progress value; -1 if expected is unknown.\n-     *\/\n-    public long getExpected() {\n-        return expected;\n-    }\n-\n-    \/**\n-     * Return state.\n-     *\/\n-    public ProgressSource.State getState() {\n-        return state;\n-    }\n-\n-    public String toString()    {\n-        return getClass().getName() + \"[url=\" + url + \", method=\" + method + \", state=\" + state\n-             + \", content-type=\" + contentType + \", progress=\" + progress + \", expected=\" + expected + \"]\";\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressEvent.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.util.EventListener;\n-\n-\/**\n- * ProgressListener is an interface to be implemented by parties\n- * interested to be notified of progress in network input stream.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public interface ProgressListener extends EventListener\n-{\n-    \/**\n-     * Start progress.\n-     *\/\n-    public void progressStart(ProgressEvent evt);\n-\n-    \/**\n-     * Update progress.\n-     *\/\n-    public void progressUpdate(ProgressEvent evt);\n-\n-    \/**\n-     * Finish progress.\n-     *\/\n-    public void progressFinish(ProgressEvent evt);\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressListener.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.net.URL;\n-\n-\/**\n- * ProgressMeteringPolicy is an interface for determining progress metering policy.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public interface ProgressMeteringPolicy\n-{\n-    \/**\n-     * Return true if metering should be turned on for a particular network input stream.\n-     *\/\n-    public boolean shouldMeterInput(URL url, String method);\n-\n-    \/**\n-     * Return update notification threshold.\n-     *\/\n-    public int getProgressUpdateThreshold();\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressMeteringPolicy.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,246 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.net;\n-\n-import java.util.ArrayList;\n-import java.util.Iterator;\n-import java.net.URL;\n-\n-\/**\n- * ProgressMonitor is a class for monitoring progress in network input stream.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public class ProgressMonitor\n-{\n-    \/**\n-     * Return default ProgressMonitor.\n-     *\/\n-    public static synchronized ProgressMonitor getDefault() {\n-        return pm;\n-    }\n-\n-    \/**\n-     * Change default ProgressMonitor implementation.\n-     *\/\n-    public static synchronized void setDefault(ProgressMonitor m)   {\n-        if (m != null)\n-            pm = m;\n-    }\n-\n-    \/**\n-     * Change progress metering policy.\n-     *\/\n-    public static synchronized void setMeteringPolicy(ProgressMeteringPolicy policy)    {\n-        if (policy != null)\n-            meteringPolicy = policy;\n-    }\n-\n-\n-    \/**\n-     * Return a snapshot of the ProgressSource list\n-     *\/\n-    public ArrayList<ProgressSource> getProgressSources()    {\n-        ArrayList<ProgressSource> snapshot = new ArrayList<>();\n-\n-        try {\n-            synchronized(progressSourceList)    {\n-                for (ProgressSource pi : progressSourceList) {\n-                    \/\/ Clone ProgressSource and add to snapshot\n-                    snapshot.add((ProgressSource)pi.clone());\n-                }\n-            }\n-        }\n-        catch(CloneNotSupportedException e) {\n-            e.printStackTrace();\n-        }\n-\n-        return snapshot;\n-    }\n-\n-    \/**\n-     * Return update notification threshold\n-     *\/\n-    public synchronized int getProgressUpdateThreshold()    {\n-        return meteringPolicy.getProgressUpdateThreshold();\n-    }\n-\n-    \/**\n-     * Return true if metering should be turned on\n-     * for a particular URL input stream.\n-     *\/\n-    public boolean shouldMeterInput(URL url, String method) {\n-        return meteringPolicy.shouldMeterInput(url, method);\n-    }\n-\n-    \/**\n-     * Register progress source when progress is began.\n-     *\/\n-    public void registerSource(ProgressSource pi) {\n-\n-        synchronized(progressSourceList)    {\n-            if (progressSourceList.contains(pi))\n-                return;\n-\n-            progressSourceList.add(pi);\n-        }\n-\n-        \/\/ Notify only if there is at least one listener\n-        if (progressListenerList.size() > 0)\n-        {\n-            \/\/ Notify progress listener if there is progress change\n-            ArrayList<ProgressListener> listeners;\n-\n-            \/\/ Copy progress listeners to another list to avoid holding locks\n-            synchronized(progressListenerList) {\n-                listeners = new ArrayList<>(progressListenerList);\n-            }\n-\n-            \/\/ Fire event on each progress listener\n-            for (ProgressListener pl : listeners) {\n-                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());\n-                pl.progressStart(pe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Unregister progress source when progress is finished.\n-     *\/\n-    public void unregisterSource(ProgressSource pi) {\n-\n-        synchronized(progressSourceList) {\n-            \/\/ Return if ProgressEvent does not exist\n-            if (progressSourceList.contains(pi) == false)\n-                return;\n-\n-            \/\/ Close entry and remove from map\n-            pi.close();\n-            progressSourceList.remove(pi);\n-        }\n-\n-        \/\/ Notify only if there is at least one listener\n-        if (progressListenerList.size() > 0)\n-        {\n-            \/\/ Notify progress listener if there is progress change\n-            ArrayList<ProgressListener> listeners;\n-\n-            \/\/ Copy progress listeners to another list to avoid holding locks\n-            synchronized(progressListenerList) {\n-                listeners = new ArrayList<>(progressListenerList);\n-            }\n-\n-            \/\/ Fire event on each progress listener\n-            for (ProgressListener pl : listeners) {\n-                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());\n-                pl.progressFinish(pe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Progress source is updated.\n-     *\/\n-    public void updateProgress(ProgressSource pi)   {\n-\n-        synchronized (progressSourceList)   {\n-            if (progressSourceList.contains(pi) == false)\n-                return;\n-        }\n-\n-        \/\/ Notify only if there is at least one listener\n-        if (progressListenerList.size() > 0)\n-        {\n-            \/\/ Notify progress listener if there is progress change\n-            ArrayList<ProgressListener> listeners;\n-\n-            \/\/ Copy progress listeners to another list to avoid holding locks\n-            synchronized(progressListenerList)  {\n-                listeners = new ArrayList<>(progressListenerList);\n-            }\n-\n-            \/\/ Fire event on each progress listener\n-            for (ProgressListener pl : listeners) {\n-                ProgressEvent pe = new ProgressEvent(pi, pi.getURL(), pi.getMethod(), pi.getContentType(), pi.getState(), pi.getProgress(), pi.getExpected());\n-                pl.progressUpdate(pe);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Add progress listener in progress monitor.\n-     *\/\n-    public void addProgressListener(ProgressListener l) {\n-        synchronized(progressListenerList) {\n-            progressListenerList.add(l);\n-        }\n-    }\n-\n-    \/**\n-     * Remove progress listener from progress monitor.\n-     *\/\n-    public void removeProgressListener(ProgressListener l) {\n-        synchronized(progressListenerList) {\n-            progressListenerList.remove(l);\n-        }\n-    }\n-\n-    \/\/ Metering policy\n-    private static ProgressMeteringPolicy meteringPolicy = new DefaultProgressMeteringPolicy();\n-\n-    \/\/ Default implementation\n-    private static ProgressMonitor pm = new ProgressMonitor();\n-\n-    \/\/ ArrayList for outstanding progress sources\n-    private ArrayList<ProgressSource> progressSourceList = new ArrayList<ProgressSource>();\n-\n-    \/\/ ArrayList for progress listeners\n-    private ArrayList<ProgressListener> progressListenerList = new ArrayList<ProgressListener>();\n-}\n-\n-\n-\/**\n- * Default progress metering policy.\n- *\/\n-class DefaultProgressMeteringPolicy implements ProgressMeteringPolicy  {\n-    \/**\n-     * Return true if metering should be turned on for a particular network input stream.\n-     *\/\n-    public boolean shouldMeterInput(URL url, String method)\n-    {\n-        \/\/ By default, no URL input stream is metered for\n-        \/\/ performance reason.\n-        return false;\n-    }\n-\n-    \/**\n-     * Return update notification threshold.\n-     *\/\n-    public int getProgressUpdateThreshold() {\n-        \/\/ 8K - same as default I\/O buffer size\n-        return 8192;\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressMonitor.java","additions":0,"deletions":246,"binary":false,"changes":246,"status":"deleted"},{"patch":"@@ -1,210 +0,0 @@\n-\/*\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package sun.net;\n-\n-import java.net.URL;\n-\n-\/**\n- * ProgressSource represents the source of progress changes.\n- *\n- * @author Stanley Man-Kit Ho\n- *\/\n-public class ProgressSource\n-{\n-    public enum State { NEW, CONNECTED, UPDATE, DELETE };\n-\n-    \/\/ URL\n-    private URL url;\n-    \/\/ URL method\n-    private String method;\n-    \/\/ Content type\n-    private String contentType;\n-    \/\/ bytes read\n-    private long progress = 0;\n-    \/\/ last bytes read\n-    private long lastProgress = 0;\n-    \/\/bytes expected\n-    private long expected = -1;\n-    \/\/ the last thing to happen with this source\n-    private State state;\n-    \/\/ connect flag\n-    private boolean connected = false;\n-    \/\/ threshold for notification\n-    private int threshold = 8192;\n-    \/\/ progress monitor\n-    private ProgressMonitor progressMonitor;\n-\n-    \/**\n-     * Construct progress source object.\n-     *\/\n-    public ProgressSource(URL url, String method) {\n-        this(url, method, -1);\n-    }\n-\n-    \/**\n-     * Construct progress source object.\n-     *\/\n-    public ProgressSource(URL url, String method, long expected)  {\n-        this.url = url;\n-        this.method = method;\n-        this.contentType = \"content\/unknown\";\n-        this.progress = 0;\n-        this.lastProgress = 0;\n-        this.expected = expected;\n-        this.state = State.NEW;\n-        this.progressMonitor = ProgressMonitor.getDefault();\n-        this.threshold = progressMonitor.getProgressUpdateThreshold();\n-    }\n-\n-    public boolean connected() {\n-        if (!connected) {\n-            connected = true;\n-            state = State.CONNECTED;\n-            return false;\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Close progress source.\n-     *\/\n-    public void close() {\n-        state = State.DELETE;\n-    }\n-\n-    \/**\n-     * Return URL of progress source.\n-     *\/\n-    public URL getURL() {\n-        return url;\n-    }\n-\n-    \/**\n-     * Return method of URL.\n-     *\/\n-    public String getMethod()  {\n-        return method;\n-    }\n-\n-    \/**\n-     * Return content type of URL.\n-     *\/\n-    public String getContentType()  {\n-        return contentType;\n-    }\n-\n-    \/\/ Change content type\n-    public void setContentType(String ct)  {\n-        contentType = ct;\n-    }\n-\n-    \/**\n-     * Return current progress.\n-     *\/\n-    public long getProgress()  {\n-        return progress;\n-    }\n-\n-    \/**\n-     * Return expected maximum progress; -1 if expected is unknown.\n-     *\/\n-    public long getExpected() {\n-        return expected;\n-    }\n-\n-    \/**\n-     * Return state.\n-     *\/\n-    public State getState() {\n-        return state;\n-    }\n-\n-    \/**\n-     * Begin progress tracking.\n-     *\/\n-    public void beginTracking() {\n-        progressMonitor.registerSource(this);\n-    }\n-\n-    \/**\n-     * Finish progress tracking.\n-     *\/\n-    public void finishTracking() {\n-        progressMonitor.unregisterSource(this);\n-    }\n-\n-    \/**\n-     * Update progress.\n-     *\/\n-    public void updateProgress(long latestProgress, long expectedProgress) {\n-        lastProgress = progress;\n-        progress = latestProgress;\n-        expected = expectedProgress;\n-\n-        if (connected() == false)\n-            state = State.CONNECTED;\n-        else\n-            state = State.UPDATE;\n-\n-        \/\/ The threshold effectively divides the progress into\n-        \/\/ different set of ranges:\n-        \/\/\n-        \/\/      Range 0: 0..threshold-1,\n-        \/\/      Range 1: threshold .. 2*threshold-1\n-        \/\/      ....\n-        \/\/      Range n: n*threshold .. (n+1)*threshold-1\n-        \/\/\n-        \/\/ To determine which range the progress belongs to, it\n-        \/\/ would be calculated as follow:\n-        \/\/\n-        \/\/      range number = progress \/ threshold\n-        \/\/\n-        \/\/ Notification should only be triggered when the current\n-        \/\/ progress and the last progress are in different ranges,\n-        \/\/ i.e. they have different range numbers.\n-        \/\/\n-        \/\/ Using this range scheme, notification will be generated\n-        \/\/ only once when the progress reaches each range.\n-        \/\/\n-        if (lastProgress \/ threshold != progress \/ threshold)   {\n-            progressMonitor.updateProgress(this);\n-        }\n-\n-        \/\/ Detect read overrun\n-        if (expected != -1) {\n-            if (progress >= expected && progress != 0)\n-                close();\n-        }\n-    }\n-\n-    public Object clone() throws CloneNotSupportedException {\n-        return super.clone();\n-    }\n-\n-    public String toString()    {\n-        return getClass().getName() + \"[url=\" + url + \", method=\" + method + \", state=\" + state\n-            + \", content-type=\" + contentType + \", progress=\" + progress + \", expected=\" + expected + \"]\";\n-    }\n-}\n","filename":"src\/java.base\/share\/classes\/sun\/net\/ProgressSource.java","additions":0,"deletions":210,"binary":false,"changes":210,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import sun.net.ProgressSource;\n@@ -45,1 +44,0 @@\n-    protected ProgressSource pi;\n@@ -48,1 +46,1 @@\n-    public MeteredStream(InputStream is, ProgressSource pi, long expected)\n+    public MeteredStream(InputStream is, long expected)\n@@ -52,1 +50,0 @@\n-        this.pi = pi;\n@@ -54,4 +51,0 @@\n-\n-        if (pi != null) {\n-            pi.updateProgress(0, expected);\n-        }\n@@ -84,3 +77,0 @@\n-        if (pi != null)\n-            pi.updateProgress(count, expected);\n-\n@@ -173,2 +163,0 @@\n-            if (pi != null)\n-                pi.finishTracking();\n@@ -244,13 +232,0 @@\n-\n-    @SuppressWarnings(\"removal\")\n-    protected void finalize() throws Throwable {\n-        try {\n-            close();\n-            if (pi != null)\n-                pi.close();\n-        }\n-        finally {\n-            \/\/ Call super class\n-            super.finalize();\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/MeteredStream.java","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-import sun.net.ProgressSource;\n@@ -744,1 +743,1 @@\n-    public boolean parseHTTP(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)\n+    public boolean parseHTTP(MessageHeader responses, HttpURLConnection httpuc)\n@@ -761,1 +760,1 @@\n-            return (parseHTTPHeader(responses, pi, httpuc));\n+            return (parseHTTPHeader(responses, httpuc));\n@@ -788,1 +787,1 @@\n-                    return parseHTTP(responses, pi, httpuc);\n+                    return parseHTTP(responses, httpuc);\n@@ -808,1 +807,1 @@\n-    private boolean parseHTTPHeader(MessageHeader responses, ProgressSource pi, HttpURLConnection httpuc)\n+    private boolean parseHTTPHeader(MessageHeader responses, HttpURLConnection httpuc)\n@@ -954,1 +953,1 @@\n-                        return parseHTTP(responses, pi, httpuc);\n+                        return parseHTTP(responses, httpuc);\n@@ -997,1 +996,1 @@\n-            return parseHTTPHeader(responses, pi, httpuc);\n+            return parseHTTPHeader(responses, httpuc);\n@@ -1070,5 +1069,0 @@\n-            if (pi != null) {\n-                \/\/ Progress monitor is enabled\n-                pi.setContentType(responses.findValue(\"content-type\"));\n-            }\n-\n@@ -1082,1 +1076,1 @@\n-                serverInput = new KeepAliveStream(serverInput, pi, cl, this);\n+                serverInput = new KeepAliveStream(serverInput, cl, this);\n@@ -1086,1 +1080,1 @@\n-                serverInput = new MeteredStream(serverInput, pi, cl);\n+                serverInput = new MeteredStream(serverInput, cl);\n@@ -1089,26 +1083,0 @@\n-        else if (cl == -1)  {\n-            \/\/ In this case, content length is unknown - the input\n-            \/\/ stream would simply be a regular InputStream or\n-            \/\/ ChunkedInputStream.\n-\n-            if (pi != null) {\n-                \/\/ Progress monitoring is enabled.\n-\n-                pi.setContentType(responses.findValue(\"content-type\"));\n-\n-                \/\/ Wrap MeteredStream for tracking indeterministic\n-                \/\/ progress, even if the input stream is ChunkedInputStream.\n-                serverInput = new MeteredStream(serverInput, pi, cl);\n-            }\n-            else    {\n-                \/\/ Progress monitoring is disabled, and there is no\n-                \/\/ need to wrap an unknown length input stream.\n-\n-                \/\/ ** This is an no-op **\n-            }\n-        }\n-        else    {\n-            if (pi != null)\n-                pi.finishTracking();\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import sun.net.ProgressSource;\n@@ -59,2 +58,2 @@\n-    public KeepAliveStream(InputStream is, ProgressSource pi, long expected, HttpClient hc)  {\n-        super(is, pi, expected);\n+    public KeepAliveStream(InputStream is, long expected, HttpClient hc) {\n+        super(is, expected);\n@@ -104,3 +103,0 @@\n-                if (pi != null)\n-                    pi.finishTracking();\n-\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveStream.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import sun.net.*;\n@@ -85,1 +84,0 @@\n-\n@@ -87,7 +85,0 @@\n-\n-                    \/\/ Check if URL should be metered\n-                    boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, \"GET\");\n-                    if (meteredInput)   {\n-                        ProgressSource pi = new ProgressSource(url, \"GET\", file.length());\n-                        is = new MeteredStream(is, pi, file.length());\n-                    }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/file\/FileURLConnection.java","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -59,2 +59,0 @@\n-import sun.net.ProgressSource;\n-import sun.net.ProgressMonitor;\n@@ -469,11 +467,1 @@\n-\n-                    \/\/ Check if URL should be metered\n-                    boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, \"GET\");\n-                    ProgressSource pi = null;\n-\n-                    if (meteredInput) {\n-                        pi = new ProgressSource(url, \"GET\", l);\n-                        pi.beginTracking();\n-                    }\n-\n-                    is = new MeteredStream(is, pi, l);\n+                    is = new MeteredStream(is, l);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/ftp\/FtpURLConnection.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-import sun.net.*;\n+import sun.net.NetProperties;\n+import sun.net.NetworkClient;\n@@ -387,3 +388,0 @@\n-    \/* Progress source *\/\n-    protected ProgressSource pi;\n-\n@@ -1334,1 +1332,1 @@\n-                http.parseHTTP(responses, pi, this);\n+                http.parseHTTP(responses, this);\n@@ -1665,8 +1663,0 @@\n-                \/\/ Check if URL should be metered\n-                boolean meteredInput = ProgressMonitor.getDefault().shouldMeterInput(url, method);\n-\n-                if (meteredInput)   {\n-                    pi = new ProgressSource(url, method);\n-                    pi.beginTracking();\n-                }\n-\n@@ -1682,1 +1672,1 @@\n-                http.parseHTTP(responses, pi, this);\n+                http.parseHTTP(responses, this);\n@@ -1946,4 +1936,0 @@\n-                    if (pi != null) {\n-                        pi.finishTracking();\n-                        pi = null;\n-                    }\n@@ -2169,3 +2155,1 @@\n-                \/\/ There is no need to track progress in HTTP Tunneling,\n-                \/\/ so ProgressSource is null.\n-                http.parseHTTP(responses, null, this);\n+                http.parseHTTP(responses, this);\n@@ -3048,4 +3032,0 @@\n-        if (pi != null) {\n-            pi.finishTracking();\n-            pi = null;\n-        }\n@@ -3065,4 +3045,0 @@\n-        if (pi != null) {\n-            pi.finishTracking();\n-            pi = null;\n-        }\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/http\/HttpURLConnection.java","additions":5,"deletions":29,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-        Class<?> modulePrivateIntf = Class.forName(\"sun.net.ProgressListener\");\n+        Class<?> modulePrivateIntf = Class.forName(\"sun.net.PlatformSocketImpl\");\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProxyModuleMapping.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4333920 4994372\n- * @summary ChunkedEncoding unit test; MeteredStream\/ProgressData problem\n- * @modules java.base\/sun.net\n- *          jdk.httpserver\n- * @library \/test\/lib\n- * @run main ChunkedEncodingWithProgressMonitorTest\n- *\/\n-\n-import java.net.*;\n-import java.util.BitSet;\n-import sun.net.ProgressMeteringPolicy;\n-import sun.net.ProgressMonitor;\n-import sun.net.ProgressListener;\n-import sun.net.ProgressEvent;\n-\n-public class ChunkedEncodingWithProgressMonitorTest {\n-    public static void main (String[] args) throws Exception {\n-        ProgressMonitor.setMeteringPolicy(new MyProgressMeteringPolicy());\n-        ProgressListener listener = new MyProgressListener();\n-        ProgressMonitor.getDefault().addProgressListener(listener);\n-        ChunkedEncodingTest.test();\n-        ProgressMonitor.getDefault().removeProgressListener(listener);\n-\n-        if (flag.cardinality() != 3) {\n-            throw new RuntimeException(\"All three methods in ProgressListener\"+\n-                                       \" should be called. Yet the number of\"+\n-                                       \" methods actually called are \"+\n-                                       flag.cardinality());\n-        }\n-    }\n-\n-    static class MyProgressMeteringPolicy implements ProgressMeteringPolicy {\n-        \/**\n-         * Return true if metering should be turned on for a particular network input stream.\n-         *\/\n-        public boolean shouldMeterInput(URL url, String method) {\n-            return true;\n-        }\n-\n-        \/**\n-         * Return update notification threshold.\n-         *\/\n-        public int getProgressUpdateThreshold() {\n-            return 8192;\n-        }\n-    }\n-\n-    static BitSet flag = new BitSet(3);\n-\n-    static class MyProgressListener implements ProgressListener {\n-        \/**\n-         * Start progress.\n-         *\/\n-        public void progressStart(ProgressEvent evt) {\n-            System.out.println(\"start: received progressevent \"+evt);\n-            if (flag.nextSetBit(0) == -1)\n-                flag.set(0);\n-        }\n-\n-        \/**\n-         * Update progress.\n-         *\/\n-        public void progressUpdate(ProgressEvent evt) {\n-            System.out.println(\"update: received progressevent \"+evt);\n-            if (flag.nextSetBit(1) == -1)\n-                flag.set(1);\n-        }\n-\n-        \/**\n-         * Finish progress.\n-         *\/\n-        public void progressFinish(ProgressEvent evt) {\n-            System.out.println(\"finish: received progressevent \"+evt);\n-            if (flag.nextSetBit(2) == -1)\n-                flag.set(2);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/sun\/net\/www\/http\/ChunkedInputStream\/ChunkedEncodingWithProgressMonitorTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240275\n+ * @library \/test\/lib\n+ * @run main\/othervm KeepAliveStreamFinalizer\n+ * @summary HttpsURLConnection: connection must not be reused after finalization\n+ *\/\n+\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+\n+public class KeepAliveStreamFinalizer {\n+\n+    static Server server;\n+    private static volatile String failureReason;\n+\n+    static class Server extends Thread {\n+        final ServerSocket srv;\n+        static final byte[] requestEnd = new byte[] {'\\r', '\\n', '\\r', '\\n'};\n+\n+        Server(ServerSocket s) {\n+            srv = s;\n+        }\n+\n+        boolean readOneRequest(InputStream is) throws IOException {\n+            int requestEndCount = 0, r;\n+            while ((r = is.read()) != -1) {\n+                if (r == requestEnd[requestEndCount]) {\n+                    requestEndCount++;\n+                    if (requestEndCount == 4) {\n+                        return true;\n+                    }\n+                } else {\n+                    requestEndCount = 0;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        public void run() {\n+            try {\n+                while (true) {\n+                    Socket ss = srv.accept();\n+                    Thread t1 = new Thread(new Runnable() {\n+                        public void run() {\n+                            try {\n+                                InputStream in = ss.getInputStream();\n+                                OutputStream out = ss.getOutputStream();\n+                                while (readOneRequest(in)) {\n+                                    out.write(\"HTTP\/1.1 200 OK\\r\\nConnection: Keep-Alive\\r\\nContent-Length: 1\\r\\n\\r\\na\".getBytes());\n+                                    out.flush();\n+                                }\n+                                in.close();\n+                                out.close();\n+                                ss.close();\n+                            } catch (Exception e) {\n+                                e.printStackTrace();\n+                            }\n+                        }\n+                    });\n+                    t1.setDaemon(true);\n+                    t1.start();\n+                }\n+            } catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        InetSocketAddress address = startHttpServer();\n+        clientHttpCalls(address);\n+        if (failureReason != null) {\n+            throw new RuntimeException(failureReason);\n+        }\n+    }\n+\n+    public static InetSocketAddress startHttpServer() throws Exception {\n+        InetAddress localHost = InetAddress.getLoopbackAddress();\n+        InetSocketAddress address = new InetSocketAddress(localHost, 0);\n+        ServerSocket serverSocket = new ServerSocket();\n+        serverSocket.bind(address);\n+        server = new Server(serverSocket);\n+        server.setDaemon(true);\n+        server.start();\n+        return (InetSocketAddress) serverSocket.getLocalSocketAddress();\n+    }\n+\n+    public static void doRequest(URL url) throws IOException {\n+        HttpsURLConnection c = (HttpsURLConnection)url.openConnection();\n+        c.setRequestMethod(\"POST\");\n+        c.setDoOutput(true);\n+        OutputStreamWriter out = new OutputStreamWriter(c.getOutputStream());\n+        out.write(\"test\");\n+        out.close();\n+        int responseCode = c.getResponseCode();\n+        \/\/ Fully reading the body causes the HttpsClient to be added to the KeepAliveCache immediately,\n+        \/\/ which avoids this issue since GC will not finalize the HttpsClient.\n+    }\n+\n+    public static void clientHttpCalls(InetSocketAddress address) throws Exception {\n+        try {\n+            System.err.println(\"http server listen on: \" + address.getPort());\n+            String hostAddr = address.getAddress().getHostAddress();\n+            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n+            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + address.getPort() + \"\/\";\n+\n+            URL testUrl = new URL(baseURLStr);\n+\n+            \/\/ CheckFinalizeSocketFactory is not a real SSLSocketFactory;\n+            \/\/ it produces regular non-SSL sockets. Effectively, the request\n+            \/\/ is made over http.\n+            HttpsURLConnection.setDefaultSSLSocketFactory(new CheckFinalizeSocketFactory());\n+            \/\/ now perform up to 3 requests; with the broken KeepAliveStream finalizer,\n+            \/\/ the second request usually attempts to use a finalized socket\n+            for (int i = 0; i < 3; i++) {\n+                System.err.println(\"Request #\" + (i + 1));\n+                doRequest(testUrl);\n+                System.gc();\n+                Thread.sleep(100);\n+                if (failureReason != null) break;\n+            }\n+        } finally {\n+            server.srv.close();\n+        }\n+    }\n+\n+    static class CheckFinalizeSocket extends SSLSocket {\n+        private volatile boolean finalized;\n+        public void finalize() throws Throwable {\n+            System.err.println(\"In finalize\");\n+            super.finalize();\n+            finalized = true;\n+        }\n+\n+        @Override\n+        public InputStream getInputStream() throws IOException {\n+            if (finalized) {\n+                System.err.println(failureReason = \"getInputStream called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            return super.getInputStream();\n+        }\n+\n+        @Override\n+        public OutputStream getOutputStream() throws IOException {\n+            if (finalized) {\n+                System.err.println(failureReason = \"getOutputStream called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            return super.getOutputStream();\n+        }\n+\n+        @Override\n+        public synchronized void close() throws IOException {\n+            if (finalized) {\n+                System.err.println(failureReason = \"close called after finalize\");\n+                Thread.dumpStack();\n+            }\n+            super.close();\n+        }\n+\n+        \/\/ required abstract method overrides\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) { }\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) { }\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+        @Override\n+        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void startHandshake() throws IOException { }\n+        @Override\n+        public void setUseClientMode(boolean mode) { }\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+        @Override\n+        public void setNeedClientAuth(boolean need) { }\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setWantClientAuth(boolean want) { }\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) { }\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return false;\n+        }\n+    }\n+\n+    static class CheckFinalizeSocketFactory extends SSLSocketFactory {\n+\n+        @Override\n+        public Socket createSocket() throws IOException {\n+            return new CheckFinalizeSocket();\n+        }\n+        \/\/ required abstract method overrides\n+        @Override\n+        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public String[] getDefaultCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamFinalizer.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"}]}