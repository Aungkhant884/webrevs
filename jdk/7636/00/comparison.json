{"files":[{"patch":"@@ -563,0 +563,1 @@\n+, _has_irreducible_loops(false)\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  bool               _has_irreducible_loops;\n@@ -138,0 +139,1 @@\n+  bool has_irreducible_loops() const             { return _has_irreducible_loops; }\n@@ -165,0 +167,1 @@\n+  void set_has_irreducible_loops(bool f)         { _has_irreducible_loops = f; }\n","filename":"src\/hotspot\/share\/c1\/c1_Compilation.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-  intArray       _loop_map;            \/\/ caches the information if a block is contained in a loop\n+  GrowableArray<ResourceBitMap> _loop_map; \/\/ caches the information if a block is contained in a loop\n@@ -87,1 +87,1 @@\n-  int  mark_loops(BlockBegin* b, bool in_subroutine);\n+  BitMap& mark_loops(BlockBegin* b, bool in_subroutine);\n@@ -379,1 +379,4 @@\n-  _loop_map = intArray(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), 0);\n+  _loop_map = GrowableArray<ResourceBitMap>(BlockBegin::number_of_blocks(), BlockBegin::number_of_blocks(), ResourceBitMap());\n+  for (int i = 0; i < BlockBegin::number_of_blocks(); i++) {\n+    _loop_map.at(i).initialize(BlockBegin::number_of_blocks());\n+  }\n@@ -383,2 +386,17 @@\n-  \/\/ recursively iterate the control flow graph\n-  mark_loops(_bci2block->at(0), false);\n+  \/\/ The loop detection algorithm works as follows:\n+  \/\/ - We maintain the _loop_map, where for each block we have a bitmap indicating which loops contain this block.\n+  \/\/ - The CFG is recursively traversed (depth-first) and if we detect a loop, we assign the loop a unique number that is stored\n+  \/\/ in the bitmap associated with the loop header block. Until we return back through that loop header the bitmap contains\n+  \/\/ only a single bit corresponding to the loop number.\n+  \/\/ -  The bit is then propagated for all the blocks in the loop after we exit them (post-order). There could be multiple bits\n+  \/\/ of course in case of nested loops.\n+  \/\/ -  When we exit the loop header we remove that single bit and assign the real loop state for it.\n+  \/\/ -  Now, the tricky part here is how we detect irriducible loops. In the algorithm above the loop state bits\n+  \/\/ are propagated to the predecessors. If we encounter an irreducible loop (a loop with multiple heads) we would see\n+  \/\/ a node with some loop bit set that would then propagate back and be never cleared because we would\n+  \/\/ never go back through the original loop header. Therefore if there are any irreducible loops the bits in the states\n+  \/\/ for these loops are going to propagate back to the root.\n+  BitMap& loop_state = mark_loops(_bci2block->at(0), false);\n+  if (!loop_state.is_empty()) {\n+    compilation()->set_has_irreducible_loops(true);\n+  }\n@@ -390,0 +408,1 @@\n+  _loop_map.clear();\n@@ -401,4 +420,3 @@\n-    assert(_loop_map.at(block->block_id()) == 0, \"must not be set yet\");\n-    assert(0 <= _next_loop_index && _next_loop_index < BitsPerInt, \"_next_loop_index is used as a bit-index in integer\");\n-    _loop_map.at_put(block->block_id(), 1 << _next_loop_index);\n-    if (_next_loop_index < 31) _next_loop_index++;\n+    assert(_loop_map.at(block->block_id()).is_empty(), \"must not be set yet\");\n+    assert(0 <= _next_loop_index && _next_loop_index < BlockBegin::number_of_blocks(), \"_next_loop_index is too large\");\n+    _loop_map.at(block->block_id()).set_bit(_next_loop_index++);\n@@ -407,1 +425,1 @@\n-    assert(is_power_of_2((unsigned int)_loop_map.at(block->block_id())), \"exactly one bit must be set\");\n+    assert(_loop_map.at(block->block_id()).count_one_bits() == 1, \"exactly one bit must be set\");\n@@ -411,1 +429,1 @@\n-int BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {\n+BitMap& BlockListBuilder::mark_loops(BlockBegin* block, bool in_subroutine) {\n@@ -413,1 +431,0 @@\n-\n@@ -431,1 +448,2 @@\n-  intptr_t loop_state = 0;\n+  ResourceMark rm;\n+  ResourceBitMap loop_state(BlockBegin::number_of_blocks());\n@@ -434,1 +452,1 @@\n-    loop_state |= mark_loops(successor_at(block, i), in_subroutine);\n+    loop_state.set_union(mark_loops(successor_at(block, i), in_subroutine));\n@@ -444,1 +462,1 @@\n-  if (loop_state != 0 || in_subroutine ) {\n+  if (!loop_state.is_empty() || in_subroutine ) {\n@@ -451,8 +469,4 @@\n-    int header_loop_state = _loop_map.at(block_id);\n-    assert(is_power_of_2((unsigned)header_loop_state), \"exactly one bit must be set\");\n-\n-    \/\/ If the highest bit is set (i.e. when integer value is negative), the method\n-    \/\/ has 32 or more loops. This bit is never cleared because it is used for multiple loops\n-    if (header_loop_state >= 0) {\n-      clear_bits(loop_state, header_loop_state);\n-    }\n+    BitMap& header_loop_state = _loop_map.at(block_id);\n+    assert(header_loop_state.count_one_bits() == 1, \"exactly one bit must be set\");\n+    \/\/ remove the bit with the loop number for the state (header is outside of the loop)\n+    loop_state.set_difference(header_loop_state);\n@@ -462,2 +476,2 @@\n-  _loop_map.at_put(block_id, loop_state);\n-  return loop_state;\n+  _loop_map.at(block_id).set_from(loop_state);\n+  return _loop_map.at(block_id);\n@@ -2499,1 +2513,1 @@\n-        if (!entry->try_merge(cur_state)) {\n+        if (!entry->try_merge(cur_state, compilation()->has_irreducible_loops())) {\n@@ -2985,1 +2999,1 @@\n-    if (!sux->try_merge(end->state())) BAILOUT_(\"block join failed\", NULL);\n+    if (!sux->try_merge(end->state(), compilation()->has_irreducible_loops())) BAILOUT_(\"block join failed\", NULL);\n@@ -3139,1 +3153,1 @@\n-    base->std_entry()->merge(state);\n+    base->std_entry()->merge(state, compilation()->has_irreducible_loops());\n@@ -3222,1 +3236,1 @@\n-  target->merge(_osr_entry->end()->state());\n+  target->merge(_osr_entry->end()->state(), compilation()->has_irreducible_loops());\n@@ -3281,1 +3295,1 @@\n-  start_block->merge(_initial_state);\n+  start_block->merge(_initial_state, compilation->has_irreducible_loops());\n@@ -4032,1 +4046,1 @@\n-    callee_start_block->merge(callee_state);\n+    callee_start_block->merge(callee_state, compilation()->has_irreducible_loops());\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":45,"deletions":31,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -722,1 +722,1 @@\n-bool BlockBegin::try_merge(ValueStack* new_state) {\n+bool BlockBegin::try_merge(ValueStack* new_state, bool has_irreducible_loops) {\n@@ -763,1 +763,0 @@\n-\n@@ -766,1 +765,1 @@\n-        if (requires_phi || !SelectivePhiFunctions) {\n+        if (requires_phi || !SelectivePhiFunctions || has_irreducible_loops) {\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1782,2 +1782,5 @@\n-  bool try_merge(ValueStack* state);             \/\/ try to merge states at block begin\n-  void merge(ValueStack* state)                  { bool b = try_merge(state); assert(b, \"merge failed\"); }\n+  bool try_merge(ValueStack* state, bool has_irreducible_loops);  \/\/ try to merge states at block begin\n+  void merge(ValueStack* state, bool has_irreducible_loops) {\n+    bool b = try_merge(state, has_irreducible_loops);\n+    assert(b, \"merge failed\");\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_Instruction.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}