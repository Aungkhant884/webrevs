{"files":[{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/biasedLocking.hpp\"\n@@ -576,0 +575,1 @@\n+\n@@ -580,64 +580,2 @@\n-        bool success = false;\n-        uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;\n-        markWord mark = rcvr->mark();\n-        intptr_t hash = (intptr_t) markWord::no_hash;\n-        \/\/ Implies UseBiasedLocking.\n-        if (mark.has_bias_pattern()) {\n-          uintptr_t thread_ident;\n-          uintptr_t anticipated_bias_locking_value;\n-          thread_ident = (uintptr_t)istate->thread();\n-          anticipated_bias_locking_value =\n-            ((rcvr->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n-            ~(markWord::age_mask_in_place);\n-\n-          if (anticipated_bias_locking_value == 0) {\n-            \/\/ Already biased towards this thread, nothing to do.\n-            if (PrintBiasedLockingStatistics) {\n-              (* BiasedLocking::biased_lock_entry_count_addr())++;\n-            }\n-            success = true;\n-          } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n-            \/\/ Try to revoke bias.\n-            markWord header = rcvr->klass()->prototype_header();\n-            if (hash != markWord::no_hash) {\n-              header = header.copy_set_hash(hash);\n-            }\n-            if (rcvr->cas_set_mark(header, mark) == mark) {\n-              if (PrintBiasedLockingStatistics)\n-                (*BiasedLocking::revoked_lock_entry_count_addr())++;\n-            }\n-          } else if ((anticipated_bias_locking_value & epoch_mask_in_place) != 0) {\n-            \/\/ Try to rebias.\n-            markWord new_header( (intptr_t) rcvr->klass()->prototype_header().value() | thread_ident);\n-            if (hash != markWord::no_hash) {\n-              new_header = new_header.copy_set_hash(hash);\n-            }\n-            if (rcvr->cas_set_mark(new_header, mark) == mark) {\n-              if (PrintBiasedLockingStatistics) {\n-                (* BiasedLocking::rebiased_lock_entry_count_addr())++;\n-              }\n-            } else {\n-              InterpreterRuntime::monitorenter(THREAD, mon);\n-            }\n-            success = true;\n-          } else {\n-            \/\/ Try to bias towards thread in case object is anonymously biased.\n-            markWord header(mark.value() &\n-                            (markWord::biased_lock_mask_in_place |\n-                             markWord::age_mask_in_place | epoch_mask_in_place));\n-            if (hash != markWord::no_hash) {\n-              header = header.copy_set_hash(hash);\n-            }\n-            markWord new_header(header.value() | thread_ident);\n-            \/\/ Debugging hint.\n-            DEBUG_ONLY(mon->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n-            if (rcvr->cas_set_mark(new_header, header) == header) {\n-              if (PrintBiasedLockingStatistics) {\n-                (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;\n-              }\n-            } else {\n-              CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n-            }\n-            success = true;\n-          }\n-        }\n+\n+        assert(!UseBiasedLocking, \"Not implemented\");\n@@ -646,11 +584,9 @@\n-        if (!success) {\n-          markWord displaced = rcvr->mark().set_unlocked();\n-          mon->lock()->set_displaced_header(displaced);\n-          bool call_vm = UseHeavyMonitors;\n-          if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              mon->lock()->set_displaced_header(markWord::from_pointer(NULL));\n-            } else {\n-              CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n-            }\n+        markWord displaced = rcvr->mark().set_unlocked();\n+        mon->lock()->set_displaced_header(displaced);\n+        bool call_vm = UseHeavyMonitors;\n+        if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n+          \/\/ Is it simple recursive case?\n+          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            mon->lock()->set_displaced_header(markWord::from_pointer(NULL));\n+          } else {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -740,65 +676,2 @@\n-      bool success = false;\n-      uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;\n-\n-      markWord mark = lockee->mark();\n-      intptr_t hash = (intptr_t) markWord::no_hash;\n-      \/\/ implies UseBiasedLocking\n-      if (mark.has_bias_pattern()) {\n-        uintptr_t thread_ident;\n-        uintptr_t anticipated_bias_locking_value;\n-        thread_ident = (uintptr_t)istate->thread();\n-        anticipated_bias_locking_value =\n-          ((lockee->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n-          ~(markWord::age_mask_in_place);\n-\n-        if  (anticipated_bias_locking_value == 0) {\n-          \/\/ already biased towards this thread, nothing to do\n-          if (PrintBiasedLockingStatistics) {\n-            (* BiasedLocking::biased_lock_entry_count_addr())++;\n-          }\n-          success = true;\n-        } else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n-          \/\/ try revoke bias\n-          markWord header = lockee->klass()->prototype_header();\n-          if (hash != markWord::no_hash) {\n-            header = header.copy_set_hash(hash);\n-          }\n-          if (lockee->cas_set_mark(header, mark) == mark) {\n-            if (PrintBiasedLockingStatistics) {\n-              (*BiasedLocking::revoked_lock_entry_count_addr())++;\n-            }\n-          }\n-        } else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {\n-          \/\/ try rebias\n-          markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);\n-          if (hash != markWord::no_hash) {\n-            new_header = new_header.copy_set_hash(hash);\n-          }\n-          if (lockee->cas_set_mark(new_header, mark) == mark) {\n-            if (PrintBiasedLockingStatistics) {\n-              (* BiasedLocking::rebiased_lock_entry_count_addr())++;\n-            }\n-          } else {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-          }\n-          success = true;\n-        } else {\n-          \/\/ try to bias towards thread in case object is anonymously biased\n-          markWord header(mark.value() & (markWord::biased_lock_mask_in_place |\n-                                          markWord::age_mask_in_place | epoch_mask_in_place));\n-          if (hash != markWord::no_hash) {\n-            header = header.copy_set_hash(hash);\n-          }\n-          markWord new_header(header.value() | thread_ident);\n-          \/\/ debugging hint\n-          DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n-          if (lockee->cas_set_mark(new_header, header) == header) {\n-            if (PrintBiasedLockingStatistics) {\n-              (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;\n-            }\n-          } else {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-          }\n-          success = true;\n-        }\n-      }\n+\n+      assert(!UseBiasedLocking, \"Not implemented\");\n@@ -807,11 +680,9 @@\n-      if (!success) {\n-        markWord displaced = lockee->mark().set_unlocked();\n-        entry->lock()->set_displaced_header(displaced);\n-        bool call_vm = UseHeavyMonitors;\n-        if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n-          } else {\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-          }\n+      markWord displaced = lockee->mark().set_unlocked();\n+      entry->lock()->set_displaced_header(displaced);\n+      bool call_vm = UseHeavyMonitors;\n+      if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+        \/\/ Is it simple recursive case?\n+        if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+          entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n+        } else {\n+          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1645,68 +1516,2 @@\n-          int success = false;\n-          uintptr_t epoch_mask_in_place = markWord::epoch_mask_in_place;\n-\n-          markWord mark = lockee->mark();\n-          intptr_t hash = (intptr_t) markWord::no_hash;\n-          \/\/ implies UseBiasedLocking\n-          if (mark.has_bias_pattern()) {\n-            uintptr_t thread_ident;\n-            uintptr_t anticipated_bias_locking_value;\n-            thread_ident = (uintptr_t)istate->thread();\n-            anticipated_bias_locking_value =\n-              ((lockee->klass()->prototype_header().value() | thread_ident) ^ mark.value()) &\n-              ~(markWord::age_mask_in_place);\n-\n-            if  (anticipated_bias_locking_value == 0) {\n-              \/\/ already biased towards this thread, nothing to do\n-              if (PrintBiasedLockingStatistics) {\n-                (* BiasedLocking::biased_lock_entry_count_addr())++;\n-              }\n-              success = true;\n-            }\n-            else if ((anticipated_bias_locking_value & markWord::biased_lock_mask_in_place) != 0) {\n-              \/\/ try revoke bias\n-              markWord header = lockee->klass()->prototype_header();\n-              if (hash != markWord::no_hash) {\n-                header = header.copy_set_hash(hash);\n-              }\n-              if (lockee->cas_set_mark(header, mark) == mark) {\n-                if (PrintBiasedLockingStatistics)\n-                  (*BiasedLocking::revoked_lock_entry_count_addr())++;\n-              }\n-            }\n-            else if ((anticipated_bias_locking_value & epoch_mask_in_place) !=0) {\n-              \/\/ try rebias\n-              markWord new_header( (intptr_t) lockee->klass()->prototype_header().value() | thread_ident);\n-              if (hash != markWord::no_hash) {\n-                new_header = new_header.copy_set_hash(hash);\n-              }\n-              if (lockee->cas_set_mark(new_header, mark) == mark) {\n-                if (PrintBiasedLockingStatistics)\n-                  (* BiasedLocking::rebiased_lock_entry_count_addr())++;\n-              }\n-              else {\n-                CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-              }\n-              success = true;\n-            }\n-            else {\n-              \/\/ try to bias towards thread in case object is anonymously biased\n-              markWord header(mark.value() & (markWord::biased_lock_mask_in_place |\n-                                              markWord::age_mask_in_place |\n-                                              epoch_mask_in_place));\n-              if (hash != markWord::no_hash) {\n-                header = header.copy_set_hash(hash);\n-              }\n-              markWord new_header(header.value() | thread_ident);\n-              \/\/ debugging hint\n-              DEBUG_ONLY(entry->lock()->set_displaced_header(markWord((uintptr_t) 0xdeaddead));)\n-              if (lockee->cas_set_mark(new_header, header) == header) {\n-                if (PrintBiasedLockingStatistics)\n-                  (* BiasedLocking::anonymously_biased_lock_entry_count_addr())++;\n-              }\n-              else {\n-                CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-              }\n-              success = true;\n-            }\n-          }\n+\n+          assert(!UseBiasedLocking, \"Not implemented\");\n@@ -1715,11 +1520,9 @@\n-          if (!success) {\n-            markWord displaced = lockee->mark().set_unlocked();\n-            entry->lock()->set_displaced_header(displaced);\n-            bool call_vm = UseHeavyMonitors;\n-            if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-              \/\/ Is it simple recursive case?\n-              if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-                entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n-              } else {\n-                CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n-              }\n+          markWord displaced = lockee->mark().set_unlocked();\n+          entry->lock()->set_displaced_header(displaced);\n+          bool call_vm = UseHeavyMonitors;\n+          if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+            \/\/ Is it simple recursive case?\n+            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              entry->lock()->set_displaced_header(markWord::from_pointer(NULL));\n+            } else {\n+              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -2011,5 +1814,2 @@\n-              if (UseBiasedLocking) {\n-                result->set_mark(ik->prototype_header());\n-              } else {\n-                result->set_mark(markWord::prototype());\n-              }\n+              assert(!UseBiasedLocking, \"Not implemented\");\n+              result->set_mark(markWord::prototype());\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":36,"deletions":236,"binary":false,"changes":272,"status":"modified"}]}