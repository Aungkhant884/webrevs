{"files":[{"patch":"@@ -111,1 +111,1 @@\n-  TaskQueueEntryChunk* new_base = MmapArrayAllocator<TaskQueueEntryChunk>::allocate_or_null(new_capacity, mtGC);\n+  TaskQueueEntryChunk* new_base = REALLOC_C_HEAP_ARRAY_RETURN_NULL(TaskQueueEntryChunk, _base, new_capacity, mtGC);\n@@ -117,4 +117,0 @@\n-  \/\/ Release old mapping.\n-  if (_base != NULL) {\n-    MmapArrayAllocator<TaskQueueEntryChunk>::free(_base, _chunk_capacity);\n-  }\n@@ -172,1 +168,1 @@\n-    MmapArrayAllocator<TaskQueueEntryChunk>::free(_base, _chunk_capacity);\n+    FREE_C_HEAP_ARRAY(TaskQueueEntryChunk, _base);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-    _hot_cache = ArrayAllocator<CardValue*>::allocate(_hot_cache_size, mtGC);\n+    _hot_cache = NEW_C_HEAP_ARRAY(CardValue*, _hot_cache_size, mtGC);\n@@ -58,1 +58,1 @@\n-    ArrayAllocator<CardValue*>::free(_hot_cache, _hot_cache_size);\n+    FREE_C_HEAP_ARRAY(CardValue*, _hot_cache);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HotCardCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-  _elems(ArrayAllocator<E>::allocate(N, F)),\n+  _elems(NEW_C_HEAP_ARRAY(E, N, F)),\n@@ -108,1 +108,1 @@\n-  ArrayAllocator<E>::free(_elems, N);\n+  FREE_C_HEAP_ARRAY(E, _elems);\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,6 @@\n+  static T* allocate_array(size_t count);\n+\n+  static void deallocate_array(T* ptr, size_t count);\n+\n+  static size_t size_for_array(size_t count);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGranuleMap.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -39,1 +40,1 @@\n-    _map(MmapArrayAllocator<T>::allocate(_size, mtGC)) {\n+    _map(allocate_array(_size)) {\n@@ -45,1 +46,1 @@\n-  MmapArrayAllocator<T>::free(_map, _size);\n+  deallocate_array(_map, _size);\n@@ -55,0 +56,26 @@\n+template <typename T>\n+T* ZGranuleMap<T>::allocate_array(size_t count) {\n+  const size_t size = size_for_array(count);\n+\n+  void* const addr = os::reserve_memory(size, !ExecMem, mtGC);\n+  if (addr == nullptr) {\n+    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"Failed to reserve ZGranuleMap memory\");\n+  }\n+\n+  os::commit_memory_or_exit(static_cast<char*>(addr), size, !ExecMem, \"Failed to commit ZGranuleMap memory\");\n+\n+  return static_cast<T*>(addr);\n+}\n+\n+template <typename T>\n+void ZGranuleMap<T>::deallocate_array(T* ptr, size_t count) {\n+  const bool result = os::release_memory(static_cast<char*>(static_cast<void*>(ptr)),\n+                                         size_for_array(count));\n+  assert(result, \"Failed to release ZGranuleMap memory\");\n+}\n+\n+template <typename T>\n+size_t ZGranuleMap<T>::size_for_array(size_t count) {\n+  return align_up(count * sizeof(T), os::vm_allocation_granularity());\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGranuleMap.inline.hpp","additions":29,"deletions":2,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -618,50 +618,0 @@\n-\/\/ Helper class to allocate arrays that may become large.\n-\/\/ Uses the OS malloc for allocations smaller than ArrayAllocatorMallocLimit\n-\/\/ and uses mapped memory for larger allocations.\n-\/\/ Most OS mallocs do something similar but Solaris malloc does not revert\n-\/\/ to mapped memory for large allocations. By default ArrayAllocatorMallocLimit\n-\/\/ is set so that we always use malloc except for Solaris where we set the\n-\/\/ limit to get mapped memory.\n-template <class E>\n-class ArrayAllocator : public AllStatic {\n- private:\n-  static bool should_use_malloc(size_t length);\n-\n-  static E* allocate_malloc(size_t length, MEMFLAGS flags);\n-  static E* allocate_mmap(size_t length, MEMFLAGS flags);\n-\n-  static E* reallocate_malloc(E* addr, size_t new_length, MEMFLAGS flags);\n-\n-  static void free_malloc(E* addr, size_t length);\n-  static void free_mmap(E* addr, size_t length);\n-\n- public:\n-  static E* allocate(size_t length, MEMFLAGS flags);\n-  static E* reallocate(E* old_addr, size_t old_length, size_t new_length, MEMFLAGS flags);\n-  static void free(E* addr, size_t length);\n-};\n-\n-\/\/ Uses mmapped memory for all allocations. All allocations are initially\n-\/\/ zero-filled. No pre-touching.\n-template <class E>\n-class MmapArrayAllocator : public AllStatic {\n- private:\n-  static size_t size_for(size_t length);\n-\n- public:\n-  static E* allocate_or_null(size_t length, MEMFLAGS flags);\n-  static E* allocate(size_t length, MEMFLAGS flags);\n-  static void free(E* addr, size_t length);\n-};\n-\n-\/\/ Uses malloc:ed memory for all allocations.\n-template <class E>\n-class MallocArrayAllocator : public AllStatic {\n- public:\n-  static size_t size_for(size_t length);\n-\n-  static E* allocate(size_t length, MEMFLAGS flags);\n-  static E* reallocate(E* addr, size_t new_length, MEMFLAGS flags);\n-  static void free(E* addr);\n-};\n-\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -36,148 +36,2 @@\n-\/\/ Explicit C-heap memory management\n-\n-#ifndef PRODUCT\n-\/\/ Increments unsigned long value for statistics (not atomic on MP, but avoids word-tearing on 32 bit).\n-inline void inc_stat_counter(volatile julong* dest, julong add_value) {\n-#ifdef _LP64\n-  *dest += add_value;\n-#else\n-  julong value = Atomic::load(dest);\n-  Atomic::store(dest, value + add_value);\n-#endif\n-}\n-#endif\n-\n-template <class E>\n-size_t MmapArrayAllocator<E>::size_for(size_t length) {\n-  size_t size = length * sizeof(E);\n-  int alignment = os::vm_allocation_granularity();\n-  return align_up(size, alignment);\n-}\n-\n-template <class E>\n-E* MmapArrayAllocator<E>::allocate_or_null(size_t length, MEMFLAGS flags) {\n-  size_t size = size_for(length);\n-\n-  char* addr = os::reserve_memory(size, !ExecMem, flags);\n-  if (addr == NULL) {\n-    return NULL;\n-  }\n-\n-  if (os::commit_memory(addr, size, !ExecMem)) {\n-    return (E*)addr;\n-  } else {\n-    os::release_memory(addr, size);\n-    return NULL;\n-  }\n-}\n-\n-template <class E>\n-E* MmapArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {\n-  size_t size = size_for(length);\n-\n-  char* addr = os::reserve_memory(size, !ExecMem, flags);\n-  if (addr == NULL) {\n-    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, \"Allocator (reserve)\");\n-  }\n-\n-  os::commit_memory_or_exit(addr, size, !ExecMem, \"Allocator (commit)\");\n-\n-  return (E*)addr;\n-}\n-\n-template <class E>\n-void MmapArrayAllocator<E>::free(E* addr, size_t length) {\n-  bool result = os::release_memory((char*)addr, size_for(length));\n-  assert(result, \"Failed to release memory\");\n-}\n-\n-template <class E>\n-size_t MallocArrayAllocator<E>::size_for(size_t length) {\n-  return length * sizeof(E);\n-}\n-\n-template <class E>\n-E* MallocArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {\n-  return (E*)AllocateHeap(size_for(length), flags);\n-}\n-\n-template <class E>\n-E* MallocArrayAllocator<E>::reallocate(E* addr, size_t new_length, MEMFLAGS flags) {\n-  return (E*)ReallocateHeap((char*)addr, size_for(new_length), flags);\n-}\n-\n-template <class E>\n-void MallocArrayAllocator<E>::free(E* addr) {\n-  FreeHeap(addr);\n-}\n-\n-template <class E>\n-bool ArrayAllocator<E>::should_use_malloc(size_t length) {\n-  return MallocArrayAllocator<E>::size_for(length) < ArrayAllocatorMallocLimit;\n-}\n-\n-template <class E>\n-E* ArrayAllocator<E>::allocate_malloc(size_t length, MEMFLAGS flags) {\n-  return MallocArrayAllocator<E>::allocate(length, flags);\n-}\n-\n-template <class E>\n-E* ArrayAllocator<E>::allocate_mmap(size_t length, MEMFLAGS flags) {\n-  return MmapArrayAllocator<E>::allocate(length, flags);\n-}\n-\n-template <class E>\n-E* ArrayAllocator<E>::allocate(size_t length, MEMFLAGS flags) {\n-  if (should_use_malloc(length)) {\n-    return allocate_malloc(length, flags);\n-  }\n-\n-  return allocate_mmap(length, flags);\n-}\n-\n-template <class E>\n-E* ArrayAllocator<E>::reallocate_malloc(E* addr, size_t new_length, MEMFLAGS flags) {\n-  return MallocArrayAllocator<E>::reallocate(addr, new_length, flags);\n-}\n-\n-template <class E>\n-E* ArrayAllocator<E>::reallocate(E* old_addr, size_t old_length, size_t new_length, MEMFLAGS flags) {\n-  if (should_use_malloc(old_length) && should_use_malloc(new_length)) {\n-    return reallocate_malloc(old_addr, new_length, flags);\n-  }\n-\n-  E* new_addr = (new_length > 0)\n-      ? allocate(new_length, flags)\n-      : NULL;\n-\n-  if (new_addr != NULL && old_addr != NULL) {\n-    memcpy(new_addr, old_addr, MIN2(old_length, new_length) * sizeof(E));\n-  }\n-\n-  if (old_addr != NULL) {\n-    free(old_addr, old_length);\n-  }\n-\n-  return new_addr;\n-}\n-\n-template <class E>\n-void ArrayAllocator<E>::free_malloc(E* addr, size_t length) {\n-  MallocArrayAllocator<E>::free(addr);\n-}\n-\n-template <class E>\n-void ArrayAllocator<E>::free_mmap(E* addr, size_t length) {\n-  MmapArrayAllocator<E>::free(addr, length);\n-}\n-\n-template <class E>\n-void ArrayAllocator<E>::free(E* addr, size_t length) {\n-  if (addr != NULL) {\n-    if (should_use_malloc(length)) {\n-      free_malloc(addr, length);\n-    } else {\n-      free_mmap(addr, length);\n-    }\n-  }\n-}\n+\/\/ FIXME: remove this empty header, this header is now empty but many source files include it making\n+\/\/        cleanup difficult\n","filename":"src\/hotspot\/share\/memory\/allocation.inline.hpp","additions":2,"deletions":148,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  void* chunk = MmapArrayAllocator<uint8_t>::allocate(total_size, flags);\n+  uint8_t* chunk = NEW_C_HEAP_ARRAY(uint8_t, total_size, flags);\n+\n@@ -68,0 +69,2 @@\n+  memset(chunk, '\\0', total_size);\n+\n","filename":"src\/hotspot\/share\/memory\/padded.inline.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"runtime\/atomic.hpp\"\n@@ -36,0 +37,12 @@\n+#ifndef PRODUCT\n+\/\/ Increments unsigned long value for statistics (not atomic on MP, but avoids word-tearing on 32 bit).\n+static inline void inc_stat_counter(volatile julong* dest, julong add_value) {\n+#ifdef _LP64\n+  *dest += add_value;\n+#else\n+  julong value = Atomic::load(dest);\n+  Atomic::store(dest, value + add_value);\n+#endif\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/indexSet.cpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1892,4 +1892,0 @@\n-  product(size_t, ArrayAllocatorMallocLimit, (size_t)-1, EXPERIMENTAL,      \\\n-          \"Allocation less than this value will be allocated \"              \\\n-          \"using malloc. Larger allocations will use mmap.\")                \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,1 +138,1 @@\n-  return ArrayAllocator<bm_word_t>::allocate(size_in_words, _flags);\n+  return NEW_C_HEAP_ARRAY(bm_word_t, size_in_words, _flags);\n@@ -142,1 +142,1 @@\n-  ArrayAllocator<bm_word_t>::free(map, size_in_words);\n+  FREE_C_HEAP_ARRAY(bm_word_t, map);\n@@ -146,1 +146,1 @@\n-  return ArrayAllocator<bm_word_t>::reallocate(map, old_size_in_words, new_size_in_words, _flags);\n+  return REALLOC_C_HEAP_ARRAY(bm_word_t, map, new_size_in_words, _flags);\n","filename":"src\/hotspot\/share\/utilities\/bitMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- *\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"memory\/allocation.inline.hpp\"\n-#include \"unittest.hpp\"\n-\n-using Element = struct TestArrayAllocatorElement {\n-  double a;\n-  int b;\n-};\n-\n-static void fill(Element* elements, int start, int size) {\n-  for (int i = 0; i < size; i++) {\n-    new (&elements[start + i]) Element{0.0, start + i};\n-  }\n-}\n-\n-static Element* allocate_and_fill(int size) {\n-  Element* const elements = MallocArrayAllocator<Element>::allocate(size, mtTest);\n-\n-  fill(elements, 0, size);\n-\n-  return elements;\n-}\n-\n-TEST_VM(ArrayAllocator, allocate) {\n-  const int size = 10;\n-\n-  Element* const elements = allocate_and_fill(size);\n-\n-  for (int i = 0; i < size; i++) {\n-    ASSERT_EQ(elements[i].b, i);\n-  }\n-\n-  MallocArrayAllocator<Element>::free(elements);\n-}\n-\n-TEST_VM(ArrayAllocator, reallocate_0) {\n-  const int size = 10;\n-\n-  Element* const elements = allocate_and_fill(size);\n-\n-  Element* const ret = MallocArrayAllocator<Element>::reallocate(elements, 0, mtTest);\n-  ASSERT_NE(ret, nullptr) << \"We've chosen to NOT return nullptr when reallcting with 0\";\n-\n-  MallocArrayAllocator<Element>::free(ret);\n-}\n-\n-TEST_VM(ArrayAllocator, reallocate_shrink) {\n-  const int size = 10;\n-\n-  Element* const elements = allocate_and_fill(size);\n-\n-  Element* const ret = MallocArrayAllocator<Element>::reallocate(elements, size \/ 2, mtTest);\n-\n-  for (int i = 0; i < size \/ 2; i++) {\n-    ASSERT_EQ(ret[i].b, i);\n-  }\n-\n-  MallocArrayAllocator<Element>::free(ret);\n-}\n-\n-TEST_VM(ArrayAllocator, reallocate_grow) {\n-  const int size = 10;\n-\n-  Element* const elements = allocate_and_fill(size);\n-\n-  Element* const ret = MallocArrayAllocator<Element>::reallocate(elements, size * 2, mtTest);\n-\n-  fill(ret, size, size);\n-\n-  for (int i = 0; i < size * 2; i++) {\n-    ASSERT_EQ(ret[i].b, i);\n-  }\n-\n-  MallocArrayAllocator<Element>::free(ret);\n-}\n","filename":"test\/hotspot\/gtest\/memory\/test_arrayAllocator.cpp","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,100 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package gc.arguments;\n-\n-\/*\n- * @test TestArrayAllocatorMallocLimit\n- * @summary Sanity check that the ArrayAllocatorMallocLimit flag can be set.\n- * The test helps verifying that size_t flags can be set\/read.\n- * @bug 8054823\n- * @library \/test\/lib\n- * @library \/\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver gc.arguments.TestArrayAllocatorMallocLimit\n- *\/\n-\n-import jdk.test.lib.Asserts;\n-import jdk.test.lib.process.OutputAnalyzer;\n-import java.math.BigInteger;\n-\n-public class TestArrayAllocatorMallocLimit {\n-  public static void main(String [] args) throws Exception {\n-    testDefaultValue();\n-    testSetValue();\n-  }\n-\n-  private static final String flagName = \"ArrayAllocatorMallocLimit\";\n-\n-  \/\/     size_t ArrayAllocatorMallocLimit                 = 18446744073709551615{experimental}\n-  private static final String printFlagsFinalPattern = \" *size_t *\" + flagName + \" *:?= *(\\\\d+) *\\\\{experimental\\\\} *\";\n-\n-  public static void testDefaultValue()  throws Exception {\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n-      \"-XX:+UnlockExperimentalVMOptions\", \"-XX:+PrintFlagsFinal\", \"-version\");\n-\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-    String value = output.firstMatch(printFlagsFinalPattern, 1);\n-\n-    try {\n-      Asserts.assertNotNull(value, \"Couldn't find size_t flag \" + flagName);\n-\n-      \/\/ A size_t is not always parseable with Long.parseValue,\n-      \/\/ use BigInteger instead.\n-      BigInteger biValue = new BigInteger(value);\n-\n-      \/\/ Sanity check that we got a non-zero value.\n-      Asserts.assertNotEquals(biValue, \"0\");\n-\n-      output.shouldHaveExitValue(0);\n-    } catch (Exception e) {\n-      System.err.println(output.getOutput());\n-      throw e;\n-    }\n-  }\n-\n-  public static void testSetValue() throws Exception {\n-    long flagValue = 2048;\n-\n-    ProcessBuilder pb = GCArguments.createJavaProcessBuilder(\n-      \"-XX:+UnlockExperimentalVMOptions\", \"-XX:\" + flagName + \"=\" + flagValue, \"-XX:+PrintFlagsFinal\", \"-version\");\n-\n-    OutputAnalyzer output = new OutputAnalyzer(pb.start());\n-    String value = output.firstMatch(printFlagsFinalPattern, 1);\n-\n-    try {\n-      Asserts.assertNotNull(\"Couldn't find size_t flag \" + flagName);\n-\n-      long longValue = Long.parseLong(value);\n-\n-      Asserts.assertEquals(longValue, flagValue);\n-\n-      output.shouldHaveExitValue(0);\n-    } catch (Exception e) {\n-      System.err.println(output.getOutput());\n-      throw e;\n-    }\n-  }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestArrayAllocatorMallocLimit.java","additions":0,"deletions":100,"binary":false,"changes":100,"status":"deleted"},{"patch":"@@ -60,5 +60,0 @@\n-    \/\/ Test a non-manageable size_t flag.\n-    \/\/ Since it is not manageable, we can't test the setFlag functionality.\n-    testGetFlag(\"ArrayAllocatorMallocLimit\", \"128\");\n-    \/\/ testSetFlag(\"ArrayAllocatorMallocLimit\", \"64\", \"128\");\n-\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/AttachSetGetFlag.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private static final String FLAG_NAME = \"ArrayAllocatorMallocLimit\";\n+    private static final String FLAG_NAME = \"StringDeduplicationCleanupDeadMinimum\";\n","filename":"test\/lib-test\/jdk\/test\/whitebox\/vm_flags\/SizeTTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}