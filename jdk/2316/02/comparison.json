{"files":[{"patch":"@@ -75,0 +75,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -353,1 +354,1 @@\n-                        if ((ct.sym.flags_field & Flags.UNATTRIBUTED) != 0) {\n+                        if (ct.sym.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED)) {\n@@ -936,1 +937,1 @@\n-        if (enclClass != null && (enclClass.flags_field & Flags.UNATTRIBUTED) != 0) {\n+        if (enclClass != null && enclClass.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/api\/JavacTrees.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -244,1 +245,1 @@\n-    long getSupplementaryFlags(ClassSymbol c) {\n+    void addSupplementaryFlags(ClassSymbol c) {\n@@ -246,1 +247,1 @@\n-            return 0;\n+            return ;\n@@ -254,15 +255,9 @@\n-\n-        Long flags = supplementaryFlags.get(packge);\n-        if (flags == null) {\n-            long newFlags = 0;\n-            try {\n-                ModuleSymbol owningModule = packge.modle;\n-                if (owningModule == syms.noModule) {\n-                    JRTIndex.CtSym ctSym = jrtIndex.getCtSym(packge.flatName());\n-                    Profile minProfile = Profile.DEFAULT;\n-                    if (ctSym.proprietary)\n-                        newFlags |= PROPRIETARY;\n-                    if (ctSym.minProfile != null)\n-                        minProfile = Profile.lookup(ctSym.minProfile);\n-                    if (profile != Profile.DEFAULT && minProfile.value > profile.value) {\n-                        newFlags |= NOT_IN_PROFILE;\n+        ModuleSymbol owningModule = packge.modle;\n+        if (owningModule == syms.noModule) {\n+            JRTIndex.CtSym extra = supplementaryFlags.computeIfAbsent(c.packge(),\n+                    p -> {\n+                        try {\n+                            return jrtIndex.getCtSym(c.packge().flatName());\n+                        } catch (IOException ignore) {\n+                            return null;\n+                        }\n@@ -270,4 +265,8 @@\n-                } else if (owningModule.name == names.jdk_unsupported) {\n-                    newFlags |= PROPRIETARY;\n-                }\n-            } catch (IOException ignore) {\n+            );\n+            Profile minProfile = Profile.DEFAULT;\n+            if (extra.proprietary)\n+                c.setFlag(TypeSymbolFlags.PROPRIETARY);\n+            if (extra.minProfile != null)\n+                minProfile = Profile.lookup(extra.minProfile);\n+            if (profile != Profile.DEFAULT && minProfile.value > profile.value) {\n+                c.setFlag(TypeSymbolFlags.NOT_IN_PROFILE);\n@@ -275,1 +274,2 @@\n-            supplementaryFlags.put(packge, flags = newFlags);\n+        } else if (owningModule.name == names.jdk_unsupported) {\n+            c.setFlag(TypeSymbolFlags.PROPRIETARY);\n@@ -277,1 +277,0 @@\n-        return flags;\n@@ -280,1 +279,1 @@\n-    private Map<PackageSymbol, Long> supplementaryFlags;\n+    private Map<PackageSymbol, JRTIndex.CtSym> supplementaryFlags;\n@@ -375,1 +374,1 @@\n-                    c.flags_field |= getSupplementaryFlags(c);\n+                    addSupplementaryFlags(c);\n@@ -469,1 +468,1 @@\n-        if ((p.flags_field & EXISTS) == 0)\n+        if (!p.isFlagSetNoComplete(TypeSymbolFlags.EXISTS))\n@@ -471,1 +470,1 @@\n-                q.flags_field |= EXISTS;\n+                ((PackageSymbol) q).setFlag(TypeSymbolFlags.EXISTS);\n@@ -473,1 +472,1 @@\n-        int seen;\n+        TypeSymbolFlags seen;\n@@ -475,1 +474,1 @@\n-            seen = CLASS_SEEN;\n+            seen = TypeSymbolFlags.CLASS_SEEN;\n@@ -477,1 +476,1 @@\n-            seen = SOURCE_SEEN;\n+            seen = TypeSymbolFlags.SOURCE_SEEN;\n@@ -495,1 +494,1 @@\n-        } else if (!preferCurrent && c.classfile != null && (c.flags_field & seen) == 0) {\n+        } else if (!preferCurrent && c.classfile != null && !c.isFlagSetNoComplete(seen)) {\n@@ -500,1 +499,2 @@\n-            if ((c.flags_field & (CLASS_SEEN | SOURCE_SEEN)) != 0)\n+            if (c.isFlagSetNoComplete(TypeSymbolFlags.CLASS_SEEN) ||\n+                c.isFlagSetNoComplete(TypeSymbolFlags.SOURCE_SEEN))\n@@ -503,1 +503,1 @@\n-        c.flags_field |= seen;\n+        c.setFlag(seen);\n@@ -765,1 +765,1 @@\n-                                p.flags_field |= Flags.HAS_RESOURCE;\n+                                p.setFlag(TypeSymbolFlags.HAS_RESOURCE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ClassFinder.java","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        Assert.check(flags == 0);\n+        Assert.check((flags & (LAST_FLAT_BIT * 2 - 1)) == 0);\n@@ -116,0 +116,1 @@\n+    \/\/on all Symbols:\n@@ -120,54 +121,2 @@\n-    \/** Flag is set for a variable symbol if the variable's definition\n-     *  has an initializer part.\n-     *\/\n-    public static final int HASINIT          = 1<<18;\n-\n-    \/** Flag is set for compiler-generated anonymous method symbols\n-     *  that `own' an initializer block.\n-     *\/\n-    public static final int BLOCK            = 1<<20;\n-\n-    \/** Flag bit 21 is available. (used earlier to tag compiler-generated abstract methods that implement\n-     *  an interface method (Miranda methods)).\n-     *\/\n-\n-    \/** Flag is set for nested classes that do not access instance members\n-     *  or `this' of an outer class and therefore don't need to be passed\n-     *  a this$n reference.  This value is currently set only for anonymous\n-     *  classes in superclass constructor calls.\n-     *  todo: use this value for optimizing away this$n parameters in\n-     *  other cases.\n-     *\/\n-    public static final int NOOUTERTHIS  = 1<<22;\n-\n-    \/** Flag is set for package symbols if a package has a member or\n-     *  directory and therefore exists.\n-     *\/\n-    public static final int EXISTS           = 1<<23;\n-\n-    \/** Flag is set for compiler-generated compound classes\n-     *  representing multiple variable bounds\n-     *\/\n-    public static final int COMPOUND     = 1<<24;\n-\n-    \/** Flag is set for class symbols if a class file was found for this class.\n-     *\/\n-    public static final int CLASS_SEEN   = 1<<25;\n-\n-    \/** Flag is set for class symbols if a source file was found for this\n-     *  class.\n-     *\/\n-    public static final int SOURCE_SEEN  = 1<<26;\n-\n-    \/* State flags (are reset during compilation).\n-     *\/\n-\n-    \/** Flag for class symbols is set and later re-set as a lock in\n-     *  Enter to detect cycles in the superclass\/superinterface\n-     *  relations.  Similarly for constructor call cycle detection in\n-     *  Attr.\n-     *\/\n-    public static final int LOCKED           = 1<<27;\n-\n-    \/** Flag for class symbols is set and later re-set to indicate that a class\n-     *  has been entered but has not yet been attributed.\n+    \/**\n+     * Flag to indicate the given symbol has a @Deprecated annotation.\n@@ -175,1 +124,1 @@\n-    public static final int UNATTRIBUTED = 1<<28;\n+    public static final long DEPRECATED_ANNOTATION = 1L<<18;\n@@ -177,1 +126,2 @@\n-    \/** Flag for synthesized default constructors of anonymous classes.\n+    \/**\n+     * Flag to indicate the given symbol has been deprecated and marked for removal.\n@@ -179,1 +129,1 @@\n-    public static final int ANONCONSTR   = 1<<29; \/\/non-class members\n+    public static final long DEPRECATED_REMOVAL = 1L<<19;\n@@ -182,1 +132,1 @@\n-     * Flag to indicate the super classes of this ClassSymbol has been attributed.\n+     * Flag to indicate the API element in question is for a preview API.\n@@ -184,1 +134,1 @@\n-    public static final int SUPER_OWNER_ATTRIBUTED = 1<<29; \/\/ClassSymbols\n+    public static final long PREVIEW_API = 1L<<20; \/\/any Symbol kind\n@@ -186,2 +136,2 @@\n-    \/** Flag for class symbols to indicate it has been checked and found\n-     *  acyclic.\n+    \/**\n+     * Flag to indicate the API element in question is for a reflective preview API.\n@@ -189,1 +139,1 @@\n-    public static final int ACYCLIC          = 1<<30;\n+    public static final long PREVIEW_REFLECTIVE = 1L<<21; \/\/any Symbol kind\n@@ -191,0 +141,1 @@\n+    \/\/classfile flags:\n@@ -193,1 +144,1 @@\n-    public static final long BRIDGE          = 1L<<31;\n+    public static final long BRIDGE          = 1L<<22;\n@@ -197,1 +148,1 @@\n-    public static final long PARAMETER   = 1L<<33;\n+    public static final long PARAMETER   = 1L<<23;\n@@ -201,43 +152,1 @@\n-    public static final long VARARGS   = 1L<<34;\n-\n-    \/** Flag for annotation type symbols to indicate it has been\n-     *  checked and found acyclic.\n-     *\/\n-    public static final long ACYCLIC_ANN      = 1L<<35;\n-\n-    \/** Flag that marks a generated default constructor.\n-     *\/\n-    public static final long GENERATEDCONSTR   = 1L<<36;\n-\n-    \/** Flag that marks a hypothetical method that need not really be\n-     *  generated in the binary, but is present in the symbol table to\n-     *  simplify checking for erasure clashes - also used for 292 poly sig methods.\n-     *\/\n-    public static final long HYPOTHETICAL   = 1L<<37;\n-\n-    \/**\n-     * Flag that marks an internal proprietary class.\n-     *\/\n-    public static final long PROPRIETARY = 1L<<38;\n-\n-    \/**\n-     * Flag that marks a multi-catch parameter.\n-     *\/\n-    public static final long UNION = 1L<<39;\n-\n-    \/**\n-     * Flags an erroneous TypeSymbol as viable for recovery.\n-     * TypeSymbols only.\n-     *\/\n-    public static final long RECOVERABLE = 1L<<40;\n-\n-    \/**\n-     * Flag that marks an 'effectively final' local variable.\n-     *\/\n-    public static final long EFFECTIVELY_FINAL = 1L<<41;\n-\n-    \/**\n-     * Flag that marks non-override equivalent methods with the same signature,\n-     * or a conflicting match binding (BindingSymbol).\n-     *\/\n-    public static final long CLASH = 1L<<42;\n+    public static final long VARARGS   = 1L<<24;\n@@ -248,42 +157,1 @@\n-    public static final long DEFAULT = 1L<<43;\n-\n-    \/**\n-     * Flag that marks class as auxiliary, ie a non-public class following\n-     * the public class in a source file, that could block implicit compilation.\n-     *\/\n-    public static final long AUXILIARY = 1L<<44;\n-\n-    \/**\n-     * Flag that marks that a symbol is not available in the current profile\n-     *\/\n-    public static final long NOT_IN_PROFILE = 1L<<45;\n-\n-    \/**\n-     * Flag that indicates that an override error has been detected by Check.\n-     *\/\n-    public static final long BAD_OVERRIDE = 1L<<45;\n-\n-    \/**\n-     * Flag that indicates a signature polymorphic method (292).\n-     *\/\n-    public static final long SIGNATURE_POLYMORPHIC = 1L<<46;\n-\n-    \/**\n-     * Flag that indicates that an inference variable is used in a 'throws' clause.\n-     *\/\n-    public static final long THROWS = 1L<<47;\n-\n-    \/**\n-     * Flag that marks potentially ambiguous overloads\n-     *\/\n-    public static final long POTENTIALLY_AMBIGUOUS = 1L<<48;\n-\n-    \/**\n-     * Flag that marks a synthetic method body for a lambda expression\n-     *\/\n-    public static final long LAMBDA_METHOD = 1L<<49;\n-\n-    \/**\n-     * Flag to control recursion in TransTypes\n-     *\/\n-    public static final long TYPE_TRANSLATED = 1L<<50;\n+    public static final long DEFAULT = 1L<<25;\n@@ -294,1 +162,1 @@\n-    public static final long MODULE = 1L<<51;\n+    public static final long MODULE = 1L<<26;\n@@ -296,27 +164,2 @@\n-    \/**\n-     * Flag to indicate the given ModuleSymbol is an automatic module.\n-     *\/\n-    public static final long AUTOMATIC_MODULE = 1L<<52; \/\/ModuleSymbols only\n-\n-    \/**\n-     * Flag to indicate the given PackageSymbol contains any non-.java and non-.class resources.\n-     *\/\n-    public static final long HAS_RESOURCE = 1L<<52; \/\/PackageSymbols only\n-\n-    \/**\n-     * Flag to indicate the given ParamSymbol has a user-friendly name filled.\n-     *\/\n-    public static final long NAME_FILLED = 1L<<52; \/\/ParamSymbols only\n-\n-    \/**\n-     * Flag to indicate the given ModuleSymbol is a system module.\n-     *\/\n-    public static final long SYSTEM_MODULE = 1L<<53; \/\/ModuleSymbols only\n-\n-    \/**\n-     * Flag to indicate the given ClassSymbol is a value based.\n-     *\/\n-    public static final long VALUE_BASED = 1L<<53; \/\/ClassSymbols only\n-\n-    \/**\n-     * Flag to indicate the given symbol has a @Deprecated annotation.\n+    \/\/used on trees:\n+    \/** Flag for synthesized default constructors of anonymous classes.\n@@ -324,1 +167,1 @@\n-    public static final long DEPRECATED_ANNOTATION = 1L<<54;\n+    public static final int ANONCONSTR   = 1<<27;\n@@ -327,1 +170,1 @@\n-     * Flag to indicate the given symbol has been deprecated and marked for removal.\n+     * Flag for synthesized default constructors of anonymous classes that have an enclosing expression.\n@@ -329,1 +172,1 @@\n-    public static final long DEPRECATED_REMOVAL = 1L<<55;\n+    public static final long ANONCONSTR_BASED = 1L<<28;\n@@ -331,2 +174,1 @@\n-    \/**\n-     * Flag to indicate the API element in question is for a preview API.\n+    \/** Flag that marks a generated default constructor.\n@@ -334,1 +176,1 @@\n-    public static final long PREVIEW_API = 1L<<56; \/\/any Symbol kind\n+    public static final long GENERATEDCONSTR   = 1L<<29;\n@@ -337,1 +179,1 @@\n-     * Flag for synthesized default constructors of anonymous classes that have an enclosing expression.\n+     * Flag to mark a record constructor as a compact one\n@@ -339,1 +181,1 @@\n-    public static final long ANONCONSTR_BASED = 1L<<57;\n+    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<30; \/\/ MethodSymbols only\n@@ -345,1 +187,1 @@\n-    public static final long BODY_ONLY_FINALIZE = 1L<<17; \/\/blocks only\n+    public static final long BODY_ONLY_FINALIZE = 1L<<31;\n@@ -347,0 +189,1 @@\n+    \/\/other:\n@@ -348,1 +191,2 @@\n-     * Flag to indicate the API element in question is for a preview API.\n+     * Flag to indicate that a class is a record. The flag is also used to mark fields that are\n+     * part of the state vector of a record and to mark the canonical constructor\n@@ -350,1 +194,1 @@\n-    public static final long PREVIEW_REFLECTIVE = 1L<<58; \/\/any Symbol kind\n+    public static final long RECORD = 1L<<32; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n@@ -352,2 +196,2 @@\n-    \/**\n-     * Flag to indicate the given variable is a match binding variable.\n+    \/** Flag is set for compiler-generated record members, it could be applied to\n+     *  accessors and fields\n@@ -355,1 +199,1 @@\n-    public static final long MATCH_BINDING = 1L<<59;\n+    public static final long GENERATED_MEMBER = 1L<<33; \/\/ MethodSymbols and VarSymbols\n@@ -358,1 +202,2 @@\n-     * A flag to indicate a match binding variable whose scope extends after the current statement.\n+     * Flag that marks non-override equivalent methods with the same signature,\n+     * or a conflicting match binding (BindingSymbol).\n@@ -360,1 +205,1 @@\n-    public static final long MATCH_BINDING_TO_OUTER = 1L<<60;\n+    public static final long CLASH = 1L<<34;\n@@ -362,3 +207,2 @@\n-    \/**\n-     * Flag to indicate that a class is a record. The flag is also used to mark fields that are\n-     * part of the state vector of a record and to mark the canonical constructor\n+    \/** Flag is set for compiler-generated anonymous method symbols\n+     *  that `own' an initializer block.\n@@ -366,1 +210,1 @@\n-    public static final long RECORD = 1L<<61; \/\/ ClassSymbols, MethodSymbols and VarSymbols\n+    public static final long BLOCK            = 1L<<35;\n@@ -368,2 +212,2 @@\n-    \/**\n-     * Flag to mark a record constructor as a compact one\n+    \/** Flag is set for a variable symbol if the variable's definition\n+     *  has an initializer part.\n@@ -371,1 +215,1 @@\n-    public static final long COMPACT_RECORD_CONSTRUCTOR = 1L<<51; \/\/ MethodSymbols only\n+    public static final long HASINIT          = 1L<<36;\n@@ -374,6 +218,1 @@\n-     * Flag to mark a record field that was not initialized in the compact constructor\n-     *\/\n-    public static final long UNINITIALIZED_FIELD= 1L<<51; \/\/ VarSymbols only\n-\n-    \/** Flag is set for compiler-generated record members, it could be applied to\n-     *  accessors and fields\n+     * Flag that indicates that an inference variable is used in a 'throws' clause.\n@@ -381,1 +220,1 @@\n-    public static final int GENERATED_MEMBER = 1<<24; \/\/ MethodSymbols and VarSymbols\n+    public static final long THROWS = 1L<<37;\n@@ -386,1 +225,1 @@\n-    public static final long SEALED = 1L<<62; \/\/ ClassSymbols\n+    public static final long SEALED = 1L<<38; \/\/ ClassSymbols\n@@ -391,1 +230,1 @@\n-    public static final long NON_SEALED = 1L<<63; \/\/ ClassSymbols\n+    public static final long NON_SEALED = 1L<<39; \/\/ ClassSymbols\n@@ -393,0 +232,5 @@\n+    \/**\n+     * The last bit used by the \"flat\" flags above. Should be updated when a new\n+     * flag is added.\n+     *\/\n+    public static final long LAST_FLAT_BIT = NON_SEALED;\n@@ -464,0 +308,204 @@\n+    public enum TypeSymbolFlags {\n+        \/\/PackageSymbols:\n+        \/** Flag is set for package symbols if a package has a member or\n+         *  directory and therefore exists.\n+         *\/\n+        EXISTS,\n+\n+        \/**\n+         * Flag to indicate the given PackageSymbol contains any non-.java and non-.class resources.\n+         *\/\n+        HAS_RESOURCE,\n+\n+        \/\/ClassSymbols:\n+        \/** Flag is set for nested classes that do not access instance members\n+         *  or `this' of an outer class and therefore don't need to be passed\n+         *  a this$n reference.  This value is currently set only for anonymous\n+         *  classes in superclass constructor calls.\n+         *\/\n+        NOOUTERTHIS,\n+\n+        \/** Flag is set for compiler-generated compound classes\n+         *  representing multiple variable bounds\n+         *\/\n+        COMPOUND,\n+\n+        \/** Flag is set for class symbols if a class file was found for this class.\n+         *\/\n+        CLASS_SEEN,\n+\n+        \/** Flag is set for class symbols if a source file was found for this\n+         *  class.\n+         *\/\n+        SOURCE_SEEN,\n+\n+        \/** Flag for class symbols is set and later re-set as a lock in\n+         *  Enter to detect cycles in the superclass\/superinterface\n+         *  relations.  Similarly for constructor call cycle detection in\n+         *  Attr.\n+         *\/\n+        LOCKED,\n+\n+        \/** Flag for class symbols is set and later re-set to indicate that a class\n+         *  has been entered but has not yet been attributed.\n+         *\/\n+        UNATTRIBUTED,\n+\n+        \/** Flag for class symbols to indicate it has been checked and found\n+         *  acyclic.\n+         *\/\n+        ACYCLIC,\n+\n+        \/** Flag for annotation type symbols to indicate it has been\n+         *  checked and found acyclic.\n+         *\/\n+        ACYCLIC_ANN,\n+\n+        \/**\n+         * Flag that marks an internal proprietary class.\n+         *\/\n+        PROPRIETARY,\n+\n+        \/**\n+         * Flag that marks class as auxiliary, ie a non-public class following\n+         * the public class in a source file, that could block implicit compilation.\n+         *\/\n+        AUXILIARY,\n+\n+        \/**\n+         * Flag to control recursion in TransTypes\n+         *\/\n+        TYPE_TRANSLATED,\n+\n+        \/**\n+         * Flag that marks that a symbol is not available in the current profile\n+         *\/\n+        NOT_IN_PROFILE,\n+\n+        \/**\n+         * Flags an erroneous TypeSymbol as viable for recovery.\n+         * TypeSymbols only.\n+         *\/\n+        RECOVERABLE,\n+\n+        \/**\n+         * Flag to indicate the given ClassSymbol is a value based.\n+         *\/\n+        VALUE_BASED,\n+\n+        \/**\n+         * Flag to indicate the super classes of this ClassSymbol has been attributed.\n+         *\/\n+        SUPER_OWNER_ATTRIBUTED,\n+\n+        \/\/ModuleSymbols:\n+        \/**\n+         * Flag to indicate the given ModuleSymbol is an automatic module.\n+         *\/\n+        AUTOMATIC_MODULE,\n+\n+        \/**\n+         * Flag to indicate the given ModuleSymbol is a system module.\n+         *\/\n+        SYSTEM_MODULE,\n+        ;\n+\n+        final long mask;\n+        private TypeSymbolFlags() {\n+            this.mask = (1L << ordinal()) * LAST_FLAT_BIT * 2;\n+            Assert.check(this.mask > 0);\n+        }\n+\n+    }\n+\n+    public enum MethodSymbolFlags {\n+        \/** Flag that marks a hypothetical method that need not really be\n+         *  generated in the binary, but is present in the symbol table to\n+         *  simplify checking for erasure clashes - also used for 292 poly sig methods.\n+         *\/\n+        HYPOTHETICAL,\n+\n+        \/**\n+         * Flag that indicates that an override error has been detected by Check.\n+         *\/\n+        BAD_OVERRIDE,\n+\n+        \/**\n+         * Flag that indicates a signature polymorphic method (292).\n+         *\/\n+        SIGNATURE_POLYMORPHIC,\n+\n+        \/**\n+         * Flag that marks potentially ambiguous overloads\n+         *\/\n+        POTENTIALLY_AMBIGUOUS,\n+\n+        \/**\n+         * Flag that marks a synthetic method body for a lambda expression\n+         *\/\n+        LAMBDA_METHOD,\n+\n+        \/** Flag for class symbols to indicate it has been checked and found\n+         *  acyclic.\n+         *\/\n+        ACYCLIC_CONSTRUCTOR,\n+\n+        \/** Flag for class symbols is set and later re-set as a lock in\n+         *  Enter to detect cycles in the superclass\/superinterface\n+         *  relations.  Similarly for constructor call cycle detection in\n+         *  Attr.\n+         *\/\n+        LOCKED_CONSTRUCTOR,\n+        ;\n+\n+        final long mask;\n+        private MethodSymbolFlags() {\n+            this.mask = (1L << ordinal()) * LAST_FLAT_BIT * 2;\n+            Assert.check(this.mask > 0);\n+        }\n+    }\n+\n+    public enum VarSymbolFlags {\n+        \/**\n+         * Flag that marks an 'effectively final' local variable.\n+         *\/\n+        EFFECTIVELY_FINAL,\n+\n+        \/**\n+         * Flag to indicate the given ParamSymbol has a user-friendly name filled.\n+         *\/\n+        NAME_FILLED,\n+\n+        \/**\n+         * Flag to indicate the given variable is a match binding variable.\n+         *\/\n+        MATCH_BINDING,\n+\n+        \/**\n+         * A flag to indicate a match binding variable whose scope extends after the current statement.\n+         *\/\n+        MATCH_BINDING_TO_OUTER,\n+\n+        \/**\n+         * Flag to mark a record field that was not initialized in the compact constructor\n+         *\/\n+        UNINITIALIZED_FIELD,\n+\n+        \/**\n+         * Flag that marks a multi-catch parameter.\n+         *\/\n+        UNION,\n+\n+        \/**\n+         * Flag to mark synthetic outer instance variables that are not needed and\n+         * should be eliminated.\n+         *\/\n+        NOOUTERTHIS,\n+        ;\n+\n+        final long mask;\n+        private VarSymbolFlags() {\n+            this.mask = (1L << ordinal()) * LAST_FLAT_BIT * 2;\n+            Assert.check(this.mask > 0);\n+        }\n+    }\n@@ -479,1 +527,0 @@\n-        BRIDGE(Flags.BRIDGE),\n@@ -483,2 +530,0 @@\n-        HASINIT(Flags.HASINIT),\n-        BLOCK(Flags.BLOCK),\n@@ -487,28 +532,0 @@\n-        NOOUTERTHIS(Flags.NOOUTERTHIS),\n-        EXISTS(Flags.EXISTS),\n-        COMPOUND(Flags.COMPOUND),\n-        CLASS_SEEN(Flags.CLASS_SEEN),\n-        SOURCE_SEEN(Flags.SOURCE_SEEN),\n-        LOCKED(Flags.LOCKED),\n-        UNATTRIBUTED(Flags.UNATTRIBUTED),\n-        ANONCONSTR(Flags.ANONCONSTR),\n-        ACYCLIC(Flags.ACYCLIC),\n-        PARAMETER(Flags.PARAMETER),\n-        VARARGS(Flags.VARARGS),\n-        ACYCLIC_ANN(Flags.ACYCLIC_ANN),\n-        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n-        HYPOTHETICAL(Flags.HYPOTHETICAL),\n-        PROPRIETARY(Flags.PROPRIETARY),\n-        UNION(Flags.UNION),\n-        EFFECTIVELY_FINAL(Flags.EFFECTIVELY_FINAL),\n-        CLASH(Flags.CLASH),\n-        AUXILIARY(Flags.AUXILIARY),\n-        NOT_IN_PROFILE(Flags.NOT_IN_PROFILE),\n-        BAD_OVERRIDE(Flags.BAD_OVERRIDE),\n-        SIGNATURE_POLYMORPHIC(Flags.SIGNATURE_POLYMORPHIC),\n-        THROWS(Flags.THROWS),\n-        LAMBDA_METHOD(Flags.LAMBDA_METHOD),\n-        TYPE_TRANSLATED(Flags.TYPE_TRANSLATED),\n-        MODULE(Flags.MODULE),\n-        AUTOMATIC_MODULE(Flags.AUTOMATIC_MODULE),\n-        SYSTEM_MODULE(Flags.SYSTEM_MODULE),\n@@ -517,4 +534,0 @@\n-        HAS_RESOURCE(Flags.HAS_RESOURCE),\n-        POTENTIALLY_AMBIGUOUS(Flags.POTENTIALLY_AMBIGUOUS),\n-        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n-        NAME_FILLED(Flags.NAME_FILLED),\n@@ -523,2 +536,9 @@\n-        MATCH_BINDING(Flags.MATCH_BINDING),\n-        MATCH_BINDING_TO_OUTER(Flags.MATCH_BINDING_TO_OUTER),\n+        BRIDGE(Flags.BRIDGE),\n+        PARAMETER(Flags.PARAMETER),\n+        VARARGS(Flags.VARARGS),\n+        MODULE(Flags.MODULE),\n+        ANONCONSTR(Flags.ANONCONSTR),\n+        ANONCONSTR_BASED(Flags.ANONCONSTR_BASED),\n+        GENERATEDCONSTR(Flags.GENERATEDCONSTR),\n+        COMPACT_RECORD_CONSTRUCTOR(Flags.COMPACT_RECORD_CONSTRUCTOR),\n+        BODY_ONLY_FINALIZE(Flags.BODY_ONLY_FINALIZE),\n@@ -526,1 +546,5 @@\n-        RECOVERABLE(Flags.RECOVERABLE),\n+        GENERATED_MEMBER(Flags.GENERATED_MEMBER),\n+        CLASH(Flags.CLASH),\n+        BLOCK(Flags.BLOCK),\n+        HASINIT(Flags.HASINIT),\n+        THROWS(Flags.THROWS),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Flags.java","additions":272,"deletions":248,"binary":false,"changes":520,"status":"modified"},{"patch":"@@ -323,1 +323,1 @@\n-            t.hasTag(CLASS) && (t.tsym.flags() & COMPOUND) != 0)\n+            t.hasTag(CLASS) && t.tsym.isFlagSet(TypeSymbolFlags.COMPOUND))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Kinds.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.util.function.Function;\n@@ -42,0 +41,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -331,1 +331,1 @@\n-                            msym.flags_field |= Flags.SYSTEM_MODULE;\n+                            msym.setFlag(TypeSymbolFlags.SYSTEM_MODULE);\n@@ -372,1 +372,1 @@\n-                    msym.flags_field |= Flags.AUTOMATIC_MODULE;\n+                    msym.setFlag(TypeSymbolFlags.AUTOMATIC_MODULE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/ModuleFinder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -301,1 +301,1 @@\n-        if (sym.name.length() == 0 && (sym.flags() & COMPOUND) != 0) {\n+        if (sym.name.length() == 0 && sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Printer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Flags;\n@@ -97,1 +98,0 @@\n-\n@@ -370,0 +370,13 @@\n+    public boolean isFlagSet(TypeSymbolFlags flag) {\n+        return false;\n+    }\n+    public boolean isFlagSetNoComplete(TypeSymbolFlags flag) {\n+        return false;\n+    }\n+    public boolean isFlagSet(MethodSymbolFlags flag) {\n+        return false;\n+    }\n+    public boolean isFlagSet(VarSymbolFlags flag) {\n+        return false;\n+    }\n+\n@@ -438,0 +451,5 @@\n+    public boolean isFinalOrEffectivellyFinal() {\n+        return isFinal() ||\n+                this.isFlagSet(VarSymbolFlags.EFFECTIVELY_FINAL);\n+    }\n+\n@@ -504,1 +522,1 @@\n-            type.getEnclosingType().hasTag(CLASS) && (flags() & (INTERFACE | NOOUTERTHIS)) == 0;\n+            type.getEnclosingType().hasTag(CLASS) && (flags() & INTERFACE) == 0 && !this.isFlagSet(TypeSymbolFlags.NOOUTERTHIS);\n@@ -635,1 +653,1 @@\n-                if ((sup.flags() & COMPOUND) != 0)\n+                if (sup.isFlagSet(TypeSymbolFlags.COMPOUND))\n@@ -829,0 +847,16 @@\n+        public boolean isFlagSet(TypeSymbolFlags flag) {\n+            return (flags() & flag.mask) != 0;\n+        }\n+\n+        public boolean isFlagSetNoComplete(TypeSymbolFlags flag) {\n+            return (flags_field & flag.mask) != 0;\n+        }\n+\n+        public void setFlag(TypeSymbolFlags flag) {\n+            flags_field |= flag.mask;\n+        }\n+\n+        public void clearFlag(TypeSymbolFlags flag) {\n+            flags_field &= ~flag.mask;\n+        }\n+\n@@ -1212,1 +1246,1 @@\n-            return (flags_field & EXISTS) != 0;\n+            return this.isFlagSetNoComplete(TypeSymbolFlags.EXISTS);\n@@ -1705,0 +1739,12 @@\n+        public boolean isFlagSet(VarSymbolFlags flag) {\n+            return (flags_field & flag.mask) != 0;\n+        }\n+\n+        public void setFlag(VarSymbolFlags flag) {\n+            flags_field |= flag.mask;\n+        }\n+\n+        public void clearFlag(VarSymbolFlags flag) {\n+            flags_field &= ~flag.mask;\n+        }\n+\n@@ -1719,1 +1765,1 @@\n-            } else if ((flags & MATCH_BINDING) != 0) {\n+            } else if (this.isFlagSet(VarSymbolFlags.MATCH_BINDING)) {\n@@ -1852,2 +1898,2 @@\n-            if ((flags_field & NAME_FILLED) == 0) {\n-                flags_field |= NAME_FILLED;\n+            if (!this.isFlagSet(VarSymbolFlags.NAME_FILLED)) {\n+                this.setFlag(VarSymbolFlags.NAME_FILLED);\n@@ -1874,1 +1920,2 @@\n-            super(flags | Flags.HASINIT | Flags.MATCH_BINDING, name, type, owner);\n+            super(flags | Flags.HASINIT, name, type, owner);\n+            this.setFlag(VarSymbolFlags.MATCH_BINDING);\n@@ -1886,1 +1933,1 @@\n-            flags_field |= Flags.MATCH_BINDING_TO_OUTER;\n+            this.setFlag(VarSymbolFlags.MATCH_BINDING_TO_OUTER);\n@@ -1890,1 +1937,1 @@\n-            return (flags_field & Flags.MATCH_BINDING_TO_OUTER) != 0;\n+            return this.isFlagSet(VarSymbolFlags.MATCH_BINDING_TO_OUTER);\n@@ -1923,0 +1970,12 @@\n+        public boolean isFlagSet(MethodSymbolFlags flag) {\n+            return (flags_field & flag.mask) != 0;\n+        }\n+\n+        public void setFlag(MethodSymbolFlags flag) {\n+            flags_field |= flag.mask;\n+        }\n+\n+        public void clearFlag(MethodSymbolFlags flag) {\n+            flags_field &= ~flag.mask;\n+        }\n+\n@@ -2151,1 +2210,1 @@\n-            return (flags() & LAMBDA_METHOD) == LAMBDA_METHOD;\n+            return this.isFlagSet(MethodSymbolFlags.LAMBDA_METHOD);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symbol.java","additions":70,"deletions":11,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -381,1 +381,2 @@\n-        sym.flags_field = PUBLIC|ACYCLIC|ANNOTATION|INTERFACE;\n+        sym.flags_field = PUBLIC|ANNOTATION|INTERFACE;\n+        sym.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -462,1 +463,2 @@\n-        errSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.any, null, rootPackage);\n+        errSymbol = new ClassSymbol(PUBLIC|STATIC, names.any, null, rootPackage);\n+        errSymbol.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -465,1 +467,2 @@\n-        unknownSymbol = new ClassSymbol(PUBLIC|STATIC|ACYCLIC, names.fromString(\"<any?>\"), null, rootPackage);\n+        unknownSymbol = new ClassSymbol(PUBLIC|STATIC, names.fromString(\"<any?>\"), null, rootPackage);\n+        unknownSymbol.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -484,1 +487,2 @@\n-        arrayClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Array, noSymbol);\n+        arrayClass = new ClassSymbol(PUBLIC, names.Array, noSymbol);\n+        arrayClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -487,1 +491,2 @@\n-        boundClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Bound, noSymbol);\n+        boundClass = new ClassSymbol(PUBLIC, names.Bound, noSymbol);\n+        boundClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -491,1 +496,2 @@\n-        methodClass = new ClassSymbol(PUBLIC|ACYCLIC, names.Method, noSymbol);\n+        methodClass = new ClassSymbol(PUBLIC, names.Method, noSymbol);\n+        methodClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -495,1 +501,2 @@\n-        predefClass = new ClassSymbol(PUBLIC|ACYCLIC, names.empty, rootPackage);\n+        predefClass = new ClassSymbol(PUBLIC, names.empty, rootPackage);\n+        predefClass.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -562,1 +569,1 @@\n-            new MethodSymbol(PROTECTED|FINAL|HYPOTHETICAL,\n+            new MethodSymbol(PROTECTED|FINAL,\n@@ -567,0 +574,1 @@\n+        enumFinalFinalize.setFlag(MethodSymbolFlags.HYPOTHETICAL);\n@@ -828,1 +836,1 @@\n-        unnamedPackage.flags_field |= EXISTS;\n+        unnamedPackage.setFlag(TypeSymbolFlags.EXISTS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":17,"deletions":9,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1070,1 +1070,1 @@\n-                if (sym.name.isEmpty() && (sym.flags() & COMPOUND) != 0) {\n+                if (sym.name.isEmpty() && sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n@@ -1267,1 +1267,1 @@\n-            Assert.check((csym.flags() & COMPOUND) != 0);\n+            Assert.check(csym.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -2402,1 +2402,2 @@\n-            this(new ClassSymbol(PUBLIC|STATIC|ACYCLIC, name, null, container), originalType);\n+            this(new ClassSymbol(PUBLIC|STATIC, name, null, container), originalType);\n+            tsym.setFlag(TypeSymbolFlags.ACYCLIC);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2502,1 +2502,1 @@\n-            new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC|COMPOUND|ACYCLIC,\n+            new ClassSymbol(ABSTRACT|PUBLIC|SYNTHETIC,\n@@ -2508,0 +2508,2 @@\n+        bc.setFlag(TypeSymbolFlags.COMPOUND);\n+        bc.setFlag(TypeSymbolFlags.ACYCLIC);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -384,1 +384,1 @@\n-                toAnnotate.flags_field |= Flags.VALUE_BASED;\n+                ((ClassSymbol) toAnnotate).setFlag(Flags.TypeSymbolFlags.VALUE_BASED);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Annotate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -824,1 +824,1 @@\n-            a.tsym.flags_field |= UNATTRIBUTED;\n+            a.tsym.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -836,1 +836,1 @@\n-            a.tsym.flags_field &= ~UNATTRIBUTED;\n+            a.tsym.clearFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -993,1 +993,1 @@\n-                    c.flags_field |= NOOUTERTHIS;\n+                    c.setFlag(TypeSymbolFlags.NOOUTERTHIS);\n@@ -1912,1 +1912,1 @@\n-            return t != null && t.tsym != null && (t.tsym.flags() & VALUE_BASED) != 0;\n+            return t != null && t.tsym != null && t.tsym.isFlagSet(TypeSymbolFlags.VALUE_BASED);\n@@ -1967,1 +1967,2 @@\n-                        c.param.sym.flags_field |= FINAL | UNION;\n+                        c.param.sym.flags_field |= FINAL;\n+                        c.param.sym.setFlag(VarSymbolFlags.UNION);\n@@ -5198,1 +5199,1 @@\n-            Assert.check((c.flags() & COMPOUND) != 0);\n+            Assert.check(c.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -5203,1 +5204,1 @@\n-            c.flags_field |= UNATTRIBUTED;\n+            c.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -5350,2 +5351,2 @@\n-        if ((c.flags_field & Flags.COMPOUND) == 0 &&\n-            (c.flags_field & Flags.SUPER_OWNER_ATTRIBUTED) == 0) {\n+        if (!c.isFlagSetNoComplete(TypeSymbolFlags.COMPOUND) &&\n+            !c.isFlagSetNoComplete(TypeSymbolFlags.SUPER_OWNER_ATTRIBUTED)) {\n@@ -5360,1 +5361,1 @@\n-            c.flags_field |= Flags.SUPER_OWNER_ATTRIBUTED;\n+            c.setFlag(TypeSymbolFlags.SUPER_OWNER_ATTRIBUTED);\n@@ -5366,2 +5367,2 @@\n-        if ((c.flags_field & UNATTRIBUTED) != 0) {\n-            c.flags_field &= ~UNATTRIBUTED;\n+        if (c.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED)) {\n+            c.clearFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -5495,1 +5496,2 @@\n-                    ((c.flags_field & (Flags.ENUM|Flags.COMPOUND)) == 0))\n+                    (c.flags_field & Flags.ENUM) == 0 &&\n+                    !c.isFlagSetNoComplete(TypeSymbolFlags.COMPOUND))\n@@ -5501,1 +5503,2 @@\n-                    ((c.flags_field & (Flags.ENUM | Flags.COMPOUND)) == 0)) {\n+                    (c.flags_field & Flags.ENUM) == 0 &&\n+                    !c.isFlagSetNoComplete(TypeSymbolFlags.COMPOUND)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -209,1 +210,1 @@\n-        if ((sym.flags_field & Flags.RECOVERABLE) != 0 && env.info.attributionMode.recover()) {\n+        if (sym.isFlagSet(TypeSymbolFlags.RECOVERABLE) && env.info.attributionMode.recover()) {\n@@ -240,1 +241,1 @@\n-                    errSymbol.flags_field |= Flags.RECOVERABLE;\n+                    errSymbol.setFlag(TypeSymbolFlags.RECOVERABLE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/AttrRecover.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -676,1 +676,1 @@\n-                    (sym.flags() & HYPOTHETICAL) != 0;\n+                        sym.isFlagSet(MethodSymbolFlags.HYPOTHETICAL);\n@@ -1046,1 +1046,1 @@\n-            } else if ((sym.flags() & (VARARGS | SIGNATURE_POLYMORPHIC)) == VARARGS) {\n+            } else if ((sym.flags() & VARARGS) == VARARGS && !sym.isFlagSet(MethodSymbolFlags.SIGNATURE_POLYMORPHIC)) {\n@@ -1798,1 +1798,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1810,1 +1810,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1827,1 +1827,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1854,1 +1854,1 @@\n-                m.flags_field |= BAD_OVERRIDE;\n+                m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1858,1 +1858,1 @@\n-                m.flags_field |= BAD_OVERRIDE;\n+                m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -1874,1 +1874,1 @@\n-            m.flags_field |= BAD_OVERRIDE;\n+            m.setFlag(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -2009,1 +2009,1 @@\n-        if ((site.tsym.flags() & COMPOUND) != 0) {\n+        if (site.tsym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n@@ -2191,1 +2191,1 @@\n-            (s.flags() & BAD_OVERRIDE) == 0;\n+            !s.isFlagSet(MethodSymbolFlags.BAD_OVERRIDE);\n@@ -2294,1 +2294,1 @@\n-            tree.sym.flags_field |= ACYCLIC;\n+            tree.sym.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -2361,1 +2361,1 @@\n-            if ((c.flags_field & ACYCLIC) != 0)\n+            if (c.isFlagSetNoComplete(TypeSymbolFlags.ACYCLIC))\n@@ -2414,1 +2414,1 @@\n-        if  (t.hasTag(TYPEVAR) && (t.tsym.flags() & UNATTRIBUTED) != 0)\n+        if  (t.hasTag(TYPEVAR) && t.tsym.isFlagSet(TypeSymbolFlags.UNATTRIBUTED))\n@@ -2438,2 +2438,2 @@\n-        Symbol c = t.tsym;\n-        if ((c.flags_field & ACYCLIC) != 0) return true;\n+        TypeSymbol c = t.tsym;\n+        if (c.isFlagSetNoComplete(TypeSymbolFlags.ACYCLIC)) return true;\n@@ -2441,1 +2441,1 @@\n-        if ((c.flags_field & LOCKED) != 0) {\n+        if (c.isFlagSetNoComplete(TypeSymbolFlags.LOCKED)) {\n@@ -2445,1 +2445,1 @@\n-                c.flags_field |= LOCKED;\n+                c.setFlag(TypeSymbolFlags.LOCKED);\n@@ -2460,1 +2460,1 @@\n-                c.flags_field &= ~LOCKED;\n+                c.clearFlag(TypeSymbolFlags.LOCKED);\n@@ -2464,2 +2464,2 @@\n-            complete = ((c.flags_field & UNATTRIBUTED) == 0) && c.isCompleted();\n-        if (complete) c.flags_field |= ACYCLIC;\n+            complete = !c.isFlagSetNoComplete(TypeSymbolFlags.UNATTRIBUTED) && c.isCompleted();\n+        if (complete) c.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -2478,1 +2478,1 @@\n-        c.flags_field |= ACYCLIC;\n+        c.setFlag(TypeSymbolFlags.ACYCLIC);\n@@ -2729,2 +2729,2 @@\n-                (msym1.flags() & POTENTIALLY_AMBIGUOUS) == 0 &&\n-                (msym2.flags() & POTENTIALLY_AMBIGUOUS) == 0) {\n+                !msym1.isFlagSet(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS) &&\n+                !msym2.isFlagSet(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS)) {\n@@ -2764,2 +2764,2 @@\n-                msym1.flags_field |= POTENTIALLY_AMBIGUOUS;\n-                msym2.flags_field |= POTENTIALLY_AMBIGUOUS;\n+                msym1.setFlag(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS);\n+                msym2.setFlag(MethodSymbolFlags.POTENTIALLY_AMBIGUOUS);\n@@ -3589,1 +3589,1 @@\n-        if ((s.flags() & PROPRIETARY) != 0) {\n+        if (s.isFlagSet(TypeSymbolFlags.PROPRIETARY)) {\n@@ -3597,1 +3597,1 @@\n-        if (profile != Profile.DEFAULT && (s.flags() & NOT_IN_PROFILE) != 0) {\n+        if (profile != Profile.DEFAULT && s.isFlagSet(TypeSymbolFlags.NOT_IN_PROFILE)) {\n@@ -3634,1 +3634,1 @@\n-        Assert.check((tree.sym.flags_field & LOCKED) == 0);\n+        Assert.check(!tree.sym.isFlagSetNoComplete(TypeSymbolFlags.LOCKED));\n@@ -3636,1 +3636,1 @@\n-            tree.sym.flags_field |= LOCKED;\n+            tree.sym.setFlag(TypeSymbolFlags.LOCKED);\n@@ -3643,2 +3643,2 @@\n-            tree.sym.flags_field &= ~LOCKED;\n-            tree.sym.flags_field |= ACYCLIC_ANN;\n+            tree.sym.clearFlag(TypeSymbolFlags.LOCKED);\n+            tree.sym.setFlag(TypeSymbolFlags.ACYCLIC_ANN);\n@@ -3649,1 +3649,1 @@\n-        if ((tsym.flags_field & ACYCLIC_ANN) != 0)\n+        if (tsym.isFlagSetNoComplete(TypeSymbolFlags.ACYCLIC_ANN))\n@@ -3651,1 +3651,1 @@\n-        if ((tsym.flags_field & LOCKED) != 0) {\n+        if (tsym.isFlagSetNoComplete(TypeSymbolFlags.LOCKED)) {\n@@ -3656,1 +3656,1 @@\n-            tsym.flags_field |= LOCKED;\n+            tsym.setFlag(TypeSymbolFlags.LOCKED);\n@@ -3663,2 +3663,2 @@\n-            tsym.flags_field &= ~LOCKED;\n-            tsym.flags_field |= ACYCLIC_ANN;\n+            tsym.clearFlag(TypeSymbolFlags.LOCKED);\n+            tsym.setFlag(TypeSymbolFlags.ACYCLIC_ANN);\n@@ -3690,1 +3690,1 @@\n-        Map<Symbol,Symbol> callMap = new HashMap<>();\n+        Map<MethodSymbol,MethodSymbol> callMap = new HashMap<>();\n@@ -3697,2 +3697,3 @@\n-            if (TreeInfo.name(app.meth) == names._this) {\n-                callMap.put(meth.sym, TreeInfo.symbol(app.meth));\n+            Symbol invConstr = TreeInfo.symbol(app.meth);\n+            if (TreeInfo.name(app.meth) == names._this && invConstr != null && invConstr.kind == MTH) {\n+                callMap.put(meth.sym, (MethodSymbol) invConstr);\n@@ -3700,1 +3701,1 @@\n-                meth.sym.flags_field |= ACYCLIC;\n+                meth.sym.setFlag(MethodSymbolFlags.ACYCLIC_CONSTRUCTOR);\n@@ -3705,1 +3706,1 @@\n-        Symbol[] ctors = new Symbol[0];\n+        MethodSymbol[] ctors = new MethodSymbol[0];\n@@ -3707,1 +3708,1 @@\n-        for (Symbol caller : ctors) {\n+        for (MethodSymbol caller : ctors) {\n@@ -3715,4 +3716,4 @@\n-    private void checkCyclicConstructor(JCClassDecl tree, Symbol ctor,\n-                                        Map<Symbol,Symbol> callMap) {\n-        if (ctor != null && (ctor.flags_field & ACYCLIC) == 0) {\n-            if ((ctor.flags_field & LOCKED) != 0) {\n+    private void checkCyclicConstructor(JCClassDecl tree, MethodSymbol ctor,\n+                                        Map<MethodSymbol,MethodSymbol> callMap) {\n+        if (ctor != null && !ctor.isFlagSet(MethodSymbolFlags.ACYCLIC_CONSTRUCTOR)) {\n+            if (ctor.isFlagSet(MethodSymbolFlags.LOCKED_CONSTRUCTOR)) {\n@@ -3722,1 +3723,1 @@\n-                ctor.flags_field |= LOCKED;\n+                ctor.setFlag(MethodSymbolFlags.LOCKED_CONSTRUCTOR);\n@@ -3724,1 +3725,1 @@\n-                ctor.flags_field &= ~LOCKED;\n+                ctor.clearFlag(MethodSymbolFlags.LOCKED_CONSTRUCTOR);\n@@ -3726,1 +3727,1 @@\n-            ctor.flags_field |= ACYCLIC;\n+            ctor.setFlag(MethodSymbolFlags.ACYCLIC_CONSTRUCTOR);\n@@ -3786,3 +3787,3 @@\n-                } else if ((sym.flags() & MATCH_BINDING) != 0 &&\n-                           (byName.flags() & MATCH_BINDING) != 0 &&\n-                           (byName.flags() & MATCH_BINDING_TO_OUTER) == 0) {\n+                } else if (sym.isFlagSet(VarSymbolFlags.MATCH_BINDING) &&\n+                           byName.isFlagSet(VarSymbolFlags.MATCH_BINDING) &&\n+                           !byName.isFlagSet(VarSymbolFlags.MATCH_BINDING_TO_OUTER)) {\n@@ -3901,1 +3902,1 @@\n-            (c.flags() & AUXILIARY) != 0 &&\n+            c.isFlagSet(TypeSymbolFlags.AUXILIARY) &&\n@@ -4109,1 +4110,1 @@\n-            || (check.sym.flags() & COMPOUND) != 0) {\n+            || check.sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n@@ -4268,1 +4269,1 @@\n-                    if ((current.flags() & Flags.AUTOMATIC_MODULE) != 0)\n+                    if (current.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE))\n@@ -4292,1 +4293,1 @@\n-            ((packge.flags() & Flags.HAS_RESOURCE) == 0)) {\n+            !packge.isFlagSet(TypeSymbolFlags.HAS_RESOURCE)) {\n@@ -4301,1 +4302,1 @@\n-        if ((rd.module.flags() & Flags.AUTOMATIC_MODULE) != 0) {\n+        if (rd.module.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":58,"deletions":57,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -374,1 +374,1 @@\n-                    q.flags_field |= EXISTS;\n+                    ((PackageSymbol) q).setFlag(TypeSymbolFlags.EXISTS);\n@@ -428,1 +428,1 @@\n-                q.flags_field |= EXISTS;\n+                ((PackageSymbol) q).setFlag(TypeSymbolFlags.EXISTS);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Enter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1563,1 +1563,1 @@\n-                (sym.flags() & (FINAL | EFFECTIVELY_FINAL)) != 0 &&\n+                sym.isFinalOrEffectivellyFinal() &&\n@@ -1999,1 +1999,1 @@\n-                sym.flags_field |= EFFECTIVELY_FINAL;\n+                sym.setFlag(VarSymbolFlags.EFFECTIVELY_FINAL);\n@@ -2012,1 +2012,1 @@\n-                if ((sym.flags() & EFFECTIVELY_FINAL) != 0) {\n+                if (sym.isFlagSet(VarSymbolFlags.EFFECTIVELY_FINAL)) {\n@@ -2017,1 +2017,1 @@\n-                        sym.flags_field &= ~EFFECTIVELY_FINAL;\n+                        sym.clearFlag(VarSymbolFlags.EFFECTIVELY_FINAL);\n@@ -2024,1 +2024,1 @@\n-                        if ((sym.flags() & UNION) != 0) { \/\/multi-catch parameter\n+                        if (sym.isFlagSet(VarSymbolFlags.UNION)) { \/\/multi-catch parameter\n@@ -2278,1 +2278,1 @@\n-                if ((tree.sym.flags() & (SYNTHETIC | LAMBDA_METHOD)) == SYNTHETIC) {\n+                if ((tree.sym.flags() & SYNTHETIC) == SYNTHETIC && !tree.sym.isFlagSet(MethodSymbolFlags.LAMBDA_METHOD)) {\n@@ -2330,4 +2330,4 @@\n-                                        \/*  this way we indicate Lower that it should generate an initialization for this field\n-                                         *  in the compact constructor\n-                                         *\/\n-                                            var.flags_field |= UNINITIALIZED_FIELD;\n+                                            \/*  this way we indicate Lower that it should generate an initialization for this field\n+                                             *  in the compact constructor\n+                                             *\/\n+                                            var.setFlag(VarSymbolFlags.UNINITIALIZED_FIELD);\n@@ -3082,1 +3082,1 @@\n-                        if ((sym.flags() & (EFFECTIVELY_FINAL | FINAL)) == 0) {\n+                        if (!sym.isFinalOrEffectivellyFinal()) {\n@@ -3229,1 +3229,1 @@\n-                    if (var != null && (var.flags() & (FINAL | EFFECTIVELY_FINAL)) == 0) {\n+                    if (var != null && !var.isFinalOrEffectivellyFinal()) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2209,1 +2209,1 @@\n-                translatedSym.flags_field = SYNTHETIC | LAMBDA_METHOD |\n+                translatedSym.flags_field = SYNTHETIC |\n@@ -2215,0 +2215,2 @@\n+                translatedSym.setFlag(MethodSymbolFlags.LAMBDA_METHOD);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/LambdaToMethod.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1498,1 +1498,2 @@\n-            new VarSymbol(flags | NOOUTERTHIS, outerThisName(target, owner), target, owner);\n+            new VarSymbol(flags, outerThisName(target, owner), target, owner);\n+        outerThis.setFlag(VarSymbolFlags.NOOUTERTHIS);\n@@ -1745,1 +1746,1 @@\n-        ot.flags_field &= ~NOOUTERTHIS;\n+        ot.clearFlag(VarSymbolFlags.NOOUTERTHIS);\n@@ -1763,1 +1764,1 @@\n-            ot.flags_field &= ~NOOUTERTHIS;\n+            ot.clearFlag(VarSymbolFlags.NOOUTERTHIS);\n@@ -1803,1 +1804,1 @@\n-        ot.flags_field &= ~NOOUTERTHIS;\n+        ot.clearFlag(VarSymbolFlags.NOOUTERTHIS);\n@@ -1816,1 +1817,1 @@\n-            ot.flags_field &= ~NOOUTERTHIS;\n+            ot.clearFlag(VarSymbolFlags.NOOUTERTHIS);\n@@ -2284,1 +2285,1 @@\n-      if ((outerThisStack.head.flags_field & NOOUTERTHIS) == 0)  {\n+      if (!outerThisStack.head.isFlagSet(VarSymbolFlags.NOOUTERTHIS))  {\n@@ -2778,1 +2779,1 @@\n-                if ((field.flags_field & Flags.UNINITIALIZED_FIELD) != 0) {\n+                if (field.isFlagSet(VarSymbolFlags.UNINITIALIZED_FIELD)) {\n@@ -2787,1 +2788,1 @@\n-                    field.flags_field &= ~Flags.UNINITIALIZED_FIELD;\n+                    field.clearFlag(VarSymbolFlags.UNINITIALIZED_FIELD);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Lower.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-            m.flags_field |= SIGNATURE_POLYMORPHIC;\n+            m.setFlag(MethodSymbolFlags.SIGNATURE_POLYMORPHIC);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/MemberEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -113,1 +113,1 @@\n-import static com.sun.tools.javac.code.Flags.UNATTRIBUTED;\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -376,1 +376,1 @@\n-                        patchesAutomaticModules |= (msym.flags_field & Flags.AUTOMATIC_MODULE) != 0;\n+                        patchesAutomaticModules |= msym.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE);\n@@ -465,1 +465,1 @@\n-                                if ((defaultModule.flags_field & Flags.AUTOMATIC_MODULE) == 0) {\n+                                if (!defaultModule.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n@@ -634,1 +634,1 @@\n-            } else if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {\n+            } else if (msym.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n@@ -711,1 +711,1 @@\n-            Set<RequiresFlag> flags = (ms.flags_field & Flags.AUTOMATIC_MODULE) != 0 ?\n+            Set<RequiresFlag> flags = ms.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE) ?\n@@ -731,1 +731,1 @@\n-                msym.flags_field |= UNATTRIBUTED;\n+                msym.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -744,1 +744,1 @@\n-                    msym.flags_field &= ~UNATTRIBUTED;\n+                    msym.clearFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -1254,1 +1254,1 @@\n-        Predicate<ModuleSymbol> systemModulePred = sym -> (sym.flags() & Flags.SYSTEM_MODULE) != 0;\n+        Predicate<ModuleSymbol> systemModulePred = sym -> sym.isFlagSet(TypeSymbolFlags.SYSTEM_MODULE);\n@@ -1363,1 +1363,1 @@\n-                m -> (m.flags_field & Flags.AUTOMATIC_MODULE) != 0;\n+                m -> m.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE);\n@@ -1401,1 +1401,1 @@\n-                if (!result.add(current) || current == syms.unnamedModule || ((current.flags_field & Flags.AUTOMATIC_MODULE) != 0))\n+                if (!result.add(current) || current == syms.unnamedModule || current.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE))\n@@ -1466,1 +1466,1 @@\n-        if ((msym.flags_field & Flags.AUTOMATIC_MODULE) != 0) {\n+        if (msym.isFlagSetNoComplete(TypeSymbolFlags.AUTOMATIC_MODULE)) {\n@@ -1489,1 +1489,1 @@\n-                    Assert.check((msym.flags() & Flags.AUTOMATIC_MODULE) == 0);\n+                    Assert.check(!msym.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE));\n@@ -1651,1 +1651,1 @@\n-            if (!allowAccessIntoSystem && (msym.flags() & Flags.SYSTEM_MODULE) != 0) {\n+            if (!allowAccessIntoSystem && msym.isFlagSet(TypeSymbolFlags.SYSTEM_MODULE)) {\n@@ -1731,1 +1731,1 @@\n-            if (!allowAccessIntoSystem && (msym.flags() & Flags.SYSTEM_MODULE) != 0) {\n+            if (!allowAccessIntoSystem && msym.isFlagSet(TypeSymbolFlags.SYSTEM_MODULE)) {\n@@ -1770,1 +1770,1 @@\n-                if ((current.flags() & Flags.AUTOMATIC_MODULE) != 0)\n+                if (current.isFlagSet(TypeSymbolFlags.AUTOMATIC_MODULE))\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Modules.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2779,1 +2779,1 @@\n-                    if ((msym.flags() & SIGNATURE_POLYMORPHIC) != 0) {\n+                    if (msym.isFlagSet(MethodSymbolFlags.SIGNATURE_POLYMORPHIC)) {\n@@ -2830,1 +2830,1 @@\n-        long flags = ABSTRACT | HYPOTHETICAL |\n+        long flags = ABSTRACT |\n@@ -2832,1 +2832,1 @@\n-        Symbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {\n+        MethodSymbol msym = new MethodSymbol(flags, spMethod.name, mtype, spMethod.owner) {\n@@ -2838,0 +2838,1 @@\n+        msym.setFlag(MethodSymbolFlags.HYPOTHETICAL);\n@@ -3153,1 +3154,1 @@\n-            if ((msym.flags() & SIGNATURE_POLYMORPHIC) != 0) {\n+            if (msym.isFlagSet(MethodSymbolFlags.SIGNATURE_POLYMORPHIC)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import com.sun.tools.javac.code.Flags.VarSymbolFlags;\n@@ -741,1 +742,1 @@\n-        if ((tree.sym.flags() & Flags.MATCH_BINDING) != 0) {\n+        if (tree.sym.isFlagSet(VarSymbolFlags.MATCH_BINDING)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransPatterns.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -924,1 +924,1 @@\n-        if (myEnv == null || (c.flags_field & TYPE_TRANSLATED) != 0) {\n+        if (myEnv == null || c.isFlagSetNoComplete(TypeSymbolFlags.TYPE_TRANSLATED)) {\n@@ -927,1 +927,1 @@\n-        c.flags_field |= TYPE_TRANSLATED;\n+        c.setFlag(TypeSymbolFlags.TYPE_TRANSLATED);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -189,1 +189,1 @@\n-            Assert.check((sym.flags() & Flags.COMPOUND) == 0);\n+            Assert.check(!sym.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -195,0 +195,2 @@\n+            ClassSymbol csym = (ClassSymbol) sym;\n+\n@@ -196,1 +198,1 @@\n-            sym.flags_field |= UNATTRIBUTED;\n+            csym.setFlag(TypeSymbolFlags.UNATTRIBUTED);\n@@ -202,1 +204,1 @@\n-                queue = completeClass.completeEnvs(List.of(typeEnvs.get((ClassSymbol) sym)));\n+                queue = completeClass.completeEnvs(List.of(typeEnvs.get(csym)));\n@@ -920,1 +922,1 @@\n-                sym.flags_field |= AUXILIARY;\n+                sym.setFlag(TypeSymbolFlags.AUXILIARY);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -929,1 +929,1 @@\n-                        c.flags_field |= AUXILIARY;\n+                        c.setFlag(TypeSymbolFlags.AUXILIARY);\n@@ -1434,4 +1434,6 @@\n-            if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName())\n-                sym.flags_field |= PROPRIETARY;\n-            else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {\n-                if (profile != Profile.DEFAULT) {\n+            if (proxy.type.tsym.flatName() == syms.proprietaryType.tsym.flatName()) {\n+                if (sym instanceof TypeSymbol) {\n+                    ((TypeSymbol) sym).setFlag(TypeSymbolFlags.PROPRIETARY);\n+                }\n+            } else if (proxy.type.tsym.flatName() == syms.profileType.tsym.flatName()) {\n+                if (profile != Profile.DEFAULT && sym instanceof TypeSymbol) {\n@@ -1441,1 +1443,1 @@\n-                                sym.flags_field |= NOT_IN_PROFILE;\n+                                ((TypeSymbol) sym).setFlag(TypeSymbolFlags.NOT_IN_PROFILE);\n@@ -1451,1 +1453,1 @@\n-                sym.flags_field |= VALUE_BASED;\n+                ((ClassSymbol) sym).setFlag(TypeSymbolFlags.VALUE_BASED);\n@@ -1464,1 +1466,1 @@\n-                    sym.flags_field |= VALUE_BASED;\n+                    ((ClassSymbol) sym).setFlag(TypeSymbolFlags.VALUE_BASED);\n@@ -2248,1 +2250,1 @@\n-            m.flags_field |= SIGNATURE_POLYMORPHIC;\n+            m.setFlag(MethodSymbolFlags.SIGNATURE_POLYMORPHIC);\n@@ -2400,1 +2402,1 @@\n-        long flags = PARAMETER;\n+        boolean nameFilled = false;\n@@ -2402,0 +2404,1 @@\n+        int flags = 0;\n@@ -2409,1 +2412,1 @@\n-            flags |= NAME_FILLED;\n+            nameFilled = true;\n@@ -2420,1 +2423,6 @@\n-        return new ParamSymbol(flags, argName, t, owner);\n+        Assert.check(flags < Flags.LAST_FLAT_BIT * 2);\n+        ParamSymbol psym = new ParamSymbol(PARAMETER | flags, argName, t, owner);\n+        if (nameFilled) {\n+            psym.setFlag(VarSymbolFlags.NAME_FILLED);\n+        }\n+        return psym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -1475,1 +1475,1 @@\n-            if (sym.kind == MTH && (sym.flags() & HYPOTHETICAL) == 0)\n+            if (sym.kind == MTH && !sym.isFlagSet(MethodSymbolFlags.HYPOTHETICAL))\n@@ -1527,1 +1527,1 @@\n-        Assert.check((c.flags() & COMPOUND) == 0);\n+        Assert.check(!c.isFlagSet(TypeSymbolFlags.COMPOUND));\n@@ -1568,1 +1568,1 @@\n-            case MTH: if ((sym.flags() & HYPOTHETICAL) == 0) methodsCount++;\n+            case MTH: if (!sym.isFlagSet(MethodSymbolFlags.HYPOTHETICAL)) methodsCount++;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.tools.javac.code.Flags.MethodSymbolFlags;\n@@ -2189,1 +2190,1 @@\n-                ((var.sym.owner.flags() & Flags.LAMBDA_METHOD) == 0 ||\n+                (!var.sym.owner.isFlagSet(MethodSymbolFlags.LAMBDA_METHOD) ||\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/Code.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -727,1 +727,1 @@\n-        return (msym.flags() & Flags.AUTOMATIC_MODULE) != 0;\n+        return msym.isFlagSet(Flags.TypeSymbolFlags.AUTOMATIC_MODULE);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import static com.sun.tools.javac.code.Flags.COMPOUND;\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -136,1 +136,1 @@\n-        if (sym.name.length() == 0 && (sym.flags() & COMPOUND) != 0) {\n+        if (sym.name.length() == 0 && sym.isFlagSet(TypeSymbolFlags.COMPOUND)) {\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/TypePrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- *      jdk.compiler\/com.sun.tools.javac.code\n+ *      jdk.compiler\/com.sun.tools.javac.code:+open\n@@ -55,0 +55,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -63,0 +64,1 @@\n+import java.lang.reflect.Field;\n@@ -216,1 +218,2 @@\n-            flags &= ~(Flags.CLASS_SEEN | Flags.SOURCE_SEEN);\n+            flags &= ~(mask(TypeSymbolFlags.CLASS_SEEN) |\n+                       mask(TypeSymbolFlags.SOURCE_SEEN));\n@@ -229,0 +232,9 @@\n+    private static long mask(TypeSymbolFlags flag) {\n+        try {\n+            Field mask = TypeSymbolFlags.class.getDeclaredField(\"mask\");\n+            mask.setAccessible(true);\n+            return mask.getLong(flag);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(ex.getMessage(), ex);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/completionfailure\/NoAbortForBadClassFile.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+import com.sun.tools.javac.code.Flags.TypeSymbolFlags;\n@@ -370,1 +371,2 @@\n-            ClassType ct = Class(Flags.COMPOUND);\n+            ClassType ct = Class();\n+            ct.tsym.setFlag(TypeSymbolFlags.COMPOUND);\n","filename":"test\/langtools\/tools\/lib\/types\/TypeHarness.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}