{"files":[{"patch":"@@ -599,1 +599,1 @@\n-    __ ldr(rscratch2, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    __ ldr(rscratch2, Address(rthread, in_bytes(JVMCIThreadState::jvmci_alternate_call_target_offset())));\n@@ -603,1 +603,1 @@\n-    __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n+    __ str(zr, Address(rthread, in_bytes(JVMCIThreadState::jvmci_alternate_call_target_offset())));\n@@ -2252,2 +2252,2 @@\n-    __ ldr(lr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n-    __ str(zr, Address(rthread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n+    __ ldr(lr, Address(rthread, in_bytes(JVMCIThreadState::jvmci_implicit_exception_pc_offset())));\n+    __ str(zr, Address(rthread, in_bytes(JVMCIThreadState::jvmci_implicit_exception_pc_offset())));\n@@ -2263,1 +2263,1 @@\n-    __ ldrw(c_rarg1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+    __ ldrw(c_rarg1, Address(rthread, in_bytes(JVMCIThreadState::pending_deoptimization_offset())));\n@@ -2265,1 +2265,1 @@\n-    __ strw(rscratch1, Address(rthread, in_bytes(JavaThread::pending_deoptimization_offset())));\n+    __ strw(rscratch1, Address(rthread, in_bytes(JVMCIThreadState::pending_deoptimization_offset())));\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -507,1 +507,1 @@\n-    __ ldrb(rscratch1, Address(rthread, JavaThread::pending_monitorenter_offset()));\n+    __ ldrb(rscratch1, Address(rthread, JVMCIThreadState::pending_monitorenter_offset()));\n@@ -510,1 +510,1 @@\n-    __ strb(zr, Address(rthread, JavaThread::pending_monitorenter_offset()));\n+    __ strb(zr, Address(rthread, JVMCIThreadState::pending_monitorenter_offset()));\n@@ -518,1 +518,1 @@\n-      __ ldrb(rscratch1, Address(rthread, JavaThread::pending_monitorenter_offset()));\n+      __ ldrb(rscratch1, Address(rthread, JVMCIThreadState::pending_monitorenter_offset()));\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -855,1 +855,1 @@\n-    __ cmpptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);\n+    __ cmpptr(Address(r15_thread, in_bytes(JVMCIThreadState::jvmci_alternate_call_target_offset())), 0);\n@@ -858,2 +858,2 @@\n-    __ movptr(r11, Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())));\n-    __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_alternate_call_target_offset())), 0);\n+    __ movptr(r11, Address(r15_thread, in_bytes(JVMCIThreadState::jvmci_alternate_call_target_offset())));\n+    __ movptr(Address(r15_thread, in_bytes(JVMCIThreadState::jvmci_alternate_call_target_offset())), 0);\n@@ -2531,2 +2531,2 @@\n-    __ pushptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())));\n-    __ movptr(Address(r15_thread, in_bytes(JavaThread::jvmci_implicit_exception_pc_offset())), (int32_t)NULL_WORD);\n+    __ pushptr(Address(r15_thread, in_bytes(JVMCIThreadState::jvmci_implicit_exception_pc_offset())));\n+    __ movptr(Address(r15_thread, in_bytes(JVMCIThreadState::jvmci_implicit_exception_pc_offset())), (int32_t)NULL_WORD);\n@@ -2541,2 +2541,2 @@\n-    __ movl(c_rarg1, Address(r15_thread, in_bytes(JavaThread::pending_deoptimization_offset())));\n-    __ movl(Address(r15_thread, in_bytes(JavaThread::pending_deoptimization_offset())), -1);\n+    __ movl(c_rarg1, Address(r15_thread, in_bytes(JVMCIThreadState::pending_deoptimization_offset())));\n+    __ movl(Address(r15_thread, in_bytes(JVMCIThreadState::pending_deoptimization_offset())), -1);\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-    __ cmpb(Address(thread, JavaThread::pending_monitorenter_offset()), 0);\n+    __ cmpb(Address(thread, JVMCIThreadState::pending_monitorenter_offset()), 0);\n@@ -269,1 +269,1 @@\n-    __ movb(Address(thread, JavaThread::pending_monitorenter_offset()), 0);\n+    __ movb(Address(thread, JVMCIThreadState::pending_monitorenter_offset()), 0);\n@@ -279,1 +279,1 @@\n-      __ cmpb(Address(r15_thread, JavaThread::pending_monitorenter_offset()), 0);\n+      __ cmpb(Address(r15_thread, JVMCIThreadState::pending_monitorenter_offset()), 0);\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -726,3 +726,3 @@\n-    thread->set_jvmci_implicit_exception_pc(pc);\n-    thread->set_pending_deoptimization(Deoptimization::make_trap_request(deopt_reason,\n-                                                                         Deoptimization::Action_reinterpret));\n+    thread->jvmci().set_jvmci_implicit_exception_pc(pc);\n+    thread->jvmci().set_pending_deoptimization(Deoptimization::make_trap_request(deopt_reason,\n+                                                                                 Deoptimization::Action_reinterpret));\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3547,1 +3547,1 @@\n-  jlong speculation = thread->pending_failed_speculation();\n+  jlong speculation = thread->jvmci().pending_failed_speculation();\n@@ -3551,1 +3551,1 @@\n-    thread->set_pending_failed_speculation(0);\n+    thread->jvmci().set_pending_failed_speculation(0);\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+#include \"runtime\/threadSMR.inline.hpp\"\n+#include \"runtime\/vmThread.hpp\"\n@@ -293,0 +295,153 @@\n+\n+jlong* JVMCI::_jvmci_old_thread_counters;\n+\n+bool jvmci_counters_include(JavaThread* thread) {\n+  return !JVMCICountersExcludeCompiler || !thread->is_Compiler_thread();\n+}\n+\n+void JVMCI::collect_counters(jlong* array, int length) {\n+  assert(length == JVMCICounterSize, \"wrong value\");\n+  for (int i = 0; i < length; i++) {\n+    array[i] = _jvmci_old_thread_counters[i];\n+  }\n+  for (JavaThread* tp : ThreadsListHandle()) {\n+    if (jvmci_counters_include(tp)) {\n+      for (int i = 0; i < length; i++) {\n+        array[i] += tp->jvmci()._jvmci_counters[i];\n+      }\n+    }\n+  }\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {\n+  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n+  if (new_counters == NULL) {\n+    return NULL;\n+  }\n+  if (old_counters == NULL) {\n+    old_counters = new_counters;\n+    memset(old_counters, 0, sizeof(jlong) * new_size);\n+  } else {\n+    for (int i = 0; i < MIN2((int) current_size, new_size); i++) {\n+      new_counters[i] = old_counters[i];\n+    }\n+    if (new_size > current_size) {\n+      memset(new_counters + current_size, 0, sizeof(jlong) * (new_size - current_size));\n+    }\n+    FREE_C_HEAP_ARRAY(jlong, old_counters);\n+  }\n+  return new_counters;\n+}\n+\n+\/\/ Attempt to enlarge the array for per thread counters.\n+bool JVMCI::resize_counters(JavaThread* thread, int current_size, int new_size) {\n+  jlong* new_counters = resize_counters_array(thread->jvmci()._jvmci_counters, current_size, new_size);\n+  if (new_counters == NULL) {\n+    return false;\n+  } else {\n+    thread->jvmci()._jvmci_counters = new_counters;\n+    return true;\n+  }\n+}\n+\n+class VM_JVMCIResizeCounters : public VM_Operation {\n+ private:\n+  int _new_size;\n+  bool _failed;\n+\n+ public:\n+  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n+  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n+  bool allow_nested_vm_operations() const        { return true; }\n+  void doit() {\n+    \/\/ Resize the old thread counters array\n+    jlong* new_counters = resize_counters_array(JVMCI::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n+    if (new_counters == NULL) {\n+      _failed = true;\n+      return;\n+    } else {\n+      JVMCI::_jvmci_old_thread_counters = new_counters;\n+    }\n+\n+    \/\/ Now resize each threads array\n+    for (JavaThread* tp : ThreadsListHandle()) {\n+      if (!JVMCI::resize_counters(tp, JVMCICounterSize, _new_size)) {\n+        _failed = true;\n+        break;\n+      }\n+    }\n+    if (!_failed) {\n+      JVMCICounterSize = _new_size;\n+    }\n+  }\n+\n+  bool failed() { return _failed; }\n+};\n+\n+bool JVMCI::resize_all_jvmci_counters(int new_size) {\n+  VM_JVMCIResizeCounters op(new_size);\n+  VMThread::execute(&op);\n+  return !op.failed();\n+}\n+\n+void JVMCI::free_counters(JavaThread* thread) {\n+  if (JVMCICounterSize > 0) {\n+    FREE_C_HEAP_ARRAY(jlong, thread->jvmci()._jvmci_counters);\n+  }\n+}\n+\n+void JVMCI::accumulate_counters(JavaThread* thread) {\n+  if (JVMCICounterSize > 0) {\n+    if (jvmci_counters_include(thread)) {\n+      for (int i = 0; i < JVMCICounterSize; i++) {\n+        _jvmci_old_thread_counters[i] += thread->jvmci()._jvmci_counters[i];\n+      }\n+    }\n+  }\n+}\n+\n+void JVMCI::init_counters() {\n+  if (JVMCICounterSize > 0) {\n+    JVMCI::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtJVMCI);\n+    memset(JVMCI::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);\n+  } else {\n+    JVMCI::_jvmci_old_thread_counters = NULL;\n+  }\n+}\n+\n+void JVMCI::free_counters() {\n+  if (JVMCICounterSize > 0) {\n+    FREE_C_HEAP_ARRAY(jlong, JVMCI::_jvmci_old_thread_counters);\n+  }\n+}\n+\n+ByteSize JVMCIThreadState::pending_deoptimization_offset() {\n+ return JavaThread::jvmci_state_offset() + byte_offset_of(JVMCIThreadState, _pending_deoptimization);\n+}\n+\n+ByteSize JVMCIThreadState::pending_monitorenter_offset() {\n+ return JavaThread::jvmci_state_offset() + byte_offset_of(JVMCIThreadState, _pending_monitorenter);\n+}\n+\n+ByteSize JVMCIThreadState::jvmci_alternate_call_target_offset() {\n+ return JavaThread::jvmci_state_offset() + byte_offset_of(JVMCIThreadState, _union._alternate_call_target);\n+}\n+\n+ByteSize JVMCIThreadState::jvmci_implicit_exception_pc_offset() {\n+ return JavaThread::jvmci_state_offset() + byte_offset_of(JVMCIThreadState, _union._implicit_exception_pc);\n+}\n+\n+JVMCIThreadState::JVMCIThreadState():\n+  _pending_deoptimization(-1),\n+  _pending_monitorenter(false),\n+  _pending_transfer_to_interpreter(false),\n+  _in_retryable_allocation(false),\n+  _pending_failed_speculation(0),\n+  _union{nullptr},\n+  _jvmci_counters(nullptr),\n+  _jvmci_reserved0(0),\n+  _jvmci_reserved1(0),\n+  _jvmci_reserved_oop0(nullptr)\n+{\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.cpp","additions":155,"deletions":0,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+  friend class VM_JVMCIResizeCounters;\n@@ -97,0 +98,3 @@\n+  \/\/ Accumulated counters for threads which have exited.\n+  static jlong* _jvmci_old_thread_counters;\n+\n@@ -159,1 +163,0 @@\n- public:\n@@ -166,0 +169,97 @@\n+\n+  \/\/ Manage shared global counter storage\n+  static void init_counters();\n+  static void free_counters();\n+  static bool resize_all_jvmci_counters(int new_size);\n+\n+  \/\/ Return the total of the counters from all live and exited threads\n+  static void collect_counters(jlong* array, int length);\n+\n+  \/\/ Accumulate the counters of this exiting thread into the global counts\n+  static void accumulate_counters(JavaThread* thread);\n+\n+  \/\/ Release the storage for the per thread counters\n+  static void free_counters(JavaThread* thread);\n+\n+  \/\/ Enlarge the per thread counter storage\n+  static bool resize_counters(JavaThread* thread, int current_size, int new_size);\n+};\n+\n+\n+\n+class JVMCIThreadState {\n+ public:\n+  JVMCIThreadState();\n+\n+ private:\n+  friend class JVMCI;\n+  friend class JVMCIVMStructs;\n+\n+  \/\/ The _pending_* fields below are used to communicate extra information\n+  \/\/ from an uncommon trap in JVMCI compiled code to the uncommon trap handler.\n+\n+  \/\/ Communicates the DeoptReason and DeoptAction of the uncommon trap\n+  int _pending_deoptimization;\n+\n+  \/\/ Specifies whether the uncommon trap is to bci 0 of a synchronized method\n+  \/\/ before the monitor has been acquired.\n+  bool _pending_monitorenter;\n+\n+  \/\/ Specifies if the DeoptReason for the last uncommon trap was Reason_transfer_to_interpreter\n+  bool _pending_transfer_to_interpreter;\n+\n+  \/\/ True if in a runtime call from compiled code that will deoptimize\n+  \/\/ and re-execute a failed heap allocation in the interpreter.\n+  bool _in_retryable_allocation;\n+\n+  \/\/ An id of a speculation that JVMCI compiled code can use to further describe and\n+  \/\/ uniquely identify the speculative optimization guarded by an uncommon trap.\n+  \/\/ See JVMCINMethodData::SPECULATION_LENGTH_BITS for further details.\n+  jlong _pending_failed_speculation;\n+\n+  \/\/ These fields are mutually exclusive in terms of live ranges.\n+  union {\n+    \/\/ Communicates the pc at which the most recent implicit exception occurred\n+    \/\/ from the signal handler to a deoptimization stub.\n+    address _implicit_exception_pc;\n+\n+    \/\/ Communicates an alternative call target to an i2c stub from a JavaCall .\n+    address _alternate_call_target;\n+  } _union;\n+\n+  \/\/ Support for high precision, thread sensitive counters in JVMCI compiled code.\n+  jlong* _jvmci_counters;\n+\n+  \/\/ Fast thread locals for use by JVMCI\n+  jlong _jvmci_reserved0;\n+  jlong _jvmci_reserved1;\n+  oop _jvmci_reserved_oop0;\n+\n+ public :\n+  int  pending_deoptimization() const             { return _pending_deoptimization; }\n+  jlong pending_failed_speculation() const        { return _pending_failed_speculation; }\n+  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n+  void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }\n+  void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }\n+  void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }\n+  void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }\n+  void set_jvmci_alternate_call_target(address a) { assert(_union._alternate_call_target == NULL, \"must be\"); _union._alternate_call_target = a; }\n+  void set_jvmci_implicit_exception_pc(address a) { assert(_union._implicit_exception_pc == NULL, \"must be\"); _union._implicit_exception_pc = a; }\n+  address implicit_exception_pc()                 { return _union._implicit_exception_pc; }\n+  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n+  bool in_retryable_allocation() const            { return _in_retryable_allocation; }\n+\n+  void set_jvmci_reserved_oop0(oop value) { _jvmci_reserved_oop0 = value;  }\n+  void set_jvmci_reserved0(jlong value)   { _jvmci_reserved0 = value;  }\n+  void set_jvmci_reserved1(jlong value)   { _jvmci_reserved1 = value;  }\n+\n+  oop get_jvmci_reserved_oop0()           { return _jvmci_reserved_oop0;  }\n+  jlong get_jvmci_reserved0()             { return _jvmci_reserved0;  }\n+  jlong get_jvmci_reserved1()             { return _jvmci_reserved1;  }\n+\n+  oop* jvmci_reserved_oop0_addr()         { return &_jvmci_reserved_oop0; }\n+\n+  static ByteSize pending_deoptimization_offset();\n+  static ByteSize pending_monitorenter_offset();\n+  static ByteSize jvmci_alternate_call_target_offset();\n+  static ByteSize jvmci_implicit_exception_pc_offset();\n","filename":"src\/hotspot\/share\/jvmci\/jvmci.hpp","additions":101,"deletions":1,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -1105,1 +1105,1 @@\n-    JavaThread::collect_counters(temp_array, JVMCICounterSize);\n+    JVMCI::collect_counters(temp_array, JVMCICounterSize);\n@@ -1116,1 +1116,1 @@\n-  return JavaThread::resize_all_jvmci_counters(new_size);\n+  return JVMCI::resize_all_jvmci_counters(new_size);\n@@ -2635,1 +2635,1 @@\n-    thread->set_jvmci_reserved_oop0(JNIHandles::resolve(value));\n+    thread->jvmci().set_jvmci_reserved_oop0(JNIHandles::resolve(value));\n@@ -2645,1 +2645,1 @@\n-    return JNIHandles::make_local(thread->get_jvmci_reserved_oop0());\n+    return JNIHandles::make_local(thread->jvmci().get_jvmci_reserved_oop0());\n@@ -2654,1 +2654,1 @@\n-    thread->set_jvmci_reserved0(value);\n+    thread->jvmci().set_jvmci_reserved0(value);\n@@ -2656,1 +2656,1 @@\n-    thread->set_jvmci_reserved1(value);\n+    thread->jvmci().set_jvmci_reserved1(value);\n@@ -2666,1 +2666,1 @@\n-    return thread->get_jvmci_reserved0();\n+    return thread->jvmci().get_jvmci_reserved0();\n@@ -2668,1 +2668,1 @@\n-    return thread->get_jvmci_reserved1();\n+    return thread->jvmci().get_jvmci_reserved1();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-      _thread->set_in_retryable_allocation(true);\n+      _thread->jvmci().set_in_retryable_allocation(true);\n@@ -105,1 +105,1 @@\n-      _thread->set_in_retryable_allocation(false);\n+      _thread->jvmci().set_in_retryable_allocation(false);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-#define VM_STRUCTS(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field) \\\n+#define VM_STRUCTS(nonstatic_field, nonstatic_field_alias, static_field, unchecked_nonstatic_field, volatile_nonstatic_field) \\\n@@ -182,7 +182,7 @@\n-  nonstatic_field(JavaThread,                  _pending_deoptimization,                       int)                                   \\\n-  nonstatic_field(JavaThread,                  _pending_failed_speculation,                   jlong)                                 \\\n-  nonstatic_field(JavaThread,                  _pending_transfer_to_interpreter,              bool)                                  \\\n-  nonstatic_field(JavaThread,                  _jvmci_counters,                               jlong*)                                \\\n-  nonstatic_field(JavaThread,                  _jvmci_reserved0,                              jlong)                                 \\\n-  nonstatic_field(JavaThread,                  _jvmci_reserved1,                              jlong)                                 \\\n-  nonstatic_field(JavaThread,                  _jvmci_reserved_oop0,                          oop)                                   \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._pending_deoptimization,          _pending_deoptimization,          int)    \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._pending_failed_speculation,      _pending_failed_speculation,      jlong)  \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._pending_transfer_to_interpreter, _pending_transfer_to_interpreter, bool)   \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._jvmci_counters,                  _jvmci_counters,                  jlong*) \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._jvmci_reserved0,                 _jvmci_reserved0,                 jlong)  \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._jvmci_reserved1,                 _jvmci_reserved1,                 jlong)  \\\n+  nonstatic_field_alias(JavaThread,            _jvmci_state._jvmci_reserved_oop0,             _jvmci_reserved_oop0,             oop)    \\\n@@ -791,0 +791,1 @@\n+             GENERATE_NONSTATIC_VM_STRUCT_ENTRY_ALIAS,\n@@ -904,0 +905,1 @@\n+             CHECK_NONSTATIC_VM_STRUCT_ENTRY_ALIAS,\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -588,1 +588,1 @@\n-    current->set_pending_monitorenter(false);\n+    current->jvmci().set_pending_monitorenter(false);\n@@ -1863,1 +1863,1 @@\n-    jlong           speculation = current->pending_failed_speculation();\n+    jlong           speculation = current->jvmci().pending_failed_speculation();\n@@ -1872,1 +1872,1 @@\n-      current->set_pending_monitorenter(true);\n+      current->jvmci().set_pending_monitorenter(true);\n@@ -1876,1 +1876,1 @@\n-      current->set_pending_transfer_to_interpreter(true);\n+      current->jvmci().set_pending_transfer_to_interpreter(true);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -411,1 +411,1 @@\n-          thread->set_jvmci_alternate_call_target(verified_entry_point);\n+          thread->jvmci().set_jvmci_alternate_call_target(verified_entry_point);\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -844,96 +844,0 @@\n-#if INCLUDE_JVMCI\n-\n-jlong* JavaThread::_jvmci_old_thread_counters;\n-\n-bool jvmci_counters_include(JavaThread* thread) {\n-  return !JVMCICountersExcludeCompiler || !thread->is_Compiler_thread();\n-}\n-\n-void JavaThread::collect_counters(jlong* array, int length) {\n-  assert(length == JVMCICounterSize, \"wrong value\");\n-  for (int i = 0; i < length; i++) {\n-    array[i] = _jvmci_old_thread_counters[i];\n-  }\n-  for (JavaThread* tp : ThreadsListHandle()) {\n-    if (jvmci_counters_include(tp)) {\n-      for (int i = 0; i < length; i++) {\n-        array[i] += tp->_jvmci_counters[i];\n-      }\n-    }\n-  }\n-}\n-\n-\/\/ Attempt to enlarge the array for per thread counters.\n-jlong* resize_counters_array(jlong* old_counters, int current_size, int new_size) {\n-  jlong* new_counters = NEW_C_HEAP_ARRAY_RETURN_NULL(jlong, new_size, mtJVMCI);\n-  if (new_counters == NULL) {\n-    return NULL;\n-  }\n-  if (old_counters == NULL) {\n-    old_counters = new_counters;\n-    memset(old_counters, 0, sizeof(jlong) * new_size);\n-  } else {\n-    for (int i = 0; i < MIN2((int) current_size, new_size); i++) {\n-      new_counters[i] = old_counters[i];\n-    }\n-    if (new_size > current_size) {\n-      memset(new_counters + current_size, 0, sizeof(jlong) * (new_size - current_size));\n-    }\n-    FREE_C_HEAP_ARRAY(jlong, old_counters);\n-  }\n-  return new_counters;\n-}\n-\n-\/\/ Attempt to enlarge the array for per thread counters.\n-bool JavaThread::resize_counters(int current_size, int new_size) {\n-  jlong* new_counters = resize_counters_array(_jvmci_counters, current_size, new_size);\n-  if (new_counters == NULL) {\n-    return false;\n-  } else {\n-    _jvmci_counters = new_counters;\n-    return true;\n-  }\n-}\n-\n-class VM_JVMCIResizeCounters : public VM_Operation {\n- private:\n-  int _new_size;\n-  bool _failed;\n-\n- public:\n-  VM_JVMCIResizeCounters(int new_size) : _new_size(new_size), _failed(false) { }\n-  VMOp_Type type()                  const        { return VMOp_JVMCIResizeCounters; }\n-  bool allow_nested_vm_operations() const        { return true; }\n-  void doit() {\n-    \/\/ Resize the old thread counters array\n-    jlong* new_counters = resize_counters_array(JavaThread::_jvmci_old_thread_counters, JVMCICounterSize, _new_size);\n-    if (new_counters == NULL) {\n-      _failed = true;\n-      return;\n-    } else {\n-      JavaThread::_jvmci_old_thread_counters = new_counters;\n-    }\n-\n-    \/\/ Now resize each threads array\n-    for (JavaThread* tp : ThreadsListHandle()) {\n-      if (!tp->resize_counters(JVMCICounterSize, _new_size)) {\n-        _failed = true;\n-        break;\n-      }\n-    }\n-    if (!_failed) {\n-      JVMCICounterSize = _new_size;\n-    }\n-  }\n-\n-  bool failed() { return _failed; }\n-};\n-\n-bool JavaThread::resize_all_jvmci_counters(int new_size) {\n-  VM_JVMCIResizeCounters op(new_size);\n-  VMThread::execute(&op);\n-  return !op.failed();\n-}\n-\n-#endif \/\/ INCLUDE_JVMCI\n-\n@@ -1010,12 +914,0 @@\n-#if INCLUDE_JVMCI\n-  _pending_deoptimization(-1),\n-  _pending_monitorenter(false),\n-  _pending_transfer_to_interpreter(false),\n-  _in_retryable_allocation(false),\n-  _pending_failed_speculation(0),\n-  _jvmci{nullptr},\n-  _jvmci_counters(nullptr),\n-  _jvmci_reserved0(0),\n-  _jvmci_reserved1(0),\n-  _jvmci_reserved_oop0(nullptr),\n-#endif \/\/ INCLUDE_JVMCI\n@@ -1055,1 +947,1 @@\n-  assert(_jvmci._implicit_exception_pc == nullptr, \"must be\");\n+  assert(jvmci().implicit_exception_pc() == nullptr, \"must be\");\n@@ -1057,1 +949,1 @@\n-    resize_counters(0, (int) JVMCICounterSize);\n+    JVMCI::resize_counters(this, 0, (int) JVMCICounterSize);\n@@ -1205,3 +1097,1 @@\n-  if (JVMCICounterSize > 0) {\n-    FREE_C_HEAP_ARRAY(jlong, _jvmci_counters);\n-  }\n+  JVMCI::free_counters(this);\n@@ -1465,7 +1355,1 @@\n-  if (JVMCICounterSize > 0) {\n-    if (jvmci_counters_include(this)) {\n-      for (int i = 0; i < JVMCICounterSize; i++) {\n-        _jvmci_old_thread_counters[i] += _jvmci_counters[i];\n-      }\n-    }\n-  }\n+  JVMCI::accumulate_counters(this);\n@@ -1974,1 +1858,1 @@\n-  f->do_oop((oop*) &_jvmci_reserved_oop0);\n+  f->do_oop((oop*) _jvmci_state.jvmci_reserved_oop0_addr());\n@@ -2780,6 +2664,1 @@\n-  if (JVMCICounterSize > 0) {\n-    JavaThread::_jvmci_old_thread_counters = NEW_C_HEAP_ARRAY(jlong, JVMCICounterSize, mtJVMCI);\n-    memset(JavaThread::_jvmci_old_thread_counters, 0, sizeof(jlong) * JVMCICounterSize);\n-  } else {\n-    JavaThread::_jvmci_old_thread_counters = NULL;\n-  }\n+  JVMCI::init_counters();\n@@ -3432,3 +3311,1 @@\n-  if (JVMCICounterSize > 0) {\n-    FREE_C_HEAP_ARRAY(jlong, JavaThread::_jvmci_old_thread_counters);\n-  }\n+  JVMCI::free_counters();\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":7,"deletions":130,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+#if INCLUDE_JVMCI\n+#include \"jvmci\/jvmci.hpp\"\n+#endif\n@@ -923,1 +926,0 @@\n-\n@@ -925,39 +927,1 @@\n-  \/\/ The _pending_* fields below are used to communicate extra information\n-  \/\/ from an uncommon trap in JVMCI compiled code to the uncommon trap handler.\n-\n-  \/\/ Communicates the DeoptReason and DeoptAction of the uncommon trap\n-  int       _pending_deoptimization;\n-\n-  \/\/ Specifies whether the uncommon trap is to bci 0 of a synchronized method\n-  \/\/ before the monitor has been acquired.\n-  bool      _pending_monitorenter;\n-\n-  \/\/ Specifies if the DeoptReason for the last uncommon trap was Reason_transfer_to_interpreter\n-  bool      _pending_transfer_to_interpreter;\n-\n-  \/\/ True if in a runtime call from compiled code that will deoptimize\n-  \/\/ and re-execute a failed heap allocation in the interpreter.\n-  bool      _in_retryable_allocation;\n-\n-  \/\/ An id of a speculation that JVMCI compiled code can use to further describe and\n-  \/\/ uniquely identify the speculative optimization guarded by an uncommon trap.\n-  \/\/ See JVMCINMethodData::SPECULATION_LENGTH_BITS for further details.\n-  jlong     _pending_failed_speculation;\n-\n-  \/\/ These fields are mutually exclusive in terms of live ranges.\n-  union {\n-    \/\/ Communicates the pc at which the most recent implicit exception occurred\n-    \/\/ from the signal handler to a deoptimization stub.\n-    address   _implicit_exception_pc;\n-\n-    \/\/ Communicates an alternative call target to an i2c stub from a JavaCall .\n-    address   _alternate_call_target;\n-  } _jvmci;\n-\n-  \/\/ Support for high precision, thread sensitive counters in JVMCI compiled code.\n-  jlong*    _jvmci_counters;\n-\n-  \/\/ Fast thread locals for use by JVMCI\n-  jlong      _jvmci_reserved0;\n-  jlong      _jvmci_reserved1;\n-  oop        _jvmci_reserved_oop0;\n+  JVMCIThreadState _jvmci_state;\n@@ -966,30 +930,1 @@\n-  static jlong* _jvmci_old_thread_counters;\n-  static void collect_counters(jlong* array, int length);\n-\n-  bool resize_counters(int current_size, int new_size);\n-\n-  static bool resize_all_jvmci_counters(int new_size);\n-\n-  void set_jvmci_reserved_oop0(oop value) {\n-    _jvmci_reserved_oop0 = value;\n-  }\n-\n-  oop get_jvmci_reserved_oop0() {\n-    return _jvmci_reserved_oop0;\n-  }\n-\n-  void set_jvmci_reserved0(jlong value) {\n-    _jvmci_reserved0 = value;\n-  }\n-\n-  jlong get_jvmci_reserved0() {\n-    return _jvmci_reserved0;\n-  }\n-\n-  void set_jvmci_reserved1(jlong value) {\n-    _jvmci_reserved1 = value;\n-  }\n-\n-  jlong get_jvmci_reserved1() {\n-    return _jvmci_reserved1;\n-  }\n+  JVMCIThreadState& jvmci() { return _jvmci_state; }\n@@ -1228,12 +1163,1 @@\n-  int  pending_deoptimization() const             { return _pending_deoptimization; }\n-  jlong pending_failed_speculation() const        { return _pending_failed_speculation; }\n-  bool has_pending_monitorenter() const           { return _pending_monitorenter; }\n-  void set_pending_monitorenter(bool b)           { _pending_monitorenter = b; }\n-  void set_pending_deoptimization(int reason)     { _pending_deoptimization = reason; }\n-  void set_pending_failed_speculation(jlong failed_speculation) { _pending_failed_speculation = failed_speculation; }\n-  void set_pending_transfer_to_interpreter(bool b) { _pending_transfer_to_interpreter = b; }\n-  void set_jvmci_alternate_call_target(address a) { assert(_jvmci._alternate_call_target == NULL, \"must be\"); _jvmci._alternate_call_target = a; }\n-  void set_jvmci_implicit_exception_pc(address a) { assert(_jvmci._implicit_exception_pc == NULL, \"must be\"); _jvmci._implicit_exception_pc = a; }\n-\n-  virtual bool in_retryable_allocation() const    { return _in_retryable_allocation; }\n-  void set_in_retryable_allocation(bool b)        { _in_retryable_allocation = b; }\n+  virtual bool in_retryable_allocation() const    { return _jvmci_state.in_retryable_allocation(); }\n@@ -1294,6 +1218,1 @@\n-  static ByteSize pending_deoptimization_offset() { return byte_offset_of(JavaThread, _pending_deoptimization); }\n-  static ByteSize pending_monitorenter_offset()  { return byte_offset_of(JavaThread, _pending_monitorenter); }\n-  static ByteSize pending_failed_speculation_offset() { return byte_offset_of(JavaThread, _pending_failed_speculation); }\n-  static ByteSize jvmci_alternate_call_target_offset() { return byte_offset_of(JavaThread, _jvmci._alternate_call_target); }\n-  static ByteSize jvmci_implicit_exception_pc_offset() { return byte_offset_of(JavaThread, _jvmci._implicit_exception_pc); }\n-  static ByteSize jvmci_counters_offset()        { return byte_offset_of(JavaThread, _jvmci_counters); }\n+  static ByteSize jvmci_state_offset() { return byte_offset_of(JavaThread, _jvmci_state); }\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":7,"deletions":88,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -162,0 +162,5 @@\n+\/\/ This macro generates a VMStructEntry line for a nonstatic field\n+#define GENERATE_NONSTATIC_VM_STRUCT_ENTRY_ALIAS(typeName, fieldName, fieldAliasName, type) \\\n+ { QUOTE(typeName), QUOTE(fieldName), QUOTE(type), 0, offset_of(typeName, fieldName), NULL }, \\\n+ { QUOTE(typeName), QUOTE(fieldAliasName), QUOTE(type), 0, offset_of(typeName, fieldName), NULL },\n+\n@@ -193,0 +198,4 @@\n+  assert(offset_of(typeName, fieldName) < sizeof(typeName), \"Illegal nonstatic struct entry, field offset too large\"); }\n+\n+#define CHECK_NONSTATIC_VM_STRUCT_ENTRY_ALIAS(typeName, fieldName, fieldAliasName, type) \\\n+ {typeName *dummyObj = NULL; type* dummy = &dummyObj->fieldName;                   \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}