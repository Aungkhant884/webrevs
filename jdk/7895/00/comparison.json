{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"cds\/heapShared.hpp\"\n@@ -43,0 +44,1 @@\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -932,1 +934,2 @@\n-  static void write_dump_region(const char* name, DumpRegion* region) {\n+  static void write_metaspace_region(const char* name, DumpRegion* region,\n+                                     const ArchiveBuilder::SourceObjList* src_objs) {\n@@ -936,0 +939,1 @@\n+    write_metaspace_objects(region, src_objs);\n@@ -952,1 +956,1 @@\n-  static void write_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n+  static void write_metaspace_objects(DumpRegion* region, const ArchiveBuilder::SourceObjList* src_objs) {\n@@ -1027,1 +1031,2 @@\n-  static void write_heap_region(const char* which, GrowableArray<MemRegion> *regions) {\n+  static void write_heap_regions(const char* which, GrowableArray<MemRegion> *regions) {\n+#if INCLUDE_CDS_JAVA_HEAP\n@@ -1032,1 +1037,29 @@\n-      write_data(start, end, start);\n+\n+      while (start < end) {\n+        size_t byte_size;\n+        oop archived_oop = cast_to_oop(start);\n+        oop original_oop = HeapShared::get_original_object(archived_oop);\n+        if (original_oop != NULL) {\n+          ResourceMark rm;\n+          log_info(cds, map)(PTR_FORMAT \": @@ Object %s\",\n+                             p2i(start), original_oop->klass()->external_name());\n+          byte_size = original_oop->size() * BytesPerWord;\n+        } else if (archived_oop == HeapShared::roots()) {\n+          \/\/ HeapShared::roots() is copied specially so it doesn't exist in\n+          \/\/ HeapShared::OriginalObjectTable. See HeapShared::copy_roots().\n+          log_info(cds, map)(PTR_FORMAT \": @@ Object HeapShared:roots (ObjArray)\",\n+                             p2i(start));\n+          byte_size = objArrayOopDesc::object_size(HeapShared::roots()->length()) * BytesPerWord;\n+        } else {\n+          \/\/ We have reached the end of the region\n+          break;\n+        }\n+        address oop_end = start + byte_size;\n+        write_data(start, oop_end, start);\n+        start = oop_end;\n+      }\n+      if (start < end) {\n+        log_info(cds, map)(PTR_FORMAT \": @@ Unused heap space \" SIZE_FORMAT \" bytes\",\n+                           p2i(start), size_t(end - start));\n+        write_data(start, end, start);\n+      }\n@@ -1034,0 +1067,1 @@\n+#endif\n@@ -1070,5 +1104,2 @@\n-    write_dump_region(\"rw region\", rw_region);\n-    write_objects(rw_region, &builder->_rw_src_objs);\n-\n-    write_dump_region(\"ro region\", ro_region);\n-    write_objects(ro_region, &builder->_ro_src_objs);\n+    write_metaspace_region(\"rw region\", rw_region, &builder->_rw_src_objs);\n+    write_metaspace_region(\"ro region\", ro_region, &builder->_ro_src_objs);\n@@ -1078,1 +1109,1 @@\n-    write_data(header, header_end, 0);\n+    write_data((address)bitmap, bitmap_end, 0);\n@@ -1081,1 +1112,1 @@\n-      write_heap_region(\"closed heap region\", closed_heap_regions);\n+      write_heap_regions(\"closed heap region\", closed_heap_regions);\n@@ -1084,1 +1115,1 @@\n-      write_heap_region(\"open heap region\", open_heap_regions);\n+      write_heap_regions(\"open heap region\", open_heap_regions);\n@@ -1146,0 +1177,1 @@\n+  CDS_JAVA_HEAP_ONLY(HeapShared::destroy_archived_object_cache());\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":44,"deletions":12,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-#include \"oops\/objArrayOop.hpp\"\n+#include \"oops\/objArrayOop.inline.hpp\"\n@@ -56,0 +56,1 @@\n+#include \"oops\/typeArrayOop.inline.hpp\"\n@@ -216,0 +217,1 @@\n+HeapShared::OriginalObjectTable* HeapShared::_original_object_table = NULL;\n@@ -320,0 +322,1 @@\n+    _original_object_table->put(archived_oop, obj);\n@@ -483,1 +486,0 @@\n-    destroy_archived_object_cache();\n@@ -535,0 +537,6 @@\n+  \/\/ HeapShared::roots() points into an ObjArray in the open archive region. A portion of the\n+  \/\/ objects in this array are discovered during HeapShared::archive_objects(). For example,\n+  \/\/ in HeapShared::archive_reachable_objects_from() ->  HeapShared::check_enum_obj().\n+  \/\/ However, HeapShared::archive_objects() happens inside a safepoint, so we can't\n+  \/\/ allocate a \"regular\" ObjArray and pass the result to HeapShared::archive_object().\n+  \/\/ Instead, we have to roll our own alloc\/copy routine here.\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -256,0 +256,7 @@\n+  typedef ResourceHashtable<oop, oop,\n+      15889, \/\/ prime number\n+      ResourceObj::C_HEAP,\n+      mtClassShared,\n+      HeapShared::oop_hash> OriginalObjectTable;\n+  static OriginalObjectTable* _original_object_table;\n+\n@@ -381,0 +388,2 @@\n+    _original_object_table =\n+      new (ResourceObj::C_HEAP, mtClass)OriginalObjectTable();\n@@ -385,0 +394,2 @@\n+    delete _original_object_table;\n+    _original_object_table = NULL;\n@@ -389,0 +400,8 @@\n+  static oop get_original_object(oop archived_object) {\n+    oop* r = _original_object_table->get(archived_object);\n+    if (r == NULL) {\n+      return NULL;\n+    } else {\n+      return *r;\n+    }\n+  }\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"}]}