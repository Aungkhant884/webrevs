{"files":[{"patch":"@@ -46,1 +46,1 @@\n-    private char buf[] = new char[20];\n+    private char[] buf = new char[20];\n@@ -49,1 +49,1 @@\n-    private final byte ctype[] = new byte[256];\n+    private final byte[] ctype = new byte[256];\n@@ -261,11 +261,4 @@\n-        switch (c) {\n-            case 0x1680:\n-            case 0x180E:\n-            case 0x200A:\n-            case 0x202F:\n-            case 0x205F:\n-            case 0x3000:\n-                return CT_WHITESPACE;\n-            default:\n-                return CT_ALPHA;\n-        }\n+        return switch (c) {\n+            case 0x1680, 0x180E, 0x200A, 0x202F, 0x205F, 0x3000 -> CT_WHITESPACE;\n+            default -> CT_ALPHA;\n+        };\n@@ -278,1 +271,1 @@\n-        byte ct[] = ctype;\n+        byte[] ct = ctype;\n@@ -333,23 +326,10 @@\n-                        switch (c) {\n-                        case 'a':\n-                            c = 0x7;\n-                            break;\n-                        case 'b':\n-                            c = '\\b';\n-                            break;\n-                        case 'f':\n-                            c = 0xC;\n-                            break;\n-                        case 'n':\n-                            c = '\\n';\n-                            break;\n-                        case 'r':\n-                            c = '\\r';\n-                            break;\n-                        case 't':\n-                            c = '\\t';\n-                            break;\n-                        case 'v':\n-                            c = 0xB;\n-                            break;\n-                        }\n+                        c = switch (c) {\n+                            case 'a' -> 0x7;\n+                            case 'b' -> '\\b';\n+                            case 'f' -> 0xC;\n+                            case 'n' -> '\\n';\n+                            case 'r' -> '\\r';\n+                            case 't' -> '\\t';\n+                            case 'v' -> 0xB;\n+                            default  -> c;\n+                        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/ArgTokenizer.java","additions":17,"deletions":37,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2805,8 +2805,5 @@\n-                switch (id.charAt(0)) {\n-                    case 's':\n-                        return Integer.parseInt(id.substring(1));\n-                    case 'e':\n-                        return 0x40000000 + Integer.parseInt(id.substring(1));\n-                    default:\n-                        return 0x20000000 + Integer.parseInt(id);\n-                }\n+                return switch (id.charAt(0)) {\n+                    case 's' -> Integer.parseInt(id.substring(1));\n+                    case 'e' -> 0x40000000 + Integer.parseInt(id.substring(1));\n+                    default -> 0x20000000 + Integer.parseInt(id);\n+                };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/JShellTool.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -233,11 +233,5 @@\n-                        final boolean isBuiltIn;\n-                        switch (all[i]) {\n-                            case \"*\":\n-                                isBuiltIn = true;\n-                                break;\n-                            case \"-\":\n-                                isBuiltIn = false;\n-                                break;\n-                            default:\n-                                throw new IllegalArgumentException(\"Unexpected StartupEntry kind: \" + all[i]);\n-                        }\n+                        final boolean isBuiltIn = switch (all[i]) {\n+                            case \"*\" -> true;\n+                            case \"-\" -> false;\n+                            default -> throw new IllegalArgumentException(\"Unexpected StartupEntry kind: \" + all[i]);\n+                        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/internal\/jshell\/tool\/Startup.java","additions":5,"deletions":11,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -79,1 +79,0 @@\n-import static jdk.jshell.Snippet.Status.RECOVERABLE_NOT_DEFINED;\n@@ -215,24 +214,22 @@\n-            switch (unitTree.getKind()) {\n-                case IMPORT:\n-                    return processImport(userSource, compileSourceInt);\n-                case VARIABLE:\n-                    return processVariables(userSource, units, compileSourceInt, pt);\n-                case EXPRESSION_STATEMENT:\n-                    return processExpression(userSource, unitTree, compileSourceInt, pt);\n-                case CLASS:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);\n-                case ENUM:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);\n-                case ANNOTATION_TYPE:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);\n-                case INTERFACE:\n-                    return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);\n-                case RECORD:\n-                    @SuppressWarnings(\"preview\")\n-                    List<Snippet> snippets = processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);\n-                    return snippets;\n-                case METHOD:\n-                    return processMethod(userSource, unitTree, compileSourceInt, pt);\n-                default:\n-                    return processStatement(userSource, compileSourceInt);\n-            }\n+            return switch (unitTree.getKind()) {\n+                case IMPORT\n+                    -> processImport(userSource, compileSourceInt);\n+                case VARIABLE\n+                    -> processVariables(userSource, units, compileSourceInt, pt);\n+                case EXPRESSION_STATEMENT\n+                    -> processExpression(userSource, unitTree, compileSourceInt, pt);\n+                case CLASS\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);\n+                case ENUM\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);\n+                case ANNOTATION_TYPE\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);\n+                case INTERFACE\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);\n+                case RECORD\n+                    -> processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);\n+                case METHOD\n+                    -> processMethod(userSource, unitTree, compileSourceInt, pt);\n+                default\n+                    -> processStatement(userSource, compileSourceInt);\n+            };\n@@ -373,26 +370,11 @@\n-                String sinit;\n-                switch (typeName) {\n-                    case \"byte\":\n-                    case \"short\":\n-                    case \"int\":\n-                        sinit = \"0\";\n-                        break;\n-                    case \"long\":\n-                        sinit = \"0L\";\n-                        break;\n-                    case \"float\":\n-                        sinit = \"0.0f\";\n-                        break;\n-                    case \"double\":\n-                        sinit = \"0.0d\";\n-                        break;\n-                    case \"boolean\":\n-                        sinit = \"false\";\n-                        break;\n-                    case \"char\":\n-                        sinit = \"'\\\\u0000'\";\n-                        break;\n-                    default:\n-                        sinit = \"null\";\n-                        break;\n-                }\n+                String sinit = switch (typeName) {\n+                    case \"byte\",\n+                         \"short\",\n+                         \"int\"     -> \"0\";\n+                    case \"long\"    -> \"0L\";\n+                    case \"float\"   -> \"0.0f\";\n+                    case \"double\"  -> \"0.0d\";\n+                    case \"boolean\" -> \"false\";\n+                    case \"char\"    -> \"'\\\\u0000'\";\n+                    default        -> \"null\";\n+                };\n@@ -865,17 +847,8 @@\n-        OuterWrap outer;\n-        switch (probableKind) {\n-            case IMPORT:\n-                outer = state.outerMap.wrapImport(Wrap.simpleWrap(compileSource), snip);\n-                break;\n-            case EXPRESSION:\n-                outer = state.outerMap.wrapInTrialClass(Wrap.methodReturnWrap(compileSource));\n-                break;\n-            case VAR:\n-            case TYPE_DECL:\n-            case METHOD:\n-                outer = state.outerMap.wrapInTrialClass(Wrap.classMemberWrap(compileSource));\n-                break;\n-            default:\n-                outer = state.outerMap.wrapInTrialClass(Wrap.methodWrap(compileSource));\n-                break;\n-        }\n+        OuterWrap outer = switch (probableKind) {\n+            case IMPORT     -> state.outerMap.wrapImport(Wrap.simpleWrap(compileSource), snip);\n+            case EXPRESSION -> state.outerMap.wrapInTrialClass(Wrap.methodReturnWrap(compileSource));\n+            case VAR,\n+                 TYPE_DECL,\n+                 METHOD     -> state.outerMap.wrapInTrialClass(Wrap.classMemberWrap(compileSource));\n+            default         -> state.outerMap.wrapInTrialClass(Wrap.methodWrap(compileSource));\n+        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/Eval.java","additions":41,"deletions":68,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -278,13 +278,5 @@\n-        OuterWrap codeWrap;\n-        switch (guessKind(code)) {\n-            case IMPORT:\n-                codeWrap = proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n-                break;\n-            case CLASS:\n-            case METHOD:\n-                codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));\n-                break;\n-            default:\n-                codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));\n-                break;\n-        }\n+        OuterWrap codeWrap = switch (guessKind(code)) {\n+            case IMPORT -> proc.outerMap.wrapImport(Wrap.simpleWrap(code + \"any.any\"), null);\n+            case CLASS, METHOD -> proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));\n+            default -> proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));\n+        };\n@@ -505,17 +497,8 @@\n-                        switch (parent.getKind()) {\n-                            case VARIABLE:\n-                                accept = ((VariableTree)parent).getType() == tp.getLeaf() ?\n-                                        IS_VOID.negate() :\n-                                        TRUE;\n-                                break;\n-                            case PARAMETERIZED_TYPE: \/\/ TODO: JEP 218: Generics over Primitive Types\n-                            case TYPE_PARAMETER:\n-                            case CLASS:\n-                            case INTERFACE:\n-                            case ENUM:\n-                                accept = FALSE;\n-                                break;\n-                            default:\n-                                accept = TRUE;\n-                                break;\n-                        }\n+                        accept = switch (parent.getKind()) {\n+                            case VARIABLE -> ((VariableTree) parent).getType() == tp.getLeaf() ?\n+                                             IS_VOID.negate() :\n+                                             TRUE;\n+                            case PARAMETERIZED_TYPE -> FALSE; \/\/ TODO: JEP 218: Generics over Primitive Types\n+                            case TYPE_PARAMETER, CLASS, INTERFACE, ENUM -> FALSE;\n+                            default -> TRUE;\n+                        };\n@@ -1106,9 +1089,6 @@\n-        switch (el.getKind()) {\n-            case METHOD:\n-                return ((ExecutableElement) el).getReturnType();\n-            case CONSTRUCTOR:\n-            case INSTANCE_INIT: case STATIC_INIT: \/\/TODO: should be filtered out\n-                return el.getEnclosingElement().asType();\n-            default:\n-                return el.asType();\n-        }\n+        return switch (el.getKind()) {\n+            case METHOD -> ((ExecutableElement) el).getReturnType();\n+            \/\/ TODO: INSTANCE_INIT and STATIC_INIT should be filtered out\n+            case CONSTRUCTOR, INSTANCE_INIT, STATIC_INIT -> el.getEnclosingElement().asType();\n+            default -> el.asType();\n+        };\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/SourceCodeAnalysisImpl.java","additions":19,"deletions":39,"binary":false,"changes":58,"status":"modified"}]}