{"files":[{"patch":"@@ -374,2 +374,0 @@\n-            if (memberMethod.isSynthetic())\n-                continue;\n@@ -472,8 +470,12 @@\n-        return AccessController.doPrivileged(\n-            new PrivilegedAction<Method[]>() {\n-                public Method[] run() {\n-                    final Method[] methods = type.getDeclaredMethods();\n-                    validateAnnotationMethods(methods);\n-                    AccessibleObject.setAccessible(methods, true);\n-                    return methods;\n-                }});\n+        return AccessController.doPrivileged((PrivilegedAction<Method[]>) () -> {\n+            final Method[] methods = Arrays.stream(type.getDeclaredMethods())\n+                    \/\/ Skip over synthetic methods. It may be a static initializer\n+                    \/\/ or similar construct. A static initializer may be used for\n+                    \/\/ purposes such as initializing a lambda stored in an\n+                    \/\/ interface field.\n+                    .filter(method -> !method.isSynthetic())\n+                    .toArray(Method[]::new);\n+            validateAnnotationMethods(methods);\n+            AccessibleObject.setAccessible(methods, true);\n+            return methods;\n+        });\n@@ -501,11 +503,0 @@\n-            \/\/ Skip over methods that may be a static initializer or\n-            \/\/ similar construct. A static initializer may be used for\n-            \/\/ purposes such as initializing a lambda stored in an\n-            \/\/ interface field.\n-            \/\/ Methods that have no arguments (lambdas without parameters)\n-            \/\/ as well as methods with arguments (lambdas with parameters)\n-            \/\/ should be skipped.\n-            if (method.isSynthetic() &&\n-                (modifiers & (Modifier.STATIC | Modifier.PRIVATE)) != 0) {\n-                continue;\n-            }\n@@ -581,5 +572,3 @@\n-        if (valid)\n-            return;\n-        else\n-            throw new AnnotationFormatError(\"Malformed method on an annotation type: \" +\n-                                            currentMethod.toString());\n+        if (!valid)\n+            throw new AnnotationFormatError(\"Malformed method on an annotation type: \"\n+                    + currentMethod);\n","filename":"src\/java.base\/share\/classes\/sun\/reflect\/annotation\/AnnotationInvocationHandler.java","additions":15,"deletions":26,"binary":false,"changes":41,"status":"modified"}]}