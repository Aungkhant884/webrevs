{"files":[{"patch":"@@ -2130,1 +2130,1 @@\n-    objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),\n+    objArrayOop r = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n@@ -2133,0 +2133,1 @@\n+    int count = 0;\n@@ -2135,5 +2136,20 @@\n-      \/\/ This returns <package-name>\/<class-name>.\n-      Symbol* klass_name = ik->constants()->klass_name_at(cp_index);\n-      assert(klass_name != NULL, \"Unexpected null klass_name\");\n-      Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);\n-      result->obj_at_put(i, perm_subtype_h());\n+      Klass* k = ik->constants()->klass_at(cp_index, THREAD);\n+      if (HAS_PENDING_EXCEPTION) {\n+        if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+          return NULL; \/\/ propagate VMEs\n+        }\n+        CLEAR_PENDING_EXCEPTION;\n+        continue;\n+      }\n+      if (k->is_instance_klass()) {\n+        result->obj_at_put(count++, k->java_mirror());\n+      }\n+    }\n+    if (count < length) {\n+      objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+                                                count, CHECK_NULL);\n+      objArrayHandle result2(THREAD, r2);\n+      for (int i = 0; i < count; i++) {\n+        result2->obj_at_put(i, result->obj_at(i));\n+      }\n+      return (jobjectArray)JNIHandles::make_local(THREAD, result2());\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -203,2 +203,0 @@\n-    private static final ClassDesc[] EMPTY_CLASS_DESC_ARRAY = new ClassDesc[0];\n-\n@@ -4369,1 +4367,1 @@\n-     * Returns an array containing {@code ClassDesc} objects representing all the\n+     * Returns an array containing {@code Class} objects representing all the\n@@ -4376,1 +4374,1 @@\n-     * @return an array of class descriptors of all the permitted subclasses of this class or interface\n+     * @return an array of class objects of all the permitted subclasses of this class or interface\n@@ -4383,13 +4381,4 @@\n-    public ClassDesc[] permittedSubclasses() {\n-        String[] subclassNames;\n-        if (isArray() || isPrimitive() || (subclassNames = getPermittedSubclasses0()).length == 0) {\n-            return EMPTY_CLASS_DESC_ARRAY;\n-        }\n-        ClassDesc[] constants = new ClassDesc[subclassNames.length];\n-        int i = 0;\n-        for (String subclassName : subclassNames) {\n-            try {\n-                constants[i++] = ClassDesc.of(subclassName.replace('\/', '.'));\n-            } catch (IllegalArgumentException iae) {\n-                throw new InternalError(\"Invalid type in permitted subclasses information: \" + subclassName, iae);\n-            }\n+    public Class<?>[] getPermittedSubclasses() {\n+        Class<?>[] subClasses;\n+        if (isArray() || isPrimitive() || (subClasses = getPermittedSubclasses0()).length == 0) {\n+            return EMPTY_CLASS_ARRAY;\n@@ -4397,1 +4386,1 @@\n-        return constants;\n+        return subClasses;\n@@ -4401,1 +4390,1 @@\n-     * * {@preview Associated with sealed classes, a preview feature of the Java language.\n+     * {@preview Associated with sealed classes, a preview feature of the Java language.\n@@ -4408,2 +4397,3 @@\n-     * Returns {@code true} if and only if this {@code Class} object represents a sealed class or interface.\n-     * If this {@code Class} object represents a primitive type, {@code void}, or an array type, this method returns\n+     * Returns {@code true} if and only if this {@code Class} object represents\n+     * a sealed class or interface. If this {@code Class} object represents a\n+     * primitive type, {@code void}, or an array type, this method returns\n@@ -4412,0 +4402,4 @@\n+     * @apiNote\n+     * This method reports on a distinct concept of sealing from\n+     * {@link Package#isSealed() Package::isSealed}.\n+     *\n@@ -4424,1 +4418,1 @@\n-        return permittedSubclasses().length != 0;\n+        return getPermittedSubclasses().length != 0;\n@@ -4427,1 +4421,1 @@\n-    private native String[] getPermittedSubclasses0();\n+    private native Class<?>[] getPermittedSubclasses0();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Class.java","additions":17,"deletions":23,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -224,0 +224,4 @@\n+     * @apiNote\n+     * This method reports on a distinct concept of sealing from\n+     * {@link Class#isSealed() Class::isSealed}.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Package.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-    {\"getPermittedSubclasses0\", \"()[\" STR,  (void *)&JVM_GetPermittedSubclasses},\n+    {\"getPermittedSubclasses0\", \"()[\" CLS,  (void *)&JVM_GetPermittedSubclasses},\n","filename":"src\/java.base\/share\/native\/libjava\/Class.c","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1632,1 +1632,1 @@\n-     * Is t is castable to s?<br>\n+     * Is t castable to s?<br>\n@@ -1637,0 +1637,1 @@\n+        \/\/ if same type\n@@ -1639,0 +1640,1 @@\n+        \/\/ if one of the types is primitive\n@@ -1645,0 +1647,1 @@\n+        boolean result;\n@@ -1649,1 +1652,1 @@\n-                return isCastable.visit(t,s);\n+                result = isCastable.visit(t,s);\n@@ -1654,1 +1657,1 @@\n-            return isCastable.visit(t,s);\n+            result = isCastable.visit(t,s);\n@@ -1656,0 +1659,6 @@\n+        if ((t.tsym.isSealed() || s.tsym.isSealed())) {\n+            return (t.isCompound() || s.isCompound()) ?\n+                    false :\n+                    !areDisjoint((ClassSymbol)t.tsym, (ClassSymbol)s.tsym);\n+        }\n+        return result;\n@@ -1658,0 +1667,28 @@\n+        private boolean areDisjoint(ClassSymbol ts, ClassSymbol ss) {\n+            if (isSubtype(ts.type, ss.type)) {\n+                return false;\n+            }\n+            \/\/ if both are classes or both are interfaces, shortcut\n+            if (ts.isInterface() == ss.isInterface()) {\n+                return !(isSubtype(ss.type, ts.type));\n+            }\n+            if (ts.isInterface() && !ss.isInterface()) {\n+                \/* so ts is interface but ss is a class\n+                 * an interface is disjoint from a class if the class is disjoint form the interface\n+                 *\/\n+                return areDisjoint(ss, ts);\n+            }\n+            \/\/ a final class that is not subtype of ss is disjoint\n+            if (!ts.isInterface() && ts.isFinal()) {\n+                return true;\n+            }\n+            \/\/ if at least one is sealed\n+            if (ts.isSealed() || ss.isSealed()) {\n+                \/\/ permitted subtypes have to be disjoint with the other symbol\n+                ClassSymbol sealedOne = ts.isSealed() ? ts : ss;\n+                ClassSymbol other = sealedOne == ts ? ss : ts;\n+                return sealedOne.permitted.stream().allMatch(sym -> areDisjoint((ClassSymbol)sym, other));\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Types.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1309,1 +1309,4 @@\n-                           FINAL | NON_SEALED)) {\n+                           FINAL | NON_SEALED)\n+                 && checkDisjoint(pos, flags,\n+                                SEALED,\n+                                ANNOTATION)) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4267,1 +4267,5 @@\n-                case MONKEYS_AT, ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case ABSTRACT, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n@@ -4271,1 +4275,5 @@\n-                case MONKEYS_AT, PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n+                case MONKEYS_AT -> {\n+                    Token afterNext = S.token(2);\n+                    yield afterNext.kind != INTERFACE || currentIsNonSealed;\n+                }\n+                case PUBLIC, PROTECTED, PRIVATE, ABSTRACT, STATIC, FINAL, STRICTFP, CLASS, INTERFACE, ENUM -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -24,3 +24,2 @@\n-\/\/ This class has entries in its PermittedSubclasses attribute that do not exist.\n-\/\/ Test that this does not prevent JVM_GetPermittedSubclasses() from returning\n-\/\/ their names.\n+\/\/ This class has an entry in its PermittedSubclasses attribute that does not exist.\n+\/\/ Test that JVM_GetPermittedSubclasses() only returns the existing class.\n@@ -28,1 +27,1 @@\n-\/\/ sealed class NoLoadSubclasses permits iDontExist, I\/Dont\/Exist\/Either { }\n+\/\/ sealed class NoLoadSubclasses permits OldClassFile, I\/Dont\/Exist\/Either { }\n@@ -50,1 +49,1 @@\n-    Utf8 \"iDontExist\"; \/\/ #15     at 0xA0\n+    Utf8 \"OldClassFile\"; \/\/ #15     at 0xA0\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/GetPermittedSubclasses.jcod","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        Object[] permitted = c.permittedSubclasses();\n+        Object[] permitted = c.getPermittedSubclasses();\n@@ -68,1 +68,1 @@\n-                permittedNames.add(((ClassDesc)permitted[i]).descriptorString());\n+                permittedNames.add(((Class)permitted[i]).getName());\n@@ -105,4 +105,5 @@\n-        testSealedInfo(SealedI1.class, new String[] {\"LGetPermittedSubclassesTest$NotSealed;\",\n-                                                     \"LGetPermittedSubclassesTest$Sub1;\",\n-                                                     \"LGetPermittedSubclassesTest$Extender;\"});\n-        testSealedInfo(Sealed1.class, new String[] {\"LGetPermittedSubclassesTest$Sub1;\"});\n+        testSealedInfo(SealedI1.class, new String[] {\"GetPermittedSubclassesTest$NotSealed\",\n+                                                     \"GetPermittedSubclassesTest$Sub1\",\n+                                                     \"GetPermittedSubclassesTest$Extender\"});\n+\n+        testSealedInfo(Sealed1.class, new String[] {\"GetPermittedSubclassesTest$Sub1\"});\n@@ -118,2 +119,2 @@\n-        \/\/ Test returning names of non-existing classes.\n-        testSealedInfo(NoLoadSubclasses.class, new String[]{\"LiDontExist;\", \"LI\/Dont\/Exist\/Either;\"});\n+        \/\/ Test returning only names of existing classes.\n+        testSealedInfo(NoLoadSubclasses.class, new String[]{\"OldClassFile\" });\n","filename":"test\/hotspot\/jtreg\/runtime\/sealedClasses\/GetPermittedSubclassesTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-        assertTrue(cls.permittedSubclasses() != null);\n-        assertTrue(cls.permittedSubclasses().length > 0);\n+        assertTrue(cls.getPermittedSubclasses() != null);\n+        assertTrue(cls.getPermittedSubclasses().length > 0);\n@@ -113,2 +113,2 @@\n-        assertTrue(cls.permittedSubclasses() != null);\n-        assertTrue(cls.permittedSubclasses().length == 0);\n+        assertTrue(cls.getPermittedSubclasses() != null);\n+        assertTrue(cls.getPermittedSubclasses().length == 0);\n@@ -131,2 +131,2 @@\n-        assertTrue(cls.permittedSubclasses() != null);\n-        assertTrue(cls.permittedSubclasses().length == 0);\n+        assertTrue(cls.getPermittedSubclasses() != null);\n+        assertTrue(cls.getPermittedSubclasses().length == 0);\n@@ -218,1 +218,1 @@\n-        assertTrue(sealedClass.permittedSubclasses().length == numberOfSubclasses);\n+        assertTrue(sealedClass.getPermittedSubclasses().length == numberOfSubclasses);\n@@ -220,2 +220,2 @@\n-        for (ClassDesc cd : sealedClass.permittedSubclasses()) {\n-            assertTrue(cd.displayName().equals(subclassDescriptors[i]), \"expected: \" + subclassDescriptors[i] + \" found: \" + cd.displayName());\n+        for (Class<?> cd : sealedClass.getPermittedSubclasses()) {\n+            assertTrue(cd.getName().equals(subclassDescriptors[i]), \"expected: \" + subclassDescriptors[i] + \" found: \" + cd.getName());\n","filename":"test\/jdk\/java\/lang\/reflect\/sealed_classes\/SealedClassesReflectionTest.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -80,1 +80,4 @@\n-        \/\/ sealing a super class which was not sealed, should fail with IncompatibleClassChangeError\n+        \/* If a class that was not declared sealed is changed to be declared sealed, then an\n+         * IncompatibleClassChangeError is thrown if a binary of a pre-existing subclass of\n+         * this class is loaded that is not contained in its permits clause\n+         *\/\n@@ -83,0 +86,1 @@\n+                true,\n@@ -106,2 +110,1 @@\n-                \"\"\",\n-                true\n+                \"\"\"\n@@ -113,1 +116,1 @@\n-        \/\/ sealing a super interface which was not sealed, should fail with IncompatibleClassChangeError\n+        \/\/ test similar to testCompatibilityAfterMakingSuperclassSealed but with interfaces\n@@ -116,0 +119,1 @@\n+                true,\n@@ -139,2 +143,1 @@\n-                \"\"\",\n-                true\n+                \"\"\"\n@@ -152,0 +155,1 @@\n+            boolean shouldFail,\n@@ -154,2 +158,1 @@\n-            String subClassCode,\n-            boolean shouldFail) throws Exception {\n+            String... subClassesCode) throws Exception {\n@@ -161,1 +164,0 @@\n-        \/\/ super class initially not sealed\n@@ -163,1 +165,1 @@\n-        tb.writeJavaFiles(sub, subClassCode);\n+        tb.writeJavaFiles(sub, subClassesCode);\n@@ -223,1 +225,3 @@\n-        \/\/ should execute without error\n+        \/* Changing a class that is declared sealed to no longer be declared\n+         * sealed does not break compatibility with pre-existing binaries.\n+         *\/\n@@ -226,0 +230,1 @@\n+                false,\n@@ -247,2 +252,1 @@\n-                \"\"\",\n-                false\n+                \"\"\"\n@@ -254,1 +258,1 @@\n-        \/\/ should execute without error\n+        \/\/ same as testRemoveSealedModifierToClass but with an interface\n@@ -257,0 +261,1 @@\n+                false,\n@@ -278,2 +283,1 @@\n-                \"\"\",\n-                false\n+                \"\"\"\n@@ -285,1 +289,3 @@\n-        \/\/ should execute without error\n+        \/* Changing a class that is not declared non-sealed to be declared\n+         * non-sealed does not break compatibility with pre-existing binaries\n+         *\/\n@@ -310,1 +316,1 @@\n-        \/\/ should execute without error\n+        \/\/ same as `testAddNonSealedModifierToClass` but with interfaces\n@@ -335,1 +341,3 @@\n-        \/\/ should execute without error\n+        \/* Changing a class that is declared non-sealed to no longer be declared\n+         * non-sealed does not break compatibility with pre-existing binaries\n+         *\/\n@@ -360,1 +368,1 @@\n-        \/\/ should execute without error\n+        \/\/ same as `testRemoveNonSealedModifier` but with interfaces\n@@ -455,1 +463,4 @@\n-        \/\/ the VM will throw IncompatibleClassChangeError\n+        \/* If a class is removed from the set of permitted direct subclasses of\n+         * a sealed class then an IncompatibleClassChangeError is thrown if the\n+         * pre-existing binary of the removed class is loaded\n+         *\/\n@@ -458,0 +469,1 @@\n+                true,\n@@ -483,0 +495,22 @@\n+                \"\"\"\n+        );\n+    }\n+\n+    @Test\n+    public void testAfterChangingPermitsClause2(Path base) throws Exception {\n+        \/* If a class is removed from the set of permitted direct subclasses of\n+         * a sealed class then an IncompatibleClassChangeError is thrown if the\n+         * pre-existing binary of the removed class is loaded\n+         *\/\n+        testCompatibilityAfterModifyingSupertype(\n+                base,\n+                true,\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1, pkg.Sub2 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        pkg.Sub2 sub2 = new pkg.Sub2();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n@@ -484,1 +518,18 @@\n-                true\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        pkg.Sub2 sub2 = new pkg.Sub2();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                final class Sub1 extends Super {}\n+                \"\"\",\n+                \"\"\"\n+                package pkg;\n+                final class Sub2 extends Super {}\n+                \"\"\"\n@@ -487,0 +538,92 @@\n+\n+    @Test\n+    public void testAfterChangingPermitsClause3(Path base) throws Exception {\n+        \/* Changing the set of permitted direct subclasses of a sealed class will\n+         * not break compatibility with pre-existing binaries, provided that the\n+         * total set of permitted direct subclasses of the sealed class loses no\n+         * members\n+         *\/\n+        String superClassCode1 =\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n+                \"\"\";\n+        String subClass1Code =\n+                \"\"\"\n+                package pkg;\n+                final class Sub1 extends Super {}\n+                \"\"\";\n+\n+        String superClassCode2 =\n+                \"\"\"\n+                package pkg;\n+                public sealed class Super permits pkg.Sub1, pkg.Sub2 {\n+                    public static void main(String... args) {\n+                        pkg.Sub1 sub1 = new pkg.Sub1();\n+                        pkg.Sub2 sub2 = new pkg.Sub2();\n+                        System.out.println(\"done\");\n+                    }\n+                }\n+                \"\"\";\n+        String subClass2Code =\n+                \"\"\"\n+                package pkg;\n+                final class Sub2 extends Super {}\n+                \"\"\";\n+\n+        Path src = base.resolve(\"src\");\n+        Path pkg = src.resolve(\"pkg\");\n+        Path superClass = pkg.resolve(\"Super\");\n+        Path sub1 = pkg.resolve(\"Sub1\");\n+\n+        tb.writeJavaFiles(superClass, superClassCode1);\n+        tb.writeJavaFiles(sub1, subClass1Code);\n+\n+        Path out = base.resolve(\"out\");\n+        Files.createDirectories(out);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                        \"-source\", Integer.toString(Runtime.version().feature()))\n+                .outdir(out)\n+                .files(findJavaFiles(pkg))\n+                .run();\n+\n+        \/\/ let's execute to check that it's working\n+        String output = new JavaTask(tb)\n+                .vmOptions(\"--enable-preview\")\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Super\")\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.STDOUT);\n+\n+        \/\/ let's first check that it runs wo issues\n+        if (!output.contains(\"done\")) {\n+            throw new AssertionError(\"execution of Super didn't finish\");\n+        }\n+\n+        \/\/ now lets change the super class\n+        tb.writeJavaFiles(superClass, superClassCode2);\n+        Path sub2 = pkg.resolve(\"Sub2\");\n+        tb.writeJavaFiles(sub2, subClass2Code);\n+\n+        new JavacTask(tb)\n+                .options(\"--enable-preview\",\n+                        \"-source\", Integer.toString(Runtime.version().feature()))\n+                .classpath(out)\n+                .outdir(out)\n+                .files(findJavaFiles(superClass)[0], findJavaFiles(sub2)[0])\n+                .run();\n+\n+        new JavaTask(tb)\n+                .vmOptions(\"--enable-preview\")\n+                .classpath(out.toString())\n+                .classArgs(\"pkg.Super\")\n+                .run(Task.Expect.SUCCESS);\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/BinaryCompatibilityTests.java","additions":165,"deletions":22,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -471,0 +471,20 @@\n+                \"\"\",\n+                \"\"\"\n+                sealed class C {\n+                    void m() {\n+                        class L {\n+                            final class D extends C { }\n+                        }\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C {\n+                    void m() {\n+                        class L {\n+                            void foo() {\n+                                final class D extends C { }\n+                            }\n+                        }\n+                    }\n+                }\n@@ -616,1 +636,1 @@\n-            Assert.check(c.permittedSubclasses().length == 0);\n+            Assert.check(c.getPermittedSubclasses().length == 0);\n@@ -959,0 +979,265 @@\n+\n+    public void testDoNotAllowSealedAnnotation() {\n+        for (String s : List.of(\n+            \"\"\"\n+            sealed @interface A {}\n+            non-sealed interface I extends A {}\n+            \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.expected4\", s);\n+        }\n+    }\n+\n+    public void testNarrowConversion() {\n+        for (String s : List.of(\n+                \"\"\"\n+                interface I {}\n+                sealed class C permits D {}\n+                final class D extends C {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits C {}\n+                final class C implements I {}\n+                interface J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                sealed interface J permits C {}\n+                final class C implements J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits A {}\n+                sealed interface J permits B {}\n+                final class A implements I {}\n+                final class B implements J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class C {}\n+                sealed interface I permits A {}\n+                final class A implements I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                final class C {}\n+                interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                final class C {}\n+                sealed interface I permits D {}\n+                final class D implements I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                final class D extends C {}\n+                non-sealed interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                final class D {}\n+                sealed interface I permits E {}\n+                final class E {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                sealed class D permits NS {}\n+                non-sealed class NS extends D {}\n+                sealed interface I permits E {}\n+                final class E {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                final class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                sealed class C permits D {}\n+                final class D {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits D {}\n+                final class D {}\n+                class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits D {}\n+                final class D implements I {}\n+                final class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed interface I permits D {}\n+                final class D implements I {}\n+                sealed class C permits E {}\n+                final class E extends C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            assertFail(\"compiler.err.prob.found.req\", s);\n+        }\n+\n+        for (String s : List.of(\n+                \"\"\"\n+                interface I {}\n+                sealed class C permits D, E {}\n+                non-sealed class D extends C {}\n+                final class E extends C {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                interface J {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        J j = (J) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                class C {}\n+                interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                interface I {}\n+                class C {}\n+\n+                class Test {\n+                    void test () {\n+                        I i = null;\n+                        C c = (C) i;\n+                    }\n+                }\n+                \"\"\",\n+                \"\"\"\n+                sealed class C permits D {}\n+                sealed class D extends C permits NS {}\n+                non-sealed class NS extends D {}\n+                interface I {}\n+\n+                class Test {\n+                    void test () {\n+                        C c = null;\n+                        I i = (I) c;\n+                    }\n+                }\n+                \"\"\"\n+        )) {\n+            assertOK(s);\n+        }\n+    }\n","filename":"test\/langtools\/tools\/javac\/sealed\/SealedCompilationTests.java","additions":286,"deletions":1,"binary":false,"changes":287,"status":"modified"}]}