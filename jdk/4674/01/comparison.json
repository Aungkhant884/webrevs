{"files":[{"patch":"@@ -159,1 +159,3 @@\n-        sumWithCompensation(other.sumCompensation);\n+\n+        \/\/Negating this value because low-order bits are in negated form\n+        sumWithCompensation(-other.sumCompensation);\n@@ -244,1 +246,1 @@\n-        double tmp =  sum + sumCompensation;\n+        double tmp =  sum - sumCompensation;\n","filename":"src\/java.base\/share\/classes\/java\/util\/DoubleSummaryStatistics.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -737,1 +737,2 @@\n-                            return sumWithCompensation(a, b[1]); },\n+                            \/\/Negating this value because low-order bits are in negated form\n+                            return sumWithCompensation(a, -b[1]); },\n@@ -768,2 +769,2 @@\n-        \/\/ Better error bounds to add both terms as the final sum\n-        double tmp = summands[0] + summands[1];\n+        \/\/ Final sum with better error bounds subtract second summand as it is negated\n+        double tmp = summands[0] - summands[1];\n@@ -843,1 +844,1 @@\n-         * the low-order bits of the sum computed via compensated\n+         * the negated low-order bits of the sum computed via compensated\n@@ -849,1 +850,7 @@\n-                (a, b) -> { sumWithCompensation(a, b[0]); sumWithCompensation(a, b[1]); a[2] += b[2]; a[3] += b[3]; return a; },\n+                (a, b) -> {\n+                    sumWithCompensation(a, b[0]);\n+                    \/\/Negating this value because low-order bits are in negated form\n+                    sumWithCompensation(a, -b[1]);\n+                    a[2] += b[2]; a[3] += b[3];\n+                    return a;\n+                    },\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/Collectors.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -445,1 +445,1 @@\n-         * the low-order bits of the sum computed via compensated\n+         * the negated low-order bits of the sum computed via compensated\n@@ -457,1 +457,2 @@\n-                                   Collectors.sumWithCompensation(ll, rr[1]);\n+                                   \/\/Negating this value because low-order bits are in negated form\n+                                   Collectors.sumWithCompensation(ll, -rr[1]);\n@@ -500,1 +501,2 @@\n-                                   Collectors.sumWithCompensation(ll, rr[1]);\n+                                   \/\/Negating this value because low-order bits are in negated form\n+                                   Collectors.sumWithCompensation(ll, -rr[1]);\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/DoublePipeline.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8214761\n+ * @run testng CompensatedSums\n+ * @summary\n+ *\/\n+\n+import java.util.Random;\n+import java.util.function.BiConsumer;\n+import java.util.function.ObjDoubleConsumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.DoubleStream;\n+\n+import static org.testng.Assert.assertTrue;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+public class CompensatedSums {\n+\n+    @Test\n+    public void testCompensatedSums() {\n+        double naive = 0;\n+        double jdkSequentialStreamError = 0;\n+        double goodSequentialStreamError = 0;\n+        double jdkParallelStreamError = 0;\n+        double goodParallelStreamError = 0;\n+        double badParallelStreamError = 0;\n+\n+        for (int loop = 0; loop < 100; loop++) {\n+            \/\/ sequence of random numbers of varying magnitudes, both positive and negative\n+            double[] rand = new Random().doubles(1_000_000)\n+                    .map(Math::log)\n+                    .map(x -> (Double.doubleToLongBits(x) % 2 == 0) ? x : -x)\n+                    .toArray();\n+\n+            \/\/ base case: standard Kahan summation\n+            double[] sum = new double[2];\n+            for (int i=0; i < rand.length; i++) {\n+                sumWithCompensation(sum, rand[i]);\n+            }\n+\n+            \/\/ All error is the squared difference of the standard Kahan Sum vs JDK Stream sum implementation\n+            \/\/ Older less accurate implementations included here as the baseline.\n+\n+            \/\/ squared error of naive sum by reduction - should be large\n+            naive += Math.pow(DoubleStream.of(rand).reduce((x, y) -> x+y).getAsDouble() - sum[0], 2);\n+\n+            \/\/ squared error of sequential sum - should be 0\n+            jdkSequentialStreamError += Math.pow(DoubleStream.of(rand).sum() - sum[0], 2);\n+\n+            goodSequentialStreamError += Math.pow(computeFinalSum(DoubleStream.of(rand).collect(doubleSupplier,objDoubleConsumer,goodCollectorConsumer)) - sum[0], 2);\n+\n+            \/\/ squared error of parallel sum from the JDK\n+            jdkParallelStreamError += Math.pow(DoubleStream.of(rand).parallel().sum() - sum[0], 2);\n+\n+            \/\/ squared error of parallel sum\n+            goodParallelStreamError += Math.pow(computeFinalSum(DoubleStream.of(rand).parallel().collect(doubleSupplier,objDoubleConsumer,goodCollectorConsumer)) - sum[0], 2);\n+\n+            \/\/ the bad parallel stream\n+            badParallelStreamError += Math.pow(computeFinalSum(DoubleStream.of(rand).parallel().collect(doubleSupplier,objDoubleConsumer,badCollectorConsumer)) - sum[0], 2);\n+\n+\n+        }\n+\n+        Assert.assertEquals(goodSequentialStreamError, 0.0);\n+        Assert.assertEquals(goodSequentialStreamError, jdkSequentialStreamError);\n+\n+        Assert.assertTrue(jdkParallelStreamError <= goodParallelStreamError);\n+        Assert.assertTrue(badParallelStreamError > goodParallelStreamError);\n+\n+        Assert.assertTrue(naive > jdkSequentialStreamError);\n+        Assert.assertTrue(naive > jdkParallelStreamError);\n+\n+    }\n+\n+    \/\/ from OpenJDK8 Collectors, unmodified\n+    static double[] sumWithCompensation(double[] intermediateSum, double value) {\n+        double tmp = value - intermediateSum[1];\n+        double sum = intermediateSum[0];\n+        double velvel = sum + tmp; \/\/ Little wolf of rounding error\n+        intermediateSum[1] = (velvel - sum) - tmp;\n+        intermediateSum[0] = velvel;\n+        return intermediateSum;\n+    }\n+\n+    \/\/ from OpenJDK8 Collectors, unmodified\n+    static double computeFinalSum(double[] summands) {\n+        double tmp = summands[0] + summands[1];\n+        double simpleSum = summands[summands.length - 1];\n+        if (Double.isNaN(tmp) && Double.isInfinite(simpleSum))\n+            return simpleSum;\n+        else\n+            return tmp;\n+    }\n+\n+    \/\/Suppliers and consumers for Double Stream summation collection.\n+    static Supplier<double[]> doubleSupplier = () -> new double[3];\n+    static ObjDoubleConsumer<double[]> objDoubleConsumer = (double[] ll, double d) -> {\n+                                                             sumWithCompensation(ll, d);\n+                                                             ll[2] += d;\n+                                                           };\n+    static BiConsumer<double[], double[]> badCollectorConsumer =\n+            (ll, rr) -> {\n+                sumWithCompensation(ll, rr[0]);\n+                sumWithCompensation(ll, rr[1]);\n+                ll[2] += rr[2];\n+            };\n+\n+    static BiConsumer<double[], double[]> goodCollectorConsumer =\n+            (ll, rr) -> {\n+                sumWithCompensation(ll, rr[0]);\n+                sumWithCompensation(ll, -rr[1]);\n+                ll[2] += rr[2];\n+            };\n+\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/DoubleStreamSums\/CompensatedSums.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8214761\n+ * @summary When combining two DoubleSummaryStatistics, the compensation\n+ *          has to be subtracted.\n+ *\/\n+\n+import java.util.DoubleSummaryStatistics;\n+\n+public class NegativeCompensation {\n+    static final double VAL = 1.000000001;\n+    static final int LOG_ITER = 21;\n+\n+    public static void main(String[] args) {\n+        DoubleSummaryStatistics stat0 = new DoubleSummaryStatistics();\n+        DoubleSummaryStatistics stat1 = new DoubleSummaryStatistics();\n+        DoubleSummaryStatistics stat2 = new DoubleSummaryStatistics();\n+\n+        stat1.accept(VAL);\n+        stat1.accept(VAL);\n+        stat2.accept(VAL);\n+        stat2.accept(VAL);\n+        stat2.accept(VAL);\n+\n+        for (int i = 0; i < LOG_ITER; ++i) {\n+            stat1.combine(stat2);\n+            stat2.combine(stat1);\n+        }\n+\n+        System.out.println(\"count: \" + stat2.getCount());\n+        for (long i = 0, iend = stat2.getCount(); i < iend; ++i) {\n+            stat0.accept(VAL);\n+        }\n+\n+        double res = 0;\n+        for(long i = 0, iend = stat2.getCount(); i < iend; ++i) {\n+            res += VAL;\n+        }\n+\n+        double absErrN = Math.abs(res - stat2.getSum());\n+        double absErr = Math.abs(stat0.getSum() - stat2.getSum());\n+        System.out.println(\"serial sum: \" + stat0.getSum());\n+        System.out.println(\"combined sum: \" + stat2.getSum());\n+        System.out.println(\"abs error: \" + absErr);\n+        if (absErr == 0.0) {\n+            throw new RuntimeException(\"Absolute error is too big: \" + absErr);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/util\/DoubleSummaryStatistics\/NegativeCompensation.java","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"}]}