{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -514,0 +514,1 @@\n+     * @jvms 4.6 Methods\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -521,0 +521,1 @@\n+     * @jvms 4.6 Methods\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -570,2 +570,2 @@\n-     * Returns {@code true} if this method is a bridge\n-     * method; returns {@code false} otherwise.\n+     * {@return {@code true} if this method is a bridge\n+     * method; returns {@code false} otherwise}\n@@ -573,2 +573,30 @@\n-     * @return true if and only if this method is a bridge\n-     * method as defined by the Java Language Specification.\n+     * @apiNote\n+     * A bridge method is a {@linkplain isSynthetic synthetic} method\n+     * created by a Java compiler alongside a method originating from\n+     * the source code. Bridge methods are used by Java compilers in\n+     * various circumstances to span differences in Java programming\n+     * language semantics and JVM semantics.\n+     *\n+     * <p>One example use of bridge methods is as a technique for a\n+     * Java compiler to support <i>covariant overrides<\/i>, where a\n+     * subclass overrides a method and gives the new method a more\n+     * specific return type than the method in the superclass.  While\n+     * the Java language specification forbids a class declaring two\n+     * methods with the same parameter types but a different return\n+     * type, the virtual machine does not. A common case where\n+     * covariant overrides are used is for a {@link\n+     * java.lang.Cloneable Cloneable} class where the {@link\n+     * Object#clone() clone} method inherited from {@code\n+     * java.lang.Object} is overridden and declared to return the type\n+     * of the class. For example, {@code Object} declares\n+     * <pre>{@code protected Object clone() throws CloneNotSupportedException {...}}<\/pre>\n+     * and {@code EnumSet<E>} declares its language-level {@linkplain\n+     * java.util.EnumSet#clone() covariant override}\n+     * <pre>{@code public EnumSet<E> clone() {...}}<\/pre>\n+     * If this technique was being used, the resulting class file for\n+     * {@code EnumSet} would have two {@code clone} methods, one\n+     * returning {@code EnumSet<E>} and the second a bridge method\n+     * returning {@code Object}. The bridge method is a JVM-level\n+     * override of {@code Object.clone()}.  The body of the {@code\n+     * clone} bridge method calls its non-bridge counterpart and\n+     * returns its result.\n@@ -576,0 +604,4 @@\n+     *\n+     * @jls 8.4.8.3 Requirements in Overriding and Hiding\n+     * @jls 15.12.4.5 Create Frame, Synchronize, Transfer Control\n+     * @jvms 4.6 Methods\n@@ -593,0 +625,1 @@\n+     * @jvms 4.6 Methods\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"}]}