{"files":[{"patch":"@@ -57,0 +57,1 @@\n+BUILD_JDK_JTREG_LIBRARIES_LDFLAGS_libAsyncInvokers := $(LIBCXX)\n@@ -69,0 +70,1 @@\n+  BUILD_JDK_JTREG_LIBRARIES_CFLAGS_libAsyncInvokers := \/EHsc\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -354,1 +354,0 @@\n-  template(jdk_incubator_foreign_MemoryAccess,       \"jdk\/incubator\/foreign\/MemoryAccess\")        \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1589,12 +1589,0 @@\n-bool MethodData::profile_memory_access(const methodHandle& m, int bci) {\n-  Bytecode_invoke inv(m , bci);\n-  if (inv.is_invokestatic()) {\n-    if (inv.klass() == vmSymbols::jdk_incubator_foreign_MemoryAccess()) {\n-      if (inv.name()->starts_with(\"get\") || inv.name()->starts_with(\"set\")) {\n-        return true;\n-      }\n-    }\n-  }\n-  return false;\n-}\n-\n@@ -1630,4 +1618,0 @@\n-  if (profile_memory_access(m, bci)) {\n-    return true;\n-  }\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+  ResourceMark rm;\n","filename":"src\/hotspot\/share\/prims\/universalUpcallHandler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -113,1 +114,2 @@\n-    private volatile boolean enableNativeAccess;\n+    @Stable\n+    private boolean enableNativeAccess;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1583,5 +1583,0 @@\n-            @Override\n-            public void ensureCustomized(MethodHandle mh) {\n-                mh.customize();\n-            }\n-\n@@ -1670,0 +1665,4 @@\n+            @Override\n+            public Class<?>[] exceptionTypes(MethodHandle handle) {\n+                return VarHandles.exceptionTypes(handle);\n+            }\n@@ -2276,9 +2275,10 @@\n-            MH_cast                  = 0,\n-            MH_selectAlternative     = 1,\n-            MH_countedLoopPred       = 2,\n-            MH_countedLoopStep       = 3,\n-            MH_initIterator          = 4,\n-            MH_iteratePred           = 5,\n-            MH_iterateNext           = 6,\n-            MH_Array_newInstance     = 7,\n-            MH_LIMIT                 = 8;\n+            MH_cast                  =              0,\n+            MH_selectAlternative     =              1,\n+            MH_countedLoopPred       =              2,\n+            MH_countedLoopStep       =              3,\n+            MH_initIterator          =              4,\n+            MH_iteratePred           =              5,\n+            MH_iterateNext           =              6,\n+            MH_Array_newInstance     =              7,\n+            MH_VarHandles_handleCheckedExceptions = 8,\n+            MH_LIMIT                 =              9;\n@@ -2334,0 +2334,3 @@\n+                case MH_VarHandles_handleCheckedExceptions:\n+                    return IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n+                            MethodType.methodType(void.class, Throwable.class));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":17,"deletions":14,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import java.lang.reflect.Parameter;\n@@ -37,1 +36,0 @@\n-import java.util.LinkedHashMap;\n@@ -39,1 +37,0 @@\n-import java.util.Map;\n@@ -48,2 +45,0 @@\n-import static java.util.stream.Collectors.joining;\n-import static java.util.stream.Collectors.toList;\n@@ -362,1 +357,1 @@\n-    public static VarHandle filterValue(VarHandle target, MethodHandle filterToTarget, MethodHandle filterFromTarget) {\n+    public static VarHandle filterValue(VarHandle target, MethodHandle pFilterToTarget, MethodHandle pFilterFromTarget) {\n@@ -364,2 +359,2 @@\n-        Objects.requireNonNull(filterToTarget);\n-        Objects.requireNonNull(filterFromTarget);\n+        Objects.requireNonNull(pFilterToTarget);\n+        Objects.requireNonNull(pFilterFromTarget);\n@@ -367,2 +362,2 @@\n-        noCheckedExceptions(filterToTarget);\n-        noCheckedExceptions(filterFromTarget);\n+        MethodHandle filterToTarget = adaptForCheckedExceptions(pFilterToTarget);\n+        MethodHandle filterFromTarget = adaptForCheckedExceptions(pFilterFromTarget);\n@@ -476,2 +471,3 @@\n-            noCheckedExceptions(filters[i]);\n-            MethodType filterType = filters[i].type();\n+            MethodHandle filter = Objects.requireNonNull(filters[i]);\n+            filter = adaptForCheckedExceptions(filter);\n+            MethodType filterType = filter.type();\n@@ -567,1 +563,1 @@\n-    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle filter) {\n+    public static VarHandle collectCoordinates(VarHandle target, int pos, MethodHandle pFilter) {\n@@ -569,2 +565,2 @@\n-        Objects.requireNonNull(filter);\n-        noCheckedExceptions(filter);\n+        Objects.requireNonNull(pFilter);\n+        MethodHandle filter = adaptForCheckedExceptions(pFilter);\n@@ -607,1 +603,23 @@\n-    private static void noCheckedExceptions(MethodHandle handle) {\n+    private static MethodHandle adaptForCheckedExceptions(MethodHandle target) {\n+        Class<?>[] exceptionTypes = exceptionTypes(target);\n+        if (exceptionTypes != null) { \/\/ exceptions known\n+            if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n+                throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n+            }\n+            return target; \/\/ no adaptation needed\n+        } else {\n+            MethodHandle handler = MethodHandleImpl.getConstantHandle(MethodHandleImpl.MH_VarHandles_handleCheckedExceptions);\n+            MethodHandle zero = MethodHandles.zero(target.type().returnType()); \/\/ dead branch\n+            handler = MethodHandles.collectArguments(zero, 0, handler);\n+            return MethodHandles.catchException(target, Throwable.class, handler);\n+        }\n+    }\n+\n+    static void handleCheckedExceptions(Throwable throwable) throws Throwable {\n+        if (isCheckedException(throwable.getClass())) {\n+            throw new IllegalStateException(\"Adapter handle threw checked exception\", throwable);\n+        }\n+        throw throwable;\n+    }\n+\n+    static Class<?>[] exceptionTypes(MethodHandle handle) {\n@@ -614,1 +632,0 @@\n-            final Class<?>[] exceptionTypes;\n@@ -616,1 +633,1 @@\n-                exceptionTypes = info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Method.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -619,1 +636,1 @@\n-                exceptionTypes = null;\n+                return new Class<?>[0];\n@@ -621,1 +638,1 @@\n-                exceptionTypes = info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n+                return info.reflectAs(Constructor.class, MethodHandles.Lookup.IMPL_LOOKUP)\n@@ -626,5 +643,0 @@\n-            if (exceptionTypes != null) {\n-                if (Stream.of(exceptionTypes).anyMatch(VarHandles::isCheckedException)) {\n-                    throw newIllegalArgumentException(\"Cannot adapt a var handle with a method handle which throws checked exceptions\");\n-                }\n-            }\n@@ -632,10 +644,3 @@\n-            noCheckedExceptions(((DelegatingMethodHandle)handle).getTarget());\n-        } else {\n-            \/\/bound\n-            BoundMethodHandle boundHandle = (BoundMethodHandle)handle;\n-            for (int i = 0 ; i < boundHandle.fieldCount() ; i++) {\n-                Object arg = boundHandle.arg(i);\n-                if (arg instanceof MethodHandle){\n-                    noCheckedExceptions((MethodHandle) arg);\n-                }\n-            }\n+            return exceptionTypes(((DelegatingMethodHandle)handle).getTarget());\n+        } else if (handle instanceof NativeMethodHandle) {\n+            return new Class<?>[0];\n@@ -643,0 +648,4 @@\n+\n+        assert handle instanceof BoundMethodHandle : \"Unexpected handle type: \" + handle;\n+        \/\/ unknown\n+        return null;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":44,"deletions":35,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -823,1 +823,1 @@\n-                public Scope.Handle acquireScope(Buffer buffer, boolean async) {\n+                public Runnable acquireScope(Buffer buffer, boolean async) {\n@@ -831,1 +831,2 @@\n-                    return scope.acquire();\n+                    scope.acquire0();\n+                    return scope::release0;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -139,7 +139,0 @@\n-    \/**\n-     * Ensure given method handle is customized\n-     *\n-     * @param mh the method handle\n-     *\/\n-    void ensureCustomized(MethodHandle mh);\n-\n@@ -184,0 +177,7 @@\n+\n+    \/**\n+     * A best-effort method that tries to find any exceptions thrown by the given method handle.\n+     * @param handle the handle to check\n+     * @return an array of exceptions, or {@code null}.\n+     *\/\n+    Class<?>[] exceptionTypes(MethodHandle handle);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -95,1 +95,1 @@\n-    Scope.Handle acquireScope(Buffer buffer, boolean async);\n+    Runnable acquireScope(Buffer buffer, boolean async);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -106,4 +106,0 @@\n-       interface Handle {\n-            Scope scope();\n-        }\n-\n@@ -114,3 +110,1 @@\n-        boolean isImplicit();\n-\n-        Handle acquire();\n+        void acquire0();\n@@ -118,1 +112,1 @@\n-        void release(Handle handle);\n+        void release0();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/X-ScopedMemoryAccess.java.template","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -109,0 +110,1 @@\n+    @ForceInline\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n-    static Scope.Handle acquireScope(ByteBuffer bb, boolean async) {\n+    static Runnable acquireScope(ByteBuffer bb, boolean async) {\n@@ -482,1 +482,1 @@\n-    private static void releaseScope(Scope.Handle handle) {\n+    private static void releaseScope(Runnable handle) {\n@@ -486,1 +486,1 @@\n-            handle.scope().release(handle);\n+            handle.run();\n@@ -538,1 +538,1 @@\n-    static record Releaser(Scope.Handle handle) implements Runnable {\n+    static record Releaser(Runnable handle) implements Runnable {\n@@ -541,2 +541,2 @@\n-        static Runnable of(Scope.Handle handle) { return new Releaser(handle); }\n-        static Runnable ofNullable(Scope.Handle handle) {\n+        static Runnable of(Runnable handle) { return new Releaser(handle); }\n+        static Runnable ofNullable(Runnable handle) {\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/IOUtil.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.vm.annotation.Stable;\n+\n@@ -29,1 +32,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +33,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -37,3 +38,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.Map;\n@@ -43,2 +41,0 @@\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n@@ -48,0 +44,1 @@\n+import static java.lang.constant.ConstantDescs.CD_Class;\n@@ -55,1 +52,3 @@\n-    final Map<String, Constable> attributes;\n+    private final Optional<String> name;\n+    @Stable\n+    long cachedSize;\n@@ -57,1 +56,1 @@\n-    public AbstractLayout(OptionalLong size, long alignment, Map<String, Constable> attributes) {\n+    public AbstractLayout(OptionalLong size, long alignment, Optional<String> name) {\n@@ -60,1 +59,1 @@\n-        this.attributes = Collections.unmodifiableMap(attributes);\n+        this.name = name;\n@@ -66,1 +65,1 @@\n-        return withAttribute(LAYOUT_NAME, name);\n+        return dup(alignment, Optional.of(name));\n@@ -71,20 +70,1 @@\n-        return attribute(LAYOUT_NAME).map(String.class::cast);\n-    }\n-\n-    @Override\n-    public Optional<Constable> attribute(String name) {\n-        Objects.requireNonNull(name);\n-        return Optional.ofNullable(attributes.get(name));\n-    }\n-\n-    @Override\n-    public Stream<String> attributes() {\n-        return attributes.keySet().stream();\n-    }\n-\n-    @Override\n-    public AbstractLayout withAttribute(String name, Constable value) {\n-        Objects.requireNonNull(name);\n-        Map<String, Constable> newAttributes = new HashMap<>(attributes);\n-        newAttributes.put(name, value);\n-        return dup(alignment, newAttributes);\n+        return name;\n@@ -93,1 +73,1 @@\n-    abstract AbstractLayout dup(long alignment, Map<String, Constable> annos);\n+    abstract AbstractLayout dup(long alignment, Optional<String> name);\n@@ -98,1 +78,1 @@\n-        return dup(alignmentBits, attributes);\n+        return dup(alignmentBits, name);\n@@ -123,0 +103,9 @@\n+    @Override\n+    public long byteSize() {\n+        if (cachedSize == 0) {\n+            cachedSize = Utils.bitsToBytesOrThrow(bitSize(),\n+                    () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n+        }\n+        return cachedSize;\n+    }\n+\n@@ -148,5 +137,0 @@\n-        if (!attributes.isEmpty()) {\n-            s += attributes.entrySet().stream()\n-                                      .map(e -> e.getKey() + \"=\" + e.getValue())\n-                                      .collect(Collectors.joining(\",\", \"[\", \"]\"));\n-        }\n@@ -161,3 +145,3 @@\n-        for (var e : attributes.entrySet()) {\n-            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withAttribute\", desc.constantType(), MH_WITH_ATTRIBUTE,\n-                    desc, e.getKey(), e.getValue().describeConstable().orElseThrow());\n+        if (name().isPresent()) {\n+            desc = DynamicConstantDesc.ofNamed(BSM_INVOKE, \"withName\", desc.constantType(), MH_WITH_NAME,\n+                    desc, name().get().describeConstable().orElseThrow());\n@@ -180,1 +164,1 @@\n-        return attributes.hashCode() << Long.hashCode(alignment);\n+        return name.hashCode() << Long.hashCode(alignment);\n@@ -193,1 +177,1 @@\n-        return Objects.equals(attributes, ((AbstractLayout) other).attributes) &&\n+        return Objects.equals(name, ((AbstractLayout) other).name) &&\n@@ -211,2 +195,0 @@\n-    static final ClassDesc CD_Constable = Constable.class.describeConstable().get();\n-\n@@ -220,3 +202,0 @@\n-    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n-                MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_long, CD_BYTEORDER));\n-\n@@ -235,0 +214,3 @@\n+    static final MethodHandleDesc MH_VALUE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_STATIC, CD_MEMORY_LAYOUT, \"valueLayout\",\n+            MethodTypeDesc.of(CD_VALUE_LAYOUT, CD_Class, CD_BYTEORDER));\n+\n@@ -244,2 +226,2 @@\n-    static final MethodHandleDesc MH_WITH_ATTRIBUTE = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withAttribute\",\n-                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String, CD_Constable));\n+    static final MethodHandleDesc MH_WITH_NAME = MethodHandleDesc.ofMethod(DirectMethodHandleDesc.Kind.INTERFACE_VIRTUAL, CD_MEMORY_LAYOUT, \"withName\",\n+                MethodTypeDesc.of(CD_MEMORY_LAYOUT, CD_String));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/AbstractLayout.java","additions":32,"deletions":50,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -30,2 +30,6 @@\n- * a memory address instance (see {@link #address()}). Examples of addressable types are {@link MemorySegment},\n- * {@link MemoryAddress} and {@link CLinker.VaList}.\n+ * a {@linkplain #address() memory address}. Examples of addressable types are {@link MemorySegment},\n+ * {@link MemoryAddress}, {@link VaList} and {@link NativeSymbol}.\n+ * <p>\n+ * The {@link Addressable} type is used by the {@link CLinker C linker} to model the types of\n+ * {@link CLinker#downcallHandle(FunctionDescriptor) downcall handle} parameters that must be passed <em>by reference<\/em>\n+ * (e.g. memory addresses, va lists and upcall stubs).\n@@ -36,1 +40,2 @@\n-public interface Addressable {\n+public sealed interface Addressable permits MemorySegment, MemoryAddress, NativeSymbol, VaList {\n+\n@@ -38,2 +43,2 @@\n-     * Map this object into a {@link MemoryAddress} instance.\n-     * @return the {@link MemoryAddress} instance associated with this object.\n+     * Returns the memory address associated with this addressable.\n+     * @return The memory address associated with this addressable.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/Addressable.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -33,4 +30,4 @@\n-import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n-import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n-import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n-import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64Linker;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64Linker;\n+import jdk.internal.foreign.abi.x64.sysv.SysVx64Linker;\n+import jdk.internal.foreign.abi.x64.windows.Windowsx64Linker;\n@@ -40,1 +37,0 @@\n-import java.lang.constant.Constable;\n@@ -43,6 +39,1 @@\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n-import java.util.Objects;\n-import java.util.function.Consumer;\n-\n-import static jdk.internal.foreign.PlatformLayouts.*;\n+import java.util.Optional;\n@@ -53,1 +44,3 @@\n- * follow the JVM's target platform C ABI.\n+ * follow the JVM's target platform C ABI. A C linker provides two main capabilities: first, it allows Java code\n+ * to <em>link<\/em> foreign functions into a so called <em>downcall method handle<\/em>; secondly, it allows\n+ * native code to call Java method handles via the generation of <em>upcall stubs<\/em>.\n@@ -55,5 +48,1 @@\n- * Linking a foreign function is a process which requires two components: a method type, and\n- * a function descriptor. The method type, consists of a set of <em>carrier<\/em> types, which, together,\n- * specify the Java signature which clients must adhere to when calling the underlying foreign function.\n- * The function descriptor contains a set of memory layouts which, together, specify the foreign function\n- * signature and classification information (via a custom layout attributes, see {@link TypeKind}), so that linking can take place.\n+ * On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n@@ -61,6 +50,21 @@\n- * Clients of this API can build function descriptors using the predefined memory layout constants\n- * (based on a subset of the built-in types provided by the C language), found in this interface; alternatively,\n- * they can also decorate existing value layouts using the required {@link TypeKind} classification attribute\n- * (this can be done using the {@link MemoryLayout#withAttribute(String, Constable)} method). A failure to do so might\n- * result in linkage errors, given that linking requires additional classification information to determine, for instance,\n- * how arguments should be loaded into registers during a foreign function call.\n+ * Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\n+ * <h2><a id = \"downcall-method-handles\">Downcall method handles<\/a><\/h2>\n+ * <p>\n+ * {@linkplain #downcallHandle(FunctionDescriptor) Linking a foreign function} is a process which requires a function descriptor,\n+ * a set of memory layouts which, together, specify the signature of the foreign function to be linked, and returns,\n+ * when complete, a downcall method handle, that is, a method handle that can be used to invoke the target native function.\n+ * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is\n+ * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n+ * as described below:\n+ * <ul>\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n+ *     <ul>\n+ *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code NativeAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n+ * <\/ul>\n@@ -68,5 +72,21 @@\n- * Implementations of this interface support the following primitive carrier types:\n- * {@code byte}, {@code short}, {@code char}, {@code int}, {@code long}, {@code float},\n- * and {@code double}, as well as {@link MemoryAddress} for passing pointers, and\n- * {@link MemorySegment} for passing structs and unions. Finally, the {@link VaList}\n- * carrier type can be used to match the native {@code va_list} type.\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters:\n+ * <ul>\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a native symbol},\n+ * the downcall method handle type features a leading parameter of type {@link NativeSymbol}, from which the\n+ * address of the target native function can be derived.<\/li>\n+ * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by the downcall method handle.<\/li>\n+ * <\/ul>\n+ * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n+ * list or with an empty formal parameter list, are not supported directly. However, it is possible to link a native\n+ * variadic function by using a {@linkplain FunctionDescriptor#asVariadic(MemoryLayout...) <em>variadic<\/em>} function descriptor,\n+ * in which the specialized signature of a given variable arity callsite is described in full. Alternatively,\n+ * if the foreign library allows it, clients might also be able to interact with variable arity methods\n+ * by passing a trailing parameter of type {@link VaList}.\n+ *\n+ * <h2><a id = \"upcall-stubs\">Upcall stubs<\/a><\/h2>\n+ *\n+ * {@linkplain #upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) Creating an upcall stub} requires a method\n+ * handle and a function descriptor; in this case, the set of memory layouts in the function descriptor\n+ * specify the signature of the function pointer associated with the upcall stub.\n@@ -74,3 +94,3 @@\n- * For the linking process to be successful, some requirements must be satisfied; if {@code M} and {@code F} are\n- * the method type (obtained after dropping any prefix arguments) and the function descriptor, respectively,\n- * used during the linking process, then it must be that:\n+ * The type of the provided method handle has to match the Java {@link java.lang.invoke.MethodType method type}\n+ * associated with the upcall stub, which is derived from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n@@ -78,5 +98,1 @@\n- *     <li>The arity of {@code M} is the same as that of {@code F};<\/li>\n- *     <li>If the return type of {@code M} is {@code void}, then {@code F} should have no return layout\n- *     (see {@link FunctionDescriptor#ofVoid(MemoryLayout...)});<\/li>\n- *     <li>for each pair of carrier type {@code C} and layout {@code L} in {@code M} and {@code F}, respectively,\n- *     where {@code C} and {@code L} refer to the same argument, or to the return value, the following conditions must hold:\n+ * <li>if {@code L} is a {@link ValueLayout} with carrier {@code E} then there are two cases:\n@@ -84,9 +100,5 @@\n- *       <li>If {@code C} is a primitve type, then {@code L} must be a {@code ValueLayout}, and the size of the layout must match\n- *       that of the carrier type (see {@link Integer#SIZE} and similar fields in other primitive wrapper classes);<\/li>\n- *       <li>If {@code C} is {@code MemoryAddress.class}, then {@code L} must be a {@code ValueLayout}, and its size must match\n- *       the platform's address size (see {@link MemoryLayouts#ADDRESS}). For this purpose, the {@link CLinker#C_POINTER} layout\n- *       constant can  be used;<\/li>\n- *       <li>If {@code C} is {@code MemorySegment.class}, then {@code L} must be a {@code GroupLayout}<\/li>\n- *       <li>If {@code C} is {@code VaList.class}, then {@code L} must be {@link CLinker#C_VA_LIST}<\/li>\n- *     <\/ul>\n- *     <\/li>\n+ *         <li>if {@code L} occurs in a return position and {@code E} is {@code MemoryAddress.class},\n+ *         then {@code C = Addressable.class};<\/li>\n+ *         <li>otherwise, {@code C = E};\n+ *     <\/ul><\/li>\n+ * <li>or, if {@code L} is a {@link GroupLayout}, then {@code C} is set to {@code MemorySegment.class}<\/li>\n@@ -94,0 +106,3 @@\n+ * Upcall stubs are modelled by instances of type {@link NativeSymbol}; upcall stubs can be passed by reference to other\n+ * downcall method handles (as {@link NativeSymbol} implements the {@link Addressable} interface) and,\n+ * when no longer required, they can be {@link ResourceScope#close() released}, via their {@linkplain NativeSymbol#scope() scope}.\n@@ -95,10 +110,1 @@\n- * <p>Variadic functions, declared in C either with a trailing ellipses ({@code ...}) at the end of the formal parameter\n- * list or with an empty formal parameter list, are not supported directly. It is not possible to create a method handle\n- * that takes a variable number of arguments, and neither is it possible to create an upcall stub wrapping a method\n- * handle that accepts a variable number of arguments. However, for downcalls only, it is possible to link a native\n- * variadic function by using a <em>specialized<\/em> method type and function descriptor: for each argument that is to be\n- * passed as a variadic argument, an explicit, additional, carrier type and memory layout must be present in the method type and\n- * function descriptor objects passed to the linker. Furthermore, as memory layouts corresponding to variadic arguments in\n- * a function descriptor must contain additional classification information, it is required that\n- * {@link #asVarArg(MemoryLayout)} is used to create the memory layouts for each parameter corresponding to a variadic\n- * argument in a specialized function descriptor.\n+ * <h2>System lookup<\/h2>\n@@ -106,1 +112,3 @@\n- * <p>On unsupported platforms this class will fail to initialize with an {@link ExceptionInInitializerError}.\n+ * This class implements the {@link SymbolLookup} interface; as such clients can {@linkplain #lookup(String) lookup} symbols\n+ * in the standard libraries associated with this linker. The set of symbols available for lookup is unspecified,\n+ * as it depends on the platform and on the operating system.\n@@ -108,2 +116,22 @@\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ * <h2>Safety considerations<\/h2>\n+ *\n+ * Obtaining downcall method handle is intrinsically unsafe. A symbol in a native library does not, in general,\n+ * contain enough signature information (e.g. arity and types of native function parameters). As a consequence,\n+ * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n+ * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n+ * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n+ * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment},\n+ * {@link NativeSymbol} or {@link VaList}):\n+ * <ul>\n+ *     <li>The resource scope of {@code R} is {@linkplain ResourceScope#isAlive() alive}. Otherwise, the invocation throws\n+ *     {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in same thread as the one {@link ResourceScope#ownerThread() owning} the resource scope of {@code R},\n+ *     if said scope is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n+ *     <li>The scope of {@code R} is {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} (and cannot be closed) during the invocation.\n+ *<\/ul>\n+ * <p>\n+ * Upcall stubs are generally safer to work with, as the linker runtime can validate the type of the target method\n+ * handle against the provided function descriptor and report an error if any mismatch is detected. If the target method\n+ * handle associated with an upcall stub returns a {@linkplain MemoryAddress native address}, clients must ensure\n+ * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n+ * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n@@ -114,1 +142,1 @@\n-public sealed interface CLinker permits AbstractCLinker {\n+public sealed interface CLinker extends SymbolLookup permits Windowsx64Linker, SysVx64Linker, LinuxAArch64Linker, MacOsAArch64Linker {\n@@ -130,1 +158,1 @@\n-    static CLinker getInstance() {\n+    static CLinker systemCLinker() {\n@@ -136,11 +164,3 @@\n-     * Obtains a system lookup which is suitable to find symbols in the standard C libraries. The set of symbols\n-     * available for lookup is unspecified, as it depends on the platform and on the operating system.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     * @return a system-specific library lookup which is suitable to find symbols in the standard C libraries.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Lookup a symbol in the standard libraries associated with this linker.\n+     * The set of symbols available for lookup is unspecified, as it depends on the platform and on the operating system.\n+     * @return a symbol in the standard libraries associated with this linker.\n@@ -148,4 +168,3 @@\n-    @CallerSensitive\n-    static SymbolLookup systemLookup() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return SystemLookup.getInstance();\n+    @Override\n+    default Optional<NativeSymbol> lookup(String name) {\n+        return SystemLookup.getInstance().lookup(name);\n@@ -156,1 +175,1 @@\n-     * which can be used to call a target foreign function at the given address.\n+     * which can be used to call a target foreign function at the address in the given native symbol.\n@@ -161,0 +180,5 @@\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+<blockquote><pre>{@code\n+    linker.downcallHandle(function).bindTo(symbol);\n+}<\/pre><\/blockquote>\n@@ -163,1 +187,0 @@\n-     * @param type     the method type.\n@@ -165,22 +188,3 @@\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n-     *                                  is {@link MemoryAddress#NULL}\n-     *\n-     * @see SymbolLookup\n-     *\/\n-    MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function);\n-\n-    \/**\n-     * Obtain a foreign method handle, with the given type and featuring the given function descriptor,\n-     * which can be used to call a target foreign function at the given address.\n-     * <p>\n-     * If the provided method type's return type is {@code MemorySegment}, then the provided allocator will be used by\n-     * the linker runtime to allocate structs returned by-value.\n-     *\n-     * @param symbol    downcall symbol.\n-     * @param allocator the segment allocator.\n-     * @param type      the method type.\n-     * @param function  the function descriptor.\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch, or if the symbol\n-     *                                  is {@link MemoryAddress#NULL}\n+     * @return the downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n+     * or if the symbol is {@link MemoryAddress#NULL}\n@@ -190,1 +194,4 @@\n-    MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function);\n+    default MethodHandle downcallHandle(NativeSymbol symbol, FunctionDescriptor function) {\n+        SharedUtils.checkSymbol(symbol);\n+        return downcallHandle(function).bindTo(symbol);\n+    }\n@@ -194,3 +201,3 @@\n-     * used to call a target foreign function at an address.\n-     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the address, of\n-     * type {@link Addressable}.\n+     * used to call a target foreign function at the address in a dynamically provided native symbol.\n+     * The resulting method handle features a prefix parameter (as the first parameter) corresponding to the foreign function\n+     * entry point, of type {@link NativeSymbol}.\n@@ -198,1 +205,1 @@\n-     * If the provided method type's return type is {@code MemorySegment}, then the resulting method handle features an\n+     * If the provided function descriptor's return layout is a {@link GroupLayout}, then the resulting method handle features an\n@@ -202,2 +209,2 @@\n-     * The returned method handle will throw an {@link IllegalArgumentException} if the target address passed to it is\n-     * {@link MemoryAddress#NULL}, or a {@link NullPointerException} if the target address is {@code null}.\n+     * The returned method handle will throw an {@link IllegalArgumentException} if the native symbol passed to it is\n+     * associated with the {@link MemoryAddress#NULL} address, or a {@link NullPointerException} if the native symbol is {@code null}.\n@@ -205,1 +212,0 @@\n-     * @param type     the method type.\n@@ -207,2 +213,3 @@\n-     * @return the downcall method handle.\n-     * @throws IllegalArgumentException in the case of a method type and function descriptor mismatch.\n+     * @return the downcall method handle. The method handle type is <a href=\"CLinker.html#downcall-method-handles\"><em>inferred<\/em><\/a>\n+     * from the provided function descriptor.\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout.\n@@ -212,1 +219,1 @@\n-    MethodHandle downcallHandle(MethodType type, FunctionDescriptor function);\n+    MethodHandle downcallHandle(FunctionDescriptor function);\n@@ -219,1 +226,1 @@\n-     * The returned memory address is associated with the provided scope. When such scope is closed,\n+     * The returned function pointer is associated with the provided scope. When such scope is closed,\n@@ -231,2 +238,4 @@\n-     * @return the native stub segment.\n-     * @throws IllegalArgumentException if the target's method type and the function descriptor mismatch.\n+     * @return the native stub symbol.\n+     * @throws IllegalArgumentException if the provided descriptor contains either a sequence or a padding layout,\n+     * or if it is determined that the target method handle can throw an exception, or if the target method handle\n+     * has a type that does not match the upcall stub <a href=\"CLinker.html#upcall-stubs\"><em>inferred type<\/em><\/a>.\n@@ -236,147 +245,1 @@\n-    MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n-\n-    \/**\n-     * The layout for the {@code char} C type\n-     *\/\n-    ValueLayout C_CHAR = pick(SysV.C_CHAR, Win64.C_CHAR, AArch64.C_CHAR);\n-    \/**\n-     * The layout for the {@code short} C type\n-     *\/\n-    ValueLayout C_SHORT = pick(SysV.C_SHORT, Win64.C_SHORT, AArch64.C_SHORT);\n-    \/**\n-     * The layout for the {@code int} C type\n-     *\/\n-    ValueLayout C_INT = pick(SysV.C_INT, Win64.C_INT, AArch64.C_INT);\n-    \/**\n-     * The layout for the {@code long} C type\n-     *\/\n-    ValueLayout C_LONG = pick(SysV.C_LONG, Win64.C_LONG, AArch64.C_LONG);\n-    \/**\n-     * The layout for the {@code long long} C type.\n-     *\/\n-    ValueLayout C_LONG_LONG = pick(SysV.C_LONG_LONG, Win64.C_LONG_LONG, AArch64.C_LONG_LONG);\n-    \/**\n-     * The layout for the {@code float} C type\n-     *\/\n-    ValueLayout C_FLOAT = pick(SysV.C_FLOAT, Win64.C_FLOAT, AArch64.C_FLOAT);\n-    \/**\n-     * The layout for the {@code double} C type\n-     *\/\n-    ValueLayout C_DOUBLE = pick(SysV.C_DOUBLE, Win64.C_DOUBLE, AArch64.C_DOUBLE);\n-    \/**\n-     * The {@code T*} native type.\n-     *\/\n-    ValueLayout C_POINTER = pick(SysV.C_POINTER, Win64.C_POINTER, AArch64.C_POINTER);\n-    \/**\n-     * The layout for the {@code va_list} C type\n-     *\/\n-    MemoryLayout C_VA_LIST = pick(SysV.C_VA_LIST, Win64.C_VA_LIST, AArch64.C_VA_LIST);\n-\n-    \/**\n-     * Returns a memory layout that is suitable to use as the layout for variadic arguments in a specialized\n-     * function descriptor.\n-     * @param <T> the memory layout type\n-     * @param layout the layout the adapt\n-     * @return a potentially newly created layout with the right attributes\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    static <T extends MemoryLayout> T asVarArg(T layout) {\n-        Objects.requireNonNull(layout);\n-        return (T) PlatformLayouts.asVarArg(layout);\n-    }\n-\n-    \/**\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n-     * storing the result into a native memory segment allocated using the provided allocator.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param allocator the allocator to be used for the native segment allocation.\n-     * @return a new native memory segment containing the converted C string.\n-     *\/\n-    static MemorySegment toCString(String str, SegmentAllocator allocator) {\n-        Objects.requireNonNull(str);\n-        Objects.requireNonNull(allocator);\n-        return toCString(str.getBytes(StandardCharsets.UTF_8), allocator);\n-    }\n-\n-    \/**\n-     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n-     * storing the result into a native memory segment associated with the provided resource scope.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement byte array.  The\n-     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n-     * control over the encoding process is required.\n-     *\n-     * @param str the Java string to be converted into a C string.\n-     * @param scope the resource scope to be associated with the returned segment.\n-     * @return a new native memory segment containing the converted C string.\n-     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-     * than the thread owning {@code scope}.\n-     *\/\n-    static MemorySegment toCString(String str, ResourceScope scope) {\n-        return toCString(str, SegmentAllocator.ofScope(scope));\n-    }\n-\n-    \/**\n-     * Converts a UTF-8 encoded, null-terminated C string stored at given address into a Java string.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform,\n-     * or if {@code addr == MemoryAddress.NULL}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-     *\/\n-    @CallerSensitive\n-    static String toJavaString(MemoryAddress addr) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SharedUtils.checkAddress(addr);\n-        return SharedUtils.toJavaStringInternal(NativeMemorySegmentImpl.EVERYTHING, addr.toRawLongValue());\n-    }\n-\n-    \/**\n-     * Converts a UTF-8 encoded, null-terminated C string stored at given address into a Java string.\n-     * <p>\n-     * This method always replaces malformed-input and unmappable-character\n-     * sequences with this charset's default replacement string.  The {@link\n-     * java.nio.charset.CharsetDecoder} class should be used when more control\n-     * over the decoding process is required.\n-     * @param addr the address at which the string is stored.\n-     * @return a Java string with the contents of the null-terminated C string at given address.\n-     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n-     * @throws IllegalStateException if the size of the native string is greater than the size of the segment\n-     * associated with {@code addr}, or if {@code addr} is associated with a segment that is <em>not alive<\/em>.\n-     *\/\n-    static String toJavaString(MemorySegment addr) {\n-        Objects.requireNonNull(addr);\n-        return SharedUtils.toJavaStringInternal(addr, 0L);\n-    }\n-\n-    private static void copy(MemorySegment addr, byte[] bytes) {\n-        var heapSegment = MemorySegment.ofArray(bytes);\n-        addr.copyFrom(heapSegment);\n-        MemoryAccess.setByteAtOffset(addr, bytes.length, (byte)0);\n-    }\n-\n-    private static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n-        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n-        copy(addr, bytes);\n-        return addr;\n-    }\n+    NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope);\n@@ -385,13 +248,5 @@\n-     * Allocates memory of given size using malloc.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param size memory size to be allocated\n-     * @return addr memory address of the allocated memory\n-     * @throws OutOfMemoryError if malloc could not allocate the required amount of native memory.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Obtains the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n@@ -399,9 +254,2 @@\n-    @CallerSensitive\n-    static MemoryAddress allocateMemory(long size) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        MemoryAddress addr = SharedUtils.allocateMemoryInternal(size);\n-        if (addr.equals(MemoryAddress.NULL)) {\n-            throw new OutOfMemoryError();\n-        } else {\n-            return addr;\n-        }\n+    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, false);\n@@ -411,12 +259,5 @@\n-     * Frees the memory pointed by the given memory address.\n-     * <p>\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n-     *\n-     * @param addr memory address of the native memory to be freed\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * @throws IllegalArgumentException if {@code addr == MemoryAddress.NULL}.\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * Obtains the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n@@ -424,365 +265,2 @@\n-    @CallerSensitive\n-    static void freeMemory(MemoryAddress addr) {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        SharedUtils.checkAddress(addr);\n-        SharedUtils.freeMemoryInternal(addr);\n-    }\n-\n-    \/**\n-     * An interface that models a C {@code va_list}.\n-     * <p>\n-     * A va list is a stateful cursor used to iterate over a set of variadic arguments.\n-     * <p>\n-     * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n-     * arguments to variadic calls are erased by way of 'default argument promotions',\n-     * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n-     * and which erases all {@code float} arguments to {@code double}.\n-     * <p>\n-     * As such, this interface only supports reading {@code int}, {@code double},\n-     * and any other type that fits into a {@code long}.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n-     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n-     *\/\n-    sealed interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n-\n-        \/**\n-         * Reads the next value as an {@code int} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code int}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-         *\/\n-        int vargAsInt(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code long} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code long}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-         *\/\n-        long vargAsLong(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code double} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code double}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-         *\/\n-        double vargAsDouble(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemoryAddress} and advances this va list's position.\n-         *\n-         * @param layout the layout of the value\n-         * @return the value read as an {@code MemoryAddress}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-         *\/\n-        MemoryAddress vargAsAddress(MemoryLayout layout);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n-         *\n-         * @param layout the layout of the value\n-         * @param allocator the allocator to be used for the native segment allocation\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator);\n-\n-        \/**\n-         * Reads the next value as a {@code MemorySegment}, and advances this va list's position.\n-         * <p>\n-         * The memory segment returned by this method will be associated with the given {@link ResourceScope}.\n-         *\n-         * @param layout the layout of the value\n-         * @param scope the resource scope to be associated with the returned segment\n-         * @return the value read as an {@code MemorySegment}\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         *\/\n-        MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope);\n-\n-        \/**\n-         * Skips a number of elements with the given memory layouts, and advances this va list's position.\n-         *\n-         * @param layouts the layout of the value\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         *\/\n-        void skip(MemoryLayout... layouts);\n-\n-        \/**\n-         * Returns the resource scope associated with this instance.\n-         * @return the resource scope associated with this instance.\n-         *\/\n-        ResourceScope scope();\n-\n-        \/**\n-         * Copies this C {@code va_list} at its current position. Copying is useful to traverse the va list's elements\n-         * starting from the current position, without affecting the state of the original va list, essentially\n-         * allowing the elements to be traversed multiple times.\n-         * <p>\n-         * Any native resource required by the execution of this method will be allocated in the resource scope\n-         * associated with this instance (see {@link #scope()}).\n-         * <p>\n-         * This method only copies the va list cursor itself and not the memory that may be attached to the\n-         * va list which holds its elements. That means that if this va list was created with the\n-         * {@link #make(Consumer, ResourceScope)} method, closing this va list will also release the native memory that holds its\n-         * elements, making the copy unusable.\n-         *\n-         * @return a copy of this C {@code va_list}.\n-         * @throws IllegalStateException if the resource scope associated with this instance has been closed\n-         * (see {@link #scope()}).\n-         *\/\n-        VaList copy();\n-\n-        \/**\n-         * Returns the memory address of the C {@code va_list} associated with this instance.\n-         * The returned memory address is associated with same resource scope as that associated with this instance.\n-         *\n-         * @return the memory address of the C {@code va_list} associated with this instance.\n-         *\/\n-        @Override\n-        MemoryAddress address();\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * backed by the {@linkplain ResourceScope#globalScope() global} resource scope.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-         *\/\n-        @CallerSensitive\n-        static VaList ofAddress(MemoryAddress address) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            return SharedUtils.newVaListOfAddress(address, ResourceScope.globalScope());\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} instance out of a memory address pointing to an existing C {@code va_list},\n-         * with given resource scope.\n-         * <p>\n-         * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-         * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-         * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-         * restricted methods, and use safe and supported functionalities, where possible.\n-         *\n-         * @param address a memory address pointing to an existing C {@code va_list}.\n-         * @param scope the resource scope to be associated with the returned {@code VaList} instance.\n-         * @return a new {@code VaList} instance backed by the C {@code va_list} at {@code address}.\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-         * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-         * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n-         *\/\n-        @CallerSensitive\n-        static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-            Objects.requireNonNull(address);\n-            Objects.requireNonNull(scope);\n-            return SharedUtils.newVaListOfAddress(address, scope);\n-        }\n-\n-        \/**\n-         * Constructs a new {@code VaList} using a builder (see {@link Builder}), associated with a given\n-         * {@linkplain ResourceScope resource scope}.\n-         * <p>\n-         * If this method needs to allocate native memory, such memory will be managed by the given\n-         * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n-         * <p>\n-         * Note that when there are no elements added to the created va list,\n-         * this method will return the same as {@link #empty()}.\n-         *\n-         * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n-         *                of the underlying C {@code va_list}.\n-         * @param scope the scope to be used for the valist allocation.\n-         * @return a new {@code VaList} instance backed by a fresh C {@code va_list}.\n-         * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n-         * than the thread owning {@code scope}.\n-         *\/\n-        static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n-            Objects.requireNonNull(actions);\n-            Objects.requireNonNull(scope);\n-            return SharedUtils.newVaList(actions, scope);\n-        }\n-\n-        \/**\n-         * Returns an empty C {@code va_list} constant.\n-         * <p>\n-         * The returned {@code VaList} can not be closed.\n-         *\n-         * @return a {@code VaList} modelling an empty C {@code va_list}.\n-         *\/\n-        static VaList empty() {\n-            return SharedUtils.emptyVaList();\n-        }\n-\n-        \/**\n-         * A builder interface used to construct a C {@code va_list}.\n-         *\n-         * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n-         * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n-         *\/\n-        sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n-\n-            \/**\n-             * Adds a native value represented as an {@code int} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as an {@code int}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code int}\n-             *\/\n-            Builder vargFromInt(ValueLayout layout, int value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code long} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code long}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code long}\n-             *\/\n-            Builder vargFromLong(ValueLayout layout, long value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code double} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code double}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code double}\n-             *\/\n-            Builder vargFromDouble(ValueLayout layout, double value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemoryAddress} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code Addressable}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemoryAddress}\n-             *\/\n-            Builder vargFromAddress(ValueLayout layout, Addressable value);\n-\n-            \/**\n-             * Adds a native value represented as a {@code MemorySegment} to the C {@code va_list} being constructed.\n-             *\n-             * @param layout the native layout of the value.\n-             * @param value the value, represented as a {@code MemorySegment}.\n-             * @return this builder.\n-             * @throws IllegalArgumentException if the given memory layout is not compatible with {@code MemorySegment}\n-             *\/\n-            Builder vargFromSegment(GroupLayout layout, MemorySegment value);\n-        }\n-    }\n-\n-    \/**\n-     * A C type kind. Each kind corresponds to a particular C language builtin type, and can be attached to\n-     * {@link ValueLayout} instances using the {@link MemoryLayout#withAttribute(String, Constable)} in order\n-     * to obtain a layout which can be classified accordingly by {@link CLinker#downcallHandle(Addressable, MethodType, FunctionDescriptor)}\n-     * and {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}.\n-     *\/\n-    enum TypeKind {\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code char} type\n-         *\/\n-        CHAR(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code short} type\n-         *\/\n-        SHORT(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code int} type\n-         *\/\n-        INT(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code long} type\n-         *\/\n-        LONG(true),\n-        \/**\n-         * A kind corresponding to the <em>integral<\/em> C {@code long long} type\n-         *\/\n-        LONG_LONG(true),\n-        \/**\n-         * A kind corresponding to the <em>floating-point<\/em> C {@code float} type\n-         *\/\n-        FLOAT(false),\n-        \/**\n-         * A kind corresponding to the <em>floating-point<\/em> C {@code double} type\n-         *\/\n-        DOUBLE(false),\n-        \/**\n-         * A kind corresponding to the an <em>integral<\/em> C pointer type\n-         *\/\n-        POINTER(false);\n-\n-        private final boolean isIntegral;\n-\n-        TypeKind(boolean isIntegral) {\n-            this.isIntegral = isIntegral;\n-        }\n-\n-        \/**\n-         * Is this kind integral?\n-         *\n-         * @return true if this kind is integral\n-         *\/\n-        public boolean isIntegral() {\n-            return isIntegral;\n-        }\n-\n-        \/**\n-         * Is this kind a floating point type?\n-         *\n-         * @return true if this kind is a floating point type\n-         *\/\n-        public boolean isFloat() {\n-            return !isIntegral() && !isPointer();\n-        }\n-\n-        \/**\n-         * Is this kind a pointer kind?\n-         *\n-         * @return true if this kind is a pointer kind\n-         *\/\n-        public boolean isPointer() {\n-            return this == POINTER;\n-        }\n-\n-        \/**\n-         * The layout attribute name associated with this classification kind. Clients can retrieve the type kind\n-         * of a layout using the following code:\n-         * <blockquote><pre>{@code\n-        ValueLayout layout = ...\n-        TypeKind = layout.attribute(TypeKind.ATTR_NAME).orElse(null);\n-         * }<\/pre><\/blockquote>\n-         *\/\n-        public static final String ATTR_NAME = \"abi\/kind\";\n+    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, true);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":140,"deletions":662,"binary":false,"changes":802,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import java.util.Collections;\n-import java.util.HashMap;\n@@ -36,1 +34,0 @@\n-import java.util.Map;\n@@ -49,7 +46,1 @@\n-public final class FunctionDescriptor implements Constable {\n-\n-    \/**\n-     * The name of the function descriptor attribute (see {@link #attributes()} used to mark trivial functions. The\n-     * attribute value must be a boolean.\n-     *\/\n-    public static final String TRIVIAL_ATTRIBUTE_NAME = \"abi\/trivial\";\n+public sealed class FunctionDescriptor implements Constable permits FunctionDescriptor.VariadicFunction {\n@@ -58,2 +49,1 @@\n-    private final MemoryLayout[] argLayouts;\n-    private final Map<String, Constable> attributes;\n+    private final List<MemoryLayout> argLayouts;\n@@ -61,1 +51,1 @@\n-    private FunctionDescriptor(MemoryLayout resLayout, Map<String, Constable> attributes, MemoryLayout... argLayouts) {\n+    private FunctionDescriptor(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n@@ -63,1 +53,0 @@\n-        this.attributes = attributes;\n@@ -67,36 +56,0 @@\n-    \/**\n-     * Returns the attribute with the given name (if it exists).\n-     *\n-     * @param name the attribute name.\n-     * @return the attribute with the given name (if it exists).\n-     *\/\n-    public Optional<Constable> attribute(String name) {\n-        Objects.requireNonNull(name);\n-        return Optional.ofNullable(attributes.get(name));\n-    }\n-\n-    \/**\n-     * Returns a stream of the attribute names associated with this function descriptor.\n-     *\n-     * @return a stream of the attribute names associated with this function descriptor.\n-     *\/\n-    public Stream<String> attributes() {\n-        return attributes.keySet().stream();\n-    }\n-\n-    \/**\n-     * Returns a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.\n-     * If this descriptor already contains an attribute with the same name, the existing attribute value is overwritten in the returned\n-     * descriptor.\n-     *\n-     * @param name the attribute name.\n-     * @param value the attribute value.\n-     * @return a new function descriptor which features the same attributes as this descriptor, plus the newly specified attribute.\n-     *\/\n-    public FunctionDescriptor withAttribute(String name, Constable value) {\n-        Objects.requireNonNull(name);\n-        Map<String, Constable> newAttributes = new HashMap<>(attributes);\n-        newAttributes.put(name, value);\n-        return new FunctionDescriptor(resLayout, newAttributes, argLayouts);\n-    }\n-\n@@ -116,1 +69,1 @@\n-        return Arrays.asList(argLayouts);\n+        return argLayouts;\n@@ -129,1 +82,1 @@\n-        return new FunctionDescriptor(resLayout, Map.of(), argLayouts);\n+        return new FunctionDescriptor(resLayout, List.of(argLayouts));\n@@ -140,1 +93,25 @@\n-        return new FunctionDescriptor(null, Map.of(), argLayouts);\n+        return new FunctionDescriptor(null, List.of(argLayouts));\n+    }\n+\n+    \/**\n+     * Obtain a specialized variadic function descriptor, by appending given variadic layouts to this\n+     * function descriptor argument layouts. The resulting function descriptor can report the position\n+     * of the {@linkplain #firstVariadicArgumentIndex() first variadic argument}, and cannot be altered\n+     * in any way: for instance, calling {@link #withReturnLayout(MemoryLayout)} on the resulting descriptor\n+     * will throw an {@link UnsupportedOperationException}.\n+     * @param variadicLayouts the variadic argument layouts to be appended to this descriptor argument layouts.\n+     * @return a new variadic function descriptor, or this descriptor if {@code variadicLayouts.length == 0}.\n+     *\/\n+    public FunctionDescriptor asVariadic(MemoryLayout... variadicLayouts) {\n+        Objects.requireNonNull(variadicLayouts);\n+        Arrays.stream(variadicLayouts).forEach(Objects::requireNonNull);\n+        return variadicLayouts.length == 0 ? this : new VariadicFunction(this, variadicLayouts);\n+    }\n+\n+    \/**\n+     * The index of the first variadic argument layout (where defined).\n+     * @return The index of the first variadic argument layout, or {@code -1} if this is not a\n+     * {@linkplain #asVariadic(MemoryLayout...) variadic} layout.\n+     *\/\n+    public int firstVariadicArgumentIndex() {\n+        return -1;\n@@ -152,3 +129,2 @@\n-        MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);\n-        System.arraycopy(addedLayouts, 0, newLayouts, argLayouts.length, addedLayouts.length);\n-        return new FunctionDescriptor(resLayout, attributes, newLayouts);\n+        List<MemoryLayout> newLayouts = Stream.concat(argLayouts.stream(), Stream.of(addedLayouts)).toList();\n+        return new FunctionDescriptor(resLayout, newLayouts);\n@@ -164,1 +140,1 @@\n-        return new FunctionDescriptor(newReturn, attributes, argLayouts);\n+        return new FunctionDescriptor(newReturn, argLayouts);\n@@ -172,1 +148,1 @@\n-        return new FunctionDescriptor(null, attributes, argLayouts);\n+        return new FunctionDescriptor(null, argLayouts);\n@@ -190,1 +166,1 @@\n-     * object is also a function descriptor, and all of the following conditions are met:\n+     * object is also a function descriptor, and all the following conditions are met:\n@@ -204,1 +180,1 @@\n-        if (!(other instanceof FunctionDescriptor)) {\n+        if (!(other instanceof FunctionDescriptor f)) {\n@@ -207,2 +183,1 @@\n-        FunctionDescriptor f = (FunctionDescriptor) other;\n-        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts);\n+        return Objects.equals(resLayout, f.resLayout) && Objects.equals(argLayouts, f.argLayouts);\n@@ -217,1 +192,1 @@\n-        int hashCode = Arrays.hashCode(argLayouts);\n+        int hashCode = Objects.hashCode(argLayouts);\n@@ -221,0 +196,8 @@\n+    \/**\n+     * Returns an {@link Optional} containing the nominal descriptor for this\n+     * function descriptor, if one can be constructed, or an empty {@link Optional}\n+     * if one cannot be constructed.\n+     *\n+     * @return An {@link Optional} containing the resulting nominal descriptor,\n+     * or an empty {@link Optional} if one cannot be constructed.\n+     *\/\n@@ -234,0 +217,36 @@\n+\n+    static final class VariadicFunction extends FunctionDescriptor {\n+\n+        private final int firstVariadicIndex;\n+\n+        public VariadicFunction(FunctionDescriptor descriptor, MemoryLayout... argLayouts) {\n+            super(descriptor.returnLayout().orElse(null),\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toList());\n+            this.firstVariadicIndex = descriptor.argumentLayouts().size();\n+        }\n+\n+        @Override\n+        public int firstVariadicArgumentIndex() {\n+            return firstVariadicIndex;\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withAppendedArgumentLayouts(MemoryLayout... addedLayouts) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withReturnLayout(MemoryLayout newReturn) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public FunctionDescriptor withVoidReturnLayout() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public Optional<DynamicConstantDesc<FunctionDescriptor>> describeConstable() {\n+            return Optional.empty();\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":83,"deletions":64,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -35,1 +34,0 @@\n-import java.util.Map;\n@@ -43,1 +41,1 @@\n- * A group layout is used to combine together multiple <em>member layouts<\/em>. There are two ways in which member layouts\n+ * A group layout is used to combine multiple <em>member layouts<\/em>. There are two ways in which member layouts\n@@ -108,1 +106,1 @@\n-        this(kind, elements, kind.alignof(elements), Map.of());\n+        this(kind, elements, kind.alignof(elements), Optional.empty());\n@@ -111,2 +109,2 @@\n-    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Map<String, Constable> attributes) {\n-        super(kind.sizeof(elements), alignment, attributes);\n+    GroupLayout(Kind kind, List<MemoryLayout> elements, long alignment, Optional<String> name) {\n+        super(kind.sizeof(elements), alignment, name);\n@@ -163,1 +161,1 @@\n-        if (!(other instanceof GroupLayout)) {\n+        if (!(other instanceof GroupLayout g)) {\n@@ -166,1 +164,0 @@\n-        GroupLayout g = (GroupLayout)other;\n@@ -176,2 +173,2 @@\n-    GroupLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new GroupLayout(kind, elements, alignment, attributes);\n+    GroupLayout dup(long alignment, Optional<String> name) {\n+        return new GroupLayout(kind, elements, alignment, name);\n@@ -215,8 +212,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public GroupLayout withAttribute(String name, Constable value) {\n-        return (GroupLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/GroupLayout.java","additions":7,"deletions":18,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1,1455 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.access.foreign.MemorySegmentProxy;\n-import jdk.internal.vm.annotation.ForceInline;\n-\n-import java.lang.invoke.VarHandle;\n-import java.nio.ByteOrder;\n-import java.util.Objects;\n-\n-\/**\n- * This class defines ready-made static accessors which can be used to dereference memory segments in many ways.\n- * <p>\n- * The most primitive accessors (see {@link #getIntAtOffset(MemorySegment, long, ByteOrder)}) take a segment, an offset\n- * (expressed in bytes) and a byte order. The final address at which the dereference will occur will be computed by offsetting\n- * the base address by the specified offset, as if by calling {@link MemoryAddress#addOffset(long)} on the specified base address.\n- * <p>\n- * In cases where no offset is required, overloads are provided (see {@link #getInt(MemorySegment, ByteOrder)}) so that\n- * clients can omit the offset coordinate.\n- * <p>\n- * To help dereferencing in array-like use cases (e.g. where the layout of a given memory segment is a sequence\n- * layout of given size an element count), higher-level overloads are also provided (see {@link #getIntAtIndex(MemorySegment, long, ByteOrder)}),\n- * which take a segment and a <em>logical<\/em> element index. The formula to obtain the byte offset {@code O} from an\n- * index {@code I} is given by {@code O = I * S} where {@code S} is the size (expressed in bytes) of the element to\n- * be dereferenced.\n- * <p>\n- * In cases where native byte order is preferred, overloads are provided (see {@link #getIntAtOffset(MemorySegment, long)})\n- * so that clients can omit the byte order parameter.\n- *\n- * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n- * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n- *\/\n-public final class MemoryAccess {\n-\n-    private MemoryAccess() {\n-        \/\/ just the one\n-    }\n-\n-    private static final VarHandle byte_handle = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n-    private static final VarHandle char_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, char.class);\n-    private static final VarHandle short_LE_handle = unalignedHandle(MemoryLayouts.BITS_16_LE, short.class);\n-    private static final VarHandle int_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, int.class);\n-    private static final VarHandle float_LE_handle = unalignedHandle(MemoryLayouts.BITS_32_LE, float.class);\n-    private static final VarHandle long_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, long.class);\n-    private static final VarHandle double_LE_handle = unalignedHandle(MemoryLayouts.BITS_64_LE, double.class);\n-    private static final VarHandle char_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, char.class);\n-    private static final VarHandle short_BE_handle = unalignedHandle(MemoryLayouts.BITS_16_BE, short.class);\n-    private static final VarHandle int_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, int.class);\n-    private static final VarHandle float_BE_handle = unalignedHandle(MemoryLayouts.BITS_32_BE, float.class);\n-    private static final VarHandle long_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, long.class);\n-    private static final VarHandle double_BE_handle = unalignedHandle(MemoryLayouts.BITS_64_BE, double.class);\n-    private static final VarHandle address_handle;\n-\n-    static {\n-        Class<?> carrier = switch ((int) MemoryLayouts.ADDRESS.byteSize()) {\n-            case 4 -> int.class;\n-            case 8 -> long.class;\n-            default -> throw new ExceptionInInitializerError(\"Unsupported pointer size: \" + MemoryLayouts.ADDRESS.byteSize());\n-        };\n-        address_handle = MemoryHandles.asAddressVarHandle(unalignedHandle(MemoryLayouts.ADDRESS, carrier));\n-    }\n-\n-    private static VarHandle unalignedHandle(ValueLayout elementLayout, Class<?> carrier) {\n-        return MemoryHandles.varHandle(carrier, 1, elementLayout.order());\n-    }\n-\n-    \/\/ Note: all the accessor methods defined below take advantage of argument type profiling\n-    \/\/ (see src\/hotspot\/share\/oops\/methodData.cpp) which greatly enhances performance when the same accessor\n-    \/\/ method is used repeatedly with different segment kinds (e.g. on-heap vs. off-heap).\n-\n-    \/**\n-     * Reads a byte from given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByteAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (byte)byte_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment and offset.\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByteAtOffset(MemorySegment segment, long offset, byte value) {\n-        Objects.requireNonNull(segment);\n-        byte_handle.set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtOffset(MemorySegment segment, long offset) {\n-        return getCharAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtOffset(MemorySegment segment, long offset, char value) {\n-        setCharAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtOffset(MemorySegment segment, long offset) {\n-        return getShortAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtOffset(MemorySegment segment, long offset, short value) {\n-        setShortAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtOffset(MemorySegment segment, long offset) {\n-        return getIntAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtOffset(MemorySegment segment, long offset, int value) {\n-        setIntAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtOffset(MemorySegment segment, long offset) {\n-        return getFloatAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, float value) {\n-        setFloatAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtOffset(MemorySegment segment, long offset) {\n-        return getLongAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtOffset(MemorySegment segment, long offset, long value) {\n-        setLongAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset) {\n-        return getDoubleAtOffset(segment, offset, ByteOrder.nativeOrder());\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, double value) {\n-        setDoubleAtOffset(segment, offset, ByteOrder.nativeOrder(), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    MemoryAddress value = (MemoryAddress)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtOffset(MemorySegment segment, long offset) {\n-        Objects.requireNonNull(segment);\n-        return (MemoryAddress)address_handle.get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and offset, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent (e.g. on a 64-bit platform) to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.asAddressHandle(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()));\n-    handle.set(segment, offset, value.address());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtOffset(MemorySegment segment, long offset, Addressable value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(value);\n-        address_handle.set(segment, offset, value.address());\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n-    char value = (char)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (char)((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(char.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtOffset(MemorySegment segment, long offset, ByteOrder order, char value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? char_BE_handle : char_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n-    short value = (short)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (short)((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(short.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtOffset(MemorySegment segment, long offset, ByteOrder order, short value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? short_BE_handle : short_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n-    int value = (int)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (int)((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(int.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtOffset(MemorySegment segment, long offset, ByteOrder order, int value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? int_BE_handle : int_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n-    float value = (float)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (float)((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(float.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtOffset(MemorySegment segment, long offset, ByteOrder order, float value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? float_BE_handle : float_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n-    long value = (long)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (long)((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(long.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtOffset(MemorySegment segment, long offset, ByteOrder order, long value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? long_BE_handle : long_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n-    double value = (double)handle.get(segment, offset);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        return (double)((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).get(segment, offset);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and offset with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    VarHandle handle = MemoryHandles.varHandle(double.class, 1, order);\n-    handle.set(segment, offset, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param offset offset in bytes (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(offset)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtOffset(MemorySegment segment, long offset, ByteOrder order, double value) {\n-        Objects.requireNonNull(segment);\n-        Objects.requireNonNull(order);\n-        ((order == ByteOrder.BIG_ENDIAN) ? double_BE_handle : double_LE_handle).set(segment, offset, value);\n-    }\n-\n-    \/**\n-     * Reads a byte from given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    byte value = getByteAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     *\n-     * @param segment the segment to be dereferenced.\n-     * @return a byte value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static byte getByte(MemorySegment segment) {\n-        return getByteAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a byte at given segment.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setByteAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the byte value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setByte(MemorySegment segment, byte value) {\n-        setByteAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment) {\n-        return getCharAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, char value) {\n-        setCharAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment) {\n-        return getShortAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, short value) {\n-        setShortAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment) {\n-        return getIntAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, int value) {\n-        setIntAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment) {\n-        return getFloatAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, float value) {\n-        setFloatAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment) {\n-        return getLongAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, long value) {\n-        setLongAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment) {\n-        return getDoubleAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, double value) {\n-        setDoubleAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    MemoryAddress value = getAddressAtOffset(segment, 0L);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @return a memory address read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddress(MemorySegment segment) {\n-        return getAddressAtOffset(segment, 0L);\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, 0L, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddress(MemorySegment segment, Addressable value) {\n-        setAddressAtOffset(segment, 0L, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static char getChar(MemorySegment segment, ByteOrder order) {\n-        return getCharAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setChar(MemorySegment segment, ByteOrder order, char value) {\n-        setCharAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static short getShort(MemorySegment segment, ByteOrder order) {\n-        return getShortAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShort(MemorySegment segment, ByteOrder order, short value) {\n-        setShortAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static int getInt(MemorySegment segment, ByteOrder order) {\n-        return getIntAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setInt(MemorySegment segment, ByteOrder order, int value) {\n-        setIntAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static float getFloat(MemorySegment segment, ByteOrder order) {\n-        return getFloatAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloat(MemorySegment segment, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    long value = getLongAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static long getLong(MemorySegment segment, ByteOrder order) {\n-        return getLongAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLong(MemorySegment segment, ByteOrder order, long value) {\n-        setLongAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    double value = getDoubleAtOffset(segment, 0L, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment}.\n-     *\/\n-    @ForceInline\n-    public static double getDouble(MemorySegment segment, ByteOrder order) {\n-        return getDoubleAtOffset(segment, 0L, order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 0L, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDouble(MemorySegment segment, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, 0L, order, value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index) {\n-        return getCharAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index) {\n-        return getShortAtOffset(segment, scale(segment, index, 2));\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index) {\n-        return getIntAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4));\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index) {\n-        return getLongAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8));\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), value);\n-    }\n-\n-    \/**\n-     * Reads a memory address from given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize());\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @return a memory address read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static MemoryAddress getAddressAtIndex(MemorySegment segment, long index) {\n-        return getAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()));\n-    }\n-\n-    \/**\n-     * Writes a memory address at given segment and element index, with byte order set to {@link ByteOrder#nativeOrder()}.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setAddressAtOffset(segment, index * MemoryLayouts.ADDRESS.byteSize(), value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param value the memory address to be written (expressed as an {@link Addressable} instance).\n-     *\/\n-    @ForceInline\n-    public static void setAddressAtIndex(MemorySegment segment, long index, Addressable value) {\n-        setAddressAtOffset(segment, scale(segment, index, (int)MemoryLayouts.ADDRESS.byteSize()), value);\n-    }\n-\n-    \/**\n-     * Reads a char from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    char value = getCharAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a char value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static char getCharAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getCharAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a char at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setCharAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the char value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setCharAtIndex(MemorySegment segment, long index, ByteOrder order, char value) {\n-        setCharAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads a short from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    short value = getShortAtOffset(segment, 2 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @return a short value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static short getShortAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getShortAtOffset(segment, scale(segment, index, 2), order);\n-    }\n-\n-    \/**\n-     * Writes a short at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setShortAtOffset(segment, 2 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 2)}.\n-     * @param order the specified byte order.\n-     * @param value the short value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setShortAtIndex(MemorySegment segment, long index, ByteOrder order, short value) {\n-        setShortAtOffset(segment, scale(segment, index, 2), order, value);\n-    }\n-\n-    \/**\n-     * Reads an int from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    int value = getIntAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return an int value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static int getIntAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getIntAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes an int at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setIntAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the int value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setIntAtIndex(MemorySegment segment, long index, ByteOrder order, int value) {\n-        setIntAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a float from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    float value = getFloatAtOffset(segment, 4 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @return a float value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static float getFloatAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getFloatAtOffset(segment, scale(segment, index, 4), order);\n-    }\n-\n-    \/**\n-     * Writes a float at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setFloatAtOffset(segment, 4 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 4)}.\n-     * @param order the specified byte order.\n-     * @param value the float value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setFloatAtIndex(MemorySegment segment, long index, ByteOrder order, float value) {\n-        setFloatAtOffset(segment, scale(segment, index, 4), order, value);\n-    }\n-\n-    \/**\n-     * Reads a long from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getLongAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a long value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static long getLongAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getLongAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a long at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setLongAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the long value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setLongAtIndex(MemorySegment segment, long index, ByteOrder order, long value) {\n-        setLongAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    \/**\n-     * Reads a double from given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    return getDoubleAtOffset(segment, 8 * index, order);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @return a double value read from {@code segment} at the element index specified by {@code index}.\n-     *\/\n-    @ForceInline\n-    public static double getDoubleAtIndex(MemorySegment segment, long index, ByteOrder order) {\n-        return getDoubleAtOffset(segment, scale(segment, index, 8), order);\n-    }\n-\n-    \/**\n-     * Writes a double at given segment and element index, with given byte order.\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    setDoubleAtOffset(segment, 8 * index, order, value);\n-     * }<\/pre><\/blockquote>\n-     * @param segment the segment to be dereferenced.\n-     * @param index element index (relative to {@code segment}). The final address of this read operation can be expressed as {@code segment.address().addOffset(index * 8)}.\n-     * @param order the specified byte order.\n-     * @param value the double value to be written.\n-     *\/\n-    @ForceInline\n-    public static void setDoubleAtIndex(MemorySegment segment, long index, ByteOrder order, double value) {\n-        setDoubleAtOffset(segment, scale(segment, index, 8), order, value);\n-    }\n-\n-    @ForceInline\n-    private static long scale(MemorySegment address, long index, int size) {\n-        return MemorySegmentProxy.multiplyOffsets(index, size, (MemorySegmentProxy)address);\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAccess.java","additions":0,"deletions":1455,"binary":false,"changes":1455,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.ref.CleanerFactory;\n@@ -33,1 +32,1 @@\n-import java.lang.ref.Cleaner;\n+import java.nio.ByteOrder;\n@@ -36,14 +35,29 @@\n- * A memory address models a reference into a memory location. Memory addresses are typically obtained using the\n- * {@link MemorySegment#address()} method, and can refer to either off-heap or on-heap memory. Off-heap memory\n- * addresses are referred to as <em>native<\/em> memory addresses (see {@link #isNative()}). Native memory addresses\n- * allow clients to obtain a raw memory address (expressed as a long value) which can then be used e.g. when interacting\n- * with native code.\n- * <p>\n- * Given an address, it is possible to compute its offset relative to a given segment, which can be useful\n- * when performing memory dereference operations using a memory access var handle (see {@link MemoryHandles}).\n- * <p>\n- * A memory address is associated with a {@linkplain ResourceScope resource scope}; the resource scope determines the\n- * lifecycle of the memory address, and whether the address can be used from multiple threads. Memory addresses\n- * obtained from {@linkplain #ofLong(long) numeric values}, or from native code, are associated with the\n- * {@linkplain ResourceScope#globalScope() global resource scope}. Memory addresses obtained from segments\n- * are associated with the same scope as the segment from which they have been obtained.\n+ * A memory address models a reference into a memory location. Memory addresses are typically obtained in three ways:\n+ * <ul>\n+ *     <li>By calling {@link Addressable#address()} on an instance of type {@link Addressable} (e.g. a memory segment);<\/li>\n+ *     <li>By invoking a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle} which returns a pointer;<\/li>\n+ *     <li>By reading an address from memory, e.g. via {@link MemorySegment#get(ValueLayout.OfAddress, long)}.<\/li>\n+ * <\/ul>\n+ * A memory address is backed by a raw machine pointer, expressed as a {@linkplain #toRawLongValue() long value}.\n+ *\n+ * <h2>Dereference<\/h2>\n+ *\n+ * A memory address can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * <blockquote><pre>{@code\n+MemoryAddress address = ...\n+int value = address.get(ValueLayout.JAVA_INT, 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * can be expressed as follows:\n+ * <blockquote><pre>{@code\n+MemoryAddress address = ...\n+int value = address.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * All the dereference methods in this class are <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>: since\n+ * a memory address does not feature temporal nor spatial bounds, the runtime has no way to check the correctness\n+ * of the memory dereference operation.\n@@ -66,4 +80,5 @@\n-    @Override\n-    default MemoryAddress address() {\n-        return this;\n-    }\n+    \/**\n+     * Returns the raw long value associated with this memory address.\n+     * @return The raw long value associated with this memory address.\n+     *\/\n+    long toRawLongValue();\n@@ -79,2 +94,19 @@\n-     * Returns the resource scope associated with this memory address.\n-     * @return the resource scope associated with this memory address.\n+     * Reads a UTF-8 encoded, null-terminated string from this address and offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a Java string constructed from the bytes read from the given starting address ({@code toRowLongValue() + offset})\n+     * up to (but not including) the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -82,1 +114,2 @@\n-    ResourceScope scope();\n+    @CallerSensitive\n+    String getUtf8String(long offset);\n@@ -85,6 +118,1 @@\n-     * Returns the offset of this memory address into the given segment. More specifically, if both the segment's\n-     * base address and this address are native addresses, the result is computed as\n-     * {@code this.toRawLongValue() - segment.address().toRawLongValue()}. Otherwise, if both addresses in the form\n-     * {@code (B, O1)}, {@code (B, O2)}, where {@code B} is the same base heap object and {@code O1}, {@code O2}\n-     * are byte offsets (relative to the base object) associated with this address and the segment's base address,\n-     * the result is computed as {@code O1 - O2}.\n+     * Writes the given string to this address at given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n@@ -92,9 +120,9 @@\n-     * If the segment's base address and this address are both heap addresses, but with different base objects, the result is undefined\n-     * and an exception is thrown. Similarly, if the segment's base address is an heap address (resp. off-heap) and\n-     * this address is an off-heap (resp. heap) address, the result is undefined and an exception is thrown.\n-     * Otherwise, the result is a byte offset {@code SO}. If this address falls within the\n-     * spatial bounds of the given segment, then {@code 0 <= SO < segment.byteSize()}; otherwise, {@code SO < 0 || SO > segment.byteSize()}.\n-     * @return the offset of this memory address into the given segment.\n-     * @param segment the segment relative to which this address offset should be computed\n-     * @throws IllegalArgumentException if {@code segment} is not compatible with this address; this can happen, for instance,\n-     * when {@code segment} models an heap memory region, while this address is a {@linkplain #isNative() native} address.\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param str the Java string to be written at this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -102,1 +130,35 @@\n-    long segmentOffset(MemorySegment segment);\n+    @CallerSensitive\n+    void setUtf8String(long offset, String str);\n+\n+    \/**\n+     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n+     * object is also an address, and it refers to the same memory location as this address.\n+     *\n+     * @param that the object to be compared for equality with this address.\n+     * @return {@code true} if the specified object is equal to this address.\n+     *\/\n+    @Override\n+    boolean equals(Object that);\n+\n+    \/**\n+     * Returns the hash code value for this address.\n+     * @return the hash code value for this address.\n+     *\/\n+    @Override\n+    int hashCode();\n+\n+    \/**\n+     * The native memory address instance modelling the {@code NULL} address.\n+     *\/\n+    MemoryAddress NULL = new MemoryAddressImpl(0L);\n+\n+    \/**\n+     * Obtain a native memory address instance from given long address.\n+     * @param value the long address.\n+     * @return the new memory address instance.\n+     *\/\n+    static MemoryAddress ofLong(long value) {\n+        return value == 0 ?\n+                NULL :\n+                new MemoryAddressImpl(value);\n+    }\n@@ -105,6 +167,1 @@\n-     Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n-     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n-     * provided resource scope.\n+     * Reads a byte from this address and offset with given layout.\n@@ -112,3 +169,17 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a byte value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    byte get(ValueLayout.OfByte layout, long offset);\n+\n+    \/**\n+     * Writes a byte to this address instance and offset with given layout.\n@@ -116,4 +187,17 @@\n-     * This method is equivalent to the following code:\n-     * <pre>{@code\n-    asSegment(byteSize, null, scope);\n-     * }<\/pre>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfByte layout, long offset, byte value);\n+\n+    \/**\n+     * Reads a boolean from this address and offset with given layout.\n@@ -126,8 +210,3 @@\n-     * @param bytesSize the desired size.\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n-     * have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a boolean value read from this address.\n@@ -139,1 +218,1 @@\n-    MemorySegment asSegment(long bytesSize, ResourceScope scope);\n+    boolean get(ValueLayout.OfBoolean layout, long offset);\n@@ -142,5 +221,1 @@\n-     * Returns a new native memory segment with given size and resource scope (replacing the scope already associated\n-     * with this address), and whose base address is this address. This method can be useful when interacting with custom\n-     * native memory sources (e.g. custom allocators), where an address to some\n-     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n-     * The returned segment is associated with the provided resource scope.\n+     * Writes a boolean to this address instance and offset with given layout.\n@@ -148,3 +223,17 @@\n-     * Clients should ensure that the address and bounds refers to a valid region of memory that is accessible for reading and,\n-     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n-     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfBoolean layout, long offset, boolean value);\n+\n+    \/**\n+     * Reads a char from this address and offset with given layout.\n@@ -152,2 +241,17 @@\n-     * Calling {@link ResourceScope#close()} on the scope associated with the returned segment will result in calling\n-     * the provided cleanup action (if any).\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a char value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    char get(ValueLayout.OfChar layout, long offset);\n+\n+    \/**\n+     * Writes a char to this address instance and offset with given layout.\n@@ -160,9 +264,3 @@\n-     * @param bytesSize the desired size.\n-     * @param cleanupAction the cleanup action; can be {@code null}.\n-     * @param scope the native segment scope.\n-     * @return a new native memory segment with given base address, size and scope.\n-     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n-     * @throws IllegalStateException if either the scope associated with this address or the provided scope\n-     * have been already closed, or if access occurs from a thread other than the thread owning either\n-     * scopes.\n-     * @throws UnsupportedOperationException if this address is not a {@linkplain #isNative() native} address.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the char value to be written.\n@@ -174,1 +272,1 @@\n-    MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope);\n+    void set(ValueLayout.OfChar layout, long offset, char value);\n@@ -177,2 +275,13 @@\n-     * Is this an off-heap memory address?\n-     * @return true, if this is an off-heap memory address.\n+     * Reads a short from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a short value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -180,1 +289,2 @@\n-    boolean isNative();\n+    @CallerSensitive\n+    short get(ValueLayout.OfShort layout, long offset);\n@@ -183,5 +293,13 @@\n-     * Returns the raw long value associated with this native memory address.\n-     * @return The raw long value associated with this native memory address.\n-     * @throws UnsupportedOperationException if this memory address is not a {@linkplain #isNative() native} address.\n-     * @throws IllegalStateException if the scope associated with this segment has been already closed,\n-     * or if access occurs from a thread other than the thread owning either segment.\n+     * Writes a short to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the short value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -189,1 +307,2 @@\n-    long toRawLongValue();\n+    @CallerSensitive\n+    void set(ValueLayout.OfShort layout, long offset, short value);\n@@ -192,2 +311,6 @@\n-     * Compares the specified object with this address for equality. Returns {@code true} if and only if the specified\n-     * object is also an address, and it refers to the same memory location as this address.\n+     * Reads an int from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -195,4 +318,17 @@\n-     * @apiNote two addresses might be considered equal despite their associated resource scopes differ. This\n-     * can happen, for instance, if the same memory address is used to create memory segments with different\n-     * scopes (using {@link #asSegment(long, ResourceScope)}), and the base address of the resulting segments is\n-     * then compared.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return an int value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    int get(ValueLayout.OfInt layout, long offset);\n+\n+    \/**\n+     * Writes an int to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n@@ -200,2 +336,6 @@\n-     * @param that the object to be compared for equality with this address.\n-     * @return {@code true} if the specified object is equal to this address.\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the int value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -203,2 +343,2 @@\n-    @Override\n-    boolean equals(Object that);\n+    @CallerSensitive\n+    void set(ValueLayout.OfInt layout, long offset, int value);\n@@ -207,2 +347,13 @@\n-     * Returns the hash code value for this address.\n-     * @return the hash code value for this address.\n+     * Reads a float from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a float value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -210,2 +361,2 @@\n-    @Override\n-    int hashCode();\n+    @CallerSensitive\n+    float get(ValueLayout.OfFloat layout, long offset);\n@@ -214,2 +365,13 @@\n-     * The native memory address instance modelling the {@code NULL} address, associated\n-     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n+     * Writes a float to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the float value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -217,1 +379,2 @@\n-    MemoryAddress NULL = new MemoryAddressImpl(null, 0L);\n+    @CallerSensitive\n+    void set(ValueLayout.OfFloat layout, long offset, float value);\n@@ -220,4 +383,13 @@\n-     * Obtain a native memory address instance from given long address. The returned address is associated\n-     * with the {@linkplain ResourceScope#globalScope() global} resource scope.\n-     * @param value the long address.\n-     * @return the new memory address instance.\n+     * Reads a long from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a long value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n@@ -225,5 +397,344 @@\n-    static MemoryAddress ofLong(long value) {\n-        return value == 0 ?\n-                NULL :\n-                new MemoryAddressImpl(null, value);\n-    }\n+    @CallerSensitive\n+    long get(ValueLayout.OfLong layout, long offset);\n+\n+    \/**\n+     * Writes a long to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the long value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfLong layout, long offset, long value);\n+\n+    \/**\n+     * Reads a double from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return a double value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    double get(ValueLayout.OfDouble layout, long offset);\n+\n+    \/**\n+     * Writes a double to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the double value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfDouble layout, long offset, double value);\n+\n+    \/**\n+     * Reads an address from this address and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @return an address value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemoryAddress get(ValueLayout.OfAddress layout, long offset);\n+\n+    \/**\n+     * Writes an address to this address instance and offset with given layout.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + offset}.\n+     * @param value the address value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void set(ValueLayout.OfAddress layout, long offset, Addressable value);\n+\n+    \/**\n+     * Reads a char from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a char value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    char getAtIndex(ValueLayout.OfChar layout, long index);\n+\n+    \/**\n+     * Writes a char to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the char value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfChar layout, long index, char value);\n+\n+    \/**\n+     * Reads a short from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a short value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    short getAtIndex(ValueLayout.OfShort layout, long index);\n+\n+    \/**\n+     * Writes a short to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfShort layout, long index, short value);\n+\n+    \/**\n+     * Reads an int from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an int value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    int getAtIndex(ValueLayout.OfInt layout, long index);\n+\n+    \/**\n+     * Writes an int to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the int value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfInt layout, long index, int value);\n+\n+    \/**\n+     * Reads a float from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a float value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    float getAtIndex(ValueLayout.OfFloat layout, long index);\n+\n+    \/**\n+     * Writes a float to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the float value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfFloat layout, long index, float value);\n+\n+    \/**\n+     * Reads a long from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a long value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    long getAtIndex(ValueLayout.OfLong layout, long index);\n+\n+    \/**\n+     * Writes a long to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the long value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfLong layout, long index, long value);\n+\n+    \/**\n+     * Reads a double from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a double value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    double getAtIndex(ValueLayout.OfDouble layout, long index);\n+\n+    \/**\n+     * Writes a double to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the double value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfDouble layout, long index, double value);\n+\n+    \/**\n+     * Reads an address from this address and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index in bytes (relative to this address). The final address of this read operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an address value read from this address.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index);\n+\n+    \/**\n+     * Writes an address to this address instance and index, scaled by given layout size.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index in bytes (relative to this address). The final address of this write operation can be expressed as {@code toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the address value to be written.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryAddress.java","additions":627,"deletions":116,"binary":false,"changes":743,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.internal.foreign.Utils;\n@@ -37,1 +36,0 @@\n-import java.nio.ByteOrder;\n@@ -43,5 +41,4 @@\n- * To obtain a memory access var handle, clients must start from one of the <em>leaf<\/em> methods\n- * (see {@link MemoryHandles#varHandle(Class, ByteOrder)},\n- * {@link MemoryHandles#varHandle(Class, long, ByteOrder)}). This determines the variable type\n- * (all primitive types but {@code void} and {@code boolean} are supported), as well as the alignment constraint and the\n- * byte order associated with a memory access var handle. The resulting memory access var handle can then be combined in various ways\n+ * Memory access var handles can be obtained using {@link MemoryHandles#varHandle(ValueLayout)}. The provided value layout\n+ * determines the type, as well as the alignment constraint and the byte order associated with the memory access var handle.\n+ * <p>\n+ * The resulting memory access var handle can then be combined in various ways\n@@ -56,1 +53,1 @@\n-        MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN).withName(\"value\")\n+        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -61,1 +58,1 @@\n-VarHandle handle = MemoryHandles.varHandle(int.class, ByteOrder.BIG_ENDIAN); \/\/(MemorySegment, long) -> int\n+VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)); \/\/(MemorySegment, long) -> int\n@@ -80,1 +77,1 @@\n- *     {@code float} or {@code double}.\n+ *     {@code float}, {@code double} or {@link MemoryAddress}.\n@@ -83,1 +80,1 @@\n- * <li>numeric atomic update access modes for {@code int} and {@code long}.\n+ * <li>numeric atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n@@ -86,1 +83,1 @@\n- * <li>bitwise atomic update access modes for {@code int} and {@code long}.\n+ * <li>bitwise atomic update access modes for {@code int}, {@code long} and {@link MemoryAddress}.\n@@ -91,1 +88,1 @@\n- * If {@code T} is {@code float} or {@code double} then atomic\n+ * If {@code T} is {@code float}, {@code double} or {@link MemoryAddress} then atomic\n@@ -93,2 +90,2 @@\n- * (see {@link Float#floatToRawIntBits} and\n- * {@link Double#doubleToRawLongBits}, respectively).\n+ * (see {@link Float#floatToRawIntBits},\n+ * {@link Double#doubleToRawLongBits} and {@link MemoryAddress#toRawLongValue()}, respectively).\n@@ -112,2 +109,0 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n-    private static final MethodHandle ADDRESS_TO_LONG;\n@@ -127,4 +122,0 @@\n-            LONG_TO_ADDRESS = MethodHandles.lookup().findStatic(MemoryHandles.class, \"longToAddress\",\n-                    MethodType.methodType(MemoryAddress.class, long.class));\n-            ADDRESS_TO_LONG = MethodHandles.lookup().findStatic(MemoryHandles.class, \"addressToLong\",\n-                    MethodType.methodType(long.class, MemoryAddress.class));\n@@ -157,28 +148,4 @@\n-     * Creates a memory access var handle with the given carrier type and byte order.\n-     *\n-     * The returned var handle's type is {@code carrier} and the list of coordinate types is\n-     * {@code (MemorySegment, long)}, where the {@code long} coordinate type corresponds to byte offset into\n-     * a given memory segment. The returned var handle accesses bytes at an offset in a given\n-     * memory segment, composing bytes to or from a value of the type {@code carrier} according to the given endianness;\n-     * the alignment constraint (in bytes) for the resulting memory access var handle is the same as the size (in bytes) of the\n-     * carrier type {@code carrier}.\n-     *\n-     * @apiNote the resulting var handle features certain <a href=\"#memaccess-mode\">access mode restrictions<\/a>,\n-     * which are common to all memory access var handles.\n-     *\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, and {@code double}.\n-     * @param byteOrder the required byte order.\n-     * @return the new memory access var handle.\n-     * @throws IllegalArgumentException when an illegal carrier type is used\n-     *\/\n-    public static VarHandle varHandle(Class<?> carrier, ByteOrder byteOrder) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(byteOrder);\n-        return varHandle(carrier,\n-                carrierSize(carrier),\n-                byteOrder);\n-    }\n-\n-    \/**\n-     * Creates a memory access var handle with the given carrier type, alignment constraint, and byte order.\n+     * Creates a memory access var handle from given value layout. The provided layout will specify the\n+     * {@linkplain ValueLayout#carrier() carrier type}, the {@linkplain ValueLayout#byteSize() the byte size},\n+     * the {@linkplain ValueLayout#byteAlignment() byte alignment} and the {@linkplain ValueLayout#order() byte order}\n+     * associated to the returned var handle.\n@@ -195,4 +162,1 @@\n-     * @param carrier the carrier type. Valid carriers are {@code byte}, {@code short}, {@code char}, {@code int},\n-     * {@code float}, {@code long}, and {@code double}.\n-     * @param alignmentBytes the alignment constraint (in bytes). Must be a power of two.\n-     * @param byteOrder the required byte order.\n+     * @param layout the value layout for which a memory access handle is to be obtained.\n@@ -202,43 +166,3 @@\n-    public static VarHandle varHandle(Class<?> carrier, long alignmentBytes, ByteOrder byteOrder) {\n-        Objects.requireNonNull(carrier);\n-        Objects.requireNonNull(byteOrder);\n-        checkCarrier(carrier);\n-\n-        if (alignmentBytes <= 0\n-                || (alignmentBytes & (alignmentBytes - 1)) != 0) { \/\/ is power of 2?\n-            throw new IllegalArgumentException(\"Bad alignment: \" + alignmentBytes);\n-        }\n-\n-        return Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, false, alignmentBytes - 1, byteOrder));\n-    }\n-\n-    \/**\n-     * Adapt an existing var handle into a new var handle whose carrier type is {@link MemorySegment}.\n-     * That is, when calling {@link VarHandle#get(Object...)} on the returned var handle,\n-     * the read numeric value will be turned into a memory address (as if by calling {@link MemoryAddress#ofLong(long)});\n-     * similarly, when calling {@link VarHandle#set(Object...)}, the memory address to be set will be converted\n-     * into a numeric value, and then written into memory. The amount of bytes read (resp. written) from (resp. to)\n-     * memory depends on the carrier of the original memory access var handle.\n-     *\n-     * @param target the memory access var handle to be adapted\n-     * @return the adapted var handle.\n-     * @throws IllegalArgumentException if the carrier type of {@code varHandle} is either {@code boolean},\n-     * {@code float}, or {@code double}, or is not a primitive type.\n-     *\/\n-    public static VarHandle asAddressVarHandle(VarHandle target) {\n-        Objects.requireNonNull(target);\n-        Class<?> carrier = target.varType();\n-        if (!carrier.isPrimitive() || carrier == boolean.class ||\n-                carrier == float.class || carrier == double.class) {\n-            throw new IllegalArgumentException(\"Unsupported carrier type: \" + carrier.getName());\n-        }\n-\n-        if (carrier != long.class) {\n-            \/\/ slow-path, we need to adapt\n-            return filterValue(target,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(carrier, MemoryAddress.class)),\n-                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, carrier)));\n-        } else {\n-            \/\/ fast-path\n-            return filterValue(target, ADDRESS_TO_LONG, LONG_TO_ADDRESS);\n-        }\n+    public static VarHandle varHandle(ValueLayout layout) {\n+        Objects.requireNonNull(layout);\n+        return layout.accessHandle();\n@@ -258,1 +182,1 @@\n-    VarHandle SHORT_VH = MemoryLayouts.JAVA_SHORT.varHandle(short.class);\n+    VarHandle SHORT_VH = ValueLayout.JAVA_SHORT.varHandle();\n@@ -279,1 +203,1 @@\n-     * java.lang.invoke.VarHandle.AccessMode}, and the same atomic access\n+     * java.lang.invoke.VarHandle.AccessMode}), and the same atomic access\n@@ -287,1 +211,1 @@\n-     * adaptedType} is not one of {@code int}, or {@code long}; if the bitwidth\n+     * adaptedType} is not one of {@code int}, or {@code long}; if the bit width\n@@ -327,1 +251,1 @@\n-     * For the boxing and unboxing filters to be well formed, their types must be of the form {@code (A... , S) -> T} and\n+     * For the boxing and unboxing filters to be well-formed, their types must be of the form {@code (A... , S) -> T} and\n@@ -332,1 +256,4 @@\n-     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode} and\n+     * If the boxing and unboxing filters throw any checked exceptions when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n+     * The resulting var handle will feature the same access modes (see {@link java.lang.invoke.VarHandle.AccessMode}) and\n@@ -341,1 +268,1 @@\n-     * or if either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n+     * or if it's determined that either {@code filterFromTarget} or {@code filterToTarget} throws any checked exceptions.\n@@ -356,1 +283,1 @@\n-     * For the coordinate filters to be well formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n+     * For the coordinate filters to be well-formed, their types must be of the form {@code S1 -> T1, S2 -> T1 ... Sn -> Tn},\n@@ -359,0 +286,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -371,1 +301,1 @@\n-     * or if any of the filters throws any checked exceptions.\n+     * or if it's determined that any of the filters throws any checked exceptions.\n@@ -385,1 +315,1 @@\n-     * For the bound coordinates to be well formed, their types must be {@code T1, T2 ... Tn },\n+     * For the bound coordinates to be well-formed, their types must be {@code T1, T2 ... Tn },\n@@ -412,1 +342,1 @@\n-     * {@code newCoordinates.size()}, and call {@code #O} the number\n+     * {@code newCoordinates.size()}), and call {@code #O} the number\n@@ -447,1 +377,1 @@\n-     * Adapts a target var handle handle by pre-processing\n+     * Adapts a target var handle by pre-processing\n@@ -467,0 +397,3 @@\n+     * If any of the filters throws a checked exception when invoked, the resulting var handle will\n+     * throw an {@link IllegalStateException}.\n+     * <p>\n@@ -479,1 +412,1 @@\n-     * or if {@code filter} throws any checked exceptions.\n+     * or if it's determined that {@code filter} throws any checked exceptions.\n@@ -508,18 +441,0 @@\n-    private static void checkAddressFirstCoordinate(VarHandle handle) {\n-        if (handle.coordinateTypes().size() < 1 ||\n-                handle.coordinateTypes().get(0) != MemorySegment.class) {\n-            throw new IllegalArgumentException(\"Expected var handle with leading coordinate of type MemorySegment\");\n-        }\n-    }\n-\n-    private static void checkCarrier(Class<?> carrier) {\n-        if (!carrier.isPrimitive() || carrier == void.class || carrier == boolean.class) {\n-            throw new IllegalArgumentException(\"Illegal carrier: \" + carrier.getSimpleName());\n-        }\n-    }\n-\n-    private static long carrierSize(Class<?> carrier) {\n-        long bitsAlignment = Math.max(8, Wrapper.forPrimitiveType(carrier).bitWidth());\n-        return Utils.bitsToBytesOrThrow(bitsAlignment, IllegalStateException::new);\n-    }\n-\n@@ -544,8 +459,0 @@\n-\n-    private static MemoryAddress longToAddress(long value) {\n-        return MemoryAddress.ofLong(value);\n-    }\n-\n-    private static long addressToLong(MemoryAddress value) {\n-        return value.toRawLongValue();\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryHandles.java","additions":41,"deletions":134,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * A memory layout can be used to describe the contents of a memory segment in a <em>language neutral<\/em> fashion.\n+ * A memory layout can be used to describe the contents of a memory segment.\n@@ -53,1 +53,1 @@\n- * Some common value layout constants are defined in the {@link MemoryLayouts} class.\n+ * Some common value layout constants are defined in the {@link ValueLayout} class.\n@@ -73,1 +73,1 @@\n-        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        ValueLayout.JAVA_BYTE.withName(\"kind\"),\n@@ -75,1 +75,1 @@\n-        MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"value\")\n+        ValueLayout.JAVA_INT.withName(\"value\")\n@@ -125,5 +125,5 @@\n- * Layout paths are for example useful in order to obtain offsets of arbitrarily nested layouts inside another layout\n- * (see {@link MemoryLayout#bitOffset(PathElement...)}), to quickly obtain a memory access handle corresponding to the selected\n- * layout (see {@link MemoryLayout#varHandle(Class, PathElement...)}), to select an arbitrarily nested layout inside\n- * another layout (see {@link MemoryLayout#select(PathElement...)}, or to transform a nested layout element inside\n- * another layout (see {@link MemoryLayout#map(UnaryOperator, PathElement...)}).\n+ * Layout paths are for example useful in order to obtain {@linkplain MemoryLayout#bitOffset(PathElement...) offsets} of\n+ * arbitrarily nested layouts inside another layout, to quickly obtain a {@linkplain #varHandle(PathElement...) memory access handle}\n+ * corresponding to the selected layout, to {@linkplain #select(PathElement...) select} an arbitrarily nested layout inside\n+ * another layout, or to {@link #map(UnaryOperator, PathElement...) transform} a nested layout element inside\n+ * another layout.\n@@ -155,1 +155,1 @@\n-        MemoryLayout.valueLayout(8, ByteOrder.nativeOrder()).withName(\"kind\"),\n+        ValueLayout.JAVA_BYTE.withName(\"kind\"),\n@@ -167,2 +167,1 @@\n-VarHandle valueHandle = taggedValues.varHandle(int.class,\n-                                               PathElement.sequenceElement(),\n+VarHandle valueHandle = taggedValues.varHandle(PathElement.sequenceElement(),\n@@ -192,3 +191,1 @@\n- * Layouts can be optionally associated with one or more <em>attributes<\/em>. A layout attribute forms a <em>name\/value<\/em>\n- * pair, where the name is a {@link String} and the value is a {@link Constable}. The most common form of layout attribute\n- * is the <em>layout name<\/em> (see {@link #LAYOUT_NAME}), a custom name that can be associated with memory layouts and that can be referred to when\n+ * Layouts can be optionally associated with a <em>name<\/em>. A layout name can be referred to when\n@@ -239,4 +236,1 @@\n-    default long byteSize() {\n-        return Utils.bitsToBytesOrThrow(bitSize(),\n-                () -> new UnsupportedOperationException(\"Cannot compute byte size; bit size is not a multiple of 8\"));\n-    }\n+    long byteSize();\n@@ -246,5 +240,0 @@\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    attribute(LAYOUT_NAME).map(String.class::cast);\n-     * }<\/pre><\/blockquote>\n@@ -259,5 +248,0 @@\n-     * <p>\n-     * This is equivalent to the following code:\n-     * <blockquote><pre>{@code\n-    withAttribute(LAYOUT_NAME, name);\n-     * }<\/pre><\/blockquote>\n@@ -316,1 +300,1 @@\n-     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than than 8.\n+     * @throws IllegalArgumentException if {@code bitAlignment} is not a power of two, or if it's less than 8.\n@@ -320,26 +304,0 @@\n-    \/**\n-     * Returns the attribute with the given name (if it exists).\n-     *\n-     * @param name the attribute name\n-     * @return the attribute with the given name (if it exists).\n-     *\/\n-    Optional<Constable> attribute(String name);\n-\n-    \/**\n-     * Returns a new memory layout which features the same attributes as this layout, plus the newly specified attribute.\n-     * If this layout already contains an attribute with the same name, the existing attribute value is overwritten in the returned\n-     * layout.\n-     *\n-     * @param name the attribute name.\n-     * @param value the attribute value.\n-     * @return a new memory layout which features the same attributes as this layout, plus the newly specified attribute.\n-     *\/\n-    MemoryLayout withAttribute(String name, Constable value);\n-\n-    \/**\n-     * Returns a stream of the attribute names associated with this layout.\n-     *\n-     * @return a stream of the attribute names associated with this layout.\n-     *\/\n-    Stream<String> attributes();\n-\n@@ -369,1 +327,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -420,1 +378,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -480,1 +438,0 @@\n-     * @param carrier the var handle carrier type.\n@@ -485,3 +442,1 @@\n-     * @throws IllegalArgumentException if the carrier does not represent a primitive type, if the carrier is {@code void},\n-     * {@code boolean}, or if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}),\n-     * or if the selected value layout has a size that that does not match that of the specified carrier type.\n+     * @throws IllegalArgumentException if the layout path in {@code elements} does not select a value layout (see {@link ValueLayout}).\n@@ -489,3 +444,2 @@\n-    default VarHandle varHandle(Class<?> carrier, PathElement... elements) {\n-        Objects.requireNonNull(carrier);\n-        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), path -> path.dereferenceHandle(carrier),\n+    default VarHandle varHandle(PathElement... elements) {\n+        return computePathOp(LayoutPath.rootPath(this, MemoryLayout::bitSize), LayoutPath::dereferenceHandle,\n@@ -501,1 +455,1 @@\n-     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()},\n+     * parameter types as there are free dimensions in the provided layout path (see {@link PathElement#sequenceElement()}),\n@@ -518,1 +472,1 @@\n-     * <p>After the offset is computed, the returned segment is create as if by calling:\n+     * <p>After the offset is computed, the returned segment is created as if by calling:\n@@ -585,1 +539,1 @@\n-     * Is this a padding layout (e.g. a layout created from {@link #paddingLayout(long)}) ?\n+     * Is this a {@linkplain #paddingLayout(long) padding layout} ?\n@@ -615,1 +569,1 @@\n-         * method will select the first one; that is, the group element with lowest offset from current path is selected.\n+         * method will select the first one; that is, the group element with the lowest offset from current path is selected.\n@@ -731,3 +685,14 @@\n-     * Create a value layout of given byte order and size.\n-     *\n-     * @param size the value layout size.\n+     * Creates a value layout of given Java carrier and byte order. The type of resulting value layout is determined\n+     * by the carrier provided:\n+     * <ul>\n+     *     <li>{@link ValueLayout.OfBoolean}, for {@code boolean.class}<\/li>\n+     *     <li>{@link ValueLayout.OfByte}, for {@code byte.class}<\/li>\n+     *     <li>{@link ValueLayout.OfShort}, for {@code short.class}<\/li>\n+     *     <li>{@link ValueLayout.OfChar}, for {@code char.class}<\/li>\n+     *     <li>{@link ValueLayout.OfInt}, for {@code int.class}<\/li>\n+     *     <li>{@link ValueLayout.OfFloat}, for {@code float.class}<\/li>\n+     *     <li>{@link ValueLayout.OfLong}, for {@code long.class}<\/li>\n+     *     <li>{@link ValueLayout.OfDouble}, for {@code double.class}<\/li>\n+     *     <li>{@link ValueLayout.OfAddress}, for {@code MemoryAddress.class}<\/li>\n+     * <\/ul>\n+     * @param carrier the value layout carrier.\n@@ -736,1 +701,1 @@\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @throws IllegalArgumentException if the carrier type is not supported.\n@@ -738,1 +703,2 @@\n-    static ValueLayout valueLayout(long size, ByteOrder order) {\n+    static ValueLayout valueLayout(Class<?> carrier, ByteOrder order) {\n+        Objects.requireNonNull(carrier);\n@@ -740,2 +706,21 @@\n-        AbstractLayout.checkSize(size);\n-        return new ValueLayout(order, size);\n+        if (carrier == boolean.class) {\n+            return new ValueLayout.OfBoolean(order);\n+        } else if (carrier == char.class) {\n+            return new ValueLayout.OfChar(order);\n+        } else if (carrier == byte.class) {\n+            return new ValueLayout.OfByte(order);\n+        } else if (carrier == short.class) {\n+            return new ValueLayout.OfShort(order);\n+        } else if (carrier == int.class) {\n+            return new ValueLayout.OfInt(order);\n+        } else if (carrier == float.class) {\n+            return new ValueLayout.OfFloat(order);\n+        } else if (carrier == long.class) {\n+            return new ValueLayout.OfLong(order);\n+        } else if (carrier == double.class) {\n+            return new ValueLayout.OfDouble(order);\n+        } else if (carrier == MemoryAddress.class) {\n+            return new ValueLayout.OfAddress(order);\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier.getName());\n+        }\n@@ -795,5 +780,0 @@\n-\n-    \/**\n-     * Attribute name used to specify the <em>name<\/em> property of a memory layout (see {@link #name()} and {@link #withName(String)}).\n-     *\/\n-    String LAYOUT_NAME = \"layout\/name\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayout.java","additions":61,"deletions":81,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -1,157 +0,0 @@\n-\/*\n- *  Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-package jdk.incubator.foreign;\n-\n-import jdk.internal.misc.Unsafe;\n-\n-import java.nio.ByteOrder;\n-\n-\/**\n- * This class defines useful layout constants. Some of the constants defined in this class are explicit in both\n- * size and byte order (see {@link #BITS_64_BE}), and can therefore be used to explicitly and unambiguously specify the\n- * contents of a memory segment. Other constants make implicit byte order assumptions (see\n- * {@link #JAVA_INT}); as such, these constants make it easy to work with other serialization-centric APIs,\n- * such as {@link java.nio.ByteBuffer}.\n- *\/\n-public final class MemoryLayouts {\n-\n-    private MemoryLayouts() {\n-        \/\/just the one, please\n-    }\n-\n-    \/**\n-     * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_8_LE = MemoryLayout.valueLayout(8, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_16_LE = MemoryLayout.valueLayout(16, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_32_LE = MemoryLayout.valueLayout(32, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#LITTLE_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_64_LE = MemoryLayout.valueLayout(64, ByteOrder.LITTLE_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of one byte, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_8_BE = MemoryLayout.valueLayout(8, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of two bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_16_BE = MemoryLayout.valueLayout(16, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of four bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_32_BE = MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A value layout constant with size of eight bytes, and byte order set to {@link ByteOrder#BIG_ENDIAN}.\n-     *\/\n-    public static final ValueLayout BITS_64_BE = MemoryLayout.valueLayout(64, ByteOrder.BIG_ENDIAN);\n-\n-    \/**\n-     * A padding layout constant with size of one byte.\n-     *\/\n-    public static final MemoryLayout PAD_8 = MemoryLayout.paddingLayout(8);\n-\n-    \/**\n-     * A padding layout constant with size of two bytes.\n-     *\/\n-    public static final MemoryLayout PAD_16 = MemoryLayout.paddingLayout(16);\n-\n-    \/**\n-     * A padding layout constant with size of four bytes.\n-     *\/\n-    public static final MemoryLayout PAD_32 = MemoryLayout.paddingLayout(32);\n-\n-    \/**\n-     * A padding layout constant with size of eight bytes.\n-     *\/\n-    public static final MemoryLayout PAD_64 = MemoryLayout.paddingLayout(64);\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}), and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout ADDRESS = MemoryLayout.valueLayout(Unsafe.ADDRESS_SIZE * 8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code byte}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_BYTE = MemoryLayout.valueLayout(8, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code char}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_CHAR = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code short}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_SHORT = MemoryLayout.valueLayout(16, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code int}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_INT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code long}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n-     * invariant holds:\n-     * <blockquote><pre>{@code\n-    MemoryLayouts.JAVA_LONG.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n-     * }<\/pre><\/blockquote>\n-     *\/\n-    public static final ValueLayout JAVA_LONG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n-            .withBitAlignment(ADDRESS.bitSize());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code float}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     *\/\n-    public static final ValueLayout JAVA_FLOAT = MemoryLayout.valueLayout(32, ByteOrder.nativeOrder());\n-\n-    \/**\n-     * A value layout constant whose size is the same as that of a Java {@code double}, and byte order set to {@link ByteOrder#nativeOrder()}.\n-     * The alignment of this layout (see {@link MemoryLayout#byteAlignment()} is platform-dependent, so that the following\n-     * invariant holds:\n-     * <blockquote><pre>{@code\n-    MemoryLayouts.JAVA_DOUBLE.byteAlignment() == MemoryLayouts.ADDRESS.byteSize();\n-     * }<\/pre><\/blockquote>\n-     *\/\n-    public static final ValueLayout JAVA_DOUBLE = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder())\n-            .withBitAlignment(ADDRESS.bitSize());\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemoryLayouts.java","additions":0,"deletions":157,"binary":false,"changes":157,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.lang.reflect.Array;\n@@ -37,0 +38,4 @@\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.misc.ScopedMemoryAccess;\n+import jdk.internal.misc.Unsafe;\n@@ -39,0 +44,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -41,0 +47,1 @@\n+import java.nio.ByteOrder;\n@@ -42,0 +49,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -89,1 +97,1 @@\n- * these capabilities are suitable replacements for some of the functionality in the {@link java.nio.MappedByteBuffer} class.\n+ * these capabilities are suitable replacements for some capabilities in the {@link java.nio.MappedByteBuffer} class.\n@@ -97,1 +105,36 @@\n- * {@link MemoryAddress#ofLong(long)} and {@link MemoryAddress#asSegment(long, Runnable, ResourceScope)}.\n+ * {@link MemoryAddress#ofLong(long)} and {@link MemorySegment#ofAddressNative(MemoryAddress, long, ResourceScope)}.\n+ *\n+ * <h2>Restricted native segments<\/h2>\n+ *\n+ * Sometimes it is necessary to turn a memory address obtained from native code into a memory segment with\n+ * full spatial, temporal and confinement bounds. To do this, clients can {@link #ofAddressNative(MemoryAddress, long, ResourceScope) obtain}\n+ * a native segment <em>unsafely<\/em> from a give memory address, by providing the segment size, as well as the segment {@linkplain ResourceScope scope}.\n+ * This is a <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a> operation and should be used with\n+ * caution: for instance, an incorrect segment size could result in a VM crash when attempting to dereference\n+ * the memory segment.\n+ *\n+ * <h2>Dereference<\/h2>\n+ *\n+ * A memory segment can be read or written using various methods provided in this class (e.g. {@link #get(ValueLayout.OfInt, long)}).\n+ * Each dereference method takes a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size,\n+ * alignment constraints, byte order as well as the Java type associated with the dereference operation, and an offset.\n+ * For instance, to read an int from a segment, using {@link ByteOrder#nativeOrder() default endianness}, the following code can be used:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+int value = segment.get(ValueLayout.JAVA_INT, 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * If the value to be read is stored in memory using {@link ByteOrder#BIG_ENDIAN big-endian} encoding, the dereference operation\n+ * can be expressed as follows:\n+ * <blockquote><pre>{@code\n+MemorySegment segment = ...\n+int value = segment.get(ValueLayout.JAVA_INT.withOrder(BIG_ENDIAN), 0);\n+ * }<\/pre><\/blockquote>\n+ *\n+ * For more complex dereference operations (e.g. structured memory access), clients can obtain a <em>memory access var handle<\/em>,\n+ * that is, a var handle that accepts a segment and, optionally, one or more additional {@code long} coordinates. Memory\n+ * access var handles can be obtained from {@linkplain MemoryLayout#varHandle(MemoryLayout.PathElement...) memory layouts}\n+ * by providing a so called <a href=\"MemoryLayout.html#layout-paths\"><em>layout path<\/em><\/a>.\n+ * Alternatively, clients can obtain raw memory access var handles from a given\n+ * {@linkplain MemoryHandles#varHandle(ValueLayout) value layout}, and then adapt it using the var handle combinator\n+ * functions defined in the {@link MemoryHandles} class.\n@@ -108,1 +151,1 @@\n-    segment = MemorySegment.allocateNative(8, 1, scope);\n+    segment = MemorySegment.allocateNative(8, scope);\n@@ -110,1 +153,1 @@\n-MemoryAccess.getLong(segment); \/\/ already closed!\n+segment.get(ValueLayout.JAVA_LONG, 0); \/\/ already closed!\n@@ -146,1 +189,1 @@\n-    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -148,3 +191,2 @@\n-    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-    int sum = segment.elements(MemoryLayouts.JAVA_INT).parallel()\n-                           .mapToInt(s -> (int)VH_int.get(s.address()))\n+    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                           .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n@@ -161,2 +203,4 @@\n-     * The base memory address associated with this memory segment.\n-     * The returned memory address is associated with same resource scope as that associated with this segment.\n+     * The base memory address associated with this native memory segment.\n+     * @throws UnsupportedOperationException if this segment is not a {@linkplain #isNative() native} segment.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n@@ -220,2 +264,0 @@\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(MemoryAddress, long)\n@@ -230,22 +272,0 @@\n-    \/**\n-     * Obtains a new memory segment view whose base address is the given address, and whose new size is specified by the given argument.\n-     * <p>\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSlice(newBase.segmentOffset(this), newSize);\n-     * }<\/pre>\n-     *\n-     * @see #asSlice(long)\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(long, long)\n-     *\n-     * @param newBase The new segment base address.\n-     * @param newSize The new segment size, specified in bytes.\n-     * @return a new memory segment view with updated base\/limit addresses.\n-     * @throws IndexOutOfBoundsException if {@code offset < 0}, {@code offset > byteSize()}, {@code newSize < 0}, or {@code newSize > byteSize() - offset}\n-     *\/\n-    default MemorySegment asSlice(MemoryAddress newBase, long newSize) {\n-        Objects.requireNonNull(newBase);\n-        return asSlice(newBase.segmentOffset(this), newSize);\n-    }\n-\n@@ -261,2 +281,0 @@\n-     * @see #asSlice(MemoryAddress)\n-     * @see #asSlice(MemoryAddress, long)\n@@ -273,22 +291,0 @@\n-    \/**\n-     * Obtains a new memory segment view whose base address is the given address, and whose new size is computed by subtracting\n-     * the address offset relative to this segment (see {@link MemoryAddress#segmentOffset(MemorySegment)}) from this segment size.\n-     * <p>\n-     * Equivalent to the following code:\n-     * <pre>{@code\n-    asSlice(newBase.segmentOffset(this));\n-     * }<\/pre>\n-     *\n-     * @see #asSlice(long)\n-     * @see #asSlice(MemoryAddress, long)\n-     * @see #asSlice(long, long)\n-     *\n-     * @param newBase The new segment base offset (relative to the current segment base address), specified in bytes.\n-     * @return a new memory segment view with updated base\/limit addresses.\n-     * @throws IndexOutOfBoundsException if {@code address.segmentOffset(this) < 0}, or {@code address.segmentOffset(this) > byteSize()}.\n-     *\/\n-    default MemorySegment asSlice(MemoryAddress newBase) {\n-        Objects.requireNonNull(newBase);\n-        return asSlice(newBase.segmentOffset(this));\n-    }\n-\n@@ -327,0 +323,36 @@\n+    \/**\n+     * Returns a slice of this segment that is the overlap between this and\n+     * the provided segment.\n+     *\n+     * <p>Two segments {@code S1} and {@code S2} are said to overlap if it is possible to find\n+     * at least two slices {@code L1} (from {@code S1}) and {@code L2} (from {@code S2}) that are backed by the\n+     * same memory region. As such, it is not possible for a\n+     * {@link #isNative() native} segment to overlap with a heap segment; in\n+     * this case, or when no overlap occurs, {@code null} is returned.\n+     *\n+     * @param other the segment to test for an overlap with this segment.\n+     * @return a slice of this segment, or {@code null} if no overlap occurs.\n+     *\/\n+    MemorySegment asOverlappingSlice(MemorySegment other);\n+\n+    \/**\n+     * Returns the offset, in bytes, of the provided segment, relative to this\n+     * segment.\n+     *\n+     * <p>The offset is relative to the base address of this segment and can be\n+     * a negative or positive value. For instance, if both segments are native\n+     * segments, the resulting offset can be computed as follows:\n+     *\n+     * <pre>{@code\n+     * other.baseAddress().toRawLongValue() - segment.baseAddress().toRawLongValue()\n+     * }<\/pre>\n+     *\n+     * If the segments share the same base address, {@code 0} is returned. If\n+     * {@code other} is a slice of this segment, the offset is always\n+     * {@code 0 <= x < this.byteSize()}.\n+     *\n+     * @param other the segment to retrieve an offset to.\n+     * @return the relative offset, in bytes, of the provided segment.\n+     *\/\n+    long segmentOffset(MemorySegment other);\n+\n@@ -334,1 +366,1 @@\n-byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)\n+byteHandle = MemoryLayout.ofSequence(ValueLayout.JAVA_BYTE)\n@@ -349,1 +381,1 @@\n-     * a thread other than the thread owning that scope,\n+     * a thread other than the thread owning that scope.\n@@ -358,4 +390,0 @@\n-     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n-     * offset {@code 0} through {@code src.byteSize() - 1} in the source segment were first copied into a\n-     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n-     * this segment at offset {@code 0} through {@code src.byteSize() - 1}.\n@@ -363,4 +391,4 @@\n-     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment\n-     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n-     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n-     *\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(src, 0, this, 0, src.byteSize);\n+     * }<\/pre><\/blockquote>\n@@ -373,0 +401,1 @@\n+     * @return this segment.\n@@ -374,1 +403,4 @@\n-    void copyFrom(MemorySegment src);\n+    default MemorySegment copyFrom(MemorySegment src) {\n+        MemorySegment.copy(src, 0, this, 0, src.byteSize());\n+        return this;\n+    }\n@@ -384,1 +416,1 @@\n-     * the length of the common prefix and it follows that there is a mismatch\n+     * the length of the common prefix, and it follows that there is a mismatch\n@@ -386,2 +418,2 @@\n-     * If one segment is a proper prefix of the other then the returned offset is\n-     * the smaller of the segment sizes, and it follows that the offset is only\n+     * If one segment is a proper prefix of the other, then the returned offset is\n+     * the smallest of the segment sizes, and it follows that the offset is only\n@@ -401,1 +433,1 @@\n-     * Tells whether or not the contents of this mapped segment is resident in physical\n+     * Tells whether the contents of this mapped segment is resident in physical\n@@ -405,1 +437,1 @@\n-     * that all of the data in this segment is resident in physical memory and\n+     * that all the data in this segment is resident in physical memory and\n@@ -484,1 +516,1 @@\n-     * Wraps this segment in a {@link ByteBuffer}. Some of the properties of the returned buffer are linked to\n+     * Wraps this segment in a {@link ByteBuffer}. Some properties of the returned buffer are linked to\n@@ -487,1 +519,1 @@\n-     * (see {@link ByteBuffer#isReadOnly()}. Additionally, if this is a native memory segment, the resulting buffer is\n+     * (see {@link ByteBuffer#isReadOnly()}). Additionally, if this is a native memory segment, the resulting buffer is\n@@ -490,1 +522,1 @@\n-     * The returned buffer's position (see {@link ByteBuffer#position()} is initially set to zero, while\n+     * The returned buffer's position (see {@link ByteBuffer#position()}) is initially set to zero, while\n@@ -496,1 +528,1 @@\n-     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}, will throw an {@link IllegalStateException}.\n+     * after the scope associated with this segment has been closed (see {@link ResourceScope#close()}), will throw an {@link IllegalStateException}.\n@@ -508,1 +540,1 @@\n-     * e.g. because it models an heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n+     * e.g. because it models a heap-based segment that is not based on a {@code byte[]}), or if its size is greater\n@@ -515,0 +547,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -520,1 +554,1 @@\n-    byte[] toByteArray();\n+    byte[] toArray(ValueLayout.OfByte elementLayout);\n@@ -524,0 +558,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -529,1 +565,1 @@\n-    short[] toShortArray();\n+    short[] toArray(ValueLayout.OfShort elementLayout);\n@@ -533,0 +569,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -538,1 +576,1 @@\n-    char[] toCharArray();\n+    char[] toArray(ValueLayout.OfChar elementLayout);\n@@ -542,0 +580,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -547,1 +587,1 @@\n-    int[] toIntArray();\n+    int[] toArray(ValueLayout.OfInt elementLayout);\n@@ -551,0 +591,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -556,1 +598,1 @@\n-    float[] toFloatArray();\n+    float[] toArray(ValueLayout.OfFloat elementLayout);\n@@ -560,0 +602,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -565,1 +609,1 @@\n-    long[] toLongArray();\n+    long[] toArray(ValueLayout.OfLong elementLayout);\n@@ -569,0 +613,2 @@\n+     * @param elementLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n@@ -574,1 +620,1 @@\n-    double[] toDoubleArray();\n+    double[] toArray(ValueLayout.OfDouble elementLayout);\n@@ -577,1 +623,39 @@\n-     * Creates a new confined buffer memory segment that models the memory associated with the given byte\n+     * Reads a UTF-8 encoded, null-terminated string from this segment at given offset.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a Java string constructed from the bytes read from the given starting address up to (but not including)\n+     * the first {@code '\\0'} terminator character (assuming one is found).\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n+     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    default String getUtf8String(long offset) {\n+        return SharedUtils.toJavaStringInternal(this, offset);\n+    }\n+\n+    \/**\n+     * Writes the given string into this segment at given offset, converting it to a null-terminated byte sequence using UTF-8 encoding.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement string.  The {@link\n+     * java.nio.charset.CharsetDecoder} class should be used when more control\n+     * over the decoding process is required.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param str the Java string to be written into this segment.\n+     * @throws IllegalArgumentException if the size of the native string is greater than the largest string supported by the platform.\n+     * @throws IllegalStateException if the size of the native string is greater than the size of this segment,\n+     * or if the scope associated with this segment has been closed, or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    default void setUtf8String(long offset, String str) {\n+        Utils.toCString(str.getBytes(StandardCharsets.UTF_8), SegmentAllocator.prefixAllocator(asSlice(offset)));\n+    }\n+\n+\n+    \/**\n+     * Creates a new buffer memory segment that models the memory associated with the given byte\n@@ -584,1 +668,1 @@\n-     * or to some other (possibly closeable) resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n+     * or some other resource scope, in case the buffer has been obtained using {@link #asByteBuffer()}.\n@@ -596,1 +680,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated byte array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.\n@@ -607,1 +691,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated char array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated char array.\n@@ -618,1 +702,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated short array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated short array.\n@@ -629,1 +713,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated int array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated int array.\n@@ -640,1 +724,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated float array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated float array.\n@@ -651,1 +735,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated long array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated long array.\n@@ -662,1 +746,1 @@\n-     * Creates a new confined array memory segment that models the memory associated with a given heap-allocated double array.\n+     * Creates a new array memory segment that models the memory associated with a given heap-allocated double array.\n@@ -672,0 +756,41 @@\n+\n+    \/**\n+     * Creates a new native memory segment with given size and resource scope, and whose base address is the given address.\n+     * This method can be useful when interacting with custom\n+     * native memory sources (e.g. custom allocators), where an address to some\n+     * underlying memory region is typically obtained from native code (often as a plain {@code long} value).\n+     * The returned segment is not read-only (see {@link MemorySegment#isReadOnly()}), and is associated with the\n+     * provided resource scope.\n+     * <p>\n+     * Clients should ensure that the address and bounds refer to a valid region of memory that is accessible for reading and,\n+     * if appropriate, writing; an attempt to access an invalid memory location from Java code will either return an arbitrary value,\n+     * have no visible effect, or cause an unspecified exception to be thrown.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     *\n+     * @param address the returned segment's base address.\n+     * @param bytesSize the desired size.\n+     * @param scope the native segment scope.\n+     * @return a new native memory segment with given base address, size and scope.\n+     * @throws IllegalArgumentException if {@code bytesSize <= 0}.\n+     * @throws IllegalStateException if the provided scope has been already closed,\n+     * or if access occurs from a thread other than the thread owning the scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static MemorySegment ofAddressNative(MemoryAddress address, long bytesSize, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        if (bytesSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n+        }\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(address, bytesSize, (ResourceScopeImpl)scope);\n+    }\n+\n@@ -673,1 +798,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given layout\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout\n@@ -698,1 +823,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes)\n@@ -721,1 +846,1 @@\n-     * Creates a new confined native memory segment that models a newly allocated block of off-heap memory with given size\n+     * Creates a new native memory segment that models a newly allocated block of off-heap memory with given size\n@@ -759,1 +884,1 @@\n-     * this (or another) program.  Whether or not such changes occur, and when they\n+     * this (or another) program.  Whether such changes occur, and when they\n@@ -777,1 +902,1 @@\n-     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the chosen mapping mode\n+     * @param mapMode a file mapping mode, see {@link FileChannel#map(FileChannel.MapMode, long, long)}; the mapping mode\n@@ -780,1 +905,1 @@\n-     * @return a new confined mapped memory segment.\n+     * @return a new mapped memory segment.\n@@ -787,1 +912,1 @@\n-     * @throws  SecurityException If a security manager is installed and it denies an unspecified permission required by the implementation.\n+     * @throws  SecurityException If a security manager is installed, and it denies an unspecified permission required by the implementation.\n@@ -798,7 +923,3 @@\n-     * Returns a native memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n-     * This method can be very useful when dereferencing memory addresses obtained when interacting with native libraries.\n-     * The returned segment is associated with the <em>global<\/em> resource scope (see {@link ResourceScope#globalScope()}).\n-     * Equivalent to (but likely more efficient than) the following code:\n-     * <pre>{@code\n-    MemoryAddress.NULL.asSegment(Long.MAX_VALUE)\n-     * }<\/pre>\n+     * Performs a bulk copy from source segment to destination segment. More specifically, the bytes at offset\n+     * {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment are copied into the destination\n+     * segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n@@ -806,4 +927,102 @@\n-     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n-     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n-     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n-     * restricted methods, and use safe and supported functionalities, where possible.\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + bytes - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + bytes - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * <p>\n+     * Calling this method is equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment.copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+     * }<\/pre><\/blockquote>\n+     * @param srcSegment the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param bytes the number of bytes to be copied.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + bytes > srcSegment.byteSize()} or if\n+     * {@code dstOffset + bytes > dstSegment.byteSize()}, or if either {@code srcOffset}, {@code dstOffset}\n+     * or {@code bytes} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, long srcOffset, MemorySegment dstSegment, long dstOffset, long bytes) {\n+        copy(srcSegment, ValueLayout.JAVA_BYTE, srcOffset, dstSegment, ValueLayout.JAVA_BYTE, dstOffset, bytes);\n+    }\n+\n+    \/**\n+     * Performs a bulk copy from source segment to destination segment. More specifically, if {@code S} is the byte size\n+     * of the element layouts, the bytes at offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1}\n+     * in the source segment are copied into the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The copy occurs in an element-wise fashion: the bytes in the source segment are interpreted as a sequence of elements\n+     * whose layout is {@code srcElementLayout}, whereas the bytes in the destination segment are interpreted as a sequence of\n+     * elements whose layout is {@code dstElementLayout}. Both element layouts must have same size {@code S}.\n+     * If the byte order of the two element layouts differ, the bytes corresponding to each element to be copied\n+     * are swapped accordingly during the copy operation.\n+     * <p>\n+     * If the source segment overlaps with this segment, then the copying is performed as if the bytes at\n+     * offset {@code srcOffset} through {@code srcOffset + (elementCount * S) - 1} in the source segment were first copied into a\n+     * temporary segment with size {@code bytes}, and then the contents of the temporary segment were copied into\n+     * the destination segment at offset {@code dstOffset} through {@code dstOffset + (elementCount * S) - 1}.\n+     * <p>\n+     * The result of a bulk copy is unspecified if, in the uncommon case, the source segment and the destination segment\n+     * do not overlap, but refer to overlapping regions of the same backing storage using different addresses.\n+     * For example, this may occur if the same file is {@linkplain MemorySegment#mapFile mapped} to two segments.\n+     * @param srcSegment the source segment.\n+     * @param srcElementLayout the element layout associated with the source segment.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstSegment the destination segment.\n+     * @param dstElementLayout the element layout associated with the destination segment.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of elements to be copied.\n+     * @throws IllegalArgumentException if the element layouts have different sizes, if the source offset is incompatible\n+     * with the alignment constraints in the source element layout, or if the destination offset is incompatible with the\n+     * alignment constraints in the destination element layout.\n+     * @throws IllegalStateException if either the scope associated with the source segment or the scope associated\n+     * with the destination segment have been already closed, or if access occurs from a thread other than the thread\n+     * owning either scopes.\n+     * @throws IndexOutOfBoundsException if {@code srcOffset + (elementCount * S) > srcSegment.byteSize()} or if\n+     * {@code dstOffset + (elementCount * S) > dstSegment.byteSize()}, where {@code S} is the byte size\n+     * of the element layouts, or if either {@code srcOffset}, {@code dstOffset} or {@code elementCount} are {@code < 0}.\n+     * @throws UnsupportedOperationException if the destination segment is read-only (see {@link #isReadOnly()}).\n+     *\/\n+    @ForceInline\n+    static void copy(MemorySegment srcSegment, ValueLayout srcElementLayout, long srcOffset, MemorySegment dstSegment,\n+                     ValueLayout dstElementLayout, long dstOffset, long elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(srcElementLayout);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstElementLayout);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        AbstractMemorySegmentImpl dstImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        if (srcElementLayout.byteSize() != dstElementLayout.byteSize()) {\n+            throw new IllegalArgumentException(\"Source and destination layouts must have same sizes\");\n+        }\n+        if (srcOffset % srcElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Source segment incompatible with alignment constraints\");\n+        }\n+        if (dstOffset % dstElementLayout.byteAlignment() != 0) {\n+            throw new IllegalArgumentException(\"Target segment incompatible with alignment constraints\");\n+        }\n+        long size = elementCount * srcElementLayout.byteSize();\n+        srcImpl.checkAccess(srcOffset, size, true);\n+        dstImpl.checkAccess(dstOffset, size, false);\n+        if (srcElementLayout.byteSize() == 1 || srcElementLayout.order() == dstElementLayout.order()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), dstImpl.scope(),\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstImpl.unsafeGetBase(), dstImpl.unsafeGetOffset() + dstOffset, size, srcElementLayout.byteSize());\n+        }\n+    }\n+\n+    \/**\n+     * Reads a byte from this segment and offset with given layout.\n@@ -811,4 +1030,8 @@\n-     * @return a memory segment whose base address is {@link MemoryAddress#NULL} and whose size is {@link Long#MAX_VALUE}.\n-     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n-     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n-     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a byte value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n@@ -816,4 +1039,617 @@\n-    @CallerSensitive\n-    static MemorySegment globalNativeSegment() {\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n-        return NativeMemorySegmentImpl.EVERYTHING;\n+    @ForceInline\n+    default byte get(ValueLayout.OfByte layout, long offset) {\n+        return (byte)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a byte to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the byte value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a boolean from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a boolean value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        return (boolean)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a boolean to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the boolean value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a char from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a char value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default char get(ValueLayout.OfChar layout, long offset) {\n+        return (char)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a char to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the char value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfChar layout, long offset, char value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a short from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a short value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default short get(ValueLayout.OfShort layout, long offset) {\n+        return (short)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a short to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfShort layout, long offset, short value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an int from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return an int value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default int get(ValueLayout.OfInt layout, long offset) {\n+        return (int)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes an int to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the int value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfInt layout, long offset, int value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a float from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a float value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default float get(ValueLayout.OfFloat layout, long offset) {\n+        return (float)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a float to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the float value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a long from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a long value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default long get(ValueLayout.OfLong layout, long offset) {\n+        return (long)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a long to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the long value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfLong layout, long offset, long value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads a double from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return a double value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default double get(ValueLayout.OfDouble layout, long offset) {\n+        return (double)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes a double to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the double value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        layout.accessHandle().set(this, offset, value);\n+    }\n+\n+    \/**\n+     * Reads an address from this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @return an address value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n+        return (MemoryAddress)layout.accessHandle().get(this, offset);\n+    }\n+\n+    \/**\n+     * Writes an address to this segment and offset with given layout.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param offset offset in bytes (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + offset}.\n+     * @param value the address value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n+        layout.accessHandle().set(this, offset, value.address());\n+    }\n+\n+    \/**\n+     * Reads a char from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a char value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        return (char)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a char to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the char value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a short from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a short value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        return (short)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a short to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the short value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads an int from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an int value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        return (int)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes an int to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the int value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a float from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a float value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        return (float)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a float to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the float value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a long from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a long value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        return (long)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a long to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the long value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads a double from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return a double value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        return (double)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes a double to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the double value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value);\n+    }\n+\n+    \/**\n+     * Reads an address from this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be read.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this read operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @return an address value read from this address.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     * memory segment.\n+     *\/\n+    @ForceInline\n+    default MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+        return (MemoryAddress)layout.accessHandle().get(this, Utils.scaleOffset(this, index, layout.byteSize()));\n+    }\n+\n+    \/**\n+     * Writes an address to this segment and index, scaled by given layout size.\n+     *\n+     * @param layout the layout of the memory region to be written.\n+     * @param index index (relative to this segment). For instance, if this segment is a {@linkplain #isNative() native} segment,\n+     *               the final address of this write operation can be expressed as {@code address().toRowLongValue() + (index * layout.byteSize())}.\n+     * @param value the address value to be written.\n+     * @throws IllegalStateException if the scope associated with this segment has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @throws IndexOutOfBoundsException when the dereference operation falls outside the <em>spatial bounds<\/em> of the\n+     *\/\n+    @ForceInline\n+    default void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+        layout.accessHandle().set(this, Utils.scaleOffset(this, index, layout.byteSize()), value.address());\n+    }\n+\n+\n+    \/**\n+     * Copies a number of elements from a source segment to a destination array,\n+     * starting at a given segment offset (expressed in bytes), and a given array index, using the given source element layout.\n+     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n+     * @param srcSegment the source segment.\n+     * @param srcLayout the source element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @param srcOffset the starting offset, in bytes, of the source segment.\n+     * @param dstArray the destination array.\n+     * @param dstIndex the starting index of the destination array.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code dstArray} is not an array, or if it is an array but whose type is not supported,\n+     * or if the destination array component type does not match the carrier of the source element layout.\n+     *\/\n+    @ForceInline\n+    static void copy(\n+            MemorySegment srcSegment, ValueLayout srcLayout, long srcOffset,\n+            Object dstArray, int dstIndex, int elementCount) {\n+        Objects.requireNonNull(srcSegment);\n+        Objects.requireNonNull(dstArray);\n+        Objects.requireNonNull(srcLayout);\n+        long baseAndScale = getBaseAndScale(dstArray.getClass());\n+        if (dstArray.getClass().componentType() != srcLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + srcLayout);\n+        }\n+        int dstBase = (int)baseAndScale;\n+        int dstWidth = (int)(baseAndScale >> 32);\n+        AbstractMemorySegmentImpl srcImpl = (AbstractMemorySegmentImpl)srcSegment;\n+        srcImpl.checkAccess(srcOffset, elementCount * dstWidth, true);\n+        Objects.checkFromIndexSize(dstIndex, elementCount, Array.getLength(dstArray));\n+        if (dstWidth == 1 || srcLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(srcImpl.scope(), null,\n+                    srcImpl.unsafeGetBase(), srcImpl.unsafeGetOffset() + srcOffset,\n+                    dstArray, dstBase + (dstIndex * dstWidth), elementCount * dstWidth, dstWidth);\n+        }\n+    }\n+\n+    \/**\n+     * Copies a number of elements from a source array to a destination segment,\n+     * starting at a given array index, and a given segment offset (expressed in bytes), using the given destination element layout.\n+     * Supported array types are {@code byte[]}, {@code char[]}, {@code short[]}, {@code int[]}, {@code float[]}, {@code long[]} and {@code double[]}.\n+     * @param srcArray the source array.\n+     * @param srcIndex the starting index of the source array.\n+     * @param dstSegment the destination segment.\n+     * @param dstLayout the destination element layout. If the byte order associated with the layout is\n+     * different from the native order, a byte swap operation will be performed on each array element.\n+     * @param dstOffset the starting offset, in bytes, of the destination segment.\n+     * @param elementCount the number of array elements to be copied.\n+     * @throws  IllegalArgumentException if {@code srcArray} is not an array, or if it is an array but whose type is not supported,\n+     * or if the source array component type does not match the carrier of the destination element layout.\n+     *\/\n+    @ForceInline\n+    static void copy(\n+            Object srcArray, int srcIndex,\n+            MemorySegment dstSegment, ValueLayout dstLayout, long dstOffset, int elementCount) {\n+        Objects.requireNonNull(srcArray);\n+        Objects.requireNonNull(dstSegment);\n+        Objects.requireNonNull(dstLayout);\n+        long baseAndScale = getBaseAndScale(srcArray.getClass());\n+        if (srcArray.getClass().componentType() != dstLayout.carrier()) {\n+            throw new IllegalArgumentException(\"Incompatible value layout: \" + dstLayout);\n+        }\n+        int srcBase = (int)baseAndScale;\n+        int srcWidth = (int)(baseAndScale >> 32);\n+        Objects.checkFromIndexSize(srcIndex, elementCount, Array.getLength(srcArray));\n+        AbstractMemorySegmentImpl destImpl = (AbstractMemorySegmentImpl)dstSegment;\n+        destImpl.checkAccess(dstOffset, elementCount * srcWidth, false);\n+        if (srcWidth == 1 || dstLayout.order() == ByteOrder.nativeOrder()) {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copyMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth);\n+        } else {\n+            ScopedMemoryAccess.getScopedMemoryAccess().copySwapMemory(null, destImpl.scope(),\n+                    srcArray, srcBase + (srcIndex * srcWidth),\n+                    destImpl.unsafeGetBase(), destImpl.unsafeGetOffset() + dstOffset, elementCount * srcWidth, srcWidth);\n+        }\n+    }\n+\n+    private static long getBaseAndScale(Class<?> arrayType) {\n+        if (arrayType.equals(byte[].class)) {\n+            return (long)Unsafe.ARRAY_BYTE_BASE_OFFSET | ((long)Unsafe.ARRAY_BYTE_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(char[].class)) {\n+            return (long)Unsafe.ARRAY_CHAR_BASE_OFFSET | ((long)Unsafe.ARRAY_CHAR_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(short[].class)) {\n+            return (long)Unsafe.ARRAY_SHORT_BASE_OFFSET | ((long)Unsafe.ARRAY_SHORT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(int[].class)) {\n+            return (long)Unsafe.ARRAY_INT_BASE_OFFSET | ((long) Unsafe.ARRAY_INT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(float[].class)) {\n+            return (long)Unsafe.ARRAY_FLOAT_BASE_OFFSET | ((long)Unsafe.ARRAY_FLOAT_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(long[].class)) {\n+            return (long)Unsafe.ARRAY_LONG_BASE_OFFSET | ((long)Unsafe.ARRAY_LONG_INDEX_SCALE << 32);\n+        } else if (arrayType.equals(double[].class)) {\n+            return (long)Unsafe.ARRAY_DOUBLE_BASE_OFFSET | ((long)Unsafe.ARRAY_DOUBLE_INDEX_SCALE << 32);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a supported array class: \" + arrayType.getSimpleName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":958,"deletions":122,"binary":false,"changes":1080,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.NativeSymbolImpl;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.Objects;\n+\n+\/**\n+ * A native symbol models a reference to a location (typically the entry point of a function) in a native library.\n+ * A native symbol has a name, and is associated with a scope, which governs the native symbol's lifecycle.\n+ * This is useful, since the library a native symbol refers to can be <em>unloaded<\/em>, thus invalidating the native symbol.\n+ * While native symbols are typically obtained using a {@link SymbolLookup#lookup(String) symbol lookup}, it is also possible to obtain an\n+ * <em>anonymous<\/em> native symbol, in the form of an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub},\n+ * that is, a reference to a dynamically-generated native symbol which can be used to call back into Java code.\n+ *\/\n+sealed public interface NativeSymbol extends Addressable permits NativeSymbolImpl {\n+\n+    \/**\n+     * Returns the name of this symbol.\n+     * @return the name of this symbol.\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the resource scope associated with this symbol.\n+     * @return the resource scope associated with this symbol.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Returns the memory address associated with this symbol.\n+     * @throws IllegalStateException if the scope associated with this symbol has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this symbol.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n+    \/**\n+     * Creates a new symbol from given name, address and scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     * @param name the symbol name.\n+     * @param address the symbol address.\n+     * @param scope the symbol scope.\n+     * @return A new symbol from given name, address and scope.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static NativeSymbol ofAddress(String name, MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(name);\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        return new NativeSymbolImpl(name, address, scope);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/NativeSymbol.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Map;\n@@ -56,1 +54,1 @@\n-        this(size, 1, Map.of());\n+        this(size, 1, Optional.empty());\n@@ -59,2 +57,2 @@\n-    PaddingLayout(long size, long alignment, Map<String, Constable> attributes) {\n-        super(OptionalLong.of(size), alignment, attributes);\n+    PaddingLayout(long size, long alignment, Optional<String> name) {\n+        super(OptionalLong.of(size), alignment, name);\n@@ -76,1 +74,1 @@\n-        if (!(other instanceof PaddingLayout)) {\n+        if (!(other instanceof PaddingLayout p)) {\n@@ -79,1 +77,0 @@\n-        PaddingLayout p = (PaddingLayout)other;\n@@ -89,2 +86,2 @@\n-    PaddingLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new PaddingLayout(bitSize(), alignment, attributes);\n+    PaddingLayout dup(long alignment, Optional<String> name) {\n+        return new PaddingLayout(bitSize(), alignment, name);\n@@ -122,8 +119,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public PaddingLayout withAttribute(String name, Constable value) {\n-        return (PaddingLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/PaddingLayout.java","additions":6,"deletions":17,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.ref.CleanerFactory;\n@@ -32,0 +33,1 @@\n+import java.nio.ByteBuffer;\n@@ -39,2 +41,2 @@\n- * with a resource scope can only be accessed while the resource scope is <em>alive<\/em> (see {@link #isAlive()}),\n- * and by the thread associated with the resource scope (if any).\n+ * with a resource scope can only be accessed while the resource scope is {@linkplain #isAlive() alive},\n+ * and by the {@linkplain #ownerThread() thread} associated with the resource scope (if any).\n@@ -42,1 +44,1 @@\n- * <h2>Explicit resource scopes<\/h2>\n+ * <h2>Deterministic deallocation<\/h2>\n@@ -44,4 +46,4 @@\n- * Resource scopes obtained from {@link #newConfinedScope()}, {@link #newSharedScope()} support <em>deterministic deallocation<\/em>;\n- * We call these resource scopes <em>explicit scopes<\/em>. Explicit resource scopes can be closed explicitly (see {@link ResourceScope#close()}).\n- * When a resource scope is closed, it is no longer <em>alive<\/em> (see {@link #isAlive()}, and subsequent operations on\n- * resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance) will fail with {@link IllegalStateException}.\n+ * Resource scopes support <em>deterministic deallocation<\/em>; that is, they can be {@linkplain ResourceScope#close() closed}\n+ * explicitly. When a resource scope is closed, it is no longer {@link #isAlive() alive}, and subsequent\n+ * operations on resources associated with that scope (e.g. attempting to access a {@link MemorySegment} instance)\n+ * will fail with {@link IllegalStateException}.\n@@ -49,1 +51,1 @@\n- * Closing a resource scope will cause all the cleanup actions associated with that scope (see {@link #addCloseAction(Runnable)}) to be called.\n+ * Closing a resource scope will cause all the {@linkplain #addCloseAction(Runnable) close actions} associated with that scope to be called.\n@@ -52,6 +54,8 @@\n- *     <li>closing the scope associated with a native memory segment results in <em>freeing<\/em> the native memory associated with it\n- *     (see {@link MemorySegment#allocateNative(long, ResourceScope)}, or {@link SegmentAllocator#arenaAllocator(ResourceScope)})<\/li>\n- *     <li>closing the scope associated with a mapped memory segment results in the backing memory-mapped file to be unmapped\n- *     (see {@link MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope)})<\/li>\n- *     <li>closing the scope associated with an upcall stub results in releasing the stub\n- *     (see {@link CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope)}<\/li>\n+ *     <li>closing the scope associated with a {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) native memory segment}\n+ *     results in <em>freeing<\/em> the native memory associated with it;<\/li>\n+ *     <li>closing the scope associated with a {@linkplain MemorySegment#mapFile(Path, long, long, FileChannel.MapMode, ResourceScope) mapped memory segment}\n+ *     results in the backing memory-mapped file to be unmapped;<\/li>\n+ *     <li>closing the scope associated with an {@linkplain CLinker#upcallStub(MethodHandle, FunctionDescriptor, ResourceScope) upcall stub}\n+ *     results in releasing the stub;<\/li>\n+ *     <li>closing the scope associated with a {@linkplain VaList variable arity list} results in releasing the memory\n+ *     associated with that variable arity list instance.<\/li>\n@@ -59,9 +63,0 @@\n- * <p>\n- * Sometimes, explicit scopes can be associated with a {@link Cleaner} instance (see {@link #newConfinedScope(Cleaner)} and\n- * {@link #newSharedScope(Cleaner)}). We call these resource scopes <em>managed<\/em> resource scopes. A managed resource scope\n- * is closed automatically once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * <p>\n- * Managed scopes can be useful to allow for predictable, deterministic resource deallocation, while still prevent accidental native memory leaks.\n- * In case a managed resource scope is closed explicitly, no further action will be taken when the scope becomes unreachable;\n- * that is, cleanup actions (see {@link #addCloseAction(Runnable)}) associated with a resource scope, whether managed or not,\n- * are called <em>exactly once<\/em>.\n@@ -69,1 +64,10 @@\n- * <h2>Implicit resource scopes<\/h2>\n+ * <h2>Implicit deallocation<\/h2>\n+ *\n+ * Resource scopes can be associated with a {@link Cleaner} instance, so that they are also closed automatically,\n+ * once the scope instance becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n+ * This can be useful to allow for predictable, deterministic resource deallocation, while still preventing accidental\n+ * native memory leaks. In case a managed resource scope is closed explicitly, no further action will be taken when\n+ * the scope becomes unreachable; that is, {@linkplain #addCloseAction(Runnable) close actions} associated with a\n+ * resource scope, whether managed or not, are called <em>exactly once<\/em>.\n+ *\n+ * <h2><a id = \"global-scope\">Global scope<\/a><\/h2>\n@@ -71,5 +75,0 @@\n- * Resource scopes obtained from {@link #newImplicitScope()} cannot be closed explicitly. We call these resource scopes\n- * <em>implicit scopes<\/em>. Calling {@link #close()} on an implicit resource scope always results in an exception.\n- * Resources associated with implicit scopes are released once the scope instance becomes\n- * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * <p>\n@@ -77,2 +76,10 @@\n- * an implicit scope that is guaranteed to never become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>.\n- * As a results, the global scope will never attempt to release resources associated with it. Such resources must, where\n+ * a resource scope that cannot be closed, either explicitly or implicitly. As a result, the global scope will never\n+ * attempt to release resources associated with it. Examples of resources associated with the global scope are:\n+ * <ul>\n+ *     <li>heap segments created from {@linkplain MemorySegment#ofArray(int[]) arrays} or\n+ *     {@linkplain MemorySegment#ofByteBuffer(ByteBuffer) buffers};<\/li>\n+ *     <li>variable arity lists {@linkplain VaList#ofAddress(MemoryAddress, ResourceScope) obtained} from raw memory addresses;\n+ *     <li>native symbols {@linkplain SymbolLookup#lookup(String) obtained} from a {@linkplain SymbolLookup#loaderLookup() loader lookup},\n+ *     or from the {@link CLinker}.<\/li>\n+ * <\/ul>\n+ * In other words, the global scope is used to indicate that the lifecycle of one or more resources must, where\n@@ -83,1 +90,1 @@\n- * Resource scopes can be further divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n+ * Resource scopes can be divided into two categories: <em>thread-confined<\/em> resource scopes, and <em>shared<\/em>\n@@ -86,2 +93,2 @@\n- * Confined resource scopes (see {@link #newConfinedScope()}), support strong thread-confinement guarantees. Upon creation,\n- * they are assigned an <em>owner thread<\/em>, typically the thread which initiated the creation operation (see {@link #ownerThread()}).\n+ * {@linkplain #newConfinedScope() Confined resource scopes}, support strong thread-confinement guarantees. Upon creation,\n+ * they are assigned an {@linkplain #ownerThread() owner thread}, typically the thread which initiated the creation operation.\n@@ -92,2 +99,2 @@\n- * Shared resource scopes (see {@link #newSharedScope()} and {@link #newImplicitScope()}), on the other hand, have no owner thread;\n- * as such resources associated with this shared resource scopes can be accessed by multiple threads.\n+ * {@linkplain #newSharedScope() Shared resource scopes}, on the other hand, have no owner thread;\n+ * as such, resources associated with shared resource scopes can be accessed by multiple threads.\n@@ -95,1 +102,1 @@\n- * For instance, a client might obtain a {@link Spliterator} from a shared segment, which can then be used to slice the\n+ * For instance, a client might obtain a {@link Spliterator} from a segment backed by a shared scope, which can then be used to slice the\n@@ -100,1 +107,0 @@\n-SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n@@ -102,0 +108,1 @@\n+    SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -103,4 +110,3 @@\n-    VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);\n-    int sum = StreamSupport.stream(segment.spliterator(SEQUENCE_LAYOUT), true)\n-        .mapToInt(s -> (int)VH_int.get(s.address()))\n-        .sum();\n+    int sum = segment.elements(ValueLayout.JAVA_INT).parallel()\n+                        .mapToInt(s -> s.get(ValueLayout.JAVA_INT, 0))\n+                        .sum();\n@@ -111,1 +117,1 @@\n- * Explicit shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n+ * Shared resource scopes, while powerful, must be used with caution: if one or more threads accesses\n@@ -115,1 +121,1 @@\n- * should always ensure that proper synchronization mechanisms (e.g. using resource scope handles, see below) are put in place\n+ * should always ensure that proper synchronization mechanisms (e.g. using temporal dependencies, see below) are put in place\n@@ -118,1 +124,1 @@\n- * <h2>Resource scope handles<\/h2>\n+ * <h2>Temporal dependencies<\/h2>\n@@ -120,5 +126,5 @@\n- * Resource scopes can be made <em>non-closeable<\/em> by acquiring one or more resource scope <em>handles<\/em> (see\n- * {@link #acquire()}. A resource scope handle can be used to make sure that resources associated with a given resource scope\n- * (either explicit or implicit) cannot be released for a certain period of time - e.g. during a critical region of code\n- * involving one or more resources associated with the scope. For instance, an explicit resource scope can only be closed\n- * <em>after<\/em> all the handles acquired against that scope have been closed (see {@link Handle#close()}).\n+ * Resource scopes can depend on each other. More specifically, a scope can feature\n+ * {@linkplain #keepAlive(ResourceScope) temporal dependencies} on one or more other resource scopes.\n+ * Such a resource scope cannot be closed (either implicitly or explicitly) until <em>all<\/em> the scopes it depends on\n+ * have also been closed.\n+ * <p>\n@@ -126,1 +132,1 @@\n- * to ensure that the segment will not be released; this can be done as follows:\n+ * to ensure that the scope associated with that segment will not be closed; this can be done as follows:\n@@ -130,5 +136,3 @@\n-ResourceScope.Handle segmentHandle = segment.scope().acquire()\n-try {\n-   <critical operation on segment>\n-} finally {\n-   segment.scope().release(segmentHandle);\n+try (ResourceScope criticalScope = ResourceScope.newConfinedScope()) {\n+    criticalScope.keepAlive(segment.scope());\n+    <critical operation on segment>\n@@ -138,4 +142,2 @@\n- * Acquiring implicit resource scopes is also possible, but it is often unnecessary: since resources associated with\n- * an implicit scope will only be released when the scope becomes <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>,\n- * clients can use e.g. {@link java.lang.ref.Reference#reachabilityFence(Object)} to make sure that resources associated\n- * with implicit scopes are not released prematurely. That said, the above code snippet works (trivially) for implicit scopes too.\n+ * Note that a resource scope does not become <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">unreachable<\/a>\n+ * until all the scopes it depends on have been closed.\n@@ -161,9 +163,1 @@\n-     * Is this resource scope an <em>implicit scope<\/em>?\n-     * @return true if this scope is an <em>implicit scope<\/em>.\n-     * @see #newImplicitScope()\n-     * @see #globalScope()\n-     *\/\n-    boolean isImplicit();\n-\n-    \/**\n-     * Closes this resource scope. As a side-effect, if this operation completes without exceptions, this scope will be marked\n+     * Closes this resource scope. As a side effect, if this operation completes without exceptions, this scope will be marked\n@@ -183,1 +177,1 @@\n-     *     <li>one or more handles (see {@link #acquire()}) associated with this resource scope have not been {@linkplain #release(Handle) released}<\/li>\n+     *     <li>one or more scopes which {@linkplain #keepAlive(ResourceScope) depend} on this resource scope have not been closed.\n@@ -185,1 +179,1 @@\n-     * @throws UnsupportedOperationException if this resource scope is {@linkplain #isImplicit() implicit}.\n+     * @throws UnsupportedOperationException if this resource scope is the {@linkplain #globalScope() global scope}.\n@@ -193,1 +187,2 @@\n-     * @throws IllegalStateException if this scope has already been closed.\n+     * @throws IllegalStateException if this scope has been closed, or if access occurs from\n+     * a thread other than the thread owning this scope.\n@@ -198,19 +193,7 @@\n-     * Acquires a resource scope handle associated with this resource scope. An explicit resource scope cannot be\n-     * {@linkplain #close() closed} until all the resource scope handles acquired from it have been {@linkplain #release(Handle)} released}.\n-     * @return a resource scope handle.\n-     *\/\n-    Handle acquire();\n-\n-    \/**\n-     * Release the provided resource scope handle. This method is idempotent, that is, releasing the same handle\n-     * multiple times has no effect.\n-     * @param handle the resource scope handle to be released.\n-     * @throws IllegalArgumentException if the provided handle is not associated with this scope.\n-     *\/\n-    void release(Handle handle);\n-\n-    \/**\n-     * An abstraction modelling a resource scope handle. A resource scope handle is typically {@linkplain #acquire() acquired} by clients\n-     * in order to prevent an explicit resource scope from being closed while executing a certain operation.\n-     * Once obtained, resource scope handles can be {@linkplain #release(Handle)} released}; an explicit resource scope can\n-     * be closed only <em>after<\/em> all the resource scope handles acquired from it have been released.\n+     * Creates a temporal dependency between this scope and the target scope. As a result, the target scope cannot\n+     * be {@linkplain #close() closed} <em>before<\/em> this scope.\n+     * @implNote A given scope can support up to {@link Integer#MAX_VALUE} pending keep alive requests.\n+     * @param target the scope that needs to be kept alive.\n+     * @throws IllegalArgumentException if {@code target == this}.\n+     * @throws IllegalStateException if this scope or {@code target} have been closed, or if access occurs from\n+     * a thread other than the thread owning this scope or {@code target}.\n@@ -218,8 +201,1 @@\n-    sealed interface Handle permits ResourceScopeImpl.HandleImpl {\n-\n-        \/**\n-         * Returns the resource scope associated with this handle.\n-         * @return the resource scope associated with this handle.\n-         *\/\n-        ResourceScope scope();\n-    }\n+    void keepAlive(ResourceScope target);\n@@ -228,1 +204,1 @@\n-     * Create a new confined scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * Creates a new confined scope.\n@@ -232,1 +208,1 @@\n-        return ResourceScopeImpl.createConfined( null);\n+        return ResourceScopeImpl.createConfined(Thread.currentThread(), null);\n@@ -236,1 +212,1 @@\n-     * Create a new confined scope managed by a {@link Cleaner}.\n+     * Creates a new confined scope, managed by the provided cleaner instance.\n@@ -239,1 +215,0 @@\n-     * @throws NullPointerException if {@code cleaner == null}.\n@@ -243,1 +218,1 @@\n-        return ResourceScopeImpl.createConfined( cleaner);\n+        return ResourceScopeImpl.createConfined(Thread.currentThread(), cleaner);\n@@ -247,1 +222,1 @@\n-     * Create a new shared scope. The resulting scope is closeable, and is not managed by a {@link Cleaner}.\n+     * Creates a new shared scope.\n@@ -255,1 +230,1 @@\n-     * Create a new shared scope managed by a {@link Cleaner}.\n+     * Creates a new shared scope, managed by the provided cleaner instance.\n@@ -258,1 +233,0 @@\n-     * @throws NullPointerException if {@code cleaner == null}.\n@@ -266,7 +240,6 @@\n-     * Create a new <em>implicit scope<\/em>. The implicit scope is a managed, shared, and non-closeable scope which only features\n-     * <a href=\"ResourceScope.html#implicit-closure\"><em>implicit closure<\/em><\/a>.\n-     * Since implicit scopes can only be closed implicitly by the garbage collector, it is recommended that implicit\n-     * scopes are only used in cases where deallocation performance is not a critical concern, to avoid unnecessary\n-     * memory pressure.\n-     *\n-     * @return a new implicit scope.\n+     * Creates a new shared scope, managed by a private {@link Cleaner} instance. Equivalent to (but likely more efficient than)\n+     * the following code:\n+     * <pre>{@code\n+    newSharedScope(Cleaner.create());\n+     * }<\/pre>\n+     * @return a shared scope, managed by a private {@link Cleaner} instance.\n@@ -275,1 +248,1 @@\n-        return ResourceScopeImpl.createImplicitScope();\n+        return newSharedScope(CleanerFactory.cleaner());\n@@ -279,2 +252,2 @@\n-     * Returns an implicit scope which is assumed to be always alive.\n-     * @return the global scope.\n+     * Returns the <a href=\"ResourceScope.html#global-scope\"><em>global scope<\/em><\/a>.\n+     * @return the <a href=\"ResourceScope.html#global-scope\"><em>global scope<\/em><\/a>.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ResourceScope.java","additions":90,"deletions":117,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.foreign.ArenaAllocator;\n@@ -30,0 +29,1 @@\n+import jdk.internal.foreign.ArenaAllocator;\n@@ -36,0 +36,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -38,1 +39,0 @@\n-import java.util.stream.Stream;\n@@ -44,2 +44,3 @@\n- * This interface can be seen as a thin wrapper around the basic capabilities for creating native segments\n- * (e.g. {@link MemorySegment#allocateNative(long, long, ResourceScope)}); since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n+ * This interface can be seen as a thin wrapper around the basic capabilities for\n+ * {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) creating} native segments;\n+ * since {@link SegmentAllocator} is a <em>functional interface<\/em>,\n@@ -48,14 +49,15 @@\n- * This interface provides a factory, namely {@link SegmentAllocator#ofScope(ResourceScope)} which can be used to obtain\n- * a <em>scoped<\/em> allocator, that is, an allocator which creates segment bound by a given scope. This can be useful\n- * when working inside a <em>try-with-resources<\/em> construct:\n- *\n- * <blockquote><pre>{@code\n-try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-   SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-   ...\n-}\n- * }<\/pre><\/blockquote>\n- *\n- * In addition, this interface also defines factories for commonly used allocators; for instance {@link #arenaAllocator(ResourceScope)}\n- * and {@link #arenaAllocator(long, ResourceScope)} are arena-style native allocators. Finally {@link #ofSegment(MemorySegment)}\n- * returns an allocator which wraps a segment (either on-heap or off-heap) and recycles its content upon each new allocation request.\n+ * This interface also defines factories for commonly used allocators:\n+ * <ul>\n+ *     <li>{@link #nativeAllocator(ResourceScope)} creates an allocator which\n+ *     {@linkplain MemorySegment#allocateNative(long, long, ResourceScope) allocates} native segments, backed by a given scope;<\/li>\n+ *     <li>{@link #newNativeArena(ResourceScope)} creates a more efficient arena-style native allocator, where memory\n+ *     is allocated in bigger blocks, which are then sliced accordingly to fit allocation requests;<\/li>\n+ *     <li>{@link #prefixAllocator(MemorySegment)} creates an allocator which wraps a segment (either on-heap or off-heap)\n+ *     and recycles its content upon each new allocation request.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Passing a segment allocator to an API can be especially useful in circumstances where a client wants to communicate <em>where<\/em>\n+ * the results of a certain operation (performed by the API) should be stored, as a memory segment. For instance,\n+ * {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handles} can accept an additional\n+ * {@link SegmentAllocator} parameter if the underlying native function is known to return a struct by-value. Effectively,\n+ * the allocator parameter tells the linker runtime where to store the return value of the native function.\n@@ -67,1 +69,18 @@\n-     * Allocate a block of memory with given layout and initialize it with given byte value.\n+     * Converts a Java string into a UTF-8 encoded, null-terminated C string,\n+     * storing the result into a memory segment.\n+     * <p>\n+     * This method always replaces malformed-input and unmappable-character\n+     * sequences with this charset's default replacement byte array.  The\n+     * {@link java.nio.charset.CharsetEncoder} class should be used when more\n+     * control over the encoding process is required.\n+     *\n+     * @param str the Java string to be converted into a C string.\n+     * @return a new native memory segment containing the converted C string.\n+     *\/\n+    default MemorySegment allocateUtf8String(String str) {\n+        Objects.requireNonNull(str);\n+        return Utils.toCString(str.getBytes(StandardCharsets.UTF_8), this);\n+    }\n+\n+    \/**\n+     * Allocate a memory segment with given layout and initialize it with given byte value.\n@@ -72,1 +91,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a byte value.\n@@ -74,1 +92,1 @@\n-    default MemorySegment allocate(ValueLayout layout, byte value) {\n+    default MemorySegment allocate(ValueLayout.OfByte layout, byte value) {\n@@ -76,1 +94,1 @@\n-        VarHandle handle = layout.varHandle(byte.class);\n+        VarHandle handle = layout.varHandle();\n@@ -83,1 +101,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given char value.\n+     * Allocate a memory segment with given layout and initialize it with given char value.\n@@ -88,1 +106,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a char value.\n@@ -90,1 +107,1 @@\n-    default MemorySegment allocate(ValueLayout layout, char value) {\n+    default MemorySegment allocate(ValueLayout.OfChar layout, char value) {\n@@ -92,1 +109,1 @@\n-        VarHandle handle = layout.varHandle(char.class);\n+        VarHandle handle = layout.varHandle();\n@@ -99,1 +116,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given short value.\n+     * Allocate a memory segment with given layout and initialize it with given short value.\n@@ -104,1 +121,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a short value.\n@@ -106,1 +122,1 @@\n-    default MemorySegment allocate(ValueLayout layout, short value) {\n+    default MemorySegment allocate(ValueLayout.OfShort layout, short value) {\n@@ -108,1 +124,1 @@\n-        VarHandle handle = layout.varHandle(short.class);\n+        VarHandle handle = layout.varHandle();\n@@ -115,1 +131,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given int value.\n+     * Allocate a memory segment with given layout and initialize it with given int value.\n@@ -120,1 +136,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a int value.\n@@ -122,1 +137,1 @@\n-    default MemorySegment allocate(ValueLayout layout, int value) {\n+    default MemorySegment allocate(ValueLayout.OfInt layout, int value) {\n@@ -124,1 +139,1 @@\n-        VarHandle handle = layout.varHandle(int.class);\n+        VarHandle handle = layout.varHandle();\n@@ -131,1 +146,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given float value.\n+     * Allocate a memory segment with given layout and initialize it with given float value.\n@@ -136,1 +151,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a float value.\n@@ -138,1 +152,1 @@\n-    default MemorySegment allocate(ValueLayout layout, float value) {\n+    default MemorySegment allocate(ValueLayout.OfFloat layout, float value) {\n@@ -140,1 +154,1 @@\n-        VarHandle handle = layout.varHandle(float.class);\n+        VarHandle handle = layout.varHandle();\n@@ -147,1 +161,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given long value.\n+     * Allocate a memory segment with given layout and initialize it with given long value.\n@@ -152,1 +166,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a long value.\n@@ -154,1 +167,1 @@\n-    default MemorySegment allocate(ValueLayout layout, long value) {\n+    default MemorySegment allocate(ValueLayout.OfLong layout, long value) {\n@@ -156,1 +169,1 @@\n-        VarHandle handle = layout.varHandle(long.class);\n+        VarHandle handle = layout.varHandle();\n@@ -163,1 +176,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given double value.\n+     * Allocate a memory segment with given layout and initialize it with given double value.\n@@ -168,1 +181,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize()} does not conform to the size of a double value.\n@@ -170,1 +182,1 @@\n-    default MemorySegment allocate(ValueLayout layout, double value) {\n+    default MemorySegment allocate(ValueLayout.OfDouble layout, double value) {\n@@ -172,1 +184,1 @@\n-        VarHandle handle = layout.varHandle(double.class);\n+        VarHandle handle = layout.varHandle();\n@@ -179,1 +191,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given address value\n+     * Allocate a memory segment with given layout and initialize it with given address value\n@@ -181,1 +193,1 @@\n-     * The address value might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n+     * The address value might be narrowed according to the platform address size (see {@link ValueLayout#ADDRESS}).\n@@ -186,1 +198,0 @@\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n@@ -188,1 +199,1 @@\n-    default MemorySegment allocate(ValueLayout layout, Addressable value) {\n+    default MemorySegment allocate(ValueLayout.OfAddress layout, Addressable value) {\n@@ -191,8 +202,3 @@\n-        if (MemoryLayouts.ADDRESS.byteSize() != layout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + layout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        return switch ((int)layout.byteSize()) {\n-            case 4 -> allocate(layout, (int)value.address().toRawLongValue());\n-            case 8 -> allocate(layout, value.address().toRawLongValue());\n-            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        };\n+        MemorySegment segment = allocate(layout);\n+        layout.varHandle().set(segment, value.address());\n+        return segment;\n@@ -202,1 +208,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given byte array.\n+     * Allocate a memory segment with given layout and initialize it with given byte array.\n@@ -207,1 +213,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a byte value.\n@@ -209,1 +214,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, byte[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfByte elementLayout, byte[] array) {\n@@ -214,1 +219,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given short array.\n+     * Allocate a memory segment with given layout and initialize it with given short array.\n@@ -219,1 +224,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a short value.\n@@ -221,1 +225,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, short[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfShort elementLayout, short[] array) {\n@@ -226,1 +230,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given char array.\n+     * Allocate a memory segment with given layout and initialize it with given char array.\n@@ -231,1 +235,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a char value.\n@@ -233,1 +236,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, char[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfChar elementLayout, char[] array) {\n@@ -238,1 +241,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given int array.\n+     * Allocate a memory segment with given layout and initialize it with given int array.\n@@ -243,1 +246,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a int value.\n@@ -245,1 +247,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, int[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfInt elementLayout, int[] array) {\n@@ -250,1 +252,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given float array.\n+     * Allocate a memory segment with given layout and initialize it with given float array.\n@@ -255,1 +257,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a float value.\n@@ -257,1 +258,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, float[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfFloat elementLayout, float[] array) {\n@@ -262,1 +263,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given long array.\n+     * Allocate a memory segment with given layout and initialize it with given long array.\n@@ -267,1 +268,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a long value.\n@@ -269,1 +269,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, long[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfLong elementLayout, long[] array) {\n@@ -274,1 +274,1 @@\n-     * Allocate a block of memory with given layout and initialize it with given double array.\n+     * Allocate a memory segment with given layout and initialize it with given double array.\n@@ -279,1 +279,0 @@\n-     * @throws IllegalArgumentException if {@code elementLayout.byteSize()} does not conform to the size of a double value.\n@@ -281,1 +280,1 @@\n-    default MemorySegment allocateArray(ValueLayout elementLayout, double[] array) {\n+    default MemorySegment allocateArray(ValueLayout.OfDouble elementLayout, double[] array) {\n@@ -285,27 +284,0 @@\n-    \/**\n-     * Allocate a block of memory with given layout and initialize it with given address array.\n-     * The address value of each array element might be narrowed according to the platform address size (see {@link MemoryLayouts#ADDRESS}).\n-     * @implSpec the default implementation for this method calls {@code this.allocateArray(layout, array.length)}.\n-     * @param elementLayout the element layout of the array to be allocated.\n-     * @param array the array to be copied on the newly allocated memory block.\n-     * @return a segment for the newly allocated memory block.\n-     * @throws IllegalArgumentException if {@code layout.byteSize() != MemoryLayouts.ADDRESS.byteSize()}.\n-     *\/\n-    default MemorySegment allocateArray(ValueLayout elementLayout, Addressable[] array) {\n-        Objects.requireNonNull(elementLayout);\n-        Objects.requireNonNull(array);\n-        Stream.of(array).forEach(Objects::requireNonNull);\n-        if (MemoryLayouts.ADDRESS.byteSize() != elementLayout.byteSize()) {\n-            throw new IllegalArgumentException(\"Layout size mismatch - \" + elementLayout.byteSize() + \" != \" + MemoryLayouts.ADDRESS.byteSize());\n-        }\n-        return switch ((int)elementLayout.byteSize()) {\n-            case 4 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToInt(a -> (int)a.address().toRawLongValue()).toArray(),\n-                    elementLayout, MemorySegment::ofArray);\n-            case 8 -> copyArrayWithSwapIfNeeded(Stream.of(array)\n-                            .mapToLong(a -> a.address().toRawLongValue()).toArray(),\n-                    elementLayout, MemorySegment::ofArray);\n-            default -> throw new UnsupportedOperationException(\"Unsupported pointer size\"); \/\/ should not get here\n-        };\n-    }\n-\n@@ -316,7 +288,4 @@\n-        Utils.checkPrimitiveCarrierCompat(array.getClass().componentType(), elementLayout);\n-        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(Array.getLength(array), elementLayout));\n-        if (elementLayout.byteSize() == 1 || (elementLayout.order() == ByteOrder.nativeOrder())) {\n-            addr.copyFrom(heapSegmentFactory.apply(array));\n-        } else {\n-            ((AbstractMemorySegmentImpl)addr).copyFromSwap(heapSegmentFactory.apply(array), elementLayout.byteSize());\n-        }\n+        int size = Array.getLength(array);\n+        MemorySegment addr = allocate(MemoryLayout.sequenceLayout(size, elementLayout));\n+        MemorySegment.copy(heapSegmentFactory.apply(array), elementLayout, 0,\n+                addr, elementLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n@@ -327,1 +296,1 @@\n-     * Allocate a block of memory  with given layout.\n+     * Allocate a memory segment with given layout.\n@@ -338,1 +307,1 @@\n-     * Allocate a block of memory corresponding to an array with given element layout and size.\n+     * Allocate a memory segment with given element layout and size.\n@@ -350,1 +319,2 @@\n-     * Allocate a block of memory with given size, with default alignment (1-byte aligned).\n+     * Allocate a memory segment with given size\n+     * and default alignment constraints (1-byte aligned).\n@@ -360,1 +330,1 @@\n-     * Allocate a block of memory  with given size and alignment constraint.\n+     * Allocate a memory segment with given size and alignment constraints.\n@@ -368,12 +338,5 @@\n-     * Returns a native arena-based allocator which allocates a single memory segment, of given size (using malloc),\n-     * and then responds to allocation request by returning different slices of that same segment\n-     * (until no further allocation is possible).\n-     * This can be useful when clients want to perform multiple allocation requests while avoiding the cost associated\n-     * with allocating a new off-heap memory region upon each allocation request.\n-     * <p>\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the allocator capacity.\n+     * Returns a native unbounded arena-based allocator, with predefined block size and maximum arena size,\n+     * associated with the provided scope. Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator.newNativeArena(Long.MAX_VALUE, predefinedBlockSize, scope);\n+     * }<\/pre><\/blockquote>\n@@ -381,4 +344,2 @@\n-     * @param size the size (in bytes) of the allocation arena.\n-     * @param scope the scope associated with the segments returned by this allocator.\n-     * @return a new bounded arena-based allocator\n-     * @throws IllegalArgumentException if {@code size <= 0}.\n+     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @return a new unbounded arena-based allocator\n@@ -388,5 +349,20 @@\n-    static SegmentAllocator arenaAllocator(long size, ResourceScope scope) {\n-        Objects.requireNonNull(scope);\n-        return scope.ownerThread() == null ?\n-                new ArenaAllocator.BoundedSharedArenaAllocator(scope, size) :\n-                new ArenaAllocator.BoundedArenaAllocator(scope, size);\n+    static SegmentAllocator newNativeArena(ResourceScope scope) {\n+        return newNativeArena(Long.MAX_VALUE, ArenaAllocator.DEFAULT_BLOCK_SIZE, scope);\n+    }\n+\n+    \/**\n+     * Returns a native unbounded arena-based allocator, with block size set to the specified arena size, associated with\n+     * the provided scope, with given arena size. Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    SegmentAllocator.newNativeArena(arenaSize, arenaSize, scope);\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n+     * @param scope the scope associated with the segments returned by the arena-based allocator.\n+     * @return a new unbounded arena-based allocator\n+     * @throws IllegalArgumentException if {@code arenaSize <= 0}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     *\/\n+    static SegmentAllocator newNativeArena(long arenaSize, ResourceScope scope) {\n+        return newNativeArena(arenaSize, arenaSize, scope);\n@@ -396,1 +372,1 @@\n-     * Returns a native unbounded arena-based allocator.\n+     * Returns a native arena-based allocator, associated with the provided scope, with given arena size and block size.\n@@ -398,2 +374,2 @@\n-     * The returned allocator allocates a memory segment {@code S} of a certain fixed size (using malloc) and then\n-     * responds to allocation requests in one of the following ways:\n+     * The returned allocator {@linkplain MemorySegment#allocateNative(long, ResourceScope) allocates} a memory segment\n+     * {@code S} of the specified block size and then responds to allocation requests in one of the following ways:\n@@ -404,1 +380,1 @@\n-     *     slices which fits that allocation request, allocate a new segment {@code S'} (using malloc), which has same size as {@code S}\n+     *     slices which fits that allocation request, allocate a new segment {@code S'}, which has same size as {@code S}\n@@ -406,2 +382,2 @@\n-     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'}\n-     *     (using malloc), which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n+     *     <li>if the size of the allocation requests is bigger than the size of {@code S}, allocate a new segment {@code S'},\n+     *     which has a sufficient size to satisfy the allocation request, and return {@code S'}.\n@@ -413,6 +389,3 @@\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n-     * The returned allocator might throw an {@link OutOfMemoryError} if an incoming allocation request exceeds\n-     * the system capacity.\n+     * The returned allocator might throw an {@link OutOfMemoryError} if the total memory allocated with this allocator\n+     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe.\n+     * Concurrent allocation needs to be guarded with synchronization primitives.\n@@ -420,1 +393,3 @@\n-     * @param scope the scope associated with the segments returned by this allocator.\n+     * @param arenaSize the size (in bytes) of the allocation arena.\n+     * @param blockSize the block size associated with the arena-based allocator.\n+     * @param scope the scope associated with the segments returned by the arena-based allocator.\n@@ -422,0 +397,1 @@\n+     * @throws IllegalArgumentException if {@code blockSize <= 0}, if {@code arenaSize <= 0} or if {@code arenaSize < blockSize}.\n@@ -425,1 +401,1 @@\n-    static SegmentAllocator arenaAllocator(ResourceScope scope) {\n+    static SegmentAllocator newNativeArena(long arenaSize, long blockSize, ResourceScope scope) {\n@@ -427,3 +403,7 @@\n-        return scope.ownerThread() == null ?\n-                new ArenaAllocator.UnboundedSharedArenaAllocator(scope) :\n-                new ArenaAllocator.UnboundedArenaAllocator(scope);\n+        if (blockSize <= 0) {\n+            throw new IllegalArgumentException(\"Invalid block size: \" + blockSize);\n+        }\n+        if (arenaSize <= 0 || arenaSize < blockSize) {\n+            throw new IllegalArgumentException(\"Invalid arena size: \" + arenaSize);\n+        }\n+        return new ArenaAllocator(blockSize, arenaSize, scope);\n@@ -435,1 +415,8 @@\n-     * constraints are ignored by this allocator). This can be useful to limit allocation requests in case a client\n+     * constraints are ignored by this allocator), hence the name <em>prefix allocator<\/em>.\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * <blockquote><pre>{@code\n+    MemorySegment segment = ...\n+    SegmentAllocator prefixAllocator = (size, align) -> segment.asSlice(0, size);\n+     * }<\/pre><\/blockquote>\n+     * <p>\n+     * This allocator can be useful to limit allocation requests in case a client\n@@ -445,1 +432,1 @@\n-    static SegmentAllocator ofSegment(MemorySegment segment) {\n+    static SegmentAllocator prefixAllocator(MemorySegment segment) {\n@@ -447,1 +434,1 @@\n-        return (size, align) -> segment.asSlice(0, size);\n+        return (AbstractMemorySegmentImpl)segment;\n@@ -451,3 +438,2 @@\n-     * Returns a native allocator which responds to allocation requests by allocating new segments\n-     * bound by the given resource scope, using the {@link MemorySegment#allocateNative(long, long, ResourceScope)}\n-     * factory. This code is equivalent (but likely more efficient) to the following:\n+     * Returns a native allocator, associated with the provided scope. Equivalent to (but likely more efficient than)\n+     * the following code:\n@@ -455,2 +441,2 @@\n-    Resource scope = ...\n-    SegmentAllocator scoped = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n+    ResourceScope scope = ...\n+    SegmentAllocator nativeAllocator = (size, align) -> MemorySegment.allocateNative(size, align, scope);\n@@ -459,2 +445,2 @@\n-     * @param scope the resource scope associated with the segments created by the returned allocator.\n-     * @return an allocator which allocates new memory segment bound by the provided resource scope.\n+     * @param scope the scope associated with the returned allocator.\n+     * @return a native allocator, associated with the provided scope.\n@@ -462,1 +448,1 @@\n-    static SegmentAllocator ofScope(ResourceScope scope) {\n+    static SegmentAllocator nativeAllocator(ResourceScope scope) {\n@@ -466,0 +452,18 @@\n+\n+    \/**\n+     * Returns a native allocator which allocates segments in independent {@linkplain ResourceScope#newImplicitScope() implicit scopes}.\n+     * Equivalent to (but likely more efficient than) the following code:\n+     * <blockquote><pre>{@code\n+    ResourceScope scope = ...\n+    SegmentAllocator implicitAllocator = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+     * }<\/pre><\/blockquote>\n+     *\n+     * @return a native allocator which allocates segments in independent {@linkplain ResourceScope#newImplicitScope() implicit scopes}.\n+     *\/\n+    static SegmentAllocator implicitAllocator() {\n+        class Holder {\n+            static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) ->\n+                    MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+        }\n+        return Holder.IMPLICIT_ALLOCATOR;\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":170,"deletions":166,"binary":false,"changes":336,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.lang.constant.Constable;\n@@ -31,1 +30,0 @@\n-import java.util.Map;\n@@ -38,1 +36,1 @@\n- * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the the sequence layout's <em>element count<\/em>.\n+ * The repetition count, where it exists (e.g. for <em>finite<\/em> sequence layouts) is said to be the sequence layout's <em>element count<\/em>.\n@@ -43,1 +41,1 @@\n-MemoryLayout.sequenceLayout(3, MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n+MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -50,3 +48,3 @@\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN),\n-    MemoryLayout.valueLayout(32, ByteOrder.BIG_ENDIAN));\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -75,1 +73,1 @@\n-        this(elemCount, elementLayout, elementLayout.bitAlignment(), Map.of());\n+        this(elemCount, elementLayout, elementLayout.bitAlignment(), Optional.empty());\n@@ -78,1 +76,1 @@\n-    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Map<String, Constable> attributes) {\n+    SequenceLayout(OptionalLong elemCount, MemoryLayout elementLayout, long alignment, Optional<String> name) {\n@@ -81,1 +79,1 @@\n-                OptionalLong.empty(), alignment, attributes);\n+                OptionalLong.empty(), alignment, name);\n@@ -113,1 +111,1 @@\n-        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, attributes);\n+        return new SequenceLayout(OptionalLong.of(elementCount), elementLayout, alignment, name());\n@@ -125,1 +123,1 @@\n-    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n@@ -129,1 +127,1 @@\n-    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, MemoryLayouts.JAVA_INT));\n+    var reshapeSeq = MemoryLayout.sequenceLayout(2, MemoryLayout.sequenceLayout(6, ValueLayout.JAVA_INT));\n@@ -154,1 +152,1 @@\n-        if (!elementCount().isPresent()) {\n+        if (elementCount().isEmpty()) {\n@@ -201,1 +199,1 @@\n-    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, MemoryLayouts.JAVA_INT));\n+    var seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(3, ValueLayout.JAVA_INT));\n@@ -205,1 +203,1 @@\n-    var flattenedSeq = MemoryLayout.sequenceLayout(12, MemoryLayouts.JAVA_INT);\n+    var flattenedSeq = MemoryLayout.sequenceLayout(12, ValueLayout.JAVA_INT);\n@@ -213,1 +211,1 @@\n-        if (!elementCount().isPresent()) {\n+        if (elementCount().isEmpty()) {\n@@ -218,2 +216,1 @@\n-        while (elemLayout instanceof SequenceLayout) {\n-            SequenceLayout elemSeq = (SequenceLayout)elemLayout;\n+        while (elemLayout instanceof SequenceLayout elemSeq) {\n@@ -244,1 +241,1 @@\n-        if (!(other instanceof SequenceLayout)) {\n+        if (!(other instanceof SequenceLayout s)) {\n@@ -247,1 +244,0 @@\n-        SequenceLayout s = (SequenceLayout)other;\n@@ -257,2 +253,2 @@\n-    SequenceLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new SequenceLayout(elementCount(), elementLayout, alignment, attributes);\n+    SequenceLayout dup(long alignment, Optional<String> name) {\n+        return new SequenceLayout(elementCount(), elementLayout, alignment, name);\n@@ -293,8 +289,0 @@\n-\n-    \/**\n-     * {@inheritDoc}\n-     *\/\n-    @Override\n-    public SequenceLayout withAttribute(String name, Constable value) {\n-        return (SequenceLayout)super.withAttribute(name, value);\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SequenceLayout.java","additions":19,"deletions":31,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -37,1 +38,1 @@\n- * A symbol lookup can be used to lookup a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n+ * A symbol lookup can be used to look up a symbol in a loaded library. Clients can obtain a {@linkplain #loaderLookup() loader lookup},\n@@ -40,2 +41,2 @@\n- * Alternatively, clients can obtain a {@linkplain CLinker#systemLookup() platform-dependent lookup}, to search symbols\n- * in the standard C library.\n+ * Alternatively, clients can search symbols in the standard C library using a {@link CLinker}, which conveniently\n+ * implements this interface.\n@@ -52,1 +53,1 @@\n-     * @return the memory address associated with the symbol (if any).\n+     * @return the lookup symbol (if any).\n@@ -54,1 +55,1 @@\n-    Optional<MemoryAddress> lookup(String name);\n+    Optional<NativeSymbol> lookup(String name);\n@@ -58,1 +59,3 @@\n-     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}).\n+     * (that is, libraries loaded using {@link System#loadLibrary} or {@link System#load}). The returned lookup\n+     * returns native symbols backed by a non-closeable, shared scope which keeps the caller's classloader\n+     * <a href=\"..\/..\/..\/java\/lang\/ref\/package.html#reachability\">reachable<\/a>.\n@@ -75,0 +78,1 @@\n+        ResourceScope loaderScope = ResourceScopeImpl.heapScope(loader);\n@@ -79,1 +83,1 @@\n-            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(addr);\n+            return addr == MemoryAddress.NULL? Optional.empty() : Optional.of(NativeSymbol.ofAddress(name, addr, loaderScope));\n@@ -82,0 +86,1 @@\n+\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SymbolLookup.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.incubator.foreign;\n+\n+import jdk.internal.foreign.abi.SharedUtils;\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64VaList;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64VaList;\n+import jdk.internal.foreign.abi.x64.sysv.SysVVaList;\n+import jdk.internal.foreign.abi.x64.windows.WinVaList;\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n+\n+import java.util.Objects;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * An interface that models a variable argument list, similar in functionality to a C {@code va_list}.\n+ * <p>\n+ * A variable argument list is a stateful cursor used to iterate over a set of arguments. A variable argument list\n+ * can be passed by reference e.g. to a {@linkplain CLinker#downcallHandle(FunctionDescriptor) downcall method handle}.\n+ * <p>\n+ * Per the C specification (see C standard 6.5.2.2 Function calls - item 6),\n+ * arguments to variadic calls are erased by way of 'default argument promotions',\n+ * which erases integral types by way of integer promotion (see C standard 6.3.1.1 - item 2),\n+ * and which erases all {@code float} arguments to {@code double}.\n+ * <p>\n+ * As such, this interface only supports reading {@code int}, {@code double},\n+ * and any other type that fits into a {@code long}.\n+ *\n+ * This class is not thread safe, and all accesses should occur within a single thread\n+ * (regardless of the scope associated with the variable arity list).\n+ *\n+ * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+ * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+ *\/\n+sealed public interface VaList extends Addressable permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, SharedUtils.EmptyVaList {\n+\n+    \/**\n+     * Reads the next value as an {@code int} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code int} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    int nextVarg(ValueLayout.OfInt layout);\n+\n+    \/**\n+     * Reads the next value as a {@code long} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code long} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    long nextVarg(ValueLayout.OfLong layout);\n+\n+    \/**\n+     * Reads the next value as a {@code double} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value\n+     * @return the {@code double} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    double nextVarg(ValueLayout.OfDouble layout);\n+\n+    \/**\n+     * Reads the next value as a {@code MemoryAddress} and advances this variable argument list's position.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @return the {@code MemoryAddress} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    MemoryAddress nextVarg(ValueLayout.OfAddress layout);\n+\n+    \/**\n+     * Reads the next value as a {@code MemorySegment}, and advances this variable argument list's position.\n+     * <p>\n+     * The memory segment returned by this method will be allocated using the given {@link SegmentAllocator}.\n+     *\n+     * @param layout the layout of the value to be read.\n+     * @param allocator the allocator to be used to create a segment where the contents of the variable argument list\n+     *                  will be copied.\n+     * @return the {@code MemorySegment} value read from this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator);\n+\n+    \/**\n+     * Skips a number of elements with the given memory layouts, and advances this variable argument list's position.\n+     *\n+     * @param layouts the layouts of the values to be skipped.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    void skip(MemoryLayout... layouts);\n+\n+    \/**\n+     * Returns the resource scope associated with this variable argument list.\n+     * @return the resource scope associated with this variable argument list.\n+     *\/\n+    ResourceScope scope();\n+\n+    \/**\n+     * Copies this variable argument list at its current position into a new variable argument list associated\n+     * with the same scope as this variable argument list. Copying is useful to\n+     * traverse the variable argument list elements, starting from the current position, without affecting the state\n+     * of the original variable argument list, essentially allowing the elements to be traversed multiple times.\n+     *\n+     * @return a copy of this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     *\/\n+    VaList copy();\n+\n+    \/**\n+     * Returns the memory address associated with this variable argument list.\n+     * @throws IllegalStateException if the scope associated with this variable argument list has been closed, or if access occurs from\n+     * a thread other than the thread owning that scope.\n+     * @return The memory address associated with this variable argument list.\n+     *\/\n+    @Override\n+    MemoryAddress address();\n+\n+    \/**\n+     * Constructs a new variable argument list from a memory address pointing to an existing variable argument list,\n+     * with given resource scope.\n+     * <p>\n+     * This method is <a href=\"package-summary.html#restricted\"><em>restricted<\/em><\/a>.\n+     * Restricted methods are unsafe, and, if used incorrectly, their use might crash\n+     * the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on\n+     * restricted methods, and use safe and supported functionalities, where possible.\n+     *\n+     * @param address a memory address pointing to an existing variable argument list.\n+     * @param scope the resource scope to be associated with the returned variable argument list.\n+     * @return a new variable argument list backed by the memory region at {@code address}.\n+     * @throws IllegalStateException if {@code scope} has been already closed, or if access occurs from a thread other\n+     * than the thread owning {@code scope}.\n+     * @throws IllegalCallerException if access to this method occurs from a module {@code M} and the command line option\n+     * {@code --enable-native-access} is either absent, or does not mention the module name {@code M}, or\n+     * {@code ALL-UNNAMED} in case {@code M} is an unnamed module.\n+     *\/\n+    @CallerSensitive\n+    static VaList ofAddress(MemoryAddress address, ResourceScope scope) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        Objects.requireNonNull(address);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaListOfAddress(address, scope);\n+    }\n+\n+    \/**\n+     * Constructs a new variable argument list using a builder (see {@link Builder}), with a given resource scope.\n+     * <p>\n+     * If this method needs to allocate native memory, such memory will be managed by the given\n+     * {@linkplain ResourceScope resource scope}, and will be released when the resource scope is {@linkplain ResourceScope#close closed}.\n+     * <p>\n+     * Note that when there are no elements added to the created va list,\n+     * this method will return the same as {@link #empty()}.\n+     *\n+     * @param actions a consumer for a builder (see {@link Builder}) which can be used to specify the elements\n+     *                of the underlying variable argument list.\n+     * @param scope scope the scope to be associated with the new variable arity list.\n+     * @return a new variable argument list.\n+     * @throws IllegalStateException if the scope associated with {@code allocator} has been already closed,\n+     * or if access occurs from a thread other than the thread owning that scope.\n+     *\/\n+    static VaList make(Consumer<Builder> actions, ResourceScope scope) {\n+        Objects.requireNonNull(actions);\n+        Objects.requireNonNull(scope);\n+        return SharedUtils.newVaList(actions, scope);\n+    }\n+\n+    \/**\n+     * Returns an empty variable argument list, associated with the {@linkplain ResourceScope#globalScope() global}\n+     * scope. The resulting variable argument list does not contain any argument, and throws {@link UnsupportedOperationException}\n+     * on all operations, except for {@link #scope()}, {@link #copy()} and {@link #address()}.\n+     * @return an empty variable argument list.\n+     *\/\n+    static VaList empty() {\n+        return SharedUtils.emptyVaList();\n+    }\n+\n+    \/**\n+     * A builder interface used to construct a variable argument list.\n+     *\n+     * <p> Unless otherwise specified, passing a {@code null} argument, or an array argument containing one or more {@code null}\n+     * elements to a method in this class causes a {@link NullPointerException NullPointerException} to be thrown. <\/p>\n+     *\/\n+    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder {\n+\n+        \/**\n+         * Writes an {@code int} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code int} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfInt layout, int value);\n+\n+        \/**\n+         * Writes a {@code long} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code long} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfLong layout, long value);\n+\n+        \/**\n+         * Writes a {@code double} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code double} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfDouble layout, double value);\n+\n+        \/**\n+         * Writes an {@code Addressable} value to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code Addressable} value to be written.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(ValueLayout.OfAddress layout, Addressable value);\n+\n+        \/**\n+         * Writes a {@code MemorySegment} value, with given layout, to the variable argument list being constructed.\n+         *\n+         * @param layout the layout of the value to be written.\n+         * @param value the {@code MemorySegment} whose contents will be copied.\n+         * @return this builder.\n+         *\/\n+        Builder addVarg(GroupLayout layout, MemorySegment value);\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/VaList.java","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -28,1 +28,6 @@\n-import java.lang.constant.Constable;\n+import jdk.internal.foreign.Utils;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.Stable;\n+import sun.invoke.util.Wrapper;\n+\n@@ -31,0 +36,1 @@\n+import java.lang.invoke.VarHandle;\n@@ -32,1 +38,0 @@\n-import java.util.Map;\n@@ -39,2 +44,8 @@\n- * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size and a byte order (see {@link ByteOrder}).\n- *\n+ * (either signed or unsigned) and <em>floating-point<\/em> types. Each value layout has a size, a {@linkplain ByteOrder byte order})\n+ * and a <em>carrier<\/em>, that is, the Java type that should be used when {@linkplain MemorySegment#get(OfInt, long) accessing}\n+ * a memory region using the value layout.\n+ * <p>\n+ * This class defines useful value layout constants for Java primitive types and addresses.\n+ * The layout constants in this class make implicit alignment and byte-ordering assumption: all layout\n+ * constants in this class are byte-aligned, and their byte order is set to the {@linkplain ByteOrder#nativeOrder() platform default},\n+ * thus making it easy to work with other APIs, such as arrays and {@link java.nio.ByteBuffer}.\n@@ -55,1 +66,1 @@\n-public final class ValueLayout extends AbstractLayout implements MemoryLayout {\n+public sealed class ValueLayout extends AbstractLayout implements MemoryLayout {\n@@ -57,0 +68,1 @@\n+    private final Class<?> carrier;\n@@ -59,2 +71,4 @@\n-    ValueLayout(ByteOrder order, long size) {\n-        this(order, size, size, Map.of());\n+    private final static int ADDRESS_SIZE_BITS = Unsafe.ADDRESS_SIZE * 8;\n+\n+    ValueLayout(Class<?> carrier, ByteOrder order, long size) {\n+        this(carrier, order, size, size, Optional.empty());\n@@ -63,2 +77,3 @@\n-    ValueLayout(ByteOrder order, long size, long alignment, Map<String, Constable> attributes) {\n-        super(OptionalLong.of(size), alignment, attributes);\n+    ValueLayout(Class<?> carrier, ByteOrder order, long size, long alignment, Optional<String> name) {\n+        super(OptionalLong.of(size), alignment, name);\n+        this.carrier = carrier;\n@@ -66,0 +81,1 @@\n+        checkCarrierSize(carrier, size);\n@@ -84,1 +100,1 @@\n-        return new ValueLayout(Objects.requireNonNull(order), bitSize(), alignment, attributes);\n+        return new ValueLayout(carrier, Objects.requireNonNull(order), bitSize(), alignment, name());\n@@ -102,1 +118,1 @@\n-        if (!(other instanceof ValueLayout)) {\n+        if (!(other instanceof ValueLayout v)) {\n@@ -105,2 +121,2 @@\n-        ValueLayout v = (ValueLayout)other;\n-        return order.equals(v.order) &&\n+        return carrier.equals(v.carrier) &&\n+            order.equals(v.order) &&\n@@ -111,0 +127,8 @@\n+    \/**\n+     * Returns the carrier associated with this value layout.\n+     * @return the carrier associated with this value layout.\n+     *\/\n+    public Class<?> carrier() {\n+        return carrier;\n+    }\n+\n@@ -117,2 +141,2 @@\n-    ValueLayout dup(long alignment, Map<String, Constable> attributes) {\n-        return new ValueLayout(order, bitSize(), alignment, attributes);\n+    ValueLayout dup(long alignment, Optional<String> name) {\n+        return new ValueLayout(carrier, order, bitSize(), alignment, name());\n@@ -124,1 +148,1 @@\n-                CD_VALUE_LAYOUT, MH_VALUE, bitSize(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n+                CD_VALUE_LAYOUT, MH_VALUE, carrier().describeConstable().get(), order == ByteOrder.BIG_ENDIAN ? BIG_ENDIAN : LITTLE_ENDIAN)));\n@@ -146,0 +170,39 @@\n+    static void checkCarrierSize(Class<?> carrier, long size) {\n+        if (!isValidCarrier(carrier)) {\n+            throw new IllegalArgumentException(\"Invalid carrier: \" + carrier.getName());\n+        }\n+        if (carrier == MemoryAddress.class && size != ADDRESS_SIZE_BITS) {\n+            throw new IllegalArgumentException(\"Address size mismatch: \" + ADDRESS_SIZE_BITS + \" != \" + size);\n+        }\n+        if (carrier.isPrimitive()) {\n+            int expectedSize =  carrier == boolean.class ? 8 : Wrapper.forPrimitiveType(carrier).bitWidth();\n+            if (size != expectedSize) {\n+                throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier.getName() + \" != \" + size);\n+            }\n+        }\n+    }\n+\n+    static boolean isValidCarrier(Class<?> carrier) {\n+        return carrier == boolean.class\n+                || carrier == byte.class\n+                || carrier == short.class\n+                || carrier == char.class\n+                || carrier == int.class\n+                || carrier == long.class\n+                || carrier == float.class\n+                || carrier == double.class\n+                || carrier == MemoryAddress.class;\n+    }\n+\n+    @Stable\n+    private VarHandle handle;\n+\n+    @ForceInline\n+    VarHandle accessHandle() {\n+        if (handle == null) {\n+            \/\/ this store to stable field is safe, because return value of 'makeMemoryAccessVarHandle' has stable identity\n+            handle = Utils.makeMemoryAccessVarHandle(this, false);\n+        }\n+        return handle;\n+    }\n+\n@@ -147,1 +210,1 @@\n-     * {@inheritDoc}\n+     * A value layout whose carrier is {@code boolean.class}.\n@@ -149,3 +212,63 @@\n-    @Override\n-    public ValueLayout withAttribute(String name, Constable value) {\n-        return (ValueLayout)super.withAttribute(name, value);\n+    public static final class OfBoolean extends ValueLayout {\n+        OfBoolean(ByteOrder order) {\n+            super(boolean.class, order, 8);\n+        }\n+\n+        OfBoolean(ByteOrder order, long alignment, Optional<String> name) {\n+            super(boolean.class, order, 8, alignment, name);\n+        }\n+\n+        @Override\n+        OfBoolean dup(long alignment, Optional<String> name) {\n+            return new OfBoolean(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfBoolean withName(String name) {\n+            return (OfBoolean)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfBoolean withBitAlignment(long alignmentBits) {\n+            return (OfBoolean)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfBoolean withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfBoolean(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code byte.class}.\n+     *\/\n+    public static final class OfByte extends ValueLayout {\n+        OfByte(ByteOrder order) {\n+            super(byte.class, order, 8);\n+        }\n+\n+        OfByte(ByteOrder order, long alignment, Optional<String> name) {\n+            super(byte.class, order, 8, alignment, name);\n+        }\n+\n+        @Override\n+        OfByte dup(long alignment, Optional<String> name) {\n+            return new OfByte(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfByte withName(String name) {\n+            return (OfByte)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfByte withBitAlignment(long alignmentBits) {\n+            return (OfByte)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfByte withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfByte(order, alignment, name());\n+        }\n@@ -153,0 +276,329 @@\n+\n+    \/**\n+     * A value layout whose carrier is {@code char.class}.\n+     *\/\n+    public static final class OfChar extends ValueLayout {\n+        OfChar(ByteOrder order) {\n+            super(char.class, order, 16);\n+        }\n+\n+        OfChar(ByteOrder order, long alignment, Optional<String> name) {\n+            super(char.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfChar dup(long alignment, Optional<String> name) {\n+            return new OfChar(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfChar withName(String name) {\n+            return (OfChar)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfChar withBitAlignment(long alignmentBits) {\n+            return (OfChar)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfChar withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfChar(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code short.class}.\n+     *\/\n+    public static final class OfShort extends ValueLayout {\n+        OfShort(ByteOrder order) {\n+            super(short.class, order, 16);\n+        }\n+\n+        OfShort(ByteOrder order, long alignment, Optional<String> name) {\n+            super(short.class, order, 16, alignment, name);\n+        }\n+\n+        @Override\n+        OfShort dup(long alignment, Optional<String> name) {\n+            return new OfShort(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfShort withName(String name) {\n+            return (OfShort)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfShort withBitAlignment(long alignmentBits) {\n+            return (OfShort)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfShort withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfShort(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code int.class}.\n+     *\/\n+    public static final class OfInt extends ValueLayout {\n+        OfInt(ByteOrder order) {\n+            super(int.class, order, 32);\n+        }\n+\n+        OfInt(ByteOrder order, long alignment, Optional<String> name) {\n+            super(int.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfInt dup(long alignment, Optional<String> name) {\n+            return new OfInt(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfInt withName(String name) {\n+            return (OfInt)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfInt withBitAlignment(long alignmentBits) {\n+            return (OfInt)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfInt withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfInt(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code float.class}.\n+     *\/\n+    public static final class OfFloat extends ValueLayout {\n+        OfFloat(ByteOrder order) {\n+            super(float.class, order, 32);\n+        }\n+\n+        OfFloat(ByteOrder order, long alignment, Optional<String> name) {\n+            super(float.class, order, 32, alignment, name);\n+        }\n+\n+        @Override\n+        OfFloat dup(long alignment, Optional<String> name) {\n+            return new OfFloat(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfFloat withName(String name) {\n+            return (OfFloat)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfFloat withBitAlignment(long alignmentBits) {\n+            return (OfFloat)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfFloat withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfFloat(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code long.class}.\n+     *\/\n+    public static final class OfLong extends ValueLayout {\n+        OfLong(ByteOrder order) {\n+            super(long.class, order, 64);\n+        }\n+\n+        OfLong(ByteOrder order, long alignment, Optional<String> name) {\n+            super(long.class, order, 64, alignment, name);\n+        }\n+\n+        @Override\n+        OfLong dup(long alignment, Optional<String> name) {\n+            return new OfLong(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfLong withName(String name) {\n+            return (OfLong)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfLong withBitAlignment(long alignmentBits) {\n+            return (OfLong)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfLong withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfLong(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code double.class}.\n+     *\/\n+    public static final class OfDouble extends ValueLayout {\n+        OfDouble(ByteOrder order) {\n+            super(double.class, order, 64);\n+        }\n+\n+        OfDouble(ByteOrder order, long alignment, Optional<String> name) {\n+            super(double.class, order, 64, alignment, name);\n+        }\n+\n+        @Override\n+        OfDouble dup(long alignment, Optional<String> name) {\n+            return new OfDouble(order(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfDouble withName(String name) {\n+            return (OfDouble)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfDouble withBitAlignment(long alignmentBits) {\n+            return (OfDouble)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfDouble withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfDouble(order, alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout whose carrier is {@code MemoryAddress.class}.\n+     *\/\n+    public static final class OfAddress extends ValueLayout {\n+        OfAddress(ByteOrder order) {\n+            super(MemoryAddress.class, order, ADDRESS_SIZE_BITS);\n+        }\n+\n+        OfAddress(ByteOrder order, long size, long alignment, Optional<String> name) {\n+            super(MemoryAddress.class, order, size, alignment, name);\n+        }\n+\n+        @Override\n+        OfAddress dup(long alignment, Optional<String> name) {\n+            return new OfAddress(order(), bitSize(), alignment, name);\n+        }\n+\n+        @Override\n+        public OfAddress withName(String name) {\n+            return (OfAddress)super.withName(name);\n+        }\n+\n+        @Override\n+        public OfAddress withBitAlignment(long alignmentBits) {\n+            return (OfAddress)super.withBitAlignment(alignmentBits);\n+        }\n+\n+        @Override\n+        public OfAddress withOrder(ByteOrder order) {\n+            Objects.requireNonNull(order);\n+            return new OfAddress(order, bitSize(), alignment, name());\n+        }\n+    }\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a machine address (e.g. {@code size_t}),\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(MemoryAddress.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfAddress ADDRESS = new OfAddress(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code byte},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(byte.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfByte JAVA_BYTE = new OfByte(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code boolean},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(boolean.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfBoolean JAVA_BOOLEAN = new OfBoolean(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code char},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(char.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfChar JAVA_CHAR = new OfChar(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code short},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(short.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfShort JAVA_SHORT = new OfShort(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code int},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(int.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfInt JAVA_INT = new OfInt(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code long},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(long.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfLong JAVA_LONG = new OfLong(ByteOrder.nativeOrder())\n+            .withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code float},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(float.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfFloat JAVA_FLOAT = new OfFloat(ByteOrder.nativeOrder()).withBitAlignment(8);\n+\n+    \/**\n+     * A value layout constant whose size is the same as that of a Java {@code double},\n+     * bit-alignment set to 8, and byte order set to {@link ByteOrder#nativeOrder()}.\n+     * Equivalent to the following code:\n+     * <blockquote><pre>{@code\n+    MemoryLayout.valueLayout(double.class, ByteOrder.nativeOrder()).withBitAlignment(8);\n+     * }<\/pre><\/blockquote>\n+     *\/\n+    public static final OfDouble JAVA_DOUBLE = new OfDouble(ByteOrder.nativeOrder()).withBitAlignment(8);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/ValueLayout.java","additions":472,"deletions":20,"binary":false,"changes":492,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n- * The key abstractions introduced to support foreign memory access are {@link jdk.incubator.foreign.MemorySegment} and {@link jdk.incubator.foreign.MemoryAddress}.\n- * The first models a contiguous memory region, which can reside either inside or outside the Java heap; the latter models an address - which also can\n- * reside either inside or outside the Java heap (and can sometimes be expressed as an offset into a given segment).\n+ * The main abstractions introduced to support foreign memory access is {@link jdk.incubator.foreign.MemorySegment}, which\n+ * models a contiguous memory region, which can reside either inside or outside the Java heap.\n@@ -38,1 +37,1 @@\n- * common dereference operations is provided also by the {@link jdk.incubator.foreign.MemoryAccess} class, which can\n+ * common dereference and copy operations is provided also by the {@link jdk.incubator.foreign.MemorySegment} class, which can\n@@ -50,1 +49,1 @@\n-   MemoryAccess.setIntAtIndex(segment, i, 42);\n+   segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n@@ -54,1 +53,1 @@\n- * Here create a <em>native<\/em> memory segment, that is, a memory segment backed by\n+ * This code creates a <em>native<\/em> memory segment, that is, a memory segment backed by\n@@ -57,3 +56,6 @@\n- * {@link jdk.incubator.foreign.MemoryAccess#setIntAtIndex(jdk.incubator.foreign.MemorySegment, long, int)} helper method;\n- * more specifically, if we view the memory segment as a set of 10 adjacent slots,\n- * {@code s[i]}, where {@code 0 <= i < 10}, where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n+ * {@link jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int)} dereference method. Note how\n+ * the dereference method accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout},\n+ * which specifies the size, alignment constraints, byte order as well\n+ * as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * if we view the memory segment as a set of 10 adjacent slots, {@code s[i]}, where {@code 0 <= i < 10},\n+ * where the size of each slot is exactly 4 bytes, the initialization logic above will set each slot\n@@ -75,1 +77,1 @@\n-        MemoryAccess.setIntAtIndex(segment, i, 42);\n+        segment.setAtIndex(ValueLayout.JAVA_INT, i, 42);\n@@ -99,3 +101,4 @@\n- * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup} and {@link jdk.incubator.foreign.CLinker}.\n- * The former is used to lookup symbols inside native libraries; the latter\n- * provides linking capabilities which allow to model foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n+ * The key abstractions introduced to support foreign function access are {@link jdk.incubator.foreign.SymbolLookup},\n+ * {@link jdk.incubator.foreign.MemoryAddress} and {@link jdk.incubator.foreign.CLinker}.\n+ * The first is used to lookup symbols inside native libraries; the second is used to model native addresses (more on that later),\n+ * while the third provides linking capabilities which allows modelling foreign functions as {@link java.lang.invoke.MethodHandle} instances,\n@@ -109,4 +112,4 @@\n-      MethodHandle strlen = CLinker.getInstance().downcallHandle(\n-        CLinker.systemLookup().lookup(\"strlen\").get(),\n-        MethodType.methodType(long.class, MemoryAddress.class),\n-        FunctionDescriptor.of(CLinker.C_LONG, CLinker.C_POINTER)\n+      var linker = CLinker.systemCLinker();\n+      MethodHandle strlen = linker.downcallHandle(\n+        linker.lookup(\"strlen\").get(),\n+        FunctionDescriptor.of(ValueLayout.JAVA_LONG, ValueLayout.ADDRESS)\n@@ -116,2 +119,3 @@\n-         var cString = CLinker.toCString(\"Hello\", scope);\n-         long len = (long)strlen.invokeExact(cString.address()); \/\/ 5\n+         var cString = MemorySegment.allocateNative(5 + 1, scope);\n+         cString.setUtf8String(\"Hello\");\n+         long len = (long)strlen.invoke(cString); \/\/ 5\n@@ -121,12 +125,13 @@\n- * Here, we lookup the {@code strlen} symbol in the {@linkplain jdk.incubator.foreign.CLinker#systemLookup() system lookup}.\n- * Then, we obtain a linker instance (see {@link jdk.incubator.foreign.CLinker#getInstance()}) and we use it to\n- * obtain a method handle which targets the {@code strlen} library symbol. To complete the linking successfully,\n- * we must provide (i) a {@link java.lang.invoke.MethodType} instance, describing the type of the resulting method handle\n- * and (ii) a {@link jdk.incubator.foreign.FunctionDescriptor} instance, describing the signature of the {@code strlen}\n- * function. From this information, the linker will uniquely determine the sequence of steps which will turn\n- * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invokeExact(java.lang.Object...)})\n- * into a foreign function call, according to the rules specified by the platform C ABI. The {@link jdk.incubator.foreign.CLinker}\n- * class also provides many useful methods for interacting with native code, such as converting Java strings into\n- * native strings and viceversa (see {@link jdk.incubator.foreign.CLinker#toCString(java.lang.String, ResourceScope)} and\n- * {@link jdk.incubator.foreign.CLinker#toJavaString(jdk.incubator.foreign.MemorySegment)}, respectively), as\n- * demonstrated in the above example.\n+ * Here, we obtain a {@linkplain jdk.incubator.foreign.CLinker#systemCLinker() linker instance} and we use it\n+ * to {@linkplain jdk.incubator.foreign.CLinker#lookup(java.lang.String) lookup} the {@code strlen} symbol in the\n+ * standard C library; a <em>downcall method handle<\/em> targeting said symbol is subsequently\n+ * {@linkplain jdk.incubator.foreign.CLinker#downcallHandle(jdk.incubator.foreign.FunctionDescriptor) obtained}.\n+ * To complete the linking successfully, we must provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance,\n+ * describing the signature of the {@code strlen} function.\n+ * From this information, the linker will uniquely determine the sequence of steps which will turn\n+ * the method handle invocation (here performed using {@link java.lang.invoke.MethodHandle#invoke(java.lang.Object...)})\n+ * into a foreign function call, according to the rules specified by the platform C ABI.\n+ * The {@link jdk.incubator.foreign.MemorySegment} class also provides many useful methods for\n+ * interacting with native code, such as converting Java strings into native strings and back\n+ * (see {@link jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String)} and\n+ * {@link jdk.incubator.foreign.MemorySegment#getUtf8String(long)}, respectively), as demonstrated in the above example.\n@@ -141,7 +146,4 @@\n- * When clients receive a {@link jdk.incubator.foreign.MemoryAddress} instance from a foreign function call, it might be\n- * necessary to obtain a {@link jdk.incubator.foreign.MemorySegment} instance to dereference the memory pointed to by that address.\n- * To do that, clients can proceed in three different ways, described below.\n- * <p>\n- * First, if the memory address is known to belong to a segment the client already owns, a <em>rebase<\/em> operation can be performed;\n- * in other words, the client can ask the address what its offset relative to a given segment is, and, then, proceed to dereference\n- * the original segment accordingly, as follows:\n+ * Raw pointers are modelled using the {@link jdk.incubator.foreign.MemoryAddress} class. When clients receive a\n+ * memory address instance from a foreign function call, they can perform memory dereference on it directly,\n+ * using one of the many <em>unsafe<\/em> dereference methods provided\n+ * (see {@link jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long)}):\n@@ -150,1 +152,0 @@\n-MemorySegment segment = MemorySegment.allocateNative(100, scope);\n@@ -153,1 +154,1 @@\n-int x = MemoryAccess.getIntAtOffset(segment, addr.segmentOffset(segment));\n+int x = addr.get(ValueLayout.JAVA_INT, 0);\n@@ -156,3 +157,3 @@\n- * Secondly, if the client does <em>not<\/em> have a segment which contains a given memory address, it can create one <em>unsafely<\/em>,\n- * using the {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} factory. This allows the client to\n- * inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n+ * Alternatively, the client can create a memory segment <em>unsafely<\/em>, using the\n+ * {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)} factory.\n+ * This allows the client to inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n@@ -164,11 +165,2 @@\n-MemorySegment segment = addr.asSegment(4, scope); \/\/ segment is 4 bytes long\n-int x = MemoryAccess.getInt(segment);\n- * }<\/pre>\n- *\n- * Alternatively, the client can fall back to use the so called <em>everything<\/em> segment - that is, a primordial segment\n- * which covers the entire native heap. This segment can be obtained by calling the {@link jdk.incubator.foreign.MemorySegment#globalNativeSegment()}\n- * method, so that dereference can happen without the need of creating any additional segment instances:\n- *\n- * <pre>{@code\n-MemoryAddress addr = ... \/\/obtain address from native code\n-int x = MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr.toRawLongValue());\n+MemorySegment segment = MemorySegment.ofAddressNative(addr, 4, scope); \/\/ segment is 4 bytes long\n+int x = segment.get(ValueLayout.JAVA_INT, 0);\n@@ -179,3 +171,2 @@\n- * to a Java method) into a native memory address (see {@link jdk.incubator.foreign.MemoryAddress}), so that Java code\n- * can effectively be passed to other foreign functions. For instance, we can write a method that compares two\n- * integer values, as follows:\n+ * to a Java method) into a memory address, so that Java code can effectively be passed to other foreign functions.\n+ * For instance, we can write a method that compares two integer values, as follows:\n@@ -186,2 +177,1 @@\n-        return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr1.toRawLongValue()) -\n-               MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), addr2.toRawLongValue());\n+        return addr1.get(ValueLayout.JAVA_INT, 0) - addr2.get(ValueLayout.JAVA_INT, 0);\n@@ -206,1 +196,1 @@\n-MemoryAddress comparFunc = CLinker.getInstance().upcallStub(\n+Addressable comparFunc = CLinker.systemCLinker().upcallStub(\n@@ -208,1 +198,1 @@\n-     FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+     FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS),\n@@ -214,3 +204,3 @@\n- * of the function pointer we want to create; as before, this, coupled with the method handle type, uniquely determines the\n- * sequence of steps which will allow foreign code to call {@code intCompareHandle} according to the rules specified\n- * by the platform C ABI. The lifecycle of the memory address returned by\n+ * of the function pointer we want to create; this descriptor allows the linker to determine the\n+ * sequence of steps which allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified\n+ * by the platform C ABI. The lifecycle of the stub returned by\n@@ -218,1 +208,2 @@\n- * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method.\n+ * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method. This\n+ * is made available by the {@link jdk.incubator.foreign.NativeSymbol} instance returned by that method.\n@@ -224,2 +215,2 @@\n- * the restricted method {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)} can be used to create\n- * a fresh segment with given spatial bounds out of a native address.\n+ * the restricted method {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)}\n+ * can be used to create a fresh segment with given spatial bounds out of a native address.\n@@ -228,2 +219,2 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemoryAddress#asSegment(long, ResourceScope)}, if the provided\n- * spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n+ * For instance, in the case of {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)},\n+ * if the provided spatial bounds are incorrect, a client of the segment returned by that method might crash the VM, or corrupt\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":61,"deletions":70,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -1,56 +0,0 @@\n-\/*\n- *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-package jdk.internal.foreign;\n-\n-import jdk.incubator.foreign.Addressable;\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.internal.foreign.abi.SharedUtils;\n-\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.Objects;\n-\n-public abstract non-sealed class AbstractCLinker implements CLinker {\n-\n-    public final MethodHandle downcallHandle(Addressable symbol, MethodType type, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        return MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-    }\n-\n-    public final MethodHandle downcallHandle(Addressable symbol, SegmentAllocator allocator, MethodType type, FunctionDescriptor function) {\n-        SharedUtils.checkSymbol(symbol);\n-        Objects.requireNonNull(allocator);\n-        MethodHandle downcall = MethodHandles.insertArguments(downcallHandle(type, function), 0, symbol);\n-        if (type.returnType().equals(MemorySegment.class)) {\n-            downcall = MethodHandles.insertArguments(downcall, 0, allocator);\n-        }\n-        return downcall;\n-    }\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractCLinker.java","additions":0,"deletions":56,"binary":false,"changes":56,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import java.nio.ByteOrder;\n@@ -46,0 +47,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -55,1 +58,1 @@\n-public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment {\n+public abstract non-sealed class AbstractMemorySegmentImpl extends MemorySegmentProxy implements MemorySegment, SegmentAllocator, Scoped {\n@@ -143,18 +146,3 @@\n-    public void copyFrom(MemorySegment src) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(src);\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copyMemory(scope, that.scope,\n-                that.base(), that.min(),\n-                base(), min(), size);\n-    }\n-\n-    public void copyFromSwap(MemorySegment src, long elemSize) {\n-        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)src;\n-        long size = that.byteSize();\n-        checkAccess(0, size, false);\n-        that.checkAccess(0, size, true);\n-        SCOPED_MEMORY_ACCESS.copySwapMemory(scope, that.scope,\n-                        that.base(), that.min(),\n-                        base(), min(), size, elemSize);\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return asSlice(0, bytesSize);\n@@ -178,1 +166,1 @@\n-            if (MemoryAccess.getByte(this) != MemoryAccess.getByte(that)) {\n+            if (get(JAVA_BYTE, 0) != that.get(JAVA_BYTE, 0)) {\n@@ -193,1 +181,1 @@\n-            if (MemoryAccess.getByteAtOffset(this, i) != MemoryAccess.getByteAtOffset(that, i)) {\n+            if (get(JAVA_BYTE, i) != that.get(JAVA_BYTE, i)) {\n@@ -233,3 +221,2 @@\n-    @ForceInline\n-    public final MemoryAddress address() {\n-        return new MemoryAddressImpl(this, 0L);\n+    public MemoryAddress address() {\n+        throw new UnsupportedOperationException(\"Cannot obtain address of on-heap segment\");\n@@ -272,0 +259,27 @@\n+    @Override\n+    public final MemorySegment asOverlappingSlice(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl)Objects.requireNonNull(other);\n+        if (base() == that.base()) {  \/\/ both either native or heap\n+            final long thisStart = this.min();\n+            final long thatStart = that.min();\n+            final long thisEnd = thisStart + this.byteSize();\n+            final long thatEnd = thatStart + that.byteSize();\n+\n+            if (thisStart < thatEnd && thisEnd > thatStart) {  \/\/overlap occurs\n+                long offsetToThat = this.segmentOffset(that);\n+                long newOffset = offsetToThat >= 0 ? offsetToThat : 0;\n+                return asSlice(newOffset, Math.min(this.byteSize() - newOffset, that.byteSize() + offsetToThat));\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public final long segmentOffset(MemorySegment other) {\n+        AbstractMemorySegmentImpl that = (AbstractMemorySegmentImpl) Objects.requireNonNull(other);\n+        if (base() == that.base()) {\n+            return that.min() - this.min();\n+        }\n+        throw new UnsupportedOperationException(\"Cannot compute offset from native to heap (or vice versa).\");\n+    }\n+\n@@ -293,2 +307,2 @@\n-    public final byte[] toByteArray() {\n-        return toArray(byte[].class, 1, byte[]::new, MemorySegment::ofArray);\n+    public final byte[] toArray(ValueLayout.OfByte elementLayout) {\n+        return toArray(byte[].class, elementLayout, byte[]::new, MemorySegment::ofArray);\n@@ -298,2 +312,2 @@\n-    public final short[] toShortArray() {\n-        return toArray(short[].class, 2, short[]::new, MemorySegment::ofArray);\n+    public final short[] toArray(ValueLayout.OfShort elementLayout) {\n+        return toArray(short[].class, elementLayout, short[]::new, MemorySegment::ofArray);\n@@ -303,2 +317,2 @@\n-    public final char[] toCharArray() {\n-        return toArray(char[].class, 2, char[]::new, MemorySegment::ofArray);\n+    public final char[] toArray(ValueLayout.OfChar elementLayout) {\n+        return toArray(char[].class, elementLayout, char[]::new, MemorySegment::ofArray);\n@@ -308,2 +322,2 @@\n-    public final int[] toIntArray() {\n-        return toArray(int[].class, 4, int[]::new, MemorySegment::ofArray);\n+    public final int[] toArray(ValueLayout.OfInt elementLayout) {\n+        return toArray(int[].class, elementLayout, int[]::new, MemorySegment::ofArray);\n@@ -313,2 +327,2 @@\n-    public final float[] toFloatArray() {\n-        return toArray(float[].class, 4, float[]::new, MemorySegment::ofArray);\n+    public final float[] toArray(ValueLayout.OfFloat elementLayout) {\n+        return toArray(float[].class, elementLayout, float[]::new, MemorySegment::ofArray);\n@@ -318,2 +332,2 @@\n-    public final long[] toLongArray() {\n-        return toArray(long[].class, 8, long[]::new, MemorySegment::ofArray);\n+    public final long[] toArray(ValueLayout.OfLong elementLayout) {\n+        return toArray(long[].class, elementLayout, long[]::new, MemorySegment::ofArray);\n@@ -323,2 +337,2 @@\n-    public final double[] toDoubleArray() {\n-        return toArray(double[].class, 8, double[]::new, MemorySegment::ofArray);\n+    public final double[] toArray(ValueLayout.OfDouble elementLayout) {\n+        return toArray(double[].class, elementLayout, double[]::new, MemorySegment::ofArray);\n@@ -327,2 +341,2 @@\n-    private <Z> Z toArray(Class<Z> arrayClass, int elemSize, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n-        int size = checkArraySize(arrayClass.getSimpleName(), elemSize);\n+    private <Z> Z toArray(Class<Z> arrayClass, ValueLayout elemLayout, IntFunction<Z> arrayFactory, Function<Z, MemorySegment> segmentFactory) {\n+        int size = checkArraySize(arrayClass.getSimpleName(), (int)elemLayout.byteSize());\n@@ -331,1 +345,1 @@\n-        arrSegment.copyFrom(this);\n+        MemorySegment.copy(this, elemLayout, 0, arrSegment, elemLayout.withOrder(ByteOrder.nativeOrder()), 0, size);\n@@ -385,2 +399,2 @@\n-                offset < Integer.MAX_VALUE && length < Integer.MAX_VALUE &&\n-                offset > Integer.MIN_VALUE && length > Integer.MIN_VALUE) {\n+                offset <= Integer.MAX_VALUE && length <= Integer.MAX_VALUE &&\n+                offset >= Integer.MIN_VALUE && length >= Integer.MIN_VALUE) {\n@@ -388,2 +402,3 @@\n-        } else {\n-            if (length < 0 ||\n+        } else if (this != NativeMemorySegmentImpl.EVERYTHING) { \/\/ oob not possible for everything segment\n+            if (\n+                    length < 0 ||\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":61,"deletions":46,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-public abstract class ArenaAllocator implements SegmentAllocator {\n+public final class ArenaAllocator implements SegmentAllocator {\n@@ -34,1 +34,1 @@\n-    protected MemorySegment segment;\n+    public static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n@@ -36,1 +36,1 @@\n-    protected long sp = 0L;\n+    private MemorySegment segment;\n@@ -38,2 +38,11 @@\n-    ArenaAllocator(MemorySegment segment) {\n-        this.segment = segment;\n+    private long sp = 0L;\n+    private long size = 0;\n+    private final long blockSize;\n+    private final long arenaSize;\n+    private final ResourceScope scope;\n+\n+    public ArenaAllocator(long blockSize, long arenaSize, ResourceScope scope) {\n+        this.blockSize = blockSize;\n+        this.arenaSize = arenaSize;\n+        this.scope = scope;\n+        this.segment = newSegment(blockSize, 1);\n@@ -54,5 +63,2 @@\n-    void checkConfinementIfNeeded() {\n-        Thread ownerThread = scope().ownerThread();\n-        if (ownerThread != null && ownerThread != Thread.currentThread()) {\n-            throw new IllegalStateException(\"Attempt to allocate outside confinement thread\");\n-        }\n+    public ResourceScope scope() {\n+        return scope;\n@@ -61,35 +67,4 @@\n-    ResourceScope scope() {\n-        return segment.scope();\n-    }\n-\n-    public static class UnboundedArenaAllocator extends ArenaAllocator {\n-\n-        private static final long DEFAULT_BLOCK_SIZE = 4 * 1024;\n-\n-        public UnboundedArenaAllocator(ResourceScope scope) {\n-            super(MemorySegment.allocateNative(DEFAULT_BLOCK_SIZE, 1, scope));\n-        }\n-\n-        private MemorySegment newSegment(long size, long align) {\n-            return MemorySegment.allocateNative(size, align, segment.scope());\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkConfinementIfNeeded();\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice != null) {\n-                return slice;\n-            } else {\n-                long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n-                if (maxPossibleAllocationSize > DEFAULT_BLOCK_SIZE) {\n-                    \/\/ too big\n-                    return newSegment(bytesSize, bytesAlignment);\n-                } else {\n-                    \/\/ allocate a new segment and slice from there\n-                    sp = 0L;\n-                    segment = newSegment(DEFAULT_BLOCK_SIZE, 1L);\n-                    return trySlice(bytesSize, bytesAlignment);\n-                }\n-            }\n+    private MemorySegment newSegment(long bytesSize, long bytesAlignment) {\n+        long allocatedSize = Utils.alignUp(bytesSize, bytesAlignment);\n+        if (size + allocatedSize > arenaSize) {\n+            throw new OutOfMemoryError();\n@@ -97,0 +72,2 @@\n+        size += allocatedSize;\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, scope);\n@@ -99,13 +76,11 @@\n-    public static class BoundedArenaAllocator extends ArenaAllocator {\n-\n-        public BoundedArenaAllocator(ResourceScope scope, long size) {\n-            super(MemorySegment.allocateNative(size, 1, scope));\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            checkConfinementIfNeeded();\n-            \/\/ try to slice from current segment first...\n-            MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n-            if (slice != null) {\n-                return slice;\n+    @Override\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        \/\/ try to slice from current segment first...\n+        MemorySegment slice = trySlice(bytesSize, bytesAlignment);\n+        if (slice != null) {\n+            return slice;\n+        } else {\n+            long maxPossibleAllocationSize = bytesSize + bytesAlignment - 1;\n+            if (maxPossibleAllocationSize > blockSize) {\n+                \/\/ too big\n+                return newSegment(bytesSize, bytesAlignment);\n@@ -113,24 +88,5 @@\n-                throw new OutOfMemoryError(\"Not enough space left to allocate\");\n-            }\n-        }\n-    }\n-\n-    public static class BoundedSharedArenaAllocator extends BoundedArenaAllocator {\n-        public BoundedSharedArenaAllocator(ResourceScope scope, long size) {\n-            super(scope, size);\n-        }\n-\n-        @Override\n-        public synchronized MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            return super.allocate(bytesSize, bytesAlignment);\n-        }\n-    }\n-\n-    public static class UnboundedSharedArenaAllocator implements SegmentAllocator {\n-\n-        final ResourceScope scope;\n-\n-        final ThreadLocal<ArenaAllocator> allocators = new ThreadLocal<>() {\n-            @Override\n-            protected ArenaAllocator initialValue() {\n-                return new UnboundedArenaAllocator(scope);\n+                \/\/ allocate a new segment and slice from there\n+                sp = 0L;\n+                segment = newSegment(blockSize, 1L);\n+                slice = trySlice(bytesSize, bytesAlignment);\n+                return slice;\n@@ -138,9 +94,0 @@\n-        };\n-\n-        public UnboundedSharedArenaAllocator(ResourceScope scope) {\n-            this.scope = scope;\n-        }\n-\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            return allocators.get().allocate(bytesSize, bytesAlignment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ArenaAllocator.java","additions":38,"deletions":91,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -28,3 +28,1 @@\n-import sun.security.action.GetPropertyAction;\n-\n-import static jdk.incubator.foreign.MemoryLayouts.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -31,0 +30,2 @@\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n@@ -32,1 +33,0 @@\n-import java.lang.ref.Reference;\n@@ -44,0 +44,1 @@\n+    private int asyncReleaseCount = 0;\n@@ -46,0 +47,10 @@\n+    static final VarHandle ASYNC_RELEASE_COUNT;\n+\n+    static {\n+        try {\n+            ASYNC_RELEASE_COUNT = MethodHandles.lookup().findVarHandle(ConfinedScope.class, \"asyncReleaseCount\", int.class);\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -47,1 +58,1 @@\n-        super(cleaner, new ConfinedResourceList());\n+        super(new ConfinedResourceList(), cleaner);\n@@ -67,1 +78,2 @@\n-    public HandleImpl acquire() {\n+    @ForceInline\n+    public void acquire0() {\n@@ -69,0 +81,3 @@\n+        if (lockCount == MAX_FORKS) {\n+            throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n+        }\n@@ -70,1 +85,14 @@\n-        return new ConfinedHandle();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        if (Thread.currentThread() == owner) {\n+            lockCount--;\n+        } else {\n+            \/\/ It is possible to end up here in two cases: this scope was kept alive by some other confined scope\n+            \/\/ which is implicitly released (in which case the release call comes from the cleaner thread). Or,\n+            \/\/ this scope might be kept alive by a shared scope, which means the release call can come from any\n+            \/\/ thread.\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n+        }\n@@ -75,1 +103,1 @@\n-        if (lockCount == 0) {\n+        if (lockCount == 0 || lockCount - ((int)ASYNC_RELEASE_COUNT.getVolatile(this)) == 0) {\n@@ -78,1 +106,1 @@\n-            throw new IllegalStateException(\"Scope is acquired by \" + lockCount + \" locks\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + lockCount + \" scopes\");\n@@ -112,21 +140,0 @@\n-\n-    \/**\n-     * A confined resource scope handle; no races are possible here.\n-     *\/\n-    final class ConfinedHandle implements HandleImpl {\n-        boolean released = false;\n-\n-        @Override\n-        public ResourceScopeImpl scope() {\n-            return ConfinedScope.this;\n-        }\n-\n-        @Override\n-        public void release() {\n-            checkValidState(); \/\/ thread check\n-            if (!released) {\n-                released = true;\n-                lockCount--;\n-            }\n-        }\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n@@ -56,1 +54,1 @@\n- * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle(Class)}).\n+ * given an address pointing to a segment associated with the root layout (see {@link #dereferenceHandle()}).\n@@ -60,2 +58,0 @@\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n@@ -159,2 +155,4 @@\n-    public VarHandle dereferenceHandle(Class<?> carrier) {\n-        Utils.checkPrimitiveCarrierCompat(carrier, layout);\n+    public VarHandle dereferenceHandle() {\n+        if (!(layout instanceof ValueLayout valueLayout)) {\n+            throw new IllegalArgumentException(\"Path does not select a value layout\");\n+        }\n@@ -168,2 +166,1 @@\n-        VarHandle handle = Utils.fixUpVarHandle(JLI.memoryAccessVarHandle(carrier, true, layout.byteAlignment() - 1,\n-                ((ValueLayout)layout).order()));\n+        VarHandle handle = Utils.makeMemoryAccessVarHandle(valueLayout, true);\n@@ -229,2 +226,1 @@\n-        } else if (enclosing.layout instanceof SequenceLayout) {\n-            SequenceLayout seq = (SequenceLayout)enclosing.layout;\n+        } else if (enclosing.layout instanceof SequenceLayout seq) {\n@@ -236,2 +232,1 @@\n-        } else if (enclosing.layout instanceof GroupLayout) {\n-            GroupLayout g = (GroupLayout)enclosing.layout;\n+        } else if (enclosing.layout instanceof GroupLayout g) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -30,0 +31,3 @@\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import jdk.internal.foreign.abi.SharedUtils;\n@@ -33,2 +37,1 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import java.util.Objects;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -40,1 +43,1 @@\n-public final class MemoryAddressImpl implements MemoryAddress {\n+public final class MemoryAddressImpl implements MemoryAddress, Scoped {\n@@ -42,1 +45,0 @@\n-    private final AbstractMemorySegmentImpl segment;\n@@ -45,2 +47,1 @@\n-    public MemoryAddressImpl(AbstractMemorySegmentImpl segment, long offset) {\n-        this.segment = segment;\n+    public MemoryAddressImpl(long offset) {\n@@ -50,2 +51,5 @@\n-    Object base() {\n-        return segment != null ? segment.base() : null;\n+    \/\/ MemoryAddress methods\n+\n+    @Override\n+    public MemoryAddress addOffset(long offset) {\n+        return new MemoryAddressImpl(this.offset + offset);\n@@ -54,3 +58,3 @@\n-    long offset() {\n-        return segment != null ?\n-                segment.min() + offset : offset;\n+    @Override\n+    public long toRawLongValue() {\n+        return offset;\n@@ -59,1 +63,34 @@\n-    \/\/ MemoryAddress methods\n+    @Override\n+    public final MemoryAddress address() {\n+        return this;\n+    }\n+\n+    \/\/ Object methods\n+\n+    @Override\n+    public int hashCode() {\n+        return (int) toRawLongValue();\n+    }\n+\n+    @Override\n+    public boolean equals(Object that) {\n+        return (that instanceof MemoryAddressImpl addressImpl &&\n+            offset == addressImpl.offset);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"MemoryAddress{ offset=0x\" + Long.toHexString(offset) + \" }\";\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value) {\n+        return ofLongUnchecked(value, Long.MAX_VALUE);\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, resourceScope);\n+    }\n+\n+    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n+        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, ResourceScopeImpl.GLOBAL);\n+    }\n@@ -63,2 +100,1 @@\n-        return segment != null ?\n-                segment.scope() : ResourceScope.globalScope();\n+        return ResourceScopeImpl.GLOBAL;\n@@ -68,2 +104,6 @@\n-    public MemoryAddress addOffset(long offset) {\n-        return new MemoryAddressImpl(segment, this.offset + offset);\n+    @CallerSensitive\n+    @ForceInline\n+    public String getUtf8String(long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkAddress(this);\n+        return NativeMemorySegmentImpl.EVERYTHING.getUtf8String(toRawLongValue() + offset);\n@@ -73,7 +113,6 @@\n-    public long segmentOffset(MemorySegment segment) {\n-        Objects.requireNonNull(segment);\n-        AbstractMemorySegmentImpl segmentImpl = (AbstractMemorySegmentImpl)segment;\n-        if (segmentImpl.base() != base()) {\n-            throw new IllegalArgumentException(\"Incompatible segment: \" + segment);\n-        }\n-        return offset() - segmentImpl.min();\n+    @CallerSensitive\n+    @ForceInline\n+    public void setUtf8String(long offset, String str) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        SharedUtils.checkAddress(this);\n+        NativeMemorySegmentImpl.EVERYTHING.setUtf8String(toRawLongValue() + offset, str);\n@@ -83,2 +122,5 @@\n-    public boolean isNative() {\n-        return base() == null;\n+    @ForceInline\n+    @CallerSensitive\n+    public byte get(ValueLayout.OfByte layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -88,8 +130,5 @@\n-    public long toRawLongValue() {\n-        if (segment != null) {\n-            if (segment.base() != null) {\n-                throw new UnsupportedOperationException(\"Not a native address\");\n-            }\n-            segment.checkValidState();\n-        }\n-        return offset();\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfByte layout, long offset, byte value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -98,1 +137,7 @@\n-    \/\/ Object methods\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public boolean get(ValueLayout.OfBoolean layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n@@ -101,2 +146,5 @@\n-    public int hashCode() {\n-        return Objects.hash(base(), offset());\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfBoolean layout, long offset, boolean value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -106,8 +154,5 @@\n-    public boolean equals(Object that) {\n-        if (that instanceof MemoryAddressImpl) {\n-            MemoryAddressImpl addr = (MemoryAddressImpl)that;\n-            return Objects.equals(base(), addr.base()) &&\n-                    offset() == addr.offset();\n-        } else {\n-            return false;\n-        }\n+    @ForceInline\n+    @CallerSensitive\n+    public char get(ValueLayout.OfChar layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -117,2 +162,5 @@\n-    public String toString() {\n-        return \"MemoryAddress{ base: \" + base() + \" offset=0x\" + Long.toHexString(offset()) + \" }\";\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfChar layout, long offset, char value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -122,0 +170,1 @@\n+    @ForceInline\n@@ -123,1 +172,1 @@\n-    public final MemorySegment asSegment(long bytesSize, ResourceScope scope) {\n+    public short get(ValueLayout.OfShort layout, long offset) {\n@@ -125,1 +174,1 @@\n-        return asSegment(bytesSize, null, scope);\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -129,0 +178,1 @@\n+    @ForceInline\n@@ -130,1 +180,1 @@\n-    public final MemorySegment asSegment(long bytesSize, Runnable cleanupAction, ResourceScope scope) {\n+    public void set(ValueLayout.OfShort layout, long offset, short value) {\n@@ -132,7 +182,1 @@\n-        Objects.requireNonNull(scope);\n-        if (bytesSize <= 0) {\n-            throw new IllegalArgumentException(\"Invalid size : \" + bytesSize);\n-        }\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(this, bytesSize,\n-                cleanupAction,\n-                (ResourceScopeImpl) scope);\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -141,2 +185,6 @@\n-    public static MemorySegment ofLongUnchecked(long value) {\n-        return ofLongUnchecked(value, Long.MAX_VALUE);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public int get(ValueLayout.OfInt layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n@@ -145,2 +193,6 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize, ResourceScopeImpl resourceScope) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, resourceScope);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfInt layout, long offset, int value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n@@ -149,2 +201,174 @@\n-    public static MemorySegment ofLongUnchecked(long value, long byteSize) {\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(value), byteSize, null, ResourceScopeImpl.GLOBAL);\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public float get(ValueLayout.OfFloat layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfFloat layout, long offset, float value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public long get(ValueLayout.OfLong layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfLong layout, long offset, long value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public double get(ValueLayout.OfDouble layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfDouble layout, long offset, double value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public MemoryAddress get(ValueLayout.OfAddress layout, long offset) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + offset);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void set(ValueLayout.OfAddress layout, long offset, Addressable value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + offset, value.address());\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public char getAtIndex(ValueLayout.OfChar layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfChar layout, long index, char value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public short getAtIndex(ValueLayout.OfShort layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfShort layout, long index, short value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public int getAtIndex(ValueLayout.OfInt layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfInt layout, long index, int value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public float getAtIndex(ValueLayout.OfFloat layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfFloat layout, long index, float value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public long getAtIndex(ValueLayout.OfLong layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfLong layout, long index, long value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public double getAtIndex(ValueLayout.OfDouble layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfDouble layout, long index, double value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value);\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public MemoryAddress getAtIndex(ValueLayout.OfAddress layout, long index) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        return NativeMemorySegmentImpl.EVERYTHING.get(layout, toRawLongValue() + (index * layout.byteSize()));\n+    }\n+\n+    @Override\n+    @ForceInline\n+    @CallerSensitive\n+    public void setAtIndex(ValueLayout.OfAddress layout, long index, Addressable value) {\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass());\n+        NativeMemorySegmentImpl.EVERYTHING.set(layout, toRawLongValue() + (index * layout.byteSize()), value.address());\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/MemoryAddressImpl.java","additions":286,"deletions":62,"binary":false,"changes":348,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -46,1 +44,1 @@\n-    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, null, ResourceScopeImpl.GLOBAL);\n+    public static final MemorySegment EVERYTHING = makeNativeSegmentUnchecked(MemoryAddress.NULL, Long.MAX_VALUE, ResourceScopeImpl.GLOBAL);\n@@ -50,2 +48,0 @@\n-    public static final SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n-\n@@ -66,0 +62,7 @@\n+    @ForceInline\n+    @Override\n+    public MemoryAddress address() {\n+        checkValidState();\n+        return MemoryAddress.ofLong(unsafeGetOffset());\n+    }\n+\n@@ -126,1 +129,1 @@\n-    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, Runnable cleanupAction, ResourceScopeImpl scope) {\n+    public static MemorySegment makeNativeSegmentUnchecked(MemoryAddress min, long bytesSize, ResourceScopeImpl scope) {\n@@ -129,3 +132,0 @@\n-        if (cleanupAction != null) {\n-            scope.addCloseAction(cleanupAction);\n-        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeMemorySegmentImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.  Oracle designates this\n+ *  particular file as subject to the \"Classpath\" exception as provided\n+ *  by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public record NativeSymbolImpl(String name, MemoryAddress address, ResourceScope scope) implements NativeSymbol, Scoped {\n+    @Override\n+    public MemoryAddress address() {\n+        ((ResourceScopeImpl)scope).checkValidState();\n+        return address;\n+    }\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/NativeSymbolImpl.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,4 +31,0 @@\n-import java.nio.ByteOrder;\n-\n-import static java.nio.ByteOrder.LITTLE_ENDIAN;\n-\n@@ -45,53 +40,0 @@\n-    public static MemoryLayout asVarArg(MemoryLayout ml) {\n-        return switch (CABI.current()) {\n-            case Win64 -> Win64.asVarArg(ml);\n-            case MacOsAArch64 -> AArch64.asVarArg(ml);\n-            default -> ml;\n-        };\n-    }\n-\n-    private static ValueLayout ofChar(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.CHAR);\n-    }\n-\n-    private static ValueLayout ofShort(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.SHORT);\n-    }\n-\n-    private static ValueLayout ofInt(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.INT);\n-    }\n-\n-    private static ValueLayout ofLong(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG);\n-    }\n-\n-    private static ValueLayout ofLongLong(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.LONG_LONG);\n-    }\n-\n-    private static ValueLayout ofFloat(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.FLOAT);\n-    }\n-\n-    private static ValueLayout ofDouble(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.DOUBLE);\n-    }\n-\n-    private static ValueLayout ofPointer(ByteOrder order, long bitSize) {\n-        return MemoryLayout.valueLayout(bitSize, order)\n-                .withAttribute(CLinker.TypeKind.ATTR_NAME, CLinker.TypeKind.POINTER);\n-    }\n-\n-    public static CLinker.TypeKind getKind(MemoryLayout layout) {\n-        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-            () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n-    }\n-\n@@ -106,0 +48,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n@@ -109,1 +56,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -114,1 +61,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -119,1 +66,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -124,1 +71,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -129,1 +76,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -134,1 +81,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -139,1 +86,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -144,1 +91,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -149,1 +96,1 @@\n-        public static final MemoryLayout C_VA_LIST = SysV.C_POINTER;\n+        public static final ValueLayout.OfAddress C_VA_LIST = SysV.C_POINTER;\n@@ -162,2 +109,1 @@\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()}) used to mark variadic parameters. The\n-         * attribute value must be a boolean.\n+         * The {@code bool} native type.\n@@ -165,1 +111,1 @@\n-        public static final String VARARGS_ATTRIBUTE_NAME = \"abi\/windows\/varargs\";\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n@@ -170,1 +116,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -175,1 +121,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -180,1 +126,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -184,1 +130,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_LONG = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -189,1 +135,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -194,1 +140,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -199,1 +145,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -204,1 +150,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -209,11 +155,1 @@\n-        public static final MemoryLayout C_VA_LIST = Win64.C_POINTER;\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be passed to a function.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for the extra attribute {@link #VARARGS_ATTRIBUTE_NAME},\n-         * which is set to {@code true}.\n-         *\/\n-        public static MemoryLayout asVarArg(MemoryLayout layout) {\n-            return layout.withAttribute(VARARGS_ATTRIBUTE_NAME, true);\n-        }\n+        public static final ValueLayout.OfAddress C_VA_LIST = Win64.C_POINTER;\n@@ -231,0 +167,5 @@\n+        \/**\n+         * The {@code bool} native type.\n+         *\/\n+        public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+\n@@ -234,1 +175,1 @@\n-        public static final ValueLayout C_CHAR = ofChar(LITTLE_ENDIAN, 8);\n+        public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n@@ -239,1 +180,1 @@\n-        public static final ValueLayout C_SHORT = ofShort(LITTLE_ENDIAN, 16);\n+        public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n@@ -244,1 +185,1 @@\n-        public static final ValueLayout C_INT = ofInt(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -249,1 +190,1 @@\n-        public static final ValueLayout C_LONG = ofLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -254,1 +195,1 @@\n-        public static final ValueLayout C_LONG_LONG = ofLongLong(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n@@ -259,1 +200,1 @@\n-        public static final ValueLayout C_FLOAT = ofFloat(LITTLE_ENDIAN, 32);\n+        public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n@@ -264,1 +205,1 @@\n-        public static final ValueLayout C_DOUBLE = ofDouble(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n@@ -269,1 +210,1 @@\n-        public static final ValueLayout C_POINTER = ofPointer(LITTLE_ENDIAN, 64);\n+        public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -274,21 +215,1 @@\n-        public static final MemoryLayout C_VA_LIST = AArch64.C_POINTER;\n-\n-        \/**\n-         * The name of the layout attribute (see {@link MemoryLayout#attributes()})\n-         * used to mark variadic parameters on systems such as macOS which pass these\n-         * entirely on the stack. The attribute value must be a boolean.\n-         *\/\n-        public final static String STACK_VARARGS_ATTRIBUTE_NAME = \"abi\/aarch64\/stack_varargs\";\n-\n-        \/**\n-         * Return a new memory layout which describes a variadic parameter to be\n-         * passed to a function. This is only required on platforms such as macOS\n-         * which pass variadic parameters entirely on the stack.\n-         * @param layout the original parameter layout.\n-         * @return a layout which is the same as {@code layout}, except for\n-         * the extra attribute {@link #STACK_VARARGS_ATTRIBUTE_NAME}, which is set\n-         * to {@code true}.\n-         *\/\n-        public static MemoryLayout asVarArg(MemoryLayout layout) {\n-            return layout.withAttribute(STACK_VARARGS_ATTRIBUTE_NAME, true);\n-        }\n+        public static final ValueLayout.OfAddress C_VA_LIST = AArch64.C_POINTER;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/PlatformLayouts.java","additions":39,"deletions":118,"binary":false,"changes":157,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.internal.ref.CleanerFactory;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -52,1 +52,1 @@\n-public abstract non-sealed class ResourceScopeImpl implements ResourceScope, ScopedMemoryAccess.Scope, SegmentAllocator {\n+public abstract non-sealed class ResourceScopeImpl implements ResourceScope, SegmentAllocator, ScopedMemoryAccess.Scope {\n@@ -55,0 +55,3 @@\n+    final Cleaner.Cleanable cleanable;\n+\n+    static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -62,5 +65,0 @@\n-    @Override\n-    public boolean isImplicit() {\n-        return false;\n-    }\n-\n@@ -94,1 +92,1 @@\n-    protected ResourceScopeImpl(Cleaner cleaner, ResourceList resourceList) {\n+    protected ResourceScopeImpl(ResourceList resourceList, Cleaner cleaner) {\n@@ -96,7 +94,2 @@\n-        if (cleaner != null) {\n-            cleaner.register(this, resourceList);\n-        }\n-    }\n-\n-    public static ResourceScopeImpl createImplicitScope() {\n-        return new ImplicitScopeImpl(CleanerFactory.cleaner());\n+        cleanable = (cleaner != null) ?\n+            cleaner.register(this, resourceList) : null;\n@@ -109,13 +102,0 @@\n-    \/**\n-     * Creates a confined memory scope with given attachment and cleanup action. The returned scope\n-     * is assumed to be confined on the current thread.\n-     * @return a confined memory scope\n-     *\/\n-    public static ResourceScopeImpl createConfined(Cleaner cleaner) {\n-        return new ConfinedScope(Thread.currentThread(), cleaner);\n-    }\n-\n-    \/**\n-     * Creates a shared memory scope with given attachment and cleanup action.\n-     * @return a shared memory scope\n-     *\/\n@@ -126,12 +106,0 @@\n-    private final void release0(HandleImpl handle) {\n-        try {\n-            Objects.requireNonNull(handle);\n-            if (handle.scope() != this) {\n-                throw new IllegalArgumentException(\"Cannot release an handle acquired from another scope\");\n-            }\n-            handle.release();\n-        } finally {\n-            Reference.reachabilityFence(this);\n-        }\n-    }\n-\n@@ -139,2 +107,2 @@\n-    public final void release(ResourceScope.Handle handle) {\n-        release0((HandleImpl)handle);\n+    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n+        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n@@ -143,4 +111,1 @@\n-    @Override\n-    public final void release(ScopedMemoryAccess.Scope.Handle handle) {\n-        release0((HandleImpl)handle);\n-    }\n+    public abstract void release0();\n@@ -148,2 +113,1 @@\n-    @Override\n-    public abstract HandleImpl acquire();\n+    public abstract void acquire0();\n@@ -151,9 +115,9 @@\n-    \/**\n-     * Internal interface used to implement resource scope handles.\n-     *\/\n-    public non-sealed interface HandleImpl extends ResourceScope.Handle, ScopedMemoryAccess.Scope.Handle {\n-\n-        @Override\n-        ResourceScopeImpl scope();\n-\n-        void release();\n+    @Override\n+    public void keepAlive(ResourceScope target) {\n+        Objects.requireNonNull(target);\n+        if (target == this) {\n+            throw new IllegalArgumentException(\"Invalid target scope.\");\n+        }\n+        ResourceScopeImpl targetImpl = (ResourceScopeImpl)target;\n+        targetImpl.acquire0();\n+        addCloseAction(targetImpl::release0);\n@@ -170,1 +134,5 @@\n-            resourceList.cleanup();\n+            if (cleanable != null) {\n+                cleanable.clean();\n+            } else {\n+                resourceList.cleanup();\n+            }\n@@ -218,11 +186,3 @@\n-     * Allocates a segment using this scope. Used by {@link SegmentAllocator#ofScope(ResourceScope)}.\n-     *\/\n-    @Override\n-    public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-        return MemorySegment.allocateNative(bytesSize, bytesAlignment, this);\n-    }\n-\n-    \/**\n-     * A non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n-     * In addition, non-closeable scopes feature a much simpler scheme for generating resource scope handles, where\n-     * the scope itself also acts as a resource scope handle and is returned by {@link #acquire()}.\n+     * The global, always alive, non-closeable, shared scope. Similar to a shared scope, but its {@link #close()} method throws unconditionally.\n+     * Adding new resources to the global scope, does nothing: as the scope can never become not-alive, there is nothing to track.\n+     * Acquiring and or releasing a resource scope similarly does nothing.\n@@ -230,1 +190,1 @@\n-    static class ImplicitScopeImpl extends SharedScope implements HandleImpl {\n+    static class GlobalScopeImpl extends SharedScope {\n@@ -232,3 +192,1 @@\n-        public ImplicitScopeImpl(Cleaner cleaner) {\n-            super(cleaner);\n-        }\n+        final Object ref;\n@@ -236,8 +194,3 @@\n-        @Override\n-        public HandleImpl acquire() {\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean isImplicit() {\n-            return true;\n+        public GlobalScopeImpl(Object ref) {\n+            super(null);\n+            this.ref = ref;\n@@ -252,1 +205,2 @@\n-        public void release() {\n+        @ForceInline\n+        public void release0() {\n@@ -257,2 +211,3 @@\n-        public ResourceScopeImpl scope() {\n-            return this;\n+        @ForceInline\n+        public void acquire0() {\n+            \/\/ do nothing\n@@ -260,1 +215,0 @@\n-    }\n@@ -262,6 +216,0 @@\n-    \/**\n-     * The global, always alive, non-closeable, shared scope. This is like a {@link ImplicitScopeImpl non-closeable scope},\n-     * except that the operation which adds new resources to the global scope does nothing: as the scope can never\n-     * become not-alive, there is nothing to track.\n-     *\/\n-    public static final ResourceScopeImpl GLOBAL = new ImplicitScopeImpl( null) {\n@@ -272,1 +220,7 @@\n-    };\n+    }\n+\n+    public static final ResourceScopeImpl GLOBAL = new GlobalScopeImpl(null);\n+\n+    public static ResourceScopeImpl heapScope(Object ref) {\n+        return new GlobalScopeImpl(ref);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ResourceScopeImpl.java","additions":46,"deletions":92,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.foreign;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+\n+public interface Scoped {\n+    ResourceScope scope();\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Scoped.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.ResourceScope;\n@@ -30,0 +29,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -34,2 +34,0 @@\n-import java.lang.ref.Reference;\n-import java.util.concurrent.atomic.AtomicBoolean;\n@@ -53,1 +51,0 @@\n-    private static final int MAX_FORKS = Integer.MAX_VALUE;\n@@ -68,1 +65,1 @@\n-        super(cleaner, new SharedResourceList());\n+        super(new SharedResourceList(), cleaner);\n@@ -84,1 +81,2 @@\n-    public HandleImpl acquire() {\n+    @ForceInline\n+    public void acquire0() {\n@@ -93,1 +91,1 @@\n-                throw new IllegalStateException(\"Segment acquire limit exceeded\");\n+                throw new IllegalStateException(\"Scope keep alive limit exceeded\");\n@@ -96,1 +94,13 @@\n-        return new SharedHandle();\n+    }\n+\n+    @Override\n+    @ForceInline\n+    public void release0() {\n+        int value;\n+        do {\n+            value = (int) STATE.getVolatile(this);\n+            if (value <= ALIVE) {\n+                \/\/cannot get here - we can't close segment twice\n+                throw new IllegalStateException(\"Already closed\");\n+            }\n+        } while (!STATE.compareAndSet(this, value, value - 1));\n@@ -104,1 +114,1 @@\n-            throw new IllegalStateException(\"Scope is acquired by \" + prevState + \" locks\");\n+            throw new IllegalStateException(\"Scope is kept alive by \" + prevState + \" scopes\");\n@@ -136,4 +146,2 @@\n-                ResourceCleanup prev = (ResourceCleanup) FST.getAcquire(this);\n-                cleanup.next = prev;\n-                ResourceCleanup newSegment = (ResourceCleanup) FST.compareAndExchangeRelease(this, prev, cleanup);\n-                if (newSegment == ResourceCleanup.CLOSED_LIST) {\n+                ResourceCleanup prev = (ResourceCleanup) FST.getVolatile(this);\n+                if (prev == ResourceCleanup.CLOSED_LIST) {\n@@ -142,1 +150,3 @@\n-                } else if (newSegment == prev) {\n+                }\n+                cleanup.next = prev;\n+                if (FST.compareAndSet(this, prev, cleanup)) {\n@@ -158,1 +168,1 @@\n-                    prev = (ResourceCleanup) FST.getAcquire(this);\n+                    prev = (ResourceCleanup) FST.getVolatile(this);\n@@ -160,1 +170,1 @@\n-                    if (FST.weakCompareAndSetRelease(this, prev, ResourceCleanup.CLOSED_LIST)) {\n+                    if (FST.compareAndSet(this, prev, ResourceCleanup.CLOSED_LIST)) {\n@@ -170,26 +180,0 @@\n-\n-    \/**\n-     * A shared resource scope handle; this implementation has to handle close vs. close races.\n-     *\/\n-    class SharedHandle implements HandleImpl {\n-        final AtomicBoolean released = new AtomicBoolean(false);\n-\n-        @Override\n-        public ResourceScopeImpl scope() {\n-            return SharedScope.this;\n-        }\n-\n-        @Override\n-        public void release() {\n-            if (released.compareAndSet(false, true)) {\n-                int value;\n-                do {\n-                    value = (int) STATE.getVolatile(jdk.internal.foreign.SharedScope.this);\n-                    if (value <= ALIVE) {\n-                        \/\/cannot get here - we can't close segment twice\n-                        throw new IllegalStateException(\"Already closed\");\n-                    }\n-                } while (!STATE.compareAndSet(jdk.internal.foreign.SharedScope.this, value, value - 1));\n-            }\n-        }\n-    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SharedScope.java","additions":26,"deletions":42,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -42,1 +42,1 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n@@ -74,2 +74,2 @@\n-            MemorySegment funcs = fallbackLibLookup.lookup(\"funcs\").orElseThrow()\n-                .asSegment(C_POINTER.byteSize() * numSymbols, ResourceScope.newImplicitScope());\n+            MemorySegment funcs = MemorySegment.ofAddressNative(fallbackLibLookup.lookup(\"funcs\").orElseThrow().address(),\n+                ADDRESS.byteSize() * numSymbols, ResourceScope.globalScope());\n@@ -78,1 +78,1 @@\n-                .map(symbol -> MemoryAccess.getAddressAtIndex(funcs, symbol.ordinal()));\n+                .map(symbol -> NativeSymbol.ofAddress(symbol.name(), funcs.getAtIndex(ADDRESS, symbol.ordinal()), ResourceScope.globalScope()));\n@@ -94,1 +94,2 @@\n-                        Optional.empty() : Optional.of(MemoryAddress.ofLong(addr));\n+                        Optional.empty() :\n+                        Optional.of(NativeSymbol.ofAddress(name, MemoryAddress.ofLong(addr), ResourceScope.globalScope()));\n@@ -102,1 +103,1 @@\n-    public Optional<MemoryAddress> lookup(String name) {\n+    public Optional<NativeSymbol> lookup(String name) {\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.access.SharedSecrets;\n@@ -31,2 +32,1 @@\n-import jdk.internal.misc.VM;\n-import sun.invoke.util.Wrapper;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -38,1 +38,2 @@\n-import java.util.Optional;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -41,0 +42,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -52,0 +54,4 @@\n+    private static final MethodHandle BYTE_TO_BOOL;\n+    private static final MethodHandle BOOL_TO_BYTE;\n+    private static final MethodHandle ADDRESS_TO_LONG;\n+    private static final MethodHandle LONG_TO_ADDRESS;\n@@ -62,0 +68,8 @@\n+            BYTE_TO_BOOL = lookup.findStatic(Utils.class, \"byteToBoolean\",\n+                    MethodType.methodType(boolean.class, byte.class));\n+            BOOL_TO_BYTE = lookup.findStatic(Utils.class, \"booleanToByte\",\n+                    MethodType.methodType(byte.class, boolean.class));\n+            ADDRESS_TO_LONG = lookup.findVirtual(MemoryAddress.class, \"toRawLongValue\",\n+                    MethodType.methodType(long.class));\n+            LONG_TO_ADDRESS = lookup.findStatic(MemoryAddress.class, \"ofLong\",\n+                    MethodType.methodType(MemoryAddress.class, long.class));\n@@ -94,1 +108,24 @@\n-    public static VarHandle fixUpVarHandle(VarHandle handle) {\n+    public static VarHandle makeMemoryAccessVarHandle(ValueLayout layout, boolean skipAlignmentCheck) {\n+        class VarHandleCache {\n+            private static final Map<ValueLayout, VarHandle> handleMap = new ConcurrentHashMap<>();\n+            private static final Map<ValueLayout, VarHandle> handleMapNoAlignCheck = new ConcurrentHashMap<>();\n+\n+            static VarHandle put(ValueLayout layout, VarHandle handle, boolean skipAlignmentCheck) {\n+                VarHandle prev = (skipAlignmentCheck ? handleMapNoAlignCheck : handleMap).putIfAbsent(layout, handle);\n+                return prev != null ? prev : handle;\n+            }\n+        }\n+        Class<?> baseCarrier = layout.carrier();\n+        if (layout.carrier() == MemoryAddress.class) {\n+            baseCarrier = switch ((int) ValueLayout.ADDRESS.byteSize()) {\n+                case 8 -> long.class;\n+                case 4 -> int.class;\n+                default -> throw new UnsupportedOperationException(\"Unsupported address layout\");\n+            };\n+        } else if (layout.carrier() == boolean.class) {\n+            baseCarrier = byte.class;\n+        }\n+\n+        VarHandle handle = SharedSecrets.getJavaLangInvokeAccess().memoryAccessVarHandle(baseCarrier, skipAlignmentCheck,\n+                layout.byteAlignment() - 1, layout.order());\n+\n@@ -97,1 +134,1 @@\n-        return SHOULD_ADAPT_HANDLES\n+        handle = SHOULD_ADAPT_HANDLES\n@@ -100,0 +137,8 @@\n+        if (layout.carrier() == boolean.class) {\n+            handle = MemoryHandles.filterValue(handle, BOOL_TO_BYTE, BYTE_TO_BOOL);\n+        } else if (layout.carrier() == MemoryAddress.class) {\n+            handle = MemoryHandles.filterValue(handle,\n+                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemoryAddress.class)),\n+                    MethodHandles.explicitCastArguments(LONG_TO_ADDRESS, MethodType.methodType(MemoryAddress.class, baseCarrier)));\n+        }\n+        return VarHandleCache.put(layout, handle, skipAlignmentCheck);\n@@ -106,6 +151,12 @@\n-    public static void checkPrimitiveCarrierCompat(Class<?> carrier, MemoryLayout layout) {\n-        checkLayoutType(layout, ValueLayout.class);\n-        if (!isValidPrimitiveCarrier(carrier))\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier);\n-        if (Wrapper.forPrimitiveType(carrier).bitWidth() != layout.bitSize())\n-            throw new IllegalArgumentException(\"Carrier size mismatch: \" + carrier + \" != \" + layout);\n+    private static boolean byteToBoolean(byte b) {\n+        return b != 0;\n+    }\n+\n+    private static byte booleanToByte(boolean b) {\n+        return b ? (byte)1 : (byte)0;\n+    }\n+\n+    public static void copy(MemorySegment addr, byte[] bytes) {\n+        var heapSegment = MemorySegment.ofArray(bytes);\n+        addr.copyFrom(heapSegment);\n+        addr.set(JAVA_BYTE, bytes.length, (byte)0);\n@@ -114,8 +165,4 @@\n-    public static boolean isValidPrimitiveCarrier(Class<?> carrier) {\n-        return carrier == byte.class\n-            || carrier == short.class\n-            || carrier == char.class\n-            || carrier == int.class\n-            || carrier == long.class\n-            || carrier == float.class\n-            || carrier == double.class;\n+    public static MemorySegment toCString(byte[] bytes, SegmentAllocator allocator) {\n+        MemorySegment addr = allocator.allocate(bytes.length + 1, 1L);\n+        copy(addr, bytes);\n+        return addr;\n@@ -124,3 +171,4 @@\n-    public static void checkLayoutType(MemoryLayout layout, Class<? extends MemoryLayout> layoutType) {\n-        if (!layoutType.isInstance(layout))\n-            throw new IllegalArgumentException(\"Expected a \" + layoutType.getSimpleName() + \": \" + layout);\n+    @ForceInline\n+    public static long scaleOffset(MemorySegment segment, long index, long size) {\n+        \/\/ note: we know size is a small value (as it comes from ValueLayout::byteSize())\n+        return MemorySegmentProxy.multiplyOffsets(index, (int)size, (AbstractMemorySegmentImpl)segment);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":70,"deletions":22,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -33,0 +34,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +40,1 @@\n+import java.lang.invoke.MethodType;\n@@ -207,1 +210,0 @@\n-    private static final MethodHandle MH_BASE_ADDRESS;\n@@ -219,2 +221,0 @@\n-            MH_BASE_ADDRESS = lookup.findVirtual(MemorySegment.class, \"address\",\n-                    methodType(MemoryAddress.class));\n@@ -265,1 +265,1 @@\n-            return new Context(SegmentAllocator.arenaAllocator(size, scope), scope);\n+            return new Context(SegmentAllocator.newNativeArena(size, scope), scope);\n@@ -324,1 +324,0 @@\n-        BASE_ADDRESS,\n@@ -347,1 +346,1 @@\n-        if (!type.isPrimitive() || type == void.class || type == boolean.class)\n+        if (!type.isPrimitive() || type == void.class)\n@@ -391,1 +390,1 @@\n-        return UnboxAddress.INSTANCE;\n+        return UnboxAddress.INSTANCE.get(MemoryAddress.class);\n@@ -394,2 +393,2 @@\n-    public static BaseAddress baseAddress() {\n-        return BaseAddress.INSTANCE;\n+    public static UnboxAddress unboxAddress(Class<?> carrier) {\n+        return UnboxAddress.INSTANCE.get(carrier);\n@@ -470,2 +469,2 @@\n-        public Binding.Builder baseAddress() {\n-            bindings.add(Binding.baseAddress());\n+        public Binding.Builder unboxAddress(Class<?> carrier) {\n+            bindings.add(Binding.unboxAddress(carrier));\n@@ -633,1 +632,2 @@\n-            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(type, 1, ByteOrder.nativeOrder()), 1, offset);\n+            ValueLayout layout = MemoryLayout.valueLayout(type(), ByteOrder.nativeOrder()).withBitAlignment(8);\n+            return MemoryHandles.insertCoordinates(MemoryHandles.varHandle(layout), 1, offset);\n@@ -743,3 +743,2 @@\n-            MemorySegment copy = context.allocator().allocate(size, alignment);\n-            copy.copyFrom(operand.asSlice(0, size));\n-            return copy;\n+            return context.allocator().allocate(size, alignment)\n+                            .copyFrom(operand.asSlice(0, size));\n@@ -878,2 +877,12 @@\n-        private static final UnboxAddress INSTANCE = new UnboxAddress();\n-        private UnboxAddress() {\n+\n+        static final ClassValue<UnboxAddress> INSTANCE = new ClassValue<>() {\n+            @Override\n+            protected UnboxAddress computeValue(Class<?> type) {\n+                return new UnboxAddress(type);\n+            }\n+        };\n+\n+        final Class<?> carrier;\n+        final MethodHandle toAddress;\n+\n+        private UnboxAddress(Class<?> carrier) {\n@@ -881,0 +890,6 @@\n+            this.carrier = carrier;\n+            try {\n+                this.toAddress = MethodHandles.lookup().findVirtual(carrier, \"address\", MethodType.methodType(MemoryAddress.class));\n+            } catch (Throwable ex) {\n+                throw new IllegalArgumentException(ex);\n+            }\n@@ -886,1 +901,1 @@\n-            SharedUtils.checkType(actualType, MemoryAddress.class);\n+            SharedUtils.checkType(actualType, carrier);\n@@ -893,1 +908,1 @@\n-            stack.push(((MemoryAddress)stack.pop()).toRawLongValue());\n+            stack.push(((Addressable)stack.pop()).address().toRawLongValue());\n@@ -898,1 +913,2 @@\n-            return filterArguments(specializedHandle, insertPos, MH_UNBOX_ADDRESS);\n+            return filterArguments(specializedHandle, insertPos,\n+                    MethodHandles.filterReturnValue(toAddress, MH_UNBOX_ADDRESS));\n@@ -942,35 +958,0 @@\n-    \/**\n-     * BASE_ADDRESS()\n-     *   Pops a MemorySegment from the operand stack, and takes the base address of the segment\n-     *   (the MemoryAddress that points to the start), and pushes that onto the operand stack\n-     *\/\n-    public static class BaseAddress extends Binding {\n-        private static final BaseAddress INSTANCE = new BaseAddress();\n-        private BaseAddress() {\n-            super(Tag.BASE_ADDRESS);\n-        }\n-\n-        @Override\n-        public void verify(Deque<Class<?>> stack) {\n-            Class<?> actualType = stack.pop();\n-            SharedUtils.checkType(actualType, MemorySegment.class);\n-            stack.push(MemoryAddress.class);\n-        }\n-\n-        @Override\n-        public void interpret(Deque<Object> stack, BindingInterpreter.StoreFunc storeFunc,\n-                              BindingInterpreter.LoadFunc loadFunc, Context context) {\n-            stack.push(((MemorySegment) stack.pop()).address());\n-        }\n-\n-        @Override\n-        public MethodHandle specialize(MethodHandle specializedHandle, int insertPos, int allocatorPos) {\n-            return filterArguments(specializedHandle, insertPos, MH_BASE_ADDRESS);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"BaseAddress{}\";\n-        }\n-    }\n-\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/Binding.java","additions":36,"deletions":55,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -37,1 +37,1 @@\n-    static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/BufferLayout.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import java.util.stream.IntStream;\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequence.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-        BASE_ADDRESS,\n@@ -132,1 +131,0 @@\n-        \/\/BASE_ADDRESS,\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/CallingSequenceBuilder.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -43,1 +43,0 @@\n-import java.lang.ref.Reference;\n@@ -73,1 +72,1 @@\n-    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -90,1 +89,1 @@\n-                    methodType(Object.class, Addressable.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n+                    methodType(Object.class, NativeSymbol.class, SegmentAllocator.class, Object[].class, MethodHandle.class, Map.class, Map.class));\n@@ -93,1 +92,1 @@\n-            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, Addressable.class));\n+            MH_ADDR_TO_LONG = lookup.findStatic(ProgrammableInvoker.class, \"unboxTargetAddress\", methodType(long.class, NativeSymbol.class));\n@@ -175,3 +174,3 @@\n-    private static long unboxTargetAddress(Addressable addr) {\n-        MemoryAddress ma = SharedUtils.checkSymbol(addr);\n-        return ma.toRawLongValue();\n+    private static long unboxTargetAddress(NativeSymbol addr) {\n+        SharedUtils.checkSymbol(addr);\n+        return addr.address().toRawLongValue();\n@@ -315,1 +314,1 @@\n-    Object invokeInterpBindings(Addressable address, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n+    Object invokeInterpBindings(NativeSymbol symbol, SegmentAllocator allocator, Object[] args, MethodHandle leaf,\n@@ -324,1 +323,1 @@\n-            leafArgs[0] = address; \/\/ addr\n+            leafArgs[0] = symbol; \/\/ symbol\n@@ -329,1 +328,1 @@\n-                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip addr\n+                            leafArgs[argIndexMap.get(storage) + 1] = value; \/\/ +1 to skip symbol\n@@ -335,4 +334,0 @@\n-            \/\/ make sure arguments are reachable during the call\n-            \/\/ technically we only need to do all Addressable parameters here\n-            Reference.reachabilityFence(address);\n-            Reference.reachabilityFence(args);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableInvoker.java","additions":11,"deletions":16,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -32,3 +32,1 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n-import jdk.internal.access.JavaLangInvokeAccess;\n-import jdk.internal.access.SharedSecrets;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -49,0 +47,1 @@\n+import static java.lang.invoke.MethodHandles.exactInvoker;\n@@ -70,3 +69,1 @@\n-    private static final JavaLangInvokeAccess JLI = SharedSecrets.getJavaLangInvokeAccess();\n-\n-    private static final VarHandle VH_LONG = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n+    private static final VarHandle VH_LONG = ValueLayout.JAVA_LONG.varHandle();\n@@ -91,1 +88,1 @@\n-    public static UpcallHandler make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence) {\n+    public static NativeSymbol make(ABIDescriptor abi, MethodHandle target, CallingSequence callingSequence, ResourceScope scope) {\n@@ -126,1 +123,1 @@\n-            JLI.ensureCustomized(doBindings);\n+            doBindings = insertArguments(exactInvoker(doBindings.type()), 0, doBindings);\n@@ -137,1 +134,1 @@\n-        return () -> entryPoint;\n+        return UpcallStubs.makeUpcall(entryPoint, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/ProgrammableUpcallHandler.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -35,0 +34,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -38,1 +38,1 @@\n-import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.VaList;\n@@ -41,0 +41,1 @@\n+import jdk.internal.access.JavaLangInvokeAccess;\n@@ -42,0 +43,1 @@\n+import jdk.internal.foreign.Scoped;\n@@ -44,0 +46,1 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n@@ -49,0 +52,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -55,1 +59,0 @@\n-import java.nio.charset.Charset;\n@@ -57,0 +60,1 @@\n+import java.util.ArrayList;\n@@ -62,0 +66,1 @@\n+import java.util.function.UnaryOperator;\n@@ -70,1 +75,1 @@\n-import static java.lang.invoke.MethodHandles.filterArguments;\n+import static java.lang.invoke.MethodHandles.foldArguments;\n@@ -76,1 +81,9 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -81,0 +94,1 @@\n+    private static final JavaLangInvokeAccess JLIA = SharedSecrets.getJavaLangInvokeAccess();\n@@ -90,0 +104,2 @@\n+    private static final MethodHandle ACQUIRE_MH;\n+    private static final MethodHandle RELEASE_MH;\n@@ -110,0 +126,4 @@\n+            ACQUIRE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"acquire\",\n+                    MethodType.methodType(void.class, Scoped[].class));\n+            RELEASE_MH = MethodHandles.lookup().findStatic(SharedUtils.class, \"release\",\n+                    MethodType.methodType(void.class, Scoped[].class));\n@@ -116,1 +136,3 @@\n-    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> { throw new IllegalStateException(\"Cannot get here\"); };\n+    public static final SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new IllegalStateException(\"Cannot get here\");\n+    };\n@@ -228,28 +250,0 @@\n-    public static void checkCompatibleType(Class<?> carrier, MemoryLayout layout, long addressSize) {\n-        if (carrier.isPrimitive()) {\n-            Utils.checkPrimitiveCarrierCompat(carrier, layout);\n-        } else if (carrier == MemoryAddress.class) {\n-            Utils.checkLayoutType(layout, ValueLayout.class);\n-            if (layout.bitSize() != addressSize)\n-                throw new IllegalArgumentException(\"Address size mismatch: \" + addressSize + \" != \" + layout.bitSize());\n-        } else if (carrier == MemorySegment.class) {\n-            Utils.checkLayoutType(layout, GroupLayout.class);\n-        } else {\n-            throw new IllegalArgumentException(\"Unsupported carrier: \" + carrier);\n-        }\n-    }\n-\n-    public static void checkFunctionTypes(MethodType mt, FunctionDescriptor cDesc, long addressSize) {\n-        if (mt.returnType() == void.class != cDesc.returnLayout().isEmpty())\n-            throw new IllegalArgumentException(\"Return type mismatch: \" + mt + \" != \" + cDesc);\n-        List<MemoryLayout> argLayouts = cDesc.argumentLayouts();\n-        if (mt.parameterCount() != argLayouts.size())\n-            throw new IllegalArgumentException(\"Arity mismatch: \" + mt + \" != \" + cDesc);\n-\n-        int paramCount = mt.parameterCount();\n-        for (int i = 0; i < paramCount; i++) {\n-            checkCompatibleType(mt.parameterType(i), argLayouts.get(i), addressSize);\n-        }\n-        cDesc.returnLayout().ifPresent(rl -> checkCompatibleType(mt.returnType(), rl, addressSize));\n-    }\n-\n@@ -290,2 +284,1 @@\n-        MemorySegment.ofArray(bytes)\n-                .copyFrom(segment.asSlice(start, len));\n+        MemorySegment.copy(segment, JAVA_BYTE, start, bytes, 0, len);\n@@ -298,1 +291,1 @@\n-            byte curr = MemoryAccess.getByteAtOffset(segment, start + offset);\n+            byte curr = segment.get(JAVA_BYTE, start + offset);\n@@ -395,1 +388,5 @@\n-            closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            if (!upcall) {\n+                closer = dropArguments(closer, 0, Throwable.class); \/\/ (Throwable, V) -> V\n+            } else {\n+                closer = collectArguments(closer, 0, MH_HANDLE_UNCAUGHT_EXCEPTION); \/\/ (Throwable, V) -> V\n+            }\n@@ -399,1 +396,1 @@\n-        \/\/ downcalls get the leading Addressable\/SegmentAllocator param as well\n+        \/\/ downcalls get the leading NativeSymbol\/SegmentAllocator param as well\n@@ -401,2 +398,2 @@\n-            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(Addressable.class));\n-            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, Addressable, SegmentAllocator) -> V\/void\n+            closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(NativeSymbol.class));\n+            closer = dropArguments(closer, insertPos++, SegmentAllocator.class); \/\/ (Throwable, V?, NativeSymbol, SegmentAllocator) -> V\/void\n@@ -405,15 +402,1 @@\n-        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, Addressable?, BindingContext) -> V\/void\n-\n-        if (!upcall) {\n-            \/\/ now for each Addressable parameter, add a reachability fence\n-            MethodType specType = specializedHandle.type();\n-            \/\/ skip 3 for address, segment allocator, and binding context\n-            for (int i = 3; i < specType.parameterCount(); i++) {\n-                Class<?> param = specType.parameterType(i);\n-                if (Addressable.class.isAssignableFrom(param)) {\n-                    closer = collectArguments(closer, insertPos++, reachabilityFenceHandle(param));\n-                } else {\n-                    closer = dropArguments(closer, insertPos++, param);\n-                }\n-            }\n-        }\n+        closer = collectArguments(closer, insertPos++, MH_CLOSE_CONTEXT); \/\/ (Throwable, V?, NativeSymbol?, BindingContext) -> V\/void\n@@ -437,0 +420,141 @@\n+    @ForceInline\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void acquire(Scoped[] args) {\n+        ResourceScope scope4 = null;\n+        ResourceScope scope3 = null;\n+        ResourceScope scope2 = null;\n+        ResourceScope scope1 = null;\n+        ResourceScope scope0 = null;\n+        switch (args.length) {\n+            default:\n+                \/\/ slow path, acquire all remaining addressable parameters in isolation\n+                for (int i = 5 ; i < args.length ; i++) {\n+                    acquire(args[i].scope());\n+                }\n+            \/\/ fast path, acquire only scopes not seen in other parameters\n+            case 5:\n+                scope4 = args[4].scope();\n+                acquire(scope4);\n+            case 4:\n+                scope3 = args[3].scope();\n+                if (scope3 != scope4)\n+                    acquire(scope3);\n+            case 3:\n+                scope2 = args[2].scope();\n+                if (scope2 != scope3 && scope2 != scope4)\n+                    acquire(scope2);\n+            case 2:\n+                scope1 = args[1].scope();\n+                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n+                    acquire(scope1);\n+            case 1:\n+                scope0 = args[0].scope();\n+                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n+                    acquire(scope0);\n+            case 0: break;\n+        }\n+    }\n+\n+    @ForceInline\n+    @SuppressWarnings(\"fallthrough\")\n+    public static void release(Scoped[] args) {\n+        ResourceScope scope4 = null;\n+        ResourceScope scope3 = null;\n+        ResourceScope scope2 = null;\n+        ResourceScope scope1 = null;\n+        ResourceScope scope0 = null;\n+        switch (args.length) {\n+            default:\n+                \/\/ slow path, release all remaining addressable parameters in isolation\n+                for (int i = 5 ; i < args.length ; i++) {\n+                    release(args[i].scope());\n+                }\n+            \/\/ fast path, release only scopes not seen in other parameters\n+            case 5:\n+                scope4 = args[4].scope();\n+                release(scope4);\n+            case 4:\n+                scope3 = args[3].scope();\n+                if (scope3 != scope4)\n+                    release(scope3);\n+            case 3:\n+                scope2 = args[2].scope();\n+                if (scope2 != scope3 && scope2 != scope4)\n+                    release(scope2);\n+            case 2:\n+                scope1 = args[1].scope();\n+                if (scope1 != scope2 && scope1 != scope3 && scope1 != scope4)\n+                    release(scope1);\n+            case 1:\n+                scope0 = args[0].scope();\n+                if (scope0 != scope1 && scope0 != scope2 && scope0 != scope3 && scope0 != scope4)\n+                    release(scope0);\n+            case 0: break;\n+        }\n+    }\n+\n+    @ForceInline\n+    private static void acquire(ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).acquire0();\n+    }\n+\n+    @ForceInline\n+    private static void release(ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).release0();\n+    }\n+\n+    \/*\n+     * This method adds a try\/finally block to a downcall method handle, to make sure that all by-reference\n+     * parameters (including the target address of the native function) are kept alive for the duration of\n+     * the downcall.\n+     *\/\n+    public static MethodHandle wrapDowncall(MethodHandle downcallHandle, FunctionDescriptor descriptor) {\n+        boolean hasReturn = descriptor.returnLayout().isPresent();\n+        MethodHandle tryBlock = downcallHandle;\n+        MethodHandle cleanup = hasReturn ?\n+                MethodHandles.identity(downcallHandle.type().returnType()) :\n+                MethodHandles.empty(MethodType.methodType(void.class));\n+        int addressableCount = 0;\n+        List<UnaryOperator<MethodHandle>> adapters = new ArrayList<>();\n+        for (int i = 0 ; i < downcallHandle.type().parameterCount() ; i++) {\n+            Class<?> ptype = downcallHandle.type().parameterType(i);\n+            if (ptype == Addressable.class || ptype == NativeSymbol.class) {\n+                addressableCount++;\n+            } else {\n+                int pos = i;\n+                adapters.add(mh -> dropArguments(mh, pos, ptype));\n+            }\n+        }\n+\n+        if (addressableCount > 0) {\n+            cleanup = dropArguments(cleanup, 0, Throwable.class);\n+\n+            MethodType adapterType = MethodType.methodType(void.class);\n+            for (int i = 0 ; i < addressableCount ; i++) {\n+                adapterType = adapterType.appendParameterTypes(i == 0 ? NativeSymbol.class : Addressable.class);\n+            }\n+\n+            MethodHandle acquireHandle = ACQUIRE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n+            MethodHandle releaseHandle = RELEASE_MH.asCollector(Scoped[].class, addressableCount).asType(adapterType);\n+\n+            for (UnaryOperator<MethodHandle> adapter : adapters) {\n+                acquireHandle = adapter.apply(acquireHandle);\n+                releaseHandle = adapter.apply(releaseHandle);\n+            }\n+\n+            tryBlock = foldArguments(tryBlock, acquireHandle);\n+            cleanup = collectArguments(cleanup, hasReturn ? 2 : 1, releaseHandle);\n+\n+            return tryFinally(tryBlock, cleanup);\n+        } else {\n+            return downcallHandle;\n+        }\n+    }\n+\n+    public static void checkExceptions(MethodHandle target) {\n+        Class<?>[] exceptions = JLIA.exceptionTypes(target);\n+        if (exceptions != null && exceptions.length != 0) {\n+            throw new IllegalArgumentException(\"Target handle may throw exceptions: \" + Arrays.toString(exceptions));\n+        }\n+    }\n+\n@@ -442,3 +566,2 @@\n-        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n-                        MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+        static final MethodHandle MH_MALLOC = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"malloc\").get(),\n+                FunctionDescriptor.of(ADDRESS, JAVA_LONG));\n@@ -446,3 +569,2 @@\n-        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n-                        MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER));\n+        static final MethodHandle MH_FREE = SYS_LINKER.downcallHandle(CLinker.systemCLinker().lookup(\"free\").get(),\n+                FunctionDescriptor.ofVoid(ADDRESS));\n@@ -451,2 +573,2 @@\n-    public static MemoryAddress checkSymbol(Addressable symbol) {\n-        return checkAddressable(symbol, \"Symbol is NULL\");\n+    public static void checkSymbol(NativeSymbol symbol) {\n+        checkAddressable(symbol, \"Symbol is NULL\");\n@@ -455,2 +577,2 @@\n-    public static MemoryAddress checkAddress(MemoryAddress address) {\n-        return checkAddressable(address, \"Address is NULL\");\n+    public static void checkAddress(MemoryAddress address) {\n+        checkAddressable(address, \"Address is NULL\");\n@@ -459,1 +581,1 @@\n-    private static MemoryAddress checkAddressable(Addressable symbol, String msg) {\n+    private static void checkAddressable(Addressable symbol, String msg) {\n@@ -461,4 +583,2 @@\n-        MemoryAddress symbolAddr = symbol.address();\n-        if (symbolAddr.equals(MemoryAddress.NULL))\n-            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbolAddr);\n-        return symbolAddr;\n+        if (symbol.address().toRawLongValue() == 0)\n+            throw new IllegalArgumentException(\"Symbol is NULL: \" + symbol);\n@@ -477,1 +597,1 @@\n-            AllocHolder.MH_FREE.invokeExact(addr);\n+            AllocHolder.MH_FREE.invokeExact((Addressable)addr);\n@@ -492,6 +612,0 @@\n-    public static VarHandle vhPrimitiveOrAddress(Class<?> carrier, MemoryLayout layout) {\n-        return carrier == MemoryAddress.class\n-            ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n-            : layout.varHandle(carrier);\n-    }\n-\n@@ -516,28 +630,0 @@\n-    public static MethodType convertVaListCarriers(MethodType mt, Class<?> carrier) {\n-        Class<?>[] params = new Class<?>[mt.parameterCount()];\n-        for (int i = 0; i < params.length; i++) {\n-            Class<?> pType = mt.parameterType(i);\n-            params[i] = ((pType == VaList.class) ? carrier : pType);\n-        }\n-        return methodType(mt.returnType(), params);\n-    }\n-\n-    public static MethodHandle unboxVaLists(MethodType type, MethodHandle handle, MethodHandle unboxer) {\n-        for (int i = 0; i < type.parameterCount(); i++) {\n-            if (type.parameterType(i) == VaList.class) {\n-               handle = filterArguments(handle, i + 1, unboxer); \/\/ +1 for leading address\n-            }\n-        }\n-        return handle;\n-    }\n-\n-    public static MethodHandle boxVaLists(MethodHandle handle, MethodHandle boxer) {\n-        MethodType type = handle.type();\n-        for (int i = 0; i < type.parameterCount(); i++) {\n-            if (type.parameterType(i) == VaList.class) {\n-               handle = filterArguments(handle, i, boxer);\n-            }\n-        }\n-        return handle;\n-    }\n-\n@@ -552,3 +638,6 @@\n-        return cDesc.attribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME)\n-                .map(Boolean.class::cast)\n-                .orElse(false);\n+        return false; \/\/ FIXME: use system property?\n+    }\n+\n+    public static boolean isVarargsIndex(FunctionDescriptor descriptor, int argIndex) {\n+        int firstPos = descriptor.firstVariadicArgumentIndex();\n+        return firstPos != -1 && argIndex >= firstPos;\n@@ -569,3 +658,1 @@\n-            return carrier == MemoryAddress.class\n-                ? MemoryHandles.asAddressVarHandle(layout.varHandle(primitiveCarrierForSize(layout.byteSize(), false)))\n-                : layout.varHandle(carrier);\n+            return layout.varHandle();\n@@ -575,1 +662,1 @@\n-    public static non-sealed class EmptyVaList implements VaList {\n+    public static non-sealed class EmptyVaList implements VaList, Scoped {\n@@ -588,6 +675,1 @@\n-        public int vargAsInt(MemoryLayout layout) {\n-            throw uoe();\n-        }\n-\n-        @Override\n-        public long vargAsLong(MemoryLayout layout) {\n+        public int nextVarg(ValueLayout.OfInt layout) {\n@@ -598,1 +680,1 @@\n-        public double vargAsDouble(MemoryLayout layout) {\n+        public long nextVarg(ValueLayout.OfLong layout) {\n@@ -603,1 +685,1 @@\n-        public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+        public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -608,1 +690,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+        public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -613,1 +695,1 @@\n-        public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n+        public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -641,1 +723,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            ptr.set(JAVA_LONG, 0, (long) o);\n@@ -643,1 +725,1 @@\n-            MemoryAccess.setLong(ptr, (int) o);\n+            ptr.set(JAVA_LONG, 0, (int) o);\n@@ -645,1 +727,1 @@\n-            MemoryAccess.setLong(ptr, (short) o);\n+            ptr.set(JAVA_LONG, 0, (short) o);\n@@ -647,1 +729,1 @@\n-            MemoryAccess.setLong(ptr, (char) o);\n+            ptr.set(JAVA_LONG, 0, (char) o);\n@@ -649,1 +731,1 @@\n-            MemoryAccess.setLong(ptr, (byte) o);\n+            ptr.set(JAVA_LONG, 0, (byte) o);\n@@ -651,1 +733,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            ptr.set(JAVA_FLOAT, 0, (float) o);\n@@ -653,1 +735,3 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            ptr.set(JAVA_DOUBLE, 0, (double) o);\n+        } else if (type == boolean.class) {\n+            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n@@ -661,1 +745,1 @@\n-            MemoryAccess.setLong(ptr, (long) o);\n+            ptr.set(JAVA_LONG, 0, (long) o);\n@@ -663,1 +747,1 @@\n-            MemoryAccess.setInt(ptr, (int) o);\n+            ptr.set(JAVA_INT, 0, (int) o);\n@@ -665,1 +749,1 @@\n-            MemoryAccess.setShort(ptr, (short) o);\n+            ptr.set(JAVA_SHORT, 0, (short) o);\n@@ -667,1 +751,1 @@\n-            MemoryAccess.setChar(ptr, (char) o);\n+            ptr.set(JAVA_CHAR, 0, (char) o);\n@@ -669,1 +753,1 @@\n-            MemoryAccess.setByte(ptr, (byte) o);\n+            ptr.set(JAVA_BYTE, 0, (byte) o);\n@@ -671,1 +755,1 @@\n-            MemoryAccess.setFloat(ptr, (float) o);\n+            ptr.set(JAVA_FLOAT, 0, (float) o);\n@@ -673,1 +757,3 @@\n-            MemoryAccess.setDouble(ptr, (double) o);\n+            ptr.set(JAVA_DOUBLE, 0, (double) o);\n+        } else if (type == boolean.class) {\n+            ptr.set(JAVA_BOOLEAN, 0, (boolean) o);\n@@ -681,1 +767,1 @@\n-            return MemoryAccess.getLong(ptr);\n+            return ptr.get(JAVA_LONG, 0);\n@@ -683,1 +769,1 @@\n-            return MemoryAccess.getInt(ptr);\n+            return ptr.get(JAVA_INT, 0);\n@@ -685,1 +771,1 @@\n-            return MemoryAccess.getShort(ptr);\n+            return ptr.get(JAVA_SHORT, 0);\n@@ -687,1 +773,1 @@\n-            return MemoryAccess.getChar(ptr);\n+            return ptr.get(JAVA_CHAR, 0);\n@@ -689,1 +775,1 @@\n-            return MemoryAccess.getByte(ptr);\n+            return ptr.get(JAVA_BYTE, 0);\n@@ -691,1 +777,1 @@\n-            return MemoryAccess.getFloat(ptr);\n+            return ptr.get(JAVA_FLOAT, 0);\n@@ -693,1 +779,3 @@\n-            return MemoryAccess.getDouble(ptr);\n+            return ptr.get(JAVA_DOUBLE, 0);\n+        } else if (type == boolean.class) {\n+            return ptr.get(JAVA_BOOLEAN, 0);\n@@ -698,0 +786,20 @@\n+\n+    public static MethodType inferMethodType(FunctionDescriptor descriptor, boolean upcall) {\n+        MethodType type = MethodType.methodType(descriptor.returnLayout().isPresent() ?\n+                carrierFor(descriptor.returnLayout().get(), upcall) : void.class);\n+        for (MemoryLayout argLayout : descriptor.argumentLayouts()) {\n+            type = type.appendParameterTypes(carrierFor(argLayout, !upcall));\n+        }\n+        return type;\n+    }\n+\n+    static Class<?> carrierFor(MemoryLayout layout, boolean forArg) {\n+        if (layout instanceof ValueLayout valueLayout) {\n+            return (forArg && valueLayout.carrier().equals(MemoryAddress.class)) ?\n+                    Addressable.class : valueLayout.carrier();\n+        } else if (layout instanceof GroupLayout) {\n+            return MemorySegment.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported layout: \" + layout);\n+        }\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":253,"deletions":145,"binary":false,"changes":398,"status":"modified"},{"patch":"@@ -1,30 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.  Oracle designates this\n- *  particular file as subject to the \"Classpath\" exception as provided\n- *  by Oracle in the LICENSE file that accompanied this code.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-package jdk.internal.foreign.abi;\n-\n-public interface UpcallHandler {\n-    long entryPoint();\n-}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallHandler.java","additions":0,"deletions":30,"binary":false,"changes":30,"status":"deleted"},{"patch":"@@ -28,1 +28,3 @@\n-import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.internal.foreign.NativeSymbolImpl;\n@@ -30,1 +32,0 @@\n-import jdk.internal.foreign.NativeMemorySegmentImpl;\n@@ -34,6 +35,0 @@\n-    public static MemoryAddress upcallAddress(UpcallHandler handler, ResourceScopeImpl scope) {\n-        long stubAddress = handler.entryPoint();\n-        return NativeMemorySegmentImpl.makeNativeSegmentUnchecked(MemoryAddress.ofLong(stubAddress), 0,\n-                () -> freeUpcallStub(stubAddress), scope).address();\n-    }\n-\n@@ -55,0 +50,10 @@\n+\n+    static NativeSymbol makeUpcall(long entry, ResourceScope scope) {\n+        ((ResourceScopeImpl)scope).addOrCleanupIfFail(new ResourceScopeImpl.ResourceList.ResourceCleanup() {\n+            @Override\n+            public void cleanup() {\n+                freeUpcallStub(entry);\n+            }\n+        });\n+        return new NativeSymbolImpl(\"upcall:\" + Long.toHexString(entry), MemoryAddress.ofLong(entry), scope);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/UpcallStubs.java","additions":13,"deletions":8,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -35,1 +37,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -43,0 +44,2 @@\n+import jdk.internal.foreign.abi.aarch64.linux.LinuxAArch64CallArranger;\n+import jdk.internal.foreign.abi.aarch64.macos.MacOsAArch64CallArranger;\n@@ -57,0 +60,4 @@\n+ *\n+ * There are minor differences between the ABIs implemented on Linux, macOS, and Windows\n+ * which are handled in sub-classes. Clients should access these through the provided\n+ * public constants CallArranger.LINUX and CallArranger.MACOS.\n@@ -58,1 +65,1 @@\n-public class CallArranger {\n+public abstract class CallArranger {\n@@ -98,2 +105,12 @@\n-    public static Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n-        SharedUtils.checkFunctionTypes(mt, cDesc, AArch64.C_POINTER.bitSize());\n+    public static final CallArranger LINUX = new LinuxAArch64CallArranger();\n+    public static final CallArranger MACOS = new MacOsAArch64CallArranger();\n+\n+    \/**\n+     * Are variadic arguments assigned to registers as in the standard calling\n+     * convention, or always passed on the stack?\n+     *\n+     * @returns true if variadic arguments should be spilled to the stack.\n+     *\/\n+    protected abstract boolean varArgsOnStack();\n+\n+    protected CallArranger() {}\n@@ -101,0 +118,1 @@\n+    public Bindings getBindings(MethodType mt, FunctionDescriptor cDesc, boolean forUpcall) {\n@@ -119,0 +137,3 @@\n+            if (varArgsOnStack() && SharedUtils.isVarargsIndex(cDesc, i)) {\n+                argCalc.storageCalculator.adjustForVarArgs();\n+            }\n@@ -127,1 +148,1 @@\n-    public static MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n+    public MethodHandle arrangeDowncall(MethodType mt, FunctionDescriptor cDesc) {\n@@ -139,1 +160,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -146,1 +167,1 @@\n-        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(C, target, bindings.callingSequence,scope);\n@@ -211,8 +232,5 @@\n-        void adjustForVarArgs(MemoryLayout layout) {\n-            if (layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME)\n-                    .map(Boolean.class::cast).orElse(false)) {\n-                \/\/ This system passes all variadic parameters on the stack. Ensure\n-                \/\/ no further arguments are allocated to registers.\n-                nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n-                nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n-            }\n+        void adjustForVarArgs() {\n+            \/\/ This system passes all variadic parameters on the stack. Ensure\n+            \/\/ no further arguments are allocated to registers.\n+            nRegs[StorageClasses.INTEGER] = MAX_REGISTER_ARGUMENTS;\n+            nRegs[StorageClasses.VECTOR] = MAX_REGISTER_ARGUMENTS;\n@@ -291,1 +309,0 @@\n-            storageCalculator.adjustForVarArgs(layout);\n@@ -320,2 +337,1 @@\n-                            .baseAddress()\n-                            .unboxAddress();\n+                            .unboxAddress(MemorySegment.class);\n@@ -352,1 +368,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n@@ -394,1 +410,0 @@\n-            assert !layout.attribute(AArch64.STACK_VARARGS_ATTRIBUTE_NAME).isPresent() : \"no variadic upcalls\";\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":35,"deletions":20,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -32,1 +33,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -45,5 +45,11 @@\n-        return switch (PlatformLayouts.getKind(type)) {\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n-            case POINTER -> POINTER;\n-            case FLOAT, DOUBLE -> FLOAT;\n-        };\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return FLOAT;\n+        } else if (carrier == MemoryAddress.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/TypeClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.linux;\n+\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for Linux ABI.\n+ *\/\n+public class LinuxAArch64CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        \/\/ Variadic arguments are passed as normal arguments\n+        return false;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -31,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -32,2 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -35,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -48,1 +48,1 @@\n-public final class LinuxAArch64Linker extends AbstractCLinker {\n+public final class LinuxAArch64Linker implements CLinker {\n@@ -53,15 +53,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(LinuxAArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -76,2 +61,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -79,2 +63,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, LinuxAArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.LINUX.arrangeDowncall(type, function);\n@@ -85,2 +69,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -90,1 +73,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -94,2 +77,6 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.LINUX.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64Linker.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n@@ -36,1 +38,0 @@\n-import java.nio.ByteOrder;\n@@ -42,1 +43,1 @@\n-import static jdk.incubator.foreign.CLinker.VaList;\n+\n@@ -46,2 +47,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n-import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n@@ -54,1 +53,1 @@\n-public non-sealed class LinuxAArch64VaList implements VaList {\n+public non-sealed class LinuxAArch64VaList implements VaList, Scoped {\n@@ -79,1 +78,1 @@\n-        = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n+        = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n@@ -81,1 +80,1 @@\n-        = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n+        = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n@@ -94,6 +93,3 @@\n-    private static final VarHandle VH_stack\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__stack\")));\n-    private static final VarHandle VH_gr_top\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__gr_top\")));\n-    private static final VarHandle VH_vr_top\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"__vr_top\")));\n+    private static final VarHandle VH_stack = LAYOUT.varHandle(groupElement(\"__stack\"));\n+    private static final VarHandle VH_gr_top = LAYOUT.varHandle(groupElement(\"__gr_top\"));\n+    private static final VarHandle VH_vr_top = LAYOUT.varHandle(groupElement(\"__vr_top\"));\n@@ -101,1 +97,1 @@\n-        = LAYOUT.varHandle(int.class, groupElement(\"__gr_offs\"));\n+        = LAYOUT.varHandle(groupElement(\"__gr_offs\"));\n@@ -103,1 +99,1 @@\n-        = LAYOUT.varHandle(int.class, groupElement(\"__vr_offs\"));\n+        = LAYOUT.varHandle(groupElement(\"__vr_offs\"));\n@@ -105,1 +101,0 @@\n-    private static final Cleaner cleaner = Cleaner.create();\n@@ -120,1 +115,1 @@\n-        MemorySegment gpRegsArea = grTop(segment).addOffset(-MAX_GP_OFFSET).asSegment(\n+        MemorySegment gpRegsArea = MemorySegment.ofAddressNative(grTop(segment).addOffset(-MAX_GP_OFFSET),\n@@ -123,1 +118,1 @@\n-        MemorySegment fpRegsArea = vrTop(segment).addOffset(-MAX_FP_OFFSET).asSegment(\n+        MemorySegment fpRegsArea = MemorySegment.ofAddressNative(vrTop(segment).addOffset(-MAX_FP_OFFSET),\n@@ -130,3 +125,4 @@\n-        MemorySegment ms = MemoryAddress.ofLong(ptr).asSegment(\n-                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n-        cleaner.register(LinuxAArch64VaList.class, () -> ms.scope().close());\n+        ResourceScope scope = ResourceScope.newImplicitScope();\n+        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment ms = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+                LAYOUT.byteSize(), scope);\n@@ -218,1 +214,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -223,1 +219,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -228,1 +224,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -233,1 +229,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -238,1 +234,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -243,5 +239,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -254,2 +245,0 @@\n-        checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n-\n@@ -261,1 +250,1 @@\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n@@ -268,2 +257,2 @@\n-                    VarHandle reader = vhPrimitiveOrAddress(carrier, layout);\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    VarHandle reader = layout.varHandle();\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n@@ -283,2 +272,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(gpRegsArea.asSlice(currentGPOffset(), copy));\n+                        MemorySegment.copy(gpRegsArea, currentGPOffset(), value, offset, copy);\n@@ -299,2 +287,1 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n-                        slice.copyFrom(fpRegsArea.asSlice(currentFPOffset(), copy));\n+                        MemorySegment.copy(fpRegsArea, currentFPOffset(), value, offset, copy);\n@@ -308,2 +295,1 @@\n-                    VarHandle ptrReader\n-                        = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class, AArch64.C_POINTER);\n+                    VarHandle ptrReader = AArch64.C_POINTER.varHandle();\n@@ -314,1 +300,1 @@\n-                    MemorySegment slice = ptr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddressNative(ptr, layout.byteSize(), scope());\n@@ -320,1 +306,1 @@\n-                    VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle();\n@@ -326,1 +312,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -338,0 +324,1 @@\n+        ((ResourceScopeImpl)segment.scope()).checkValidStateSlow();\n@@ -359,1 +346,1 @@\n-        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n@@ -421,1 +408,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -426,1 +413,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -431,1 +418,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -436,1 +423,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -441,1 +428,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -448,2 +435,0 @@\n-            checkCompatibleType(carrier, layout, LinuxAArch64Linker.ADDRESS_SIZE);\n-\n@@ -461,2 +446,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            gpRegs.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, gpRegs, currentGPOffset, copy);\n@@ -476,2 +460,1 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n-                            fpRegs.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                            MemorySegment.copy(valueSegment, offset, fpRegs, currentFPOffset, copy);\n@@ -485,3 +468,1 @@\n-                        VarHandle writer\n-                            = SharedUtils.vhPrimitiveOrAddress(MemoryAddress.class,\n-                                                               AArch64.C_POINTER);\n+                        VarHandle writer = AArch64.C_POINTER.varHandle();\n@@ -493,1 +474,1 @@\n-                        VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                        VarHandle writer = layout.varHandle();\n@@ -498,1 +479,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n@@ -516,1 +497,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64VaList.java","additions":44,"deletions":63,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.macos;\n+\n+import jdk.internal.foreign.abi.aarch64.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for macOS ABI.\n+ *\/\n+public class MacOsAArch64CallArranger extends CallArranger {\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        \/\/ Variadic arguments are always passed on the stack\n+        return true;\n+    }\n+\n+}\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -28,1 +28,1 @@\n-import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -33,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -34,2 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -37,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -46,2 +44,0 @@\n-import static jdk.internal.foreign.PlatformLayouts.*;\n-\n@@ -52,1 +48,1 @@\n-public final class MacOsAArch64Linker extends AbstractCLinker {\n+public final class MacOsAArch64Linker implements CLinker {\n@@ -57,15 +53,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(MacOsAArch64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -80,2 +61,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -83,2 +63,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, MacOsAArch64VaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.MACOS.arrangeDowncall(type, function);\n@@ -89,2 +69,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -94,1 +73,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -98,2 +77,5 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.MACOS.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64Linker.java","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.internal.foreign.Scoped;\n@@ -48,1 +48,1 @@\n-public non-sealed class MacOsAArch64VaList implements VaList {\n+public non-sealed class MacOsAArch64VaList implements VaList, Scoped {\n@@ -51,1 +51,1 @@\n-    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n@@ -68,1 +68,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -73,1 +73,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -78,1 +78,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -83,1 +83,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -88,1 +88,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -93,5 +93,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -104,1 +99,0 @@\n-        SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n@@ -111,1 +105,1 @@\n-                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n@@ -118,2 +112,2 @@\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n+                    MemorySegment struct = allocator.allocate(layout)\n+                            .copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -126,1 +120,1 @@\n-            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            VarHandle reader = layout.varHandle();\n@@ -136,0 +130,1 @@\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n@@ -147,1 +142,1 @@\n-        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n@@ -184,1 +179,0 @@\n-            SharedUtils.checkCompatibleType(carrier, layout, MacOsAArch64Linker.ADDRESS_SIZE);\n@@ -190,1 +184,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -195,1 +189,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -200,1 +194,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -205,1 +199,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -210,1 +204,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -219,1 +213,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -240,4 +234,3 @@\n-                        case STRUCT_REGISTER, STRUCT_HFA -> {\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()));\n-                            cursor = cursor.asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n-                        }\n+                        case STRUCT_REGISTER, STRUCT_HFA ->\n+                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                                    .asSlice(alignUp(arg.layout.byteSize(), VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","additions":23,"deletions":30,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -89,2 +90,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, SysVx64Linker.ADDRESS_SIZE);\n-\n@@ -137,1 +136,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -144,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CSysV, target, bindings.callingSequence, scope);\n@@ -283,1 +282,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/CallArranger.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.internal.foreign.Scoped;\n@@ -35,1 +37,0 @@\n-import java.nio.ByteOrder;\n@@ -41,1 +42,1 @@\n-import static jdk.incubator.foreign.CLinker.VaList;\n+\n@@ -45,2 +46,0 @@\n-import static jdk.internal.foreign.abi.SharedUtils.checkCompatibleType;\n-import static jdk.internal.foreign.abi.SharedUtils.vhPrimitiveOrAddress;\n@@ -49,1 +48,1 @@\n-public non-sealed class SysVVaList implements VaList {\n+public non-sealed class SysVVaList implements VaList, Scoped {\n@@ -70,2 +69,2 @@\n-    private static final MemoryLayout GP_REG = MemoryLayout.valueLayout(64, ByteOrder.nativeOrder());\n-    private static final MemoryLayout FP_REG = MemoryLayout.valueLayout(128, ByteOrder.nativeOrder());\n+    private static final MemoryLayout GP_REG = MemoryLayout.paddingLayout(64).withBitAlignment(64);\n+    private static final MemoryLayout FP_REG = MemoryLayout.paddingLayout(128).withBitAlignment(128);\n@@ -108,6 +107,4 @@\n-    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(int.class, groupElement(\"fp_offset\"));\n-    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(int.class, groupElement(\"gp_offset\"));\n-    private static final VarHandle VH_overflow_arg_area\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"overflow_arg_area\")));\n-    private static final VarHandle VH_reg_save_area\n-        = MemoryHandles.asAddressVarHandle(LAYOUT.varHandle(long.class, groupElement(\"reg_save_area\")));\n+    private static final VarHandle VH_fp_offset = LAYOUT.varHandle(groupElement(\"fp_offset\"));\n+    private static final VarHandle VH_gp_offset = LAYOUT.varHandle(groupElement(\"gp_offset\"));\n+    private static final VarHandle VH_overflow_arg_area = LAYOUT.varHandle(groupElement(\"overflow_arg_area\"));\n+    private static final VarHandle VH_reg_save_area = LAYOUT.varHandle(groupElement(\"reg_save_area\"));\n@@ -115,1 +112,0 @@\n-    private static final Cleaner cleaner = Cleaner.create();\n@@ -133,3 +129,4 @@\n-        MemorySegment base = MemoryAddress.ofLong(ptr).asSegment(\n-                LAYOUT.byteSize(), () -> U.freeMemory(ptr), ResourceScope.newSharedScope());\n-        cleaner.register(SysVVaList.class, () -> base.scope().close());\n+        ResourceScope scope = ResourceScope.newImplicitScope();\n+        scope.addCloseAction(() -> U.freeMemory(ptr));\n+        MemorySegment base = MemorySegment.ofAddressNative(MemoryAddress.ofLong(ptr),\n+                LAYOUT.byteSize(), scope);\n@@ -176,1 +173,1 @@\n-        return ((MemoryAddress)VH_reg_save_area.get(segment)).asSegment(\n+        return MemorySegment.ofAddressNative(((MemoryAddress)VH_reg_save_area.get(segment)),\n@@ -191,1 +188,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -196,1 +193,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -201,1 +198,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -206,1 +203,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -211,1 +208,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -216,5 +213,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -227,1 +219,0 @@\n-        checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);\n@@ -234,1 +225,1 @@\n-                    MemorySegment slice = stackPtr().asSegment(layout.byteSize(), scope());\n+                    MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), scope());\n@@ -241,1 +232,1 @@\n-                    VarHandle reader = vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle();\n@@ -243,1 +234,1 @@\n-                        MemorySegment slice = stackPtr().asSegment(layout.byteSize(), localScope);\n+                        MemorySegment slice = MemorySegment.ofAddressNative(stackPtr(), layout.byteSize(), localScope);\n@@ -259,1 +250,0 @@\n-                        MemorySegment slice = value.asSlice(offset, copy);\n@@ -261,1 +251,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentFPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentFPOffset(), value, offset, copy);\n@@ -264,1 +254,1 @@\n-                            slice.copyFrom(regSaveArea.asSlice(currentGPOffset(), copy));\n+                            MemorySegment.copy(regSaveArea, currentGPOffset(), value, offset, copy);\n@@ -272,1 +262,1 @@\n-                    VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                    VarHandle reader = layout.varHandle();\n@@ -278,1 +268,1 @@\n-                    VarHandle reader = layout.varHandle(carrier);\n+                    VarHandle reader = layout.varHandle();\n@@ -290,0 +280,1 @@\n+        ((ResourceScopeImpl)segment.scope()).checkValidStateSlow();\n@@ -308,1 +299,1 @@\n-        return readFromSegment(ma.asSegment(LAYOUT.byteSize(), scope));\n+        return readFromSegment(MemorySegment.ofAddressNative(ma, LAYOUT.byteSize(), scope));\n@@ -356,1 +347,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -361,1 +352,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -366,1 +357,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -371,1 +362,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -376,1 +367,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -383,1 +374,0 @@\n-            checkCompatibleType(carrier, layout, SysVx64Linker.ADDRESS_SIZE);\n@@ -398,1 +388,0 @@\n-                            MemorySegment slice = valueSegment.asSlice(offset, copy);\n@@ -400,1 +389,1 @@\n-                                reg_save_area.asSlice(currentFPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentFPOffset, copy);\n@@ -403,1 +392,1 @@\n-                                reg_save_area.asSlice(currentGPOffset, copy).copyFrom(slice);\n+                                MemorySegment.copy(valueSegment, offset, reg_save_area, currentGPOffset, copy);\n@@ -410,1 +399,1 @@\n-                        VarHandle writer = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+                        VarHandle writer = layout.varHandle();\n@@ -415,1 +404,1 @@\n-                        VarHandle writer = layout.varHandle(carrier);\n+                        VarHandle writer = layout.varHandle();\n@@ -433,1 +422,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVVaList.java","additions":39,"deletions":50,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -31,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -32,2 +34,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -35,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -46,1 +46,1 @@\n-public final class SysVx64Linker extends AbstractCLinker {\n+public final class SysVx64Linker implements CLinker {\n@@ -57,15 +57,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(SysVx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -86,2 +71,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -89,2 +73,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, SysVVaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -95,2 +79,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -100,1 +83,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -104,2 +87,6 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/SysVx64Linker.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -31,1 +32,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n@@ -110,5 +110,11 @@\n-        return switch (PlatformLayouts.getKind(layout)) {\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> ArgumentClassImpl.INTEGER;\n-            case FLOAT, DOUBLE -> ArgumentClassImpl.SSE;\n-            case POINTER -> ArgumentClassImpl.POINTER;\n-        };\n+        Class<?> carrier = ((ValueLayout)layout).carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return ArgumentClassImpl.INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            return ArgumentClassImpl.SSE;\n+        } else if (carrier == MemoryAddress.class) {\n+            return ArgumentClassImpl.POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/sysv\/TypeClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -32,0 +32,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -34,1 +36,0 @@\n-import jdk.internal.foreign.abi.UpcallHandler;\n@@ -85,2 +86,0 @@\n-        SharedUtils.checkFunctionTypes(mt, cDesc, Windowsx64Linker.ADDRESS_SIZE);\n-\n@@ -94,2 +93,2 @@\n-            void addArgumentBindings(Class<?> carrier, MemoryLayout layout) {\n-                csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout));\n+            void addArgumentBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+                csb.addArgumentBindings(carrier, layout, argCalc.getBindings(carrier, layout, isVararg));\n@@ -99,1 +98,1 @@\n-                csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout));\n+                csb.setReturnBindings(carrier, layout, retCalc.getBindings(carrier, layout, false));\n@@ -108,1 +107,1 @@\n-            csb.addArgumentBindings(carrier, layout);\n+            csb.addArgumentBindings(carrier, layout, false);\n@@ -117,1 +116,1 @@\n-            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i));\n+            csb.addArgumentBindings(mt.parameterType(i), cDesc.argumentLayouts().get(i), SharedUtils.isVarargsIndex(cDesc, i));\n@@ -137,1 +136,1 @@\n-    public static UpcallHandler arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc) {\n+    public static NativeSymbol arrangeUpcall(MethodHandle target, MethodType mt, FunctionDescriptor cDesc, ResourceScope scope) {\n@@ -144,1 +143,1 @@\n-        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence);\n+        return ProgrammableUpcallHandler.make(CWindows, target, bindings.callingSequence, scope);\n@@ -188,1 +187,1 @@\n-        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout);\n+        List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg);\n@@ -199,2 +198,2 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {\n-            TypeClass argumentClass = TypeClass.typeClassFor(layout);\n+        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+            TypeClass argumentClass = TypeClass.typeClassFor(layout, isVararg);\n@@ -214,2 +213,1 @@\n-                            .baseAddress()\n-                            .unboxAddress();\n+                            .unboxAddress(MemorySegment.class);\n@@ -221,1 +219,1 @@\n-                    bindings.unboxAddress();\n+                    bindings.unboxAddress(carrier);\n@@ -262,2 +260,2 @@\n-        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout) {\n-            TypeClass argumentClass = TypeClass.typeClassFor(layout);\n+        public List<Binding> getBindings(Class<?> carrier, MemoryLayout layout, boolean isVararg) {\n+            TypeClass argumentClass = TypeClass.typeClassFor(layout, isVararg);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/CallArranger.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,3 +31,0 @@\n-import jdk.internal.foreign.PlatformLayouts;\n-\n-import static jdk.internal.foreign.PlatformLayouts.Win64.VARARGS_ATTRIBUTE_NAME;\n@@ -42,1 +40,1 @@\n-    private static TypeClass classifyValueType(ValueLayout type) {\n+    private static TypeClass classifyValueType(ValueLayout type, boolean isVararg) {\n@@ -52,9 +50,9 @@\n-        return switch (PlatformLayouts.getKind(type)) {\n-            case CHAR, SHORT, INT, LONG, LONG_LONG -> INTEGER;\n-            case POINTER -> POINTER;\n-            case FLOAT, DOUBLE -> {\n-                 if (type.attribute(VARARGS_ATTRIBUTE_NAME)\n-                        .map(Boolean.class::cast).orElse(false)) {\n-                    yield VARARG_FLOAT;\n-                }\n-                yield FLOAT;\n+        Class<?> carrier = type.carrier();\n+        if (carrier == boolean.class || carrier == byte.class || carrier == char.class ||\n+                carrier == short.class || carrier == int.class || carrier == long.class) {\n+            return INTEGER;\n+        } else if (carrier == float.class || carrier == double.class) {\n+            if (isVararg) {\n+                return VARARG_FLOAT;\n+            } else {\n+                return FLOAT;\n@@ -62,1 +60,5 @@\n-        };\n+        } else if (carrier == MemoryAddress.class) {\n+            return POINTER;\n+        } else {\n+            throw new IllegalStateException(\"Cannot get here: \" + carrier.getName());\n+        }\n@@ -80,1 +82,1 @@\n-    static TypeClass typeClassFor(MemoryLayout type) {\n+    static TypeClass typeClassFor(MemoryLayout type, boolean isVararg) {\n@@ -82,1 +84,1 @@\n-            return classifyValueType((ValueLayout) type);\n+            return classifyValueType((ValueLayout) type, isVararg);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/TypeClass.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.internal.foreign.Scoped;\n@@ -58,1 +58,1 @@\n-public non-sealed class WinVaList implements VaList {\n+public non-sealed class WinVaList implements VaList, Scoped {\n@@ -61,1 +61,1 @@\n-    private static final VarHandle VH_address = MemoryHandles.asAddressVarHandle(C_POINTER.varHandle(long.class));\n+    private static final VarHandle VH_address = C_POINTER.varHandle();\n@@ -78,1 +78,1 @@\n-    public int vargAsInt(MemoryLayout layout) {\n+    public int nextVarg(ValueLayout.OfInt layout) {\n@@ -83,1 +83,1 @@\n-    public long vargAsLong(MemoryLayout layout) {\n+    public long nextVarg(ValueLayout.OfLong layout) {\n@@ -88,1 +88,1 @@\n-    public double vargAsDouble(MemoryLayout layout) {\n+    public double nextVarg(ValueLayout.OfDouble layout) {\n@@ -93,1 +93,1 @@\n-    public MemoryAddress vargAsAddress(MemoryLayout layout) {\n+    public MemoryAddress nextVarg(ValueLayout.OfAddress layout) {\n@@ -98,1 +98,1 @@\n-    public MemorySegment vargAsSegment(MemoryLayout layout, SegmentAllocator allocator) {\n+    public MemorySegment nextVarg(GroupLayout layout, SegmentAllocator allocator) {\n@@ -103,5 +103,0 @@\n-    @Override\n-    public MemorySegment vargAsSegment(MemoryLayout layout, ResourceScope scope) {\n-        return vargAsSegment(layout, SegmentAllocator.ofScope(scope));\n-    }\n-\n@@ -114,1 +109,0 @@\n-        SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);\n@@ -117,1 +111,1 @@\n-            TypeClass typeClass = TypeClass.typeClassFor(layout);\n+            TypeClass typeClass = TypeClass.typeClassFor(layout, false);\n@@ -121,1 +115,1 @@\n-                    MemorySegment struct = structAddr.asSegment(layout.byteSize(), scope());\n+                    MemorySegment struct = MemorySegment.ofAddressNative(structAddr, layout.byteSize(), scope());\n@@ -126,5 +120,2 @@\n-                case STRUCT_REGISTER -> {\n-                    MemorySegment struct = allocator.allocate(layout);\n-                    struct.copyFrom(segment.asSlice(0L, layout.byteSize()));\n-                    yield struct;\n-                }\n+                case STRUCT_REGISTER ->\n+                    allocator.allocate(layout).copyFrom(segment.asSlice(0, layout.byteSize()));\n@@ -134,1 +125,1 @@\n-            VarHandle reader = SharedUtils.vhPrimitiveOrAddress(carrier, layout);\n+            VarHandle reader = layout.varHandle();\n@@ -144,0 +135,1 @@\n+        ((ResourceScopeImpl)scope).checkValidStateSlow();\n@@ -149,1 +141,1 @@\n-        MemorySegment segment = addr.asSegment(Long.MAX_VALUE, scope);\n+        MemorySegment segment = MemorySegment.ofAddressNative(addr, Long.MAX_VALUE, scope);\n@@ -186,1 +178,0 @@\n-            SharedUtils.checkCompatibleType(carrier, layout, Windowsx64Linker.ADDRESS_SIZE);\n@@ -192,1 +183,1 @@\n-        public Builder vargFromInt(ValueLayout layout, int value) {\n+        public Builder addVarg(ValueLayout.OfInt layout, int value) {\n@@ -197,1 +188,1 @@\n-        public Builder vargFromLong(ValueLayout layout, long value) {\n+        public Builder addVarg(ValueLayout.OfLong layout, long value) {\n@@ -202,1 +193,1 @@\n-        public Builder vargFromDouble(ValueLayout layout, double value) {\n+        public Builder addVarg(ValueLayout.OfDouble layout, double value) {\n@@ -207,1 +198,1 @@\n-        public Builder vargFromAddress(ValueLayout layout, Addressable value) {\n+        public Builder addVarg(ValueLayout.OfAddress layout, Addressable value) {\n@@ -212,1 +203,1 @@\n-        public Builder vargFromSegment(GroupLayout layout, MemorySegment value) {\n+        public Builder addVarg(GroupLayout layout, MemorySegment value) {\n@@ -220,1 +211,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -229,1 +220,1 @@\n-                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout);\n+                    TypeClass typeClass = TypeClass.typeClassFor(arg.layout, false);\n@@ -237,4 +228,2 @@\n-                        case STRUCT_REGISTER -> {\n-                            MemorySegment slice = cursor.asSlice(0, VA_SLOT_SIZE_BYTES);\n-                            slice.copyFrom(msArg);\n-                        }\n+                        case STRUCT_REGISTER ->\n+                            cursor.copyFrom(msArg.asSlice(0, VA_SLOT_SIZE_BYTES));\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/WinVaList.java","additions":24,"deletions":35,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -30,0 +31,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -31,2 +33,1 @@\n-import jdk.internal.foreign.AbstractCLinker;\n-import jdk.internal.foreign.ResourceScopeImpl;\n+import jdk.incubator.foreign.VaList;\n@@ -34,1 +35,0 @@\n-import jdk.internal.foreign.abi.UpcallStubs;\n@@ -45,1 +45,1 @@\n-public final class Windowsx64Linker extends AbstractCLinker {\n+public final class Windowsx64Linker implements CLinker {\n@@ -58,15 +58,0 @@\n-    private static final MethodHandle MH_unboxVaList;\n-    private static final MethodHandle MH_boxVaList;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_unboxVaList = lookup.findVirtual(VaList.class, \"address\",\n-                MethodType.methodType(MemoryAddress.class));\n-            MH_boxVaList = MethodHandles.insertArguments(lookup.findStatic(Windowsx64Linker.class, \"newVaListOfAddress\",\n-                MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)), 1, ResourceScope.globalScope());\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n@@ -87,2 +72,1 @@\n-    public final MethodHandle downcallHandle(MethodType type, FunctionDescriptor function) {\n-        Objects.requireNonNull(type);\n+    public final MethodHandle downcallHandle(FunctionDescriptor function) {\n@@ -90,2 +74,2 @@\n-        MethodType llMt = SharedUtils.convertVaListCarriers(type, WinVaList.CARRIER);\n-        MethodHandle handle = CallArranger.arrangeDowncall(llMt, function);\n+        MethodType type = SharedUtils.inferMethodType(function, false);\n+        MethodHandle handle = CallArranger.arrangeDowncall(type, function);\n@@ -96,2 +80,1 @@\n-        handle = SharedUtils.unboxVaLists(type, handle, MH_unboxVaList);\n-        return handle;\n+        return SharedUtils.wrapDowncall(handle, function);\n@@ -101,1 +84,1 @@\n-    public final MemoryAddress upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n+    public final NativeSymbol upcallStub(MethodHandle target, FunctionDescriptor function, ResourceScope scope) {\n@@ -105,2 +88,6 @@\n-        target = SharedUtils.boxVaLists(target, MH_boxVaList);\n-        return UpcallStubs.upcallAddress(CallArranger.arrangeUpcall(target, target.type(), function), (ResourceScopeImpl) scope);\n+        SharedUtils.checkExceptions(target);\n+        MethodType type = SharedUtils.inferMethodType(function, true);\n+        if (!type.equals(target.type())) {\n+            throw new IllegalArgumentException(\"Wrong method handle type: \" + target.type());\n+        }\n+        return CallArranger.arrangeUpcall(target, target.type(), function, scope);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/abi\/x64\/windows\/Windowsx64Linker.java","additions":15,"deletions":28,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -45,3 +46,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -54,1 +52,1 @@\n-    final static CLinker abi = CLinker.getInstance();\n+    final static CLinker abi = CLinker.systemCLinker();\n@@ -57,2 +55,1 @@\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+            FunctionDescriptor.of(ValueLayout.JAVA_INT));\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/compiler\/TestLinkToNativeRBP.java","additions":3,"deletions":6,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,0 +25,3 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n@@ -29,0 +32,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,0 +37,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -43,1 +48,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -48,1 +52,3 @@\n-    static SegmentAllocator IMPLICIT_ALLOCATOR = (size, align) -> MemorySegment.allocateNative(size, align, ResourceScope.newImplicitScope());\n+    static SegmentAllocator THROWING_ALLOCATOR = (size, align) -> {\n+        throw new UnsupportedOperationException();\n+    };\n@@ -61,1 +67,1 @@\n-                VarHandle vh = g.varHandle(vhCarrier(field), MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n+                VarHandle vh = g.varHandle(MemoryLayout.PathElement.groupElement(field.name().orElseThrow()));\n@@ -413,1 +419,1 @@\n-            VarHandle accessor = g.varHandle(structFieldCarrier(l), MemoryLayout.PathElement.groupElement(l.name().get()));\n+            VarHandle accessor = g.varHandle(MemoryLayout.PathElement.groupElement(l.name().get()));\n@@ -416,3 +422,0 @@\n-            if (isPointer(l)) {\n-                value = ((MemoryAddress)value).toRawLongValue();\n-            }\n@@ -427,5 +430,1 @@\n-                        if (isPointer(l)) {\n-                            fieldsCheck.get(0).accept(MemoryAddress.ofLong((long)accessor.get(actual)));\n-                        } else {\n-                            fieldsCheck.get(0).accept(accessor.get(actual));\n-                        }\n+                        fieldsCheck.get(0).accept(accessor.get(actual));\n@@ -440,17 +439,1 @@\n-    static Class<?> structFieldCarrier(MemoryLayout layout) {\n-        if (isPointer(layout)) {\n-            return long.class;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            } else {\n-                return double.class;\n-            }\n-        } else {\n-            throw new IllegalStateException(\"Unexpected layout: \" + layout);\n-        }\n-    }\n-\n-    static Class<?> paramCarrier(MemoryLayout layout) {\n+    static Class<?> carrier(MemoryLayout layout, boolean param) {\n@@ -460,9 +443,3 @@\n-            return MemoryAddress.class;\n-        } else if (layout instanceof ValueLayout) {\n-            if (isIntegral(layout)) {\n-                return int.class;\n-            } else if (layout.bitSize() == 32) {\n-                return float.class;\n-            } else {\n-                return double.class;\n-            }\n+            return param ? Addressable.class : MemoryAddress.class;\n+        } else if (layout instanceof ValueLayout valueLayout) {\n+            return valueLayout.carrier();\n@@ -473,0 +450,8 @@\n+\n+    MethodHandle downcallHandle(CLinker abi, NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor) {\n+        MethodHandle mh = abi.downcallHandle(symbol, descriptor);\n+        if (descriptor.returnLayout().isPresent() && descriptor.returnLayout().get() instanceof GroupLayout) {\n+            mh = mh.bindTo(allocator);\n+        }\n+        return mh;\n+    }\n","filename":"test\/jdk\/java\/foreign\/CallGeneratorHelper.java","additions":23,"deletions":38,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -26,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -30,0 +33,3 @@\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n@@ -33,3 +39,2 @@\n-    static CLinker.TypeKind kind(MemoryLayout layout) {\n-        return (CLinker.TypeKind)layout.attribute(CLinker.TypeKind.ATTR_NAME).orElseThrow(\n-                () -> new IllegalStateException(\"Unexpected value layout: could not determine ABI class\"));\n+    public static boolean isIntegral(MemoryLayout layout) {\n+        return layout instanceof ValueLayout valueLayout && isIntegral(valueLayout.carrier());\n@@ -38,2 +43,3 @@\n-    public static boolean isIntegral(MemoryLayout layout) {\n-        return kind(layout).isIntegral();\n+    static boolean isIntegral(Class<?> clazz) {\n+        return clazz == byte.class || clazz == char.class || clazz == short.class\n+                || clazz == int.class || clazz == long.class;\n@@ -43,1 +49,1 @@\n-        return kind(layout).isPointer();\n+        return layout instanceof ValueLayout valueLayout && valueLayout.carrier() == MemoryAddress.class;\n@@ -46,4 +52,1 @@\n-    public static class NativeScope implements SegmentAllocator, AutoCloseable {\n-        final ResourceScope resourceScope;\n-        final ResourceScope.Handle scopeHandle;\n-        final SegmentAllocator allocator;\n+    \/\/ the constants below are useful aliases for C types. The type\/carrier association is only valid for 64-bit platforms.\n@@ -51,1 +54,16 @@\n-        long allocatedBytes = 0;\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT.withBitAlignment(16);\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT.withBitAlignment(32);\n@@ -53,5 +71,16 @@\n-        public NativeScope() {\n-            this.resourceScope = ResourceScope.newConfinedScope();\n-            this.scopeHandle = resourceScope.acquire();\n-            this.allocator = SegmentAllocator.arenaAllocator(resourceScope);\n-        }\n+    \/**\n+     * The layout for the {@code long long} C type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG.withBitAlignment(64);\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT.withBitAlignment(32);\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE.withBitAlignment(64);\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS.withBitAlignment(64);\n@@ -59,5 +88,1 @@\n-        @Override\n-        public MemorySegment allocate(long bytesSize, long bytesAlignment) {\n-            allocatedBytes += bytesSize;\n-            return allocator.allocate(bytesSize, bytesAlignment);\n-        }\n+    private static CLinker LINKER = CLinker.systemCLinker();\n@@ -65,3 +90,2 @@\n-        public ResourceScope scope() {\n-            return resourceScope;\n-        }\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n@@ -69,2 +93,8 @@\n-        public long allocatedBytes() {\n-            return allocatedBytes;\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n@@ -72,0 +102,1 @@\n+    }\n@@ -73,4 +104,5 @@\n-        @Override\n-        public void close() {\n-            resourceScope.release(scopeHandle);\n-            resourceScope.close();\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n","filename":"test\/jdk\/java\/foreign\/NativeTestHelper.java","additions":62,"deletions":30,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -32,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -39,0 +40,1 @@\n+import java.lang.invoke.MethodHandles;\n@@ -41,0 +43,1 @@\n+import jdk.incubator.foreign.VaList;\n@@ -42,0 +45,1 @@\n+\n@@ -44,1 +48,1 @@\n-public class SafeFunctionAccessTest {\n+public class SafeFunctionAccessTest extends NativeTestHelper {\n@@ -50,1 +54,1 @@\n-            CLinker.C_INT, CLinker.C_INT\n+            C_INT, C_INT\n@@ -62,1 +66,1 @@\n-        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n@@ -64,1 +68,0 @@\n-                MethodType.methodType(void.class, MemorySegment.class),\n@@ -70,0 +73,37 @@\n+    @Test\n+    public void testClosedStructAddr_6() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_6\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        for (int i = 0 ; i < 6 ; i++) {\n+            MemorySegment[] segments = new MemorySegment[]{\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope()),\n+                    MemorySegment.allocateNative(POINT, ResourceScope.newImplicitScope())\n+            };\n+            \/\/ check liveness\n+            segments[i].scope().close();\n+            for (int j = 0 ; j < 6 ; j++) {\n+                if (i == j) {\n+                    assertFalse(segments[j].scope().isAlive());\n+                } else {\n+                    assertTrue(segments[j].scope().isAlive());\n+                }\n+            }\n+            try {\n+                handle.invokeWithArguments(segments);\n+                fail();\n+            } catch (IllegalStateException ex) {\n+                assertTrue(ex.getMessage().contains(\"Already closed\"));\n+            }\n+            for (int j = 0 ; j < 6 ; j++) {\n+                if (i != j) {\n+                    segments[j].scope().close(); \/\/ should succeed!\n+                }\n+            }\n+        }\n+    }\n+\n@@ -71,2 +111,2 @@\n-    public void testClosedPointer() throws Throwable {\n-        MemoryAddress address;\n+    public void testClosedVaList() throws Throwable {\n+        VaList list;\n@@ -74,1 +114,1 @@\n-            address = MemorySegment.allocateNative(POINT, scope).address();\n+            list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n@@ -76,2 +116,2 @@\n-        assertFalse(address.scope().isAlive());\n-        MethodHandle handle = CLinker.getInstance().downcallHandle(\n+        assertFalse(list.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n@@ -79,2 +119,1 @@\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(CLinker.C_POINTER));\n+                FunctionDescriptor.ofVoid(C_POINTER));\n@@ -82,1 +121,75 @@\n-        handle.invokeExact(address);\n+        handle.invokeExact((Addressable)list);\n+    }\n+\n+    @Test(expectedExceptions = IllegalStateException.class)\n+    public void testClosedUpcall() throws Throwable {\n+        NativeSymbol upcall;\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+        }\n+        assertFalse(upcall.scope().isAlive());\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER));\n+\n+        handle.invokeExact((Addressable)upcall);\n+    }\n+\n+    static void dummy() { }\n+\n+    @Test\n+    public void testClosedVaListCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            VaList list = VaList.make(b -> b.addVarg(C_INT, 42), scope);\n+            handle.invoke(list, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedStructCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment segment = MemorySegment.allocateNative(POINT, scope);\n+            handle.invoke(segment, scopeChecker(scope));\n+        }\n+    }\n+\n+    @Test\n+    public void testClosedUpcallCallback() throws Throwable {\n+        MethodHandle handle = CLinker.systemCLinker().downcallHandle(\n+                LOOKUP.lookup(\"addr_func_cb\").get(),\n+                FunctionDescriptor.ofVoid(C_POINTER, C_POINTER));\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MethodHandle dummy = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"dummy\", MethodType.methodType(void.class));\n+            NativeSymbol upcall = CLinker.systemCLinker().upcallStub(dummy, FunctionDescriptor.ofVoid(), scope);\n+            handle.invoke(upcall, scopeChecker(scope));\n+        }\n+    }\n+\n+    NativeSymbol scopeChecker(ResourceScope scope) {\n+        try {\n+            MethodHandle handle = MethodHandles.lookup().findStatic(SafeFunctionAccessTest.class, \"checkScope\",\n+                    MethodType.methodType(void.class, ResourceScope.class));\n+            handle = handle.bindTo(scope);\n+            return CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), ResourceScope.newImplicitScope());\n+        } catch (Throwable ex) {\n+            throw new AssertionError(ex);\n+        }\n+    }\n+\n+    static void checkScope(ResourceScope scope) {\n+        try {\n+            scope.close();\n+            fail(\"Scope closed unexpectedly!\");\n+        } catch (IllegalStateException ex) {\n+            assertTrue(ex.getMessage().contains(\"kept alive\")); \/\/if acquired, fine\n+        }\n","filename":"test\/jdk\/java\/foreign\/SafeFunctionAccessTest.java","additions":126,"deletions":13,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -42,1 +42,0 @@\n-import java.util.Optional;\n@@ -51,2 +50,0 @@\n-import static jdk.incubator.foreign.MemoryAccess.*;\n-\n@@ -55,1 +52,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -59,1 +55,1 @@\n-public class StdLibTest {\n+public class StdLibTest extends NativeTestHelper {\n@@ -61,1 +57,1 @@\n-    final static CLinker abi = CLinker.getInstance();\n+    final static CLinker abi = CLinker.systemCLinker();\n@@ -158,5 +154,3 @@\n-        static final SymbolLookup LOOKUP = CLinker.systemLookup();\n-\n-        final static MethodHandle strcat = abi.downcallHandle(LOOKUP.lookup(\"strcat\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER));\n+        final static MethodHandle strcat = abi.downcallHandle(abi.lookup(\"strcat\").get(),\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER))\n+                .asType(MethodType.methodType(MemoryAddress.class, MemorySegment.class, MemorySegment.class)); \/\/ exact signature match\n@@ -164,2 +158,1 @@\n-        final static MethodHandle strcmp = abi.downcallHandle(LOOKUP.lookup(\"strcmp\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle strcmp = abi.downcallHandle(abi.lookup(\"strcmp\").get(),\n@@ -168,2 +161,1 @@\n-        final static MethodHandle puts = abi.downcallHandle(LOOKUP.lookup(\"puts\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        final static MethodHandle puts = abi.downcallHandle(abi.lookup(\"puts\").get(),\n@@ -172,2 +164,1 @@\n-        final static MethodHandle strlen = abi.downcallHandle(LOOKUP.lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        final static MethodHandle strlen = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -176,2 +167,1 @@\n-        final static MethodHandle gmtime = abi.downcallHandle(LOOKUP.lookup(\"gmtime\").get(),\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n+        final static MethodHandle gmtime = abi.downcallHandle(abi.lookup(\"gmtime\").get(),\n@@ -180,2 +170,1 @@\n-        final static MethodHandle qsort = abi.downcallHandle(LOOKUP.lookup(\"qsort\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class, long.class, long.class, MemoryAddress.class),\n+        final static MethodHandle qsort = abi.downcallHandle(abi.lookup(\"qsort\").get(),\n@@ -188,2 +177,1 @@\n-        final static MethodHandle rand = abi.downcallHandle(LOOKUP.lookup(\"rand\").get(),\n-                MethodType.methodType(int.class),\n+        final static MethodHandle rand = abi.downcallHandle(abi.lookup(\"rand\").get(),\n@@ -192,3 +180,2 @@\n-        final static MethodHandle vprintf = abi.downcallHandle(LOOKUP.lookup(\"vprintf\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class, VaList.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER, C_VA_LIST));\n+        final static MethodHandle vprintf = abi.downcallHandle(abi.lookup(\"vprintf\").get(),\n+                FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER));\n@@ -196,1 +183,1 @@\n-        final static MemoryAddress printfAddr = LOOKUP.lookup(\"printf\").get();\n+        final static NativeSymbol printfAddr = abi.lookup(\"printf\").get();\n@@ -204,1 +191,1 @@\n-                        MethodType.methodType(int.class, MemorySegment.class, MemoryAddress.class, MemoryAddress.class));\n+                        CLinker.upcallType(qsortComparFunction));\n@@ -212,8 +199,5 @@\n-                MemorySegment buf = MemorySegment.allocateNative(s1.length() + s2.length() + 1, scope);\n-                MemorySegment other = toCString(s2, scope);\n-                char[] chars = s1.toCharArray();\n-                for (long i = 0 ; i < chars.length ; i++) {\n-                    setByteAtOffset(buf, i, (byte)chars[(int)i]);\n-                }\n-                setByteAtOffset(buf, chars.length, (byte)'\\0');\n-                return toJavaString(((MemoryAddress)strcat.invokeExact(buf.address(), other.address())));\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment buf = malloc.allocate(s1.length() + s2.length() + 1);\n+                buf.setUtf8String(0, s1);\n+                MemorySegment other = malloc.allocateUtf8String(s2);\n+                return ((MemoryAddress)strcat.invokeExact(buf, other)).getUtf8String(0);\n@@ -225,3 +209,4 @@\n-                MemorySegment ns1 = toCString(s1, scope);\n-                MemorySegment ns2 = toCString(s2, scope);\n-                return (int)strcmp.invokeExact(ns1.address(), ns2.address());\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment ns1 = malloc.allocateUtf8String(s1);\n+                MemorySegment ns2 = malloc.allocateUtf8String(s2);\n+                return (int)strcmp.invoke(ns1, ns2);\n@@ -233,2 +218,3 @@\n-                MemorySegment s = toCString(msg, scope);\n-                return (int)puts.invokeExact(s.address());\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment s = malloc.allocateUtf8String(msg);\n+                return (int)puts.invoke(s);\n@@ -240,2 +226,3 @@\n-                MemorySegment s = toCString(msg, scope);\n-                return (int)strlen.invokeExact(s.address());\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment s = malloc.allocateUtf8String(msg);\n+                return (int)strlen.invoke(s);\n@@ -248,2 +235,2 @@\n-                setLong(time, arg);\n-                return new Tm((MemoryAddress)gmtime.invokeExact(time.address()));\n+                time.set(C_LONG_LONG, 0, arg);\n+                return new Tm((MemoryAddress)gmtime.invoke(time));\n@@ -261,1 +248,1 @@\n-                this.base = addr.asSegment(SIZE, ResourceScope.globalScope());\n+                this.base = MemorySegment.ofAddressNative(addr, SIZE, ResourceScope.globalScope());\n@@ -265,1 +252,1 @@\n-                return getIntAtOffset(base, 0);\n+                return base.get(C_INT, 0);\n@@ -268,1 +255,1 @@\n-                return getIntAtOffset(base, 4);\n+                return base.get(C_INT, 4);\n@@ -271,1 +258,1 @@\n-                return getIntAtOffset(base, 8);\n+                return base.get(C_INT, 8);\n@@ -274,1 +261,1 @@\n-                return getIntAtOffset(base, 12);\n+                return base.get(C_INT, 12);\n@@ -277,1 +264,1 @@\n-                return getIntAtOffset(base, 16);\n+                return base.get(C_INT, 16);\n@@ -280,1 +267,1 @@\n-                return getIntAtOffset(base, 20);\n+                return base.get(C_INT, 20);\n@@ -283,1 +270,1 @@\n-                return getIntAtOffset(base, 24);\n+                return base.get(C_INT, 24);\n@@ -286,1 +273,1 @@\n-                return getIntAtOffset(base, 28);\n+                return base.get(C_INT, 28);\n@@ -289,2 +276,1 @@\n-                byte b = getByteAtOffset(base, 32);\n-                return b != 0;\n+                return base.get(C_BOOL, 32);\n@@ -297,2 +283,2 @@\n-                SegmentAllocator allocator = SegmentAllocator.ofScope(scope);\n-                MemorySegment nativeArr = allocator.allocateArray(C_INT, arr);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment nativeArr = malloc.allocateArray(C_INT, arr);\n@@ -301,1 +287,1 @@\n-                MemoryAddress qsortUpcallStub = abi.upcallStub(qsortCompar.bindTo(nativeArr), qsortComparFunction, scope);\n+                NativeSymbol qsortUpcallStub = abi.upcallStub(qsortCompar, qsortComparFunction, scope);\n@@ -303,1 +289,1 @@\n-                qsort.invokeExact(nativeArr.address(), (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n+                qsort.invoke(nativeArr, (long)arr.length, C_INT.byteSize(), qsortUpcallStub);\n@@ -306,1 +292,1 @@\n-                return nativeArr.toIntArray();\n+                return nativeArr.toArray(C_INT);\n@@ -310,3 +296,3 @@\n-        static int qsortCompare(MemorySegment base, MemoryAddress addr1, MemoryAddress addr2) {\n-            return getIntAtOffset(base, addr1.segmentOffset(base)) -\n-                   getIntAtOffset(base, addr2.segmentOffset(base));\n+        static int qsortCompare(MemoryAddress addr1, MemoryAddress addr2) {\n+            return addr1.get(C_INT, 0) -\n+                   addr2.get(C_INT, 0);\n@@ -321,2 +307,3 @@\n-                MemorySegment formatStr = toCString(format, scope);\n-                return (int)specializedPrintf(args).invokeExact(formatStr.address(),\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment formatStr = malloc.allocateUtf8String(format);\n+                return (int)specializedPrintf(args).invoke(formatStr,\n@@ -329,1 +316,2 @@\n-                MemorySegment formatStr = toCString(format, scope);\n+                var malloc = SegmentAllocator.nativeAllocator(scope);\n+                MemorySegment formatStr = malloc.allocateUtf8String(format);\n@@ -331,1 +319,1 @@\n-                return (int)vprintf.invokeExact(formatStr.address(), vaList);\n+                return (int)vprintf.invoke(formatStr, vaList);\n@@ -339,0 +327,1 @@\n+            List<MemoryLayout> variadicLayouts = new ArrayList<>(args.size());\n@@ -341,1 +330,1 @@\n-                fd = fd.withAppendedArgumentLayouts(arg.layout);\n+                variadicLayouts.add(arg.layout);\n@@ -343,1 +332,2 @@\n-            MethodHandle mh = abi.downcallHandle(printfAddr, mt, fd);\n+            MethodHandle mh = abi.downcallHandle(printfAddr,\n+                    fd.asVariadic(variadicLayouts.toArray(new MemoryLayout[args.size()])));\n@@ -404,4 +394,8 @@\n-        INTEGRAL(int.class, asVarArg(C_INT), \"%d\", scope -> 42, 42, VaList.Builder::vargFromInt),\n-        STRING(MemoryAddress.class, asVarArg(C_POINTER), \"%s\", scope -> toCString(\"str\", scope).address(), \"str\", VaList.Builder::vargFromAddress),\n-        CHAR(byte.class, asVarArg(C_CHAR), \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.vargFromInt(C_INT, (int)value)),\n-        DOUBLE(double.class, asVarArg(C_DOUBLE), \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::vargFromDouble);\n+        INTEGRAL(int.class, C_INT, \"%d\", scope -> 42, 42, VaList.Builder::addVarg),\n+        STRING(MemoryAddress.class, C_POINTER, \"%s\", scope -> {\n+            var segment = MemorySegment.allocateNative(4, scope);\n+            segment.setUtf8String(0, \"str\");\n+            return segment.address();\n+        }, \"str\", VaList.Builder::addVarg),\n+        CHAR(byte.class, C_CHAR, \"%c\", scope -> (byte) 'h', 'h', (builder, layout, value) -> builder.addVarg(C_INT, (int)value)),\n+        DOUBLE(double.class, C_DOUBLE, \"%.4f\", scope ->1.2345d, 1.2345d, VaList.Builder::addVarg);\n@@ -417,1 +411,1 @@\n-        <Z> PrintfArg(Class<?> carrier, ValueLayout layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z> builderCall) {\n+        <Z, L extends ValueLayout> PrintfArg(Class<?> carrier, L layout, String format, Function<ResourceScope, Z> nativeValueFactory, Object javaValue, VaListBuilderCall<Z, L> builderCall) {\n@@ -432,2 +426,2 @@\n-        interface VaListBuilderCall<V> {\n-            void build(VaList.Builder builder, ValueLayout layout, V value);\n+        interface VaListBuilderCall<V, L> {\n+            void build(VaList.Builder builder, L layout, V value);\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":71,"deletions":77,"binary":false,"changes":148,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -89,2 +88,2 @@\n-    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandleIndexed = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -92,1 +91,1 @@\n-    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -94,1 +93,1 @@\n-    static final VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n+    static final VarHandle floatHandle = ValueLayout.JAVA_FLOAT.varHandle();\n@@ -98,1 +97,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -100,1 +99,1 @@\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        VarHandle intHandle = layout.varHandle();\n@@ -117,1 +116,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -119,1 +118,1 @@\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        VarHandle intHandle = layout.varHandle();\n@@ -138,1 +137,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -140,1 +139,1 @@\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        VarHandle intHandle = layout.varHandle();\n@@ -162,1 +161,1 @@\n-        VarHandle floatHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle floatHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -168,1 +167,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -174,1 +173,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -182,1 +181,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -188,1 +187,1 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -192,1 +191,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -194,2 +193,7 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I, I2S_EX);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n+            vh.set(seg, \"42\");\n+            String x = (String) vh.get(seg); \/\/ should throw\n+        }\n@@ -198,1 +202,1 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n+    @Test(expectedExceptions = IllegalStateException.class)\n@@ -200,2 +204,6 @@\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n+        VarHandle vh = MemoryHandles.filterValue(intHandle, S2I_EX, I2S);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            MemorySegment seg = MemorySegment.allocateNative(ValueLayout.JAVA_INT, scope);\n+            vh.set(seg, \"42\"); \/\/ should throw\n+        }\n@@ -206,1 +214,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -249,1 +257,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -287,1 +295,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -326,1 +334,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n@@ -369,1 +377,1 @@\n-        ValueLayout layout = MemoryLayouts.JAVA_INT;\n+        ValueLayout layout = ValueLayout.JAVA_INT;\n","filename":"test\/jdk\/java\/foreign\/TestAdaptVarHandles.java","additions":35,"deletions":27,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=true -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=false -Xverify:all TestAddressHandle\n- * @run testng\/othervm -Djava.lang.invoke.VarHandle.VAR_HANDLE_GUARDS=false -Djava.lang.invoke.VarHandle.VAR_HANDLE_IDENTITY_ADAPT=true -Xverify:all TestAddressHandle\n- *\/\n-\n-import java.lang.invoke.*;\n-import java.nio.ByteOrder;\n-import jdk.incubator.foreign.*;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestAddressHandle {\n-\n-    static final MethodHandle INT_TO_BOOL;\n-    static final MethodHandle BOOL_TO_INT;\n-    static final MethodHandle INT_TO_STRING;\n-    static final MethodHandle STRING_TO_INT;\n-\n-    static {\n-        try {\n-            INT_TO_BOOL = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"intToBool\",\n-                    MethodType.methodType(boolean.class, int.class));\n-            BOOL_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"boolToInt\",\n-                    MethodType.methodType(int.class, boolean.class));\n-            INT_TO_STRING = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"intToString\",\n-                    MethodType.methodType(String.class, int.class));\n-            STRING_TO_INT = MethodHandles.lookup().findStatic(TestAddressHandle.class, \"stringToInt\",\n-                    MethodType.methodType(int.class, String.class));\n-        } catch (Throwable ex) {\n-            throw new ExceptionInInitializerError(ex);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"addressHandles\")\n-    public void testAddressHandle(VarHandle addrHandle, int byteSize) {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n-            MemorySegment target = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN ?\n-                    segment.asSlice(8 - byteSize) :\n-                    segment;\n-            longHandle.set(segment, 42L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(target);\n-            assertEquals(address.toRawLongValue(), 42L);\n-            addrHandle.set(target, address.addOffset(1));\n-            long result = (long)longHandle.get(segment);\n-            assertEquals(43L, result);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"addressHandles\")\n-    public void testNull(VarHandle addrHandle, int byteSize) {\n-        VarHandle longHandle = MemoryLayouts.JAVA_LONG.varHandle(long.class);\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment segment = MemorySegment.allocateNative(8, scope);\n-            longHandle.set(segment, 0L);\n-            MemoryAddress address = (MemoryAddress)addrHandle.get(segment);\n-            assertTrue(address == MemoryAddress.NULL);\n-        }\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptFloat() {\n-        VarHandle floatHandle = MemoryLayouts.JAVA_FLOAT.varHandle(float.class);\n-        MemoryHandles.asAddressVarHandle(floatHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptDouble() {\n-        VarHandle doubleHandle = MemoryLayouts.JAVA_DOUBLE.varHandle(double.class);\n-        MemoryHandles.asAddressVarHandle(doubleHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptBoolean() {\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        VarHandle boolHandle = MemoryHandles.filterValue(intHandle, BOOL_TO_INT, INT_TO_BOOL);\n-        MemoryHandles.asAddressVarHandle(boolHandle);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testBadAdaptString() {\n-        VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-        VarHandle stringHandle = MemoryHandles.filterValue(intHandle, STRING_TO_INT, INT_TO_STRING);\n-        MemoryHandles.asAddressVarHandle(stringHandle);\n-    }\n-\n-    @DataProvider(name = \"addressHandles\")\n-    static Object[][] addressHandles() {\n-        return new Object[][] {\n-                \/\/ long\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(long.class, ByteOrder.nativeOrder()), 0)), 8 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_LONG.varHandle(long.class)), 8 },\n-\n-                \/\/ int\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()), 0)), 4 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_INT.varHandle(int.class)), 4 },\n-\n-                \/\/ short\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(short.class, ByteOrder.nativeOrder()), 0)), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_SHORT.varHandle(short.class)), 2 },\n-\n-                \/\/ char\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(char.class, ByteOrder.nativeOrder()), 0)), 2 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_CHAR.varHandle(char.class)), 2 },\n-\n-                \/\/ byte\n-                { MemoryHandles.asAddressVarHandle(at(MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder()), 0)), 1 },\n-                { MemoryHandles.asAddressVarHandle(MemoryLayouts.JAVA_BYTE.varHandle(byte.class)), 1 }\n-        };\n-    }\n-\n-    static VarHandle at(VarHandle handle, long offset) {\n-        return MemoryHandles.insertCoordinates(handle, 1, offset);\n-    }\n-\n-    static int boolToInt(boolean value) {\n-        return value ? 1 : 0;\n-    }\n-\n-    static boolean intToBool(int value) {\n-        return value != 0;\n-    }\n-\n-    static int stringToInt(String value) {\n-        return value.length();\n-    }\n-\n-    static String intToString(int value) {\n-        return String.valueOf(value);\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestAddressHandle.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -0,0 +1,542 @@\n+\/*\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestArrayCopy\n+ *\/\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.fail;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * These tests exercise the MemoryCopy copyFromArray(...) and copyToArray(...).\n+ * To make these tests more challenging the segment is a view of the given array,\n+ * which makes the copy operations overlapping self-copies.  Thus, this checks the claim:\n+ *\n+ * <p>If the source (destination) segment is actually a view of the destination (source) array,\n+ * and if the copy region of the source overlaps with the copy region of the destination,\n+ * the copy of the overlapping region is performed as if the data in the overlapping region\n+ * were first copied into a temporary segment before being copied to the destination.<\/p>\n+ *\/\n+public class TestArrayCopy {\n+    private static final ByteOrder NATIVE_ORDER = ByteOrder.nativeOrder();\n+    private static final ByteOrder NON_NATIVE_ORDER = NATIVE_ORDER == ByteOrder.LITTLE_ENDIAN\n+            ? ByteOrder.BIG_ENDIAN : ByteOrder.LITTLE_ENDIAN;\n+\n+    private static final int SEG_LENGTH_BYTES = 32;\n+    private static final int SEG_OFFSET_BYTES = 8;\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testSelfCopy(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        MemorySegment truth = truthSegment(base, helper, indexShifts, mode);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? SEG_OFFSET_BYTES : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        assertEquals(truth.mismatch(dstSeg), -1);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : SEG_OFFSET_BYTES;\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+        MemorySegment result = helper.fromArray(dstArr);\n+        assertEquals(truth.mismatch(result), -1);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testUnalignedCopy(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        int indexShifts = SEG_OFFSET_BYTES \/ bytesPerElement;\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        ByteOrder bo = mode.swap ? NON_NATIVE_ORDER : NATIVE_ORDER;\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        int srcIndex = mode.direction ? 0 : indexShifts;\n+        int srcCopyLen = helper.length(srcArr) - indexShifts;\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        long dstOffsetBytes = mode.direction ? (SEG_OFFSET_BYTES - 1) : 0;\n+        helper.copyFromArray(srcArr, srcIndex, srcCopyLen, dstSeg, dstOffsetBytes, bo);\n+        \/\/CopyTo\n+        long srcOffsetBytes = mode.direction ? 0 : (SEG_OFFSET_BYTES - 1);\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        int dstIndex = mode.direction ? indexShifts : 0;\n+        int dstCopyLen = helper.length(dstArr) - indexShifts;\n+        helper.copyToArray(srcSeg, srcOffsetBytes, dstArr, dstIndex, dstCopyLen, bo);\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobLength(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, 0, (SEG_LENGTH_BYTES \/ bytesPerElement) * 2, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeIndices(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, -1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyNegativeOffsets(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, -1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, -1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobIndices(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, helper.length(srcArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, 0, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, 0, dstArr, helper.length(dstArr) + 1, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(dataProvider = \"copyModesAndHelpers\")\n+    public void testCopyOobOffsets(CopyMode mode, CopyHelper<Object, ValueLayout> helper, String helperDebugString) {\n+        int bytesPerElement = (int)helper.elementLayout.byteSize();\n+        MemorySegment base = srcSegment(SEG_LENGTH_BYTES);\n+        \/\/CopyFrom\n+        Object srcArr = helper.toArray(base);\n+        MemorySegment dstSeg = helper.fromArray(srcArr);\n+        try {\n+            helper.copyFromArray(srcArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, dstSeg, SEG_LENGTH_BYTES + 1, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+        \/\/CopyTo\n+        Object dstArr = helper.toArray(base);\n+        MemorySegment srcSeg = helper.fromArray(dstArr).asReadOnly();\n+        try {\n+            helper.copyToArray(srcSeg, SEG_OFFSET_BYTES + 1, dstArr, 0, SEG_LENGTH_BYTES \/ bytesPerElement, ByteOrder.nativeOrder());\n+            fail();\n+        } catch (IndexOutOfBoundsException ex) {\n+            \/\/ok\n+        }\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNotAnArraySrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_BYTE, 0, new String[] { \"hello\" }, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testNotAnArrayDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(new String[] { \"hello\" }, 0, segment, JAVA_BYTE, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testCarrierMismatchSrc() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(segment, JAVA_INT, 0, new byte[] { 1, 2, 3, 4 }, 0, 4);\n+    }\n+\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testCarrierMismatchDst() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[] {1, 2, 3, 4});\n+        MemorySegment.copy(new byte[] { 1, 2, 3, 4 }, 0, segment, JAVA_INT, 0, 4);\n+    }\n+\n+    \/***** Utilities *****\/\n+\n+    public static MemorySegment srcSegment(int bytesLength) {\n+        byte[] arr = new byte[bytesLength];\n+        for (int i = 0; i < arr.length; i++) {\n+            arr[i] = (byte)i;\n+        }\n+        return MemorySegment.ofArray(arr);\n+    }\n+\n+    public static MemorySegment truthSegment(MemorySegment srcSeg, CopyHelper<?, ?> helper, int indexShifts, CopyMode mode) {\n+        VarHandle indexedHandleNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NATIVE_ORDER))\n+                                                .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        VarHandle indexedHandleNNO = MemoryLayout.sequenceLayout(helper.elementLayout.withOrder(NON_NATIVE_ORDER))\n+                                                 .varHandle(MemoryLayout.PathElement.sequenceElement());\n+        MemorySegment dstSeg = MemorySegment.ofArray(srcSeg.toArray(JAVA_BYTE));\n+        int indexLength = (int) dstSeg.byteSize() \/ (int)helper.elementLayout.byteSize();\n+        if (mode.direction) {\n+            if (mode.swap) {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            } else {\n+                for (int i = indexLength - 1; i >= indexShifts; i--) {\n+                    Object v = indexedHandleNO.get(dstSeg, i - indexShifts);\n+                    indexedHandleNO.set(dstSeg, i, v);\n+                }\n+            }\n+        } else { \/\/down\n+            if (mode.swap) {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            } else {\n+                for (int i = indexShifts; i < indexLength; i++) {\n+                    Object v = indexedHandleNO.get(dstSeg, i);\n+                    indexedHandleNO.set(dstSeg, i - indexShifts, v);\n+                }\n+            }\n+        }\n+        return dstSeg;\n+    }\n+\n+    enum CopyMode {\n+        UP_NO_SWAP(true, false),\n+        UP_SWAP(true, true),\n+        DOWN_NO_SWAP(false, false),\n+        DOWN_SWAP(false, true);\n+\n+        final boolean direction;\n+        final boolean swap;\n+\n+        CopyMode(boolean direction, boolean swap) {\n+            this.direction = direction;\n+            this.swap = swap;\n+        }\n+    }\n+\n+    abstract static class CopyHelper<X, L extends ValueLayout> {\n+\n+        final L elementLayout;\n+        final Class<?> carrier;\n+\n+        public CopyHelper(L elementLayout, Class<X> carrier) {\n+            this.elementLayout = elementLayout;\n+            this.carrier = carrier;\n+        }\n+\n+        abstract void copyFromArray(X srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo);\n+        abstract void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, X dstArr, int dstIndex, int dstCopyLen, ByteOrder bo);\n+        abstract X toArray(MemorySegment segment);\n+        abstract MemorySegment fromArray(X array);\n+        abstract int length(X arr);\n+\n+        @Override\n+        public String toString() {\n+            return \"CopyHelper{\" +\n+                    \"elementLayout=\" + elementLayout +\n+                    \", carrier=\" + carrier.getName() +\n+                    '}';\n+        }\n+\n+        static final CopyHelper<byte[], ValueLayout.OfByte> BYTE = new CopyHelper<>(JAVA_BYTE, byte[].class) {\n+            @Override\n+            void copyFromArray(byte[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, byte[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            byte[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(byte[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(byte[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<char[], ValueLayout.OfChar> CHAR = new CopyHelper<>(ValueLayout.JAVA_CHAR, char[].class) {\n+            @Override\n+            void copyFromArray(char[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, char[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            char[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(char[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(char[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<short[], ValueLayout.OfShort> SHORT = new CopyHelper<>(ValueLayout.JAVA_SHORT, short[].class) {\n+            @Override\n+            void copyFromArray(short[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, short[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            short[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(short[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(short[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<int[], ValueLayout.OfInt> INT = new CopyHelper<>(ValueLayout.JAVA_INT, int[].class) {\n+            @Override\n+            void copyFromArray(int[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, int[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            int[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(int[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(int[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<float[], ValueLayout.OfFloat> FLOAT = new CopyHelper<>(ValueLayout.JAVA_FLOAT, float[].class) {\n+            @Override\n+            void copyFromArray(float[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, float[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            float[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(float[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(float[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<long[], ValueLayout.OfLong> LONG = new CopyHelper<>(ValueLayout.JAVA_LONG, long[].class) {\n+            @Override\n+            void copyFromArray(long[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, long[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            long[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(long[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(long[] arr) {\n+                return arr.length;\n+            }\n+        };\n+\n+        static final CopyHelper<double[], ValueLayout.OfDouble> DOUBLE = new CopyHelper<>(ValueLayout.JAVA_DOUBLE, double[].class) {\n+            @Override\n+            void copyFromArray(double[] srcArr, int srcIndex, int srcCopyLen, MemorySegment dstSeg, long dstOffsetBytes, ByteOrder bo) {\n+                MemorySegment.copy(srcArr, srcIndex, dstSeg, elementLayout.withOrder(bo), dstOffsetBytes, srcCopyLen);\n+            }\n+\n+            @Override\n+            void copyToArray(MemorySegment srcSeg, long srcOffsetBytes, double[] dstArr, int dstIndex, int dstCopyLen, ByteOrder bo) {\n+                MemorySegment.copy(srcSeg, elementLayout.withOrder(bo), srcOffsetBytes, dstArr, dstIndex, dstCopyLen);\n+            }\n+\n+            @Override\n+            double[] toArray(MemorySegment segment) {\n+                return segment.toArray(elementLayout);\n+            }\n+\n+            @Override\n+            MemorySegment fromArray(double[] array) {\n+                return MemorySegment.ofArray(array);\n+            }\n+\n+            @Override\n+            int length(double[] arr) {\n+                return arr.length;\n+            }\n+        };\n+    }\n+\n+    @DataProvider\n+    Object[][] copyModesAndHelpers() {\n+        CopyHelper<?, ?>[] helpers = { CopyHelper.BYTE, CopyHelper.CHAR, CopyHelper.SHORT, CopyHelper.INT,\n+                                    CopyHelper.FLOAT, CopyHelper.LONG, CopyHelper.DOUBLE };\n+        List<Object[]> results = new ArrayList<>();\n+        for (CopyHelper<?, ?> helper : helpers) {\n+            for (CopyMode mode : CopyMode.values()) {\n+                results.add(new Object[] { mode, helper, helper.toString() });\n+            }\n+        }\n+        return results.stream().toArray(Object[][]::new);\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestArrayCopy.java","additions":542,"deletions":0,"binary":false,"changes":542,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -46,0 +45,7 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -51,1 +57,1 @@\n-            MemoryLayouts.JAVA_BYTE\n+            JAVA_BYTE\n@@ -55,1 +61,1 @@\n-            MemoryLayouts.JAVA_CHAR\n+            JAVA_CHAR\n@@ -59,1 +65,1 @@\n-            MemoryLayouts.JAVA_SHORT\n+            JAVA_SHORT\n@@ -63,1 +69,1 @@\n-            MemoryLayouts.JAVA_INT\n+            JAVA_INT\n@@ -67,1 +73,1 @@\n-            MemoryLayouts.JAVA_FLOAT\n+            JAVA_FLOAT\n@@ -71,1 +77,1 @@\n-            MemoryLayouts.JAVA_LONG\n+            JAVA_LONG\n@@ -75,1 +81,1 @@\n-            MemoryLayouts.JAVA_DOUBLE\n+            JAVA_DOUBLE\n@@ -78,7 +84,7 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = longs.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = doubles.varHandle(double.class, PathElement.sequenceElement());\n+    static VarHandle byteHandle = bytes.varHandle(PathElement.sequenceElement());\n+    static VarHandle charHandle = chars.varHandle(PathElement.sequenceElement());\n+    static VarHandle shortHandle = shorts.varHandle(PathElement.sequenceElement());\n+    static VarHandle intHandle = ints.varHandle(PathElement.sequenceElement());\n+    static VarHandle floatHandle = floats.varHandle(PathElement.sequenceElement());\n+    static VarHandle longHandle = longs.varHandle(PathElement.sequenceElement());\n+    static VarHandle doubleHandle = doubles.varHandle(PathElement.sequenceElement());\n@@ -115,1 +121,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(seq.byteSize(), ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, seq.byteSize(), ResourceScope.globalScope());\n@@ -155,1 +161,1 @@\n-                (base) -> checkBytes(base, bytes, MemorySegment::toByteArray, (addr, pos) -> (byte)byteHandle.get(addr, pos));\n+                (base) -> checkBytes(base, bytes, s -> s.toArray(JAVA_BYTE), (addr, pos) -> (byte)byteHandle.get(addr, pos));\n@@ -157,1 +163,1 @@\n-                (base) -> checkBytes(base, shorts, MemorySegment::toShortArray, (addr, pos) -> (short)shortHandle.get(addr, pos));\n+                (base) -> checkBytes(base, shorts, s -> s.toArray(JAVA_SHORT), (addr, pos) -> (short)shortHandle.get(addr, pos));\n@@ -159,1 +165,1 @@\n-                (base) -> checkBytes(base, chars, MemorySegment::toCharArray, (addr, pos) -> (char)charHandle.get(addr, pos));\n+                (base) -> checkBytes(base, chars, s -> s.toArray(JAVA_CHAR), (addr, pos) -> (char)charHandle.get(addr, pos));\n@@ -161,1 +167,1 @@\n-                (base) -> checkBytes(base, ints, MemorySegment::toIntArray, (addr, pos) -> (int)intHandle.get(addr, pos));\n+                (base) -> checkBytes(base, ints, s -> s.toArray(JAVA_INT), (addr, pos) -> (int)intHandle.get(addr, pos));\n@@ -163,1 +169,1 @@\n-                (base) -> checkBytes(base, floats, MemorySegment::toFloatArray, (addr, pos) -> (float)floatHandle.get(addr, pos));\n+                (base) -> checkBytes(base, floats, s -> s.toArray(JAVA_FLOAT), (addr, pos) -> (float)floatHandle.get(addr, pos));\n@@ -165,1 +171,1 @@\n-                (base) -> checkBytes(base, longs, MemorySegment::toLongArray, (addr, pos) -> (long)longHandle.get(addr, pos));\n+                (base) -> checkBytes(base, longs, s -> s.toArray(JAVA_LONG), (addr, pos) -> (long)longHandle.get(addr, pos));\n@@ -167,1 +173,1 @@\n-                (base) -> checkBytes(base, doubles, MemorySegment::toDoubleArray, (addr, pos) -> (double)doubleHandle.get(addr, pos));\n+                (base) -> checkBytes(base, doubles, s -> s.toArray(JAVA_DOUBLE), (addr, pos) -> (double)doubleHandle.get(addr, pos));\n@@ -183,7 +189,7 @@\n-                { MemoryLayouts.JAVA_BYTE, (Function<MemorySegment, Object>) MemorySegment::toByteArray },\n-                { MemoryLayouts.JAVA_SHORT, (Function<MemorySegment, Object>) MemorySegment::toShortArray },\n-                { MemoryLayouts.JAVA_CHAR, (Function<MemorySegment, Object>) MemorySegment::toCharArray },\n-                { MemoryLayouts.JAVA_INT, (Function<MemorySegment, Object>) MemorySegment::toIntArray },\n-                { MemoryLayouts.JAVA_FLOAT, (Function<MemorySegment, Object>) MemorySegment::toFloatArray },\n-                { MemoryLayouts.JAVA_LONG, (Function<MemorySegment, Object>) MemorySegment::toLongArray },\n-                { MemoryLayouts.JAVA_DOUBLE, (Function<MemorySegment, Object>) MemorySegment::toDoubleArray }\n+                { JAVA_BYTE, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_BYTE)},\n+                { JAVA_SHORT, (Function<MemorySegment, Object>) s -> s.toArray(JAVA_SHORT)},\n+                { JAVA_CHAR, (Function<MemorySegment, Object>) s -> s.toArray(JAVA_CHAR)},\n+                { JAVA_INT, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_INT)},\n+                { JAVA_FLOAT, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_FLOAT)},\n+                { JAVA_LONG, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_LONG)},\n+                { JAVA_DOUBLE, (Function<MemorySegment, Object>)s -> s.toArray(JAVA_DOUBLE)}\n","filename":"test\/jdk\/java\/foreign\/TestArrays.java","additions":36,"deletions":30,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,2 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -85,0 +83,7 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -105,2 +110,2 @@\n-                    MemoryLayouts.BITS_32_BE.withName(\"index\"),\n-                    MemoryLayouts.BITS_32_BE.withName(\"value\")\n+                    JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"index\"),\n+                    JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN).withName(\"value\")\n@@ -110,1 +115,1 @@\n-            MemoryLayouts.BITS_8_BE\n+            JAVA_BYTE\n@@ -114,1 +119,1 @@\n-            MemoryLayouts.BITS_16_BE\n+            JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -118,1 +123,1 @@\n-            MemoryLayouts.BITS_16_BE\n+            JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -122,1 +127,1 @@\n-            MemoryLayouts.BITS_32_BE\n+            JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -126,1 +131,1 @@\n-            MemoryLayouts.BITS_32_BE\n+            JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -130,1 +135,1 @@\n-            MemoryLayouts.BITS_64_BE\n+            JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -134,1 +139,1 @@\n-            MemoryLayouts.BITS_64_BE\n+            JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN)\n@@ -137,2 +142,2 @@\n-    static VarHandle indexHandle = tuples.varHandle(int.class, PathElement.sequenceElement(), PathElement.groupElement(\"index\"));\n-    static VarHandle valueHandle = tuples.varHandle(float.class, PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n+    static VarHandle indexHandle = tuples.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"index\"));\n+    static VarHandle valueHandle = tuples.varHandle(PathElement.sequenceElement(), PathElement.groupElement(\"value\"));\n@@ -266,1 +271,1 @@\n-    @Test(dataProvider = \"mappedOps\", expectedExceptions = UnsupportedOperationException.class)\n+    @Test(dataProvider = \"mappedOps\", expectedExceptions = IllegalStateException.class)\n@@ -327,0 +332,3 @@\n+        } catch(IOException e) {\n+            if (e.getMessage().equals(\"Function not implemented\"))\n+                throw new SkipException(e.getMessage(), e);\n@@ -483,1 +491,1 @@\n-        MemorySegment segment = MemoryAddress.NULL.asSegment(Integer.MAX_VALUE + 10L, ResourceScope.globalScope());\n+        MemorySegment segment = MemorySegment.ofAddressNative(MemoryAddress.NULL, Integer.MAX_VALUE + 10L, ResourceScope.newImplicitScope());\n@@ -514,1 +522,1 @@\n-                MemoryAccess.setByteAtOffset(segment, offset, offset);\n+                segment.set(JAVA_BYTE, offset, offset);\n@@ -522,1 +530,1 @@\n-                assertEquals(MemoryAccess.getByte(segment), offset);\n+                assertEquals(segment.get(JAVA_BYTE, 0), offset);\n@@ -639,1 +647,1 @@\n-        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT, ResourceScope.newConfinedScope());\n+        MemorySegment s1 = MemorySegment.allocateNative(JAVA_INT, ResourceScope.newConfinedScope());\n@@ -645,1 +653,1 @@\n-        MemoryAccess.setInt(s2, 10); \/\/ Dead access!\n+        s2.set(JAVA_INT, 0, 10); \/\/ Dead access!\n@@ -657,1 +665,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                segment.set(JAVA_BYTE, i, (byte) i);\n@@ -677,1 +685,1 @@\n-                MemoryAccess.setByteAtOffset(segment, i, (byte) i);\n+                segment.set(JAVA_BYTE, i, (byte) i);\n@@ -697,1 +705,1 @@\n-            var bytes = slice.toByteArray();\n+            var bytes = slice.toArray(JAVA_BYTE);\n@@ -722,0 +730,1 @@\n+                { (Supplier<MemorySegment>) () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()) },\n@@ -732,9 +741,2 @@\n-                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) }\n-        };\n-    }\n-\n-    @DataProvider(name = \"implicitScopes\")\n-    public static Object[][] implicitScopes() {\n-        return new Object[][] {\n-                { (Supplier<ResourceScope>) ResourceScope::newImplicitScope },\n-                { (Supplier<ResourceScope>) ResourceScope::globalScope      },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newConfinedScope(Cleaner.create()) },\n+                { (Supplier<ResourceScope>) () -> ResourceScope.newImplicitScope() }\n@@ -746,1 +748,1 @@\n-        return Stream.of(implicitScopes(), closeableScopes())\n+        return Stream.of(new Object[][] { { (Supplier<ResourceScope>)ResourceScope::globalScope } }, closeableScopes())\n@@ -752,1 +754,1 @@\n-        if (scope.isImplicit())\n+        if (scope == ResourceScope.globalScope())\n@@ -815,1 +817,1 @@\n-                (base) -> initBytes(base, bytes, (addr, pos) -> MemoryAccess.setByteAtOffset(addr, pos, (byte)(long)pos));\n+                (base) -> initBytes(base, bytes, (addr, pos) -> addr.set(JAVA_BYTE, pos, (byte)(long)pos));\n@@ -817,1 +819,1 @@\n-                (base) -> initBytes(base, chars, (addr, pos) -> MemoryAccess.setCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (char)(long)pos));\n+                (base) -> initBytes(base, chars, (addr, pos) -> addr.setAtIndex(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), pos, (char)(long)pos));\n@@ -819,1 +821,1 @@\n-                (base) -> initBytes(base, shorts, (addr, pos) -> MemoryAccess.setShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (short)(long)pos));\n+                (base) -> initBytes(base, shorts, (addr, pos) -> addr.setAtIndex(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), pos, (short)(long)pos));\n@@ -821,1 +823,1 @@\n-                (base) -> initBytes(base, ints, (addr, pos) -> MemoryAccess.setIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (int)(long)pos));\n+                (base) -> initBytes(base, ints, (addr, pos) -> addr.setAtIndex(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), pos, (int)(long)pos));\n@@ -823,1 +825,1 @@\n-                (base) -> initBytes(base, floats, (addr, pos) -> MemoryAccess.setFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (float)(long)pos));\n+                (base) -> initBytes(base, floats, (addr, pos) -> addr.setAtIndex(JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), pos, (float)(long)pos));\n@@ -825,1 +827,1 @@\n-                (base) -> initBytes(base, longs, (addr, pos) -> MemoryAccess.setLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (long)pos));\n+                (base) -> initBytes(base, longs, (addr, pos) -> addr.setAtIndex(JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), pos, (long)pos));\n@@ -827,1 +829,1 @@\n-                (base) -> initBytes(base, doubles, (addr, pos) -> MemoryAccess.setDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN, (double)(long)pos));\n+                (base) -> initBytes(base, doubles, (addr, pos) -> addr.setAtIndex(JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), pos, (double)(long)pos));\n@@ -830,1 +832,1 @@\n-                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> MemoryAccess.getByteAtOffset(addr, pos), ByteBuffer::get);\n+                (base) -> checkBytes(base, bytes, Function.identity(), (addr, pos) -> addr.get(JAVA_BYTE, pos), ByteBuffer::get);\n@@ -832,1 +834,1 @@\n-                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> MemoryAccess.getCharAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), CharBuffer::get);\n+                (base) -> checkBytes(base, chars, ByteBuffer::asCharBuffer, (addr, pos) -> addr.getAtIndex(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), pos), CharBuffer::get);\n@@ -834,1 +836,1 @@\n-                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> MemoryAccess.getShortAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), ShortBuffer::get);\n+                (base) -> checkBytes(base, shorts, ByteBuffer::asShortBuffer, (addr, pos) -> addr.getAtIndex(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), pos), ShortBuffer::get);\n@@ -836,1 +838,1 @@\n-                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> MemoryAccess.getIntAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), IntBuffer::get);\n+                (base) -> checkBytes(base, ints, ByteBuffer::asIntBuffer, (addr, pos) -> addr.getAtIndex(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), pos), IntBuffer::get);\n@@ -838,1 +840,1 @@\n-                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> MemoryAccess.getFloatAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), FloatBuffer::get);\n+                (base) -> checkBytes(base, floats, ByteBuffer::asFloatBuffer, (addr, pos) -> addr.getAtIndex(JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), pos), FloatBuffer::get);\n@@ -840,1 +842,1 @@\n-                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> MemoryAccess.getLongAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), LongBuffer::get);\n+                (base) -> checkBytes(base, longs, ByteBuffer::asLongBuffer, (addr, pos) -> addr.getAtIndex(JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), pos), LongBuffer::get);\n@@ -842,1 +844,1 @@\n-                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> MemoryAccess.getDoubleAtIndex(addr, pos, ByteOrder.BIG_ENDIAN), DoubleBuffer::get);\n+                (base) -> checkBytes(base, doubles, ByteBuffer::asDoubleBuffer, (addr, pos) -> addr.getAtIndex(JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), pos), DoubleBuffer::get);\n","filename":"test\/jdk\/java\/foreign\/TestByteBuffer.java","additions":49,"deletions":47,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm TestCircularInit1\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-public class TestCircularInit1 {\n-\n-    @Test\n-    public void testCircularInit() {\n-        System.out.println(PlatformLayouts.Win64.C_CHAR); \/\/ trigger clinit\n-        assertNotNull(CLinker.C_CHAR); \/\/ should not be null\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit1.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,47 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n- * @modules jdk.incubator.foreign\/jdk.internal.foreign\n- * @run testng\/othervm TestCircularInit2\n- *\/\n-\n-import jdk.incubator.foreign.CLinker;\n-import jdk.internal.foreign.PlatformLayouts;\n-import org.testng.annotations.Test;\n-\n-import static org.testng.Assert.assertNotNull;\n-\n-public class TestCircularInit2 {\n-\n-    @Test\n-    public void testCircularInit() {\n-        System.out.println(CLinker.C_CHAR); \/\/ trigger clinit\n-        assertNotNull(PlatformLayouts.Win64.C_CHAR);\n-        assertNotNull(PlatformLayouts.SysV.C_CHAR);\n-        assertNotNull(PlatformLayouts.AArch64.C_CHAR);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/foreign\/TestCircularInit2.java","additions":0,"deletions":47,"binary":false,"changes":47,"status":"deleted"},{"patch":"@@ -42,1 +42,9 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -56,8 +64,9 @@\n-        C_CHAR,\n-        C_SHORT,\n-        C_INT,\n-        C_LONG,\n-        C_LONG_LONG,\n-        C_FLOAT,\n-        C_DOUBLE,\n-        C_POINTER\n+        JAVA_BOOLEAN,\n+        JAVA_CHAR,\n+        JAVA_BYTE,\n+        JAVA_SHORT,\n+        JAVA_INT,\n+        JAVA_FLOAT,\n+        JAVA_LONG,\n+        JAVA_DOUBLE,\n+        ADDRESS\n@@ -81,1 +90,1 @@\n-        testValues.add(FunctionDescriptor.of(C_CHAR, constants));\n+        testValues.add(FunctionDescriptor.of(JAVA_BYTE, constants));\n","filename":"test\/jdk\/java\/foreign\/TestCondy.java","additions":19,"deletions":10,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +39,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -55,1 +58,1 @@\n-    static CLinker abi = CLinker.getInstance();\n+    static CLinker abi = CLinker.systemCLinker();\n@@ -65,1 +68,1 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n@@ -69,1 +72,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n@@ -71,1 +74,4 @@\n-            Object res = doCall(addr, scope, mt, descriptor, args);\n+            SegmentAllocator allocator = needsScope ?\n+                    SegmentAllocator.newNativeArena(scope) :\n+                    THROWING_ALLOCATOR;\n+            Object res = doCall(addr, allocator, descriptor, args);\n@@ -76,5 +82,1 @@\n-                    assertEquals(((MemorySegment) res).scope(), scope.scope());\n-                    assertEquals(scope.allocatedBytes(), descriptor.returnLayout().get().byteSize());\n-                } else {\n-                    \/\/ if here, there should be no allocation through the scope!\n-                    assertEquals(scope.allocatedBytes(), 0L);\n+                    assertEquals(((MemorySegment) res).scope(), scope);\n@@ -82,3 +84,0 @@\n-            } else {\n-                \/\/ if here, there should be no allocation through the scope!\n-                assertEquals(scope.allocatedBytes(), 0L);\n@@ -89,25 +88,2 @@\n-    @Test(dataProvider=\"functions\", dataProviderClass=CallGeneratorHelper.class)\n-    public void testDowncallNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n-        List<Consumer<Object>> checks = new ArrayList<>();\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n-        MethodType mt = methodType(ret, paramTypes, fields);\n-        FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n-        Object[] args = makeArgs(paramTypes, fields, checks);\n-        boolean needsScope = mt.returnType().equals(MemorySegment.class);\n-        Object res = doCall(addr, IMPLICIT_ALLOCATOR, mt, descriptor, args);\n-        if (ret == Ret.NON_VOID) {\n-            checks.forEach(c -> c.accept(res));\n-            if (needsScope) {\n-                \/\/ check that return struct has indeed been allocated in the default scope\n-                try {\n-                    ((MemorySegment)res).scope().close(); \/\/ should throw\n-                    fail(\"Expected exception!\");\n-                } catch (UnsupportedOperationException ex) {\n-                    \/\/ ok\n-                }\n-            }\n-        }\n-    }\n-\n-    Object doCall(MemoryAddress addr, SegmentAllocator allocator, MethodType type, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n-        MethodHandle mh = abi.downcallHandle(addr, allocator, type, descriptor);\n+    Object doCall(NativeSymbol symbol, SegmentAllocator allocator, FunctionDescriptor descriptor, Object[] args) throws Throwable {\n+        MethodHandle mh = downcallHandle(abi, symbol, allocator, descriptor);\n@@ -120,1 +96,1 @@\n-                MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));\n+                MethodType.methodType(void.class) : MethodType.methodType(carrier(params.get(0).layout(fields), false));\n@@ -122,1 +98,1 @@\n-            mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));\n+            mt = mt.appendParameterTypes(carrier(p.layout(fields), true));\n","filename":"test\/jdk\/java\/foreign\/TestDowncall.java","additions":15,"deletions":39,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -38,1 +37,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -41,1 +39,1 @@\n-public class TestFree {\n+public class TestFree extends NativeTestHelper {\n@@ -43,1 +41,1 @@\n-        return addr.asSegment(numElements * layout.byteSize(), ResourceScope.globalScope());\n+        return MemorySegment.ofAddressNative(addr, numElements * layout.byteSize(), ResourceScope.globalScope());\n@@ -51,2 +49,2 @@\n-        MemoryAccess.setByteAtOffset(seg, str.length(), (byte)0);\n-        assertEquals(str, toJavaString(seg));\n+        seg.set(C_CHAR, str.length(), (byte)0);\n+        assertEquals(str, seg.getUtf8String(0));\n","filename":"test\/jdk\/java\/foreign\/TestFree.java","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @run testng TestFunctionDescriptor\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestFunctionDescriptor\n@@ -40,4 +40,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -48,1 +44,1 @@\n-public class TestFunctionDescriptor {\n+public class TestFunctionDescriptor extends NativeTestHelper {\n@@ -71,15 +67,0 @@\n-    @Test\n-    public void testAttribute() {\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n-        fd = fd.withAttribute(DUMMY_ATTR, true);\n-\n-        assertEquals(fd.argumentLayouts(), List.of(C_DOUBLE, C_LONG_LONG));\n-        Optional<MemoryLayout> returnLayoutOp = fd.returnLayout();\n-        assertTrue(returnLayoutOp.isPresent());\n-        assertEquals(returnLayoutOp.get(), C_INT);\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n-        Optional<Constable> attr = fd.attribute(DUMMY_ATTR);\n-        assertTrue(attr.isPresent());\n-        assertEquals(attr.get(), true);\n-    }\n-\n@@ -88,2 +69,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -96,1 +76,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n@@ -101,2 +80,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -109,1 +87,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n@@ -114,2 +91,1 @@\n-        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG)\n-                                                  .withAttribute(DUMMY_ATTR, true);\n+        FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_DOUBLE, C_LONG_LONG);\n@@ -121,1 +97,0 @@\n-        assertEquals(fd.attributes().collect(Collectors.toList()), List.of(DUMMY_ATTR));\n","filename":"test\/jdk\/java\/foreign\/TestFunctionDescriptor.java","additions":5,"deletions":30,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -51,0 +50,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -153,1 +154,1 @@\n-                sum += MemoryAccess.getByteAtOffset(segment, i);\n+                sum += segment.get(JAVA_BYTE, i);\n@@ -196,1 +197,1 @@\n-            MemoryAccess.setByteAtOffset(copy, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n+            copy.set(JAVA_BYTE, ThreadLocalRandom.current().nextInt(SEGMENT_SIZE), (byte)42);\n","filename":"test\/jdk\/java\/foreign\/TestHandshake.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -35,2 +35,2 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,3 +40,0 @@\n-import java.lang.invoke.MethodType;\n-\n-import static jdk.incubator.foreign.CLinker.C_INT;\n@@ -46,1 +43,1 @@\n-public class TestIllegalLink {\n+public class TestIllegalLink extends NativeTestHelper {\n@@ -48,2 +45,2 @@\n-    private static final MemoryAddress DUMMY_TARGET = MemoryAddress.ofLong(1);\n-    private static final CLinker ABI = CLinker.getInstance();\n+    private static final NativeSymbol DUMMY_TARGET = NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope());\n+    private static final CLinker ABI = CLinker.systemCLinker();\n@@ -52,1 +49,1 @@\n-    public void testTypeMismatch(MethodType mt, FunctionDescriptor desc, String expectedExceptionMessage) {\n+    public void testTypeMismatch(FunctionDescriptor desc, String expectedExceptionMessage) {\n@@ -54,1 +51,1 @@\n-            ABI.downcallHandle(DUMMY_TARGET, mt, desc);\n+            ABI.downcallHandle(DUMMY_TARGET, desc);\n@@ -65,8 +62,2 @@\n-                MethodType.methodType(void.class),\n-                FunctionDescriptor.of(C_INT),\n-                \"Return type mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class),\n-                FunctionDescriptor.ofVoid(C_INT),\n-                \"Arity mismatch\"\n+                FunctionDescriptor.of(MemoryLayout.paddingLayout(64)),\n+                \"Unsupported layout: x64\"\n@@ -75,16 +66,0 @@\n-                MethodType.methodType(void.class, int.class),\n-                FunctionDescriptor.ofVoid(MemoryLayout.paddingLayout(32)),\n-                \"Expected a ValueLayout\"\n-            },\n-            {\n-                MethodType.methodType(void.class, boolean.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_8_LE),\n-                \"Unsupported carrier\"\n-            },\n-            {\n-                MethodType.methodType(void.class, int.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Carrier size mismatch\"\n-            },\n-            {\n-                MethodType.methodType(void.class, MemoryAddress.class),\n@@ -92,6 +67,1 @@\n-                \"Expected a ValueLayout\"\n-            },\n-            {\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_16_LE),\n-                \"Address size mismatch\"\n+                \"Unsupported layout: x64\"\n@@ -100,3 +70,2 @@\n-                MethodType.methodType(void.class, MemorySegment.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Expected a GroupLayout\"\n+                    FunctionDescriptor.of(MemoryLayout.sequenceLayout(C_INT)),\n+                    \"Unsupported layout: [:b32]\"\n@@ -105,3 +74,2 @@\n-                MethodType.methodType(void.class, String.class),\n-                FunctionDescriptor.ofVoid(MemoryLayouts.BITS_64_LE),\n-                \"Unsupported carrier\"\n+                    FunctionDescriptor.ofVoid(MemoryLayout.sequenceLayout(C_INT)),\n+                    \"Unsupported layout: [:b32]\"\n","filename":"test\/jdk\/java\/foreign\/TestIllegalLink.java","additions":14,"deletions":46,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -49,2 +50,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n-import static jdk.incubator.foreign.FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n@@ -53,1 +53,1 @@\n-public class TestIntrinsics {\n+public class TestIntrinsics extends NativeTestHelper {\n@@ -55,1 +55,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -91,1 +91,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(name).get();\n+            NativeSymbol ma = LOOKUP.lookup(name).get();\n@@ -95,3 +95,2 @@\n-            tests.add(abi.downcallHandle(ma, mt, fd), arg, arg);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), arg, arg);\n-            tests.add(abi.downcallHandle(mt, fd), arg, ma, arg);\n+            tests.add(abi.downcallHandle(ma, fd), arg, arg);\n+            tests.add(abi.downcallHandle(fd), arg, ma, arg);\n@@ -101,1 +100,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"empty\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"empty\").get();\n@@ -104,2 +103,1 @@\n-            tests.add(abi.downcallHandle(ma, mt, fd), null);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), null);\n+            tests.add(abi.downcallHandle(ma, fd), null);\n@@ -108,6 +106,7 @@\n-        addIdentity.add(\"identity_char\",   byte.class,   C_CHAR,   (byte) 10);\n-        addIdentity.add(\"identity_short\",  short.class,  C_SHORT, (short) 10);\n-        addIdentity.add(\"identity_int\",    int.class,    C_INT,           10);\n-        addIdentity.add(\"identity_long\",   long.class,   C_LONG_LONG,     10L);\n-        addIdentity.add(\"identity_float\",  float.class,  C_FLOAT,         10F);\n-        addIdentity.add(\"identity_double\", double.class, C_DOUBLE,        10D);\n+        addIdentity.add(\"identity_bool\",   boolean.class, C_BOOL,   true);\n+        addIdentity.add(\"identity_char\",   byte.class,    C_CHAR,   (byte) 10);\n+        addIdentity.add(\"identity_short\",  short.class,   C_SHORT, (short) 10);\n+        addIdentity.add(\"identity_int\",    int.class,     C_INT,           10);\n+        addIdentity.add(\"identity_long\",   long.class,    C_LONG_LONG,     10L);\n+        addIdentity.add(\"identity_float\",  float.class,   C_FLOAT,         10F);\n+        addIdentity.add(\"identity_double\", double.class,  C_DOUBLE,        10D);\n@@ -116,1 +115,1 @@\n-            MemoryAddress ma = LOOKUP.lookup(\"identity_va\").get();\n+            NativeSymbol ma = LOOKUP.lookup(\"identity_va\").get();\n@@ -118,4 +117,2 @@\n-            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT, asVarArg(C_DOUBLE),\n-                    asVarArg(C_INT), asVarArg(C_FLOAT), asVarArg(C_LONG_LONG));\n-            tests.add(abi.downcallHandle(ma, mt, fd), 1, 1, 10D, 2, 3F, 4L);\n-            tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), 1, 1, 10D, 2, 3F, 4L);\n+            FunctionDescriptor fd = FunctionDescriptor.of(C_INT, C_INT).asVariadic(C_DOUBLE, C_INT, C_FLOAT, C_LONG_LONG);\n+            tests.add(abi.downcallHandle(ma, fd), 1, 1, 10D, 2, 3F, 4L);\n@@ -128,1 +125,1 @@\n-                    C_SHORT, C_SHORT);\n+                    C_SHORT, JAVA_CHAR);\n@@ -131,1 +128,1 @@\n-                MemoryAddress ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n+                NativeSymbol ma = LOOKUP.lookup(\"invoke_high_arity\" + i).get();\n@@ -135,2 +132,1 @@\n-                tests.add(abi.downcallHandle(ma, mt, fd), expected, args);\n-                tests.add(abi.downcallHandle(ma, mt, fd.withAttribute(TRIVIAL_ATTRIBUTE_NAME, true)), expected, args);\n+                tests.add(abi.downcallHandle(ma, fd), expected, args);\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":22,"deletions":26,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -1,82 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestLayoutAttributes\n- *\/\n-\n-import jdk.incubator.foreign.MemoryLayout;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import org.testng.annotations.Test;\n-\n-import java.util.List;\n-import java.util.stream.Collectors;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertTrue;\n-\n-public class TestLayoutAttributes {\n-\n-    @Test\n-    public void testAttribute() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 10L);\n-    }\n-\n-    @Test\n-    public void testAttributeOverwrite() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 10L);\n-        ml = ml.withAttribute(\"MyAttribute\", 11L);\n-        assertEquals((long) ml.attribute(\"MyAttribute\").orElseThrow(), 11L);\n-    }\n-\n-    @Test\n-    public void testAttributeNonExistent() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withAttribute(\"MyAttribute\", 10L);\n-        assertTrue(ml.attribute(\"Foo\").isEmpty());\n-    }\n-\n-    @Test\n-    public void testNameAttribute() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withName(\"foo\");\n-        assertEquals(ml.name().orElseThrow(), \"foo\");\n-        assertEquals(ml.attribute(MemoryLayout.LAYOUT_NAME).orElseThrow(), \"foo\");\n-    }\n-\n-    @Test\n-    public void testAttributesStream() {\n-        MemoryLayout ml = MemoryLayouts.BITS_32_LE\n-                .withName(\"foo\")\n-                .withAttribute(\"MyAttribute\", 10L);\n-        List<String> attribs = ml.attributes().collect(Collectors.toList());\n-        assertEquals(attribs.size(), 2);\n-        assertTrue(attribs.contains(\"MyAttribute\"));\n-        assertTrue(attribs.contains(MemoryLayout.LAYOUT_NAME));\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestLayoutAttributes.java","additions":0,"deletions":82,"binary":false,"changes":82,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +33,1 @@\n+import java.nio.ByteOrder;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -69,5 +70,5 @@\n-                { MemoryLayouts.PAD_32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayouts.PAD_32) },\n-                { MemoryLayout.sequenceLayout(5, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.structLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n-                { MemoryLayout.unionLayout(MemoryLayouts.PAD_32, MemoryLayouts.PAD_32) },\n+                {MemoryLayout.paddingLayout(32)},\n+                { MemoryLayout.sequenceLayout(MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.sequenceLayout(5, MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.structLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n+                { MemoryLayout.unionLayout(MemoryLayout.paddingLayout(32), MemoryLayout.paddingLayout(32)) },\n@@ -75,1 +76,1 @@\n-                { MemoryLayouts.BITS_32_BE },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN) },\n@@ -77,2 +78,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        MemoryLayouts.BITS_32_BE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n@@ -80,2 +81,2 @@\n-                        MemoryLayouts.BITS_32_BE,\n-                        MemoryLayouts.BITS_32_BE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN)) },\n@@ -83,1 +84,1 @@\n-                { MemoryLayouts.BITS_32_LE },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN) },\n@@ -85,2 +86,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        MemoryLayouts.BITS_32_LE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n@@ -88,2 +89,2 @@\n-                        MemoryLayouts.BITS_32_LE,\n-                        MemoryLayouts.BITS_32_LE) },\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                        ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN)) },\n@@ -92,1 +93,1 @@\n-                        MemoryLayouts.PAD_16,\n+                        MemoryLayout.paddingLayout(16),\n@@ -94,2 +95,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -97,1 +98,1 @@\n-                        MemoryLayouts.PAD_16,\n+                        MemoryLayout.paddingLayout(16),\n@@ -99,2 +100,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -103,2 +104,2 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n@@ -107,5 +108,4 @@\n-                                MemoryLayouts.PAD_8,\n-                                MemoryLayouts.BITS_32_BE)) },\n-                { MemoryLayouts.BITS_32_LE.withName(\"myInt\") },\n-                { MemoryLayouts.BITS_32_LE.withBitAlignment(8) },\n-                { MemoryLayouts.BITS_32_LE.withAttribute(\"xyz\", \"abc\") },\n+                                MemoryLayout.paddingLayout(8),\n+                                ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN))) },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withName(\"myInt\") },\n+                { ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN).withBitAlignment(8) },\n","filename":"test\/jdk\/java\/foreign\/TestLayoutConstants.java","additions":29,"deletions":29,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -42,0 +42,9 @@\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -48,1 +57,3 @@\n-        ValueLayout newLayout = MemoryLayout.valueLayout(layout.bitSize(), layout.order());\n+        ValueLayout newLayout = valueLayoutForCarrier(layout.carrier());\n+        newLayout = newLayout.withBitAlignment(layout.bitAlignment());\n+        newLayout = newLayout.withOrder(layout.order());\n@@ -54,2 +65,0 @@\n-        assertEquals(newLayout.attributes().toArray().length, 0);\n-        assertEquals(layout.attributes().toArray().length, 1);\n@@ -57,2 +66,2 @@\n-        \/\/ but equals should return false, because one is a ValueLayout with a CLinker kind\n-        assertNotEquals(newLayout, layout);\n+        \/\/ layouts should be equals\n+        assertEquals(newLayout, layout);\n@@ -79,0 +88,23 @@\n+    static ValueLayout valueLayoutForCarrier(Class<?> carrier) {\n+        if (carrier == boolean.class) {\n+            return JAVA_BOOLEAN;\n+        } else if (carrier == char.class) {\n+            return JAVA_CHAR;\n+        } else if (carrier == byte.class) {\n+            return JAVA_BYTE;\n+        } else if (carrier == short.class) {\n+            return JAVA_SHORT;\n+        } else if (carrier == int.class) {\n+            return JAVA_INT;\n+        } else if (carrier == long.class) {\n+            return JAVA_LONG;\n+        } else if (carrier == float.class) {\n+            return JAVA_FLOAT;\n+        } else if (carrier == double.class) {\n+            return JAVA_DOUBLE;\n+        } else if (carrier == MemoryAddress.class) {\n+            return ADDRESS;\n+        } else {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n","filename":"test\/jdk\/java\/foreign\/TestLayoutEquality.java","additions":38,"deletions":6,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +42,0 @@\n-import java.nio.ByteOrder;\n@@ -48,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -156,1 +155,1 @@\n-        seq.varHandle(int.class, sequenceElement());\n+        seq.varHandle(sequenceElement());\n@@ -224,1 +223,1 @@\n-            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n+            g.varHandle(groupElement(\"foo\")); \/\/ok\n@@ -235,1 +234,1 @@\n-        GroupLayout g = MemoryLayout.structLayout(MemoryLayouts.PAD_8, JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n+        GroupLayout g = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), JAVA_INT.withBitAlignment(16).withName(\"foo\"));\n@@ -243,1 +242,1 @@\n-            g.varHandle(int.class, groupElement(\"foo\")); \/\/ok\n+            g.varHandle(groupElement(\"foo\")); \/\/ok\n@@ -302,4 +301,4 @@\n-                MemoryLayouts.JAVA_BYTE.withName(\"1\"),\n-                MemoryLayouts.JAVA_CHAR.withName(\"2\"),\n-                MemoryLayouts.JAVA_FLOAT.withName(\"3\"),\n-                MemoryLayouts.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"1\"),\n+                ValueLayout.JAVA_CHAR.withName(\"2\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n+                ValueLayout.JAVA_LONG.withName(\"4\")\n@@ -327,1 +326,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -331,1 +330,1 @@\n-                    assertEquals(g2.memberLayouts().get(j), MemoryLayouts.JAVA_DOUBLE);\n+                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n@@ -343,4 +342,4 @@\n-                MemoryLayouts.JAVA_BYTE.withName(\"1\"),\n-                MemoryLayouts.JAVA_CHAR.withName(\"2\"),\n-                MemoryLayouts.JAVA_FLOAT.withName(\"3\"),\n-                MemoryLayouts.JAVA_LONG.withName(\"4\")\n+                ValueLayout.JAVA_BYTE.withName(\"1\"),\n+                ValueLayout.JAVA_CHAR.withName(\"2\"),\n+                ValueLayout.JAVA_FLOAT.withName(\"3\"),\n+                ValueLayout.JAVA_LONG.withName(\"4\")\n@@ -368,1 +367,1 @@\n-            GroupLayout g2 = (GroupLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n+            GroupLayout g2 = (GroupLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, groupElement(String.valueOf(i)));\n@@ -372,1 +371,1 @@\n-                    assertEquals(g2.memberLayouts().get(j), MemoryLayouts.JAVA_DOUBLE);\n+                    assertEquals(g2.memberLayouts().get(j), ValueLayout.JAVA_DOUBLE);\n@@ -383,1 +382,1 @@\n-        SequenceLayout g = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_BYTE);\n+        SequenceLayout g = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_BYTE);\n@@ -388,1 +387,1 @@\n-        assertTrue(selected == MemoryLayouts.JAVA_BYTE);\n+        assertTrue(selected == ValueLayout.JAVA_BYTE);\n@@ -401,2 +400,2 @@\n-        SequenceLayout seq2 = (SequenceLayout)g.map(l -> MemoryLayouts.JAVA_DOUBLE, sequenceElement());\n-        assertTrue(seq2.elementLayout() == MemoryLayouts.JAVA_DOUBLE);\n+        SequenceLayout seq2 = (SequenceLayout)g.map(l -> ValueLayout.JAVA_DOUBLE, sequenceElement());\n+        assertTrue(seq2.elementLayout() == ValueLayout.JAVA_DOUBLE);\n@@ -509,1 +508,1 @@\n-            assertEquals(slice.address().segmentOffset(segment), expectedBitOffset \/ 8);\n+            assertEquals(slice.address().toRawLongValue() - segment.address().toRawLongValue(), expectedBitOffset \/ 8);\n@@ -514,10 +513,0 @@\n-    @Test(expectedExceptions = UnsupportedOperationException.class)\n-    public void testSliceHandleUOEInvalidSize() {\n-        MemoryLayout layout = MemoryLayout.structLayout(\n-            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"x\"),\n-            MemoryLayout.valueLayout(31, ByteOrder.nativeOrder()).withName(\"y\") \/\/ size not a multiple of 8\n-        );\n-\n-        layout.sliceHandle(groupElement(\"y\")); \/\/ should throw\n-    }\n-\n@@ -528,1 +517,1 @@\n-            MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+            JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n@@ -539,1 +528,1 @@\n-                MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()).withName(\"y\") \/\/ offset not a multiple of 8\n+                    JAVA_INT.withName(\"y\") \/\/ offset not a multiple of 8\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":25,"deletions":36,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -37,0 +37,5 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n@@ -41,5 +46,0 @@\n-    @Test(dataProvider = \"badLayoutSizes\", expectedExceptions = IllegalArgumentException.class)\n-    public void testBadLayoutSize(SizedLayoutFactory factory, long size) {\n-        factory.make(size);\n-    }\n-\n@@ -54,1 +54,1 @@\n-                MemoryLayouts.JAVA_INT.withName(\"size\"),\n+                ValueLayout.JAVA_INT.withName(\"size\"),\n@@ -56,1 +56,1 @@\n-                MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE).withName(\"arr\"));\n+                MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE).withName(\"arr\"));\n@@ -58,2 +58,2 @@\n-        VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(double.class,\n+        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n+        VarHandle array_elem_handle = layout.varHandle(\n@@ -80,1 +80,1 @@\n-                MemoryLayouts.JAVA_INT.withName(\"size\"),\n+                ValueLayout.JAVA_INT.withName(\"size\"),\n@@ -82,1 +82,1 @@\n-                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_DOUBLE)).withName(\"arr\"));\n+                MemoryLayout.sequenceLayout(1, MemoryLayout.sequenceLayout(ValueLayout.JAVA_DOUBLE)).withName(\"arr\"));\n@@ -84,2 +84,2 @@\n-        VarHandle size_handle = layout.varHandle(int.class, MemoryLayout.PathElement.groupElement(\"size\"));\n-        VarHandle array_elem_handle = layout.varHandle(double.class,\n+        VarHandle size_handle = layout.varHandle(MemoryLayout.PathElement.groupElement(\"size\"));\n+        VarHandle array_elem_handle = layout.varHandle(\n@@ -106,1 +106,1 @@\n-        MemoryLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        MemoryLayout seq = MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_INT);\n@@ -109,1 +109,1 @@\n-            VarHandle indexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+            VarHandle indexHandle = seq.varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -116,1 +116,1 @@\n-                VarHandle preindexHandle = seq.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(i));\n+                VarHandle preindexHandle = seq.varHandle(MemoryLayout.PathElement.sequenceElement(i));\n@@ -146,1 +146,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -152,1 +152,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(10, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(10, ValueLayout.JAVA_INT);\n@@ -171,4 +171,4 @@\n-                MemoryLayouts.JAVA_BYTE,\n-                MemoryLayouts.JAVA_CHAR,\n-                MemoryLayouts.JAVA_INT,\n-                MemoryLayouts.JAVA_LONG\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_LONG\n@@ -177,1 +177,1 @@\n-        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n+        assertEquals(struct.byteAlignment(), ValueLayout.ADDRESS.byteAlignment());\n@@ -202,4 +202,4 @@\n-                MemoryLayouts.JAVA_BYTE,\n-                MemoryLayouts.JAVA_CHAR,\n-                MemoryLayouts.JAVA_INT,\n-                MemoryLayouts.JAVA_LONG\n+                ValueLayout.JAVA_BYTE,\n+                ValueLayout.JAVA_CHAR,\n+                ValueLayout.JAVA_INT,\n+                ValueLayout.JAVA_LONG\n@@ -208,1 +208,1 @@\n-        assertEquals(struct.byteAlignment(), MemoryLayouts.ADDRESS.byteAlignment());\n+        assertEquals(struct.byteAlignment(), ValueLayout.ADDRESS.byteAlignment());\n@@ -227,13 +227,0 @@\n-    @DataProvider(name = \"badLayoutSizes\")\n-    public Object[][] factoriesAndSizes() {\n-        return new Object[][] {\n-                { SizedLayoutFactory.VALUE_BE, 0 },\n-                { SizedLayoutFactory.VALUE_BE, -1 },\n-                { SizedLayoutFactory.VALUE_LE, 0 },\n-                { SizedLayoutFactory.VALUE_LE, -1 },\n-                { SizedLayoutFactory.PADDING, 0 },\n-                { SizedLayoutFactory.PADDING, -1 },\n-                { SizedLayoutFactory.SEQUENCE, -1 }\n-        };\n-    }\n-\n@@ -242,0 +229,1 @@\n+        ValueLayout alignedInt = JAVA_INT.withBitAlignment(32);\n@@ -243,9 +231,9 @@\n-                { MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT), 32 },\n-                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n-                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT))), 32 },\n+                { MemoryLayout.sequenceLayout(alignedInt), 32 },\n+                { MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.structLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(alignedInt)), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(MemoryLayout.sequenceLayout(alignedInt))), 32 },\n+                { MemoryLayout.unionLayout(MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(alignedInt))), 32 },\n@@ -274,2 +262,2 @@\n-        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n-        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n+        VALUE_LE(size -> valueLayoutForSize((int)size).withOrder(ByteOrder.LITTLE_ENDIAN)),\n+        VALUE_BE(size -> valueLayoutForSize((int)size).withOrder(ByteOrder.BIG_ENDIAN)),\n@@ -277,1 +265,1 @@\n-        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayouts.PAD_8));\n+        SEQUENCE(size -> MemoryLayout.sequenceLayout(size, MemoryLayout.paddingLayout(8)));\n@@ -290,0 +278,10 @@\n+    static ValueLayout valueLayoutForSize(int size) {\n+        return switch (size) {\n+            case 1 -> JAVA_BYTE;\n+            case 2 -> JAVA_SHORT;\n+            case 4 -> JAVA_INT;\n+            case 8 -> JAVA_LONG;\n+            default -> throw new UnsupportedOperationException();\n+        };\n+    }\n+\n@@ -291,6 +289,5 @@\n-        VALUE_LE(MemoryLayouts.BITS_8_LE),\n-        VALUE_BE(MemoryLayouts.BITS_8_BE),\n-        PADDING(MemoryLayouts.PAD_8),\n-        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayouts.PAD_8)),\n-        STRUCT(MemoryLayout.structLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8)),\n-        UNION(MemoryLayout.unionLayout(MemoryLayouts.PAD_8, MemoryLayouts.PAD_8));\n+        VALUE(ValueLayout.JAVA_BYTE),\n+        PADDING(MemoryLayout.paddingLayout(8)),\n+        SEQUENCE(MemoryLayout.sequenceLayout(1, MemoryLayout.paddingLayout(8))),\n+        STRUCT(MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8))),\n+        UNION(MemoryLayout.unionLayout(MemoryLayout.paddingLayout(8), MemoryLayout.paddingLayout(8)));\n@@ -336,7 +333,7 @@\n-            MemoryLayouts.JAVA_BYTE,\n-            MemoryLayouts.JAVA_CHAR,\n-            MemoryLayouts.JAVA_SHORT,\n-            MemoryLayouts.JAVA_INT,\n-            MemoryLayouts.JAVA_FLOAT,\n-            MemoryLayouts.JAVA_LONG,\n-            MemoryLayouts.JAVA_DOUBLE,\n+            ValueLayout.JAVA_BYTE,\n+            ValueLayout.JAVA_CHAR,\n+            ValueLayout.JAVA_SHORT,\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_FLOAT,\n+            ValueLayout.JAVA_LONG,\n+            ValueLayout.JAVA_DOUBLE,\n","filename":"test\/jdk\/java\/foreign\/TestLayouts.java","additions":63,"deletions":66,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -42,0 +42,1 @@\n+import java.nio.ByteOrder;\n@@ -50,1 +51,1 @@\n-    public void testAccess(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testAccess(Function<MemorySegment, MemorySegment> viewFactory, ValueLayout elemLayout, Checker checker) {\n@@ -52,1 +53,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(), checker);\n@@ -56,1 +57,1 @@\n-    public void testPaddedAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testPaddedAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Checker checker) {\n@@ -58,1 +59,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.groupElement(\"elem\")), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(PathElement.groupElement(\"elem\")), checker);\n@@ -62,1 +63,1 @@\n-    public void testPaddedAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, Checker checker) {\n+    public void testPaddedAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Checker checker) {\n@@ -64,1 +65,1 @@\n-        testAccessInternal(viewFactory, layout, layout.varHandle(carrier, PathElement.sequenceElement(1)), checker);\n+        testAccessInternal(viewFactory, layout, layout.varHandle(PathElement.sequenceElement(1)), checker);\n@@ -68,1 +69,1 @@\n-    public void testArrayAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testArrayAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -70,1 +71,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement()), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(PathElement.sequenceElement()), checker);\n@@ -74,1 +75,1 @@\n-    public void testPaddedArrayAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testPaddedArrayAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -76,1 +77,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(\"elem\")), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(MemoryLayout.PathElement.sequenceElement(), MemoryLayout.PathElement.groupElement(\"elem\")), checker);\n@@ -80,1 +81,1 @@\n-    public void testPaddedArrayAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, ArrayChecker checker) {\n+    public void testPaddedArrayAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, ArrayChecker checker) {\n@@ -82,1 +83,1 @@\n-        testArrayAccessInternal(viewFactory, seq, seq.varHandle(carrier, PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);\n+        testArrayAccessInternal(viewFactory, seq, seq.varHandle(PathElement.sequenceElement(), MemoryLayout.PathElement.sequenceElement(1)), checker);\n@@ -152,1 +153,1 @@\n-    public void testMatrixAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testMatrixAccess(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -155,1 +156,1 @@\n-        testMatrixAccessInternal(viewFactory, seq, seq.varHandle(carrier,\n+        testMatrixAccessInternal(viewFactory, seq, seq.varHandle(\n@@ -160,1 +161,1 @@\n-    public void testPaddedMatrixAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testPaddedMatrixAccessByName(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -164,1 +165,1 @@\n-                seq.varHandle(carrier,\n+                seq.varHandle(\n@@ -170,1 +171,1 @@\n-    public void testPaddedMatrixAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, Class<?> carrier, MatrixChecker checker) {\n+    public void testPaddedMatrixAccessByIndexSeq(Function<MemorySegment, MemorySegment> viewFactory, MemoryLayout elemLayout, MatrixChecker checker) {\n@@ -174,1 +175,1 @@\n-                seq.varHandle(carrier,\n+                seq.varHandle(\n@@ -179,7 +180,0 @@\n-    @Test(dataProvider = \"badCarriers\",\n-          expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarriers(Class<?> carrier) {\n-        ValueLayout l = MemoryLayouts.BITS_32_LE.withName(\"elem\");\n-        l.varHandle(carrier);\n-    }\n-\n@@ -230,7 +224,7 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), Checker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), Checker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), Checker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), Checker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), Checker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), Checker.DOUBLE },\n@@ -238,7 +232,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, Checker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, Checker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, Checker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, Checker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, Checker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, Checker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, Checker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), Checker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), Checker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), Checker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), Checker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), Checker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), Checker.DOUBLE },\n@@ -246,7 +240,7 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.DOUBLE },\n@@ -254,7 +248,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, Checker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, Checker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, Checker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, Checker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, Checker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, Checker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, Checker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, Checker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), Checker.DOUBLE },\n@@ -307,7 +301,7 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.DOUBLE },\n@@ -315,7 +309,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, ArrayChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, ArrayChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, ArrayChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, ArrayChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, ArrayChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, ArrayChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, ArrayChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), ArrayChecker.DOUBLE },\n@@ -323,7 +317,7 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.LONG },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.DOUBLE },\n@@ -331,7 +325,7 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, ArrayChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, ArrayChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, ArrayChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, ArrayChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, ArrayChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, ArrayChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, ArrayChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, ArrayChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.LONG },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), ArrayChecker.DOUBLE },\n@@ -384,7 +378,9 @@\n-                { ID, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { ID, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.LONG },\n+                { ID, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.ADDR },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.DOUBLE },\n@@ -392,7 +388,9 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_BE, byte.class, MatrixChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, short.class, MatrixChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_BE, char.class, MatrixChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, int.class, MatrixChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, long.class, MatrixChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_BE, float.class, MatrixChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_BE, double.class, MatrixChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.LONG },\n+                { IMMUTABLE, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.ADDR },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), MatrixChecker.DOUBLE },\n@@ -400,7 +398,9 @@\n-                { ID, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },\n-                { ID, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },\n-                { ID, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },\n-                { ID, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },\n-                { ID, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },\n-                { ID, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },\n-                { ID, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },\n+                { ID, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { ID, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { ID, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.SHORT },\n+                { ID, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.CHAR },\n+                { ID, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.INT },\n+                { ID, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.LONG },\n+                { ID, ValueLayout.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.ADDR },\n+                { ID, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.FLOAT },\n+                { ID, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.DOUBLE },\n@@ -408,7 +408,9 @@\n-                { IMMUTABLE, MemoryLayouts.BITS_8_LE, byte.class, MatrixChecker.BYTE },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, short.class, MatrixChecker.SHORT },\n-                { IMMUTABLE, MemoryLayouts.BITS_16_LE, char.class, MatrixChecker.CHAR },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, int.class, MatrixChecker.INT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, long.class, MatrixChecker.LONG },\n-                { IMMUTABLE, MemoryLayouts.BITS_32_LE, float.class, MatrixChecker.FLOAT },\n-                { IMMUTABLE, MemoryLayouts.BITS_64_LE, double.class, MatrixChecker.DOUBLE },\n+                { IMMUTABLE, ValueLayout.JAVA_BYTE, MatrixChecker.BYTE },\n+                { IMMUTABLE, ValueLayout.JAVA_BOOLEAN, MatrixChecker.BOOLEAN },\n+                { IMMUTABLE, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.SHORT },\n+                { IMMUTABLE, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.CHAR },\n+                { IMMUTABLE, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.INT },\n+                { IMMUTABLE, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.LONG },\n+                { IMMUTABLE, ValueLayout.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.ADDR },\n+                { IMMUTABLE, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.FLOAT },\n+                { IMMUTABLE, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), MatrixChecker.DOUBLE },\n@@ -426,0 +428,5 @@\n+        MatrixChecker BOOLEAN = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, (r + c) != 0);\n+            assertEquals((r + c) != 0, (boolean)handle.get(segment, r, c));\n+        };\n+\n@@ -446,0 +453,5 @@\n+        MatrixChecker ADDR = (handle, segment, r, c) -> {\n+            handle.set(segment, r, c, MemoryAddress.ofLong(r + c));\n+            assertEquals(MemoryAddress.ofLong(r + c), (MemoryAddress)handle.get(segment, r, c));\n+        };\n+\n@@ -456,10 +468,0 @@\n-\n-    @DataProvider(name = \"badCarriers\")\n-    public Object[][] createBadCarriers() {\n-        return new Object[][] {\n-                { void.class },\n-                { boolean.class },\n-                { Object.class },\n-                { int[].class }\n-        };\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccess.java","additions":122,"deletions":120,"binary":false,"changes":242,"status":"modified"},{"patch":"@@ -0,0 +1,296 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm --enable-native-access=ALL-UNNAMED TestMemoryAccessInstance\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.function.Function;\n+\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.*;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryAccessInstance {\n+\n+    static class Accessor<T, X, L> {\n+\n+        interface SegmentGetter<T, X, L> {\n+            X get(T buffer, L layout, long offset);\n+        }\n+\n+        interface SegmentSetter<T, X, L> {\n+            void set(T buffer, L layout, long offset, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment, int offset);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, int offset, X o);\n+        }\n+\n+        final X value;\n+        final L layout;\n+        final Function<MemorySegment, T> transform;\n+        final SegmentGetter<T, X, L> segmentGetter;\n+        final SegmentSetter<T, X, L> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(Function<MemorySegment, T> transform, L layout, X value,\n+                 SegmentGetter<T, X, L> segmentGetter, SegmentSetter<T, X, L> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.transform = transform;\n+            this.layout = layout;\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                MemorySegment segment = MemorySegment.allocateNative(64, scope);\n+                ByteBuffer buffer = segment.asByteBuffer();\n+                T t = transform.apply(segment);\n+                segmentSetter.set(t, layout, 4, value);\n+                assertEquals(bufferGetter.get(buffer, 4), value);\n+                bufferSetter.set(buffer, 4, value);\n+                assertEquals(value, segmentGetter.get(t, layout, 4));\n+            }\n+        }\n+\n+        static <L, X> Accessor<MemorySegment, X, L> ofSegment(L layout, X value,\n+                         SegmentGetter<MemorySegment, X, L> segmentGetter, SegmentSetter<MemorySegment, X, L> segmentSetter,\n+                         BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(Function.identity(), layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+\n+        static <L, X> Accessor<MemoryAddress, X, L> ofAddress(L layout, X value,\n+                                                              SegmentGetter<MemoryAddress, X, L> segmentGetter, SegmentSetter<MemoryAddress, X, L> segmentSetter,\n+                                                              BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            return new Accessor<>(MemorySegment::address, layout, value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"segmentAccessors\")\n+    public void testSegmentAccess(String testName, Accessor<?, ?, ?> accessor) {\n+        accessor.test();\n+    }\n+\n+    @Test(dataProvider = \"addressAccessors\")\n+    public void testAddressAccess(String testName, Accessor<?, ?, ?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"segmentAccessors\")\n+    static Object[][] segmentAccessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", Accessor.ofSegment(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        ByteBuffer::get, ByteBuffer::put)\n+                },\n+                {\"bool\", Accessor.ofSegment(ValueLayout.JAVA_BOOLEAN, false,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n+                },\n+                {\"char\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n+                },\n+                {\"int\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n+                },\n+                {\"float\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n+                },\n+                {\"long\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n+                },\n+                {\"double\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n+                },\n+                { \"address\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemorySegment::get, MemorySegment::set,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos) : nb.getInt(pos);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+\n+                {\"char\/index\", Accessor.ofSegment(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n+                },\n+                {\"int\/index\", Accessor.ofSegment(ValueLayout.JAVA_INT, 42,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n+                },\n+                {\"float\/index\", Accessor.ofSegment(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n+                },\n+                {\"long\/index\", Accessor.ofSegment(ValueLayout.JAVA_LONG, 42L,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n+                },\n+                {\"double\/index\", Accessor.ofSegment(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n+                },\n+                { \"address\/index\", Accessor.ofSegment(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemorySegment::getAtIndex, MemorySegment::setAtIndex,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos * 8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+\n+    @DataProvider(name = \"addressAccessors\")\n+    static Object[][] addressAccessors() {\n+        return new Object[][]{\n+\n+                {\"byte\", Accessor.ofAddress(ValueLayout.JAVA_BYTE, (byte) 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        ByteBuffer::get, ByteBuffer::put)\n+                },\n+                {\"bool\", Accessor.ofAddress(ValueLayout.JAVA_BOOLEAN, false,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.get(pos) != 0, (bb, pos, v) -> bb.put(pos, v ? (byte)1 : (byte)0))\n+                },\n+                {\"char\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getChar(pos), (bb, pos, v) -> bb.order(NE).putChar(pos, v))\n+                },\n+                {\"int\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getInt(pos), (bb, pos, v) -> bb.order(NE).putInt(pos, v))\n+                },\n+                {\"float\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos), (bb, pos, v) -> bb.order(NE).putFloat(pos, v))\n+                },\n+                {\"long\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getLong(pos), (bb, pos, v) -> bb.order(NE).putLong(pos, v))\n+                },\n+                {\"double\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos), (bb, pos, v) -> bb.order(NE).putDouble(pos, v))\n+                },\n+                { \"address\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemoryAddress::get, MemoryAddress::set,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos) : nb.getInt(pos);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+                {\"char\/index\", Accessor.ofAddress(ValueLayout.JAVA_CHAR, (char) 42,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getChar(pos * 2), (bb, pos, v) -> bb.order(NE).putChar(pos * 2, v))\n+                },\n+                {\"int\/index\", Accessor.ofAddress(ValueLayout.JAVA_INT, 42,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getInt(pos * 4), (bb, pos, v) -> bb.order(NE).putInt(pos * 4, v))\n+                },\n+                {\"float\/index\", Accessor.ofAddress(ValueLayout.JAVA_FLOAT, 42f,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getFloat(pos * 4), (bb, pos, v) -> bb.order(NE).putFloat(pos * 4, v))\n+                },\n+                {\"long\/index\", Accessor.ofAddress(ValueLayout.JAVA_LONG, 42L,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getLong(pos * 8), (bb, pos, v) -> bb.order(NE).putLong(pos * 8, v))\n+                },\n+                {\"double\/index\", Accessor.ofAddress(ValueLayout.JAVA_DOUBLE, 42d,\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> bb.order(NE).getDouble(pos * 8), (bb, pos, v) -> bb.order(NE).putDouble(pos * 8, v))\n+                },\n+                { \"address\/index\", Accessor.ofAddress(ValueLayout.ADDRESS, MemoryAddress.ofLong(42),\n+                        MemoryAddress::getAtIndex, MemoryAddress::setAtIndex,\n+                        (bb, pos) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(pos * 8) : nb.getInt(pos * 4);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, pos, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(pos * 8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(pos * 4, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessInstance.java","additions":296,"deletions":0,"binary":false,"changes":296,"status":"added"},{"patch":"@@ -1,364 +0,0 @@\n-\/*\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryAccessStatics\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.nio.ByteBuffer;\n-import java.nio.ByteOrder;\n-\n-import org.testng.annotations.*;\n-import static org.testng.Assert.*;\n-\n-public class TestMemoryAccessStatics {\n-\n-    static class Accessor<X> {\n-\n-        interface SegmentGetter<X> {\n-            X get(MemorySegment segment);\n-        }\n-\n-        interface SegmentSetter<X> {\n-            void set(MemorySegment segment, X o);\n-        }\n-\n-        interface BufferGetter<X> {\n-            X get(ByteBuffer segment);\n-        }\n-\n-        interface BufferSetter<X> {\n-            void set(ByteBuffer buffer, X o);\n-        }\n-\n-        final X value;\n-        final SegmentGetter<X> segmentGetter;\n-        final SegmentSetter<X> segmentSetter;\n-        final BufferGetter<X> bufferGetter;\n-        final BufferSetter<X> bufferSetter;\n-\n-        Accessor(X value,\n-                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n-                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n-            this.value = value;\n-            this.segmentGetter = segmentGetter;\n-            this.segmentSetter = segmentSetter;\n-            this.bufferGetter = bufferGetter;\n-            this.bufferSetter = bufferSetter;\n-        }\n-\n-        void test() {\n-            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n-            ByteBuffer buffer = segment.asByteBuffer();\n-            segmentSetter.set(segment, value);\n-            assertEquals(bufferGetter.get(buffer), value);\n-            bufferSetter.set(buffer, value);\n-            assertEquals(value, segmentGetter.get(segment));\n-        }\n-\n-        <Z> Accessor<Z> of(Z value,\n-                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n-                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n-            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n-        }\n-    }\n-\n-    @Test(dataProvider = \"accessors\")\n-    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n-        accessor.test();\n-    }\n-\n-    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n-    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n-    static final ByteOrder NE = ByteOrder.nativeOrder();\n-\n-    @DataProvider(name = \"accessors\")\n-    static Object[][] accessors() {\n-        return new Object[][]{\n-\n-                {\"byte\", new Accessor<>((byte) 42,\n-                        MemoryAccess::getByte, MemoryAccess::setByte,\n-                        (bb) -> bb.get(0), (bb, v) -> bb.put(0, v))\n-                },\n-                {\"char\", new Accessor<>((char) 42,\n-                        MemoryAccess::getChar, MemoryAccess::setChar,\n-                        (bb) -> bb.order(NE).getChar(0), (bb, v) -> bb.order(NE).putChar(0, v))\n-                },\n-                {\"char\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, LE), (s, x) -> MemoryAccess.setChar(s, LE, x),\n-                        (bb) -> bb.order(LE).getChar(0), (bb, v) -> bb.order(LE).putChar(0, v))\n-                },\n-                {\"char\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getChar(s, BE), (s, x) -> MemoryAccess.setChar(s, BE, x),\n-                        (bb) -> bb.order(BE).getChar(0), (bb, v) -> bb.order(BE).putChar(0, v))\n-                },\n-                {\"short\", new Accessor<>((short) 42,\n-                        MemoryAccess::getShort, MemoryAccess::setShort,\n-                        (bb) -> bb.order(NE).getShort(0), (bb, v) -> bb.order(NE).putShort(0, v))\n-                },\n-                {\"short\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, LE), (s, x) -> MemoryAccess.setShort(s, LE, x),\n-                        (bb) -> bb.order(LE).getShort(0), (bb, v) -> bb.order(LE).putShort(0, v))\n-                },\n-                {\"short\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShort(s, BE), (s, x) -> MemoryAccess.setShort(s, BE, x),\n-                        (bb) -> bb.order(BE).getShort(0), (bb, v) -> bb.order(BE).putShort(0, v))\n-                },\n-                {\"int\", new Accessor<>(42,\n-                        MemoryAccess::getInt, MemoryAccess::setInt,\n-                        (bb) -> bb.order(NE).getInt(0), (bb, v) -> bb.order(NE).putInt(0, v))\n-                },\n-                {\"int\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, LE), (s, x) -> MemoryAccess.setInt(s, LE, x),\n-                        (bb) -> bb.order(LE).getInt(0), (bb, v) -> bb.order(LE).putInt(0, v))\n-                },\n-                {\"int\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getInt(s, BE), (s, x) -> MemoryAccess.setInt(s, BE, x),\n-                        (bb) -> bb.order(BE).getInt(0), (bb, v) -> bb.order(BE).putInt(0, v))\n-                },\n-                \/\/ float, no offset\n-                {\"float\", new Accessor<>(42f,\n-                        MemoryAccess::getFloat, MemoryAccess::setFloat,\n-                        (bb) -> bb.order(NE).getFloat(0), (bb, v) -> bb.order(NE).putFloat(0, v))\n-                },\n-                {\"float\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, LE), (s, x) -> MemoryAccess.setFloat(s, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(0), (bb, v) -> bb.order(LE).putFloat(0, v))\n-                },\n-                {\"float\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloat(s, BE), (s, x) -> MemoryAccess.setFloat(s, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(0), (bb, v) -> bb.order(BE).putFloat(0, v))\n-                },\n-                \/\/ double, no offset\n-                {\"double\", new Accessor<>(42d,\n-                        MemoryAccess::getDouble, MemoryAccess::setDouble,\n-                        (bb) -> bb.order(NE).getDouble(0), (bb, v) -> bb.order(NE).putDouble(0, v))\n-                },\n-                {\"double\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, LE), (s, x) -> MemoryAccess.setDouble(s, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(0), (bb, v) -> bb.order(LE).putDouble(0, v))\n-                },\n-                {\"double\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDouble(s, BE), (s, x) -> MemoryAccess.setDouble(s, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(0), (bb, v) -> bb.order(BE).putDouble(0, v))\n-                },\n-\n-\n-                \/\/ byte, offset\n-                {\"byte\/offset\", new Accessor<>((byte) 42,\n-                        s -> MemoryAccess.getByteAtOffset(s, 4), (s, x) -> MemoryAccess.setByteAtOffset(s, 4, x),\n-                        (bb) -> bb.get(4), (bb, v) -> bb.put(4, v))\n-                },\n-                \/\/ char, offset\n-                {\"char\/offset\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getChar(4), (bb, v) -> bb.order(NE).putChar(4, v))\n-                },\n-                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getChar(4), (bb, v) -> bb.order(LE).putChar(4, v))\n-                },\n-                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setCharAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getChar(4), (bb, v) -> bb.order(BE).putChar(4, v))\n-                },\n-                \/\/ short, offset\n-                {\"short\/offset\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getShort(4), (bb, v) -> bb.order(NE).putShort(4, v))\n-                },\n-                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getShort(4), (bb, v) -> bb.order(LE).putShort(4, v))\n-                },\n-                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setShortAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getShort(4), (bb, v) -> bb.order(BE).putShort(4, v))\n-                },\n-                \/\/ int, offset\n-                {\"int\/offset\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getInt(4), (bb, v) -> bb.order(NE).putInt(4, v))\n-                },\n-                {\"int\/offset\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getInt(4), (bb, v) -> bb.order(LE).putInt(4, v))\n-                },\n-                {\"int\/offset\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setIntAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getInt(4), (bb, v) -> bb.order(BE).putInt(4, v))\n-                },\n-                \/\/ float, offset\n-                {\"float\/offset\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getFloat(4), (bb, v) -> bb.order(NE).putFloat(4, v))\n-                },\n-                {\"float\/offset\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getFloat(4), (bb, v) -> bb.order(LE).putFloat(4, v))\n-                },\n-                {\"float\/offset\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setFloatAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getFloat(4), (bb, v) -> bb.order(BE).putFloat(4, v))\n-                },\n-                \/\/ double, offset\n-                {\"double\/offset\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, x),\n-                        (bb) -> bb.order(NE).getDouble(4), (bb, v) -> bb.order(NE).putDouble(4, v))\n-                },\n-                {\"double\/offset\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, LE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, LE, x),\n-                        (bb) -> bb.order(LE).getDouble(4), (bb, v) -> bb.order(LE).putDouble(4, v))\n-                },\n-                {\"double\/offset\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtOffset(s, 4, BE), (s, x) -> MemoryAccess.setDoubleAtOffset(s, 4, BE, x),\n-                        (bb) -> bb.order(BE).getDouble(4), (bb, v) -> bb.order(BE).putDouble(4, v))\n-                },\n-\n-\n-                \/\/ char, index\n-                {\"char\/index\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asCharBuffer().get(2), (bb, v) -> bb.order(NE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/LE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asCharBuffer().get(2), (bb, v) -> bb.order(LE).asCharBuffer().put(2, v))\n-                },\n-                {\"char\/index\/BE\", new Accessor<>((char) 42,\n-                        s -> MemoryAccess.getCharAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setCharAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asCharBuffer().get(2), (bb, v) -> bb.order(BE).asCharBuffer().put(2, v))\n-                },\n-                \/\/ short, index\n-                {\"short\/index\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asShortBuffer().get(2), (bb, v) -> bb.order(NE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/LE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asShortBuffer().get(2), (bb, v) -> bb.order(LE).asShortBuffer().put(2, v))\n-                },\n-                {\"short\/index\/BE\", new Accessor<>((short) 42,\n-                        s -> MemoryAccess.getShortAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setShortAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asShortBuffer().get(2), (bb, v) -> bb.order(BE).asShortBuffer().put(2, v))\n-                },\n-                {\"int\/index\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asIntBuffer().get(2), (bb, v) -> bb.order(NE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/LE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asIntBuffer().get(2), (bb, v) -> bb.order(LE).asIntBuffer().put(2, v))\n-                },\n-                {\"int\/index\/BE\", new Accessor<>(42,\n-                        s -> MemoryAccess.getIntAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setIntAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asIntBuffer().get(2), (bb, v) -> bb.order(BE).asIntBuffer().put(2, v))\n-                },\n-                {\"float\/index\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asFloatBuffer().get(2), (bb, v) -> bb.order(NE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/LE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asFloatBuffer().get(2), (bb, v) -> bb.order(LE).asFloatBuffer().put(2, v))\n-                },\n-                {\"float\/index\/BE\", new Accessor<>(42f,\n-                        s -> MemoryAccess.getFloatAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setFloatAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asFloatBuffer().get(2), (bb, v) -> bb.order(BE).asFloatBuffer().put(2, v))\n-                },\n-                {\"double\/index\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, x),\n-                        (bb) -> bb.order(NE).asDoubleBuffer().get(2), (bb, v) -> bb.order(NE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/LE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, LE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, LE, x),\n-                        (bb) -> bb.order(LE).asDoubleBuffer().get(2), (bb, v) -> bb.order(LE).asDoubleBuffer().put(2, v))\n-                },\n-                {\"double\/index\/BE\", new Accessor<>(42d,\n-                        s -> MemoryAccess.getDoubleAtIndex(s, 2, BE), (s, x) -> MemoryAccess.setDoubleAtIndex(s, 2, BE, x),\n-                        (bb) -> bb.order(BE).asDoubleBuffer().get(2), (bb, v) -> bb.order(BE).asDoubleBuffer().put(2, v))\n-                },\n-\n-                { \"address\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        MemoryAccess::getAddress, MemoryAccess::setAddress,\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(0) : nb.getInt(0);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(0, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(0, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtOffset(s, 4), (s, x) -> MemoryAccess.setAddressAtOffset(s, 4, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.getLong(4) : nb.getInt(4);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.putLong(4, v.toRawLongValue());\n-                            } else {\n-                                nb.putInt(4, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-                { \"address\/index\", new Accessor<>(MemoryAddress.ofLong(42),\n-                        s -> MemoryAccess.getAddressAtIndex(s, 2), (s, x) -> MemoryAccess.setAddressAtIndex(s, 2, x),\n-                        (bb) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            long addr = MemoryLayouts.ADDRESS.byteSize() == 8 ?\n-                                    nb.asLongBuffer().get(2) : nb.asIntBuffer().get(2);\n-                            return MemoryAddress.ofLong(addr);\n-                        },\n-                        (bb, v) -> {\n-                            ByteBuffer nb = bb.order(NE);\n-                            if (MemoryLayouts.ADDRESS.byteSize() == 8) {\n-                                nb.asLongBuffer().put(2, v.toRawLongValue());\n-                            } else {\n-                                nb.asIntBuffer().put(2, (int)v.toRawLongValue());\n-                            }\n-                        })\n-                },\n-        };\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAccessStatics.java","additions":0,"deletions":364,"binary":false,"changes":364,"status":"deleted"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -39,0 +38,1 @@\n+import java.nio.ByteOrder;\n@@ -48,1 +48,3 @@\n-        ValueLayout layout = MemoryLayouts.BITS_32_BE;\n+        ValueLayout layout = ValueLayout.JAVA_INT\n+                .withBitAlignment(32)\n+                .withOrder(ByteOrder.BIG_ENDIAN);\n@@ -52,1 +54,1 @@\n-        VarHandle vh = aligned.varHandle(int.class);\n+        VarHandle vh = aligned.varHandle();\n@@ -63,1 +65,3 @@\n-        ValueLayout layout = MemoryLayouts.BITS_32_BE;\n+        ValueLayout layout = ValueLayout.JAVA_INT\n+                .withBitAlignment(32)\n+                .withOrder(ByteOrder.BIG_ENDIAN);\n@@ -66,1 +70,1 @@\n-        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n+        MemoryLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -68,1 +72,1 @@\n-        VarHandle vh = aligned.varHandle(int.class);\n+        VarHandle vh = aligned.varHandle();\n@@ -80,1 +84,1 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_32_BE;\n+        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -82,1 +86,1 @@\n-        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayouts.PAD_8, aligned);\n+        GroupLayout alignedGroup = MemoryLayout.structLayout(MemoryLayout.paddingLayout(8), aligned);\n@@ -84,1 +88,1 @@\n-            alignedGroup.varHandle(int.class, PathElement.groupElement(\"value\"));\n+            alignedGroup.varHandle(PathElement.groupElement(\"value\"));\n@@ -93,1 +97,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(5, MemoryLayouts.BITS_32_BE.withBitAlignment(align));\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withBitAlignment(align));\n@@ -95,1 +99,1 @@\n-            VarHandle vh = layout.varHandle(int.class, PathElement.sequenceElement());\n+            VarHandle vh = layout.varHandle(PathElement.sequenceElement());\n@@ -109,3 +113,3 @@\n-        ValueLayout vChar = MemoryLayouts.BITS_8_BE;\n-        ValueLayout vShort = MemoryLayouts.BITS_16_BE;\n-        ValueLayout vInt = MemoryLayouts.BITS_32_BE;\n+        ValueLayout vChar = ValueLayout.JAVA_BYTE;\n+        ValueLayout vShort = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        ValueLayout vInt = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n@@ -117,3 +121,3 @@\n-        VarHandle vh_c = g.varHandle(byte.class, PathElement.groupElement(\"a\"));\n-        VarHandle vh_s = g.varHandle(short.class, PathElement.groupElement(\"b\"));\n-        VarHandle vh_i = g.varHandle(int.class, PathElement.groupElement(\"c\"));\n+        VarHandle vh_c = g.varHandle(PathElement.groupElement(\"a\"));\n+        VarHandle vh_s = g.varHandle(PathElement.groupElement(\"b\"));\n+        VarHandle vh_i = g.varHandle(PathElement.groupElement(\"c\"));\n","filename":"test\/jdk\/java\/foreign\/TestMemoryAlignment.java","additions":21,"deletions":17,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -1,121 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestMemoryCopy\n- *\/\n-\n-import jdk.incubator.foreign.MemoryLayouts;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.VarHandle;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestMemoryCopy {\n-\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testCopy(SegmentSlice s1, SegmentSlice s2) {\n-        int size = Math.min(s1.size(), s2.size());\n-        \/\/prepare source and target segments\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s2.segment.asSlice(i), (byte)0);\n-        }\n-        for (int i = 0 ; i < size ; i++) {\n-            BYTE_HANDLE.set(s1.segment.asSlice(i), (byte) i);\n-        }\n-        \/\/perform copy\n-        s2.segment.copyFrom(s1.segment.asSlice(0, size));\n-        \/\/check that copy actually worked\n-        for (int i = 0 ; i < size ; i++) {\n-            assertEquals((byte)i, BYTE_HANDLE.get(s2.segment.asSlice(i)));\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        int size() {\n-            return last - first + 1;\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            MemorySegment segment = kind.makeSegment(16);\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryCopy.java","additions":0,"deletions":121,"binary":false,"changes":121,"status":"deleted"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestMemoryDereference\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemorySegment;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.*;\n+\n+import static jdk.incubator.foreign.ValueLayout.ADDRESS;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BOOLEAN;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_CHAR;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_SHORT;\n+import static org.testng.Assert.*;\n+\n+public class TestMemoryDereference {\n+\n+    static class Accessor<X> {\n+\n+        interface SegmentGetter<X> {\n+            X get(MemorySegment segment);\n+        }\n+\n+        interface SegmentSetter<X> {\n+            void set(MemorySegment segment, X o);\n+        }\n+\n+        interface BufferGetter<X> {\n+            X get(ByteBuffer segment);\n+        }\n+\n+        interface BufferSetter<X> {\n+            void set(ByteBuffer buffer, X o);\n+        }\n+\n+        final X value;\n+        final SegmentGetter<X> segmentGetter;\n+        final SegmentSetter<X> segmentSetter;\n+        final BufferGetter<X> bufferGetter;\n+        final BufferSetter<X> bufferSetter;\n+\n+        Accessor(X value,\n+                 SegmentGetter<X> segmentGetter, SegmentSetter<X> segmentSetter,\n+                 BufferGetter<X> bufferGetter, BufferSetter<X> bufferSetter) {\n+            this.value = value;\n+            this.segmentGetter = segmentGetter;\n+            this.segmentSetter = segmentSetter;\n+            this.bufferGetter = bufferGetter;\n+            this.bufferSetter = bufferSetter;\n+        }\n+\n+        void test() {\n+            MemorySegment segment = MemorySegment.ofArray(new byte[32]);\n+            ByteBuffer buffer = segment.asByteBuffer();\n+            segmentSetter.set(segment, value);\n+            assertEquals(bufferGetter.get(buffer), value);\n+            bufferSetter.set(buffer, value);\n+            assertEquals(value, segmentGetter.get(segment));\n+        }\n+\n+        <Z> Accessor<Z> of(Z value,\n+                           SegmentGetter<Z> segmentGetter, SegmentSetter<Z> segmentSetter,\n+                           BufferGetter<Z> bufferGetter, BufferSetter<Z> bufferSetter) {\n+            return new Accessor<>(value, segmentGetter, segmentSetter, bufferGetter, bufferSetter);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"accessors\")\n+    public void testMemoryAccess(String testName, Accessor<?> accessor) {\n+        accessor.test();\n+    }\n+\n+    static final ByteOrder BE = ByteOrder.BIG_ENDIAN;\n+    static final ByteOrder LE = ByteOrder.LITTLE_ENDIAN;\n+    static final ByteOrder NE = ByteOrder.nativeOrder();\n+\n+    @DataProvider(name = \"accessors\")\n+    static Object[][] accessors() {\n+        return new Object[][]{\n+\n+                \/\/ byte, offset\n+                {\"byte\/offset\", new Accessor<>((byte) 42,\n+                        s -> s.get(JAVA_BYTE, 8), (s, x) -> s.set(JAVA_BYTE, 8, x),\n+                        (bb) -> bb.get(8), (bb, v) -> bb.put(8, v))\n+                },\n+                \/\/ bool, offset\n+                {\"bool\", new Accessor<>(false,\n+                        s -> s.get(JAVA_BOOLEAN, 8), (s, x) -> s.set(JAVA_BOOLEAN, 8, x),\n+                        (bb) -> bb.get(8) != 0, (bb, v) -> bb.put(8, v ? (byte)1 : (byte)0))\n+                },\n+                \/\/ char, offset\n+                {\"char\/offset\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR, 8), (s, x) -> s.set(JAVA_CHAR, 8, x),\n+                        (bb) -> bb.order(NE).getChar(8), (bb, v) -> bb.order(NE).putChar(8, v))\n+                },\n+                {\"char\/offset\/LE\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getChar(8), (bb, v) -> bb.order(LE).putChar(8, v))\n+                },\n+                {\"char\/offset\/BE\", new Accessor<>((char) 42,\n+                        s -> s.get(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getChar(8), (bb, v) -> bb.order(BE).putChar(8, v))\n+                },\n+                \/\/ short, offset\n+                {\"short\/offset\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT, 8), (s, x) -> s.set(JAVA_SHORT, 8, x),\n+                        (bb) -> bb.order(NE).getShort(8), (bb, v) -> bb.order(NE).putShort(8, v))\n+                },\n+                {\"short\/offset\/LE\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getShort(8), (bb, v) -> bb.order(LE).putShort(8, v))\n+                },\n+                {\"short\/offset\/BE\", new Accessor<>((short) 42,\n+                        s -> s.get(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getShort(8), (bb, v) -> bb.order(BE).putShort(8, v))\n+                },\n+                \/\/ int, offset\n+                {\"int\/offset\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT, 8), (s, x) -> s.set(JAVA_INT, 8, x),\n+                        (bb) -> bb.order(NE).getInt(8), (bb, v) -> bb.order(NE).putInt(8, v))\n+                },\n+                {\"int\/offset\/LE\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getInt(8), (bb, v) -> bb.order(LE).putInt(8, v))\n+                },\n+                {\"int\/offset\/BE\", new Accessor<>(42,\n+                        s -> s.get(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getInt(8), (bb, v) -> bb.order(BE).putInt(8, v))\n+                },\n+                \/\/ float, offset\n+                {\"float\/offset\", new Accessor<>(42f,\n+                        s -> s.get(JAVA_FLOAT, 8), (s, x) -> s.set(JAVA_FLOAT, 8, x),\n+                        (bb) -> bb.order(NE).getFloat(8), (bb, v) -> bb.order(NE).putFloat(8, v))\n+                },\n+                {\"float\/offset\/LE\", new Accessor<>(42f,\n+                        s -> s.get(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getFloat(8), (bb, v) -> bb.order(LE).putFloat(8, v))\n+                },\n+                {\"float\/offset\/BE\", new Accessor<>(42f,\n+                        s -> s.get(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getFloat(8), (bb, v) -> bb.order(BE).putFloat(8, v))\n+                },\n+                \/\/ double, offset\n+                {\"double\/offset\", new Accessor<>(42d,\n+                        s -> s.get(JAVA_DOUBLE, 8), (s, x) -> s.set(JAVA_DOUBLE, 8, x),\n+                        (bb) -> bb.order(NE).getDouble(8), (bb, v) -> bb.order(NE).putDouble(8, v))\n+                },\n+                {\"double\/offset\/LE\", new Accessor<>(42d,\n+                        s -> s.get(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), 8, x),\n+                        (bb) -> bb.order(LE).getDouble(8), (bb, v) -> bb.order(LE).putDouble(8, v))\n+                },\n+                {\"double\/offset\/BE\", new Accessor<>(42d,\n+                        s -> s.get(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), 8),\n+                        (s, x) -> s.set(ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), 8, x),\n+                        (bb) -> bb.order(BE).getDouble(8), (bb, v) -> bb.order(BE).putDouble(8, v))\n+                },\n+                { \"address\/offset\", new Accessor<>(MemoryAddress.ofLong(42),\n+                        s -> s.get(ADDRESS, 8), (s, x) -> s.set(ADDRESS, 8, x),\n+                        (bb) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            long addr = ValueLayout.ADDRESS.byteSize() == 8 ?\n+                                    nb.getLong(8) : nb.getInt(8);\n+                            return MemoryAddress.ofLong(addr);\n+                        },\n+                        (bb, v) -> {\n+                            ByteBuffer nb = bb.order(NE);\n+                            if (ValueLayout.ADDRESS.byteSize() == 8) {\n+                                nb.putLong(8, v.toRawLongValue());\n+                            } else {\n+                                nb.putInt(8, (int)v.toRawLongValue());\n+                            }\n+                        })\n+                },\n+        };\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestMemoryDereference.java","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import java.nio.ByteOrder;\n@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,2 +58,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_8_BE;\n-        VarHandle byteHandle = layout.varHandle(byte.class);\n+        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n+        VarHandle byteHandle = layout.varHandle();\n@@ -80,2 +81,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_8_BE;\n-        VarHandle byteHandle = layout.varHandle(byte.class);\n+        MemoryLayout layout = ValueLayout.JAVA_BYTE;\n+        VarHandle byteHandle = layout.varHandle();\n@@ -103,2 +104,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_16_BE;\n-        VarHandle shortHandle = layout.varHandle(short.class);\n+        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle shortHandle = layout.varHandle();\n@@ -126,2 +127,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_16_BE;\n-        VarHandle shortHandle = layout.varHandle(short.class);\n+        MemoryLayout layout = ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle shortHandle = layout.varHandle();\n@@ -153,2 +154,2 @@\n-        MemoryLayout layout = MemoryLayouts.BITS_32_BE;\n-        VarHandle intHandle = layout.varHandle(int.class);\n+        MemoryLayout layout = ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN);\n+        VarHandle intHandle = layout.varHandle();\n@@ -168,2 +169,2 @@\n-        MemoryLayout layout = MemoryLayout.sequenceLayout(2, MemoryLayouts.BITS_8_BE);\n-        VarHandle byteHandle = layout.varHandle(byte.class, PathElement.sequenceElement());\n+        MemoryLayout layout = MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_BYTE);\n+        VarHandle byteHandle = layout.varHandle(PathElement.sequenceElement());\n@@ -187,2 +188,2 @@\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(PathElement.sequenceElement());\n@@ -193,2 +194,2 @@\n-            VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                    .varHandle(byte.class, PathElement.sequenceElement());\n+            VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                    .varHandle(PathElement.sequenceElement());\n@@ -204,1 +205,1 @@\n-        VarHandle handle = MemoryHandles.varHandle(byte.class, BIG_ENDIAN);\n+        VarHandle handle = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withOrder(BIG_ENDIAN));\n@@ -212,2 +213,2 @@\n-    static void assertIllegalArgumentExceptionIllegalCarrier(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIllegalCarrier(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -219,2 +220,2 @@\n-    static void assertIllegalArgumentExceptionIllegalAdapter(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIllegalAdapter(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -226,2 +227,2 @@\n-    static void assertIllegalArgumentExceptionIsNotWiderThan(Class<?> carrier, Class<?> adaptedType) {\n-        var vh = MemoryHandles.varHandle(carrier, BIG_ENDIAN);\n+    static void assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout layout, Class<?> adaptedType) {\n+        var vh = MemoryHandles.varHandle(layout.withOrder(BIG_ENDIAN));\n@@ -235,20 +236,20 @@\n-        assertIllegalArgumentExceptionIllegalCarrier(char.class,   long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(double.class, long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(float.class,  long.class);\n-        assertIllegalArgumentExceptionIllegalCarrier(long.class,   long.class);\n-\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, void.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, byte.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, short.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, char.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, double.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, float.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Object.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Integer.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Long.class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, long[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, int[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Integer[].class);\n-        assertIllegalArgumentExceptionIllegalAdapter(byte.class, Long[].class);\n-\n-        assertIllegalArgumentExceptionIsNotWiderThan(int.class, int.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_CHAR,   long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_DOUBLE, long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_FLOAT,  long.class);\n+        assertIllegalArgumentExceptionIllegalCarrier(ValueLayout.JAVA_LONG,   long.class);\n+\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, void.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, byte.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, short.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, char.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, double.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, float.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Object.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long.class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, long[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, int[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Integer[].class);\n+        assertIllegalArgumentExceptionIllegalAdapter(ValueLayout.JAVA_BYTE, Long[].class);\n+\n+        assertIllegalArgumentExceptionIsNotWiderThan(ValueLayout.JAVA_INT, int.class);\n","filename":"test\/jdk\/java\/foreign\/TestMemoryHandleAsUnsigned.java","additions":45,"deletions":44,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -46,1 +46,1 @@\n-    final static VarHandle BYTE_HANDLE = MemoryLayouts.JAVA_BYTE.varHandle(byte.class);\n+    final static VarHandle BYTE_HANDLE = ValueLayout.JAVA_BYTE.varHandle();\n@@ -115,1 +115,1 @@\n-        if (MemoryLayouts.ADDRESS.byteSize() > 32) {\n+        if (ValueLayout.ADDRESS.byteSize() > 32) {\n","filename":"test\/jdk\/java\/foreign\/TestMismatch.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -37,0 +37,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n@@ -40,2 +42,0 @@\n-import java.lang.invoke.MethodType;\n-import java.nio.charset.Charset;\n@@ -45,1 +45,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -50,2 +50,1 @@\n-                MemoryAddress.NULL,\n-                MethodType.methodType(void.class),\n+                NativeSymbol.ofAddress(\"nullAddress\", MemoryAddress.NULL, ResourceScope.globalScope()),\n@@ -58,1 +57,0 @@\n-                MethodType.methodType(void.class),\n@@ -60,1 +58,1 @@\n-        mh.invokeExact((Addressable) MemoryAddress.NULL);\n+        mh.invokeExact(NativeSymbol.ofAddress(\"null\", MemoryAddress.NULL, ResourceScope.globalScope()));\n@@ -64,2 +62,2 @@\n-    public void testNULLtoJavaString() {\n-        CLinker.toJavaString(MemoryAddress.NULL);\n+    public void testNULLgetString() {\n+        MemoryAddress.NULL.getUtf8String(0);\n@@ -69,2 +67,2 @@\n-    public void testNULLfreeMemory() {\n-        CLinker.freeMemory(MemoryAddress.NULL);\n+    public void testNULLsetString() {\n+        MemoryAddress.NULL.setUtf8String(0, \"hello\");\n","filename":"test\/jdk\/java\/foreign\/TestNULLAddress.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -32,2 +32,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -37,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -41,0 +38,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -59,0 +57,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -61,1 +60,1 @@\n-public class TestNative {\n+public class TestNative extends NativeTestHelper {\n@@ -64,1 +63,1 @@\n-            MemoryLayouts.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_BYTE.withOrder(ByteOrder.nativeOrder())\n@@ -68,1 +67,1 @@\n-            MemoryLayouts.JAVA_CHAR.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_CHAR.withOrder(ByteOrder.nativeOrder())\n@@ -72,1 +71,1 @@\n-            MemoryLayouts.JAVA_SHORT.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_SHORT.withOrder(ByteOrder.nativeOrder())\n@@ -76,1 +75,1 @@\n-            MemoryLayouts.JAVA_INT.withOrder(ByteOrder.nativeOrder())\n+            JAVA_INT.withOrder(ByteOrder.nativeOrder())\n@@ -80,1 +79,1 @@\n-            MemoryLayouts.JAVA_FLOAT.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.nativeOrder())\n@@ -84,1 +83,1 @@\n-            MemoryLayouts.JAVA_LONG.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_LONG.withOrder(ByteOrder.nativeOrder())\n@@ -88,1 +87,1 @@\n-            MemoryLayouts.JAVA_DOUBLE.withOrder(ByteOrder.nativeOrder())\n+            ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.nativeOrder())\n@@ -91,7 +90,7 @@\n-    static VarHandle byteHandle = bytes.varHandle(byte.class, PathElement.sequenceElement());\n-    static VarHandle charHandle = chars.varHandle(char.class, PathElement.sequenceElement());\n-    static VarHandle shortHandle = shorts.varHandle(short.class, PathElement.sequenceElement());\n-    static VarHandle intHandle = ints.varHandle(int.class, PathElement.sequenceElement());\n-    static VarHandle floatHandle = floats.varHandle(float.class, PathElement.sequenceElement());\n-    static VarHandle longHandle = doubles.varHandle(long.class, PathElement.sequenceElement());\n-    static VarHandle doubleHandle = longs.varHandle(double.class, PathElement.sequenceElement());\n+    static VarHandle byteHandle = bytes.varHandle(PathElement.sequenceElement());\n+    static VarHandle charHandle = chars.varHandle(PathElement.sequenceElement());\n+    static VarHandle shortHandle = shorts.varHandle(PathElement.sequenceElement());\n+    static VarHandle intHandle = ints.varHandle(PathElement.sequenceElement());\n+    static VarHandle floatHandle = floats.varHandle(PathElement.sequenceElement());\n+    static VarHandle longHandle = longs.varHandle(PathElement.sequenceElement());\n+    static VarHandle doubleHandle = doubles.varHandle(PathElement.sequenceElement());\n@@ -147,8 +146,0 @@\n-    public static MemoryAddress allocate(int size) {\n-        return CLinker.allocateMemory(size);\n-    }\n-\n-    public static void free(MemoryAddress addr) {\n-        CLinker.freeMemory(addr);\n-    }\n-\n@@ -179,1 +170,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -181,1 +172,2 @@\n-            MemorySegment mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            scope.addCloseAction(() -> freeMemory(addr));\n+            MemorySegment mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n@@ -186,6 +178,0 @@\n-    @Test\n-    public void testDefaultAccessModesEverthing() {\n-        MemorySegment everything = MemorySegment.globalNativeSegment();\n-        assertFalse(everything.isReadOnly());\n-    }\n-\n@@ -194,1 +180,1 @@\n-        MemoryAddress addr = allocate(12);\n+        MemoryAddress addr = allocateMemory(12);\n@@ -197,1 +183,2 @@\n-            mallocSegment = addr.asSegment(12, () -> free(addr), scope);\n+            scope.addCloseAction(() -> freeMemory(addr));\n+            mallocSegment = MemorySegment.ofAddressNative(addr, 12, scope);\n@@ -205,6 +192,5 @@\n-    public void testEverythingSegment() {\n-        MemoryAddress addr = allocate(4);\n-        MemorySegment everything = MemorySegment.globalNativeSegment();\n-        MemoryAccess.setIntAtOffset(everything, addr.toRawLongValue(), 42);\n-        assertEquals(MemoryAccess.getIntAtOffset(everything, addr.toRawLongValue()), 42);\n-        free(addr);\n+    public void testAddressAccess() {\n+        MemoryAddress addr = allocateMemory(4);\n+        addr.set(JAVA_INT, 0, 42);\n+        assertEquals(addr.get(JAVA_INT, 0), 42);\n+        freeMemory(addr);\n@@ -217,1 +203,1 @@\n-            segment.address().asSegment(0, ResourceScope.globalScope());\n+            MemorySegment.ofAddressNative(segment.address(), 0, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestNative.java","additions":29,"deletions":43,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/TestNoForeignUnsafeOverride.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,0 +63,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -85,0 +87,9 @@\n+            ValueLayout.OfBoolean.class,\n+            ValueLayout.OfByte.class,\n+            ValueLayout.OfChar.class,\n+            ValueLayout.OfShort.class,\n+            ValueLayout.OfInt.class,\n+            ValueLayout.OfFloat.class,\n+            ValueLayout.OfLong.class,\n+            ValueLayout.OfDouble.class,\n+            ValueLayout.OfAddress.class,\n@@ -88,2 +99,0 @@\n-            MemoryAccess.class,\n-            MemoryLayouts.class,\n@@ -92,2 +101,2 @@\n-            CLinker.VaList.class,\n-            CLinker.VaList.Builder.class,\n+            VaList.class,\n+            VaList.Builder.class,\n@@ -96,1 +105,2 @@\n-            ResourceScope.class\n+            ResourceScope.class,\n+            NativeSymbol.class\n@@ -100,0 +110,2 @@\n+            \"jdk.incubator.foreign.ResourceScope\/newConfinedScope(java.lang.ref.Cleaner)\/0\/0\",\n+            \"jdk.incubator.foreign.ResourceScope\/newSharedScope(java.lang.ref.Cleaner)\/0\/0\",\n@@ -101,3 +113,0 @@\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/1\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,java.lang.Object)\/2\/0\",\n-            \"jdk.incubator.foreign.MemoryAddress\/asSegment(long,java.lang.Runnable,jdk.incubator.foreign.ResourceScope)\/1\/0\",\n@@ -106,0 +115,9 @@\n+            \"jdk.incubator.foreign.ValueLayout$OfAddress\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfBoolean\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfByte\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfChar\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfShort\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfInt\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfFloat\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfLong\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n+            \"jdk.incubator.foreign.ValueLayout$OfDouble\/withAttribute(java.lang.String,java.lang.constant.Constable)\/1\/0\",\n@@ -142,1 +160,1 @@\n-        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder()));\n+        addDefaultMapping(VarHandle.class, MemoryHandles.varHandle(JAVA_INT));\n@@ -150,4 +168,13 @@\n-        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n-        addDefaultMapping(ValueLayout.class, MemoryLayouts.JAVA_INT);\n-        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(MemoryLayouts.JAVA_INT));\n-        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n+        addDefaultMapping(MemoryLayout.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(ValueLayout.OfByte.class, ValueLayout.JAVA_BYTE);\n+        addDefaultMapping(ValueLayout.OfBoolean.class, ValueLayout.JAVA_BOOLEAN);\n+        addDefaultMapping(ValueLayout.OfChar.class, ValueLayout.JAVA_CHAR);\n+        addDefaultMapping(ValueLayout.OfShort.class, ValueLayout.JAVA_SHORT);\n+        addDefaultMapping(ValueLayout.OfInt.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfFloat.class, ValueLayout.JAVA_FLOAT);\n+        addDefaultMapping(ValueLayout.OfLong.class, JAVA_LONG);\n+        addDefaultMapping(ValueLayout.OfDouble.class, ValueLayout.JAVA_DOUBLE);\n+        addDefaultMapping(GroupLayout.class, MemoryLayout.structLayout(ValueLayout.JAVA_INT));\n+        addDefaultMapping(SequenceLayout.class, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n@@ -156,5 +183,5 @@\n-        addDefaultMapping(CLinker.class, CLinker.getInstance());\n-        addDefaultMapping(CLinker.VaList.class, VaListHelper.vaList);\n-        addDefaultMapping(CLinker.VaList.Builder.class, VaListHelper.vaListBuilder);\n-        addDefaultMapping(ResourceScope.class, ResourceScope.newImplicitScope());\n-        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n+        addDefaultMapping(VaList.class, VaListHelper.vaList);\n+        addDefaultMapping(VaList.Builder.class, VaListHelper.vaListBuilder);\n+        addDefaultMapping(ResourceScope.class, ResourceScope.newSharedScope());\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[10])));\n@@ -162,1 +189,0 @@\n-        addDefaultMapping(ResourceScope.Handle.class, ResourceScope.globalScope().acquire());\n@@ -164,1 +190,2 @@\n-        addDefaultMapping(SymbolLookup.class, CLinker.systemLookup());\n+        addDefaultMapping(SymbolLookup.class, CLinker.systemCLinker());\n+        addDefaultMapping(NativeSymbol.class, NativeSymbol.ofAddress(\"dummy\", MemoryAddress.ofLong(1), ResourceScope.globalScope()));\n@@ -168,2 +195,2 @@\n-        static final CLinker.VaList vaList;\n-        static final CLinker.VaList.Builder vaListBuilder;\n+        static final VaList vaList;\n+        static final VaList.Builder vaListBuilder;\n@@ -172,2 +199,2 @@\n-            AtomicReference<CLinker.VaList.Builder> builderRef = new AtomicReference<>();\n-            vaList = CLinker.VaList.make(b -> {\n+            AtomicReference<VaList.Builder> builderRef = new AtomicReference<>();\n+            vaList = VaList.make(b -> {\n@@ -175,1 +202,1 @@\n-                b.vargFromLong(CLinker.C_LONG_LONG, 42L);\n+                b.addVarg(JAVA_LONG, 42L);\n","filename":"test\/jdk\/java\/foreign\/TestNulls.java","additions":52,"deletions":25,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @run testng TestRebase\n- *\/\n-\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n-import jdk.incubator.foreign.MemorySegment;\n-import jdk.incubator.foreign.ResourceScope;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.*;\n-\n-public class TestRebase {\n-\n-    @Test(dataProvider = \"slices\")\n-    public void testRebase(SegmentSlice s1, SegmentSlice s2) {\n-        if (s1.contains(s2)) {\n-            \/\/check that an address and its rebased counterpart point to same element\n-            MemoryAddress base = s2.segment.address();\n-            long offset = base.segmentOffset(s1.segment);\n-            for (int i = 0; i < s2.size(); i++) {\n-                int expected = MemoryAccess.getByteAtOffset(s2.segment, i);\n-                int found = (int)MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n-                assertEquals(found, expected);\n-            }\n-        } else if (s1.kind != s2.kind) {\n-            \/\/ check that rebase s1 to s2 fails\n-            try {\n-                s1.segment.address().segmentOffset(s2.segment);\n-                fail(\"Rebase unexpectedly passed!\");\n-            } catch (IllegalArgumentException ex) {\n-                assertTrue(true);\n-            }\n-        } else if (!s2.contains(s1)) {\n-            \/\/disjoint segments - check that rebased address is out of bounds\n-            MemoryAddress base = s2.segment.address();\n-            long offset = base.segmentOffset(s1.segment);\n-            for (int i = 0; i < s2.size(); i++) {\n-                MemoryAccess.getByteAtOffset(s2.segment, i);\n-                try {\n-                    MemoryAccess.getByteAtOffset(s1.segment, i + offset);\n-                    fail(\"Rebased address on a disjoint segment is not out of bounds!\");\n-                } catch (IndexOutOfBoundsException ex) {\n-                    assertTrue(true);\n-                }\n-            }\n-        }\n-    }\n-\n-    static class SegmentSlice {\n-\n-        enum Kind {\n-            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n-            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n-\n-            final IntFunction<MemorySegment> segmentFactory;\n-\n-            Kind(IntFunction<MemorySegment> segmentFactory) {\n-                this.segmentFactory = segmentFactory;\n-            }\n-\n-            MemorySegment makeSegment(int elems) {\n-                return segmentFactory.apply(elems);\n-            }\n-        }\n-\n-        final Kind kind;\n-        final int first;\n-        final int last;\n-        final MemorySegment segment;\n-\n-        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n-            this.kind = kind;\n-            this.first = first;\n-            this.last = last;\n-            this.segment = segment;\n-        }\n-\n-        boolean contains(SegmentSlice other) {\n-            return kind == other.kind &&\n-                    first <= other.first &&\n-                    last >= other.last;\n-        }\n-\n-        int size() {\n-            return last - first + 1;\n-        }\n-    }\n-\n-    @DataProvider(name = \"slices\")\n-    static Object[][] slices() {\n-        int[] sizes = { 16, 8, 4, 2, 1 };\n-        List<SegmentSlice> slices = new ArrayList<>();\n-        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n-            \/\/init root segment\n-            MemorySegment segment = kind.makeSegment(16);\n-            for (int i = 0 ; i < 16 ; i++) {\n-                MemoryAccess.setByteAtOffset(segment, i, (byte)i);\n-            }\n-            \/\/compute all slices\n-            for (int size : sizes) {\n-                for (int index = 0 ; index < 16 ; index += size) {\n-                    MemorySegment slice = segment.asSlice(index, size);\n-                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n-                }\n-            }\n-        }\n-        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n-        for (int i = 0 ; i < slices.size() ; i++) {\n-            for (int j = 0 ; j < slices.size() ; j++) {\n-                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n-            }\n-        }\n-        return sliceArray;\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/TestRebase.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -38,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,1 +57,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -63,1 +63,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -69,1 +69,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -75,1 +75,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, ValueLayout.JAVA_INT);\n@@ -81,1 +81,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -87,1 +87,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT);\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT);\n@@ -93,1 +93,1 @@\n-        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT));\n+        SequenceLayout seq = MemoryLayout.sequenceLayout(4, MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT));\n@@ -128,2 +128,2 @@\n-            MemoryLayouts.JAVA_INT,\n-            MemoryLayouts.JAVA_INT\n+            ValueLayout.JAVA_INT,\n+            ValueLayout.JAVA_INT\n@@ -135,48 +135,48 @@\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_BYTE, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_SHORT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_CHAR, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_INT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_INT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_LONG, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_LONG, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_FLOAT, new long[] { 8, 16, 2 } },\n-\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 256 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 16, 16 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 4, 4, 4, 4 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 2, 8, 16 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 16, 8, 2 } },\n-                { MemoryLayouts.JAVA_DOUBLE, new long[] { 8, 16, 2 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 256 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_BYTE, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_SHORT, new long[] { 256 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_SHORT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_CHAR, new long[] { 256 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_CHAR, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_INT, new long[] { 256 } },\n+                { ValueLayout.JAVA_INT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_INT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_INT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_INT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_INT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_LONG, new long[] { 256 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_LONG, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_FLOAT, new long[] { 256 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_FLOAT, new long[] { 8, 16, 2 } },\n+\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 256 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 16, 16 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 4, 4, 4, 4 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 2, 8, 16 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 16, 8, 2 } },\n+                { ValueLayout.JAVA_DOUBLE, new long[] { 8, 16, 2 } },\n","filename":"test\/jdk\/java\/foreign\/TestReshape.java","additions":58,"deletions":58,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import java.util.Set;\n@@ -160,7 +161,4 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testLockSingleThread(Supplier<Cleaner> cleanerSupplier) {\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newConfinedScope(cleaner) :\n-                ResourceScope.newConfinedScope();\n-        List<ResourceScope.Handle> handles = new ArrayList<>();\n+    @Test\n+    public void testLockSingleThread() {\n+        ResourceScope scope = ResourceScope.newConfinedScope();\n+        List<ResourceScope> handles = new ArrayList<>();\n@@ -168,1 +166,3 @@\n-            handles.add(scope.acquire());\n+            ResourceScope handle = ResourceScope.newConfinedScope();\n+            handle.keepAlive(scope);\n+            handles.add(handle);\n@@ -178,4 +178,2 @@\n-                ResourceScope.Handle handle = handles.remove(0);\n-                scope.release(handle);\n-                scope.release(handle); \/\/ make sure it's idempotent\n-                scope.release(handle); \/\/ make sure it's idempotent\n+                ResourceScope handle = handles.remove(0);\n+                handle.close();\n@@ -186,6 +184,3 @@\n-    @Test(dataProvider = \"cleaners\")\n-    public void testLockSharedMultiThread(Supplier<Cleaner> cleanerSupplier) {\n-        Cleaner cleaner = cleanerSupplier.get();\n-        ResourceScope scope = cleaner != null ?\n-                ResourceScope.newSharedScope(cleaner) :\n-                ResourceScope.newSharedScope();\n+    @Test\n+    public void testLockSharedMultiThread() {\n+        ResourceScope scope = ResourceScope.newSharedScope();\n@@ -195,2 +190,2 @@\n-                try {\n-                    ResourceScope.Handle handle = scope.acquire(); \/\/ this can throw if segment has been closed\n+                try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n+                    handle.keepAlive(scope);\n@@ -200,3 +195,1 @@\n-                    scope.release(handle); \/\/ cannot throw (acquired segments cannot be closed)\n-                    scope.release(handle); \/\/ cannot throw (idempotent)\n-                    scope.release(handle); \/\/ cannot throw (idempotent)\n+                    handle.close();\n@@ -233,1 +226,2 @@\n-        ResourceScope.Handle handle = scope.acquire();\n+        ResourceScope handle = ResourceScope.newConfinedScope();\n+        handle.keepAlive(scope);\n@@ -237,3 +231,1 @@\n-                scope.release(handle);\n-                scope.release(handle); \/\/ make sure it's idempotent\n-                scope.release(handle); \/\/ make sure it's idempotent\n+                handle.close();\n@@ -258,1 +250,1 @@\n-        if (!scope.isImplicit()) {\n+        if (scope != ResourceScope.globalScope()) {\n@@ -263,0 +255,6 @@\n+    @Test(dataProvider = \"scopes\", expectedExceptions = IllegalArgumentException.class)\n+    public void testAcquireSelf(Supplier<ResourceScope> scopeSupplier) {\n+        ResourceScope scope = scopeSupplier.get();\n+        scope.keepAlive(scope);\n+    }\n+\n@@ -264,5 +262,9 @@\n-        ResourceScope.Handle handle = scope.acquire();\n-        assertEquals(handle.scope(), scope);\n-        if (acquireCount > 0) {\n-            \/\/ recursive acquire\n-            acquireRecursive(scope, acquireCount - 1);\n+        try (ResourceScope handle = ResourceScope.newConfinedScope()) {\n+            handle.keepAlive(scope);\n+            if (acquireCount > 0) {\n+                \/\/ recursive acquire\n+                acquireRecursive(scope, acquireCount - 1);\n+            }\n+            if (scope != ResourceScope.globalScope()) {\n+                assertThrows(IllegalStateException.class, scope::close);\n+            }\n@@ -270,2 +272,8 @@\n-        if (!scope.isImplicit()) {\n-            assertThrows(IllegalStateException.class, scope::close);\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithImplicitDependency() {\n+        ResourceScope root = ResourceScope.newConfinedScope();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            ResourceScope.newConfinedScope(Cleaner.create()).keepAlive(root);\n@@ -273,3 +281,48 @@\n-        scope.release(handle);\n-        scope.release(handle); \/\/ make sure it's idempotent\n-        scope.release(handle); \/\/ make sure it's idempotent\n+        \/\/ Now let's keep trying to close 'root' until we succeed. This is trickier than it seems: cleanup action\n+        \/\/ might be called from another thread (the Cleaner thread), so that the confined scope lock count is updated racily.\n+        \/\/ If that happens, the loop below never terminates.\n+        while (true) {\n+            try {\n+                root.close();\n+                break; \/\/ success!\n+            } catch (IllegalStateException ex) {\n+                kickGC();\n+                for (int i = 0 ; i < N_THREADS ; i++) {  \/\/ add more races from current thread\n+                    try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                        scope.keepAlive(root);\n+                        \/\/ dummy\n+                    }\n+                }\n+                \/\/ try again\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void testConfinedScopeWithSharedDependency() {\n+        ResourceScope root = ResourceScope.newConfinedScope();\n+        List<Thread> threads = new ArrayList<>();\n+        \/\/ Create many implicit scopes which depend on 'root', and let them become unreachable.\n+        for (int i = 0; i < N_THREADS; i++) {\n+            ResourceScope scope = ResourceScope.newSharedScope(); \/\/ create scope inside same thread!\n+            scope.keepAlive(root);\n+            Thread t = new Thread(scope::close); \/\/ close from another thread!\n+            threads.add(t);\n+            t.start();\n+        }\n+        for (int i = 0 ; i < N_THREADS ; i++) { \/\/ add more races from current thread\n+            try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+                scope.keepAlive(root);\n+                \/\/ dummy\n+            }\n+        }\n+        threads.forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException ex) {\n+                \/\/ ok\n+            }\n+        });\n+        \/\/ Now let's close 'root'. This is trickier than it seems: releases of the confined scope happen in different\n+        \/\/ threads, so that the confined scope lock count is updated racily. If that happens, the following close will blow up.\n+        root.close();\n","filename":"test\/jdk\/java\/foreign\/TestResourceScope.java","additions":91,"deletions":38,"binary":false,"changes":129,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import jdk.incubator.foreign.CLinker;\n@@ -41,1 +42,1 @@\n-        Method method = MemorySegment.class.getDeclaredMethod(\"globalNativeSegment\");\n+        Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -47,3 +48,3 @@\n-        var mh = MethodHandles.lookup().findStatic(MemorySegment.class,\n-                \"globalNativeSegment\", MethodType.methodType(MemorySegment.class));\n-        var seg = (MemorySegment)mh.invokeExact();\n+        var mh = MethodHandles.lookup().findStatic(CLinker.class,\n+                \"systemCLinker\", MethodType.methodType(CLinker.class));\n+        var seg = (CLinker)mh.invokeExact();\n@@ -54,1 +55,1 @@\n-        MemorySegment.globalNativeSegment();\n+        CLinker.systemCLinker();\n@@ -59,2 +60,2 @@\n-        Method method = MemoryAddress.class.getDeclaredMethod(\"asSegment\", long.class, ResourceScope.class);\n-        method.invoke(MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n+        Method method = MemorySegment.class.getDeclaredMethod(\"ofAddressNative\", MemoryAddress.class, long.class, ResourceScope.class);\n+        method.invoke(null, MemoryAddress.NULL, 4000L, ResourceScope.globalScope());\n@@ -65,2 +66,2 @@\n-        var mh = MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class));\n+        var mh = MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class));\n@@ -72,1 +73,1 @@\n-        MemoryAddress.NULL.asSegment(4000L, ResourceScope.globalScope());\n+        MemorySegment.ofAddressNative(MemoryAddress.NULL, 4000, ResourceScope.globalScope());\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -33,1 +32,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -37,0 +36,2 @@\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -50,0 +51,3 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -70,1 +74,1 @@\n-    public void testOpAfterClose(String name, ScopedOperation scopedOperation) {\n+    public <Z> void testOpAfterClose(String name, ScopedOperation<Z> scopedOperation) {\n@@ -72,0 +76,1 @@\n+        Z obj = scopedOperation.apply(scope);\n@@ -74,1 +79,1 @@\n-            scopedOperation.accept(scope);\n+            scopedOperation.accept(obj);\n@@ -82,1 +87,1 @@\n-    public void testOpOutsideConfinement(String name, ScopedOperation scopedOperation) {\n+    public <Z> void testOpOutsideConfinement(String name, ScopedOperation<Z> scopedOperation) {\n@@ -84,0 +89,1 @@\n+            Z obj = scopedOperation.apply(scope);\n@@ -87,1 +93,1 @@\n-                    scopedOperation.accept(scope);\n+                    scopedOperation.accept(obj);\n@@ -109,3 +115,4 @@\n-            ResourceScope.Handle handle = scope.acquire();\n-            scope.release(handle);\n-        }, \"ResourceScope::lock\");\n+            ResourceScope scope2 = ResourceScope.newConfinedScope();\n+            scope2.keepAlive(scope);\n+            scope2.close();\n+        }, \"ResourceScope::keepAlive\");\n@@ -120,4 +127,3 @@\n-        ScopedOperation.ofScope(scope -> CLinker.VaList.make(b -> {}, scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> CLinker.VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n-        ScopedOperation.ofScope(scope -> CLinker.toCString(\"Hello\", scope), \"CLinker::toCString\");\n-        ScopedOperation.ofScope(SegmentAllocator::arenaAllocator, \"SegmentAllocator::arenaAllocator\");\n+        ScopedOperation.ofScope(scope -> VaList.make(b -> b.addVarg(JAVA_INT, 42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(scope -> VaList.ofAddress(MemoryAddress.ofLong(42), scope), \"VaList::make\");\n+        ScopedOperation.ofScope(SegmentAllocator::newNativeArena, \"SegmentAllocator::arenaAllocator\");\n@@ -125,7 +131,1 @@\n-        ScopedOperation.ofSegment(MemorySegment::toByteArray, \"MemorySegment::toByteArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toCharArray, \"MemorySegment::toCharArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toShortArray, \"MemorySegment::toShortArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toIntArray, \"MemorySegment::toIntArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toFloatArray, \"MemorySegment::toFloatArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toLongArray, \"MemorySegment::toLongArray\");\n-        ScopedOperation.ofSegment(MemorySegment::toDoubleArray, \"MemorySegment::toDoubleArray\");\n+        ScopedOperation.ofSegment(s -> s.toArray(JAVA_BYTE), \"MemorySegment::toArray(BYTE)\");\n@@ -133,1 +133,0 @@\n-        ScopedOperation.ofSegment(s -> MemoryLayout.sequenceLayout(s.byteSize(), MemoryLayouts.JAVA_BYTE), \"MemorySegment::spliterator\");\n@@ -137,3 +136,0 @@\n-        \/\/ address operations\n-        ScopedOperation.ofAddress(a -> a.toRawLongValue(), \"MemoryAddress::toRawLongValue\");\n-        ScopedOperation.ofAddress(a -> a.asSegment(100, ResourceScope.globalScope()), \"MemoryAddress::asSegment\");\n@@ -141,8 +137,9 @@\n-        ScopedOperation.ofVaList(CLinker.VaList::address, \"VaList::address\");\n-        ScopedOperation.ofVaList(CLinker.VaList::copy, \"VaList::copy\");\n-        ScopedOperation.ofVaList(list -> list.vargAsAddress(MemoryLayouts.ADDRESS), \"VaList::vargAsAddress\");\n-        ScopedOperation.ofVaList(list -> list.vargAsInt(MemoryLayouts.JAVA_INT), \"VaList::vargAsInt\");\n-        ScopedOperation.ofVaList(list -> list.vargAsLong(MemoryLayouts.JAVA_LONG), \"VaList::vargAsLong\");\n-        ScopedOperation.ofVaList(list -> list.vargAsDouble(MemoryLayouts.JAVA_DOUBLE), \"VaList::vargAsDouble\");\n-        ScopedOperation.ofVaList(CLinker.VaList::skip, \"VaList::skip\");\n-        ScopedOperation.ofVaList(list -> list.vargAsSegment(MemoryLayout.structLayout(MemoryLayouts.JAVA_INT), ResourceScope.newImplicitScope()), \"VaList::vargAsSegment\/1\");\n+        ScopedOperation.ofVaList(VaList::address, \"VaList::address\");\n+        ScopedOperation.ofVaList(VaList::copy, \"VaList::copy\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.ADDRESS), \"VaList::nextVarg\/address\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_INT), \"VaList::nextVarg\/int\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_LONG), \"VaList::nextVarg\/long\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(ValueLayout.JAVA_DOUBLE), \"VaList::nextVarg\/double\");\n+        ScopedOperation.ofVaList(VaList::skip, \"VaList::skip\");\n+        ScopedOperation.ofVaList(list -> list.nextVarg(MemoryLayout.structLayout(ValueLayout.JAVA_INT),\n+                SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[4]))), \"VaList::nextVargs\/segment\");\n@@ -152,16 +149,18 @@\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocate(MemoryLayouts.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n-        ScopedOperation.ofAllocator(a -> a.allocateArray(MemoryLayouts.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE), \"NativeAllocator::allocate\/layout\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(JAVA_BYTE, (byte) 0), \"NativeAllocator::allocate\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_CHAR, (char) 0), \"NativeAllocator::allocate\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_SHORT, (short) 0), \"NativeAllocator::allocate\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_INT, 0), \"NativeAllocator::allocate\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_FLOAT, 0f), \"NativeAllocator::allocate\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_LONG, 0L), \"NativeAllocator::allocate\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocate(ValueLayout.JAVA_DOUBLE, 0d), \"NativeAllocator::allocate\/double\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, 1L), \"NativeAllocator::allocateArray\/size\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(JAVA_BYTE, new byte[]{0}), \"NativeAllocator::allocateArray\/byte\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_CHAR, new char[]{0}), \"NativeAllocator::allocateArray\/char\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_SHORT, new short[]{0}), \"NativeAllocator::allocateArray\/short\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_INT, new int[]{0}), \"NativeAllocator::allocateArray\/int\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_FLOAT, new float[]{0}), \"NativeAllocator::allocateArray\/float\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_LONG, new long[]{0}), \"NativeAllocator::allocateArray\/long\");\n+        ScopedOperation.ofAllocator(a -> a.allocateArray(ValueLayout.JAVA_DOUBLE, new double[]{0}), \"NativeAllocator::allocateArray\/double\");\n+        \/\/ native symbol\n+        ScopedOperation.of(scope -> NativeSymbol.ofAddress(\"\", MemoryAddress.NULL, scope), NativeSymbol::address, \"NativeSymbol::address\");\n@@ -175,1 +174,1 @@\n-    static class ScopedOperation implements Consumer<ResourceScope> {\n+    static class ScopedOperation<X> implements Consumer<X>, Function<ResourceScope, X> {\n@@ -177,1 +176,2 @@\n-        final Consumer<ResourceScope> scopeConsumer;\n+        final Function<ResourceScope, X> factory;\n+        final Consumer<X> operation;\n@@ -180,2 +180,3 @@\n-        private ScopedOperation(Consumer<ResourceScope> scopeConsumer, String name) {\n-            this.scopeConsumer = scopeConsumer;\n+        private ScopedOperation(Function<ResourceScope, X> factory, Consumer<X> operation, String name) {\n+            this.factory = factory;\n+            this.operation = operation;\n@@ -186,2 +187,2 @@\n-        public void accept(ResourceScope scope) {\n-            scopeConsumer.accept(scope);\n+        public void accept(X obj) {\n+            operation.accept(obj);\n@@ -190,2 +191,3 @@\n-        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n-            scopedOperations.add(new ScopedOperation(scopeConsumer::accept, name));\n+        @Override\n+        public X apply(ResourceScope scope) {\n+            return factory.apply(scope);\n@@ -194,5 +196,2 @@\n-        static void ofVaList(Consumer<CLinker.VaList> vaListConsumer, String name) {\n-            scopedOperations.add(new ScopedOperation(scope -> {\n-                CLinker.VaList vaList = CLinker.VaList.make((builder) -> {}, scope);\n-                vaListConsumer.accept(vaList);\n-            }, name));\n+        static <Z> void of(Function<ResourceScope, Z> factory, Consumer<Z> consumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(factory, consumer, name));\n@@ -201,7 +200,7 @@\n-        static void ofSegment(Consumer<MemorySegment> segmentConsumer, String name) {\n-            for (SegmentFactory segmentFactory : SegmentFactory.values()) {\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    MemorySegment segment = segmentFactory.segmentFactory.apply(scope);\n-                    segmentConsumer.accept(segment);\n-                }, segmentFactory.name() + \"\/\" + name));\n-            }\n+        static void ofScope(Consumer<ResourceScope> scopeConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(Function.identity(), scopeConsumer, name));\n+        }\n+\n+        static void ofVaList(Consumer<VaList> vaListConsumer, String name) {\n+            scopedOperations.add(new ScopedOperation<>(scope -> VaList.make(builder -> builder.addVarg(JAVA_LONG, 42), scope),\n+                    vaListConsumer, name));\n@@ -210,1 +209,1 @@\n-        static void ofAddress(Consumer<MemoryAddress> addressConsumer, String name) {\n+        static void ofSegment(Consumer<MemorySegment> segmentConsumer, String name) {\n@@ -212,4 +211,4 @@\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    MemoryAddress segment = segmentFactory.segmentFactory.apply(scope).address();\n-                    addressConsumer.accept(segment);\n-                }, segmentFactory.name() + \"\/\" + name));\n+                scopedOperations.add(new ScopedOperation<>(\n+                        segmentFactory.segmentFactory,\n+                        segmentConsumer,\n+                        segmentFactory.name() + \"\/\" + name));\n@@ -221,4 +220,4 @@\n-                scopedOperations.add(new ScopedOperation(scope -> {\n-                    SegmentAllocator allocator = allocatorFactory.allocatorFactory.apply(scope);\n-                    allocatorConsumer.accept(allocator);\n-                }, allocatorFactory.name() + \"\/\" + name));\n+                scopedOperations.add(new ScopedOperation<>(\n+                        allocatorFactory.allocatorFactory,\n+                        allocatorConsumer,\n+                        allocatorFactory.name() + \"\/\" + name));\n@@ -238,1 +237,1 @@\n-            UNSAFE(scope -> MemoryAddress.NULL.asSegment(10, scope));\n+            UNSAFE(scope -> MemorySegment.ofAddressNative(MemoryAddress.NULL, 10, scope));\n@@ -258,7 +257,2 @@\n-            ARENA_BOUNDED(scope -> SegmentAllocator.arenaAllocator(1000, scope)),\n-            ARENA_UNBOUNDED(SegmentAllocator::arenaAllocator),\n-            FROM_SEGMENT(scope -> {\n-                MemorySegment segment = MemorySegment.allocateNative(10, scope);\n-                return SegmentAllocator.ofSegment(segment);\n-            }),\n-            FROM_SCOPE(SegmentAllocator::ofScope);\n+            ARENA_BOUNDED(scope -> SegmentAllocator.newNativeArena(1000, scope)),\n+            ARENA_UNBOUNDED(SegmentAllocator::newNativeArena);\n","filename":"test\/jdk\/java\/foreign\/TestScopedOperations.java","additions":79,"deletions":85,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+import java.nio.CharBuffer;\n@@ -54,1 +55,1 @@\n-    final static Class<?> ADDRESS_CARRIER = MemoryLayouts.ADDRESS.bitSize() == 64 ? long.class : int.class;\n+    final static Class<?> ADDRESS_CARRIER = ValueLayout.ADDRESS.bitSize() == 64 ? long.class : int.class;\n@@ -57,2 +58,4 @@\n-    public <Z> void testAllocation(Z value, AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Z> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n-        ValueLayout[] layouts = {\n+    @SuppressWarnings(\"unchecked\")\n+    public <Z, L extends ValueLayout> void testAllocation(Z value, AllocationFactory allocationFactory, L layout, AllocationFunction<Z, L> allocationFunction, Function<MemoryLayout, VarHandle> handleFactory) {\n+        layout = (L)layout.withBitAlignment(layout.bitSize());\n+        L[] layouts = (L[])new ValueLayout[] {\n@@ -64,1 +67,1 @@\n-        for (ValueLayout alignedLayout : layouts) {\n+        for (L alignedLayout : layouts) {\n@@ -83,1 +86,1 @@\n-                        allocationFunction.allocate(allocator, alignedLayout, value); \/\/too much, should fail if bound\n+                        allocationFunction.allocate(allocator, alignedLayout, value);\n@@ -90,3 +93,5 @@\n-                \/\/ addresses should be invalid now\n-                for (MemorySegment address : addressList) {\n-                    assertFalse(address.scope().isAlive());\n+                if (allocationFactory != AllocationFactory.IMPLICIT_ALLOCATOR) {\n+                    \/\/ addresses should be invalid now\n+                    for (MemorySegment address : addressList) {\n+                        assertFalse(address.scope().isAlive());\n+                    }\n@@ -103,1 +108,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n@@ -114,1 +119,1 @@\n-    @Test(expectedExceptions = OutOfMemoryError.class)\n+    @Test\n@@ -117,2 +122,3 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(10, scope);\n-            allocator.allocate(12);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(10, scope);\n+            assertThrows(OutOfMemoryError.class, () -> allocator.allocate(12));\n+            allocator.allocate(5); \/\/ ok\n@@ -125,1 +131,1 @@\n-            SegmentAllocator allocator = SegmentAllocator.arenaAllocator(4 * 1024 * 2, scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(4 * 1024 * 2, scope);\n@@ -130,0 +136,5 @@\n+    @Test(expectedExceptions = IllegalArgumentException.class)\n+    public void testBadUnboundedArenaSize() {\n+        SegmentAllocator.newNativeArena( -1, ResourceScope.globalScope());\n+    }\n+\n@@ -131,1 +142,1 @@\n-    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n+    public <Z> void testArray(AllocationFactory allocationFactory, ValueLayout layout, AllocationFunction<Object, ValueLayout> allocationFunction, ToArrayHelper<Z> arrayHelper) {\n@@ -149,105 +160,52 @@\n-        return new Object[][] {\n-                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-\n-                { (byte)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<Byte>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(byte.class) },\n-                { (short)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Short>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(short.class) },\n-                { (char)42, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<Character>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(char.class) },\n-                { 42, AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Integer>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(int.class) },\n-                { 42f, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<Float>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(float.class) },\n-                { 42L, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Long>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(long.class) },\n-                { 42d, AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<Double>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> l.varHandle(double.class) },\n-                { MemoryAddress.ofLong(42), AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress>) SegmentAllocator::allocate,\n-                        (Function<MemoryLayout, VarHandle>)l -> MemoryHandles.asAddressVarHandle(l.varHandle(ADDRESS_CARRIER)) },\n-        };\n+        List<Object[]> nativeScopes = new ArrayList<>();\n+        for (AllocationFactory factory : AllocationFactory.values()) {\n+            nativeScopes.add(new Object[] { (byte)42, factory, ValueLayout.JAVA_BYTE,\n+                    (AllocationFunction.OfByte) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42, factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+\n+            nativeScopes.add(new Object[] { (short)42, factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfShort) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { (char)42, factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfChar) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42, factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfInt) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42f, factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfFloat) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42L, factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfLong) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { 42d, factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfDouble) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+            nativeScopes.add(new Object[] { MemoryAddress.ofLong(42), factory, ValueLayout.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfAddress) SegmentAllocator::allocate,\n+                    (Function<MemoryLayout, VarHandle>)l -> l.varHandle() });\n+        }\n+        return nativeScopes.toArray(Object[][]::new);\n@@ -258,94 +216,44 @@\n-        return new Object[][] {\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.BOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.BOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_LE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_LE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_LE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_LE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.LITTLE_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n-\n-\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_8_BE,\n-                        (AllocationFunction<byte[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toByteArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_16_BE,\n-                        (AllocationFunction<short[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toShortArray },\n-                { AllocationFactory.UNBOUNDED,\n-                        MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<int[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toIntArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_32_BE,\n-                        (AllocationFunction<float[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toFloatArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<long[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toLongArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.BITS_64_BE,\n-                        (AllocationFunction<double[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toDoubleArray },\n-                { AllocationFactory.UNBOUNDED, MemoryLayouts.ADDRESS.withOrder(ByteOrder.BIG_ENDIAN),\n-                        (AllocationFunction<MemoryAddress[]>) SegmentAllocator::allocateArray,\n-                        ToArrayHelper.toAddressArray },\n+        List<Object[]> arrayScopes = new ArrayList<>();\n+        for (AllocationFactory factory : AllocationFactory.values()) {\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_BYTE,\n+                    (AllocationFunction.OfByteArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toByteArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toCharArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toShortArray });\n+            arrayScopes.add(new Object[] { factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toIntArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toFloatArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toLongArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN),\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toDoubleArray });\n+\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfCharArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toCharArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfShortArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toShortArray });\n+            arrayScopes.add(new Object[] { factory,\n+                    ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfIntArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toIntArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfFloatArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toFloatArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfLongArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toLongArray });\n+            arrayScopes.add(new Object[] { factory, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN),\n+                    (AllocationFunction.OfDoubleArray) SegmentAllocator::allocateArray,\n+                    ToArrayHelper.toDoubleArray });\n@@ -353,0 +261,1 @@\n+        return arrayScopes.toArray(Object[][]::new);\n@@ -355,2 +264,20 @@\n-    interface AllocationFunction<X> {\n-        MemorySegment allocate(SegmentAllocator allocator, ValueLayout layout, X value);\n+    interface AllocationFunction<X, L extends ValueLayout> {\n+        MemorySegment allocate(SegmentAllocator allocator, L layout, X value);\n+\n+        interface OfByte extends AllocationFunction<Byte, ValueLayout.OfByte> { }\n+        interface OfBoolean extends AllocationFunction<Boolean, ValueLayout.OfBoolean> { }\n+        interface OfChar extends AllocationFunction<Character, ValueLayout.OfChar> { }\n+        interface OfShort extends AllocationFunction<Short, ValueLayout.OfShort> { }\n+        interface OfInt extends AllocationFunction<Integer, ValueLayout.OfInt> { }\n+        interface OfFloat extends AllocationFunction<Float, ValueLayout.OfFloat> { }\n+        interface OfLong extends AllocationFunction<Long, ValueLayout.OfLong> { }\n+        interface OfDouble extends AllocationFunction<Double, ValueLayout.OfDouble> { }\n+        interface OfAddress extends AllocationFunction<MemoryAddress, ValueLayout.OfAddress> { }\n+\n+        interface OfByteArray extends AllocationFunction<byte[], ValueLayout.OfByte> { }\n+        interface OfCharArray extends AllocationFunction<char[], ValueLayout.OfChar> { }\n+        interface OfShortArray extends AllocationFunction<short[], ValueLayout.OfShort> { }\n+        interface OfIntArray extends AllocationFunction<int[], ValueLayout.OfInt> { }\n+        interface OfFloatArray extends AllocationFunction<float[], ValueLayout.OfFloat> { }\n+        interface OfLongArray extends AllocationFunction<long[], ValueLayout.OfLong> { }\n+        interface OfDoubleArray extends AllocationFunction<double[], ValueLayout.OfDouble> { }\n@@ -359,1 +286,6 @@\n-    static class AllocationFactory {\n+    enum AllocationFactory {\n+        ARENA_BOUNDED(true, SegmentAllocator::newNativeArena),\n+        ARENA_UNBOUNDED(false, (size, scope) -> SegmentAllocator.newNativeArena(scope)),\n+        NATIVE_ALLOCATOR(false, (size, scope) -> SegmentAllocator.nativeAllocator(scope)),\n+        IMPLICIT_ALLOCATOR(false, (size, scope) -> SegmentAllocator.implicitAllocator());\n+\n@@ -363,1 +295,1 @@\n-        private AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n+        AllocationFactory(boolean isBound, BiFunction<Long, ResourceScope, SegmentAllocator> factory) {\n@@ -375,3 +307,0 @@\n-\n-        static AllocationFactory BOUNDED = new AllocationFactory(true, SegmentAllocator::arenaAllocator);\n-        static AllocationFactory UNBOUNDED = new AllocationFactory(false, (size, scope) -> SegmentAllocator.arenaAllocator(scope));\n@@ -399,0 +328,15 @@\n+        ToArrayHelper<char[]> toCharArray = new ToArrayHelper<>() {\n+            @Override\n+            public char[] array() {\n+                return new char[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };\n+            }\n+\n+            @Override\n+            public char[] toArray(MemorySegment segment, ValueLayout layout) {\n+                CharBuffer buffer = segment.asByteBuffer().order(layout.order()).asCharBuffer();\n+                char[] found = new char[buffer.limit()];\n+                buffer.get(found);\n+                return found;\n+            }\n+        };\n+\n@@ -477,1 +421,1 @@\n-                return switch ((int)MemoryLayouts.ADDRESS.byteSize()) {\n+                return switch ((int) ValueLayout.ADDRESS.byteSize()) {\n","filename":"test\/jdk\/java\/foreign\/TestSegmentAllocators.java","additions":165,"deletions":221,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentCopy\n+ *\/\n+\n+import jdk.incubator.foreign.MemoryHandles;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.ValueLayout;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.ByteOrder;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentCopy {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testByteCopy(SegmentSlice s1, SegmentSlice s2) {\n+        int size = Math.min(s1.byteSize(), s2.byteSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s2, i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.set(s1, i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, 0, s2.segment, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0 ; i < size ; i++) {\n+            Type.BYTE.check(s2, i, i);\n+        }\n+    }\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testElementCopy(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.type.carrier != s2.type.carrier) return;\n+        int size = Math.min(s1.elementSize(), s2.elementSize());\n+        \/\/prepare source and target segments\n+        for (int i = 0 ; i < size ; i++) {\n+            s2.set(i, 0);\n+        }\n+        for (int i = 0 ; i < size ; i++) {\n+            s1.set(i, i);\n+        }\n+        \/\/perform copy\n+        MemorySegment.copy(s1.segment, s1.type.layout, 0, s2.segment, s2.type.layout, 0, size);\n+        \/\/check that copy actually worked\n+        for (int i = 0; i < size; i++) {\n+            s2.check(i, i);\n+        }\n+    }\n+\n+    interface Getter<X> {\n+        X get(MemorySegment segment, ValueLayout layout, long index);\n+    }\n+\n+    interface Setter<X> {\n+        void set(MemorySegment segment, ValueLayout layout, long index, X val);\n+    }\n+\n+    enum Type {\n+        \/\/ Byte\n+        BYTE(byte.class, ValueLayout.JAVA_BYTE, i -> (byte)i),\n+        \/\/LE\n+        SHORT_LE(short.class, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (short)i),\n+        CHAR_LE(char.class, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (char)i),\n+        INT_LE(int.class, ValueLayout.JAVA_INT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> i),\n+        FLOAT_LE(float.class, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (float)i),\n+        LONG_LE(long.class, ValueLayout.JAVA_LONG.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (long)i),\n+        DOUBLE_LE(double.class, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.LITTLE_ENDIAN), i -> (double)i),\n+        \/\/BE\n+        SHORT_BE(short.class, ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN), i -> (short)i),\n+        CHAR_BE(char.class, ValueLayout.JAVA_CHAR.withOrder(ByteOrder.BIG_ENDIAN), i -> (char)i),\n+        INT_BE(int.class, ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN), i -> i),\n+        FLOAT_BE(float.class, ValueLayout.JAVA_FLOAT.withOrder(ByteOrder.BIG_ENDIAN), i -> (float)i),\n+        LONG_BE(long.class, ValueLayout.JAVA_LONG.withOrder(ByteOrder.BIG_ENDIAN), i -> (long)i),\n+        DOUBLE_BE(double.class, ValueLayout.JAVA_DOUBLE.withOrder(ByteOrder.BIG_ENDIAN), i -> (double)i);\n+\n+        final ValueLayout layout;\n+        final IntFunction<Object> valueConverter;\n+        final Class<?> carrier;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        <Z> Type(Class<Z> carrier, ValueLayout layout, IntFunction<Z> valueConverter) {\n+            this.carrier = carrier;\n+            this.layout = layout;\n+            this.valueConverter = (IntFunction<Object>)valueConverter;\n+        }\n+\n+        int size() {\n+            return (int)layout.byteSize();\n+        }\n+\n+        VarHandle handle() {\n+            return MemoryHandles.varHandle(layout);\n+        }\n+\n+        void set(SegmentSlice slice, int index, int val) {\n+            handle().set(slice.segment, index * size(), valueConverter.apply(val));\n+        }\n+\n+        void check(SegmentSlice slice, int index, int val) {\n+            assertEquals(handle().get(slice.segment, index * size()), valueConverter.apply(val));\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newImplicitScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final Type type;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, Type type, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.type = type;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        void set(int index, int val) {\n+            type.set(this, index, val);\n+        }\n+\n+        void check(int index, int val) {\n+            type.check(this, index, val);\n+        }\n+\n+        int byteSize() {\n+            return last - first + 1;\n+        }\n+\n+        int elementSize() {\n+            return byteSize() \/ type.size();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"SegmentSlice{%s, %d, %d}\", type, first, last);\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] elementSlices() {\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            MemorySegment segment = kind.makeSegment(16);\n+            \/\/compute all slices\n+            for (Type type : Type.values()) {\n+                for (int index = 0; index < 16; index += type.size()) {\n+                    MemorySegment first = segment.asSlice(0, index);\n+                    slices.add(new SegmentSlice(kind, type, 0, index - 1, first));\n+                    MemorySegment second = segment.asSlice(index);\n+                    slices.add(new SegmentSlice(kind, type, index, 15, second));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentCopy.java","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,144 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng TestSegmentOffset\n+ *\/\n+\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.function.IntFunction;\n+import static java.lang.System.out;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOffset {\n+\n+    @Test(dataProvider = \"slices\")\n+    public void testOffset(SegmentSlice s1, SegmentSlice s2) {\n+        if (s1.contains(s2)) {\n+            \/\/ check that a segment and its overlapping segment point to same elements\n+            long offset = s1.segment.segmentOffset(s2.segment);\n+            for (int i = 0; i < s2.size(); i++) {\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d, i:%s\\n\", s1, s2, offset, i);\n+                byte expected = s2.segment.get(JAVA_BYTE, i);\n+                byte found = s1.segment.get(JAVA_BYTE, i + offset);\n+                assertEquals(found, expected);\n+            }\n+        } else if (s1.kind != s2.kind) {\n+            \/\/ check that offset from s1 to s2 fails\n+            try {\n+                long offset = s1.segment.segmentOffset(s2.segment);\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d\\n\", s1, s2, offset);\n+                fail(\"offset unexpectedly passed!\");\n+            } catch (UnsupportedOperationException ex) {\n+                assertTrue(ex.getMessage().contains(\"Cannot compute offset from native to heap (or vice versa).\"));\n+            }\n+        } else if (!s2.contains(s1)) {\n+            \/\/ disjoint segments - check that offset is out of bounds\n+            long offset = s1.segment.segmentOffset(s2.segment);\n+            for (int i = 0; i < s2.size(); i++) {\n+                out.format(\"testOffset s1:%s, s2:%s, offset:%d, i:%s\\n\", s1, s2, offset, i);\n+                s2.segment.get(JAVA_BYTE, i);\n+                try {\n+                    s1.segment.get(JAVA_BYTE, i + offset);\n+                    fail(\"Offset on a disjoint segment is not out of bounds!\");\n+                } catch (IndexOutOfBoundsException ex) {\n+                    assertTrue(true);\n+                }\n+            }\n+        }\n+    }\n+\n+    static class SegmentSlice {\n+\n+        enum Kind {\n+            NATIVE(i -> MemorySegment.allocateNative(i, ResourceScope.newConfinedScope())),\n+            ARRAY(i -> MemorySegment.ofArray(new byte[i]));\n+\n+            final IntFunction<MemorySegment> segmentFactory;\n+\n+            Kind(IntFunction<MemorySegment> segmentFactory) {\n+                this.segmentFactory = segmentFactory;\n+            }\n+\n+            MemorySegment makeSegment(int elems) {\n+                return segmentFactory.apply(elems);\n+            }\n+        }\n+\n+        final Kind kind;\n+        final int first;\n+        final int last;\n+        final MemorySegment segment;\n+\n+        public SegmentSlice(Kind kind, int first, int last, MemorySegment segment) {\n+            this.kind = kind;\n+            this.first = first;\n+            this.last = last;\n+            this.segment = segment;\n+        }\n+\n+        boolean contains(SegmentSlice other) {\n+            return kind == other.kind &&\n+                    first <= other.first &&\n+                    last >= other.last;\n+        }\n+\n+        int size() {\n+            return last - first + 1;\n+        }\n+    }\n+\n+    @DataProvider(name = \"slices\")\n+    static Object[][] slices() {\n+        int[] sizes = { 16, 8, 4, 2, 1 };\n+        List<SegmentSlice> slices = new ArrayList<>();\n+        for (SegmentSlice.Kind kind : SegmentSlice.Kind.values()) {\n+            \/\/ init root segment\n+            MemorySegment segment = kind.makeSegment(16);\n+            for (int i = 0 ; i < 16 ; i++) {\n+                segment.set(JAVA_BYTE, i, (byte)i);\n+            }\n+            \/\/ compute all slices\n+            for (int size : sizes) {\n+                for (int index = 0 ; index < 16 ; index += size) {\n+                    MemorySegment slice = segment.asSlice(index, size);\n+                    slices.add(new SegmentSlice(kind, index, index + size - 1, slice));\n+                }\n+            }\n+        }\n+        Object[][] sliceArray = new Object[slices.size() * slices.size()][];\n+        for (int i = 0 ; i < slices.size() ; i++) {\n+            for (int j = 0 ; j < slices.size() ; j++) {\n+                sliceArray[i * slices.size() + j] = new Object[] { slices.get(i), slices.get(j) };\n+            }\n+        }\n+        return sliceArray;\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOffset.java","additions":144,"deletions":0,"binary":false,"changes":144,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ *  Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *  Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @run testng\/othervm TestSegmentOverlap\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+import java.util.function.Supplier;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.ResourceScope;\n+import org.testng.annotations.Test;\n+import org.testng.annotations.DataProvider;\n+import static java.lang.System.out;\n+import static org.testng.Assert.*;\n+\n+public class TestSegmentOverlap {\n+\n+    static Path tempPath;\n+\n+    static {\n+        try {\n+            File file = File.createTempFile(\"buffer\", \"txt\");\n+            file.deleteOnExit();\n+            tempPath = file.toPath();\n+            Files.write(file.toPath(), new byte[16], StandardOpenOption.WRITE);\n+\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    @DataProvider(name = \"segmentFactories\")\n+    public Object[][] segmentFactories() {\n+        List<Supplier<MemorySegment>> l = List.of(\n+                () -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope()),\n+                () -> {\n+                    try {\n+                        return MemorySegment.mapFile(tempPath, 0L, 16, FileChannel.MapMode.READ_WRITE, ResourceScope.newConfinedScope());\n+                    } catch (IOException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                },\n+                () -> MemorySegment.ofArray(new byte[] { 0x00, 0x01, 0x02, 0x03 } ),\n+                () -> MemorySegment.ofArray(new char[] {'a', 'b', 'c', 'd' } ),\n+                () -> MemorySegment.ofArray(new double[] { 1d, 2d, 3d, 4d} ),\n+                () -> MemorySegment.ofArray(new float[] { 1.0f, 2.0f, 3.0f, 4.0f } ),\n+                () -> MemorySegment.ofArray(new int[] { 1, 2, 3, 4 }),\n+                () -> MemorySegment.ofArray(new long[] { 1L, 2L, 3L, 4L } ),\n+                () -> MemorySegment.ofArray(new short[] { 1, 2, 3, 4 } )\n+        );\n+        return l.stream().map(s -> new Object[] { s }).toArray(Object[][]::new);\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testBasic(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = segmentSupplier.get();\n+        var sOther = s1.isNative() ? OtherSegmentFactory.HEAP.factory.get()\n+                : OtherSegmentFactory.NATIVE.factory.get();\n+        out.format(\"testBasic s1:%s, s2:%s, sOther:%s\\n\", s1, s2, sOther);\n+        assertNull(s1.asOverlappingSlice(s2));\n+        assertNull(s2.asOverlappingSlice(s1));\n+        assertNull(s1.asOverlappingSlice(sOther));\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testIdentical(Supplier<MemorySegment> segmentSupplier) {\n+        var s1 = segmentSupplier.get();\n+        var s2 = s1.asReadOnly();\n+        out.format(\"testIdentical s1:%s, s2:%s\\n\", s1, s2);\n+        assertEquals(s1.asOverlappingSlice(s2).byteSize(), s1.byteSize());\n+        assertEquals(s1.asOverlappingSlice(s2).scope(), s1.scope());\n+\n+        assertEquals(s2.asOverlappingSlice(s1).byteSize(), s2.byteSize());\n+        assertEquals(s2.asOverlappingSlice(s1).scope(), s2.scope());\n+\n+        if (s1.isNative()) {\n+            assertEquals(s1.asOverlappingSlice(s2).address(), s1.address());\n+            assertEquals(s2.asOverlappingSlice(s1).address(), s2.address());\n+        }\n+    }\n+\n+    @Test(dataProvider=\"segmentFactories\")\n+    public void testSlices(Supplier<MemorySegment> segmentSupplier) {\n+        MemorySegment s1 = segmentSupplier.get();\n+        MemorySegment s2 = segmentSupplier.get();\n+        for (int offset = 0 ; offset < 4 ; offset++) {\n+            MemorySegment slice = s1.asSlice(offset);\n+            out.format(\"testSlices s1:%s, s2:%s, slice:%s, offset:%d\\n\", s1, s2, slice, offset);\n+            assertEquals(s1.asOverlappingSlice(slice).byteSize(), s1.byteSize() - offset);\n+            assertEquals(s1.asOverlappingSlice(slice).scope(), s1.scope());\n+\n+            assertEquals(slice.asOverlappingSlice(s1).byteSize(), slice.byteSize());\n+            assertEquals(slice.asOverlappingSlice(s1).scope(), slice.scope());\n+\n+            if (s1.isNative()) {\n+                assertEquals(s1.asOverlappingSlice(slice).address(), s1.address().addOffset(offset));\n+                assertEquals(slice.asOverlappingSlice(s1).address(), slice.address());\n+            }\n+            assertNull(s2.asOverlappingSlice(slice));\n+        }\n+    }\n+\n+    enum OtherSegmentFactory {\n+        NATIVE(() -> MemorySegment.allocateNative(16, ResourceScope.newConfinedScope())),\n+        HEAP(() -> MemorySegment.ofArray(new byte[]{16}));\n+\n+        final Supplier<MemorySegment> factory;\n+\n+        OtherSegmentFactory(Supplier<MemorySegment> segmentFactory) {\n+            this.factory = segmentFactory;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/TestSegmentOverlap.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -35,0 +33,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -40,1 +39,0 @@\n-import java.nio.ByteOrder;\n@@ -44,1 +42,0 @@\n-import java.util.function.LongFunction;\n@@ -47,0 +44,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -56,5 +54,0 @@\n-    @Test(dataProvider = \"badLayouts\", expectedExceptions = UnsupportedOperationException.class)\n-    public void testBadAllocateLayout(MemoryLayout layout) {\n-        MemorySegment.allocateNative(layout, ResourceScope.newImplicitScope());\n-    }\n-\n@@ -74,2 +67,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -86,2 +79,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -110,1 +103,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        memorySegment.get(JAVA_INT, offset);\n@@ -117,1 +110,1 @@\n-        MemoryAccess.getIntAtOffset(memorySegment, offset);\n+        memorySegment.get(JAVA_INT, offset);\n@@ -128,1 +121,1 @@\n-        if (!segment.scope().isImplicit()) {\n+        if (segment.scope() != ResourceScope.globalScope()) {\n@@ -145,4 +138,4 @@\n-                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newImplicitScope()),\n-                () -> MemorySegment.allocateNative(4, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newConfinedScope()),\n-                () -> MemorySegment.allocateNative(MemoryLayout.valueLayout(32, ByteOrder.nativeOrder()), ResourceScope.newConfinedScope())\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(4, 8, ResourceScope.newImplicitScope()),\n+                () -> MemorySegment.allocateNative(JAVA_INT, ResourceScope.newImplicitScope())\n@@ -156,2 +149,2 @@\n-        VarHandle byteHandle = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_BYTE)\n-                .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());\n+        VarHandle byteHandle = MemoryLayout.sequenceLayout(ValueLayout.JAVA_BYTE)\n+                .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -196,1 +189,1 @@\n-    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) throws Exception {\n+    public void testNativeSegments(Supplier<MemorySegment> memorySegmentSupplier) {\n@@ -199,1 +192,1 @@\n-            segment.address().toRawLongValue();\n+            segment.address();\n@@ -201,1 +194,0 @@\n-            assertTrue(segment.address().isNative());\n@@ -204,1 +196,0 @@\n-            assertFalse(segment.address().isNative());\n@@ -265,27 +256,0 @@\n-    @DataProvider(name = \"badLayouts\")\n-    public Object[][] layouts() {\n-        SizedLayoutFactory[] layoutFactories = SizedLayoutFactory.values();\n-        Object[][] values = new Object[layoutFactories.length * 2][2];\n-        for (int i = 0; i < layoutFactories.length ; i++) {\n-            values[i * 2] = new Object[] { MemoryLayout.structLayout(layoutFactories[i].make(7), MemoryLayout.paddingLayout(9)) }; \/\/ good size, bad align\n-            values[(i * 2) + 1] = new Object[] { layoutFactories[i].make(15).withBitAlignment(16) }; \/\/ bad size, good align\n-        }\n-        return values;\n-    }\n-\n-    enum SizedLayoutFactory {\n-        VALUE_BE(size -> MemoryLayout.valueLayout(size, ByteOrder.BIG_ENDIAN)),\n-        VALUE_LE(size -> MemoryLayout.valueLayout(size, ByteOrder.LITTLE_ENDIAN)),\n-        PADDING(MemoryLayout::paddingLayout);\n-\n-        private final LongFunction<MemoryLayout> factory;\n-\n-        SizedLayoutFactory(LongFunction<MemoryLayout> factory) {\n-            this.factory = factory;\n-        }\n-\n-        MemoryLayout make(long size) {\n-            return factory.apply(size);\n-        }\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestSegments.java","additions":17,"deletions":53,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    static final VarHandle intHandle = MemoryLayouts.JAVA_INT.varHandle(int.class);\n+    static final VarHandle intHandle = ValueLayout.JAVA_INT.varHandle();\n@@ -50,1 +50,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -101,1 +101,1 @@\n-            MemorySegment sharedSegment = s.address().asSegment(s.byteSize(), scope);\n+            MemorySegment sharedSegment = MemorySegment.ofAddressNative(s.address(), s.byteSize(), scope);\n@@ -124,1 +124,1 @@\n-            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, MemoryLayouts.JAVA_INT), scope);\n+            MemorySegment s1 = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(2, ValueLayout.JAVA_INT), scope);\n","filename":"test\/jdk\/java\/foreign\/TestSharedAccess.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -32,0 +31,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -42,1 +42,1 @@\n-            MemoryLayout.sequenceLayout(5, MemoryLayouts.JAVA_INT));\n+            MemoryLayout.sequenceLayout(5, ValueLayout.JAVA_INT));\n@@ -44,1 +44,1 @@\n-    static VarHandle VH_ALL = LAYOUT.varHandle(int.class,\n+    static VarHandle VH_ALL = LAYOUT.varHandle(\n@@ -79,1 +79,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -82,1 +82,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -85,1 +85,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n@@ -88,1 +88,1 @@\n-                { LAYOUT.varHandle(int.class, MemoryLayout.PathElement.sequenceElement(),\n+                { LAYOUT.varHandle(MemoryLayout.PathElement.sequenceElement(),\n","filename":"test\/jdk\/java\/foreign\/TestSlices.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -43,1 +42,0 @@\n-import java.util.stream.StreamSupport;\n@@ -45,0 +43,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -51,2 +50,2 @@\n-    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle INT_HANDLE = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -58,1 +57,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(size, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(size, ValueLayout.JAVA_INT);\n@@ -85,1 +84,1 @@\n-        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT);\n+        SequenceLayout layout = MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT);\n@@ -103,1 +102,1 @@\n-        MemorySegment.ofArray(new byte[2]).spliterator(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[2]).spliterator(ValueLayout.JAVA_INT);\n@@ -108,1 +107,1 @@\n-        MemorySegment.ofArray(new byte[2]).elements(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[2]).elements(ValueLayout.JAVA_INT);\n@@ -113,1 +112,1 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[7]).spliterator(ValueLayout.JAVA_INT);\n@@ -118,1 +117,1 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayouts.JAVA_INT);\n+        MemorySegment.ofArray(new byte[7]).elements(ValueLayout.JAVA_INT);\n@@ -123,1 +122,1 @@\n-        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+        MemorySegment.ofArray(new byte[7]).spliterator(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n@@ -128,1 +127,1 @@\n-        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, MemoryLayouts.JAVA_INT));\n+        MemorySegment.ofArray(new byte[7]).elements(MemoryLayout.sequenceLayout(0, ValueLayout.JAVA_INT));\n","filename":"test\/jdk\/java\/foreign\/TestSpliterator.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -29,0 +28,1 @@\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -43,1 +43,2 @@\n-            MemorySegment text = CLinker.toCString(testString, scope);\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(expectedByteLength, scope);\n+            MemorySegment text = allocator.allocateUtf8String(testString);\n@@ -47,1 +48,1 @@\n-            String roundTrip = CLinker.toJavaString(text);\n+            String roundTrip = text.getUtf8String(0);\n","filename":"test\/jdk\/java\/foreign\/TestStringEncoding.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -32,2 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -36,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -38,0 +38,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -64,2 +65,2 @@\n-        MemorySegment segment = LOOKUP.lookup(\"c\").get().asSegment(MemoryLayouts.JAVA_INT.byteSize(), ResourceScope.globalScope());\n-        assertEquals(MemoryAccess.getInt(segment), 42);\n+        MemorySegment segment = MemorySegment.ofAddressNative(LOOKUP.lookup(\"c\").get().address(), ValueLayout.JAVA_INT.byteSize(), ResourceScope.globalScope());\n+        assertEquals(segment.get(JAVA_BYTE, 0), 42);\n","filename":"test\/jdk\/java\/foreign\/TestSymbolLookup.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.incubator.foreign.MemoryHandles;\n@@ -32,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -34,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -41,3 +40,2 @@\n-    static final VarHandle INT_HANDLE = MemoryLayouts.JAVA_INT.varHandle(int.class);\n-\n-    static final VarHandle ADDR_HANDLE = MemoryHandles.asAddressVarHandle(INT_HANDLE);\n+    static final VarHandle INT_HANDLE = ValueLayout.JAVA_INT.varHandle();\n+    static final VarHandle ADDR_HANDLE = ValueLayout.ADDRESS.varHandle();\n@@ -47,4 +45,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n-            int v = (int)INT_HANDLE.get(\"string\");\n-        }\n+        int v = (int)INT_HANDLE.get(\"string\");\n@@ -55,4 +50,1 @@\n-        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n-            MemorySegment s = MemorySegment.allocateNative(8, 8, scope);\n-            int v = (int)INT_HANDLE.get(1);\n-        }\n+        int v = (int)INT_HANDLE.get(1);\n","filename":"test\/jdk\/java\/foreign\/TestTypeAccess.java","additions":5,"deletions":13,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        CLinker.getInstance(); \/\/ trigger initialization\n+        CLinker.systemCLinker(); \/\/ trigger initialization\n","filename":"test\/jdk\/java\/foreign\/TestUnsupportedPlatform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @test\n+ * @test id=async\n@@ -33,0 +33,1 @@\n+ *   -DUPCALL_TEST_TYPE=ASYNC\n@@ -36,0 +37,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +40,2 @@\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.SegmentAllocator;\n@@ -44,0 +48,1 @@\n+import org.testng.SkipException;\n@@ -51,0 +56,1 @@\n+import java.util.HashMap;\n@@ -52,0 +58,1 @@\n+import java.util.Map;\n@@ -57,1 +64,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -63,0 +69,8 @@\n+    private enum TestType {\n+        SCOPE,\n+        NO_SCOPE,\n+        ASYNC\n+    }\n+\n+    private static final TestType UPCALL_TEST_TYPE = TestType.valueOf(System.getProperty(\"UPCALL_TEST_TYPE\"));\n+\n@@ -65,0 +79,1 @@\n+        System.loadLibrary(\"AsyncInvokers\");\n@@ -66,1 +81,1 @@\n-    static CLinker abi = CLinker.getInstance();\n+    static CLinker abi = CLinker.systemCLinker();\n@@ -83,1 +98,1 @@\n-    static MemoryAddress dummyStub;\n+    static NativeSymbol dummyStub;\n@@ -90,0 +105,5 @@\n+    private static void checkSelected(TestType type) {\n+        if (UPCALL_TEST_TYPE != type)\n+            return;\/\/throw new SkipException(\"Skipping tests that were not selected\");\n+    }\n+\n@@ -92,0 +112,2 @@\n+        checkSelected(TestType.SCOPE);\n+\n@@ -94,5 +116,5 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n-        try (NativeScope scope = new NativeScope()) {\n-            MethodHandle mh = abi.downcallHandle(addr, scope, mtype, function(ret, paramTypes, fields));\n-            Object[] args = makeArgs(scope.scope(), ret, paramTypes, fields, returnChecks, argChecks);\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, function(ret, paramTypes, fields));\n+            Object[] args = makeArgs(scope, ret, paramTypes, fields, returnChecks, argChecks);\n@@ -109,1 +131,2 @@\n-    public void testUpcallsNoScope(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+    public void testUpcallsAsync(int count, String fName, Ret ret, List<ParamType> paramTypes, List<StructFieldType> fields) throws Throwable {\n+        checkSelected(TestType.ASYNC);\n@@ -112,9 +135,23 @@\n-        MemoryAddress addr = LOOKUP.lookup(fName).get();\n-        MethodType mtype = methodType(ret, paramTypes, fields);\n-        MethodHandle mh = abi.downcallHandle(addr, IMPLICIT_ALLOCATOR, mtype, function(ret, paramTypes, fields));\n-        Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n-        Object[] callArgs = args;\n-        Object res = mh.invokeWithArguments(callArgs);\n-        argChecks.forEach(c -> c.accept(args));\n-        if (ret == Ret.NON_VOID) {\n-            returnChecks.forEach(c -> c.accept(res));\n+        NativeSymbol addr = LOOKUP.lookup(fName).get();\n+        try (ResourceScope scope = ResourceScope.newSharedScope()) {\n+            SegmentAllocator allocator = SegmentAllocator.newNativeArena(scope);\n+            FunctionDescriptor descriptor = function(ret, paramTypes, fields);\n+            MethodHandle mh = downcallHandle(abi, addr, allocator, descriptor);\n+            Object[] args = makeArgs(ResourceScope.newImplicitScope(), ret, paramTypes, fields, returnChecks, argChecks);\n+\n+            mh = mh.asSpreader(Object[].class, args.length);\n+            mh = MethodHandles.insertArguments(mh, 0, (Object) args);\n+            FunctionDescriptor callbackDesc = descriptor.returnLayout()\n+                    .map(FunctionDescriptor::of)\n+                    .orElse(FunctionDescriptor.ofVoid());\n+            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n+\n+            MethodHandle invoker = asyncInvoker(ret, ret == Ret.VOID ? null : paramTypes.get(0), fields);\n+\n+            Object res = invoker.type().returnType() == MemorySegment.class\n+                    ? invoker.invoke(allocator, callback)\n+                    : invoker.invoke(callback);\n+            argChecks.forEach(c -> c.accept(args));\n+            if (ret == Ret.NON_VOID) {\n+                returnChecks.forEach(c -> c.accept(res));\n+            }\n@@ -124,5 +161,9 @@\n-    static MethodType methodType(Ret ret, List<ParamType> params, List<StructFieldType> fields) {\n-        MethodType mt = ret == Ret.VOID ?\n-                MethodType.methodType(void.class) : MethodType.methodType(paramCarrier(params.get(0).layout(fields)));\n-        for (ParamType p : params) {\n-            mt = mt.appendParameterTypes(paramCarrier(p.layout(fields)));\n+    private static final Map<String, MethodHandle> INVOKERS = new HashMap<>();\n+\n+    private MethodHandle asyncInvoker(Ret ret, ParamType returnType, List<StructFieldType> fields) {\n+        if (ret == Ret.VOID) {\n+            String name = \"call_async_V\";\n+            return INVOKERS.computeIfAbsent(name, symbol ->\n+                abi.downcallHandle(\n+                    LOOKUP.lookup(symbol).orElseThrow(),\n+                        FunctionDescriptor.ofVoid(C_POINTER)));\n@@ -130,2 +171,11 @@\n-        mt = mt.appendParameterTypes(MemoryAddress.class); \/\/the callback\n-        return mt;\n+\n+        String name = \"call_async_\" + returnType.name().charAt(0)\n+                + (returnType == ParamType.STRUCT ? \"_\" + sigCode(fields) : \"\");\n+\n+        return INVOKERS.computeIfAbsent(name, symbol -> {\n+            NativeSymbol invokerSymbol = LOOKUP.lookup(symbol).orElseThrow();\n+            MemoryLayout returnLayout = returnType.layout(fields);\n+            FunctionDescriptor desc = FunctionDescriptor.of(returnLayout, C_POINTER);\n+\n+            return abi.downcallHandle(invokerSymbol, desc);\n+        });\n@@ -153,1 +203,1 @@\n-    static MemoryAddress makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n+    static NativeSymbol makeCallback(ResourceScope scope, Ret ret, List<ParamType> params, List<StructFieldType> fields, List<Consumer<Object>> checks, List<Consumer<Object[]>> argChecks) {\n@@ -155,1 +205,1 @@\n-            return dummyStub.address();\n+            return dummyStub;\n@@ -165,1 +215,1 @@\n-            Class<?> carrier = paramCarrier(layout);\n+            Class<?> carrier = carrier(layout, false);\n@@ -178,1 +228,1 @@\n-        Class<?> firstCarrier = paramCarrier(firstlayout);\n+        Class<?> firstCarrier = carrier(firstlayout, true);\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":80,"deletions":30,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -36,3 +36,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.ResourceScope;\n@@ -57,2 +54,2 @@\n-        boolean useSpec = false;\n-        run(useSpec);\n+        run(\/* useSpec = *\/ false, \/* isVoid = *\/ true);\n+        run(\/* useSpec = *\/ false, \/* isVoid = *\/ false);\n@@ -63,2 +60,2 @@\n-        boolean useSpec = true;\n-        run(useSpec);\n+        run(\/* useSpec = *\/ true, \/* isVoid = *\/ true);\n+        run(\/* useSpec = *\/ true, \/* isVoid = *\/ false);\n@@ -67,1 +64,1 @@\n-    private void run(boolean useSpec) throws IOException, InterruptedException {\n+    private void run(boolean useSpec, boolean isVoid) throws IOException, InterruptedException {\n@@ -80,1 +77,2 @@\n-                \"ThrowingUpcall\")\n+                \"ThrowingUpcall\",\n+                isVoid ? \"void\" : \"non-void\")\n","filename":"test\/jdk\/java\/foreign\/TestUpcallException.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -38,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -52,1 +54,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -58,1 +59,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -73,6 +74,1 @@\n-                MethodType.methodType(void.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class,\n-                    MemorySegment.class, int.class, double.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER,\n+                    FunctionDescriptor.ofVoid(C_POINTER,\n@@ -111,1 +107,1 @@\n-            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDescriptor, scope);\n@@ -113,1 +109,1 @@\n-            args[0] = upcallStub.address();\n+            args[0] = upcallStub;\n@@ -126,1 +122,1 @@\n-                    assertEquals(capturedArgsArr[i], args[i + 1]);\n+                    assertEquals(capturedArgsArr[i], args[i + 1], \"For index \" + i);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallHighArity.java","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -42,0 +43,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -55,3 +57,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -60,1 +59,1 @@\n-public class TestUpcallStructScope {\n+public class TestUpcallStructScope extends NativeTestHelper {\n@@ -62,1 +61,1 @@\n-    static final CLinker LINKER = CLinker.getInstance();\n+    static final CLinker LINKER = CLinker.systemCLinker();\n@@ -77,2 +76,1 @@\n-            MethodType.methodType(void.class, MemoryAddress.class, MemorySegment.class),\n-            FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n+                FunctionDescriptor.ofVoid(C_POINTER, S_PDI_LAYOUT)\n@@ -99,1 +97,1 @@\n-            MemoryAddress upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n+            NativeSymbol upcallStub = LINKER.upcallStub(target, upcallDesc, scope);\n@@ -101,1 +99,1 @@\n-            MH_do_upcall.invokeExact(upcallStub.address(), argSegment);\n+            MH_do_upcall.invoke(upcallStub, argSegment);\n","filename":"test\/jdk\/java\/foreign\/TestUpcallStructScope.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -48,1 +49,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -52,1 +52,1 @@\n-public class TestVarArgs {\n+public class TestVarArgs extends NativeTestHelper {\n@@ -58,2 +58,2 @@\n-    static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(long.class, groupElement(\"writeback\"));\n-    static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(long.class, groupElement(\"argIDs\"));\n+    static final VarHandle VH_CallInfo_writeback = ML_CallInfo.varHandle(groupElement(\"writeback\"));\n+    static final VarHandle VH_CallInfo_argIDs = ML_CallInfo.varHandle(groupElement(\"argIDs\"));\n@@ -61,1 +61,1 @@\n-    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_IntArray = MemoryLayout.sequenceLayout(C_INT).varHandle(sequenceElement());\n@@ -63,1 +63,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -68,1 +68,1 @@\n-    static final MemoryAddress VARARGS_ADDR =\n+    static final NativeSymbol VARARGS_ADDR =\n@@ -83,2 +83,2 @@\n-            VH_CallInfo_writeback.set(callInfo, writeBack.address().toRawLongValue());\n-            VH_CallInfo_argIDs.set(callInfo, argIDs.address().toRawLongValue());\n+            VH_CallInfo_writeback.set(callInfo, writeBack.address());\n+            VH_CallInfo_argIDs.set(callInfo, argIDs.address());\n@@ -93,1 +93,0 @@\n-            args.forEach(a -> argLayouts.add(asVarArg(a.layout)));\n@@ -95,1 +94,2 @@\n-            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.toArray(MemoryLayout[]::new));\n+            FunctionDescriptor desc = FunctionDescriptor.ofVoid(argLayouts.stream().toArray(MemoryLayout[]::new))\n+                    .asVariadic(args.stream().map(a -> a.layout).toArray(MemoryLayout[]::new));\n@@ -104,1 +104,1 @@\n-            MethodHandle downcallHandle = abi.downcallHandle(VARARGS_ADDR, mt, desc);\n+            MethodHandle downcallHandle = abi.downcallHandle(VARARGS_ADDR, desc);\n@@ -143,1 +143,1 @@\n-            this.vh = layout.varHandle(carrier);\n+            this.vh = layout.varHandle();\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -46,1 +47,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE);\n@@ -55,1 +56,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 4, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(32));\n@@ -63,10 +64,0 @@\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testAlignNotPowerOf2() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 3, ByteOrder.nativeOrder());\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class)\n-    public void testAlignNegative() {\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, -1, ByteOrder.nativeOrder());\n-    }\n-\n@@ -75,1 +66,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(byte.class, 2, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_BYTE.withBitAlignment(16));\n@@ -84,1 +75,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.LITTLE_ENDIAN);\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.LITTLE_ENDIAN));\n@@ -94,1 +85,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(short.class, 2, ByteOrder.BIG_ENDIAN);\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_SHORT.withOrder(ByteOrder.BIG_ENDIAN));\n@@ -109,1 +100,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(ValueLayout.JAVA_INT.withBitAlignment(32));\n@@ -124,17 +115,0 @@\n-\n-    @Test(dataProvider = \"badCarriers\", expectedExceptions = IllegalArgumentException.class)\n-    public void testBadCarrier(Class<?> carrier) {\n-        MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n-    }\n-\n-    @DataProvider(name = \"badCarriers\")\n-    public Object[][] createBadCarriers() {\n-        return new Object[][] {\n-                { void.class },\n-                { boolean.class },\n-                { Object.class },\n-                { int[].class },\n-                { MemorySegment.class }\n-        };\n-    }\n-\n","filename":"test\/jdk\/java\/foreign\/TestVarHandleCombinators.java","additions":7,"deletions":33,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -33,1 +33,0 @@\n-import java.security.Permission;\n@@ -35,1 +34,1 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n+public class ThrowingUpcall extends NativeTestHelper {\n@@ -37,3 +36,2 @@\n-public class ThrowingUpcall {\n-\n-    private static final MethodHandle downcall;\n+    private static final MethodHandle downcallVoid;\n+    private static final MethodHandle downcallNonVoid;\n@@ -45,1 +43,1 @@\n-        downcall = CLinker.getInstance().downcallHandle(\n+        downcallVoid = CLinker.systemCLinker().downcallHandle(\n@@ -47,2 +45,5 @@\n-            MethodType.methodType(void.class, MemoryAddress.class),\n-            FunctionDescriptor.ofVoid(C_POINTER)\n+                FunctionDescriptor.ofVoid(C_POINTER)\n+        );\n+        downcallNonVoid = CLinker.systemCLinker().downcallHandle(\n+            lookup.lookup(\"f10_I_I_\").orElseThrow(),\n+                FunctionDescriptor.of(C_INT, C_INT, C_POINTER)\n@@ -64,1 +65,5 @@\n-        test();\n+        if (args[0].equals(\"void\")) {\n+            testVoid();\n+        } else {\n+            testNonVoid();\n+        }\n@@ -67,1 +72,1 @@\n-    public static void test() throws Throwable {\n+    public static void testVoid() throws Throwable {\n@@ -73,1 +78,14 @@\n-            MemoryAddress stub = CLinker.getInstance().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.ofVoid(), scope);\n+\n+            downcallVoid.invoke(stub); \/\/ should call Shutdown.exit(1);\n+        }\n+    }\n+\n+    public static void testNonVoid() throws Throwable {\n+        MethodHandle handle = MethodHandles.identity(int.class);\n+        handle = MethodHandles.collectArguments(handle, 0, MH_throwException);\n+        MethodHandle invoker = MethodHandles.exactInvoker(MethodType.methodType(int.class, int.class));\n+        handle = MethodHandles.insertArguments(invoker, 0, handle);\n+\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            NativeSymbol stub = CLinker.systemCLinker().upcallStub(handle, FunctionDescriptor.of(C_INT, C_INT), scope);\n@@ -75,1 +93,1 @@\n-            downcall.invokeExact(stub); \/\/ should call Shutdown.exit(1);\n+            downcallNonVoid.invoke(42, stub); \/\/ should call Shutdown.exit(1);\n","filename":"test\/jdk\/java\/foreign\/ThrowingUpcall.java","additions":31,"deletions":13,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -81,1 +81,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -106,1 +106,1 @@\n-      MethodType mt = MethodType.methodType(void.class,\n+        MethodType mt = MethodType.methodType(void.class,\n@@ -110,1 +110,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -131,1 +131,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -160,2 +160,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -191,1 +190,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -201,2 +200,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -207,2 +205,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -223,1 +220,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -246,1 +243,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -272,1 +269,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -308,1 +305,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -361,1 +358,1 @@\n-        CallArranger.Bindings bindings = CallArranger.getBindings(mt, fd, false);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n@@ -369,2 +366,2 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(r0, long.class) },\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(r1, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(r1, long.class) },\n@@ -377,1 +374,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n@@ -383,0 +380,42 @@\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn);\n+        CallingSequence callingSequence = bindings.callingSequence;\n+        assertEquals(callingSequence.methodType(), mt);\n+        assertEquals(callingSequence.functionDesc(), fd);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage(0), int.class) },\n+            { vmStore(stackStorage(1), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":60,"deletions":21,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -159,2 +159,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -181,1 +180,1 @@\n-                C_INT, C_DOUBLE, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_DOUBLE));\n+                C_INT, C_DOUBLE).asVariadic(C_INT, C_DOUBLE, C_DOUBLE);\n@@ -254,2 +253,1 @@\n-                baseAddress(),\n-                unboxAddress(),\n+                unboxAddress(MemorySegment.class),\n@@ -353,1 +351,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(rcx, long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(rcx, long.class) },\n@@ -357,1 +355,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(0), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(0), long.class) },\n@@ -361,1 +359,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(4), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(4), long.class) },\n@@ -365,1 +363,1 @@\n-            { copy(struct), baseAddress(), unboxAddress(), vmStore(stackStorage(8), long.class) },\n+            { copy(struct), unboxAddress(MemorySegment.class), vmStore(stackStorage(8), long.class) },\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsCallArranger.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.lang.ref.Cleaner;\n@@ -32,1 +31,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -37,0 +36,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -54,1 +55,1 @@\n-        if (scope.isImplicit())\n+        if (scope == ResourceScope.globalScope())\n@@ -78,1 +79,1 @@\n-            MemoryAccess.setByteAtOffset(segment, i, ((byte)RANDOM.nextInt()));\n+            segment.set(JAVA_BYTE, i, ((byte)RANDOM.nextInt()));\n@@ -132,1 +133,0 @@\n-                { ScopeSupplier.NEW_CONFINED_EXPLICIT },\n@@ -140,1 +140,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT },\n@@ -154,1 +153,0 @@\n-                { ScopeSupplier.NEW_IMPLICIT },\n@@ -177,1 +175,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT ,  0 },\n@@ -179,1 +176,0 @@\n-                { ScopeSupplier.NEW_SHARED_EXPLICIT , 30 },\n@@ -186,3 +182,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newConfinedScope(), \"newConfinedScope()\");\n-        static final Supplier<ResourceScope> NEW_CONFINED_EXPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newConfinedScope(Cleaner.create()), \"newConfinedScope(Cleaner)\");\n+                new ScopeSupplier(ResourceScope::newConfinedScope, \"newConfinedScope()\");\n@@ -190,3 +184,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newSharedScope(), \"newSharedScope()\");\n-        static final Supplier<ResourceScope> NEW_SHARED_EXPLICIT =\n-                new ScopeSupplier(() -> ResourceScope.newSharedScope(Cleaner.create()), \"newSharedScope(Cleaner)\");\n+                new ScopeSupplier(ResourceScope::newSharedScope, \"newSharedScope()\");\n@@ -194,1 +186,1 @@\n-                new ScopeSupplier(() -> ResourceScope.newImplicitScope(), \"newImplicitScope()\");\n+                new ScopeSupplier(ResourceScope::newImplicitScope, \"newImplicitScope()\");\n@@ -196,1 +188,1 @@\n-                new ScopeSupplier(() -> ResourceScope.globalScope(), \"globalScope()\");\n+                new ScopeSupplier(ResourceScope::globalScope, \"globalScope()\");\n","filename":"test\/jdk\/java\/foreign\/channels\/AbstractChannelsTest.java","additions":9,"deletions":17,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -57,0 +57,1 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -165,1 +166,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n@@ -224,1 +225,1 @@\n-                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+                assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n@@ -273,1 +274,1 @@\n-            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is acquired by\");\n+            assertMessage(expectThrows(ISE, () -> scope.close()), \"Scope is kept alive by\");\n","filename":"test\/jdk\/java\/foreign\/channels\/TestAsyncSocketChannels.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+\n@@ -47,0 +47,2 @@\n+\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -104,1 +106,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n@@ -122,1 +124,1 @@\n-                MemoryAccess.setByteAtOffset(segment1, i, (byte) i);\n+                segment1.set(JAVA_BYTE, i, (byte) i);\n","filename":"test\/jdk\/java\/foreign\/channels\/TestSocketChannels.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -41,1 +41,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n@@ -48,1 +48,1 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n@@ -55,1 +55,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/org\/openjdk\/foreigntest\/PanamaMainUnnamedModule.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       CLinker.getInstance();\n+       CLinker.systemCLinker();\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMain.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n+       var mh = MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainInvoke.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-       Method method = CLinker.class.getDeclaredMethod(\"getInstance\");\n+       Method method = CLinker.class.getDeclaredMethod(\"systemCLinker\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainReflection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n+import jdk.incubator.foreign.MemorySegment;\n@@ -35,0 +35,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -55,1 +56,1 @@\n-            throw new AssertionError(\"Call to restricted method did not fail as expected!\");\n+            throw new AssertionError(\"Call to restricted method did not fail as expected!\", ex);\n@@ -66,2 +67,1 @@\n-        addDefaultMapping(CLinker.class, CLinker.getInstance());\n-        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(CLinker.class, CLinker.systemCLinker());\n@@ -76,1 +76,1 @@\n-        addDefaultMapping(MemoryLayout.class, MemoryLayouts.JAVA_INT);\n+        addDefaultMapping(MemoryLayout.class, ValueLayout.JAVA_INT);\n@@ -80,1 +80,18 @@\n-        addDefaultMapping(SegmentAllocator.class, (size, align) -> null);\n+        addDefaultMapping(SegmentAllocator.class, SegmentAllocator.prefixAllocator(MemorySegment.ofArray(new byte[10])));\n+        addDefaultMapping(ValueLayout.OfByte.class, ValueLayout.JAVA_BYTE);\n+        addDefaultMapping(ValueLayout.OfBoolean.class, ValueLayout.JAVA_BOOLEAN);\n+        addDefaultMapping(ValueLayout.OfChar.class, ValueLayout.JAVA_CHAR);\n+        addDefaultMapping(ValueLayout.OfShort.class, ValueLayout.JAVA_SHORT);\n+        addDefaultMapping(ValueLayout.OfInt.class, ValueLayout.JAVA_INT);\n+        addDefaultMapping(ValueLayout.OfFloat.class, ValueLayout.JAVA_FLOAT);\n+        addDefaultMapping(ValueLayout.OfLong.class, ValueLayout.JAVA_LONG);\n+        addDefaultMapping(ValueLayout.OfDouble.class, ValueLayout.JAVA_DOUBLE);\n+        addDefaultMapping(ValueLayout.OfAddress.class, ValueLayout.ADDRESS);\n+        addDefaultMapping(byte.class, (byte)0);\n+        addDefaultMapping(boolean.class, true);\n+        addDefaultMapping(char.class, (char)0);\n+        addDefaultMapping(short.class, (short)0);\n+        addDefaultMapping(int.class, 0);\n+        addDefaultMapping(float.class, 0f);\n+        addDefaultMapping(long.class, 0L);\n+        addDefaultMapping(double.class, 0d);\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":23,"deletions":6,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -32,3 +31,0 @@\n-import java.nio.charset.Charset;\n-import java.nio.file.Path;\n-import java.util.Optional;\n@@ -36,1 +32,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.Addressable;\n@@ -39,1 +35,0 @@\n-import jdk.incubator.foreign.MemoryLayout;\n@@ -42,1 +37,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -44,0 +38,2 @@\n+import jdk.incubator.foreign.VaList;\n+import jdk.incubator.foreign.ValueLayout;\n@@ -57,13 +53,4 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"getInstance\",\n-                            MethodType.methodType(CLinker.class)), \"CLinker::getInstance\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"toJavaString\",\n-                            MethodType.methodType(String.class, MemoryAddress.class)),\n-                            \"CLinker::toJavaString\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"allocateMemory\",\n-                            MethodType.methodType(MemoryAddress.class, long.class)),\n-                            \"CLinker::allocateMemory\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"freeMemory\",\n-                            MethodType.methodType(void.class, MemoryAddress.class)),\n-                            \"CLinker::freeMemory\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n-                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class)),\n+                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemCLinker\",\n+                            MethodType.methodType(CLinker.class)), \"ForeignLinker::systemCLinker\" },\n+                    { MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\",\n+                            MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class)),\n@@ -71,6 +58,0 @@\n-                    { MethodHandles.lookup().findStatic(CLinker.VaList.class, \"ofAddress\",\n-                            MethodType.methodType(CLinker.VaList.class, MemoryAddress.class, ResourceScope.class)),\n-                            \"VaList::ofAddress\/2\" },\n-                    { MethodHandles.lookup().findStatic(CLinker.class, \"systemLookup\",\n-                            MethodType.methodType(SymbolLookup.class)),\n-                            \"CLinker::systemLookup\" },\n@@ -80,9 +61,63 @@\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-                            MethodType.methodType(MemorySegment.class, long.class, ResourceScope.class)),\n-                            \"MemoryAddress::asSegment\/1\" },\n-                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"asSegment\",\n-                            MethodType.methodType(MemorySegment.class, long.class, Runnable.class, ResourceScope.class)),\n-                            \"MemoryAddress::asSegment\/2\" },\n-                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"globalNativeSegment\",\n-                            MethodType.methodType(MemorySegment.class)),\n-                            \"MemoryAddress::globalNativeSegment\" }\n+                    { MethodHandles.lookup().findStatic(MemorySegment.class, \"ofAddressNative\",\n+                            MethodType.methodType(MemorySegment.class, MemoryAddress.class, long.class, ResourceScope.class)),\n+                            \"MemorySegment::ofAddressNative\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"getUtf8String\",\n+                            MethodType.methodType(String.class, long.class)),\n+                            \"MemoryAddress::getUtf8String\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"setUtf8String\",\n+                            MethodType.methodType(void.class, long.class, String.class)),\n+                            \"MemoryAddress::setUtf8String\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(byte.class, ValueLayout.OfByte.class, long.class)),\n+                            \"MemoryAddress::get\/byte\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(boolean.class, ValueLayout.OfBoolean.class, long.class)),\n+                            \"MemoryAddress::get\/boolean\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(char.class, ValueLayout.OfChar.class, long.class)),\n+                            \"MemoryAddress::get\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(short.class, ValueLayout.OfShort.class, long.class)),\n+                            \"MemoryAddress::get\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(int.class, ValueLayout.OfInt.class, long.class)),\n+                            \"MemoryAddress::get\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(float.class, ValueLayout.OfFloat.class, long.class)),\n+                            \"MemoryAddress::get\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(long.class, ValueLayout.OfLong.class, long.class)),\n+                            \"MemoryAddress::get\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(double.class, ValueLayout.OfDouble.class, long.class)),\n+                            \"MemoryAddress::get\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"get\",\n+                            MethodType.methodType(MemoryAddress.class, ValueLayout.OfAddress.class, long.class)),\n+                            \"MemoryAddress::get\/address\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfByte.class, long.class, byte.class)),\n+                            \"MemoryAddress::set\/byte\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfBoolean.class, long.class, boolean.class)),\n+                            \"MemoryAddress::set\/boolean\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfChar.class, long.class, char.class)),\n+                            \"MemoryAddress::set\/char\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfShort.class, long.class, short.class)),\n+                            \"MemoryAddress::set\/short\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfInt.class, long.class, int.class)),\n+                            \"MemoryAddress::set\/int\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfFloat.class, long.class, float.class)),\n+                            \"MemoryAddress::set\/float\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfLong.class, long.class, long.class)),\n+                            \"MemoryAddress::set\/long\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfDouble.class, long.class, double.class)),\n+                            \"MemoryAddress::set\/double\" },\n+                    { MethodHandles.lookup().findVirtual(MemoryAddress.class, \"set\",\n+                            MethodType.methodType(void.class, ValueLayout.OfAddress.class, long.class, Addressable.class)),\n+                            \"MemoryAddress::set\/address\" },\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":70,"deletions":35,"binary":false,"changes":105,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <thread>\n+\n+#include \"libTestUpcall.h\"\n+#ifdef __clang__\n+#pragma clang optimize off\n+#elif defined __GNUC__\n+#pragma GCC optimize (\"O0\")\n+#elif defined _MSC_BUILD\n+#pragma optimize( \"\", off )\n+#endif\n+\n+template<typename CB>\n+void launch_v(CB cb) {\n+    std::thread thrd(cb);\n+    thrd.join();\n+}\n+\n+template<typename O, typename CB>\n+void start(O& out, CB cb) {\n+    out = cb();\n+}\n+\n+template<typename O, typename CB>\n+O launch(CB cb) {\n+    O result;\n+    std::thread thrd(&start<O, CB>, std::ref(result), cb);\n+    thrd.join();\n+    return result;\n+}\n+\n+extern \"C\" {\n+EXPORT void call_async_V(void (*cb)(void)) { launch_v(cb); }\n+\n+EXPORT int call_async_I(int (*cb)(void)) { return launch<int>(cb); }\n+EXPORT float call_async_F(float (*cb)(void)) { return launch<float>(cb); }\n+EXPORT double call_async_D(double (*cb)(void)) { return launch<double>(cb); }\n+EXPORT void* call_async_P(void* (*cb)(void)) { return launch<void*>(cb); }\n+\n+EXPORT struct S_I call_async_S_I(struct S_I (*cb)(void)) { return launch<struct S_I>(cb); }\n+EXPORT struct S_F call_async_S_F(struct S_F (*cb)(void)) { return launch<struct S_F>(cb); }\n+EXPORT struct S_D call_async_S_D(struct S_D (*cb)(void)) { return launch<struct S_D>(cb); }\n+EXPORT struct S_P call_async_S_P(struct S_P (*cb)(void)) { return launch<struct S_P>(cb); }\n+EXPORT struct S_II call_async_S_II(struct S_II (*cb)(void)) { return launch<struct S_II>(cb); }\n+EXPORT struct S_IF call_async_S_IF(struct S_IF (*cb)(void)) { return launch<struct S_IF>(cb); }\n+EXPORT struct S_ID call_async_S_ID(struct S_ID (*cb)(void)) { return launch<struct S_ID>(cb); }\n+EXPORT struct S_IP call_async_S_IP(struct S_IP (*cb)(void)) { return launch<struct S_IP>(cb); }\n+EXPORT struct S_FI call_async_S_FI(struct S_FI (*cb)(void)) { return launch<struct S_FI>(cb); }\n+EXPORT struct S_FF call_async_S_FF(struct S_FF (*cb)(void)) { return launch<struct S_FF>(cb); }\n+EXPORT struct S_FD call_async_S_FD(struct S_FD (*cb)(void)) { return launch<struct S_FD>(cb); }\n+EXPORT struct S_FP call_async_S_FP(struct S_FP (*cb)(void)) { return launch<struct S_FP>(cb); }\n+EXPORT struct S_DI call_async_S_DI(struct S_DI (*cb)(void)) { return launch<struct S_DI>(cb); }\n+EXPORT struct S_DF call_async_S_DF(struct S_DF (*cb)(void)) { return launch<struct S_DF>(cb); }\n+EXPORT struct S_DD call_async_S_DD(struct S_DD (*cb)(void)) { return launch<struct S_DD>(cb); }\n+EXPORT struct S_DP call_async_S_DP(struct S_DP (*cb)(void)) { return launch<struct S_DP>(cb); }\n+EXPORT struct S_PI call_async_S_PI(struct S_PI (*cb)(void)) { return launch<struct S_PI>(cb); }\n+EXPORT struct S_PF call_async_S_PF(struct S_PF (*cb)(void)) { return launch<struct S_PF>(cb); }\n+EXPORT struct S_PD call_async_S_PD(struct S_PD (*cb)(void)) { return launch<struct S_PD>(cb); }\n+EXPORT struct S_PP call_async_S_PP(struct S_PP (*cb)(void)) { return launch<struct S_PP>(cb); }\n+EXPORT struct S_III call_async_S_III(struct S_III (*cb)(void)) { return launch<struct S_III>(cb); }\n+EXPORT struct S_IIF call_async_S_IIF(struct S_IIF (*cb)(void)) { return launch<struct S_IIF>(cb); }\n+EXPORT struct S_IID call_async_S_IID(struct S_IID (*cb)(void)) { return launch<struct S_IID>(cb); }\n+EXPORT struct S_IIP call_async_S_IIP(struct S_IIP (*cb)(void)) { return launch<struct S_IIP>(cb); }\n+EXPORT struct S_IFI call_async_S_IFI(struct S_IFI (*cb)(void)) { return launch<struct S_IFI>(cb); }\n+EXPORT struct S_IFF call_async_S_IFF(struct S_IFF (*cb)(void)) { return launch<struct S_IFF>(cb); }\n+EXPORT struct S_IFD call_async_S_IFD(struct S_IFD (*cb)(void)) { return launch<struct S_IFD>(cb); }\n+EXPORT struct S_IFP call_async_S_IFP(struct S_IFP (*cb)(void)) { return launch<struct S_IFP>(cb); }\n+EXPORT struct S_IDI call_async_S_IDI(struct S_IDI (*cb)(void)) { return launch<struct S_IDI>(cb); }\n+EXPORT struct S_IDF call_async_S_IDF(struct S_IDF (*cb)(void)) { return launch<struct S_IDF>(cb); }\n+EXPORT struct S_IDD call_async_S_IDD(struct S_IDD (*cb)(void)) { return launch<struct S_IDD>(cb); }\n+EXPORT struct S_IDP call_async_S_IDP(struct S_IDP (*cb)(void)) { return launch<struct S_IDP>(cb); }\n+EXPORT struct S_IPI call_async_S_IPI(struct S_IPI (*cb)(void)) { return launch<struct S_IPI>(cb); }\n+EXPORT struct S_IPF call_async_S_IPF(struct S_IPF (*cb)(void)) { return launch<struct S_IPF>(cb); }\n+EXPORT struct S_IPD call_async_S_IPD(struct S_IPD (*cb)(void)) { return launch<struct S_IPD>(cb); }\n+EXPORT struct S_IPP call_async_S_IPP(struct S_IPP (*cb)(void)) { return launch<struct S_IPP>(cb); }\n+EXPORT struct S_FII call_async_S_FII(struct S_FII (*cb)(void)) { return launch<struct S_FII>(cb); }\n+EXPORT struct S_FIF call_async_S_FIF(struct S_FIF (*cb)(void)) { return launch<struct S_FIF>(cb); }\n+EXPORT struct S_FID call_async_S_FID(struct S_FID (*cb)(void)) { return launch<struct S_FID>(cb); }\n+EXPORT struct S_FIP call_async_S_FIP(struct S_FIP (*cb)(void)) { return launch<struct S_FIP>(cb); }\n+EXPORT struct S_FFI call_async_S_FFI(struct S_FFI (*cb)(void)) { return launch<struct S_FFI>(cb); }\n+EXPORT struct S_FFF call_async_S_FFF(struct S_FFF (*cb)(void)) { return launch<struct S_FFF>(cb); }\n+EXPORT struct S_FFD call_async_S_FFD(struct S_FFD (*cb)(void)) { return launch<struct S_FFD>(cb); }\n+EXPORT struct S_FFP call_async_S_FFP(struct S_FFP (*cb)(void)) { return launch<struct S_FFP>(cb); }\n+EXPORT struct S_FDI call_async_S_FDI(struct S_FDI (*cb)(void)) { return launch<struct S_FDI>(cb); }\n+EXPORT struct S_FDF call_async_S_FDF(struct S_FDF (*cb)(void)) { return launch<struct S_FDF>(cb); }\n+EXPORT struct S_FDD call_async_S_FDD(struct S_FDD (*cb)(void)) { return launch<struct S_FDD>(cb); }\n+EXPORT struct S_FDP call_async_S_FDP(struct S_FDP (*cb)(void)) { return launch<struct S_FDP>(cb); }\n+EXPORT struct S_FPI call_async_S_FPI(struct S_FPI (*cb)(void)) { return launch<struct S_FPI>(cb); }\n+EXPORT struct S_FPF call_async_S_FPF(struct S_FPF (*cb)(void)) { return launch<struct S_FPF>(cb); }\n+EXPORT struct S_FPD call_async_S_FPD(struct S_FPD (*cb)(void)) { return launch<struct S_FPD>(cb); }\n+EXPORT struct S_FPP call_async_S_FPP(struct S_FPP (*cb)(void)) { return launch<struct S_FPP>(cb); }\n+EXPORT struct S_DII call_async_S_DII(struct S_DII (*cb)(void)) { return launch<struct S_DII>(cb); }\n+EXPORT struct S_DIF call_async_S_DIF(struct S_DIF (*cb)(void)) { return launch<struct S_DIF>(cb); }\n+EXPORT struct S_DID call_async_S_DID(struct S_DID (*cb)(void)) { return launch<struct S_DID>(cb); }\n+EXPORT struct S_DIP call_async_S_DIP(struct S_DIP (*cb)(void)) { return launch<struct S_DIP>(cb); }\n+EXPORT struct S_DFI call_async_S_DFI(struct S_DFI (*cb)(void)) { return launch<struct S_DFI>(cb); }\n+EXPORT struct S_DFF call_async_S_DFF(struct S_DFF (*cb)(void)) { return launch<struct S_DFF>(cb); }\n+EXPORT struct S_DFD call_async_S_DFD(struct S_DFD (*cb)(void)) { return launch<struct S_DFD>(cb); }\n+EXPORT struct S_DFP call_async_S_DFP(struct S_DFP (*cb)(void)) { return launch<struct S_DFP>(cb); }\n+EXPORT struct S_DDI call_async_S_DDI(struct S_DDI (*cb)(void)) { return launch<struct S_DDI>(cb); }\n+EXPORT struct S_DDF call_async_S_DDF(struct S_DDF (*cb)(void)) { return launch<struct S_DDF>(cb); }\n+EXPORT struct S_DDD call_async_S_DDD(struct S_DDD (*cb)(void)) { return launch<struct S_DDD>(cb); }\n+EXPORT struct S_DDP call_async_S_DDP(struct S_DDP (*cb)(void)) { return launch<struct S_DDP>(cb); }\n+EXPORT struct S_DPI call_async_S_DPI(struct S_DPI (*cb)(void)) { return launch<struct S_DPI>(cb); }\n+EXPORT struct S_DPF call_async_S_DPF(struct S_DPF (*cb)(void)) { return launch<struct S_DPF>(cb); }\n+EXPORT struct S_DPD call_async_S_DPD(struct S_DPD (*cb)(void)) { return launch<struct S_DPD>(cb); }\n+EXPORT struct S_DPP call_async_S_DPP(struct S_DPP (*cb)(void)) { return launch<struct S_DPP>(cb); }\n+EXPORT struct S_PII call_async_S_PII(struct S_PII (*cb)(void)) { return launch<struct S_PII>(cb); }\n+EXPORT struct S_PIF call_async_S_PIF(struct S_PIF (*cb)(void)) { return launch<struct S_PIF>(cb); }\n+EXPORT struct S_PID call_async_S_PID(struct S_PID (*cb)(void)) { return launch<struct S_PID>(cb); }\n+EXPORT struct S_PIP call_async_S_PIP(struct S_PIP (*cb)(void)) { return launch<struct S_PIP>(cb); }\n+EXPORT struct S_PFI call_async_S_PFI(struct S_PFI (*cb)(void)) { return launch<struct S_PFI>(cb); }\n+EXPORT struct S_PFF call_async_S_PFF(struct S_PFF (*cb)(void)) { return launch<struct S_PFF>(cb); }\n+EXPORT struct S_PFD call_async_S_PFD(struct S_PFD (*cb)(void)) { return launch<struct S_PFD>(cb); }\n+EXPORT struct S_PFP call_async_S_PFP(struct S_PFP (*cb)(void)) { return launch<struct S_PFP>(cb); }\n+EXPORT struct S_PDI call_async_S_PDI(struct S_PDI (*cb)(void)) { return launch<struct S_PDI>(cb); }\n+EXPORT struct S_PDF call_async_S_PDF(struct S_PDF (*cb)(void)) { return launch<struct S_PDF>(cb); }\n+EXPORT struct S_PDD call_async_S_PDD(struct S_PDD (*cb)(void)) { return launch<struct S_PDD>(cb); }\n+EXPORT struct S_PDP call_async_S_PDP(struct S_PDP (*cb)(void)) { return launch<struct S_PDP>(cb); }\n+EXPORT struct S_PPI call_async_S_PPI(struct S_PPI (*cb)(void)) { return launch<struct S_PPI>(cb); }\n+EXPORT struct S_PPF call_async_S_PPF(struct S_PPF (*cb)(void)) { return launch<struct S_PPF>(cb); }\n+EXPORT struct S_PPD call_async_S_PPD(struct S_PPD (*cb)(void)) { return launch<struct S_PPD>(cb); }\n+EXPORT struct S_PPP call_async_S_PPP(struct S_PPP (*cb)(void)) { return launch<struct S_PPP>(cb); }\n+}\n","filename":"test\/jdk\/java\/foreign\/libAsyncInvokers.cpp","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -25,0 +25,2 @@\n+#include <stdbool.h>\n+\n@@ -34,0 +36,4 @@\n+EXPORT bool identity_bool(bool x) {\n+    return x;\n+}\n+\n","filename":"test\/jdk\/java\/foreign\/libIntrinsics.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -39,0 +39,6 @@\n+\n+EXPORT void addr_func_6(struct Point* p1, struct Point* p2, struct Point* p3, struct Point* p4, struct Point* p5, struct Point* p6) { }\n+\n+EXPORT void addr_func_cb(void* p, void (*callback)()) {\n+   callback();\n+}\n","filename":"test\/jdk\/java\/foreign\/libSafeAccess.c","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires ((os.arch == \"amd64\" | os.arch == \"x86_64\") & sun.arch.data.model == \"64\") | os.arch == \"aarch64\"\n+ * @compile --add-modules jdk.incubator.foreign lookup\/Lookup.java\n+ * @compile --add-modules jdk.incubator.foreign invoker\/Invoker.java\n+ * @run main\/othervm --enable-native-access=ALL-UNNAMED TestLoaderLookup\n+ *\/\n+\n+import java.lang.reflect.*;\n+import jdk.incubator.foreign.*;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Paths;\n+\n+public class TestLoaderLookup {\n+    public static void main(String[] args) throws ReflectiveOperationException {\n+        ClassLoader loader1 = newClassLoader(\"lookup\");\n+        Class<?> lookup = loader1.loadClass(\"lookup.Lookup\");\n+        Method fooSymbol = lookup.getDeclaredMethod(\"fooSymbol\");\n+        NativeSymbol foo = (NativeSymbol)fooSymbol.invoke(null);\n+\n+        ClassLoader loader2 = newClassLoader(\"invoker\");\n+        Class<?> invoker = loader2.loadClass(\"invoker.Invoker\");\n+        Method invoke = invoker.getDeclaredMethod(\"invoke\", NativeSymbol.class);\n+        invoke.invoke(null, foo);\n+\n+        loader1 = null;\n+        lookup = null;\n+        fooSymbol = null;\n+        \/\/ Make sure that the loader is kept reachable\n+        for (int i = 0 ; i < 1000 ; i++) {\n+            invoke.invoke(null, foo); \/\/ might crash if loader1 is GC'ed\n+            System.gc();\n+        }\n+    }\n+\n+    public static ClassLoader newClassLoader(String path) {\n+        try {\n+            return new URLClassLoader(new URL[] {\n+                    Paths.get(System.getProperty(\"test.classes\", path)).toUri().toURL(),\n+            }, null);\n+        } catch (MalformedURLException e){\n+            throw new RuntimeException(\"Unexpected URL conversion failure\", e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/TestLoaderLookup.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package invoker;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class Invoker {\n+    public static void invoke(NativeSymbol symbol) throws Throwable {\n+        var linker = CLinker.systemCLinker();\n+        var handle = linker.downcallHandle(symbol, FunctionDescriptor.ofVoid());\n+        handle.invokeExact();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/invoker\/Invoker.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package lookup;\n+\n+import jdk.incubator.foreign.*;\n+\n+public class Lookup {\n+    static {\n+        System.loadLibrary(\"Foo\");\n+    }\n+\n+    static SymbolLookup lookup = SymbolLookup.loaderLookup();\n+\n+    public static NativeSymbol fooSymbol() {\n+        return lookup.lookup(\"foo\").get();\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/Lookup.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+EXPORT void foo(void) {\n+    \/\/ do nothing\n+}\n","filename":"test\/jdk\/java\/foreign\/loaderLookup\/lookup\/libFoo.c","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+ * @library ..\/\n@@ -32,1 +33,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -40,1 +40,0 @@\n-import java.lang.invoke.MethodType;\n@@ -42,1 +41,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -45,1 +44,1 @@\n-public class TestMixedMallocFree {\n+public class TestMixedMallocFree extends NativeTestHelper {\n@@ -53,1 +52,1 @@\n-        MH_my_malloc = CLinker.getInstance().downcallHandle(\n+        MH_my_malloc = CLinker.systemCLinker().downcallHandle(\n@@ -55,2 +54,1 @@\n-            MethodType.methodType(MemoryAddress.class, long.class),\n-            FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n+                FunctionDescriptor.of(C_POINTER, C_LONG_LONG));\n@@ -62,3 +60,3 @@\n-        MemorySegment seg = ma.asSegment(4L, ResourceScope.newImplicitScope());\n-        MemoryAccess.setInt(seg, 42);\n-        assertEquals(MemoryAccess.getInt(seg), 42);\n+        MemorySegment seg = MemorySegment.ofAddressNative(ma, 4L, ResourceScope.newImplicitScope());\n+        seg.set(JAVA_INT, 0, 42);\n+        assertEquals(seg.get(JAVA_INT, 0), 42);\n@@ -67,1 +65,1 @@\n-        CLinker.freeMemory(ma);\n+        freeMemory(ma);\n","filename":"test\/jdk\/java\/foreign\/malloc\/TestMixedMallocFree.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -55,0 +56,1 @@\n+ * @library ..\/\n@@ -83,0 +85,1 @@\n+ * @library ..\/\n@@ -109,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -119,1 +123,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -122,1 +125,1 @@\n-public class TestAsyncStackWalk {\n+public class TestAsyncStackWalk extends NativeTestHelper {\n@@ -125,1 +128,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -136,1 +139,0 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n@@ -149,1 +151,1 @@\n-            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -159,1 +161,1 @@\n-        MH_asyncStackWalk.invokeExact(cb);\n+        MH_asyncStackWalk.invoke(cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestAsyncStackWalk.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * @library ..\/\n@@ -55,0 +56,1 @@\n+ * @library ..\/\n@@ -83,0 +85,1 @@\n+ * @library ..\/\n@@ -109,0 +112,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -120,1 +124,0 @@\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -122,1 +125,1 @@\n-public class TestStackWalk {\n+public class TestStackWalk extends NativeTestHelper {\n@@ -125,1 +128,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -136,1 +139,0 @@\n-                    MethodType.methodType(void.class, MemoryAddress.class),\n@@ -148,1 +150,1 @@\n-            MemoryAddress stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n+            NativeSymbol stub = linker.upcallStub(MH_m, FunctionDescriptor.ofVoid(), scope);\n@@ -161,1 +163,1 @@\n-        MH_foo.invokeExact(cb);\n+        MH_foo.invoke(cb);\n","filename":"test\/jdk\/java\/foreign\/stackwalk\/TestStackWalk.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-import jdk.incubator.foreign.CLinker.VaList;\n+import jdk.incubator.foreign.VaList;\n@@ -58,7 +58,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_FLOAT;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n-import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n@@ -66,1 +59,3 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n@@ -72,1 +67,1 @@\n-    private static final CLinker abi = CLinker.getInstance();\n+    private static final CLinker abi = CLinker.systemCLinker();\n@@ -79,27 +74,39 @@\n-    private static final MethodHandle MH_sumInts = link(\"sumInts\",\n-            MethodType.methodType(int.class, int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumDoubles = link(\"sumDoubles\",\n-            MethodType.methodType(double.class, int.class, VaList.class),\n-            FunctionDescriptor.of(C_DOUBLE, C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_getInt = link(\"getInt\",\n-            MethodType.methodType(int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumStruct = link(\"sumStruct\",\n-            MethodType.methodType(int.class, VaList.class),\n-            FunctionDescriptor.of(C_INT, C_VA_LIST));\n-    private static final MethodHandle MH_sumBigStruct = link(\"sumBigStruct\",\n-            MethodType.methodType(long.class, VaList.class),\n-            FunctionDescriptor.of(C_LONG_LONG, C_VA_LIST));\n-    private static final MethodHandle MH_sumHugeStruct = link(\"sumHugeStruct\",\n-            MethodType.methodType(long.class, VaList.class),\n-            FunctionDescriptor.of(C_LONG_LONG, C_VA_LIST));\n-    private static final MethodHandle MH_sumFloatStruct = link(\"sumFloatStruct\",\n-            MethodType.methodType(float.class, VaList.class),\n-            FunctionDescriptor.of(C_FLOAT, C_VA_LIST));\n-    private static final MethodHandle MH_sumStack = link(\"sumStack\",\n-            MethodType.methodType(void.class, MemoryAddress.class, MemoryAddress.class, VaList.class),\n-            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_VA_LIST));\n-\n-    private static MethodHandle link(String symbol, MethodType mt, FunctionDescriptor fd) {\n-        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), mt, fd);\n+    private static final MethodHandle ADDRESS_TO_VALIST;\n+\n+    static {\n+        try {\n+            ADDRESS_TO_VALIST = MethodHandles.lookup().findStatic(VaList.class, \"ofAddress\", MethodType.methodType(VaList.class, MemoryAddress.class, ResourceScope.class));\n+        } catch (Throwable ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+\n+    private static final MethodHandle MH_sumInts = linkVaList(\"sumInts\",\n+            FunctionDescriptor.of(C_INT, C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumDoubles = linkVaList(\"sumDoubles\",\n+            FunctionDescriptor.of(C_DOUBLE, C_INT, C_POINTER));\n+    private static final MethodHandle MH_getInt = linkVaList(\"getInt\",\n+            FunctionDescriptor.of(C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumStruct = linkVaList(\"sumStruct\",\n+            FunctionDescriptor.of(C_INT, C_POINTER));\n+    private static final MethodHandle MH_sumBigStruct = linkVaList(\"sumBigStruct\",\n+            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+    private static final MethodHandle MH_sumHugeStruct = linkVaList(\"sumHugeStruct\",\n+            FunctionDescriptor.of(C_LONG_LONG, C_POINTER));\n+    private static final MethodHandle MH_sumFloatStruct = linkVaList(\"sumFloatStruct\",\n+            FunctionDescriptor.of(C_FLOAT, C_POINTER));\n+    private static final MethodHandle MH_sumStack = linkVaList(\"sumStack\",\n+            FunctionDescriptor.ofVoid(C_POINTER, C_POINTER, C_POINTER));\n+\n+    private static MethodHandle link(String symbol, FunctionDescriptor fd) {\n+        return linkInternal(symbol, fd);\n+    }\n+\n+    private static MethodHandle linkVaList(String symbol, FunctionDescriptor fd) {\n+        return linkInternal(symbol, fd);\n+    }\n+\n+\n+    private static MethodHandle linkInternal(String symbol, FunctionDescriptor fd) {\n+        return abi.downcallHandle(LOOKUP.lookup(symbol).get(), fd);\n@@ -110,1 +117,0 @@\n-                MethodType.methodType(void.class, MemoryAddress.class),\n@@ -126,10 +132,10 @@\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> winVaListScopedFactory\n-            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> sysvVaListScopedFactory\n-            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> linuxAArch64VaListScopedFactory\n-            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> macAArch64VaListScopedFactory\n-            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope.scope());\n-    private static final BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> platformVaListScopedFactory\n-            = (builder, scope) -> VaList.make(builder, scope.scope());\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> winVaListScopedFactory\n+            = (builder, scope) -> Windowsx64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> sysvVaListScopedFactory\n+            = (builder, scope) -> SysVx64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> linuxAArch64VaListScopedFactory\n+            = (builder, scope) -> LinuxAArch64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> macAArch64VaListScopedFactory\n+            = (builder, scope) -> MacOsAArch64Linker.newVaList(builder, scope);\n+    private static final BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> platformVaListScopedFactory\n+            = (builder, scope) -> VaList.make(builder, scope);\n@@ -140,2 +146,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();\n+        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n+                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -156,1 +162,1 @@\n-                           ValueLayout intLayout) {\n+                           ValueLayout.OfInt intLayout) {\n@@ -158,3 +164,3 @@\n-            b.vargFromInt(intLayout, 10)\n-                    .vargFromInt(intLayout, 15)\n-                    .vargFromInt(intLayout, 20));\n+            b.addVarg(intLayout, 10)\n+                    .addVarg(intLayout, 15)\n+                    .addVarg(intLayout, 20));\n@@ -169,2 +175,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n-                (num, list) -> DoubleStream.generate(() -> list.vargAsDouble(layout)).limit(num).sum();\n+        Function<ValueLayout.OfDouble, BiFunction<Integer, VaList, Double>> sumDoublesJavaFact  = layout ->\n+                (num, list) -> DoubleStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -185,1 +191,1 @@\n-                              ValueLayout doubleLayout) {\n+                              ValueLayout.OfDouble doubleLayout) {\n@@ -187,3 +193,3 @@\n-            b.vargFromDouble(doubleLayout, 3.0D)\n-                    .vargFromDouble(doubleLayout, 4.0D)\n-                    .vargFromDouble(doubleLayout, 5.0D));\n+            b.addVarg(doubleLayout, 3.0D)\n+                    .addVarg(doubleLayout, 4.0D)\n+                    .addVarg(doubleLayout, 5.0D));\n@@ -198,1 +204,1 @@\n-        Function<MemoryLayout, Function<VaList, Integer>> getIntJavaFact = layout ->\n+        Function<ValueLayout.OfAddress, Function<VaList, Integer>> getIntJavaFact = layout ->\n@@ -200,2 +206,2 @@\n-                    MemoryAddress ma = list.vargAsAddress(layout);\n-                    return MemoryAccess.getIntAtOffset(MemorySegment.globalNativeSegment(), ma.toRawLongValue());\n+                    MemoryAddress ma = list.nextVarg(layout);\n+                    return ma.get(JAVA_INT, 0);\n@@ -216,1 +222,1 @@\n-                                        ValueLayout pointerLayout) {\n+                                        ValueLayout.OfAddress pointerLayout) {\n@@ -219,2 +225,2 @@\n-            MemoryAccess.setInt(msInt, 10);\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromAddress(pointerLayout, msInt.address()));\n+            msInt.set(JAVA_INT, 0, 10);\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(pointerLayout, msInt.address()));\n@@ -234,1 +240,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructJavaFact\n@@ -237,1 +243,2 @@\n-                    MemorySegment struct = list.vargAsSegment(pointLayout, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(pointLayout, ResourceScope.newImplicitScope());\n+                    list.nextVarg(pointLayout, SegmentAllocator.prefixAllocator(struct));\n@@ -243,1 +250,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>> sumStructNativeFact\n@@ -248,1 +255,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Integer>>, Object[]> argsFact\n@@ -254,2 +261,2 @@\n-            VarHandle VH_Point_x = pointLayout.varHandle(int.class, groupElement(\"x\"));\n-            VarHandle VH_Point_y = pointLayout.varHandle(int.class, groupElement(\"y\"));\n+            VarHandle VH_Point_x = pointLayout.varHandle(groupElement(\"x\"));\n+            VarHandle VH_Point_y = pointLayout.varHandle(groupElement(\"y\"));\n@@ -277,1 +284,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, struct));\n@@ -287,1 +294,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n@@ -290,1 +297,2 @@\n-                    MemorySegment struct = list.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -296,1 +304,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n@@ -301,1 +309,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n@@ -307,2 +315,2 @@\n-            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n+            VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -330,1 +338,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(BigPoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(BigPoint_LAYOUT, struct));\n@@ -340,1 +348,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructJavaFact\n@@ -343,1 +351,2 @@\n-                    MemorySegment struct = list.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -349,1 +358,1 @@\n-        TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n+        TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>> sumStructNativeFact\n@@ -354,1 +363,1 @@\n-                TriFunction<MemoryLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n+                TriFunction<GroupLayout, VarHandle, VarHandle, Function<VaList, Float>>, Object[]> argsFact\n@@ -360,2 +369,2 @@\n-            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"x\"));\n-            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"y\"));\n+            VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -384,1 +393,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(FloatPoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(FloatPoint_LAYOUT, struct));\n@@ -398,1 +407,1 @@\n-        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n+        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructJavaFact\n@@ -401,1 +410,2 @@\n-                    MemorySegment struct = list.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    list.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -408,1 +418,1 @@\n-        QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n+        QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>> sumStructNativeFact\n@@ -413,1 +423,1 @@\n-                QuadFunc<MemoryLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n+                QuadFunc<GroupLayout, VarHandle, VarHandle, VarHandle, Function<VaList, Long>>, Object[]> argsFact\n@@ -420,3 +430,3 @@\n-            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n-            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"z\"));\n+            VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n+            VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n+            VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n@@ -449,1 +459,1 @@\n-            VaList vaList = vaListFactory.apply(b -> b.vargFromSegment(HugePoint_LAYOUT, struct));\n+            VaList vaList = vaListFactory.apply(b -> b.addVarg(HugePoint_LAYOUT, struct));\n@@ -462,1 +472,1 @@\n-        BiFunction<MemoryLayout, MemoryLayout, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n+        BiFunction<ValueLayout.OfLong, ValueLayout.OfDouble, SumStackFunc> sumStackJavaFact = (longLayout, doubleLayout) ->\n@@ -466,1 +476,1 @@\n-                        lSum += list.vargAsLong(longLayout);\n+                        lSum += list.nextVarg(longLayout);\n@@ -468,1 +478,1 @@\n-                    MemoryAccess.setLong(longSum, lSum);\n+                    longSum.set(JAVA_LONG, 0, lSum);\n@@ -471,1 +481,1 @@\n-                        dSum += list.vargAsDouble(doubleLayout);\n+                        dSum += list.nextVarg(doubleLayout);\n@@ -473,1 +483,1 @@\n-                    MemoryAccess.setDouble(doubleSum, dSum);\n+                    doubleSum.set(JAVA_DOUBLE, 0, dSum);\n@@ -477,1 +487,1 @@\n-                MH_sumStack.invokeExact(longSum.address(), doubleSum.address(), list);\n+                MH_sumStack.invoke(longSum, doubleSum, list);\n@@ -494,2 +504,2 @@\n-                          ValueLayout longLayout,\n-                          ValueLayout doubleLayout) {\n+                          ValueLayout.OfLong longLayout,\n+                          ValueLayout.OfDouble doubleLayout) {\n@@ -499,2 +509,2 @@\n-            MemoryAccess.setLong(longSum, 0L);\n-            MemoryAccess.setDouble(doubleSum, 0D);\n+            longSum.set(JAVA_LONG, 0, 0L);\n+            doubleSum.set(JAVA_DOUBLE, 0, 0D);\n@@ -504,1 +514,1 @@\n-                    b.vargFromLong(longLayout, l);\n+                    b.addVarg(longLayout, l);\n@@ -507,1 +517,1 @@\n-                    b.vargFromDouble(doubleLayout, d);\n+                    b.addVarg(doubleLayout, d);\n@@ -517,2 +527,2 @@\n-            long lSum = MemoryAccess.getLong(longSum);\n-            double dSum = MemoryAccess.getDouble(doubleSum);\n+            long lSum = longSum.get(JAVA_LONG, 0);\n+            double dSum = doubleSum.get(JAVA_DOUBLE, 0);\n@@ -527,1 +537,1 @@\n-        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_VA_LIST);\n+        FunctionDescriptor desc = FunctionDescriptor.ofVoid(C_POINTER);\n@@ -529,2 +539,2 @@\n-            MemoryAddress stub = abi.upcallStub(callback, desc, scope);\n-            target.invokeExact(stub.address());\n+            NativeSymbol stub = abi.upcallStub(callback, desc, scope);\n+            target.invoke(stub);\n@@ -558,2 +568,2 @@\n-        Function<MemoryLayout, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n-                (num, list) -> IntStream.generate(() -> list.vargAsInt(layout)).limit(num).sum();\n+        Function<ValueLayout.OfInt, BiFunction<Integer, VaList, Integer>> sumIntsJavaFact = layout ->\n+                (num, list) -> IntStream.generate(() -> list.nextVarg(layout)).limit(num).sum();\n@@ -572,1 +582,1 @@\n-    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, NativeScope, VaList> vaListFactory,\n+    public void testScopedVaList(BiFunction<Consumer<VaList.Builder>, ResourceScope, VaList> vaListFactory,\n@@ -574,1 +584,1 @@\n-                                 ValueLayout intLayout) {\n+                                 ValueLayout.OfInt intLayout) {\n@@ -576,4 +586,3 @@\n-        try (NativeScope scope = new NativeScope()) {\n-            VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                            .vargFromInt(intLayout, 8),\n-                    scope);\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                            .addVarg(intLayout, 8), scope);\n@@ -592,1 +601,1 @@\n-        try (NativeScope scope = new NativeScope()) {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n@@ -597,2 +606,3 @@\n-                VaList list = vaListFactory.apply(b -> b.vargFromSegment(Point_LAYOUT, pointIn));\n-                pointOut = list.vargAsSegment(Point_LAYOUT, scope);\n+                VaList list = vaListFactory.apply(b -> b.addVarg(Point_LAYOUT, pointIn));\n+                pointOut = MemorySegment.allocateNative(Point_LAYOUT, scope);\n+                list.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(pointOut));\n@@ -620,3 +630,3 @@\n-    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n+    public void testCopy(Function<Consumer<VaList.Builder>, VaList> vaListFactory, ValueLayout.OfInt intLayout) {\n+        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                .addVarg(intLayout, 8));\n@@ -624,2 +634,2 @@\n-        assertEquals(copy.vargAsInt(intLayout), 4);\n-        assertEquals(copy.vargAsInt(intLayout), 8);\n+        assertEquals(copy.nextVarg(intLayout), 4);\n+        assertEquals(copy.nextVarg(intLayout), 8);\n@@ -634,2 +644,2 @@\n-        assertEquals(list.vargAsInt(intLayout), 4);\n-        assertEquals(list.vargAsInt(intLayout), 8);\n+        assertEquals(list.nextVarg(intLayout), 4);\n+        assertEquals(list.nextVarg(intLayout), 8);\n@@ -642,3 +652,3 @@\n-                                                    ValueLayout intLayout) {\n-        VaList list = vaListFactory.apply(b -> b.vargFromInt(intLayout, 4)\n-                .vargFromInt(intLayout, 8));\n+                                                    ValueLayout.OfInt intLayout) {\n+        VaList list = vaListFactory.apply(b -> b.addVarg(intLayout, 4)\n+                .addVarg(intLayout, 8));\n@@ -648,1 +658,1 @@\n-        copy.vargAsInt(intLayout); \/\/ should throw\n+        copy.nextVarg(intLayout); \/\/ should throw\n@@ -657,2 +667,2 @@\n-        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n+        VarHandle VH_BigPoint_x = BigPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_BigPoint_y = BigPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -663,2 +673,2 @@\n-        VarHandle VH_Point_x = Point_LAYOUT.varHandle(int.class, groupElement(\"x\"));\n-        VarHandle VH_Point_y = Point_LAYOUT.varHandle(int.class, groupElement(\"y\"));\n+        VarHandle VH_Point_x = Point_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_Point_y = Point_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -669,2 +679,2 @@\n-        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"x\"));\n-        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(float.class, groupElement(\"y\"));\n+        VarHandle VH_FloatPoint_x = FloatPoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_FloatPoint_y = FloatPoint_LAYOUT.varHandle(groupElement(\"y\"));\n@@ -676,3 +686,3 @@\n-        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"x\"));\n-        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"y\"));\n-        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(long.class, groupElement(\"z\"));\n+        VarHandle VH_HugePoint_x = HugePoint_LAYOUT.varHandle(groupElement(\"x\"));\n+        VarHandle VH_HugePoint_y = HugePoint_LAYOUT.varHandle(groupElement(\"y\"));\n+        VarHandle VH_HugePoint_z = HugePoint_LAYOUT.varHandle(groupElement(\"z\"));\n@@ -682,1 +692,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -688,1 +699,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -696,1 +708,1 @@\n-                    struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    copy.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -701,1 +713,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(BigPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -705,1 +718,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n@@ -709,1 +722,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 42);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 42);\n@@ -712,1 +725,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(Point_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -717,1 +731,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(HugePoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(HugePoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -723,1 +738,2 @@\n-                    MemorySegment struct = vaList.vargAsSegment(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = MemorySegment.allocateNative(FloatPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    vaList.nextVarg(FloatPoint_LAYOUT, SegmentAllocator.prefixAllocator(struct));\n@@ -728,3 +744,3 @@\n-                    MemoryAddress intPtr = vaList.vargAsAddress(C_POINTER);\n-                    MemorySegment ms = intPtr.asSegment(C_INT.byteSize(), ResourceScope.globalScope());\n-                    int x = MemoryAccess.getInt(ms);\n+                    MemoryAddress intPtr = vaList.nextVarg(C_POINTER);\n+                    MemorySegment ms = MemorySegment.ofAddressNative(intPtr, C_INT.byteSize(), ResourceScope.globalScope());\n+                    int x = ms.get(JAVA_INT, 0);\n@@ -734,3 +750,3 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 3.0);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 4.0);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 5.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 3.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 4.0);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 5.0);\n@@ -739,3 +755,3 @@\n-                    assertEquals(vaList.vargAsInt(C_INT), 10);\n-                    assertEquals(vaList.vargAsInt(C_INT), 15);\n-                    assertEquals(vaList.vargAsInt(C_INT), 20);\n+                    assertEquals(vaList.nextVarg(C_INT), 10);\n+                    assertEquals(vaList.nextVarg(C_INT), 15);\n+                    assertEquals(vaList.nextVarg(C_INT), 20);\n@@ -746,1 +762,1 @@\n-                        assertEquals(vaList.vargAsLong(C_LONG_LONG), l);\n+                        assertEquals(vaList.nextVarg(C_LONG_LONG), l);\n@@ -749,1 +765,1 @@\n-                        assertEquals(vaList.vargAsDouble(C_DOUBLE), d);\n+                        assertEquals(vaList.nextVarg(C_DOUBLE), d);\n@@ -753,16 +769,19 @@\n-                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 1);\n-                    assertEquals((char) vaList.vargAsInt(C_INT), 'a');\n-                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 3);\n-                    assertEquals(vaList.vargAsInt(C_INT), 4);\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 5L);\n-                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 6.0F);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 7.0D);\n-                    assertEquals((byte) vaList.vargAsInt(C_INT), (byte) 8);\n-                    assertEquals((char) vaList.vargAsInt(C_INT), 'b');\n-                    assertEquals((short) vaList.vargAsInt(C_INT), (short) 10);\n-                    assertEquals(vaList.vargAsInt(C_INT), 11);\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 12L);\n-                    assertEquals((float) vaList.vargAsDouble(C_DOUBLE), 13.0F);\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 14.0D);\n-\n-                    MemorySegment point = vaList.vargAsSegment(Point_LAYOUT, ResourceScope.newImplicitScope());\n+                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 1);\n+                    assertEquals((char) vaList.nextVarg(C_INT), 'a');\n+                    assertEquals((short) vaList.nextVarg(C_INT), (short) 3);\n+                    assertEquals(vaList.nextVarg(C_INT), 4);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n+                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 6.0F);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 7.0D);\n+                    assertEquals((byte) vaList.nextVarg(C_INT), (byte) 8);\n+                    assertEquals((char) vaList.nextVarg(C_INT), 'b');\n+                    assertEquals((short) vaList.nextVarg(C_INT), (short) 10);\n+                    assertEquals(vaList.nextVarg(C_INT), 11);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 12L);\n+                    assertEquals((float) vaList.nextVarg(C_DOUBLE), 13.0F);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 14.0D);\n+\n+                    MemorySegment buffer = MemorySegment.allocateNative(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    SegmentAllocator bufferAllocator = SegmentAllocator.prefixAllocator(buffer);\n+\n+                    MemorySegment point = vaList.nextVarg(Point_LAYOUT, bufferAllocator);\n@@ -773,1 +792,1 @@\n-                    MemorySegment bigPoint = vaList.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment bigPoint = vaList.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n@@ -781,1 +800,1 @@\n-                    MemorySegment struct = copy.vargAsSegment(BigPoint_LAYOUT, ResourceScope.newImplicitScope());\n+                    MemorySegment struct = copy.nextVarg(BigPoint_LAYOUT, bufferAllocator);\n@@ -788,1 +807,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 5L);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 5L);\n@@ -790,1 +809,1 @@\n-                    assertEquals(vaList.vargAsLong(C_LONG_LONG), 10L);\n+                    assertEquals(vaList.nextVarg(C_LONG_LONG), 10L);\n@@ -792,1 +811,1 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 1.0D);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 1.0D);\n@@ -794,1 +813,1 @@\n-                    assertEquals(vaList.vargAsDouble(C_DOUBLE), 6.0D);\n+                    assertEquals(vaList.nextVarg(C_DOUBLE), 6.0D);\n@@ -804,1 +823,1 @@\n-                return MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n+                MethodHandle handle = MethodHandles.lookup().findVirtual(VaListConsumer.class, \"accept\",\n@@ -806,0 +825,2 @@\n+                return MethodHandles.filterArguments(handle, 0,\n+                        MethodHandles.insertArguments(ADDRESS_TO_VALIST, 1, ResourceScope.newConfinedScope()));\n","filename":"test\/jdk\/java\/foreign\/valist\/VaListTest.java","additions":207,"deletions":186,"binary":false,"changes":393,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * @library ..\/\n@@ -37,1 +38,0 @@\n-import java.lang.invoke.MethodType;\n@@ -39,0 +39,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -43,1 +44,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -46,1 +46,1 @@\n-public class TestVirtualCalls {\n+public class TestVirtualCalls extends NativeTestHelper {\n@@ -48,1 +48,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -51,3 +51,3 @@\n-    static final MemoryAddress funcA;\n-    static final MemoryAddress funcB;\n-    static final MemoryAddress funcC;\n+    static final NativeSymbol funcA;\n+    static final NativeSymbol funcB;\n+    static final NativeSymbol funcC;\n@@ -57,2 +57,1 @@\n-            MethodType.methodType(int.class),\n-            FunctionDescriptor.of(C_INT));\n+                FunctionDescriptor.of(C_INT));\n@@ -69,3 +68,3 @@\n-        assertEquals((int) func.invokeExact((Addressable) funcA), 1);\n-        assertEquals((int) func.invokeExact((Addressable) funcB), 2);\n-        assertEquals((int) func.invokeExact((Addressable) funcC), 3);\n+        assertEquals((int) func.invokeExact(funcA), 1);\n+        assertEquals((int) func.invokeExact(funcB), 2);\n+        assertEquals((int) func.invokeExact(funcC), 3);\n@@ -76,1 +75,1 @@\n-        int x = (int) func.invokeExact((Addressable) null);\n+        int x = (int) func.invokeExact((NativeSymbol) null);\n","filename":"test\/jdk\/java\/foreign\/virtual\/TestVirtualCalls.java","additions":12,"deletions":13,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import jdk.incubator.foreign.MemoryLayout;\n@@ -173,1 +174,1 @@\n-        VarHandle vh = MemoryHandles.varHandle(carrier, ByteOrder.nativeOrder());\n+        VarHandle vh = MemoryHandles.varHandle(MemoryLayout.valueLayout(carrier, ByteOrder.nativeOrder()));\n","filename":"test\/jdk\/java\/lang\/invoke\/VarHandles\/VarHandleTestExact.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -39,0 +37,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -44,1 +43,1 @@\n-        Function<MemorySegment, Byte> mapper = MemoryAccess::getByte;\n+        Function<MemorySegment, Byte> mapper = s -> s.get(ValueLayout.JAVA_BYTE, 0);\n@@ -55,1 +54,1 @@\n-        Function<MemorySegment, Character> mapper = MemoryAccess::getChar;\n+        Function<MemorySegment, Character> mapper = s -> s.get(ValueLayout.JAVA_CHAR, 0);\n@@ -66,1 +65,1 @@\n-        Function<MemorySegment, Short> mapper = MemoryAccess::getShort;\n+        Function<MemorySegment, Short> mapper = s -> s.get(ValueLayout.JAVA_SHORT, 0);\n@@ -77,1 +76,1 @@\n-        Function<MemorySegment, Integer> mapper = MemoryAccess::getInt;\n+        Function<MemorySegment, Integer> mapper = s -> s.get(ValueLayout.JAVA_INT, 0);\n@@ -88,1 +87,1 @@\n-        Function<MemorySegment, Long> mapper = MemoryAccess::getLong;\n+        Function<MemorySegment, Long> mapper = s-> s.get(ValueLayout.JAVA_LONG, 0);\n@@ -99,1 +98,1 @@\n-        Function<MemorySegment, Float> mapper = MemoryAccess::getFloat;\n+        Function<MemorySegment, Float> mapper = s -> s.get(ValueLayout.JAVA_FLOAT, 0);\n@@ -118,1 +117,1 @@\n-        Function<MemorySegment, Double> mapper = MemoryAccess::getDouble;\n+        Function<MemorySegment, Double> mapper = s -> s.get(ValueLayout.JAVA_DOUBLE, 0);\n@@ -130,1 +129,1 @@\n-            MemoryAccess.setByte(segment, (byte)i);\n+            segment.set(ValueLayout.JAVA_BYTE, 0, (byte)i);\n@@ -135,7 +134,7 @@\n-            { \"bytes\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n-            { \"chars\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n-            { \"shorts\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n-            { \"ints\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n-            { \"longs\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n-            { \"floats\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n-            { \"doubles\", MemoryLayout.sequenceLayout(1024, MemoryLayouts.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n+            { \"bytes\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_BYTE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsByte },\n+            { \"chars\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_CHAR), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsChar },\n+            { \"shorts\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_SHORT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsShort },\n+            { \"ints\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_INT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsInt },\n+            { \"longs\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_LONG), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsLong },\n+            { \"floats\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_FLOAT), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsFloat },\n+            { \"doubles\", MemoryLayout.sequenceLayout(1024, ValueLayout.JAVA_DOUBLE), (SpliteratorTestHelper.ContentAsserter<MemorySegment>)SegmentTestDataProvider::compareSegmentsDouble },\n","filename":"test\/jdk\/java\/util\/stream\/test\/org\/openjdk\/tests\/java\/util\/stream\/SegmentTestDataProvider.java","additions":16,"deletions":17,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.SegmentAllocator;\n@@ -41,1 +40,0 @@\n-import sun.misc.Unsafe;\n@@ -48,2 +46,0 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n-\n@@ -74,1 +70,1 @@\n-    @Param({\"CONFINED\", \"SHARED\", \"IMPLICIT\"})\n+    @Param({\"CONFINED\", \"SHARED\"})\n@@ -124,2 +120,1 @@\n-        if (!scope.isImplicit())\n-            scope.close();\n+        scope.close();\n@@ -137,2 +132,2 @@\n-        var handle = mismatchSegmentLarge1.scope().acquire();\n-        try {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            scope.keepAlive(mismatchSegmentLarge1.scope());\n@@ -140,2 +135,0 @@\n-        } finally {\n-            mismatchSegmentLarge1.scope().release(handle);\n@@ -160,2 +153,2 @@\n-        var handle = mismatchSegmentLarge1.scope().acquire();\n-        try {\n+        try (ResourceScope scope = ResourceScope.newConfinedScope()) {\n+            scope.keepAlive(mismatchSegmentLarge1.scope());\n@@ -163,2 +156,0 @@\n-        } finally {\n-            mismatchSegmentLarge1.scope().release(handle);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkMismatchAcquire.java","additions":6,"deletions":15,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import org.openjdk.jmh.annotations.CompilerControl;\n@@ -34,0 +35,1 @@\n+import org.openjdk.jmh.annotations.Setup;\n@@ -35,0 +37,1 @@\n+import org.openjdk.jmh.annotations.TearDown;\n@@ -40,0 +43,1 @@\n+import java.nio.IntBuffer;\n@@ -42,1 +46,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -58,2 +62,1 @@\n-    static final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n-    static final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final ResourceScope scope = ResourceScope.newConfinedScope();\n@@ -61,3 +64,7 @@\n-    static final int[] bytes = new int[ELEM_SIZE];\n-    static final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n-    static final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n+    final long unsafe_addr = unsafe.allocateMemory(ALLOC_SIZE);\n+    final MemorySegment segment = MemorySegment.allocateNative(ALLOC_SIZE, ResourceScope.newConfinedScope());\n+    final IntBuffer buffer = IntBuffer.allocate(ELEM_SIZE);\n+\n+    final int[] bytes = new int[ELEM_SIZE];\n+    final MemorySegment bytesSegment = MemorySegment.ofArray(bytes);\n+    final int UNSAFE_INT_OFFSET = unsafe.arrayBaseOffset(int[].class);\n@@ -67,4 +74,4 @@\n-    static final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n-    static final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, ResourceScope.newConfinedScope());\n-    static final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n-    static final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final MemorySegment mismatchSegmentLarge1 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final MemorySegment mismatchSegmentLarge2 = MemorySegment.allocateNative(SIZE_WITH_TAIL, scope);\n+    final ByteBuffer mismatchBufferLarge1 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n+    final ByteBuffer mismatchBufferLarge2 = ByteBuffer.allocateDirect(SIZE_WITH_TAIL);\n@@ -73,5 +80,7 @@\n-    static final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n-    static final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, ResourceScope.newConfinedScope());\n-    static final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n-    static final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n-    static {\n+    final MemorySegment mismatchSegmentSmall1 = MemorySegment.allocateNative(7, scope);\n+    final MemorySegment mismatchSegmentSmall2 = MemorySegment.allocateNative(7, scope);\n+    final ByteBuffer mismatchBufferSmall1 = ByteBuffer.allocateDirect(7);\n+    final ByteBuffer mismatchBufferSmall2 = ByteBuffer.allocateDirect(7);\n+\n+    @Setup\n+    public void setup() {\n@@ -93,1 +102,0 @@\n-    }\n@@ -95,1 +103,0 @@\n-    static {\n@@ -101,0 +108,5 @@\n+    @TearDown\n+    public void tearDown() {\n+        scope.close();\n+    }\n+\n@@ -125,0 +137,44 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_small_dontinline() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void unsafe_copy_small() {\n+        unsafe.copyMemory(bytes, UNSAFE_INT_OFFSET, null, unsafe_addr, 10 * CARRIER_SIZE);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy_small() {\n+        buffer.put(0, bytes, 0, 10);\n+    }\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void buffer_copy() {\n+        buffer.put(0, bytes, 0, bytes.length);\n+    }\n+\n+    @Benchmark\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public void segment_copy_static_dontinline() {\n+        MemorySegment.copy(bytes, 0, segment, JAVA_INT, 0, bytes.length);\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/BulkOps.java","additions":74,"deletions":18,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.ValueLayout;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+public class CLayouts {\n+\n+    \/\/ the constants below are useful aliases for C types. The type\/carrier association is only valid for 64-bit platforms.\n+\n+    \/**\n+     * The layout for the {@code bool} C type\n+     *\/\n+    public static final ValueLayout.OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;\n+    \/**\n+     * The layout for the {@code char} C type\n+     *\/\n+    public static final ValueLayout.OfByte C_CHAR = ValueLayout.JAVA_BYTE;\n+    \/**\n+     * The layout for the {@code short} C type\n+     *\/\n+    public static final ValueLayout.OfShort C_SHORT = ValueLayout.JAVA_SHORT;\n+    \/**\n+     * The layout for the {@code int} C type\n+     *\/\n+    public static final ValueLayout.OfInt C_INT = ValueLayout.JAVA_INT;\n+\n+    \/**\n+     * The layout for the {@code long long} C type.\n+     *\/\n+    public static final ValueLayout.OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;\n+    \/**\n+     * The layout for the {@code float} C type\n+     *\/\n+    public static final ValueLayout.OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;\n+    \/**\n+     * The layout for the {@code double} C type\n+     *\/\n+    public static final ValueLayout.OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;\n+    \/**\n+     * The {@code T*} native type.\n+     *\/\n+    public static final ValueLayout.OfAddress C_POINTER = ValueLayout.ADDRESS;\n+\n+    private static CLinker LINKER = CLinker.systemCLinker();\n+\n+    private static final MethodHandle FREE = LINKER.downcallHandle(\n+            LINKER.lookup(\"free\").get(), FunctionDescriptor.ofVoid(ValueLayout.ADDRESS));\n+\n+    private static final MethodHandle MALLOC = LINKER.downcallHandle(\n+            LINKER.lookup(\"malloc\").get(), FunctionDescriptor.of(ValueLayout.ADDRESS, ValueLayout.JAVA_LONG));\n+\n+    public static void freeMemory(Addressable address) {\n+        try {\n+            FREE.invokeExact(address);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    public static MemoryAddress allocateMemory(long size) {\n+        try {\n+            return (MemoryAddress)MALLOC.invokeExact(size);\n+        } catch (Throwable ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CLayouts.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -58,5 +59,0 @@\n-    @Benchmark\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial.invokeExact();\n-    }\n-\n@@ -74,2 +70,57 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial.invokeExact(10);\n+    public MemorySegment panama_identity_struct_confined() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared() throws Throwable {\n+        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_confined_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3.invokeExact(recycling_allocator, confinedPoint, confinedPoint, confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemorySegment panama_identity_struct_shared_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3.invokeExact(recycling_allocator, sharedPoint, sharedPoint, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3.invokeExact((Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n@@ -79,2 +130,2 @@\n-    public MemorySegment panama_identity_struct() throws Throwable {\n-        return (MemorySegment) identity_struct.invokeExact(recycling_allocator, point);\n+    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invokeExact((Addressable)MemoryAddress.NULL);\n@@ -84,2 +135,2 @@\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address.invokeExact(MemoryAddress.NULL);\n+    public MemoryAddress panama_identity_memory_address_null_non_exact() throws Throwable {\n+        return (MemoryAddress) identity_memory_address.invoke(MemoryAddress.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadConstant.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.Addressable;\n@@ -28,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,0 +29,1 @@\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -39,4 +38,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -44,1 +39,1 @@\n-public class CallOverheadHelper {\n+public class CallOverheadHelper extends CLayouts {\n@@ -46,1 +41,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -50,1 +45,1 @@\n-    static Addressable func_addr;\n+    static NativeSymbol func_addr;\n@@ -53,1 +48,1 @@\n-    static Addressable identity_addr;\n+    static NativeSymbol identity_addr;\n@@ -56,1 +51,4 @@\n-    static Addressable identity_struct_addr;\n+    static NativeSymbol identity_struct_addr;\n+    static final MethodHandle identity_struct_3;\n+    static final MethodHandle identity_struct_3_v;\n+    static NativeSymbol identity_struct_3_addr;\n@@ -59,1 +57,4 @@\n-    static Addressable identity_memory_address_addr;\n+    static NativeSymbol identity_memory_address_addr;\n+    static final MethodHandle identity_memory_address_3;\n+    static final MethodHandle identity_memory_address_3_v;\n+    static NativeSymbol identity_memory_address_3_addr;\n@@ -62,1 +63,1 @@\n-    static Addressable args1_addr;\n+    static NativeSymbol args1_addr;\n@@ -65,1 +66,1 @@\n-    static Addressable args2_addr;\n+    static NativeSymbol args2_addr;\n@@ -68,1 +69,1 @@\n-    static Addressable args3_addr;\n+    static NativeSymbol args3_addr;\n@@ -71,1 +72,1 @@\n-    static Addressable args4_addr;\n+    static NativeSymbol args4_addr;\n@@ -74,1 +75,1 @@\n-    static Addressable args5_addr;\n+    static NativeSymbol args5_addr;\n@@ -77,5 +78,1 @@\n-    static Addressable args10_addr;\n-    static final MethodHandle func_trivial;\n-    static final MethodHandle func_trivial_v;\n-    static final MethodHandle identity_trivial;\n-    static final MethodHandle identity_trivial_v;\n+    static NativeSymbol args10_addr;\n@@ -84,1 +81,1 @@\n-            C_LONG_LONG, C_LONG_LONG\n+            C_INT, C_INT\n@@ -87,0 +84,3 @@\n+    static final MemorySegment sharedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newSharedScope());\n+    static final MemorySegment confinedPoint = MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newConfinedScope());\n+\n@@ -89,1 +89,1 @@\n-    static final SegmentAllocator recycling_allocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n+    static final SegmentAllocator recycling_allocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(POINT_LAYOUT, ResourceScope.newImplicitScope()));\n@@ -100,1 +100,1 @@\n-            func_v = abi.downcallHandle(mt, fd);\n+            func_v = abi.downcallHandle(fd);\n@@ -102,2 +102,0 @@\n-            func_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            func_trivial = insertArguments(func_trivial_v, 0, func_addr);\n@@ -107,1 +105,0 @@\n-            MethodType mt = MethodType.methodType(int.class, int.class);\n@@ -109,1 +106,1 @@\n-            identity_v = abi.downcallHandle(mt, fd);\n+            identity_v = abi.downcallHandle(fd);\n@@ -111,2 +108,0 @@\n-            identity_trivial_v = abi.downcallHandle(mt, fd.withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-            identity_trivial = insertArguments(identity_trivial_v, 0, identity_addr);\n@@ -116,1 +111,0 @@\n-                MethodType.methodType(MemorySegment.class, MemorySegment.class),\n@@ -120,0 +114,5 @@\n+        identity_struct_3_addr = lookup.lookup(\"identity_struct_3\").orElseThrow();\n+        identity_struct_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT, POINT_LAYOUT));\n+        identity_struct_3 = insertArguments(identity_struct_3_v, 0, identity_struct_3_addr);\n+\n@@ -122,1 +121,0 @@\n-                MethodType.methodType(MemoryAddress.class, MemoryAddress.class),\n@@ -126,0 +124,5 @@\n+        identity_memory_address_3_addr = lookup.lookup(\"identity_memory_address_3\").orElseThrow();\n+        identity_memory_address_3_v = abi.downcallHandle(\n+                FunctionDescriptor.of(C_POINTER, C_POINTER, C_POINTER, C_POINTER));\n+        identity_memory_address_3 = insertArguments(identity_memory_address_3_v, 0, identity_memory_address_3_addr);\n+\n@@ -128,1 +131,0 @@\n-                MethodType.methodType(void.class, long.class),\n@@ -134,1 +136,0 @@\n-                MethodType.methodType(void.class, long.class, double.class),\n@@ -140,1 +141,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class),\n@@ -146,1 +146,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class),\n@@ -152,1 +151,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class),\n@@ -158,2 +156,0 @@\n-                MethodType.methodType(void.class, long.class, double.class, long.class, double.class, long.class,\n-                                                  double.class, long.class, double.class, long.class, double.class),\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadHelper.java","additions":36,"deletions":40,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -59,2 +60,6 @@\n-    public void panama_blank_trivial() throws Throwable {\n-        func_trivial_v.invokeExact(func_addr);\n+    public int jni_identity() throws Throwable {\n+        return identity(10);\n+    }\n+\n+    public MemorySegment panama_identity_struct_confined() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, confinedPoint);\n@@ -64,2 +69,2 @@\n-    public int jni_identity() throws Throwable {\n-        return identity(10);\n+    public MemorySegment panama_identity_struct_shared() throws Throwable {\n+        return (MemorySegment) identity_struct_v.invokeExact(identity_struct_addr, recycling_allocator, sharedPoint);\n@@ -69,2 +74,2 @@\n-    public int panama_identity() throws Throwable {\n-        return (int) identity_v.invokeExact(identity_addr, 10);\n+    public MemorySegment panama_identity_struct_confined_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3_v.invokeExact(identity_struct_3_addr, recycling_allocator, confinedPoint, confinedPoint, confinedPoint);\n@@ -74,2 +79,47 @@\n-    public int panama_identity_trivial() throws Throwable {\n-        return (int) identity_trivial_v.invokeExact(identity_addr, 10);\n+    public MemorySegment panama_identity_struct_shared_3() throws Throwable {\n+        return (MemorySegment) identity_struct_3_v.invokeExact(identity_struct_3_addr, recycling_allocator, sharedPoint, sharedPoint, sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address(), (Addressable)sharedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_memory_address_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_memory_address_3_addr, (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address(), (Addressable)confinedPoint.address());\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_struct_addr, (Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_shared_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)sharedPoint, (Addressable)sharedPoint, (Addressable)sharedPoint);\n+    }\n+\n+    @Benchmark\n+    public MemoryAddress panama_identity_struct_ref_confined_3() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_3_v.invokeExact(identity_struct_3_addr, (Addressable)confinedPoint, (Addressable)confinedPoint, (Addressable)confinedPoint);\n+    }\n+\n+    @Benchmark\n+    public int panama_identity() throws Throwable {\n+        return (int) identity_v.invokeExact(identity_addr, 10);\n@@ -84,2 +134,2 @@\n-    public MemoryAddress panama_identity_memory_address() throws Throwable {\n-        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, MemoryAddress.NULL);\n+    public MemoryAddress panama_identity_memory_address_null() throws Throwable {\n+        return (MemoryAddress) identity_memory_address_v.invokeExact(identity_memory_address_addr, (Addressable)MemoryAddress.NULL);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/CallOverheadVirtual.java","additions":60,"deletions":10,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+typedef struct {\n+    jclass holder;\n+    jmethodID mid;\n+} *JNICB;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.h","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+public class JNICB {\n+\n+    static {\n+        System.loadLibrary(\"JNICB\");\n+    }\n+\n+    public static native long makeCB(String holder, String name, String signature);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/JNICB.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -76,1 +76,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverConstant.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -64,1 +64,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -67,1 +67,1 @@\n-    final SegmentAllocator recyclingAlloc = SegmentAllocator.ofSegment(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n+    final SegmentAllocator recyclingAlloc = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(ALLOC_LAYOUT, scope));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNew.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import sun.misc.Unsafe;\n+\n+import java.lang.invoke.VarHandle;\n+import java.nio.IntBuffer;\n+import java.util.concurrent.TimeUnit;\n+\n+import static jdk.incubator.foreign.MemoryLayout.PathElement.sequenceElement;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+public class LoopOverNewHeap {\n+\n+    static final Unsafe unsafe = Utils.unsafe;\n+\n+    static final int ELEM_SIZE = 1_000_000;\n+    static final int CARRIER_SIZE = (int)JAVA_INT.byteSize();\n+\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n+\n+    @Param(value = {\"false\", \"true\"})\n+    boolean polluteProfile;\n+\n+    @Setup\n+    public void setup() {\n+        if (polluteProfile) {\n+            for (int i = 0 ; i < 10000 ; i++) {\n+                MemorySegment intB = MemorySegment.ofArray(new byte[ELEM_SIZE]);\n+                MemorySegment intI = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+                MemorySegment intD = MemorySegment.ofArray(new double[ELEM_SIZE]);\n+                MemorySegment intF = MemorySegment.ofArray(new float[ELEM_SIZE]);\n+            }\n+        }\n+    }\n+\n+    @Benchmark\n+    public void unsafe_loop() {\n+        int[] elems = new int[ELEM_SIZE];\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            unsafe.putInt(elems, Unsafe.ARRAY_INT_BASE_OFFSET + (i * CARRIER_SIZE) , i);\n+        }\n+    }\n+\n+\n+    @Benchmark\n+    public void segment_loop() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    @Benchmark\n+    public void segment_loop_dontinline() {\n+        MemorySegment segment = MemorySegment.ofArray(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            VH_int.set(segment, (long) i, i);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void buffer_loop() {\n+        IntBuffer buffer = IntBuffer.wrap(new int[ELEM_SIZE]);\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            buffer.put(i , i);\n+        }\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNewHeap.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.MemoryAccess;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -47,1 +47,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -54,1 +54,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n@@ -63,1 +63,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -120,4 +120,4 @@\n-    public int segment_loop_static() {\n-        int res = 0;\n-        for (int i = 0; i < ELEM_SIZE; i ++) {\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+    public int segment_loop() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += (int) VH_int.get(segment, (long) i);\n@@ -125,1 +125,1 @@\n-        return res;\n+        return sum;\n@@ -129,1 +129,1 @@\n-    public int segment_loop() {\n+    public int segment_loop_instance() {\n@@ -132,1 +132,30 @@\n-            sum += (int) VH_int.get(segment, (long) i);\n+            sum += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_index() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.getAtIndex(JAVA_INT, i);\n+\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return sum;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address_index() {\n+        int sum = 0;\n+        for (int i = 0; i < ELEM_SIZE; i++) {\n+            sum += segment.address().getAtIndex(JAVA_INT, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstant.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,1 +44,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n@@ -78,1 +77,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentIn, i, i);\n+            segmentIn.setAtIndex(JAVA_DOUBLE, i, i);\n@@ -81,1 +80,1 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i, i);\n+            segmentOut.setAtIndex(JAVA_DOUBLE, i, i);\n@@ -115,3 +114,3 @@\n-            MemoryAccess.setDoubleAtIndex(segmentOut, i,\n-                    MemoryAccess.getDoubleAtIndex(segmentIn, i) +\n-                    MemoryAccess.getDoubleAtIndex(segmentOut, i));\n+            segmentOut.setAtIndex(JAVA_DOUBLE, i,\n+                    segmentIn.getAtIndex(JAVA_DOUBLE, i) +\n+                    segmentOut.getAtIndex(JAVA_DOUBLE, i));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantFP.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -49,1 +48,4 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_DOUBLE;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -66,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -82,1 +84,1 @@\n-            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope(Cleaner.create()));\n+            MemorySegment s = MemorySegment.allocateNative(ALLOC_SIZE, 1, ResourceScope.newConfinedScope());\n@@ -84,5 +86,5 @@\n-                MemoryAccess.setByteAtOffset(intB, i, (byte)i);\n-                MemoryAccess.setIntAtIndex(intI, i, i);\n-                MemoryAccess.setDoubleAtIndex(intD, i, i);\n-                MemoryAccess.setFloatAtIndex(intF, i, i);\n-                MemoryAccess.setByteAtOffset(s, i, (byte) i);\n+                intB.set(JAVA_BYTE, i, (byte)i);\n+                intI.setAtIndex(JAVA_INT, i, i);\n+                intD.setAtIndex(JAVA_DOUBLE, i, i);\n+                intF.setAtIndex(JAVA_FLOAT, i, i);\n+                s.set(JAVA_BYTE, i, (byte) i);\n@@ -137,1 +139,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -140,1 +142,1 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantHeap.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -54,1 +53,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -61,1 +60,1 @@\n-@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\" })\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n@@ -84,1 +83,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -146,1 +145,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -149,1 +148,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.address().get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantMapped.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -47,1 +46,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -63,1 +62,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -75,1 +74,1 @@\n-        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newSharedScope());\n+        segment = MemorySegment.allocateNative(ALLOC_SIZE, CARRIER_SIZE, ResourceScope.newConfinedScope());\n@@ -120,1 +119,1 @@\n-    public int segment_loop_static() {\n+    public int segment_loop_instance() {\n@@ -123,1 +122,10 @@\n-            res += MemoryAccess.getIntAtIndex(segment, i);\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n+        }\n+        return res;\n+    }\n+\n+    @Benchmark\n+    public int segment_loop_instance_address() {\n+        int res = 0;\n+        for (int i = 0; i < ELEM_SIZE; i ++) {\n+            res += segment.get(JAVA_INT, i * CARRIER_SIZE);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverNonConstantShared.java","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedBuffer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -45,1 +44,2 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_FLOAT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -65,1 +65,1 @@\n-    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle intHandle = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -82,2 +82,2 @@\n-                MemoryAccess.setIntAtIndex(nativeSegment, i, i);\n-                MemoryAccess.setFloatAtIndex(nativeSegment, i, i);\n+                nativeSegment.setAtIndex(JAVA_INT, i, i);\n+                nativeSegment.setAtIndex(JAVA_FLOAT, i, i);\n@@ -85,2 +85,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentBytes, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentBytes, i, i);\n+                heapSegmentBytes.setAtIndex(JAVA_INT, i, i);\n+                heapSegmentBytes.setAtIndex(JAVA_FLOAT, i, i);\n@@ -88,2 +88,2 @@\n-                MemoryAccess.setIntAtIndex(heapSegmentFloats, i, i);\n-                MemoryAccess.setFloatAtIndex(heapSegmentFloats, i, i);\n+                heapSegmentFloats.setAtIndex(JAVA_INT, i, i);\n+                heapSegmentFloats.setAtIndex(JAVA_FLOAT, i, i);\n@@ -116,1 +116,1 @@\n-    public int native_segment_static() {\n+    public int native_segment_instance() {\n@@ -119,2 +119,2 @@\n-            MemoryAccess.setIntAtOffset(nativeSegment, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(nativeSegment, k);\n+            nativeSegment.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = nativeSegment.getAtIndex(JAVA_INT, k);\n@@ -138,1 +138,1 @@\n-    public int heap_segment_ints_static() {\n+    public int heap_segment_ints_instance() {\n@@ -141,2 +141,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentBytes, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentBytes, k);\n+            heapSegmentBytes.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = heapSegmentBytes.getAtIndex(JAVA_INT, k);\n@@ -160,1 +160,1 @@\n-    public int heap_segment_floats_static() {\n+    public int heap_segment_floats_instance() {\n@@ -163,2 +163,2 @@\n-            MemoryAccess.setIntAtOffset(heapSegmentFloats, k, k + 1);\n-            int v = MemoryAccess.getIntAtOffset(heapSegmentFloats, k);\n+            heapSegmentFloats.setAtIndex(JAVA_INT, k, k + 1);\n+            int v = heapSegmentFloats.getAtIndex(JAVA_INT, k);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/LoopOverPollutedSegments.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -30,0 +29,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -55,1 +55,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -68,1 +68,1 @@\n-    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(int.class, sequenceElement());\n+    static final VarHandle VH_int = MemoryLayout.sequenceLayout(JAVA_INT).varHandle(sequenceElement());\n@@ -70,1 +70,1 @@\n-    final static MemoryLayout ELEM_LAYOUT = MemoryLayouts.JAVA_INT;\n+    final static MemoryLayout ELEM_LAYOUT = ValueLayout.JAVA_INT;\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/ParallelSum.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.jdk.incubator.foreign;\n+\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.MemoryLayout;\n+import jdk.incubator.foreign.MemorySegment;\n+import jdk.incubator.foreign.NativeSymbol;\n+import jdk.incubator.foreign.ResourceScope;\n+import jdk.incubator.foreign.SymbolLookup;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.lang.invoke.MethodHandles.lookup;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = { \"--add-modules=jdk.incubator.foreign\", \"--enable-native-access=ALL-UNNAMED\" })\n+public class QSort extends CLayouts {\n+\n+    static final CLinker abi = CLinker.systemCLinker();\n+    static final MethodHandle clib_qsort;\n+    static final NativeSymbol native_compar;\n+    static final NativeSymbol panama_upcall_compar;\n+    static final long jni_upcall_compar;\n+\n+    static final int[] INPUT = { 5, 3, 2, 7, 8, 12, 1, 7 };\n+    static final MemorySegment INPUT_SEGMENT;\n+\n+    static NativeSymbol qsort_addr = abi.lookup(\"qsort\").get();\n+\n+    static {\n+        INPUT_SEGMENT = MemorySegment.allocateNative(MemoryLayout.sequenceLayout(INPUT.length, JAVA_INT), ResourceScope.globalScope());\n+        INPUT_SEGMENT.copyFrom(MemorySegment.ofArray(INPUT));\n+\n+        System.loadLibrary(\"QSortJNI\");\n+        jni_upcall_compar = JNICB.makeCB(\"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\", \"jni_upcall_compar\", \"(II)I\");\n+\n+        try {\n+            clib_qsort = abi.downcallHandle(\n+                    qsort_addr,\n+                    FunctionDescriptor.ofVoid(C_POINTER, C_LONG_LONG, C_LONG_LONG, C_POINTER)\n+            );\n+            System.loadLibrary(\"QSort\");\n+            native_compar = SymbolLookup.loaderLookup().lookup(\"compar\").orElseThrow();\n+            panama_upcall_compar = abi.upcallStub(\n+                    lookup().findStatic(QSort.class,\n+                            \"panama_upcall_compar\",\n+                            MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class)),\n+                    FunctionDescriptor.of(C_INT, C_POINTER, C_POINTER),\n+                    ResourceScope.globalScope()\n+            );\n+        } catch (ReflectiveOperationException e) {\n+            throw new BootstrapMethodError(e);\n+        }\n+    }\n+\n+    static native void jni_qsort_optimized(int[] array, long cb);\n+    static native void jni_qsort_naive(int[] array);\n+\n+    @FunctionalInterface\n+    interface JNIComparator {\n+        int cmp(int e0, int e1);\n+    }\n+\n+    static final JNIComparator COMP = QSort::jni_upcall_compar;\n+\n+    @Benchmark\n+    public void native_qsort() throws Throwable {\n+         clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)native_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_optimized() {\n+        jni_qsort_optimized(INPUT, jni_upcall_compar);\n+    }\n+\n+    @Benchmark\n+    public void jni_upcall_qsort_naive() {\n+        jni_qsort_naive(INPUT);\n+    }\n+\n+    @Benchmark\n+    public void panama_upcall_qsort() throws Throwable {\n+        clib_qsort.invokeExact((Addressable)INPUT_SEGMENT, (long) INPUT.length, JAVA_INT.byteSize(), (Addressable)panama_upcall_compar);\n+    }\n+\n+    private static int getIntAbsolute(MemoryAddress addr) {\n+        return addr.get(JAVA_INT, 0);\n+    }\n+\n+    static int panama_upcall_compar(MemoryAddress e0, MemoryAddress e1) {\n+        return Integer.compare(getIntAbsolute(e0), getIntAbsolute(e1));\n+    }\n+\n+    static int jni_upcall_compar(int j0, int j1) {\n+        return Integer.compare(j0, j1);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.incubator.foreign.Addressable;\n@@ -30,1 +31,0 @@\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -48,1 +48,0 @@\n-import java.lang.invoke.MethodType;\n@@ -51,1 +50,1 @@\n-import static jdk.incubator.foreign.CLinker.*;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n@@ -59,1 +58,1 @@\n-public class StrLenTest {\n+public class StrLenTest extends CLayouts {\n@@ -61,1 +60,1 @@\n-    ResourceScope scope = ResourceScope.newConfinedScope();\n+    ResourceScope scope = ResourceScope.newImplicitScope();\n@@ -64,1 +63,1 @@\n-    SegmentAllocator arenaAllocator = SegmentAllocator.arenaAllocator(scope);\n+    SegmentAllocator arenaAllocator = SegmentAllocator.newNativeArena(scope);\n@@ -75,3 +74,0 @@\n-    static final MethodHandle STRLEN_TRIVIAL;\n-    static final MethodHandle MALLOC_TRIVIAL;\n-    static final MethodHandle FREE_TRIVIAL;\n@@ -80,3 +76,2 @@\n-        CLinker abi = CLinker.getInstance();\n-        STRLEN = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n+        CLinker abi = CLinker.systemCLinker();\n+        STRLEN = abi.downcallHandle(abi.lookup(\"strlen\").get(),\n@@ -84,10 +79,0 @@\n-        STRLEN_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"strlen\").get(),\n-                MethodType.methodType(int.class, MemoryAddress.class),\n-                FunctionDescriptor.of(C_INT, C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-        MALLOC_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"malloc\").get(),\n-                MethodType.methodType(MemoryAddress.class, long.class),\n-                FunctionDescriptor.of(C_POINTER, C_LONG_LONG).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n-\n-        FREE_TRIVIAL = abi.downcallHandle(CLinker.systemLookup().lookup(\"free\").get(),\n-                MethodType.methodType(void.class, MemoryAddress.class),\n-                FunctionDescriptor.ofVoid(C_POINTER).withAttribute(FunctionDescriptor.TRIVIAL_ATTRIBUTE_NAME, true));\n@@ -99,1 +84,1 @@\n-        segmentAllocator = SegmentAllocator.ofSegment(MemorySegment.allocateNative(size + 1, ResourceScope.newImplicitScope()));\n+        segmentAllocator = SegmentAllocator.prefixAllocator(MemorySegment.allocateNative(size + 1, ResourceScope.newConfinedScope()));\n@@ -115,2 +100,3 @@\n-            MemorySegment segment = CLinker.toCString(str, scope);\n-            return (int)STRLEN.invokeExact(segment.address());\n+            MemorySegment segment = MemorySegment.allocateNative(str.length() + 1, scope);\n+            segment.setUtf8String(0, str);\n+            return (int)STRLEN.invokeExact((Addressable)segment);\n@@ -122,1 +108,1 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, arenaAllocator).address());\n+        return (int)STRLEN.invokeExact((Addressable)arenaAllocator.allocateUtf8String(str));\n@@ -127,1 +113,1 @@\n-        return (int)STRLEN.invokeExact(CLinker.toCString(str, segmentAllocator).address());\n+        return (int)STRLEN.invokeExact((Addressable)segmentAllocator.allocateUtf8String(str));\n@@ -133,10 +119,2 @@\n-        int res = (int) STRLEN.invokeExact(address);\n-        CLinker.freeMemory(address);\n-        return res;\n-    }\n-\n-    @Benchmark\n-    public int panama_strlen_unsafe_trivial() throws Throwable {\n-        MemoryAddress address = makeStringUnsafeTrivial(str);\n-        int res = (int) STRLEN_TRIVIAL.invokeExact(address);\n-        FREE_TRIVIAL.invokeExact(address);\n+        int res = (int) STRLEN.invokeExact((Addressable)address);\n+        freeMemory(address);\n@@ -149,12 +127,2 @@\n-        MemoryAddress address = CLinker.allocateMemory(len + 1);\n-        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n-        str.copyFrom(MemorySegment.ofArray(bytes));\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n-        return address;\n-    }\n-\n-    static MemoryAddress makeStringUnsafeTrivial(String s) throws Throwable {\n-        byte[] bytes = s.getBytes();\n-        int len = bytes.length;\n-        MemoryAddress address = (MemoryAddress)MALLOC_TRIVIAL.invokeExact((long)len + 1);\n-        MemorySegment str = address.asSegment(len + 1, ResourceScope.globalScope());\n+        MemoryAddress address = allocateMemory(len + 1);\n+        MemorySegment str = MemorySegment.ofAddressNative(address, len + 1, ResourceScope.globalScope());\n@@ -162,1 +130,1 @@\n-        MemoryAccess.setByteAtOffset(str, len, (byte)0);\n+        str.set(JAVA_BYTE, len, (byte)0);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/StrLenTest.java","additions":18,"deletions":50,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.incubator.foreign.MemoryLayouts;\n@@ -31,0 +30,1 @@\n+import jdk.incubator.foreign.ValueLayout;\n@@ -88,2 +88,2 @@\n-    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(MemoryLayouts.JAVA_INT)\n-            .varHandle(int.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle VH_addr_int = MemoryLayout.sequenceLayout(ValueLayout.JAVA_INT)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestAdaptVarHandles.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n-import jdk.incubator.foreign.MemoryAddress;\n@@ -31,3 +28,0 @@\n-import jdk.incubator.vector.ByteVector;\n-import jdk.incubator.vector.IntVector;\n-import jdk.incubator.vector.VectorSpecies;\n@@ -47,1 +41,0 @@\n-import java.nio.ByteOrder;\n@@ -50,0 +43,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -122,1 +117,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n@@ -132,1 +127,1 @@\n-            var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n+            var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/TestLoadBytes.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import static jdk.incubator.foreign.MemoryAccess.*;\n@@ -37,0 +36,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_LONG;\n+\n@@ -42,1 +43,1 @@\n-@Fork(3)\n+@Fork(value = 3, jvmArgsAppend = { \"--enable-native-access=ALL-UNNAMED\" })\n@@ -49,2 +50,2 @@\n-    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, MemoryLayouts.JAVA_LONG)\n-            .varHandle(long.class, MemoryLayout.PathElement.sequenceElement());\n+    static final VarHandle LONG_HANDLE = MemoryLayout.sequenceLayout(SIZE, JAVA_LONG)\n+            .varHandle(MemoryLayout.PathElement.sequenceElement());\n@@ -68,2 +69,2 @@\n-            this.inputSegment = MemoryAddress.ofLong(inputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n-            this.outputSegment = MemoryAddress.ofLong(outputAddress).asSegment(8*SIZE, ResourceScope.globalScope());\n+            this.inputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(inputAddress), 8*SIZE, ResourceScope.globalScope());\n+            this.outputSegment = MemorySegment.ofAddressNative(MemoryAddress.ofLong(outputAddress), 8*SIZE, ResourceScope.globalScope());\n@@ -99,1 +100,1 @@\n-    public void static_handle_loop(Data state) {\n+    public void handle_loop_instance(Data state) {\n@@ -104,4 +105,4 @@\n-            setLongAtIndex(os, i,getLongAtIndex(is, i) + MemoryAccess.getLongAtIndex(os, i));\n-            setLongAtIndex(os, i+1,getLongAtIndex(is, i+1) + getLongAtIndex(os, i+1));\n-            setLongAtIndex(os, i+2,getLongAtIndex(is, i+2) + getLongAtIndex(os, i+2));\n-            setLongAtIndex(os, i+3,getLongAtIndex(is, i+3) + getLongAtIndex(os, i+3));\n+            os.setAtIndex(JAVA_LONG, i, is.getAtIndex(JAVA_LONG, i) + os.get(JAVA_LONG, i));\n+            os.setAtIndex(JAVA_LONG, i+1, is.getAtIndex(JAVA_LONG, i+1) + os.get(JAVA_LONG, i+1));\n+            os.setAtIndex(JAVA_LONG, i+2, is.getAtIndex(JAVA_LONG, i+2) + os.get(JAVA_LONG, i+2));\n+            os.setAtIndex(JAVA_LONG, i+3, is.getAtIndex(JAVA_LONG, i+3) + os.get(JAVA_LONG, i+3));\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/UnrolledAccess.java","additions":13,"deletions":12,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n-import jdk.incubator.foreign.MemoryAddress;\n+import jdk.incubator.foreign.Addressable;\n@@ -28,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.NativeSymbol;\n@@ -44,4 +45,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_POINTER;\n@@ -55,1 +52,1 @@\n-public class Upcalls {\n+public class Upcalls extends CLayouts {\n@@ -57,1 +54,1 @@\n-    static final CLinker abi = CLinker.getInstance();\n+    static final CLinker abi = CLinker.systemCLinker();\n@@ -63,4 +60,4 @@\n-    static final MemoryAddress cb_blank;\n-    static final MemoryAddress cb_identity;\n-    static final MemoryAddress cb_args5;\n-    static final MemoryAddress cb_args10;\n+    static final NativeSymbol cb_blank;\n+    static final NativeSymbol cb_identity;\n+    static final NativeSymbol cb_args5;\n+    static final NativeSymbol cb_args10;\n@@ -77,4 +74,4 @@\n-        cb_blank_jni = makeCB(className, \"blank\", \"()V\");\n-        cb_identity_jni = makeCB(className, \"identity\", \"(I)I\");\n-        cb_args5_jni = makeCB(className, \"args5\", \"(JDJDJ)V\");\n-        cb_args10_jni = makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n+        cb_blank_jni = JNICB.makeCB(className, \"blank\", \"()V\");\n+        cb_identity_jni = JNICB.makeCB(className, \"identity\", \"(I)I\");\n+        cb_args5_jni = JNICB.makeCB(className, \"args5\", \"(JDJDJ)V\");\n+        cb_args10_jni = JNICB.makeCB(className, \"args10\", \"(JDJDJDJDJD)V\");\n@@ -89,1 +86,1 @@\n-                blank = linkFunc(name, mt, fd);\n+                blank = linkFunc(name, fd);\n@@ -97,1 +94,1 @@\n-                identity = linkFunc(name, mt, fd);\n+                identity = linkFunc(name, fd);\n@@ -107,1 +104,1 @@\n-                args5 = linkFunc(name, mt, fd);\n+                args5 = linkFunc(name, fd);\n@@ -119,1 +116,1 @@\n-                args10 = linkFunc(name, mt, fd);\n+                args10 = linkFunc(name, fd);\n@@ -127,1 +124,1 @@\n-    static MethodHandle linkFunc(String name, MethodType baseType, FunctionDescriptor baseDesc) {\n+    static MethodHandle linkFunc(String name, FunctionDescriptor baseDesc) {\n@@ -130,2 +127,1 @@\n-            baseType.insertParameterTypes(baseType.parameterCount(), MemoryAddress.class),\n-            baseDesc.withAppendedArgumentLayouts(C_POINTER)\n+                baseDesc.withAppendedArgumentLayouts(C_POINTER)\n@@ -135,1 +131,1 @@\n-    static MemoryAddress makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n+    static NativeSymbol makeCB(String name, MethodType mt, FunctionDescriptor fd) throws ReflectiveOperationException {\n@@ -139,1 +135,1 @@\n-        ).address();\n+        );\n@@ -147,1 +143,0 @@\n-    static native long makeCB(String holder, String name, String signature);\n@@ -156,1 +151,1 @@\n-        blank.invokeExact(cb_blank);\n+        blank.invokeExact((Addressable)cb_blank);\n@@ -176,1 +171,1 @@\n-        return (int) identity.invokeExact(10, cb_identity);\n+        return (int) identity.invokeExact(10, (Addressable)cb_identity);\n@@ -181,1 +176,1 @@\n-        args5.invokeExact(1L, 2D, 3L, 4D, 5L, cb_args5);\n+        args5.invokeExact(1L, 2D, 3L, 4D, 5L, (Addressable)cb_args5);\n@@ -186,1 +181,1 @@\n-        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, cb_args10);\n+        args10.invokeExact(1L, 2D, 3L, 4D, 5L, 6D, 7L, 8D, 9L, 10D, (Addressable)cb_args10);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/Upcalls.java","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.Addressable;\n@@ -27,0 +27,2 @@\n+import jdk.incubator.foreign.FunctionDescriptor;\n+import jdk.incubator.foreign.MemoryAddress;\n@@ -39,1 +41,0 @@\n-import java.lang.invoke.MethodType;\n@@ -42,6 +43,0 @@\n-import static jdk.incubator.foreign.CLinker.C_DOUBLE;\n-import static jdk.incubator.foreign.CLinker.C_INT;\n-import static jdk.incubator.foreign.CLinker.C_LONG_LONG;\n-import static jdk.incubator.foreign.CLinker.C_VA_LIST;\n-import static jdk.incubator.foreign.CLinker.asVarArg;\n-\n@@ -54,1 +49,1 @@\n-public class VaList {\n+public class VaList extends CLayouts {\n@@ -56,1 +51,1 @@\n-    static final CLinker linker = CLinker.getInstance();\n+    static final CLinker linker = CLinker.systemCLinker();\n@@ -67,2 +62,1 @@\n-                MethodType.methodType(void.class, int.class, int.class, double.class, long.class),\n-                FunctionDescriptor.ofVoid(C_INT, asVarArg(C_INT), asVarArg(C_DOUBLE), asVarArg(C_LONG_LONG)));\n+                FunctionDescriptor.ofVoid(C_INT).asVariadic(C_INT, C_DOUBLE, C_LONG_LONG));\n@@ -70,2 +64,1 @@\n-                MethodType.methodType(void.class, int.class, CLinker.VaList.class),\n-                FunctionDescriptor.ofVoid(C_INT, C_VA_LIST));\n+                FunctionDescriptor.ofVoid(C_INT, C_POINTER));\n@@ -83,4 +76,4 @@\n-            CLinker.VaList vaList = CLinker.VaList.make(b ->\n-                    b.vargFromInt(C_INT, 1)\n-                            .vargFromDouble(C_DOUBLE, 2D)\n-                            .vargFromLong(C_LONG_LONG, 3L), scope);\n+            jdk.incubator.foreign.VaList vaList = jdk.incubator.foreign.VaList.make(b ->\n+                    b.addVarg(C_INT, 1)\n+                            .addVarg(C_DOUBLE, 2D)\n+                            .addVarg(C_LONG_LONG, 3L), scope);\n@@ -88,1 +81,1 @@\n-                    vaList);\n+                    (Addressable)vaList);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VaList.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-import static jdk.incubator.foreign.MemoryLayouts.JAVA_INT;\n+import static jdk.incubator.foreign.ValueLayout.JAVA_INT;\n@@ -57,1 +57,1 @@\n-        generic = MemoryHandles.varHandle(int.class, ByteOrder.nativeOrder());\n+        generic = MemoryHandles.varHandle(JAVA_INT);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/VarHandleExact.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-    long long x;\n-    long long y;\n+    int x;\n+    int y;\n@@ -45,0 +45,4 @@\n+EXPORT Point identity_struct_3(Point p1, Point p2, Point p3) {\n+    return p1;\n+}\n+\n@@ -49,0 +53,4 @@\n+EXPORT void* identity_memory_address_3(void* p1, void* p2, void* p3) {\n+    return p1;\n+}\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libCallOverhead.c","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+#include <stdlib.h>\n+\n+#include \"JNICB.h\"\n+#include \"jlong.h\"\n+\n+#define CHECK_NULL(thing, message) \\\n+    if (thing == NULL) { \\\n+        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n+        (*env)->ThrowNew(env, cls, message); \\\n+        return 0; \\\n+    }\n+\n+JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_JNICB_makeCB\n+  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n+\n+  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n+  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n+  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n+\n+  JNICB cb = malloc(sizeof *cb);\n+  CHECK_NULL(cb, \"Can not allocate cb\");\n+\n+  jclass holder = (*env)->FindClass(env, holderNameC);\n+  CHECK_NULL(holder, \"Can not find class\");\n+  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n+  cb->holder = holder;\n+\n+  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n+  CHECK_NULL(methodID, \"Can not find method\");\n+  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n+  cb->mid = methodID;\n+\n+  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n+  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n+  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n+\n+  return ptr_to_jlong(cb);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libJNICB.c","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifdef _WIN64\n+#define EXPORT __declspec(dllexport)\n+#else\n+#define EXPORT\n+#endif\n+\n+\n+EXPORT int compar(const void* e0, const void* e1) {\n+    int i0 = *((int*) e0);\n+    int i1 = *((int*) e1);\n+    return i0 - i1;\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSort.c","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <stdlib.h>\n+\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n+\n+#ifdef _WIN64\n+#define THREAD_LOCAL __declspec(thread)\n+#else\n+#define THREAD_LOCAL __thread\n+#endif\n+\n+THREAD_LOCAL struct {\n+  JNICB cb;\n+  JNIEnv* env;\n+} ctx_opt;\n+\n+static int comparator(const void* e0, const void* e1) {\n+    JNICB jniCb = ctx_opt.cb;\n+    JNIEnv* env = ctx_opt.env;\n+    jint j0 = *((jint*) e0);\n+    jint j1 = *((jint*) e1);\n+    return (*env)->CallStaticIntMethod(env, jniCb->holder, jniCb->mid, j0, j1);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1optimized\n+        (JNIEnv *env, jclass cls, jintArray arr, jlong cb) {\n+\n+    ctx_opt.cb = jlong_to_ptr(cb);\n+    ctx_opt.env = env;\n+\n+    jint* ints = (*env)->GetIntArrayElements(env, arr, NULL);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+\n+    qsort(ints, length, sizeof(jint), &comparator);\n+\n+    (*env)->ReleaseIntArrayElements(env, arr, ints, 0);\n+}\n+\n+JavaVM* VM = NULL;\n+\n+int java_cmp(const void *a, const void *b) {\n+   int v1 = *((int*)a);\n+   int v2 = *((int*)b);\n+\n+   JNIEnv* env;\n+   (*VM)->GetEnv(VM, (void**) &env, JNI_VERSION_10);\n+\n+   jclass qsortClass = (*env)->FindClass(env, \"org\/openjdk\/bench\/jdk\/incubator\/foreign\/QSort\");\n+   jmethodID methodId = (*env)->GetStaticMethodID(env, qsortClass, \"jni_upcall_compar\", \"(II)I\");\n+\n+   return (*env)->CallStaticIntMethod(env, qsortClass, methodId, v1, v2);\n+}\n+\n+JNIEXPORT void JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_QSort_jni_1qsort_1naive\n+        (JNIEnv *env, jclass cls, jintArray arr) {\n+    if (VM == NULL) {\n+        (*env)->GetJavaVM(env, &VM);\n+    }\n+\n+    jint* carr = (*env)->GetIntArrayElements(env, arr, 0);\n+    jsize length = (*env)->GetArrayLength(env, arr);\n+    qsort(carr, length, sizeof(jint), java_cmp);\n+    (*env)->ReleaseIntArrayElements(env, arr, carr, 0);\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libQSortJNI.c","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -25,20 +25,0 @@\n-#include \"jlong.h\"\n-\n-typedef struct {\n-    jclass holder;\n-    jmethodID mid;\n-} *JNICB;\n-\n-#define CHECK_NULL(thing, message) \\\n-    if (thing == NULL) { \\\n-        jclass cls = (*env)->FindClass(env, \"java\/lang\/Exception\"); \\\n-        (*env)->ThrowNew(env, cls, message); \\\n-        return 0; \\\n-    }\n-\n-JNIEXPORT jlong JNICALL Java_org_openjdk_bench_jdk_incubator_foreign_Upcalls_makeCB\n-  (JNIEnv *env, jclass cls, jstring holderName, jstring methodName, jstring descriptor) {\n-\n-  const char* holderNameC = (*env)->GetStringUTFChars(env, holderName, NULL);\n-  const char* methodNameC = (*env)->GetStringUTFChars(env, methodName, NULL);\n-  const char* descriptorC = (*env)->GetStringUTFChars(env, descriptor, NULL);\n@@ -46,19 +26,2 @@\n-  JNICB cb = malloc(sizeof *cb);\n-  CHECK_NULL(cb, \"Can not allocate cb\");\n-\n-  jclass holder = (*env)->FindClass(env, holderNameC);\n-  CHECK_NULL(holder, \"Can not find class\");\n-  holder = (jclass) (*env)->NewGlobalRef(env, holder);\n-  cb->holder = holder;\n-\n-  jmethodID methodID = (*env)->GetStaticMethodID(env, holder, methodNameC, descriptorC);\n-  CHECK_NULL(methodID, \"Can not find method\");\n-  \/\/methodID = (jmethodID) (*env)->NewGlobalRef(env, methodID); \/\/ DON'T DO THIS! -> Crashes GC\n-  cb->mid = methodID;\n-\n-  (*env)->ReleaseStringUTFChars(env, holderName, holderNameC);\n-  (*env)->ReleaseStringUTFChars(env, methodName, methodNameC);\n-  (*env)->ReleaseStringUTFChars(env, descriptor, descriptorC);\n-\n-  return ptr_to_jlong(cb);\n-}\n+#include \"jlong.h\"\n+#include \"JNICB.h\"\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/libUpcallsJNI.c","additions":2,"deletions":39,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import jdk.incubator.foreign.Addressable;\n+import jdk.incubator.foreign.CLinker;\n@@ -26,1 +28,0 @@\n-import jdk.incubator.foreign.SymbolLookup;\n@@ -28,0 +29,1 @@\n+import jdk.incubator.foreign.SymbolLookup;\n@@ -30,1 +32,0 @@\n-import jdk.incubator.foreign.CLinker;\n@@ -32,0 +33,1 @@\n+import org.openjdk.bench.jdk.incubator.foreign.CLayouts;\n@@ -38,1 +40,0 @@\n-import static jdk.incubator.foreign.CLinker.*;\n@@ -40,1 +41,1 @@\n-public class PanamaPoint implements AutoCloseable {\n+public class PanamaPoint extends CLayouts implements AutoCloseable {\n@@ -47,2 +48,2 @@\n-    private static final VarHandle VH_x = LAYOUT.varHandle(int.class, groupElement(\"x\"));\n-    private static final VarHandle VH_y = LAYOUT.varHandle(int.class, groupElement(\"y\"));\n+    private static final VarHandle VH_x = LAYOUT.varHandle(groupElement(\"x\"));\n+    private static final VarHandle VH_y = LAYOUT.varHandle(groupElement(\"y\"));\n@@ -53,1 +54,1 @@\n-        CLinker abi = CLinker.getInstance();\n+        CLinker abi = CLinker.systemCLinker();\n@@ -58,2 +59,1 @@\n-            methodType(double.class, MemorySegment.class, MemorySegment.class),\n-            FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n+                FunctionDescriptor.of(C_DOUBLE, LAYOUT, LAYOUT)\n@@ -62,3 +62,2 @@\n-            lookup.lookup(\"distance_ptrs\").get(),\n-            methodType(double.class, MemoryAddress.class, MemoryAddress.class),\n-            FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n+                lookup.lookup(\"distance_ptrs\").get(),\n+                FunctionDescriptor.of(C_DOUBLE, C_POINTER, C_POINTER)\n@@ -110,1 +109,1 @@\n-            return (double) MH_distance_ptrs.invokeExact(segment.address(), other.segment.address());\n+            return (double) MH_distance_ptrs.invokeExact((Addressable)segment, (Addressable)other.segment);\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/foreign\/points\/support\/PanamaPoint.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -29,2 +29,0 @@\n-import jdk.incubator.foreign.CLinker;\n-import jdk.incubator.foreign.MemoryAccess;\n@@ -49,0 +47,2 @@\n+import static jdk.incubator.foreign.ValueLayout.JAVA_BYTE;\n+\n@@ -119,2 +119,2 @@\n-    srcAddress = CLinker.allocateMemory(size);\n-    dstAddress = CLinker.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -235,2 +235,2 @@\n-      var v = MemoryAccess.getByteAtOffset(srcSegmentImplicit, i);\n-      MemoryAccess.setByteAtOffset(dstSegmentImplicit, i, v);\n+      var v = srcSegmentImplicit.get(JAVA_BYTE, i);\n+      dstSegmentImplicit.set(JAVA_BYTE, i, v);\n@@ -243,2 +243,2 @@\n-      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreBytes.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-import jdk.incubator.foreign.CLinker;\n+\n@@ -115,1 +115,1 @@\n-    implicitScope = ResourceScope.newImplicitScope();\n+    implicitScope = ResourceScope.newSharedScope();\n@@ -122,2 +122,2 @@\n-    srcAddress = CLinker.allocateMemory(size);\n-    dstAddress = CLinker.allocateMemory(size);\n+    srcAddress = MemorySegment.allocateNative(size, implicitScope).address();\n+    dstAddress = MemorySegment.allocateNative(size, implicitScope).address();\n@@ -133,6 +133,0 @@\n-  @TearDown\n-  public void tearDown() {\n-    CLinker.freeMemory(srcAddress);\n-    CLinker.freeMemory(dstAddress);\n-  }\n-\n@@ -219,2 +213,2 @@\n-      final var srcBufferSegmentConfined = srcAddress.asSegment(size, scope).asByteBuffer();\n-      final var dstBufferSegmentConfined = dstAddress.asSegment(size, scope).asByteBuffer();\n+      final var srcBufferSegmentConfined = MemorySegment.ofAddressNative(srcAddress, size, scope).asByteBuffer();\n+      final var dstBufferSegmentConfined = MemorySegment.ofAddressNative(dstAddress, size, scope).asByteBuffer();\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/TestLoadStoreShort.java","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"}]}