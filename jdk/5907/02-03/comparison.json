{"files":[{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2020, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-    private final MemoryLayout[] argLayouts;\n+    private final List<MemoryLayout> argLayouts;\n@@ -51,1 +51,1 @@\n-    private FunctionDescriptor(MemoryLayout resLayout, MemoryLayout... argLayouts) {\n+    private FunctionDescriptor(MemoryLayout resLayout, List<MemoryLayout> argLayouts) {\n@@ -69,1 +69,1 @@\n-        return Arrays.asList(argLayouts);\n+        return argLayouts;\n@@ -82,1 +82,1 @@\n-        return new FunctionDescriptor(resLayout, argLayouts);\n+        return new FunctionDescriptor(resLayout, List.of(argLayouts));\n@@ -93,1 +93,1 @@\n-        return new FunctionDescriptor(null, argLayouts);\n+        return new FunctionDescriptor(null, List.of(argLayouts));\n@@ -129,2 +129,1 @@\n-        MemoryLayout[] newLayouts = Arrays.copyOf(argLayouts, argLayouts.length + addedLayouts.length);\n-        System.arraycopy(addedLayouts, 0, newLayouts, argLayouts.length, addedLayouts.length);\n+        List<MemoryLayout> newLayouts = Stream.concat(argLayouts.stream(), Stream.of(addedLayouts)).toList();\n@@ -184,1 +183,1 @@\n-        return Objects.equals(resLayout, f.resLayout) && Arrays.equals(argLayouts, f.argLayouts);\n+        return Objects.equals(resLayout, f.resLayout) && Objects.equals(argLayouts, f.argLayouts);\n@@ -193,1 +192,1 @@\n-        int hashCode = Arrays.hashCode(argLayouts);\n+        int hashCode = Objects.hashCode(argLayouts);\n@@ -197,0 +196,8 @@\n+    \/**\n+     * Returns an {@link Optional} containing the nominal descriptor for this\n+     * function descriptor, if one can be constructed, or an empty {@link Optional}\n+     * if one cannot be constructed.\n+     *\n+     * @return An {@link Optional} containing the resulting nominal descriptor,\n+     * or an empty {@link Optional} if one cannot be constructed.\n+     *\/\n@@ -217,1 +224,1 @@\n-                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toArray(MemoryLayout[]::new));\n+                    Stream.concat(descriptor.argumentLayouts().stream(), Stream.of(argLayouts)).toList());\n@@ -221,4 +228,1 @@\n-        public boolean isVariadicIndex(int pos) {\n-            return pos >= firstVariadicIndex;\n-        }\n-\n+        @Override\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/FunctionDescriptor.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -327,2 +327,2 @@\n-     * <p>Two segments S1 and S2 are said to overlap if it is possible to find\n-     * at least two slices L1 (from S1) and L2 (from S2) that are backed by the\n+     * <p>Two segments {@code S1} and {@code S2} are said to overlap if it is possible to find\n+     * at least two slices {@code L1} (from {@code S1}) and {@code L2} (from {@code S2}) that are backed by the\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/MemorySegment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -389,4 +389,0 @@\n-     * An allocator associated with a <em>shared<\/em> resource scope is thread-safe and allocation requests may be\n-     * performed concurrently; conversely, if the arena allocator is associated with a <em>confined<\/em> resource scope,\n-     * allocation requests can only occur from the thread owning the allocator's resource scope.\n-     * <p>\n@@ -394,2 +390,2 @@\n-     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe, and all\n-     * allocation requests should occur within a single thread (regardless of the scope associated with the native arena).\n+     * exceeds the arena size, or the system capacity. Furthermore, the returned allocator is not thread safe.\n+     * Concurrent allocation needs to be guarded with synchronization primitives.\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/SegmentAllocator.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -97,4 +97,1 @@\n-            int value;\n-            do {\n-                value = (int)ASYNC_RELEASE_COUNT.getVolatile(this);\n-            } while (!ASYNC_RELEASE_COUNT.compareAndSet(this, value, value + 1));\n+            ASYNC_RELEASE_COUNT.getAndAdd(this, 1);\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/internal\/foreign\/ConfinedScope.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"}]}