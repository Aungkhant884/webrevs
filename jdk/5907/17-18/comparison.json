{"files":[{"patch":"@@ -55,5 +55,4 @@\n- * Inside a loop, we then initialize the contents of the memory segment using the\n- * {@link jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int)} dereference method. Note how\n- * the dereference method accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout},\n- * which specifies the size, alignment constraints, byte order as well\n- * as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n+ * Inside a loop, we then initialize the contents of the memory segment; note how the\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#setAtIndex(ValueLayout.OfInt, long, int) dereference method}\n+ * accepts a {@linkplain jdk.incubator.foreign.ValueLayout value layout}, which specifies the size, alignment constraints,\n+ * byte order as well as the Java type ({@code int}, in this case) associated with the dereference operation. More specifically,\n@@ -135,3 +134,3 @@\n- * interacting with native code, such as converting Java strings into native strings and back\n- * (see {@link jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String)} and\n- * {@link jdk.incubator.foreign.MemorySegment#getUtf8String(long)}, respectively), as demonstrated in the above example.\n+ * interacting with native code, such as converting Java strings\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#setUtf8String(long, java.lang.String) into} native strings and\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#getUtf8String(long) back}, as demonstrated in the above example.\n@@ -148,2 +147,3 @@\n- * using one of the many <em>unsafe<\/em> dereference methods provided\n- * (see {@link jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long)}):\n+ * using one of the many <em>unsafe<\/em>\n+ * {@linkplain jdk.incubator.foreign.MemoryAddress#get(jdk.incubator.foreign.ValueLayout.OfInt, long) dereference methods}\n+ * provided:\n@@ -157,4 +157,5 @@\n- * Alternatively, the client can create a memory segment <em>unsafely<\/em>, using the\n- * {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)} factory.\n- * This allows the client to inject extra knowledge about spatial bounds which might, for instance, be available in the documentation of the foreign function\n- * which produced the native address. Here is how an unsafe segment can be created from a native address:\n+ * Alternatively, the client can\n+ * {@linkplain jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope) create}\n+ * a memory segment <em>unsafely<\/em>. This allows the client to inject extra knowledge about spatial bounds which might,\n+ * for instance, be available in the documentation of the foreign function which produced the native address.\n+ * Here is how an unsafe segment can be created from a native address:\n@@ -187,0 +188,1 @@\n+FunctionDescriptor intCompareDescriptor = FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS);\n@@ -189,1 +191,1 @@\n-                                                   MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                                                   CLinker.upcallType(comparFunction));\n@@ -192,1 +194,7 @@\n- * Now that we have a method handle instance, we can link it into a fresh native memory address, using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n+ * As before, we need to create a {@link jdk.incubator.foreign.FunctionDescriptor} instance, this time describing the signature\n+ * of the function pointer we want to create. The descriptor can be used to\n+ * {@linkplain jdk.incubator.foreign.CLinker#upcallType(jdk.incubator.foreign.FunctionDescriptor) derive} a method type\n+ * that can be used to lookup the method handle for {@code IntComparator.intCompare}.\n+ * <p>\n+ * Now that we have a method handle instance, we can turn it into a fresh function pointer,\n+ * using the {@link jdk.incubator.foreign.CLinker} interface, as follows:\n@@ -197,3 +205,1 @@\n-     intCompareHandle,\n-     FunctionDescriptor.of(ValueLayout.JAVA_INT, ValueLayout.ADDRESS, ValueLayout.ADDRESS),\n-     scope\n+     intCompareHandle, intCompareDescriptor, scope);\n@@ -203,7 +209,7 @@\n- * As before, we need to provide a {@link jdk.incubator.foreign.FunctionDescriptor} instance describing the signature\n- * of the function pointer we want to create; this descriptor allows the linker to determine the\n- * sequence of steps which allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified\n- * by the platform C ABI. The lifecycle of the stub returned by\n- * {@link jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope)}\n- * is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope} parameter passed to that method. This\n- * is made available by the {@link jdk.incubator.foreign.NativeSymbol} instance returned by that method.\n+ * The {@link jdk.incubator.foreign.FunctionDescriptor} instance created in the previous step is then used to\n+ * {@linkplain jdk.incubator.foreign.CLinker#upcallStub(java.lang.invoke.MethodHandle, jdk.incubator.foreign.FunctionDescriptor, jdk.incubator.foreign.ResourceScope) create}\n+ * a new upcall stub; the layouts in the function descriptors allow the linker to determine the sequence of steps which\n+ * allow foreign code to call the stub for {@code intCompareHandle} according to the rules specified by the platform C ABI.\n+ * The lifecycle of the upcall stub returned by is tied to the {@linkplain jdk.incubator.foreign.ResourceScope resource scope}\n+ * provided when the upcall stub is created. This same scope is made available by the {@link jdk.incubator.foreign.NativeSymbol}\n+ * instance returned by that method.\n@@ -215,1 +221,1 @@\n- * the restricted method {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)}\n+ * the restricted method {@link MemorySegment#ofAddressNative(MemoryAddress, long, ResourceScope)}\n@@ -219,1 +225,1 @@\n- * For instance, in the case of {@link jdk.incubator.foreign.MemorySegment#ofAddressNative(jdk.incubator.foreign.MemoryAddress, long, jdk.incubator.foreign.ResourceScope)},\n+ * For instance, in the case of {@link MemorySegment#ofAddressNative(MemoryAddress, long, ResourceScope)},\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/package-info.java","additions":34,"deletions":28,"binary":false,"changes":62,"status":"modified"}]}