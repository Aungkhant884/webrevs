{"files":[{"patch":"@@ -38,0 +38,1 @@\n+import java.lang.invoke.MethodType;\n@@ -57,3 +58,4 @@\n- * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is derived from the\n- * argument and return layouts in the function descriptor. More specifically, given each layout {@code L} in the\n- * function descriptor, a corresponding carrier {@code C} is inferred, as described below:\n+ * The Java {@link java.lang.invoke.MethodType method type} associated with the returned method handle is\n+ * {@linkplain #downcallType(FunctionDescriptor) derived} from the argument and return layouts in the function descriptor.\n+ * More specifically, given each layout {@code L} in the function descriptor, a corresponding carrier {@code C} is inferred,\n+ * as described below:\n@@ -63,1 +65,1 @@\n- *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code MemoryAddress.class},\n+ *         <li>if {@code L} occurs in a parameter position and {@code E} is {@code NativeAddress.class},\n@@ -70,13 +72,9 @@\n- * Arguments of type {@link MemorySegment}, {@link VaList} and {@link NativeSymbol} passed by-reference to a downcall method handle\n- * are {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation. That is, the resource\n- * scope associated with such arguments cannot be closed, either implicitly or {@linkplain ResourceScope#close() explicitly}\n- * until the downcall method handle completes.\n- * <p>\n- * Furthermore, if the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n- * an extra parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n- * memory region associated with the struct returned by the downcall method handle.\n- * <p>\n- * Finally, downcall method handles feature a leading parameter of type {@link NativeSymbol}, from which the\n- * address of the target native function can be derived. The address, when known statically, can also be provided by\n- * clients at link time. As for other by-reference parameters (see above) this leading parameter will be\n- * {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} by the linker implementation.\n+ * The downcall method handle type, derived as above, might be decorated by additional leading parameters:\n+ * <ul>\n+ * <li>If the downcall method handle is created {@linkplain #downcallHandle(FunctionDescriptor) without specifying a native symbol},\n+ * the downcall method handle type features a leading parameter of type {@link NativeSymbol}, from which the\n+ * address of the target native function can be derived.<\/li>\n+ * <li>If the function descriptor's return layout is a group layout, the resulting downcall method handle accepts\n+ * an additional leading parameter of type {@link SegmentAllocator}, which is used by the linker runtime to allocate the\n+ * memory region associated with the struct returned by the downcall method handle.<\/li>\n+ * <\/ul>\n@@ -118,0 +116,23 @@\n+ * <h2>Safety considerations<\/h2>\n+ *\n+ * Obtaining downcall method handle is intrinsically unsafe. A symbol in a native library does not, in general,\n+ * contain enough signature information (e.g. arity and types of native function parameters). As a consequence,\n+ * the linker runtime cannot validate linkage requests. When a client interacts with a downcall method handle obtained\n+ * through an invalid linkage request (e.g. by specifying a function descriptor featuring too many argument layouts),\n+ * the result of such interaction is unspecified and can lead to JVM crashes. On downcall handle invocation,\n+ * the linker runtime guarantees the following for any argument that is a memory resource {@code R} (of type {@link MemorySegment},\n+ * {@link NativeSymbol} or {@link VaList}):\n+ * <ul>\n+ *     <li>The resource scope of {@code R} is {@linkplain ResourceScope#isAlive() alive}. Otherwise, the invocation throws\n+ *     {@link IllegalStateException};<\/li>\n+ *     <li>The invocation occurs in same thread as the one {@link ResourceScope#ownerThread() owning} the resource scope of {@code R},\n+ *     if said scope is confined. Otherwise, the invocation throws {@link IllegalStateException}; and<\/li>\n+ *     <li>The scope of {@code R} is {@linkplain ResourceScope#keepAlive(ResourceScope) kept alive} (and cannot be closed) during the invocation.\n+ *<\/ul>\n+ * <p>\n+ * Upcall stubs are generally safer to work with, as the linker runtime can validate the type of the target method\n+ * handle against the provided function descriptor and report an error if any mismatch is detected. If the target method\n+ * handle associated with an upcall stub returns a {@linkplain MemoryAddress native address}, clients must ensure\n+ * that this address cannot become invalid after the upcall completes. This can lead to unspecified behavior,\n+ * and even JVM crashes, since an upcall is typically executed in the context of a downcall method handle invocation.\n+ *\n@@ -225,0 +246,22 @@\n+\n+    \/**\n+     * Obtains the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the downcall method handle {@linkplain MethodType type} associated with a given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    static MethodType downcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, false);\n+    }\n+\n+    \/**\n+     * Obtains the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @param functionDescriptor a function descriptor.\n+     * @return the method handle {@linkplain MethodType type} associated with an upcall stub with given function descriptor.\n+     * @throws IllegalArgumentException if one or more layouts in the function descriptor are not supported\n+     * (e.g. if they are sequence layouts or padding layouts).\n+     *\/\n+    static MethodType upcallType(FunctionDescriptor functionDescriptor) {\n+        return SharedUtils.inferMethodType(functionDescriptor, true);\n+    }\n","filename":"src\/jdk.incubator.foreign\/share\/classes\/jdk\/incubator\/foreign\/CLinker.java","additions":60,"deletions":17,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -191,1 +191,1 @@\n-                        MethodType.methodType(int.class, MemoryAddress.class, MemoryAddress.class));\n+                        CLinker.upcallType(qsortComparFunction));\n","filename":"test\/jdk\/java\/foreign\/StdLibTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -147,1 +147,1 @@\n-            NativeSymbol callback = abi.upcallStub(reverse(mh), callbackDesc, scope);\n+            NativeSymbol callback = abi.upcallStub(mh.asType(CLinker.upcallType(callbackDesc)), callbackDesc, scope);\n@@ -261,13 +261,0 @@\n-\n-    static MethodHandle reverse(MethodHandle handle) {\n-        MethodType type = handle.type();\n-        if (type.returnType().equals(MemoryAddress.class)) {\n-            type = type.changeReturnType(Addressable.class);\n-        }\n-        for (int i = 0 ; i < type.parameterCount() ; i++) {\n-            if (type.parameterType(i).equals(Addressable.class)) {\n-                type = type.changeParameterType(i, MemoryAddress.class);\n-            }\n-        }\n-        return handle.asType(type);\n-    }\n","filename":"test\/jdk\/java\/foreign\/TestUpcall.java","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"}]}