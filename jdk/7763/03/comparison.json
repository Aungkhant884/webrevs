{"files":[{"patch":"@@ -66,0 +66,1 @@\n+#include <limits>\n@@ -747,3 +748,45 @@\n-\/\/ Parses a size specification string.\n-bool Arguments::atojulong(const char *s, julong* result) {\n-  julong n = 0;\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ signed 32-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  STATIC_ASSERT(sizeof(long) >= 4); \/\/ need to have enough bits\n+  errno = 0; \/\/ errno is thread safe\n+  long v = strtol(s, endptr, base);\n+  if (errno != 0 LP64_ONLY(|| v < min_jint || v > max_jint)) {\n+    \/\/ long is 64-bit on LP64, so we need explicit range check.\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)> \/\/ unsigned 32-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  STATIC_ASSERT(sizeof(unsigned long) >= 4); \/\/ need to have enough bits\n+  errno = 0; \/\/ errno is thread safe\n+  unsigned long v = strtoul(s, endptr, base);\n+  if (errno != 0 LP64_ONLY(|| v > max_juint)) {\n+    \/\/ unsigned long is 64-bit on LP64, so we need explicit range check.\n+    return false;\n+  }\n+  *result = static_cast<T>(v);\n+  return true;\n+}\n+\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ signed 64-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoll(s, endptr, base);\n+  return errno == 0;\n+}\n+\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)> \/\/ unsigned 64-bit\n+static bool parse_integer_impl(const char *s, char **endptr, int base, T* result) {\n+  if (s[0] == '-') {\n+    return false;\n+  }\n+  errno = 0; \/\/ errno is thread safe\n+  *result = strtoull(s, endptr, base);\n+  return errno == 0;\n+}\n@@ -751,2 +794,7 @@\n-  \/\/ First char must be a digit. Don't allow negative numbers or leading spaces.\n-  if (!isdigit(*s)) {\n+template<typename T>\n+static bool multiply_by_1k(T& n) {\n+  if (n >= std::numeric_limits<T>::min() \/ 1024 &&\n+      n <= std::numeric_limits<T>::max() \/ 1024) {\n+    n *= 1024;\n+    return true;\n+  } else {\n@@ -755,0 +803,1 @@\n+}\n@@ -756,1 +805,17 @@\n-  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X'));\n+\/\/ All of the integral types that can be used for command line options:\n+\/\/   int, uint, intx, uintx, uint64_t, size_t\n+\/\/\n+\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n+\/\/    {signed, unsigned} x {32-bit, 64-bit}\n+\/\/\n+\/\/ We use SFINAE to pick the correct parse_integer_impl() function\n+template<typename T>\n+static bool parse_integer(const char *s, T* result) {\n+  if (!isdigit(s[0]) && s[0] != '-') {\n+    \/\/ strtoll\/strtoull may allow leading spaces. Forbid it.\n+    return false;\n+  }\n+\n+  T n = 0;\n+  bool is_hex = (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) ||\n+                (s[0] == '-' && s[1] == '0' && (s[2] == 'x' || s[3] == 'X'));\n@@ -758,3 +823,2 @@\n-  errno = 0;\n-  n = strtoull(s, &remainder, (is_hex ? 16 : 10));\n-  if (errno != 0) {\n+\n+  if (!parse_integer_impl(s, &remainder, (is_hex ? 16 : 10), &n)) {\n@@ -771,4 +835,2 @@\n-      *result = n * G * K;\n-      \/\/ Check for overflow.\n-      if (*result\/((julong)G * K) != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -776,3 +838,2 @@\n-      *result = n * G;\n-      if (*result\/G != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -780,3 +841,2 @@\n-      *result = n * M;\n-      if (*result\/M != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      \/\/ fall-through\n@@ -784,3 +844,2 @@\n-      *result = n * K;\n-      if (*result\/K != n) return false;\n-      return true;\n+      if (!multiply_by_1k(n)) return false;\n+      break;\n@@ -788,2 +847,1 @@\n-      *result = n;\n-      return true;\n+      break;\n@@ -793,0 +851,7 @@\n+\n+  *result = n;\n+  return true;\n+}\n+\n+bool Arguments::atojulong(const char *s, julong* result) {\n+  return parse_integer(s, result);\n@@ -841,6 +906,1 @@\n-static bool set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n-  julong v;\n-  int int_v;\n-  intx intx_v;\n-  bool is_neg = false;\n-\n+static JVMFlag::Error set_numeric_flag(JVMFlag* flag, char* value, JVMFlagOrigin origin) {\n@@ -848,1 +908,1 @@\n-    return false;\n+    return JVMFlag::INVALID_FLAG;\n@@ -851,11 +911,0 @@\n-  \/\/ Check the sign first since atojulong() parses only unsigned values.\n-  if (*value == '-') {\n-    if (!flag->is_intx() && !flag->is_int()) {\n-      return false;\n-    }\n-    value++;\n-    is_neg = true;\n-  }\n-  if (!Arguments::atojulong(value, &v)) {\n-    return false;\n-  }\n@@ -863,3 +912,3 @@\n-    int_v = (int) v;\n-    if (is_neg) {\n-      int_v = -int_v;\n+    int v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_int(flag, &v, origin);\n@@ -867,4 +916,0 @@\n-    if ((!is_neg && v > max_jint) || (is_neg && -(intx)v < min_jint)) {\n-      return false;\n-    }\n-    return JVMFlagAccess::set_int(flag, &int_v, origin) == JVMFlag::SUCCESS;\n@@ -872,2 +917,3 @@\n-    if (v > max_juint) {\n-      return false;\n+    uint v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uint(flag, &v, origin);\n@@ -875,2 +921,0 @@\n-    uint uint_v = (uint) v;\n-    return JVMFlagAccess::set_uint(flag, &uint_v, origin) == JVMFlag::SUCCESS;\n@@ -878,12 +922,3 @@\n-    intx_v = (intx) v;\n-    if (is_neg) {\n-      if (intx_v != min_intx) {\n-        intx_v = - intx_v;\n-        if (intx_v > 0) {\n-          return false; \/\/ underflow\n-        }\n-      }\n-    } else {\n-      if (intx_v < 0) {\n-        return false; \/\/ overflow\n-      }\n+    intx v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_intx(flag, &v, origin);\n@@ -891,1 +926,0 @@\n-    return JVMFlagAccess::set_intx(flag, &intx_v, origin) == JVMFlag::SUCCESS;\n@@ -893,2 +927,4 @@\n-    uintx uintx_v = (uintx) v;\n-    return JVMFlagAccess::set_uintx(flag, &uintx_v, origin) == JVMFlag::SUCCESS;\n+    uintx v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uintx(flag, &v, origin);\n+    }\n@@ -896,2 +932,4 @@\n-    uint64_t uint64_t_v = (uint64_t) v;\n-    return JVMFlagAccess::set_uint64_t(flag, &uint64_t_v, origin) == JVMFlag::SUCCESS;\n+    uint64_t v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_uint64_t(flag, &v, origin);\n+    }\n@@ -899,2 +937,4 @@\n-    size_t size_t_v = (size_t) v;\n-    return JVMFlagAccess::set_size_t(flag, &size_t_v, origin) == JVMFlag::SUCCESS;\n+    size_t v;\n+    if (parse_integer(value, &v)) {\n+      return JVMFlagAccess::set_size_t(flag, &v, origin);\n+    }\n@@ -902,4 +942,12 @@\n-    double double_v = (double) v;\n-    return JVMFlagAccess::set_double(flag, &double_v, origin) == JVMFlag::SUCCESS;\n-  } else {\n-    return false;\n+    \/\/ This function parses only input strings without a decimal\n+    \/\/ point character (.)\n+    \/\/ If a string looks like a FP number, it would be parsed by\n+    \/\/ set_fp_numeric_flag(). See Arguments::parse_argument().\n+    jlong v;\n+    if (parse_integer(value, &v)) {\n+      double double_v = (double) v;\n+      if (value[0] == '-' && v == 0) { \/\/ special case: 0.0 is different than -0.0.\n+        double_v = -0.0;\n+      }\n+      return JVMFlagAccess::set_double(flag, &double_v, origin);\n+    }\n@@ -907,0 +955,2 @@\n+\n+  return JVMFlag::WRONG_FORMAT;\n@@ -1068,1 +1118,1 @@\n-    return set_numeric_flag(flag, value, origin);\n+    return set_numeric_flag(flag, value, origin) == JVMFlag::SUCCESS;\n@@ -2085,16 +2135,9 @@\n-\n-  \/\/ Check the sign first since atojulong() parses only unsigned values.\n-  bool value_is_positive = !(*value == '-');\n-\n-  if (value_is_positive) {\n-    julong n;\n-    bool good_return = atojulong(value, &n);\n-    if (good_return) {\n-      bool above_minimum = n >= min_size;\n-      bool value_is_too_large = n > max_uintx;\n-\n-      if (above_minimum && !value_is_too_large) {\n-        *uintx_arg = n;\n-        return true;\n-      }\n-    }\n+  uintx n;\n+  if (!parse_integer(value, &n)) {\n+    return false;\n+  }\n+  if (n >= min_size) {\n+    *uintx_arg = n;\n+    return true;\n+  } else {\n+    return false;\n@@ -2102,1 +2145,0 @@\n-  return false;\n@@ -2153,1 +2195,1 @@\n-  if (!atojulong(s, long_arg)) return arg_unreadable;\n+  if (!parse_integer(s, long_arg)) return arg_unreadable;\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":137,"deletions":95,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,23 @@\n+  product(bool, TestFlagFor_bool, false,                                    \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(int, TestFlagFor_int, 0,                                          \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(uint, TestFlagFor_uint, 0,                                        \\\n+           \"Used by VM internal regression tests only\")                     \\\n+                                                                            \\\n+  product(intx, TestFlagFor_intx, 0,                                        \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(uintx, TestFlagFor_uintx, 0,                                      \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(uint64_t, TestFlagFor_uint64_t, 0,                                \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(size_t, TestFlagFor_size_t, 0,                                    \\\n+          \"Used by VM internal regression tests only\")                      \\\n+                                                                            \\\n+  product(double, TestFlagFor_double, 0.0,                                  \\\n+          \"Used by VM internal regression tests only\")                      \\\n","filename":"src\/hotspot\/share\/runtime\/flags\/debug_globals.hpp","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"runtime\/flags\/jvmFlag.hpp\"\n@@ -44,0 +45,10 @@\n+\n+  static bool parse_argument(const char* name, const char* value) {\n+    char buf[1024];\n+    int ret = jio_snprintf(buf, sizeof(buf), \"%s=%s\", name, value);\n+    if (ret > 0) {\n+      return Arguments::parse_argument(buf, JVMFlagOrigin::COMMAND_LINE);\n+    } else {\n+      return false;\n+    }\n+  }\n@@ -204,0 +215,353 @@\n+\n+struct Dummy {};\n+static Dummy BAD;\n+\n+template <typename T>\n+struct NumericArgument {\n+  bool bad;\n+  const char* str;\n+  T expected_value;\n+\n+  NumericArgument(const char* s, T v) :           bad(false), str(s), expected_value(v) {}\n+  NumericArgument(const char* s, Dummy & dummy) : bad(true),  str(s), expected_value(0) {}\n+};\n+\n+static void check_invalid_numeric_string(JVMFlag* flag,  const char** invalid_strings) {\n+  for (uint i = 0; ; i++) {\n+    const char* str = invalid_strings[i];\n+    if (str == NULL) {\n+      return;\n+    }\n+    ASSERT_FALSE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Invalid string '\" << str\n+        << \"' parsed without error for type \" << flag->type_string() << \".\";\n+  }\n+}\n+\n+template <typename T>\n+void check_numeric_flag(JVMFlag* flag, T getvalue(JVMFlag* flag),\n+                        NumericArgument<T>* valid_args, size_t n,\n+                        bool is_double = false) {\n+  for (size_t i = 0; i < n; i++) {\n+    NumericArgument<T>* info = &valid_args[i];\n+    const char* str = info->str;\n+    if (info->bad) {\n+      ASSERT_FALSE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Invalid string '\" << str\n+        << \"' parsed without error for type \" << flag->type_string() << \".\";\n+    } else {\n+      ASSERT_TRUE(ArgumentsTest::parse_argument(flag->name(), str))\n+        << \"Valid string '\" <<\n+        str << \"' did not parse for type \" << flag->type_string() << \".\";\n+      ASSERT_EQ(getvalue(flag), info->expected_value)\n+        << \"Valid string '\" << str\n+        << \"' did not parse to the correct value for type \"\n+        << flag->type_string() << \".\";\n+    }\n+  }\n+\n+  {\n+    \/\/ Invalid strings for *any* type of integer VM arguments\n+    const char* invalid_strings[] = {\n+      \"\", \" 1\", \"2 \", \"3 2\",\n+      \"0x\", \"0x0x1\" \"e\"\n+      \"K\", \"M\", \"G\", \"1MB\", \"1KM\", \"AA\", \"0B\",\n+      \"18446744073709551615K\", \"17179869184G\",\n+      \"999999999999999999999999999999\",\n+      \"0x10000000000000000\", \"18446744073709551616\",\n+      \"-0x10000000000000000\", \"-18446744073709551616\",\n+      \"-0x8000000000000001\", \"-9223372036854775809\",\n+      \"0x8000000t\", \"0x800000000g\",\n+      \"0x800000000000m\", \"0x800000000000000k\",\n+      \"-0x8000000t\", \"-0x800000000g\",\n+      \"-0x800000000000m\", \"-0x800000000000000k\",\n+      NULL,\n+    };\n+    check_invalid_numeric_string(flag, invalid_strings);\n+  }\n+\n+  if (!is_double) {\n+    const char* invalid_strings_for_integers[] = {\n+      \"1.0\", \"0x4.5\", \"0.001\", \"4e10\",\n+      NULL,\n+    };\n+    check_invalid_numeric_string(flag, invalid_strings_for_integers);\n+  }\n+}\n+\n+#define INTEGER_TEST_TABLE(f) \\\n+  \/*input                      i32           u32           i64                      u64 *\/ \\\n+  f(\"0\",                       0,            0,            0,                       0                        ) \\\n+  f(\"-0\",                      0,            BAD,          0,                       BAD                      ) \\\n+  f(\"-1\",                     -1,            BAD,         -1,                       BAD                      ) \\\n+  f(\"0x1\",                     1,            1,            1,                       1                        ) \\\n+  f(\"-0x1\",                   -1,            BAD,         -1,                       BAD                      ) \\\n+  f(\"4711\",                    4711,         4711,         4711,                    4711                     ) \\\n+  f(\"1K\",                      1024,         1024,         1024,                    1024                     ) \\\n+  f(\"1k\",                      1024,         1024,         1024,                    1024                     ) \\\n+  f(\"2M\",                      2097152,      2097152,      2097152,                 2097152                  ) \\\n+  f(\"2m\",                      2097152,      2097152,      2097152,                 2097152                  ) \\\n+  f(\"1G\",                      1073741824,   1073741824,   1073741824,              1073741824               ) \\\n+  f(\"2G\",                      BAD,          0x80000000,   2147483648LL,            2147483648ULL            ) \\\n+  f(\"1T\",                      BAD,          BAD,          1099511627776LL,         1099511627776ULL         ) \\\n+  f(\"1t\",                      BAD,          BAD,          1099511627776LL,         1099511627776ULL         ) \\\n+  f(\"-1K\",                    -1024,         BAD,         -1024,                    BAD                      ) \\\n+  f(\"0x1K\",                    1024,         1024,         1024,                    1024                     ) \\\n+  f(\"-0x1K\",                  -1024,         BAD,         -1024,                    BAD                      ) \\\n+  f(\"0K\",                      0,            0,            0,                       0                        ) \\\n+  f(\"0x1000000k\",              BAD,          BAD,          17179869184LL,           17179869184ULL           ) \\\n+  f(\"0x800000m\",               BAD,          BAD,          0x80000000000LL,         0x80000000000ULL         ) \\\n+  f(\"0x8000g\",                 BAD,          BAD,          0x200000000000LL,        0x200000000000ULL        ) \\\n+  f(\"0x8000t\",                 BAD,          BAD,          0x80000000000000LL,      0x80000000000000ULL      ) \\\n+  f(\"-0x1000000k\",             BAD,          BAD,         -17179869184LL,           BAD                      ) \\\n+  f(\"-0x800000m\",              BAD,          BAD,         -0x80000000000LL,         BAD                      ) \\\n+  f(\"-0x8000g\",                BAD,          BAD,         -0x200000000000LL,        BAD                      ) \\\n+  f(\"-0x8000t\",                BAD,          BAD,         -0x80000000000000LL,      BAD                      ) \\\n+  f(\"0x7fffffff\",              0x7fffffff,   0x7fffffff,   0x7fffffff,              0x7fffffff               ) \\\n+  f(\"0xffffffff\",              BAD,          0xffffffff,   0xffffffff,              0xffffffff               ) \\\n+  f(\"0x80000000\",              BAD,          0x80000000,   0x80000000,              0x80000000               ) \\\n+  f(\"-0x7fffffff\",            -2147483647,   BAD,         -2147483647LL,            BAD                      ) \\\n+  f(\"-0x80000000\",            -2147483648,   BAD,         -2147483648LL,            BAD                      ) \\\n+  f(\"-0x80000001\",             BAD,          BAD,         -2147483649LL,            BAD                      ) \\\n+  f(\"0x100000000\",             BAD,          BAD,          0x100000000LL,           0x100000000ULL           ) \\\n+  f(\"0xcafebabe\",              BAD,          0xcafebabe,   0xcafebabe,              0xcafebabe               ) \\\n+  f(\"0XCAFEBABE\",              BAD,          0xcafebabe,   0xcafebabe,              0xcafebabe               ) \\\n+  f(\"0XCAFEbabe\",              BAD,          0xcafebabe,   0xcafebabe,              0xcafebabe               ) \\\n+  f(\"0xcafebabe1\",             BAD,          BAD,          0xcafebabe1,             0xcafebabe1              ) \\\n+  f(\"0x7fffffffffffffff\",      BAD,          BAD,          max_jlong,               9223372036854775807ULL   ) \\\n+  f(\"0x8000000000000000\",      BAD,          BAD,          BAD,                     9223372036854775808ULL   ) \\\n+  f(\"0xffffffffffffffff\",      BAD,          BAD,          BAD,                     max_julong               ) \\\n+  f(\"9223372036854775807\",     BAD,          BAD,          9223372036854775807LL,   9223372036854775807ULL   ) \\\n+  f(\"9223372036854775808\",     BAD,          BAD,          BAD,                     9223372036854775808ULL   ) \\\n+  f(\"-9223372036854775808\",    BAD,          BAD,          min_jlong,               BAD                      ) \\\n+  f(\"18446744073709551615\",    BAD,          BAD,          BAD,                     max_julong               ) \\\n+                                                                                                               \\\n+  \/* All edge cases without a k\/m\/g\/t suffix *\/                                                                \\\n+  f(\"0x7ffffffe\",              max_jint-1,   0x7ffffffe,   0x7ffffffeLL,            0x7ffffffeULL            ) \\\n+  f(\"0x7fffffff\",              max_jint,     0x7fffffff,   0x7fffffffLL,            0x7fffffffULL            ) \\\n+  f(\"0x80000000\",              BAD,          0x80000000,   0x80000000LL,            0x80000000ULL            ) \\\n+  f(\"0xfffffffe\",              BAD,          max_juint-1,  0xfffffffeLL,            0xfffffffeULL            ) \\\n+  f(\"0xffffffff\",              BAD,          max_juint,    0xffffffffLL,            0xffffffffULL            ) \\\n+  f(\"0x100000000\",             BAD,          BAD,          0x100000000LL,           0x100000000ULL           ) \\\n+  f(\"-0x7fffffff\",             min_jint+1,   BAD,         -0x7fffffffLL,            BAD                      ) \\\n+  f(\"-0x80000000\",             min_jint,     BAD,         -0x80000000LL,            BAD                      ) \\\n+  f(\"-0x80000001\",             BAD,          BAD,         -0x80000001LL,            BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x7ffffffffffffffe\",      BAD,          BAD,          max_jlong-1,             0x7ffffffffffffffeULL    ) \\\n+  f(\"0x7fffffffffffffff\",      BAD,          BAD,          max_jlong,               0x7fffffffffffffffULL    ) \\\n+  f(\"0x8000000000000000\",      BAD,          BAD,          BAD,                     0x8000000000000000ULL    ) \\\n+  f(\"0xfffffffffffffffe\",      BAD,          BAD,          BAD,                     max_julong-1             ) \\\n+  f(\"0xffffffffffffffff\",      BAD,          BAD,          BAD,                     max_julong               ) \\\n+  f(\"0x10000000000000000\",     BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x7fffffffffffffff\",     BAD,          BAD,          min_jlong+1,             BAD                      ) \\\n+  f(\"-0x8000000000000000\",     BAD,          BAD,          min_jlong,               BAD                      ) \\\n+  f(\"-0x8000000000000001\",     BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: K *\/                                                                               \\\n+  f(\"0x1ffffek\",               0x1ffffe * k, 0x1ffffeU * k,0x1ffffeLL * k,          0x1ffffeULL * k          ) \\\n+  f(\"0x1fffffk\",               0x1fffff * k, 0x1fffffU * k,0x1fffffLL * k,          0x1fffffULL * k          ) \\\n+  f(\"0x200000k\",               BAD,          0x200000U * k,0x200000LL * k,          0x200000ULL * k          ) \\\n+  f(\"0x3ffffek\",               BAD,          0x3ffffeU * k,0x3ffffeLL * k,          0x3ffffeULL * k          ) \\\n+  f(\"0x3fffffk\",               BAD,          0x3fffffU * k,0x3fffffLL * k,          0x3fffffULL * k          ) \\\n+  f(\"0x400000k\",               BAD,          BAD,          0x400000LL * k,          0x400000ULL * k          ) \\\n+  f(\"-0x1fffffk\",             -0x1fffff * k, BAD,         -0x1fffffLL * k,          BAD                      ) \\\n+  f(\"-0x200000k\",             -0x200000 * k, BAD,         -0x200000LL * k,          BAD                      ) \\\n+  f(\"-0x200001k\",              BAD,          BAD,         -0x200001LL * k,          BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x1ffffffffffffek\",       BAD,          BAD,          0x1ffffffffffffeLL * k,  0x1ffffffffffffeULL * k  ) \\\n+  f(\"0x1fffffffffffffk\",       BAD,          BAD,          0x1fffffffffffffLL * k,  0x1fffffffffffffULL * k  ) \\\n+  f(\"0x20000000000000k\",       BAD,          BAD,          BAD,                     0x20000000000000ULL * k  ) \\\n+  f(\"0x3ffffffffffffek\",       BAD,          BAD,          BAD,                     0x3ffffffffffffeULL * k  ) \\\n+  f(\"0x3fffffffffffffk\",       BAD,          BAD,          BAD,                     0x3fffffffffffffULL * k  ) \\\n+  f(\"0x40000000000000k\",       BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x1fffffffffffffk\",      BAD,          BAD,         -0x1fffffffffffffLL * k,  BAD                      ) \\\n+  f(\"-0x20000000000000k\",      BAD,          BAD,         -0x20000000000000LL * k,  BAD                      ) \\\n+  f(\"-0x20000000000001k\",      BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: M *\/                                                                               \\\n+  f(\"0x7fem\",                  0x7fe * m,    0x7feU * m,   0x7feLL * m,             0x7feULL * m             ) \\\n+  f(\"0x7ffm\",                  0x7ff * m,    0x7ffU * m,   0x7ffLL * m,             0x7ffULL * m             ) \\\n+  f(\"0x800m\",                  BAD,          0x800U * m,   0x800LL * m,             0x800ULL * m             ) \\\n+  f(\"0xffem\",                  BAD,          0xffeU * m,   0xffeLL * m,             0xffeULL * m             ) \\\n+  f(\"0xfffm\",                  BAD,          0xfffU * m,   0xfffLL * m,             0xfffULL * m             ) \\\n+  f(\"0x1000m\",                 BAD,          BAD,          0x1000LL * m,            0x1000ULL * m            ) \\\n+  f(\"-0x7ffm\",                -0x7ff * m,    BAD,         -0x7ffLL * m,             BAD                      ) \\\n+  f(\"-0x800m\",                -0x800 * m,    BAD,         -0x800LL * m,             BAD                      ) \\\n+  f(\"-0x801m\",                 BAD,          BAD,         -0x801LL * m,             BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x7fffffffffem\",          BAD,          BAD,          0x7fffffffffeLL * m,     0x7fffffffffeULL * m     ) \\\n+  f(\"0x7ffffffffffm\",          BAD,          BAD,          0x7ffffffffffLL * m,     0x7ffffffffffULL * m     ) \\\n+  f(\"0x80000000000m\",          BAD,          BAD,          BAD,                     0x80000000000ULL * m     ) \\\n+  f(\"0xffffffffffem\",          BAD,          BAD,          BAD,                     0xffffffffffeULL * m     ) \\\n+  f(\"0xfffffffffffm\",          BAD,          BAD,          BAD,                     0xfffffffffffULL * m     ) \\\n+  f(\"0x100000000000m\",         BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x7ffffffffffm\",         BAD,          BAD,         -0x7ffffffffffLL * m,     BAD                      ) \\\n+  f(\"-0x80000000000m\",         BAD,          BAD,         -0x80000000000LL * m,     BAD                      ) \\\n+  f(\"-0x80000000001m\",         BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: G *\/                                                                               \\\n+  f(\"0x0g\",                    0x0 * g,      0x0U * g,     0x0LL * g,               0x0ULL * g               ) \\\n+  f(\"0x1g\",                    0x1 * g,      0x1U * g,     0x1LL * g,               0x1ULL * g               ) \\\n+  f(\"0x2g\",                    BAD,          0x2U * g,     0x2LL * g,               0x2ULL * g               ) \\\n+  f(\"0x3g\",                    BAD,          0x3U * g,     0x3LL * g,               0x3ULL * g               ) \\\n+  f(\"0x4g\",                    BAD,          BAD,          0x4LL * g,               0x4ULL * g               ) \\\n+  f(\"-0x1g\",                  -0x1 * g,      BAD,         -0x1LL * g,               BAD                      ) \\\n+  f(\"-0x2g\",                  -0x2 * g,      BAD,         -0x2LL * g,               BAD                      ) \\\n+  f(\"-0x3g\",                   BAD,          BAD,         -0x3LL * g,               BAD                      ) \\\n+                                                                                                               \\\n+  f(\"0x1fffffffeg\",            BAD,          BAD,          0x1fffffffeLL * g,       0x1fffffffeULL * g       ) \\\n+  f(\"0x1ffffffffg\",            BAD,          BAD,          0x1ffffffffLL * g,       0x1ffffffffULL * g       ) \\\n+  f(\"0x200000000g\",            BAD,          BAD,          BAD,                     0x200000000ULL * g       ) \\\n+  f(\"0x3fffffffeg\",            BAD,          BAD,          BAD,                     0x3fffffffeULL * g       ) \\\n+  f(\"0x3ffffffffg\",            BAD,          BAD,          BAD,                     0x3ffffffffULL * g       ) \\\n+  f(\"0x400000000g\",            BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x1ffffffffg\",           BAD,          BAD,         -0x1ffffffffLL * g,       BAD                      ) \\\n+  f(\"-0x200000000g\",           BAD,          BAD,         -0x200000000LL * g,       BAD                      ) \\\n+  f(\"-0x200000001g\",           BAD,          BAD,          BAD,                     BAD                      ) \\\n+                                                                                                               \\\n+  \/* edge cases for suffix: T *\/                                                                               \\\n+  f(\"0x7ffffet\",               BAD,          BAD,          0x7ffffeLL * t,          0x7ffffeULL * t          ) \\\n+  f(\"0x7ffffft\",               BAD,          BAD,          0x7fffffLL * t,          0x7fffffULL * t          ) \\\n+  f(\"0x800000t\",               BAD,          BAD,          BAD,                     0x800000ULL * t          ) \\\n+  f(\"0xfffffet\",               BAD,          BAD,          BAD,                     0xfffffeULL * t          ) \\\n+  f(\"0xfffffft\",               BAD,          BAD,          BAD,                     0xffffffULL * t          ) \\\n+  f(\"0x1000000t\",              BAD,          BAD,          BAD,                     BAD                      ) \\\n+  f(\"-0x7ffffft\",              BAD,          BAD,         -0x7fffffLL * t,          BAD                      ) \\\n+  f(\"-0x800000t\",              BAD,          BAD,         -0x800000LL * t,          BAD                      ) \\\n+  f(\"-0x800001t\",              BAD,          BAD,          BAD,                     BAD                      )\n+\n+#define INTEGER_TEST_i32(s, i32, u32, i64, u64) NumericArgument<T>(s, i32),\n+#define INTEGER_TEST_u32(s, i32, u32, i64, u64) NumericArgument<T>(s, u32),\n+#define INTEGER_TEST_i64(s, i32, u32, i64, u64) NumericArgument<T>(s, i64),\n+#define INTEGER_TEST_u64(s, i32, u32, i64, u64) NumericArgument<T>(s, u64),\n+\n+\/\/ signed 32-bit\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_i32) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ unsigned 32-bit\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 4)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_u32) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ signed 64-bit\n+template <typename T, ENABLE_IF(std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  T t = static_cast<T>(G) * k;\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_i64) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ unsigned 64-bit\n+template <typename T, ENABLE_IF(!std::is_signed<T>::value), ENABLE_IF(sizeof(T) == 8)>\n+void check_flag(const char* f, T getvalue(JVMFlag* flag)) {\n+  JVMFlag* flag = JVMFlag::find_flag(f);\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  T k = static_cast<T>(K);\n+  T m = static_cast<T>(M);\n+  T g = static_cast<T>(G);\n+  T t = static_cast<T>(G) * k;\n+  NumericArgument<T> valid_strings[] = { INTEGER_TEST_TABLE(INTEGER_TEST_u64) };\n+  check_numeric_flag(flag, getvalue, valid_strings, ARRAY_SIZE(valid_strings));\n+}\n+\n+\/\/ Testing the parsing of -XX:<SomeFlag>=<an integer value>\n+\/\/\n+\/\/ All of the integral types that can be used for command line options:\n+\/\/   int, uint, intx, uintx, uint64_t, size_t\n+\/\/\n+\/\/ In all supported platforms, these types can be mapped to only 4 native types:\n+\/\/    {signed, unsigned} x {32-bit, 64-bit}\n+\/\/\n+\/\/ We use SFINAE to pick the correct column in the INTEGER_TEST_TABLE for each type.\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_int) {\n+  check_flag<int>(\"TestFlagFor_int\", [] (JVMFlag* flag) {\n+    return flag->get_int();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_uint) {\n+  check_flag<uint>(\"TestFlagFor_uint\", [] (JVMFlag* flag) {\n+    return flag->get_uint();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_intx) {\n+  check_flag<intx>(\"TestFlagFor_intx\", [] (JVMFlag* flag) {\n+    return flag->get_intx();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_uintx) {\n+  check_flag<uintx>(\"TestFlagFor_uintx\", [] (JVMFlag* flag) {\n+    return flag->get_uintx();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_uint64_t) {\n+  check_flag<uint64_t>(\"TestFlagFor_uint64_t\", [] (JVMFlag* flag) {\n+    return flag->get_uint64_t();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_size_t) {\n+  check_flag<size_t>(\"TestFlagFor_size_t\", [] (JVMFlag* flag) {\n+    return flag->get_size_t();\n+  });\n+}\n+\n+TEST_VM_F(ArgumentsTest, set_numeric_flag_double) {\n+  JVMFlag* flag = JVMFlag::find_flag(\"TestFlagFor_double\");\n+  if (flag == NULL) { \/\/ not available in product builds\n+    return;\n+  }\n+\n+  \/\/ TODO -- JDK-8282774\n+  \/\/ Need to add more test input that have a fractional part like \"4.2\".\n+  NumericArgument<double> valid_strings[] = {\n+    NumericArgument<double>(\"0\",   0.0),\n+    NumericArgument<double>(\"1\",   1.0),\n+    NumericArgument<double>(\"-0\", -0.0),\n+    NumericArgument<double>(\"-1\", -1.0),\n+  };\n+\n+  auto getvalue = [] (JVMFlag* flag) {\n+    return flag->get_double();\n+  };\n+\n+  check_numeric_flag<double>(flag, getvalue, valid_strings,\n+                             ARRAY_SIZE(valid_strings), \/*is_double=*\/true);\n+}\n","filename":"test\/hotspot\/gtest\/runtime\/test_arguments.cpp","additions":365,"deletions":1,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"compiler\/compiler_globals.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"runtime\/flags\/jvmFlag.hpp\"\n-#include \"runtime\/globals.hpp\"\n-#include \"unittest.hpp\"\n-\n-class LargeOptionsTest : public ::testing::Test {\n-public:\n-  static bool test_option_value(const char* option, intx value) {\n-    char buffer[100];\n-    UnlockDiagnosticVMOptions = true;\n-    os::snprintf(buffer, 100, \"%s=\" INTX_FORMAT, option, value);\n-    return Arguments::parse_argument(buffer, JVMFlagOrigin::COMMAND_LINE);\n-  }\n-\n-  static bool test_option_value(const char* option) {\n-    UnlockDiagnosticVMOptions = true;\n-    return Arguments::parse_argument(option, JVMFlagOrigin::COMMAND_LINE);\n-  }\n-};\n-\n-#ifdef _LP64\n-\/\/ CompilerDirectivesLimit is a diagnostic int option.\n-TEST_VM(LARGE_OPTION, large_ints) {\n-  for (intx x = max_jint - 1; x <= (intx)max_jint + 1; x++) {\n-    bool result = LargeOptionsTest::test_option_value(\"CompilerDirectivesLimit\", x);\n-    if (x > max_jint) {\n-      ASSERT_FALSE(result);\n-    } else {\n-      ASSERT_TRUE(result);\n-      ASSERT_EQ(CompilerDirectivesLimit, x);\n-    }\n-  }\n-}\n-\n-TEST_VM(LARGE_OPTION, small_ints) {\n-  for (intx x = min_jint + 1; x >= (intx)min_jint - 1; x--) {\n-    bool result = LargeOptionsTest::test_option_value(\"CompilerDirectivesLimit\", x);\n-    if (x < min_jint) {\n-      ASSERT_FALSE(result);\n-    } else {\n-      ASSERT_TRUE(result);\n-      ASSERT_EQ(CompilerDirectivesLimit, x);\n-    }\n-  }\n-}\n-\n-TEST_VM(LARGE_OPTION, large_int_overflow) { \/\/ Test 0x100000000\n-  ASSERT_FALSE(LargeOptionsTest::test_option_value(\"CompilerDirectivesLimit\", 4294967296));\n-}\n-#endif\n-\n-\/\/ HandshakeTimeout is a diagnostic uint option.\n-TEST_VM(LARGE_OPTION, large_uints) {\n-  for (uintx x = max_juint - 1; x <= (uintx)max_juint + 1; x++) {\n-    bool result = LargeOptionsTest::test_option_value(\"HandshakeTimeout\", x);\n-    if (x <= max_juint) {\n-      ASSERT_TRUE(result);\n-      ASSERT_EQ(HandshakeTimeout, x);\n-    } else {\n-      ASSERT_FALSE(result);\n-    }\n-  }\n-}\n-\n-#ifdef _LP64\n-\/\/ MaxJNILocalCapacity is an intx option.\n-TEST_VM(LARGE_OPTION, large_intxs) {\n-  \/\/ max_intx + 1 equals min_intx!\n-  for (julong x = max_intx - 1; x <= (julong)max_intx + 1; x++) {\n-    ASSERT_TRUE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity\", x));\n-    ASSERT_EQ((julong)MaxJNILocalCapacity, x);\n-  }\n-}\n-\n-TEST_VM(LARGE_OPTION, small_intxs) {\n-  ASSERT_TRUE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity\", min_intx + 1));\n-  ASSERT_EQ(MaxJNILocalCapacity, -9223372036854775807);\n-  ASSERT_TRUE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity\", min_intx));\n-  ASSERT_EQ(MaxJNILocalCapacity, min_intx);\n-  \/\/ Test value that's less than min_intx (-0x8000000000000001).\n-  ASSERT_FALSE(LargeOptionsTest::test_option_value(\"MaxJNILocalCapacity=-9223372036854775809\"));\n-}\n-#endif\n","filename":"test\/hotspot\/gtest\/runtime\/test_largeOptions.cpp","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"}]}