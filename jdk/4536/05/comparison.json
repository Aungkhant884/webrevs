{"files":[{"patch":"@@ -57,1 +57,1 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n@@ -510,1 +510,1 @@\n-bool ClassListParser::is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS) {\n+bool ClassListParser::is_matching_cp_entry(const constantPoolHandle &pool, int cp_index, TRAPS) {\n@@ -646,2 +646,3 @@\n-    InstanceKlass** old_ptr = table()->lookup(id);\n-    if (old_ptr != NULL) {\n+    bool created;\n+    id2klass_table()->put_if_absent(id, ik, &created);\n+    if (!created) {\n@@ -650,1 +651,3 @@\n-    table()->add(id, ik);\n+    if (id2klass_table()->maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n+    }\n@@ -661,1 +664,1 @@\n-  InstanceKlass** klass_ptr = table()->lookup(id);\n+  InstanceKlass** klass_ptr = id2klass_table()->get(id);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -36,0 +36,1 @@\n+class constantPoolHandle;\n@@ -69,1 +70,3 @@\n-  typedef KVHashtable<int, InstanceKlass*, mtInternal> ID2KlassTable;\n+  \/\/ Must be C_HEAP allocated -- we don't want nested resource allocations.\n+  typedef ResizeableResourceHashtable<int, InstanceKlass*,\n+                                      ResourceObj::C_HEAP, mtClassShared> ID2KlassTable;\n@@ -83,1 +86,3 @@\n-  static const int INITIAL_TABLE_SIZE = 1987;\n+  \/\/ Use a small initial size in debug build to test resizing logic\n+  static const int INITIAL_TABLE_SIZE = DEBUG_ONLY(17) NOT_DEBUG(1987);\n+  static const int MAX_TABLE_SIZE = 61333;\n@@ -109,1 +114,1 @@\n-  ID2KlassTable* table() {\n+  ID2KlassTable* id2klass_table() {\n@@ -115,1 +120,1 @@\n-  bool is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS);\n+  bool is_matching_cp_entry(const constantPoolHandle &pool, int cp_index, TRAPS);\n@@ -164,1 +169,1 @@\n-    if (_id2klass_table.lookup(id) == NULL) {\n+    if (!id2klass_table()->contains(id)) {\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  _has_been_visited.add_if_absent(ref->obj(), read_only, &created);\n+  _has_been_visited.put_if_absent(ref->obj(), read_only, &created);\n@@ -102,1 +102,1 @@\n-    if (_has_been_visited.maybe_grow(MAX_TABLE_SIZE)) {\n+    if (_has_been_visited.maybe_grow()) {\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -396,1 +396,1 @@\n-  UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}\n+  UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {}\n@@ -399,1 +399,2 @@\n-  KVHashtable<address, bool, mtInternal> _has_been_visited;\n+  ResizeableResourceHashtable<address, bool, ResourceObj::C_HEAP,\n+                              mtClassShared> _has_been_visited;\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n+#define SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n+\n+#include \"utilities\/resourceHash.hpp\"\n+\n+template<\n+    typename K, typename V,\n+    ResourceObj::allocation_type ALLOC_TYPE,\n+    MEMFLAGS MEM_TYPE>\n+class ResizeableResourceHashtableStorage : public ResourceObj {\n+  using Node = ResourceHashtableNode<K, V>;\n+\n+protected:\n+  unsigned _table_size;\n+  Node** _table;\n+\n+  ResizeableResourceHashtableStorage(unsigned table_size) {\n+    _table_size = table_size;\n+    _table = alloc_table(table_size);\n+  }\n+\n+  ~ResizeableResourceHashtableStorage() {\n+    if (ALLOC_TYPE == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, _table);\n+    }\n+  }\n+\n+  Node** alloc_table(unsigned table_size) {\n+    Node** table;\n+    if (ALLOC_TYPE == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TYPE);\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(Node*));\n+    return table;\n+  }\n+\n+  unsigned table_size() const {\n+    return _table_size;\n+  }\n+\n+  Node** table() const {\n+    return _table;\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n+    MEMFLAGS MEM_TYPE = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class ResizeableResourceHashtable : public ResourceHashtableBase<\n+    ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TYPE>,\n+    K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE> {\n+  unsigned _max_size;\n+\n+  using BASE = ResourceHashtableBase<ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TYPE>,\n+                                     K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>;\n+  using Node = ResourceHashtableNode<K, V>;\n+  NONCOPYABLE(ResizeableResourceHashtable);\n+public:\n+  ResizeableResourceHashtable(unsigned size, unsigned max_size = 0)\n+  : BASE(size), _max_size(max_size) {\n+    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n+  }\n+\n+  bool maybe_grow(int load_factor = 8) {\n+    unsigned old_size = BASE::_table_size;\n+    if (old_size >= _max_size) {\n+      return false;\n+    }\n+    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n+      unsigned new_size = MIN2<unsigned>(old_size * 2, _max_size);\n+      resize(old_size, new_size);\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+\n+  void resize(unsigned old_size, unsigned new_size) {\n+    Node** old_table = BASE::_table;\n+    Node** new_table = BASE::alloc_table(new_size);\n+\n+    Node* const* bucket = old_table;\n+    while (bucket < &old_table[old_size]) {\n+      Node* node = *bucket;\n+      while (node != NULL) {\n+        Node* next = node->_next;\n+        unsigned hash = HASH(node->_key);\n+        unsigned index = hash % new_size;\n+\n+        node->_next = new_table[index];\n+        new_table[index] = node;\n+\n+        node = next;\n+      }\n+      ++bucket;\n+    }\n+\n+    if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, old_table);\n+    }\n+    BASE::_table = new_table;\n+    BASE::_table_size = new_size;\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,16 @@\n+template<typename K, typename V>\n+class ResourceHashtableNode : public ResourceObj {\n+public:\n+  unsigned _hash;\n+  K _key;\n+  V _value;\n+  ResourceHashtableNode* _next;\n+\n+  ResourceHashtableNode(unsigned hash, K const& key, V const& value) :\n+    _hash(hash), _key(key), _value(value), _next(NULL) {}\n+\n+  \/\/ Create a node with a default-constructed value.\n+  ResourceHashtableNode(unsigned hash, K const& key) :\n+    _hash(hash), _key(key), _value(), _next(NULL) {}\n+};\n+\n@@ -31,0 +47,1 @@\n+    class STORAGE,\n@@ -32,9 +49,4 @@\n-    \/\/ xlC does not compile this:\n-    \/\/ http:\/\/stackoverflow.com\/questions\/8532961\/template-argument-of-type-that-is-defined-by-inner-typedef-from-other-template-c\n-    \/\/typename ResourceHashtableFns<K>::hash_fn   HASH   = primitive_hash<K>,\n-    \/\/typename ResourceHashtableFns<K>::equals_fn EQUALS = primitive_equals<K>,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-    unsigned SIZE = 256,\n-    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n-    MEMFLAGS MEM_TYPE = mtInternal\n+    unsigned (*HASH)  (K const&),\n+    bool     (*EQUALS)(K const&, K const&),\n+    ResourceObj::allocation_type ALLOC_TYPE,\n+    MEMFLAGS MEM_TYPE\n@@ -42,1 +54,2 @@\n-class ResourceHashtable : public ResourceObj {\n+class ResourceHashtableBase : public STORAGE {\n+  using Node = ResourceHashtableNode<K, V>;\n@@ -44,0 +57,1 @@\n+  int _number_of_entries;\n@@ -45,17 +59,4 @@\n-  class Node : public ResourceObj {\n-   public:\n-    unsigned _hash;\n-    K _key;\n-    V _value;\n-    Node* _next;\n-\n-    Node(unsigned hash, K const& key, V const& value) :\n-        _hash(hash), _key(key), _value(value), _next(NULL) {}\n-\n-    \/\/ Create a node with a default-constructed value.\n-    Node(unsigned hash, K const& key) :\n-        _hash(hash), _key(key), _value(), _next(NULL) {}\n-\n-  };\n-\n-  Node* _table[SIZE];\n+  Node** bucket_at(unsigned index) const {\n+    Node** t = table();\n+    return &t[index];\n+  }\n@@ -66,2 +67,2 @@\n-    unsigned index = hash % SIZE;\n-    Node** ptr = &_table[index];\n+    unsigned index = hash % table_size();\n+    Node** ptr = bucket_at(index);\n@@ -80,1 +81,1 @@\n-        const_cast<ResourceHashtable*>(this)->lookup_node(hash, key));\n+        const_cast<ResourceHashtableBase*>(this)->lookup_node(hash, key));\n@@ -83,2 +84,2 @@\n- public:\n-  ResourceHashtable() { memset(_table, 0, SIZE * sizeof(Node*)); }\n+ protected:\n+  Node** table() const { return STORAGE::table(); }\n@@ -86,4 +87,9 @@\n-  ~ResourceHashtable() {\n-    if (ALLOC_TYPE == C_HEAP) {\n-      Node* const* bucket = _table;\n-      while (bucket < &_table[SIZE]) {\n+  ResourceHashtableBase() : STORAGE(), _number_of_entries(0) {}\n+  ResourceHashtableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n+  NONCOPYABLE(ResourceHashtableBase);\n+\n+  ~ResourceHashtableBase() {\n+    if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n+      Node* const* bucket = table();\n+      const unsigned sz = table_size();\n+      while (bucket < bucket_at(sz)) {\n@@ -101,0 +107,4 @@\n+ public:\n+  unsigned table_size() const { return STORAGE::table_size(); }\n+  int number_of_entries() const { return _number_of_entries; }\n+\n@@ -128,0 +138,1 @@\n+      _number_of_entries ++;\n@@ -143,0 +154,1 @@\n+      _number_of_entries ++;\n@@ -160,0 +172,1 @@\n+      _number_of_entries ++;\n@@ -174,1 +187,1 @@\n-      if (ALLOC_TYPE == C_HEAP) {\n+      if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n@@ -177,0 +190,1 @@\n+      _number_of_entries --;\n@@ -187,2 +201,3 @@\n-    Node* const* bucket = _table;\n-    while (bucket < &_table[SIZE]) {\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n@@ -200,0 +215,34 @@\n+template<unsigned TABLE_SIZE, typename K, typename V>\n+class FixedResourceHashtableStorage : public ResourceObj {\n+  using Node = ResourceHashtableNode<K, V>;\n+\n+  Node* _table[TABLE_SIZE];\n+protected:\n+  FixedResourceHashtableStorage() : _table() {}\n+  ~FixedResourceHashtableStorage() = default;\n+\n+  constexpr unsigned table_size() const {\n+    return TABLE_SIZE;\n+  }\n+\n+  Node** table() const {\n+    return const_cast<Node**>(_table);\n+  }\n+};\n+\n+template<\n+    typename K, typename V,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+    unsigned SIZE = 256,\n+    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n+    MEMFLAGS MEM_TYPE = mtInternal\n+    >\n+class ResourceHashtable : public ResourceHashtableBase<\n+  FixedResourceHashtableStorage<SIZE, K, V>,\n+    K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE> {\n+  NONCOPYABLE(ResourceHashtable);\n+public:\n+  ResourceHashtable() : ResourceHashtableBase<FixedResourceHashtableStorage<SIZE, K, V>,\n+                                              K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>() {}\n+};\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":89,"deletions":40,"binary":false,"changes":129,"status":"modified"}]}