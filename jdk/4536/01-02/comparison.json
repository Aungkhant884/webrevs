{"files":[{"patch":"@@ -652,1 +652,1 @@\n-      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->size());\n+      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->table_size());\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-      log_info(cds, hashtables)(\"Expanded _has_been_visited table to %d\", _has_been_visited.size());\n+      log_info(cds, hashtables)(\"Expanded _has_been_visited table to %d\", _has_been_visited.table_size());\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,0 +30,42 @@\n+template<\n+    typename K, typename V,\n+    ResourceObj::allocation_type ALLOC_TYPE,\n+    MEMFLAGS MEM_TYPE>\n+class ResizeableResourceHashtableStorage : public ResourceObj {\n+  using Node = ResourceHashtableNode<K, V>;\n+\n+protected:\n+  unsigned _table_size;\n+  Node** _table;\n+\n+  ResizeableResourceHashtableStorage(unsigned table_size) {\n+    _table_size = table_size;\n+    _table = alloc_table(table_size);\n+  }\n+\n+  ~ResizeableResourceHashtableStorage() {\n+    if (ALLOC_TYPE == C_HEAP) {\n+      FREE_C_HEAP_ARRAY(Node*, _table);\n+    }\n+  }\n+\n+  Node** alloc_table(unsigned table_size) {\n+    Node** table;\n+    if (ALLOC_TYPE == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(Node*, table_size, MEM_TYPE);\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(Node*, table_size);\n+    }\n+    memset(table, 0, table_size * sizeof(Node*));\n+    return table;\n+  }\n+\n+  unsigned table_size() const {\n+    return _table_size;\n+  }\n+\n+  Node** table() const {\n+    return _table;\n+  }\n+};\n+\n@@ -38,1 +80,1 @@\n-    ResizeableResourceHashtable<K, V, ALLOC_TYPE, MEM_TYPE, HASH, EQUALS>,\n+    ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TYPE>,\n@@ -40,1 +82,0 @@\n-  unsigned _size;\n@@ -43,1 +84,2 @@\n-  using BASE = ResourceHashtableBase<ResizeableResourceHashtable, K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>;\n+  using BASE = ResourceHashtableBase<ResizeableResourceHashtableStorage<K, V, ALLOC_TYPE, MEM_TYPE>, K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>;\n+  using Node = ResourceHashtableNode<K, V>;\n@@ -47,3 +89,3 @@\n-  : BASE(size),\n-    _size(size), _max_size(max_size) {}\n-  unsigned size_impl() const { return _size; }\n+  : BASE(size), _max_size(max_size) {\n+    assert(size <= 0x3fffffff && max_size <= 0x3fffffff, \"avoid overflow in resize\");\n+  }\n@@ -52,1 +94,2 @@\n-    if (_size >= _max_size) {\n+    unsigned old_size = BASE::_table_size;\n+    if (old_size >= _max_size) {\n@@ -55,4 +98,3 @@\n-    if (BASE::number_of_entries() \/ int(_size) > load_factor) {\n-      int new_size = MIN2<int>(_size * 2, _max_size);\n-      BASE::resize(new_size);\n-      _size = new_size;\n+    if (BASE::number_of_entries() \/ int(old_size) > load_factor) {\n+      unsigned new_size = MIN2<unsigned>(old_size * 2, _max_size);\n+      resize(old_size, new_size);\n@@ -64,0 +106,25 @@\n+\n+  void resize(unsigned old_size, unsigned new_size) {\n+    Node** old_table = BASE::_table;\n+    Node** new_table = BASE::alloc_table(new_size);\n+\n+    Node* const* bucket = old_table;\n+    while (bucket < &old_table[old_size]) {\n+      Node* node = *bucket;\n+      while (node != NULL) {\n+        Node* next = node->_next;\n+        unsigned hash = HASH(node->_key);\n+        unsigned index = hash % new_size;\n+\n+        node->_next = new_table[index];\n+        new_table[index] = node;\n+\n+        node = next;\n+      }\n+      ++bucket;\n+    }\n+\n+    FREE_C_HEAP_ARRAY(Node*, old_table);\n+    BASE::_table = new_table;\n+    BASE::_table_size = new_size;\n+  }\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":78,"deletions":11,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -30,0 +30,16 @@\n+template<typename K, typename V>\n+class ResourceHashtableNode : public ResourceObj {\n+public:\n+  unsigned _hash;\n+  K _key;\n+  V _value;\n+  ResourceHashtableNode* _next;\n+\n+  ResourceHashtableNode(unsigned hash, K const& key, V const& value) :\n+    _hash(hash), _key(key), _value(value), _next(NULL) {}\n+\n+  \/\/ Create a node with a default-constructed value.\n+  ResourceHashtableNode(unsigned hash, K const& key) :\n+    _hash(hash), _key(key), _value(), _next(NULL) {}\n+};\n+\n@@ -31,1 +47,1 @@\n-    typename TABLE_IMPL,\n+    class STORAGE,\n@@ -38,1 +54,2 @@\n-class ResourceHashtableBase : public ResourceObj {\n+class ResourceHashtableBase : public STORAGE {\n+  using Node = ResourceHashtableNode<K, V>;\n@@ -40,17 +57,0 @@\n-\n-  class Node : public ResourceObj {\n-   public:\n-    unsigned _hash;\n-    K _key;\n-    V _value;\n-    Node* _next;\n-\n-    Node(unsigned hash, K const& key, V const& value) :\n-        _hash(hash), _key(key), _value(value), _next(NULL) {}\n-\n-    \/\/ Create a node with a default-constructed value.\n-    Node(unsigned hash, K const& key) :\n-        _hash(hash), _key(key), _value(), _next(NULL) {}\n-\n-  };\n-\n@@ -58,1 +58,5 @@\n-  Node** _table;\n+\n+  Node** bucket_at(unsigned index) const {\n+    Node** t = table();\n+    return &t[index];\n+  }\n@@ -63,2 +67,2 @@\n-    unsigned index = hash % size();\n-    Node** ptr = &_table[index];\n+    unsigned index = hash % table_size();\n+    Node** ptr = bucket_at(index);\n@@ -80,10 +84,2 @@\n-  Node** alloc_table(unsigned size) {\n-    Node** table;\n-    if (ALLOC_TYPE == C_HEAP) {\n-      table = NEW_C_HEAP_ARRAY(Node*, size, MEM_TYPE);\n-    } else {\n-      table = NEW_RESOURCE_ARRAY(Node*, size);\n-    }\n-    memset(table, 0, size * sizeof(Node*));\n-    return table;\n-  }\n+ protected:\n+  Node** table() const { return STORAGE::table(); }\n@@ -92,5 +88,3 @@\n-  ResourceHashtableBase(unsigned size) : _number_of_entries(0) {\n-    \/\/ Don't call size() yet as the TABLE_IMPL constructor\n-    \/\/ hasn't been called yet.\n-    _table = alloc_table(size);\n-  }\n+  ResourceHashtableBase() : _number_of_entries(0) {}\n+\n+  ResourceHashtableBase(unsigned size) : STORAGE(size), _number_of_entries(0) {}\n@@ -99,4 +93,4 @@\n-    if (ALLOC_TYPE == C_HEAP) {\n-      Node* const* bucket = _table;\n-      const unsigned sz = size();\n-      while (bucket < &_table[sz]) {\n+    if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n+      Node* const* bucket = table();\n+      const unsigned sz = table_size();\n+      while (bucket < bucket_at(sz)) {\n@@ -111,1 +105,0 @@\n-      FREE_C_HEAP_ARRAY(Node*, _table);\n@@ -115,1 +108,1 @@\n-  unsigned size() const { return static_cast<const TABLE_IMPL*>(this)->size_impl(); }\n+  unsigned table_size() const { return STORAGE::table_size(); }\n@@ -194,1 +187,1 @@\n-      if (ALLOC_TYPE == C_HEAP) {\n+      if (ALLOC_TYPE == ResourceObj::C_HEAP) {\n@@ -208,3 +201,3 @@\n-    Node* const* bucket = _table;\n-    const unsigned sz = size();\n-    while (bucket < &_table[sz]) {\n+    Node* const* bucket = table();\n+    const unsigned sz = table_size();\n+    while (bucket < bucket_at(sz)) {\n@@ -220,0 +213,1 @@\n+};\n@@ -221,13 +215,3 @@\n- protected:\n-  void resize(unsigned new_size) {\n-    Node** old_table = _table;\n-    _table = alloc_table(new_size);\n-\n-    Node* const* bucket = old_table;\n-    const unsigned old_size = size();\n-    while (bucket < &old_table[old_size]) {\n-      Node* node = *bucket;\n-      while (node != NULL) {\n-        Node* next = node->_next;\n-        unsigned hash = HASH(node->_key);\n-        unsigned index = hash % new_size;\n+template<unsigned TABLE_SIZE, typename K, typename V>\n+class FixedResourceHashtableStorage : public ResourceObj {\n+  using Node = ResourceHashtableNode<K, V>;\n@@ -235,2 +219,5 @@\n-        node->_next = _table[index];\n-        _table[index] = node;\n+  Node* _table[TABLE_SIZE];\n+protected:\n+  FixedResourceHashtableStorage() {\n+    memset(_table, 0, TABLE_SIZE * sizeof(Node*));\n+  }\n@@ -238,4 +225,3 @@\n-        node = next;\n-      }\n-      ++bucket;\n-    }\n+  constexpr unsigned table_size() const {\n+    return TABLE_SIZE;\n+  }\n@@ -243,1 +229,2 @@\n-    FREE_C_HEAP_ARRAY(Node*, old_table);\n+  Node** table() const {\n+    return const_cast<Node**>(_table);\n@@ -256,1 +243,1 @@\n-    ResourceHashtable<K, V, HASH, EQUALS, SIZE, ALLOC_TYPE, MEM_TYPE>,\n+  FixedResourceHashtableStorage<SIZE, K, V>,\n@@ -259,2 +246,1 @@\n-  ResourceHashtable() : ResourceHashtableBase<ResourceHashtable, K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>(SIZE) {}\n-  constexpr unsigned size_impl() const { return SIZE; }\n+  ResourceHashtable() : ResourceHashtableBase<FixedResourceHashtableStorage<SIZE, K, V>, K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>() {}\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":56,"deletions":70,"binary":false,"changes":126,"status":"modified"}]}