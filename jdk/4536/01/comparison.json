{"files":[{"patch":"@@ -57,1 +57,1 @@\n-ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE) {\n+ClassListParser::ClassListParser(const char* file) : _id2klass_table(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {\n@@ -510,1 +510,1 @@\n-bool ClassListParser::is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS) {\n+bool ClassListParser::is_matching_cp_entry(const constantPoolHandle &pool, int cp_index, TRAPS) {\n@@ -646,2 +646,3 @@\n-    InstanceKlass** old_ptr = table()->lookup(id);\n-    if (old_ptr != NULL) {\n+    bool created;\n+    id2klass_table()->put_if_absent(id, ik, &created);\n+    if (!created) {\n@@ -650,1 +651,3 @@\n-    table()->add(id, ik);\n+    if (id2klass_table()->maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded id2klass_table() to %d\", id2klass_table()->size());\n+    }\n@@ -661,1 +664,1 @@\n-  InstanceKlass** klass_ptr = table()->lookup(id);\n+  InstanceKlass** klass_ptr = id2klass_table()->get(id);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -36,0 +36,1 @@\n+class constantPoolHandle;\n@@ -69,1 +70,3 @@\n-  typedef KVHashtable<int, InstanceKlass*, mtInternal> ID2KlassTable;\n+  \/\/ Must be C_HEAP allocated -- we don't want nested resource allocations.\n+  typedef ResizeableResourceHashtable<int, InstanceKlass*,\n+                                      ResourceObj::C_HEAP, mtClassShared> ID2KlassTable;\n@@ -83,1 +86,3 @@\n-  static const int INITIAL_TABLE_SIZE = 1987;\n+  \/\/ Use a small initial size in debug build to test resizing logic\n+  static const int INITIAL_TABLE_SIZE = DEBUG_ONLY(17) NOT_DEBUG(1987);\n+  static const int MAX_TABLE_SIZE = 61333;\n@@ -109,1 +114,1 @@\n-  ID2KlassTable* table() {\n+  ID2KlassTable* id2klass_table() {\n@@ -115,1 +120,1 @@\n-  bool is_matching_cp_entry(constantPoolHandle &pool, int cp_index, TRAPS);\n+  bool is_matching_cp_entry(const constantPoolHandle &pool, int cp_index, TRAPS);\n@@ -164,1 +169,1 @@\n-    if (_id2klass_table.lookup(id) == NULL) {\n+    if (!id2klass_table()->contains(id)) {\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+#include \"services\/memTracker.hpp\"\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-  _has_been_visited.add_if_absent(ref->obj(), read_only, &created);\n+  _has_been_visited.put_if_absent(ref->obj(), read_only, &created);\n@@ -102,2 +102,2 @@\n-    if (_has_been_visited.maybe_grow(MAX_TABLE_SIZE)) {\n-      log_info(cds, hashtables)(\"Expanded _has_been_visited table to %d\", _has_been_visited.table_size());\n+    if (_has_been_visited.maybe_grow()) {\n+      log_info(cds, hashtables)(\"Expanded _has_been_visited table to %d\", _has_been_visited.size());\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-#include \"utilities\/hashtable.inline.hpp\"\n@@ -36,0 +35,1 @@\n+#include \"utilities\/resizeableResourceHash.hpp\"\n@@ -396,1 +396,1 @@\n-  UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE) {}\n+  UniqueMetaspaceClosure() : _has_been_visited(INITIAL_TABLE_SIZE, MAX_TABLE_SIZE) {}\n@@ -399,1 +399,2 @@\n-  KVHashtable<address, bool, mtInternal> _has_been_visited;\n+  ResizeableResourceHashtable<address, bool, ResourceObj::C_HEAP,\n+                              mtClassShared> _has_been_visited;\n","filename":"src\/hotspot\/share\/memory\/metaspaceClosure.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n+#define SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n+\n+#include \"utilities\/resourceHash.hpp\"\n+\n+template<\n+    typename K, typename V,\n+    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n+    MEMFLAGS MEM_TYPE = mtInternal,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>\n+    >\n+class ResizeableResourceHashtable : public ResourceHashtableBase<\n+    ResizeableResourceHashtable<K, V, ALLOC_TYPE, MEM_TYPE, HASH, EQUALS>,\n+    K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE> {\n+  unsigned _size;\n+  unsigned _max_size;\n+\n+  using BASE = ResourceHashtableBase<ResizeableResourceHashtable, K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>;\n+\n+public:\n+  ResizeableResourceHashtable(unsigned size, unsigned max_size = 0)\n+  : BASE(size),\n+    _size(size), _max_size(max_size) {}\n+  unsigned size_impl() const { return _size; }\n+\n+  bool maybe_grow(int load_factor = 8) {\n+    if (_size >= _max_size) {\n+      return false;\n+    }\n+    if (BASE::number_of_entries() \/ int(_size) > load_factor) {\n+      int new_size = MIN2<int>(_size * 2, _max_size);\n+      BASE::resize(new_size);\n+      _size = new_size;\n+      return true;\n+    } else {\n+      return false;\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_RESIZEABLERESOURCEHASH_HPP\n","filename":"src\/hotspot\/share\/utilities\/resizeableResourceHash.hpp","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+    typename TABLE_IMPL,\n@@ -32,9 +33,4 @@\n-    \/\/ xlC does not compile this:\n-    \/\/ http:\/\/stackoverflow.com\/questions\/8532961\/template-argument-of-type-that-is-defined-by-inner-typedef-from-other-template-c\n-    \/\/typename ResourceHashtableFns<K>::hash_fn   HASH   = primitive_hash<K>,\n-    \/\/typename ResourceHashtableFns<K>::equals_fn EQUALS = primitive_equals<K>,\n-    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n-    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n-    unsigned SIZE = 256,\n-    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n-    MEMFLAGS MEM_TYPE = mtInternal\n+    unsigned (*HASH)  (K const&),\n+    bool     (*EQUALS)(K const&, K const&),\n+    ResourceObj::allocation_type ALLOC_TYPE,\n+    MEMFLAGS MEM_TYPE\n@@ -42,1 +38,1 @@\n-class ResourceHashtable : public ResourceObj {\n+class ResourceHashtableBase : public ResourceObj {\n@@ -61,1 +57,2 @@\n-  Node* _table[SIZE];\n+  int _number_of_entries;\n+  Node** _table;\n@@ -66,1 +63,1 @@\n-    unsigned index = hash % SIZE;\n+    unsigned index = hash % size();\n@@ -80,1 +77,12 @@\n-        const_cast<ResourceHashtable*>(this)->lookup_node(hash, key));\n+        const_cast<ResourceHashtableBase*>(this)->lookup_node(hash, key));\n+  }\n+\n+  Node** alloc_table(unsigned size) {\n+    Node** table;\n+    if (ALLOC_TYPE == C_HEAP) {\n+      table = NEW_C_HEAP_ARRAY(Node*, size, MEM_TYPE);\n+    } else {\n+      table = NEW_RESOURCE_ARRAY(Node*, size);\n+    }\n+    memset(table, 0, size * sizeof(Node*));\n+    return table;\n@@ -84,1 +92,5 @@\n-  ResourceHashtable() { memset(_table, 0, SIZE * sizeof(Node*)); }\n+  ResourceHashtableBase(unsigned size) : _number_of_entries(0) {\n+    \/\/ Don't call size() yet as the TABLE_IMPL constructor\n+    \/\/ hasn't been called yet.\n+    _table = alloc_table(size);\n+  }\n@@ -86,1 +98,1 @@\n-  ~ResourceHashtable() {\n+  ~ResourceHashtableBase() {\n@@ -89,1 +101,2 @@\n-      while (bucket < &_table[SIZE]) {\n+      const unsigned sz = size();\n+      while (bucket < &_table[sz]) {\n@@ -98,0 +111,1 @@\n+      FREE_C_HEAP_ARRAY(Node*, _table);\n@@ -101,0 +115,3 @@\n+  unsigned size() const { return static_cast<const TABLE_IMPL*>(this)->size_impl(); }\n+  int number_of_entries() const { return _number_of_entries; }\n+\n@@ -128,0 +145,1 @@\n+      _number_of_entries ++;\n@@ -143,0 +161,1 @@\n+      _number_of_entries ++;\n@@ -160,0 +179,1 @@\n+      _number_of_entries ++;\n@@ -177,0 +197,1 @@\n+      _number_of_entries --;\n@@ -188,1 +209,2 @@\n-    while (bucket < &_table[SIZE]) {\n+    const unsigned sz = size();\n+    while (bucket < &_table[sz]) {\n@@ -198,0 +220,25 @@\n+\n+ protected:\n+  void resize(unsigned new_size) {\n+    Node** old_table = _table;\n+    _table = alloc_table(new_size);\n+\n+    Node* const* bucket = old_table;\n+    const unsigned old_size = size();\n+    while (bucket < &old_table[old_size]) {\n+      Node* node = *bucket;\n+      while (node != NULL) {\n+        Node* next = node->_next;\n+        unsigned hash = HASH(node->_key);\n+        unsigned index = hash % new_size;\n+\n+        node->_next = _table[index];\n+        _table[index] = node;\n+\n+        node = next;\n+      }\n+      ++bucket;\n+    }\n+\n+    FREE_C_HEAP_ARRAY(Node*, old_table);\n+  }\n@@ -200,0 +247,15 @@\n+template<\n+    typename K, typename V,\n+    unsigned (*HASH)  (K const&)           = primitive_hash<K>,\n+    bool     (*EQUALS)(K const&, K const&) = primitive_equals<K>,\n+    unsigned SIZE = 256,\n+    ResourceObj::allocation_type ALLOC_TYPE = ResourceObj::RESOURCE_AREA,\n+    MEMFLAGS MEM_TYPE = mtInternal\n+    >\n+class ResourceHashtable : public ResourceHashtableBase<\n+    ResourceHashtable<K, V, HASH, EQUALS, SIZE, ALLOC_TYPE, MEM_TYPE>,\n+    K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE> {\n+public:\n+  ResourceHashtable() : ResourceHashtableBase<ResourceHashtable, K, V, HASH, EQUALS, ALLOC_TYPE, MEM_TYPE>(SIZE) {}\n+  constexpr unsigned size_impl() const { return SIZE; }\n+};\n","filename":"src\/hotspot\/share\/utilities\/resourceHash.hpp","additions":80,"deletions":18,"binary":false,"changes":98,"status":"modified"}]}