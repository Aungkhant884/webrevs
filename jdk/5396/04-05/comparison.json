{"files":[{"patch":"@@ -65,0 +65,1 @@\n+import static java.time.LocalTime.MILLIS_PER_SECOND;\n@@ -1150,1 +1151,1 @@\n-                case MILLIS    -> Math.subtractExact(end.toEpochMilli(), toEpochMilli());\n+                case MILLIS    -> millisUntil(end);\n@@ -1174,0 +1175,6 @@\n+    private long millisUntil(Instant end) {\n+        long secsDiff = Math.subtractExact(end.seconds, seconds);\n+        long totalMillis = Math.multiplyExact(secsDiff, MILLIS_PER_SECOND);\n+        return Math.addExact(totalMillis, (end.nanos - nanos) \/ 1000_000);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/time\/Instant.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -185,0 +185,4 @@\n+    \/**\n+     * Milliseconds per second.\n+     *\/\n+    static final long MILLIS_PER_SECOND = 1000L;\n@@ -188,1 +192,1 @@\n-    static final long MILLIS_PER_DAY = SECONDS_PER_DAY * 1000L;\n+    static final long MILLIS_PER_DAY = MILLIS_PER_SECOND * SECONDS_PER_DAY;\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalTime.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -113,0 +113,10 @@\n+\n+    \/**\n+     * Checks whether Instant.until() returning milliseconds does not throw\n+     * an ArithmeticException for very large\/small Instants\n+     *\/\n+    @Test\n+    public void test_millisUntil() {\n+        assertEquals(Instant.MIN.until(Instant.MIN.plusSeconds(1), ChronoUnit.MILLIS), 1000L);\n+        assertEquals(Instant.MAX.plusSeconds(-1).until(Instant.MAX, ChronoUnit.MILLIS), 1000L);\n+    }\n","filename":"test\/jdk\/java\/time\/test\/java\/time\/TestInstant.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}