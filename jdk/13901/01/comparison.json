{"files":[{"patch":"@@ -4136,0 +4136,28 @@\n+\/\/ If a post or main loop is removed due to an assert predicate, the opaque that guards the loop is not needed anymore\n+void PhaseIdealLoop::eliminate_useless_zero_trip_guard() {\n+  if (_zero_trip_guard_opaque_nodes.size() == 0) {\n+    return;\n+  }\n+  Unique_Node_List useful_zero_trip_guard_opaques_nodes;\n+  for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n+    IdealLoopTree* lpt = iter.current();\n+    if (lpt->_child == nullptr && lpt->is_counted()) {\n+      CountedLoopNode* head = lpt->_head->as_CountedLoop();\n+      Node* opaque = head->is_canonical_loop_entry();\n+      if (opaque != nullptr) {\n+        useful_zero_trip_guard_opaques_nodes.push(opaque);\n+      }\n+    }\n+  }\n+  for (uint i = 0; i < _zero_trip_guard_opaque_nodes.size(); ++i) {\n+    Node* opaque = _zero_trip_guard_opaque_nodes.at(i);\n+    DEBUG_ONLY(CountedLoopNode* loop = ((OpaqueZeroTripGuardNode*) opaque)->guarded_loop());\n+    if (!useful_zero_trip_guard_opaques_nodes.member(opaque)) {\n+      assert(loop == nullptr, \"\");\n+      this->_igvn.replace_node(opaque, opaque->in(1));\n+    } else {\n+      assert(loop != nullptr, \"\");\n+    }\n+  }\n+}\n+\n@@ -4424,0 +4452,2 @@\n+  eliminate_useless_zero_trip_guard();\n+\n@@ -6148,0 +6178,5 @@\n+\n+  if (!_verify_only && n->Opcode() == Op_OpaqueZeroTripGuard) {\n+    _zero_trip_guard_opaque_nodes.push(n);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -900,0 +900,1 @@\n+  Node_List _zero_trip_guard_opaque_nodes;\n@@ -1426,0 +1427,1 @@\n+  void eliminate_useless_zero_trip_guard();\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/loopnode.hpp\"\n@@ -57,0 +58,33 @@\n+#ifdef ASSERT\n+CountedLoopNode* OpaqueZeroTripGuardNode::guarded_loop() const {\n+  Node* cmp = unique_out();\n+  assert(cmp->Opcode() == Op_CmpI, \"\");\n+  Node* bol = cmp->unique_out();\n+  assert(bol->Opcode() == Op_Bool, \"\");\n+  Node* iff = bol->unique_out();\n+  assert(iff->is_If(), \"\");\n+  ResourceMark rm;\n+  Unique_Node_List wq;\n+  wq.push(iff);\n+  for (uint i = 0; i < wq.size(); ++i) {\n+    Node* nn = wq.at(i);\n+    for (DUIterator_Fast imax, i = nn->fast_outs(imax); i < imax; i++) {\n+      Node* u = nn->fast_out(i);\n+      if (u->is_OuterStripMinedLoop()) {\n+        wq.push(u);\n+      }\n+      if (u->is_CountedLoop() && u->as_CountedLoop()->is_canonical_loop_entry() == this) {\n+        return u->as_CountedLoop();\n+      }\n+      if (u->is_Region()) {\n+        continue;\n+      }\n+      if (u->is_CFG()) {\n+        wq.push(u);\n+      }\n+    }\n+  }\n+  return nullptr;\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -82,0 +82,2 @@\n+\n+  DEBUG_ONLY(CountedLoopNode* guarded_loop() const);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8305189\n+ * @summary C2 failed \"assert(_outcnt==1) failed: not unique\"\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestZeroTripGuardShared TestZeroTripGuardShared\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestZeroTripGuardShared {\n+    static double dFld1;\n+    static int iArrFld[];\n+\n+    public static void main(String[] strArr) throws Exception {\n+        Thread thread = new Thread() {\n+                public void run() {\n+                    test();\n+                }\n+            };\n+        \/\/ Give thread some time to trigger compilation\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(500));\n+    }\n+\n+    static void test() {\n+        int i5 = 2, i8 = 2, i9, i11, i12;\n+        while (i8 < 5) {\n+            for (i9 = i8; 6 > i9; i9++) {\n+                for (i11 = 1; i11 > i9; i11 -= 2) {\n+                    try {\n+                        i12 = iArrFld[i11];\n+                    } catch (ArithmeticException a_e) {\n+                    }\n+                    i5 += dFld1;\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestZeroTripGuardShared.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}