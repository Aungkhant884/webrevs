{"files":[{"patch":"@@ -327,1 +327,1 @@\n-    DEPS := java.base-libs exploded-image buildtools-jdk, \\\n+    DEPS := java.base-libs exploded-image, \\\n@@ -386,1 +386,1 @@\n-    DEPS := buildtools-jdk java.base-java java.security.jgss-java java.security.jgss-libs, \\\n+    DEPS := java.base-java java.security.jgss-java java.security.jgss-libs, \\\n@@ -391,1 +391,1 @@\n-    DEPS := buildtools-jdk gensrc, \\\n+    DEPS := gensrc, \\\n@@ -511,1 +511,1 @@\n-    DEPS :=  docs-jdk buildtools-jdk, \\\n+    DEPS :=  docs-jdk, \\\n@@ -517,1 +517,1 @@\n-    DEPS := docs-jdk-specs buildtools-jdk, \\\n+    DEPS := docs-jdk-specs, \\\n","filename":"make\/Main.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,2 +85,0 @@\n-TOOL_MAKEZIPREPRODUCIBLE = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n-    build.tools.makezipreproducible.MakeZipReproducible\n","filename":"make\/ToolsJdk.gmk","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,3 +29,0 @@\n-# Depends on build tools for MakeZipReproducible\n-include ..\/ToolsJdk.gmk\n-\n@@ -140,2 +137,0 @@\n-  # For reproducible builds set the zip access & modify times to SOURCE_DATE_EPOCH\n-  # by using a ziptmp folder to generate final zip from using MakeZipReproducible.\n@@ -171,12 +166,1 @@\n-\t) true\n-        ifeq ($(ENABLE_REPRODUCIBLE_BUILD), true)\n-\t    $$(call ExecuteWithLog, \\\n-\t\t$$(SUPPORT_OUTPUTDIR)\/makezipreproducible\/$$(patsubst $$(OUTPUTDIR)\/%,%, $$@), \\\n-\t\t($(RM) $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip && \\\n-\t\t $(MKDIR) -p $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1 && \\\n-\t\t $(TOOL_MAKEZIPREPRODUCIBLE) -f $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip \\\n-\t\t\t \t\t     -t $(SOURCE_DATE_EPOCH) $$@ && \\\n-\t\t $(RM) $$@ && \\\n-\t\t $(MV) $$(SUPPORT_OUTPUTDIR)\/ziptmp\/$1\/tmp.zip $$@ \\\n-\t\t))\n-        endif\n+\t) true \\\n","filename":"make\/common\/ZipArchive.gmk","additions":2,"deletions":18,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,236 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package build.tools.makezipreproducible;\n-\n-import java.io.*;\n-import java.nio.file.*;\n-import java.nio.file.attribute.BasicFileAttributes;\n-import java.nio.channels.Channels;\n-import java.nio.channels.FileChannel;\n-import java.util.*;\n-import java.util.zip.ZipEntry;\n-import java.util.zip.ZipException;\n-import java.util.zip.ZipFile;\n-import java.util.zip.ZipInputStream;\n-import java.util.zip.ZipOutputStream;\n-\n-\/**\n- * Generate a zip file in a \"reproducible\" manner from the input zip file.\n- * Standard zip tools rely on OS file list querying whose ordering can vary\n- * by platform architecture, this class ensures the zip entries are ordered\n- * and also supports SOURCE_DATE_EPOCH timestamps.\n- *\/\n-public class MakeZipReproducible {\n-    String input_file = null;\n-    String fname = null;\n-    String zname = \"\";\n-    long   timestamp = -1L;\n-    boolean verbose = false;\n-\n-    \/\/ Keep a sorted Set of ZipEntrys to be processed, so that the zip is reproducible\n-    SortedMap<String, ZipEntry> entries  = new TreeMap<String, ZipEntry>();\n-\n-    private boolean ok;\n-\n-    public MakeZipReproducible() {\n-    }\n-\n-    public synchronized boolean run(String args[]) {\n-        ok = true;\n-        if (!parseArgs(args)) {\n-            return false;\n-        }\n-        try {\n-            zname = fname.replace(File.separatorChar, '\/');\n-            if (zname.startsWith(\".\/\")) {\n-                zname = zname.substring(2);\n-            }\n-\n-            if (verbose) System.out.println(\"Input zip file: \" + input_file);\n-\n-            File inFile  = new File(input_file);\n-            if (!inFile.exists()) {\n-                error(\"Input zip file does not exist\");\n-                ok = false;\n-            } else {\n-                File zipFile = new File(fname);\n-                \/\/ Check archive to create does not exist\n-                if (!zipFile.exists()) {\n-                    \/\/ Process input ZipEntries\n-                    ok = processInputEntries(inFile);\n-                    if (ok) {\n-                        try (FileOutputStream out = new FileOutputStream(fname)) {\n-                            ok = create(inFile, new BufferedOutputStream(out, 4096));\n-                        }\n-                    } else {\n-                    }\n-                } else {\n-                    error(\"Target zip file \"+fname+\" already exists.\");\n-                    ok = false;\n-                }\n-            }\n-        } catch (IOException e) {\n-            fatalError(e);\n-            ok = false;\n-        } catch (Error ee) {\n-            ee.printStackTrace();\n-            ok = false;\n-        } catch (Throwable t) {\n-            t.printStackTrace();\n-            ok = false;\n-        }\n-        return ok;\n-    }\n-\n-    boolean parseArgs(String args[]) {\n-        try {\n-            boolean parsingIncludes = false;\n-            boolean parsingExcludes = false;\n-            int count = 0;\n-            while(count < args.length) {\n-                if (args[count].startsWith(\"-\")) {\n-                    String flag = args[count].substring(1);\n-                    switch (flag.charAt(0)) {\n-                    case 'f':\n-                        fname = args[++count];\n-                        break;\n-                    case 't':\n-                        \/\/ SOURCE_DATE_EPOCH timestamp specified\n-                        timestamp = Long.parseLong(args[++count]) * 1000;\n-                        break;\n-                    case 'v':\n-                        verbose = true;\n-                        break;\n-                    default:\n-                        error(String.format(\"Illegal option -%s\", String.valueOf(flag.charAt(0))));\n-                        usageError();\n-                        return false;\n-                    }\n-                } else {\n-                    \/\/ input zip file\n-                    if (input_file != null) {\n-                        error(\"Input zip file already specified\");\n-                        usageError();\n-                        return false;\n-                    }\n-                    input_file = args[count];\n-                }\n-                count++;\n-            }\n-        } catch (ArrayIndexOutOfBoundsException e) {\n-            usageError();\n-            return false;\n-        } catch (NumberFormatException e) {\n-            usageError();\n-            return false;\n-        }\n-        if (fname == null) {\n-            error(\"-f <outputArchiveName> must be specified\");\n-            usageError();\n-            return false;\n-        }\n-        \/\/ If no files specified then default to current directory\n-        if (input_file == null) {\n-            error(\"No input zip file specified\");\n-            usageError();\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    \/\/ Process input zip file and add to sorted entries set\n-    boolean processInputEntries(File inFile) throws IOException {\n-        try (FileInputStream fis = new FileInputStream(inFile);\n-             ZipInputStream  zis = new ZipInputStream(fis)) {\n-            ZipEntry entry;\n-            while ((entry = zis.getNextEntry()) != null) {\n-                entries.put(entry.getName(), entry);\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    \/\/ Create new zip from entries\n-    boolean create(File inFile, OutputStream out) throws IOException\n-    {\n-        try (ZipFile zipFile = new ZipFile(inFile);\n-             ZipOutputStream zos = new ZipOutputStream(out)) {\n-            for (Map.Entry<String, ZipEntry> entry : entries.entrySet()) {\n-                ZipEntry zipEntry = entry.getValue();\n-                if (zipEntry.getSize() > 0) {\n-                    try (InputStream eis = zipFile.getInputStream(zipEntry)) {\n-                        addEntry(zos, zipEntry, eis);\n-                    }\n-                } else {\n-                    addEntry(zos, zipEntry, null);\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n-    \/\/ Add Entry and data to Zip\n-    void addEntry(ZipOutputStream zos, ZipEntry entry, InputStream entryInputStream) throws IOException {\n-        if (verbose) {\n-            System.out.println(\"Adding: \"+entry.getName());\n-        }\n-\n-        \/\/ Set to specified timestamp if set otherwise leave as original lastModified time\n-        if (timestamp != -1L) {\n-            entry.setTime(timestamp);\n-        }\n-\n-        zos.putNextEntry(entry);\n-        if (entry.getSize() > 0 && entryInputStream != null) {\n-            entryInputStream.transferTo(zos);\n-        }\n-        zos.closeEntry();\n-    }\n-\n-    void usageError() {\n-        error(\n-        \"Usage: MakeZipReproducible [-v] [-t <SOURCE_DATE_EPOCH>] -f <output_zip_file> <input_zip_file>\\n\" +\n-        \"Options:\\n\" +\n-        \"   -v  verbose output\\n\" +\n-        \"   -f  specify archive file name to create\\n\" +\n-        \"   -t  specific SOURCE_DATE_EPOCH value to use for timestamps\\n\" +\n-        \"   input_zip_file re-written as a reproducible zip output_zip_file.\\n\");\n-    }\n-\n-    void fatalError(Exception e) {\n-        e.printStackTrace();\n-    }\n-\n-    protected void error(String s) {\n-        System.err.println(s);\n-    }\n-\n-    public static void main(String args[]) {\n-        MakeZipReproducible z = new MakeZipReproducible();\n-        System.exit(z.run(args) ? 0 : 1);\n-    }\n-}\n-\n","filename":"make\/jdk\/src\/classes\/build\/tools\/makezipreproducible\/MakeZipReproducible.java","additions":0,"deletions":236,"binary":false,"changes":236,"status":"deleted"}]}