{"files":[{"patch":"@@ -1775,2 +1775,7 @@\n-  ShouldNotReachHere();\n-  return -1;\n+  \/\/ This is implemented using aarch64_enc_java_to_runtime as above.\n+  CodeBlob *cb = CodeCache::find_blob(_entry_point);\n+  if (cb) {\n+    return 1 * NativeInstruction::instruction_size;\n+  } else {\n+    return 6 * NativeInstruction::instruction_size;\n+  }\n@@ -16047,0 +16052,15 @@\n+instruct CallNativeDirect(method meth)\n+%{\n+  match(CallNative);\n+\n+  effect(USE meth);\n+\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"CALL, native $meth\" %}\n+\n+  ins_encode( aarch64_enc_java_to_runtime(meth) );\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -357,0 +357,5 @@\n+\n+  if (jfa->saved_fp_address()) {\n+    update_map_with_saved_link(map, jfa->saved_fp_address());\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -317,1 +317,1 @@\n-  RegSet                _fp_regs;\n+  FloatRegSet           _fp_regs;\n@@ -330,1 +330,1 @@\n-          _fp_regs += RegSet::of((Register)vm_reg->as_FloatRegister());\n+          _fp_regs += FloatRegSet::of(vm_reg->as_FloatRegister());\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,0 +34,3 @@\n+  \/\/ (Optional) location of saved FP register, which GCs want to inspect\n+  intptr_t** volatile _saved_fp_address;\n+\n@@ -47,0 +50,1 @@\n+    _saved_fp_address = NULL;\n@@ -65,0 +69,2 @@\n+\n+    _saved_fp_address = src->_saved_fp_address;\n@@ -75,0 +81,2 @@\n+  intptr_t** saved_fp_address(void) const        { return _saved_fp_address; }\n+\n@@ -78,0 +86,1 @@\n+  static ByteSize saved_fp_address_offset()      { return byte_offset_of(JavaFrameAnchor, _saved_fp_address); }\n","filename":"src\/hotspot\/cpu\/aarch64\/javaFrameAnchor_aarch64.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -321,0 +321,2 @@\n+\n+  str(zr, Address(rthread, JavaThread::saved_fp_address_offset()));\n@@ -5296,0 +5298,2 @@\n+  \/\/ Make sure that native code does not change SVE vector length.\n+  if (!UseSVE) return;\n@@ -5297,1 +5301,0 @@\n-  assert(UseSVE > 0, \"should only be used for SVE\");\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -477,2 +477,2 @@\n-  void push_fp(RegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n-  void pop_fp(RegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n+  void push_fp(FloatRegSet regs, Register stack) { if (regs.bits()) push_fp(regs.bits(), stack); }\n+  void pop_fp(FloatRegSet regs, Register stack) { if (regs.bits()) pop_fp(regs.bits(), stack); }\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -66,4 +66,0 @@\n-\n-  \/\/ Return the bit which represents this register.  This is intended\n-  \/\/ to be ORed into a bitmask: for usage see class RegSet below.\n-  uint64_t bit(bool should_set = true) const { return should_set ? 1 << encoding() : 0; }\n@@ -307,1 +303,1 @@\n-class RegSetIterator;\n+template <class RegImpl = Register> class RegSetIterator;\n@@ -310,1 +306,2 @@\n-class RegSet {\n+template <class RegImpl>\n+class AbstractRegSet {\n@@ -313,1 +310,1 @@\n-  RegSet(uint32_t bitset) : _bitset(bitset) { }\n+  AbstractRegSet(uint32_t bitset) : _bitset(bitset) { }\n@@ -317,1 +314,1 @@\n-  RegSet() : _bitset(0) { }\n+  AbstractRegSet() : _bitset(0) { }\n@@ -319,1 +316,1 @@\n-  RegSet(Register r1) : _bitset(r1->bit()) { }\n+  AbstractRegSet(RegImpl r1) : _bitset(1 << r1->encoding()) { }\n@@ -321,2 +318,2 @@\n-  RegSet operator+(const RegSet aSet) const {\n-    RegSet result(_bitset | aSet._bitset);\n+  AbstractRegSet operator+(const AbstractRegSet aSet) const {\n+    AbstractRegSet result(_bitset | aSet._bitset);\n@@ -326,2 +323,2 @@\n-  RegSet operator-(const RegSet aSet) const {\n-    RegSet result(_bitset & ~aSet._bitset);\n+  AbstractRegSet operator-(const AbstractRegSet aSet) const {\n+    AbstractRegSet result(_bitset & ~aSet._bitset);\n@@ -331,1 +328,1 @@\n-  RegSet &operator+=(const RegSet aSet) {\n+  AbstractRegSet &operator+=(const AbstractRegSet aSet) {\n@@ -336,1 +333,1 @@\n-  RegSet &operator-=(const RegSet aSet) {\n+  AbstractRegSet &operator-=(const AbstractRegSet aSet) {\n@@ -341,2 +338,2 @@\n-  static RegSet of(Register r1) {\n-    return RegSet(r1);\n+  static AbstractRegSet of(RegImpl r1) {\n+    return AbstractRegSet(r1);\n@@ -345,1 +342,1 @@\n-  static RegSet of(Register r1, Register r2) {\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2) {\n@@ -349,1 +346,1 @@\n-  static RegSet of(Register r1, Register r2, Register r3) {\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3) {\n@@ -353,1 +350,1 @@\n-  static RegSet of(Register r1, Register r2, Register r3, Register r4) {\n+  static AbstractRegSet of(RegImpl r1, RegImpl r2, RegImpl r3, RegImpl r4) {\n@@ -357,1 +354,1 @@\n-  static RegSet range(Register start, Register end) {\n+  static AbstractRegSet range(RegImpl start, RegImpl end) {\n@@ -363,1 +360,1 @@\n-    return RegSet(bits);\n+    return AbstractRegSet(bits);\n@@ -370,4 +367,1 @@\n-  Register first() {\n-    uint32_t first = _bitset & -_bitset;\n-    return first ? as_Register(exact_log2(first)) : noreg;\n-  }\n+  RegImpl first();\n@@ -377,1 +371,1 @@\n-  friend class RegSetIterator;\n+  friend class RegSetIterator<RegImpl>;\n@@ -379,1 +373,1 @@\n-  RegSetIterator begin();\n+  RegSetIterator<RegImpl> begin();\n@@ -382,0 +376,4 @@\n+typedef AbstractRegSet<Register> RegSet;\n+typedef AbstractRegSet<FloatRegister> FloatRegSet;\n+\n+template <class RegImpl>\n@@ -383,1 +381,1 @@\n-  RegSet _regs;\n+  AbstractRegSet<RegImpl> _regs;\n@@ -386,1 +384,1 @@\n-  RegSetIterator(RegSet x): _regs(x) {}\n+  RegSetIterator(AbstractRegSet<RegImpl> x): _regs(x) {}\n@@ -390,2 +388,2 @@\n-    Register r = _regs.first();\n-    if (r != noreg)\n+    RegImpl r = _regs.first();\n+    if (r->is_valid())\n@@ -403,1 +401,1 @@\n-  Register operator*() {\n+  RegImpl operator*() {\n@@ -408,2 +406,15 @@\n-inline RegSetIterator RegSet::begin() {\n-  return RegSetIterator(*this);\n+template <class RegImpl>\n+inline RegSetIterator<RegImpl> AbstractRegSet<RegImpl>::begin() {\n+  return RegSetIterator<RegImpl>(*this);\n+}\n+\n+template <>\n+inline Register AbstractRegSet<Register>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_Register(exact_log2(first)) : noreg;\n+}\n+\n+template <>\n+inline FloatRegister AbstractRegSet<FloatRegister>::first() {\n+  uint32_t first = _bitset & -_bitset;\n+  return first ? as_FloatRegister(exact_log2(first)) : fnoreg;\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":46,"deletions":35,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1858,4 +1858,1 @@\n-  if (UseSVE > 0) {\n-    \/\/ Make sure that jni code does not change SVE vector length.\n-    __ verify_sve_vector_length();\n-  }\n+  __ verify_sve_vector_length();\n@@ -3074,0 +3071,31 @@\n+\/\/ ---------------------------------------------------------------\n+\n+class NativeInvokerGenerator : public StubCodeGenerator {\n+  address _call_target;\n+  int _shadow_space_bytes;\n+\n+  const GrowableArray<VMReg>& _input_registers;\n+  const GrowableArray<VMReg>& _output_registers;\n+public:\n+  NativeInvokerGenerator(CodeBuffer* buffer,\n+                         address call_target,\n+                         int shadow_space_bytes,\n+                         const GrowableArray<VMReg>& input_registers,\n+                         const GrowableArray<VMReg>& output_registers)\n+   : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n+     _call_target(call_target),\n+     _shadow_space_bytes(shadow_space_bytes),\n+     _input_registers(input_registers),\n+     _output_registers(output_registers) {}\n+  void generate();\n+\n+private:\n+#ifdef ASSERT\n+  bool target_uses_register(VMReg reg) {\n+    return _input_registers.contains(reg) || _output_registers.contains(reg);\n+  }\n+#endif\n+};\n+\n+static const int native_invoker_code_size = 1024;\n+\n@@ -3075,4 +3103,132 @@\n-                                           int shadow_space_bytes,\n-                                           const GrowableArray<VMReg>& input_registers,\n-                                           const GrowableArray<VMReg>& output_registers) {\n-  return NULL;\n+                                               int shadow_space_bytes,\n+                                               const GrowableArray<VMReg>& input_registers,\n+                                               const GrowableArray<VMReg>& output_registers) {\n+  BufferBlob* _invoke_native_blob =\n+    BufferBlob::create(\"nep_invoker_blob\", native_invoker_code_size);\n+  if (_invoke_native_blob == NULL)\n+    return NULL; \/\/ allocation failure\n+\n+  CodeBuffer code(_invoke_native_blob);\n+  NativeInvokerGenerator g(&code, call_target, shadow_space_bytes, input_registers, output_registers);\n+  g.generate();\n+  code.log_section_sizes(\"nep_invoker_blob\");\n+\n+  return _invoke_native_blob;\n+}\n+\n+void NativeInvokerGenerator::generate() {\n+  assert(!(target_uses_register(rscratch1->as_VMReg())\n+           || target_uses_register(rscratch2->as_VMReg())\n+           || target_uses_register(rthread->as_VMReg())),\n+         \"Register conflict\");\n+\n+  MacroAssembler* masm = _masm;\n+\n+  __ set_last_Java_frame(sp, noreg, lr, rscratch1);\n+\n+  __ enter();\n+\n+  \/\/ Store a pointer to the previous R29 (RFP) saved on the stack as it\n+  \/\/ may contain an oop if PreserveFramePointer is off. This value is\n+  \/\/ retrieved later by frame::sender_for_entry_frame() when the stack\n+  \/\/ is walked.\n+  __ mov(rscratch1, sp);\n+  __ str(rscratch1, Address(rthread, JavaThread::saved_fp_address_offset()));\n+\n+  \/\/ State transition\n+  __ mov(rscratch1, _thread_in_native);\n+  __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));\n+  __ stlrw(rscratch1, rscratch2);\n+\n+  assert(_shadow_space_bytes == 0, \"not expecting shadow space on AArch64\");\n+\n+  rt_call(masm, _call_target);\n+\n+  __ mov(rscratch1, _thread_in_native_trans);\n+  __ strw(rscratch1, Address(rthread, JavaThread::thread_state_offset()));\n+\n+  \/\/ Force this write out before the read below\n+  __ membar(Assembler::LoadLoad | Assembler::LoadStore |\n+            Assembler::StoreLoad | Assembler::StoreStore);\n+\n+  __ verify_sve_vector_length();\n+\n+  Label L_after_safepoint_poll;\n+  Label L_safepoint_poll_slow_path;\n+\n+  __ safepoint_poll(L_safepoint_poll_slow_path, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+\n+  __ ldrw(rscratch1, Address(rthread, JavaThread::suspend_flags_offset()));\n+  __ cbnzw(rscratch1, L_safepoint_poll_slow_path);\n+\n+  __ bind(L_after_safepoint_poll);\n+\n+  \/\/ change thread state\n+  __ mov(rscratch1, _thread_in_Java);\n+  __ lea(rscratch2, Address(rthread, JavaThread::thread_state_offset()));\n+  __ stlrw(rscratch1, rscratch2);\n+\n+  __ block_comment(\"reguard stack check\");\n+  Label L_reguard;\n+  Label L_after_reguard;\n+  __ ldrb(rscratch1, Address(rthread, JavaThread::stack_guard_state_offset()));\n+  __ cmpw(rscratch1, StackOverflow::stack_guard_yellow_reserved_disabled);\n+  __ br(Assembler::EQ, L_reguard);\n+  __ bind(L_after_reguard);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+  __ ret(lr);\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_safepoint_poll_slow_path\");\n+  __ bind(L_safepoint_poll_slow_path);\n+\n+  \/\/ Need to save the native result registers around any runtime calls.\n+  RegSet spills;\n+  FloatRegSet fp_spills;\n+  for (int i = 0; i < _output_registers.length(); i++) {\n+    VMReg output = _output_registers.at(i);\n+    if (output->is_Register()) {\n+      spills += RegSet::of(output->as_Register());\n+    } else if (output->is_FloatRegister()) {\n+      fp_spills += FloatRegSet::of(output->as_FloatRegister());\n+    }\n+  }\n+\n+  __ push(spills, sp);\n+  __ push_fp(fp_spills, sp);\n+\n+  __ mov(c_rarg0, rthread);\n+  assert(frame::arg_reg_save_area_bytes == 0, \"not expecting frame reg save area\");\n+  __ lea(rscratch1, RuntimeAddress(CAST_FROM_FN_PTR(address, JavaThread::check_special_condition_for_native_trans)));\n+  __ blr(rscratch1);\n+\n+  __ pop_fp(fp_spills, sp);\n+  __ pop(spills, sp);\n+\n+  __ b(L_after_safepoint_poll);\n+  __ block_comment(\"} L_safepoint_poll_slow_path\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ block_comment(\"{ L_reguard\");\n+  __ bind(L_reguard);\n+\n+  __ push(spills, sp);\n+  __ push_fp(fp_spills, sp);\n+\n+  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n+\n+  __ pop_fp(fp_spills, sp);\n+  __ pop(spills, sp);\n+\n+  __ b(L_after_reguard);\n+\n+  __ block_comment(\"} L_reguard\");\n+\n+  \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+  __ flush();\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":164,"deletions":8,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -1322,1 +1322,1 @@\n-    for (RegSetIterator it = clobbered.begin(); *it != noreg; ++it) {\n+    for (RegSetIterator<> it = clobbered.begin(); *it != noreg; ++it) {\n@@ -5699,1 +5699,1 @@\n-      RegSetIterator regs = (RegSet::range(r0, r26) - r18_tls).begin();\n+      RegSetIterator<> regs = (RegSet::range(r0, r26) - r18_tls).begin();\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1376,4 +1376,1 @@\n-  if (UseSVE > 0) {\n-    \/\/ Make sure that jni code does not change SVE vector length.\n-    __ verify_sve_vector_length();\n-  }\n+  __ verify_sve_vector_length();\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -42,0 +42,4 @@\n+  static ByteSize saved_fp_address_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/thread_linux_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,4 @@\n+  static ByteSize saved_fp_address_offset() {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::saved_fp_address_offset();\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @requires os.arch==\"amd64\" | os.arch==\"x86_64\"\n+ * @requires os.arch==\"amd64\" | os.arch==\"x86_64\" | os.arch==\"aarch64\"\n","filename":"test\/jdk\/java\/foreign\/TestIntrinsics.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}