{"files":[{"patch":"@@ -1037,6 +1037,6 @@\n-                        if (cause instanceof InstantiationException)\n-                            throw (InstantiationException) cause;\n-                        if (cause instanceof InvocationTargetException)\n-                            throw (InvocationTargetException) cause;\n-                        if (cause instanceof IllegalAccessException)\n-                            throw (IllegalAccessException) cause;\n+                        if (cause instanceof InstantiationException ie)\n+                            throw ie;\n+                        if (cause instanceof InvocationTargetException ite)\n+                            throw ite;\n+                        if (cause instanceof IllegalAccessException iae)\n+                            throw iae;\n@@ -1050,0 +1050,6 @@\n+            } catch (InvocationTargetException ex) {\n+                Throwable cause = ex.getCause();\n+                if (cause instanceof Error err)\n+                    throw err;\n+                else\n+                    throw ex;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectStreamClass.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-            return makeAllocator(member);\n+            return makeAllocator(member.getDeclaringClass(), member);\n@@ -134,1 +134,1 @@\n-    private static DirectMethodHandle makeAllocator(MemberName ctor) {\n+    static DirectMethodHandle makeAllocator(Class<?> instanceClass, MemberName ctor) {\n@@ -136,1 +136,0 @@\n-        Class<?> instanceClass = ctor.getDeclaringClass();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/DirectMethodHandle.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1650,0 +1650,6 @@\n+\n+            @Override\n+            public MethodHandle serializableConstructor(Class<?> decl, Constructor<?> ctorToCall) throws IllegalAccessException {\n+                return IMPL_LOOKUP.serializableConstructor(decl, ctorToCall);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3528,0 +3528,27 @@\n+        \/*\n+         * Produces a method handle that is capable of creating instances of the given class\n+         * and instantiated by the given constructor.  No security manager check.\n+         *\n+         * This method should only be used by ReflectionFactory::newConstructorForSerialization.\n+         *\/\n+        \/* package-private *\/ MethodHandle serializableConstructor(Class<?> decl, Constructor<?> c) throws IllegalAccessException {\n+            MemberName ctor = new MemberName(c);\n+            assert(ctor.isConstructor() && constructorInSuperclass(decl, c));\n+            checkAccess(REF_newInvokeSpecial, decl, ctor);\n+            assert(!MethodHandleNatives.isCallerSensitive(ctor));  \/\/ maybeBindCaller not relevant here\n+            return DirectMethodHandle.makeAllocator(decl, ctor).setVarargs(ctor);\n+        }\n+\n+        private static boolean constructorInSuperclass(Class<?> decl, Constructor<?> ctor) {\n+            if (decl == ctor.getDeclaringClass())\n+                return true;\n+\n+            Class<?> cl = decl;\n+            while ((cl = cl.getSuperclass()) != null) {\n+                if (cl == ctor.getDeclaringClass()) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -165,0 +165,8 @@\n+\n+    \/**\n+     * Returns a method handle that allocates an instance of the given class\n+     * and then invoke the given constructor of one of its superclasses.\n+     *\n+     * This method should only be used by ReflectionFactory::newConstructorForSerialization.\n+     *\/\n+    MethodHandle serializableConstructor(Class<?> decl, Constructor<?> ctorToCall) throws IllegalAccessException;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangInvokeAccess.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -197,1 +197,2 @@\n-            throw new IllegalArgumentException(\"object is not an instance of declaring class\");\n+            throw new IllegalArgumentException(\"object of type \" + o.getClass().getName()\n+                    +  \" is not an instance of \" + declaringClass.getName());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/DirectMethodHandleAccessor.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -104,0 +104,7 @@\n+        try {\n+            MethodHandle target = makeConstructorHandle(JLIA.unreflectConstructor(ctor));\n+            return DirectConstructorHandleAccessor.constructorAccessor(ctor, target);\n+        } catch (IllegalAccessException e) {\n+            throw new InternalError(e);\n+        }\n+    }\n@@ -105,0 +112,17 @@\n+    \/**\n+     * Creates a ConstructorAccessor that is capable of creating instances\n+     * of the given class and instantiated by the given constructor.\n+     *\n+     * @param decl the class to instantiate\n+     * @param ctor the constructor to call\n+     * @return an accessible constructor\n+     *\/\n+    static ConstructorAccessorImpl newSerializableConstructorAccessor(Class<?> decl, Constructor<?> ctor) {\n+        if (!constructorInSuperclass(decl, ctor)) {\n+            throw new UnsupportedOperationException(ctor + \" not a superclass of \" + decl.getName());\n+        }\n+\n+        \/\/ ExceptionInInitializerError may be thrown during class initialization\n+        \/\/ Ensure class initialized outside the invocation of method handle\n+        \/\/ so that EIIE is propagated (not wrapped with ITE)\n+        ensureClassInitialized(decl);\n@@ -106,9 +130,1 @@\n-            MethodHandle mh = JLIA.unreflectConstructor(ctor);\n-            int paramCount = mh.type().parameterCount();\n-            MethodHandle target = mh.asFixedArity();\n-            MethodType mtype = specializedMethodTypeForConstructor(paramCount);\n-            if (paramCount > SPECIALIZED_PARAM_COUNT) {\n-                \/\/ spread the parameters only for the non-specialized case\n-                target = target.asSpreader(Object[].class, paramCount);\n-            }\n-            target = target.asType(mtype);\n+            MethodHandle target = makeConstructorHandle(JLIA.serializableConstructor(decl, ctor));\n@@ -121,0 +137,24 @@\n+    private static boolean constructorInSuperclass(Class<?> decl, Constructor<?> ctor) {\n+        if (decl == ctor.getDeclaringClass())\n+            return true;\n+\n+        Class<?> cl = decl;\n+        while ((cl = cl.getSuperclass()) != null) {\n+            if (cl == ctor.getDeclaringClass()) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static MethodHandle makeConstructorHandle(MethodHandle ctor) {\n+        int paramCount = ctor.type().parameterCount();\n+        MethodHandle target = ctor.asFixedArity();\n+        MethodType mtype = specializedMethodTypeForConstructor(paramCount);\n+        if (paramCount > SPECIALIZED_PARAM_COUNT) {\n+            \/\/ spread the parameters only for the non-specialized case\n+            target = target.asSpreader(Object[].class, paramCount);\n+        }\n+        return target.asType(mtype);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/MethodHandleAccessorFactory.java","additions":49,"deletions":9,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -373,3 +373,1 @@\n-\n-        ConstructorAccessor acc = new SerializationConstructorAccessorGenerator().\n-            generateSerializationConstructor(cl,\n+        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n@@ -377,0 +375,1 @@\n+                                             constructorToCall.getExceptionTypes(),\n@@ -378,16 +377,21 @@\n-                                             constructorToCall.getDeclaringClass());\n-        Constructor<?> c = newConstructor(constructorToCall.getDeclaringClass(),\n-                                          constructorToCall.getParameterTypes(),\n-                                          constructorToCall.getExceptionTypes(),\n-                                          constructorToCall.getModifiers(),\n-                                          langReflectAccess.\n-                                          getConstructorSlot(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorSignature(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorAnnotations(constructorToCall),\n-                                          langReflectAccess.\n-                                          getConstructorParameterAnnotations(constructorToCall));\n-        setConstructorAccessor(c, acc);\n-        c.setAccessible(true);\n-        return c;\n+                                             langReflectAccess.\n+                                             getConstructorSlot(constructorToCall),\n+                                             langReflectAccess.\n+                                             getConstructorSignature(constructorToCall),\n+                                             langReflectAccess.\n+                                             getConstructorAnnotations(constructorToCall),\n+                                             langReflectAccess.\n+                                             getConstructorParameterAnnotations(constructorToCall));\n+        ConstructorAccessor acc;\n+        if (useOldSerializableConstructor()) {\n+            acc = new SerializationConstructorAccessorGenerator().\n+                                generateSerializationConstructor(cl,\n+                                                                 constructorToCall.getParameterTypes(),\n+                                                                 constructorToCall.getModifiers(),\n+                                                                 constructorToCall.getDeclaringClass());\n+        } else {\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+        }\n+        setConstructorAccessor(ctor, acc);\n+        ctor.setAccessible(true);\n+        return ctor;\n@@ -396,0 +400,1 @@\n+\n@@ -551,0 +556,4 @@\n+    static boolean useOldSerializableConstructor() {\n+        return config().useOldSerializableConstructor;\n+    }\n+\n@@ -567,0 +576,1 @@\n+                                                            false,  \/\/ useOldSerializeableConstructor\n@@ -581,0 +591,1 @@\n+                          boolean useOldSerializableConstructor,\n@@ -604,0 +615,2 @@\n+        boolean useOldSerializableConstructor =\n+            \"true\".equals(props.getProperty(\"jdk.reflect.useOldSerializableConstructor\"));\n@@ -607,1 +620,1 @@\n-        return new Config(useNativeAccessorOnly, disableSerialConstructorChecks);\n+        return new Config(useNativeAccessorOnly, useOldSerializableConstructor, disableSerialConstructorChecks);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":33,"deletions":20,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-            new IllegalArgumentException(\"object is not an instance of declaring class\"),\n+            new IllegalArgumentException(\"object of type java.lang.Object is not an instance of MethodHandleAccessorsTest\"),\n","filename":"test\/jdk\/java\/lang\/reflect\/MethodHandleAccessorsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,0 +139,5 @@\n+    @Test(expectedExceptions = UnsupportedOperationException.class)\n+    static void testConstructorNotSuperClass() throws ReflectiveOperationException {\n+        factory.newConstructorForSerialization(Bar.class, Baz.class.getDeclaredConstructor());\n+    }\n+\n","filename":"test\/jdk\/sun\/reflect\/ReflectionFactory\/ReflectionFactoryTest.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}