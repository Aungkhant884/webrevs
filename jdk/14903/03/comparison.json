{"files":[{"patch":"@@ -313,0 +313,13 @@\n+  const size_t ps = page_size(false, 8);\n+  \/\/ Print warning if using large pages but not able to use the size given\n+  if (UseLargePages && ps < LargePageSizeInBytes) {\n+      char msg[256];\n+      jio_snprintf(msg, sizeof(msg),\n+                   \"Failed to reserve large page memory for code cache (\" SIZE_FORMAT \"%s). \"\n+                   \"Reverting to smaller page size (\" SIZE_FORMAT \"%s).\",\n+                   byte_size_in_exact_unit(LargePageSizeInBytes), exact_unit_for_byte_size(LargePageSizeInBytes),\n+                   byte_size_in_exact_unit(ps), exact_unit_for_byte_size(ps));\n+      log_warning(codecache)(\"%s\", msg);\n+      warning(\"%s\", msg);\n+  }\n+\n@@ -315,1 +328,1 @@\n-  const size_t alignment = MAX2(page_size(false, 8), os::vm_allocation_granularity());\n+  const size_t alignment = MAX2(ps, os::vm_allocation_granularity());\n@@ -327,1 +340,1 @@\n-  ReservedCodeSpace rs = reserve_heap_memory(cache_size);\n+  ReservedCodeSpace rs = reserve_heap_memory(cache_size, ps);\n@@ -357,1 +370,1 @@\n-ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size) {\n+ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size, size_t rs_ps) {\n@@ -359,1 +372,0 @@\n-  const size_t rs_ps = page_size();\n@@ -1197,1 +1209,1 @@\n-    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize);\n+    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, 8));\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-  static ReservedCodeSpace reserve_heap_memory(size_t size);  \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n+  static ReservedCodeSpace reserve_heap_memory(size_t size, size_t rs_ps); \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304954\n+ * @summary Test checks that if using large pages and code cache gets above the limit it tries to revert to smaller pages instead of failing\n+ * @requires vm.gc != \"Z\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseLargePages -XX:LargePageSizeInBytes=1g compiler.codecache.CheckLargePages\n+ *\/\n+\n+package compiler.codecache;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class CheckLargePages {\n+    private final static WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+        final boolean largePages = WHITE_BOX.getBooleanVMFlag(\"UseLargePages\");\n+        final long largePageSize = WHITE_BOX.getVMLargePageSize();\n+        if (largePages && (largePageSize == 1024 * 1024 * 1024)) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                    \"-XX:+UseLargePages\",\n+                    \"-XX:+SegmentedCodeCache\",\n+                    \"-XX:InitialCodeCacheSize=2g\",\n+                    \"-XX:ReservedCodeCacheSize=2g\",\n+                    \"-XX:LargePageSizeInBytes=1g\",\n+                    \"-Xlog:pagesize*=debug\",\n+                    \"-version\");\n+            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+            out.shouldContain(\"Failed to reserve large page memory for code cache\");\n+            out.shouldHaveExitValue(0);\n+        } else {\n+            System.out.println(\"1GB large pages not supported: UseLargePages=\" + largePages +\n+                    (largePages ? \", largePageSize=\" + largePageSize : \"\") + \". Skipping\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckLargePages.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}