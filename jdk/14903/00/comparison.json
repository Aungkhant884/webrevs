{"files":[{"patch":"@@ -320,0 +320,27 @@\n+  \/\/ Check that code heap segments fit in cache when using large pages\n+  size_t ps = page_size();\n+  if (UseLargePages) {\n+    size_t temp_ps = ps;\n+    while (temp_ps > 0 &&\n+           align_up(non_nmethod_size, temp_ps) +\n+           align_up(profiled_size, temp_ps) +\n+           align_up(non_profiled_size, temp_ps) > cache_size) {\n+      temp_ps = os::page_sizes().next_smaller(temp_ps);\n+    }\n+    if (temp_ps <= 0) {\n+      \/\/ No small enough page found\n+      vm_exit_during_initialization(err_msg(\"Could not reserve enough space for code cache with any page size\"));\n+    } else if (temp_ps != ps){\n+      \/\/ Smaller page found\n+      char msg[256];\n+      jio_snprintf(msg, sizeof(msg),\n+                   \"Failed to reserve large page memory for segmented code cache (\" SIZE_FORMAT \"%s). \"\n+                   \"Reverting to smaller page size (\" SIZE_FORMAT \"%s).\",\n+                   byte_size_in_exact_unit(ps), exact_unit_for_byte_size(ps),\n+                   byte_size_in_exact_unit(temp_ps), exact_unit_for_byte_size(temp_ps));\n+      log_warning(codecache)(\"%s\", msg);\n+      warning(\"%s\", msg);\n+      ps = temp_ps;\n+    }\n+  }\n+\n@@ -327,1 +354,1 @@\n-  ReservedCodeSpace rs = reserve_heap_memory(cache_size);\n+  ReservedCodeSpace rs = reserve_heap_memory(cache_size, ps);\n@@ -357,1 +384,1 @@\n-ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size) {\n+ReservedCodeSpace CodeCache::reserve_heap_memory(size_t size, size_t page_size) {\n@@ -359,2 +386,1 @@\n-  const size_t rs_ps = page_size();\n-  const size_t rs_align = MAX2(rs_ps, os::vm_allocation_granularity());\n+  const size_t rs_align = MAX2(page_size, os::vm_allocation_granularity());\n@@ -362,1 +388,1 @@\n-  ReservedCodeSpace rs(rs_size, rs_align, rs_ps);\n+  ReservedCodeSpace rs(rs_size, rs_align, page_size);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":31,"deletions":5,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -124,1 +124,4 @@\n-  static ReservedCodeSpace reserve_heap_memory(size_t size);  \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n+  static ReservedCodeSpace reserve_heap_memory(size_t size, size_t page_size);  \/\/ Reserves one continuous chunk of memory for the CodeHeaps\n+  static ReservedCodeSpace reserve_heap_memory(size_t size) { \/\/ Calls the above with current page size\n+    return reserve_heap_memory(size, page_size());\n+  };\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304954\n+ * @summary Test checks that if using large pages and code cache gets above the limit it tries to revert to smaller pages instead of failing\n+ * @requires vm.gc != \"Z\"\n+ * @library \/test\/lib\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseLargePages -XX:LargePageSizeInBytes=1g compiler.codecache.CheckLargePages\n+ *\/\n+\n+package compiler.codecache;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class CheckLargePages {\n+    private final static WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+\n+    public static void main(String[] args) throws Exception {\n+        final boolean largePages = WHITE_BOX.getBooleanVMFlag(\"UseLargePages\");\n+        final long largePageSize = WHITE_BOX.getVMLargePageSize();\n+        if (largePages && (largePageSize == 1024 * 1024 * 1024)) {\n+            ProcessBuilder pb = ProcessTools.createJavaProcessBuilder(\n+                    \"-XX:+UseLargePages\",\n+                    \"-XX:+SegmentedCodeCache\",\n+                    \"-XX:InitialCodeCacheSize=2g\",\n+                    \"-XX:ReservedCodeCacheSize=2g\",\n+                    \"-XX:LargePageSizeInBytes=1g\",\n+                    \"-Xlog:pagesize*=debug\",\n+                    \"-version\");\n+            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+            out.shouldContain(\"Failed to reserve large page memory for segmented code cache\");\n+            out.shouldHaveExitValue(0);\n+        } else {\n+            System.out.println(\"1GB large pages not supported: UseLargePages=\" + largePages +\n+                    (largePages ? \", largePageSize=\" + largePageSize : \"\") + \". Skipping\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckLargePages.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}