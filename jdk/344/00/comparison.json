{"files":[{"patch":"@@ -556,24 +556,0 @@\n-  __ reset_last_Java_frame(true);\n-  __ maybe_isb();\n-\n-  \/\/ check for pending exceptions\n-  { Label L;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbz(rscratch1, L);\n-    \/\/ exception pending => remove activation and forward to exception handler\n-\n-    { Label L1;\n-      __ cbnz(r0, L1);                                  \/\/ have we deoptimized?\n-      __ far_jump(RuntimeAddress(Runtime1::entry_for(Runtime1::forward_exception_id)));\n-      __ bind(L1);\n-    }\n-\n-    \/\/ the deopt blob expects exceptions in the special fields of\n-    \/\/ JavaThread, so copy and clear pending exception.\n-\n-    \/\/ load and clear pending exception\n-    __ ldr(r0, Address(rthread, Thread::pending_exception_offset()));\n-    __ str(zr, Address(rthread, Thread::pending_exception_offset()));\n-\n-    \/\/ check that there is really a valid exception\n-    __ verify_not_null_oop(r0);\n@@ -581,2 +557,1 @@\n-    \/\/ load throwing pc: this is the return address of the stub\n-    __ mov(r3, lr);\n+  __ reset_last_Java_frame(true);\n@@ -585,34 +560,6 @@\n-    \/\/ check that fields in JavaThread for exception oop and issuing pc are empty\n-    Label oop_empty;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbz(rscratch1, oop_empty);\n-    __ stop(\"exception oop must be empty\");\n-    __ bind(oop_empty);\n-\n-    Label pc_empty;\n-    __ ldr(rscratch1, Address(rthread, JavaThread::exception_pc_offset()));\n-    __ cbz(rscratch1, pc_empty);\n-    __ stop(\"exception pc must be empty\");\n-    __ bind(pc_empty);\n-#endif\n-\n-    \/\/ store exception oop and throwing pc to JavaThread\n-    __ str(r0, Address(rthread, JavaThread::exception_oop_offset()));\n-    __ str(r3, Address(rthread, JavaThread::exception_pc_offset()));\n-\n-    restore_live_registers(sasm);\n-\n-    __ leave();\n-\n-    \/\/ Forward the exception directly to deopt blob. We can blow no\n-    \/\/ registers and must leave throwing pc on the stack.  A patch may\n-    \/\/ have values live in registers so the entry point with the\n-    \/\/ exception in tls.\n-    __ far_jump(RuntimeAddress(deopt_blob->unpack_with_exception_in_tls()));\n-\n-    __ bind(L);\n-  }\n-\n-\n-  \/\/ Runtime will return true if the nmethod has been deoptimized during\n-  \/\/ the patching process. In that case we must do a deopt reexecute instead.\n+  \/\/ check that fields in JavaThread for exception oop and issuing pc are empty\n+  Label oop_empty;\n+  __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+  __ cbz(rscratch1, oop_empty);\n+  __ stop(\"exception oop must be empty\");\n+  __ bind(oop_empty);\n@@ -620,1 +567,6 @@\n-  Label cont;\n+  Label pc_empty;\n+  __ ldr(rscratch1, Address(rthread, JavaThread::exception_pc_offset()));\n+  __ cbz(rscratch1, pc_empty);\n+  __ stop(\"exception pc must be empty\");\n+  __ bind(pc_empty);\n+#endif\n@@ -622,1 +574,5 @@\n-  __ cbz(r0, cont);                                 \/\/ have we deoptimized?\n+  \/\/ Runtime will return true if the nmethod has been deoptimized, this is the\n+  \/\/ expected scenario and anything else is  an error. Note that we maintain a\n+  \/\/ check on the result purely as a defensive measure.\n+  Label no_deopt;\n+  __ cbz(r0, no_deopt);                                \/\/ Have we deoptimized?\n@@ -624,2 +580,3 @@\n-  \/\/ Will reexecute. Proper return address is already on the stack we just restore\n-  \/\/ registers, pop all of our frame but the return address and jump to the deopt blob\n+  \/\/ Perform a re-execute. The proper return  address is already on the stack,\n+  \/\/ we just need  to restore registers, pop  all of our frame  but the return\n+  \/\/ address and jump to the deopt blob.\n@@ -630,4 +587,2 @@\n-  __ bind(cont);\n-  restore_live_registers(sasm);\n-  __ leave();\n-  __ ret(lr);\n+  __ bind(no_deopt);\n+  __ stop(\"deopt not performed\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":23,"deletions":68,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -1258,2 +1258,2 @@\n-JRT_ENTRY(void, Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id ))\n-  RegisterMap reg_map(thread, false);\n+void Runtime1::patch_code(JavaThread* thread, Runtime1::StubID stub_id) {\n+  NOT_PRODUCT(_patch_code_slowcase_cnt++);\n@@ -1261,1 +1261,0 @@\n-  NOT_PRODUCT(_patch_code_slowcase_cnt++;)\n@@ -1266,0 +1265,2 @@\n+  RegisterMap reg_map(thread, false);\n+\n@@ -1268,0 +1269,1 @@\n+  assert(caller_frame.is_compiled_frame(), \"Wrong frame type\");\n@@ -1269,2 +1271,1 @@\n-  \/\/ It's possible the nmethod was invalidated in the last\n-  \/\/ safepoint, but if it's still alive then make it not_entrant.\n+  \/\/ Make sure the nmethod is invalidated, i.e. made not entrant.\n@@ -1277,1 +1278,0 @@\n-\n@@ -1279,1 +1279,2 @@\n-JRT_END\n+  postcond(caller_is_deopted());\n+}\n@@ -1283,1 +1284,0 @@\n-\/\/\n@@ -1348,1 +1348,1 @@\n-\/\/\n+\n@@ -1357,1 +1357,0 @@\n-\n@@ -1375,1 +1374,1 @@\n-JRT_END\n+}\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1626,0 +1626,1 @@\n+  assert(fr.is_compiled_frame(), \"Wrong frame type\");\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}