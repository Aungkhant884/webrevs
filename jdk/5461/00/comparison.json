{"files":[{"patch":"@@ -42,14 +42,2 @@\n-G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n-                                                                                 G1EvacFailureRegions* evac_failure_regions) :\n-  G1BatchedGangTask(\"Post Evacuate Cleanup 1\", G1CollectedHeap::heap()->phase_times())\n-{\n-  add_serial_task(new MergePssTask(per_thread_states));\n-  add_serial_task(new RecalculateUsedTask());\n-  if (SampleCollectionSetCandidatesTask::should_execute()) {\n-    add_serial_task(new SampleCollectionSetCandidatesTask());\n-  }\n-  if (RemoveSelfForwardPtrsTask::should_execute()) {\n-    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n-  }\n-  add_parallel_task(G1CollectedHeap::heap()->rem_set()->create_cleanup_after_scan_heap_roots_task());\n-}\n+class G1PostEvacuateCollectionSetCleanupTask1::MergePssTask : public G1AbstractSubTask {\n+  G1ParScanThreadStateSet* _per_thread_states;\n@@ -57,3 +45,4 @@\n-G1PostEvacuateCollectionSetCleanupTask1::MergePssTask::MergePssTask(G1ParScanThreadStateSet* per_thread_states) :\n-  G1AbstractSubTask(G1GCPhaseTimes::MergePSS),\n-  _per_thread_states(per_thread_states) { }\n+public:\n+  MergePssTask(G1ParScanThreadStateSet* per_thread_states) :\n+    G1AbstractSubTask(G1GCPhaseTimes::MergePSS),\n+    _per_thread_states(per_thread_states) { }\n@@ -61,3 +50,1 @@\n-void G1PostEvacuateCollectionSetCleanupTask1::MergePssTask::do_work(uint worker_id) {\n-  _per_thread_states->flush();\n-}\n+  double worker_cost() const override { return 1.0; }\n@@ -65,4 +52,2 @@\n-double G1PostEvacuateCollectionSetCleanupTask1::RecalculateUsedTask::worker_cost() const {\n-  \/\/ If there is no evacuation failure, the work to perform is minimal.\n-  return G1CollectedHeap::heap()->evacuation_failed() ? 1.0 : AlmostNoWork;\n-}\n+  void do_work(uint worker_id) override { _per_thread_states->flush(); }\n+};\n@@ -70,3 +55,3 @@\n-void G1PostEvacuateCollectionSetCleanupTask1::RecalculateUsedTask::do_work(uint worker_id) {\n-  G1CollectedHeap::heap()->update_used_after_gc();\n-}\n+class G1PostEvacuateCollectionSetCleanupTask1::RecalculateUsedTask : public G1AbstractSubTask {\n+public:\n+  RecalculateUsedTask() : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed) { }\n@@ -74,3 +59,4 @@\n-bool G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::should_execute() {\n-  return G1CollectedHeap::heap()->should_sample_collection_set_candidates();\n-}\n+  double worker_cost() const override {\n+    \/\/ If there is no evacuation failure, the work to perform is minimal.\n+    return G1CollectedHeap::heap()->evacuation_failed() ? 1.0 : AlmostNoWork;\n+  }\n@@ -78,3 +64,2 @@\n-double G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::worker_cost() const {\n-  return should_execute() ? 1.0 : AlmostNoWork;\n-}\n+  void do_work(uint worker_id) override { G1CollectedHeap::heap()->update_used_after_gc(); }\n+};\n@@ -82,1 +67,1 @@\n-class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n+class G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask : public G1AbstractSubTask {\n@@ -84,1 +69,1 @@\n-  G1CardSetMemoryStats _total;\n+  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n@@ -86,3 +71,24 @@\n-  bool do_heap_region(HeapRegion* r) override {\n-    _total.add(r->rem_set()->card_set_memory_stats());\n-    return false;\n+  static bool should_execute() {\n+    return G1CollectedHeap::heap()->should_sample_collection_set_candidates();\n+  }\n+\n+  double worker_cost() const override {\n+    return should_execute() ? 1.0 : AlmostNoWork;\n+  }\n+\n+  void do_work(uint worker_id) override {\n+\n+    class G1SampleCollectionSetCandidatesClosure : public HeapRegionClosure {\n+    public:\n+      G1CardSetMemoryStats _total;\n+\n+      bool do_heap_region(HeapRegion* r) override {\n+        _total.add(r->rem_set()->card_set_memory_stats());\n+        return false;\n+      }\n+    } cl;\n+\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+\n+    g1h->collection_set()->candidates()->iterate(&cl);\n+    g1h->set_collection_set_candidates_stats(cl._total);\n@@ -92,2 +98,3 @@\n-void G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask::do_work(uint worker_id) {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+class G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask : public G1AbstractSubTask {\n+  G1ParRemoveSelfForwardPtrsTask _task;\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -95,4 +102,5 @@\n-  G1SampleCollectionSetCandidatesClosure cl;\n-  g1h->collection_set()->candidates()->iterate(&cl);\n-  g1h->set_collection_set_candidates_stats(cl._total);\n-}\n+public:\n+  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions) :\n+    G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr),\n+    _task(rdcqs, evac_failure_regions),\n+    _evac_failure_regions(evac_failure_regions) { }\n@@ -100,3 +108,5 @@\n-bool G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::should_execute() {\n-  return G1CollectedHeap::heap()->evacuation_failed();\n-}\n+  ~RemoveSelfForwardPtrsTask() {\n+    assert(_task.num_failed_regions() == _evac_failure_regions->num_regions_failed_evacuation(),\n+           \"Removed regions %u inconsistent with expected %u\",\n+           _task.num_failed_regions(), _evac_failure_regions->num_regions_failed_evacuation());\n+  }\n@@ -104,13 +114,3 @@\n-G1PostEvacuateCollectionSetCleanupTask1::\n-    RemoveSelfForwardPtrsTask::RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs,\n-                                                         G1EvacFailureRegions* evac_failure_regions) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RemoveSelfForwardingPtr),\n-  _task(rdcqs, evac_failure_regions),\n-  _evac_failure_regions(evac_failure_regions) { }\n-\n-G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::~RemoveSelfForwardPtrsTask() {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n-  assert(_task.num_failed_regions() == _evac_failure_regions->num_regions_failed_evacuation(),\n-         \"Removed regions %u inconsistent with expected %u\",\n-         _task.num_failed_regions(), _evac_failure_regions->num_regions_failed_evacuation());\n-}\n+  static bool should_execute() {\n+    return G1CollectedHeap::heap()->evacuation_failed();\n+  }\n@@ -118,4 +118,4 @@\n-double G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::worker_cost() const {\n-  assert(should_execute(), \"Should not call this if not executed\");\n-  return _evac_failure_regions->num_regions_failed_evacuation();\n-}\n+  double worker_cost() const override {\n+    assert(should_execute(), \"Should not call this if not executed\");\n+    return _evac_failure_regions->num_regions_failed_evacuation();\n+  }\n@@ -123,2 +123,18 @@\n-void G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask::do_work(uint worker_id) {\n-  _task.work(worker_id);\n+  void do_work(uint worker_id) override {\n+    _task.work(worker_id);\n+  }\n+};\n+\n+G1PostEvacuateCollectionSetCleanupTask1::G1PostEvacuateCollectionSetCleanupTask1(G1ParScanThreadStateSet* per_thread_states,\n+                                                                                 G1EvacFailureRegions* evac_failure_regions) :\n+  G1BatchedGangTask(\"Post Evacuate Cleanup 1\", G1CollectedHeap::heap()->phase_times())\n+{\n+  add_serial_task(new MergePssTask(per_thread_states));\n+  add_serial_task(new RecalculateUsedTask());\n+  if (SampleCollectionSetCandidatesTask::should_execute()) {\n+    add_serial_task(new SampleCollectionSetCandidatesTask());\n+  }\n+  if (RemoveSelfForwardPtrsTask::should_execute()) {\n+    add_parallel_task(new RemoveSelfForwardPtrsTask(per_thread_states->rdcqs(), evac_failure_regions));\n+  }\n+  add_parallel_task(G1CollectedHeap::heap()->rem_set()->create_cleanup_after_scan_heap_roots_task());\n@@ -230,3 +246,3 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::ResetHotCardCacheTask::do_work(uint worker_id) {\n-  G1CollectedHeap::heap()->reset_hot_card_cache();\n-}\n+class G1PostEvacuateCollectionSetCleanupTask2::ResetHotCardCacheTask : public G1AbstractSubTask {\n+public:\n+  ResetHotCardCacheTask() : G1AbstractSubTask(G1GCPhaseTimes::ResetHotCardCache) { }\n@@ -234,3 +250,11 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::PurgeCodeRootsTask::do_work(uint worker_id) {\n-  G1CollectedHeap::heap()->purge_code_root_memory();\n-}\n+  double worker_cost() const override { return 0.5; }\n+  void do_work(uint worker_id) override { G1CollectedHeap::heap()->reset_hot_card_cache(); }\n+};\n+\n+class G1PostEvacuateCollectionSetCleanupTask2::PurgeCodeRootsTask : public G1AbstractSubTask {\n+public:\n+  PurgeCodeRootsTask() : G1AbstractSubTask(G1GCPhaseTimes::PurgeCodeRoots) { }\n+\n+  double worker_cost() const override { return 1.0; }\n+  void do_work(uint worker_id) override { G1CollectedHeap::heap()->purge_code_root_memory(); }\n+};\n@@ -239,3 +263,7 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::UpdateDerivedPointersTask::do_work(uint worker_id) {\n-  DerivedPointerTable::update_pointers();\n-}\n+class G1PostEvacuateCollectionSetCleanupTask2::UpdateDerivedPointersTask : public G1AbstractSubTask {\n+public:\n+  UpdateDerivedPointersTask() : G1AbstractSubTask(G1GCPhaseTimes::UpdateDerivedPointers) { }\n+\n+  double worker_cost() const override { return 1.0; }\n+  void do_work(uint worker_id) override {   DerivedPointerTable::update_pointers(); }\n+};\n@@ -244,3 +272,3 @@\n-bool G1PostEvacuateCollectionSetCleanupTask2::EagerlyReclaimHumongousObjectsTask::should_execute() {\n-  return G1CollectedHeap::heap()->should_do_eager_reclaim();\n-}\n+class G1PostEvacuateCollectionSetCleanupTask2::EagerlyReclaimHumongousObjectsTask : public G1AbstractSubTask {\n+  uint _humongous_regions_reclaimed;\n+  size_t _bytes_freed;\n@@ -248,4 +276,5 @@\n-G1PostEvacuateCollectionSetCleanupTask2::EagerlyReclaimHumongousObjectsTask::EagerlyReclaimHumongousObjectsTask() :\n-  G1AbstractSubTask(G1GCPhaseTimes::EagerlyReclaimHumongousObjects),\n-  _humongous_regions_reclaimed(0),\n-  _bytes_freed(0) { }\n+public:\n+  EagerlyReclaimHumongousObjectsTask() :\n+    G1AbstractSubTask(G1GCPhaseTimes::EagerlyReclaimHumongousObjects),\n+    _humongous_regions_reclaimed(0),\n+    _bytes_freed(0) { }\n@@ -253,2 +282,2 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::EagerlyReclaimHumongousObjectsTask::do_work(uint worker_id) {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+  virtual ~EagerlyReclaimHumongousObjectsTask() {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -256,2 +285,3 @@\n-  G1FreeHumongousRegionClosure cl;\n-  g1h->heap_region_iterate(&cl);\n+    g1h->remove_from_old_gen_sets(0, 0, _humongous_regions_reclaimed);\n+    g1h->decrement_summary_bytes(_bytes_freed);\n+  }\n@@ -259,3 +289,1 @@\n-  record_work_item(worker_id, G1GCPhaseTimes::EagerlyReclaimNumTotal, g1h->num_humongous_objects());\n-  record_work_item(worker_id, G1GCPhaseTimes::EagerlyReclaimNumCandidates, g1h->num_humongous_reclaim_candidates());\n-  record_work_item(worker_id, G1GCPhaseTimes::EagerlyReclaimNumReclaimed, cl.humongous_objects_reclaimed());\n+  static bool should_execute() {   return G1CollectedHeap::heap()->should_do_eager_reclaim(); }\n@@ -263,3 +291,3 @@\n-  _humongous_regions_reclaimed = cl.humongous_regions_reclaimed();\n-  _bytes_freed = cl.bytes_freed();\n-}\n+  double worker_cost() const override { return 1.0; }\n+  void do_work(uint worker_id) override {\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n@@ -267,2 +295,2 @@\n-G1PostEvacuateCollectionSetCleanupTask2::EagerlyReclaimHumongousObjectsTask::~EagerlyReclaimHumongousObjectsTask() {\n-  G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1FreeHumongousRegionClosure cl;\n+    g1h->heap_region_iterate(&cl);\n@@ -270,3 +298,3 @@\n-  g1h->remove_from_old_gen_sets(0, 0, _humongous_regions_reclaimed);\n-  g1h->decrement_summary_bytes(_bytes_freed);\n-}\n+    record_work_item(worker_id, G1GCPhaseTimes::EagerlyReclaimNumTotal, g1h->num_humongous_objects());\n+    record_work_item(worker_id, G1GCPhaseTimes::EagerlyReclaimNumCandidates, g1h->num_humongous_reclaim_candidates());\n+    record_work_item(worker_id, G1GCPhaseTimes::EagerlyReclaimNumReclaimed, cl.humongous_objects_reclaimed());\n@@ -274,3 +302,4 @@\n-bool G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask::should_execute() {\n-  return G1CollectedHeap::heap()->evacuation_failed();\n-}\n+    _humongous_regions_reclaimed = cl.humongous_regions_reclaimed();\n+    _bytes_freed = cl.bytes_freed();\n+  }\n+};\n@@ -278,2 +307,3 @@\n-G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask::RestorePreservedMarksTask(PreservedMarksSet* preserved_marks) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RestorePreservedMarks), _preserved_marks(preserved_marks), _task(preserved_marks->create_task()) { }\n+class G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask : public G1AbstractSubTask {\n+  PreservedMarksSet* _preserved_marks;\n+  AbstractGangTask* _task;\n@@ -281,3 +311,5 @@\n-G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask::~RestorePreservedMarksTask() {\n-  delete _task;\n-}\n+public:\n+  RestorePreservedMarksTask(PreservedMarksSet* preserved_marks) :\n+    G1AbstractSubTask(G1GCPhaseTimes::RestorePreservedMarks),\n+    _preserved_marks(preserved_marks),\n+    _task(preserved_marks->create_task()) { }\n@@ -285,4 +317,3 @@\n-double G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask::worker_cost() const {\n-  assert(should_execute(), \"Should not call this if not executed\");\n-  return _preserved_marks->num();\n-}\n+  virtual ~RestorePreservedMarksTask() {\n+    delete _task;\n+  }\n@@ -290,3 +321,9 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask::do_work(uint worker_id) {\n-  _task->work(worker_id);\n-}\n+  static bool should_execute() { return G1CollectedHeap::heap()->evacuation_failed(); }\n+\n+  double worker_cost() const override {\n+    assert(should_execute(), \"Should not call this if not executed\");\n+    return _preserved_marks->num();\n+  }\n+\n+  void do_work(uint worker_id) override { _task->work(worker_id); }\n+};\n@@ -332,13 +369,4 @@\n-G1PostEvacuateCollectionSetCleanupTask2::\n-      RedirtyLoggedCardsTask::RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs,\n-                                                     G1EvacFailureRegions* evac_failure_regions) :\n-  G1AbstractSubTask(G1GCPhaseTimes::RedirtyCards),\n-  _rdcqs(rdcqs),\n-  _nodes(rdcqs->all_completed_buffers()),\n-  _evac_failure_regions(evac_failure_regions) { }\n-\n-G1PostEvacuateCollectionSetCleanupTask2::RedirtyLoggedCardsTask::~RedirtyLoggedCardsTask() {\n-  G1DirtyCardQueueSet& dcq = G1BarrierSet::dirty_card_queue_set();\n-  dcq.merge_bufferlists(_rdcqs);\n-  _rdcqs->verify_empty();\n-}\n+class G1PostEvacuateCollectionSetCleanupTask2::RedirtyLoggedCardsTask : public G1AbstractSubTask {\n+  G1RedirtyCardsQueueSet* _rdcqs;\n+  BufferNode* volatile _nodes;\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -346,4 +374,12 @@\n-double G1PostEvacuateCollectionSetCleanupTask2::RedirtyLoggedCardsTask::worker_cost() const {\n-  \/\/ Needs more investigation.\n-  return G1CollectedHeap::heap()->workers()->active_workers();\n-}\n+public:\n+  RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions) :\n+    G1AbstractSubTask(G1GCPhaseTimes::RedirtyCards),\n+    _rdcqs(rdcqs),\n+    _nodes(rdcqs->all_completed_buffers()),\n+    _evac_failure_regions(evac_failure_regions) { }\n+\n+  virtual ~RedirtyLoggedCardsTask() {\n+    G1DirtyCardQueueSet& dcq = G1BarrierSet::dirty_card_queue_set();\n+    dcq.merge_bufferlists(_rdcqs);\n+    _rdcqs->verify_empty();\n+  }\n@@ -351,10 +387,16 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::RedirtyLoggedCardsTask::do_work(uint worker_id) {\n-  RedirtyLoggedCardTableEntryClosure cl(G1CollectedHeap::heap(), _evac_failure_regions);\n-  const size_t buffer_size = _rdcqs->buffer_size();\n-  BufferNode* next = Atomic::load(&_nodes);\n-  while (next != nullptr) {\n-    BufferNode* node = next;\n-    next = Atomic::cmpxchg(&_nodes, node, node->next());\n-    if (next == node) {\n-      cl.apply_to_buffer(node, buffer_size, worker_id);\n-      next = node->next();\n+  double worker_cost() const override {\n+    \/\/ Needs more investigation.\n+    return G1CollectedHeap::heap()->workers()->active_workers();\n+  }\n+\n+  void do_work(uint worker_id) override {\n+    RedirtyLoggedCardTableEntryClosure cl(G1CollectedHeap::heap(), _evac_failure_regions);\n+    const size_t buffer_size = _rdcqs->buffer_size();\n+    BufferNode* next = Atomic::load(&_nodes);\n+    while (next != nullptr) {\n+      BufferNode* node = next;\n+      next = Atomic::cmpxchg(&_nodes, node, node->next());\n+      if (next == node) {\n+        cl.apply_to_buffer(node, buffer_size, worker_id);\n+        next = node->next();\n+      }\n@@ -362,0 +404,1 @@\n+    record_work_item(worker_id, 0, cl.num_dirtied());\n@@ -363,2 +406,1 @@\n-  record_work_item(worker_id, 0, cl.num_dirtied());\n-}\n+};\n@@ -565,3 +607,8 @@\n-FreeCSetStats* G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::worker_stats(uint worker) {\n-  return &_worker_stats[worker];\n-}\n+class G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask : public G1AbstractSubTask {\n+  G1CollectedHeap*  _g1h;\n+  G1EvacInfo* _evacuation_info;\n+  FreeCSetStats*    _worker_stats;\n+  HeapRegionClaimer _claimer;\n+  const size_t*     _surviving_young_words;\n+  uint              _active_workers;\n+  G1EvacFailureRegions* _evac_failure_regions;\n@@ -569,5 +616,2 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::report_statistics() {\n-  \/\/ Merge the accounting\n-  FreeCSetStats total_stats;\n-  for (uint worker = 0; worker < _active_workers; worker++) {\n-    total_stats.merge_stats(worker_stats(worker));\n+  FreeCSetStats* worker_stats(uint worker) {\n+    return &_worker_stats[worker];\n@@ -575,2 +619,0 @@\n-  total_stats.report(_g1h, _evacuation_info);\n-}\n@@ -578,4 +620,13 @@\n-G1PostEvacuateCollectionSetCleanupTask2::\n-      FreeCollectionSetTask::FreeCollectionSetTask(G1EvacInfo* evacuation_info,\n-                                                   const size_t* surviving_young_words,\n-                                                   G1EvacFailureRegions* evac_failure_regions) :\n+  void report_statistics() {\n+    \/\/ Merge the accounting\n+    FreeCSetStats total_stats;\n+    for (uint worker = 0; worker < _active_workers; worker++) {\n+      total_stats.merge_stats(worker_stats(worker));\n+    }\n+    total_stats.report(_g1h, _evacuation_info);\n+  }\n+\n+public:\n+  FreeCollectionSetTask(G1EvacInfo* evacuation_info,\n+                        const size_t* surviving_young_words,\n+                        G1EvacFailureRegions* evac_failure_regions) :\n@@ -590,2 +641,0 @@\n-  _g1h->clear_eden();\n-}\n@@ -593,5 +642,1 @@\n-G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::~FreeCollectionSetTask() {\n-  Ticks serial_time = Ticks::now();\n-  report_statistics();\n-  for (uint worker = 0; worker < _active_workers; worker++) {\n-    _worker_stats[worker].~FreeCSetStats();\n+    _g1h->clear_eden();\n@@ -599,4 +644,0 @@\n-  FREE_C_HEAP_ARRAY(FreeCSetStats, _worker_stats);\n-  _g1h->phase_times()->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n-  _g1h->clear_collection_set();\n-}\n@@ -604,3 +645,12 @@\n-double G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::worker_cost() const {\n-  return G1CollectedHeap::heap()->collection_set()->region_length();\n-}\n+  virtual ~FreeCollectionSetTask() {\n+    Ticks serial_time = Ticks::now();\n+    report_statistics();\n+    for (uint worker = 0; worker < _active_workers; worker++) {\n+      _worker_stats[worker].~FreeCSetStats();\n+    }\n+    FREE_C_HEAP_ARRAY(FreeCSetStats, _worker_stats);\n+    _g1h->phase_times()->record_serial_free_cset_time_ms((Ticks::now() - serial_time).seconds() * 1000.0);\n+    _g1h->clear_collection_set();\n+  }\n+\n+  double worker_cost() const override { return G1CollectedHeap::heap()->collection_set()->region_length(); }\n@@ -608,5 +658,7 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::set_max_workers(uint max_workers) {\n-  _active_workers = max_workers;\n-  _worker_stats = NEW_C_HEAP_ARRAY(FreeCSetStats, max_workers, mtGC);\n-  for (uint worker = 0; worker < _active_workers; worker++) {\n-    ::new (&_worker_stats[worker]) FreeCSetStats();\n+  void set_max_workers(uint max_workers) override {\n+    _active_workers = max_workers;\n+    _worker_stats = NEW_C_HEAP_ARRAY(FreeCSetStats, max_workers, mtGC);\n+    for (uint worker = 0; worker < _active_workers; worker++) {\n+      ::new (&_worker_stats[worker]) FreeCSetStats();\n+    }\n+    _claimer.set_n_workers(_active_workers);\n@@ -614,2 +666,0 @@\n-  _claimer.set_n_workers(_active_workers);\n-}\n@@ -617,6 +667,7 @@\n-void G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask::do_work(uint worker_id) {\n-  FreeCSetClosure cl(_surviving_young_words, worker_id, worker_stats(worker_id), _evac_failure_regions);\n-  _g1h->collection_set_par_iterate_all(&cl, &_claimer, worker_id);\n-  \/\/ Report per-region type timings.\n-  cl.report_timing();\n-}\n+  void do_work(uint worker_id) override {\n+    FreeCSetClosure cl(_surviving_young_words, worker_id, worker_stats(worker_id), _evac_failure_regions);\n+    _g1h->collection_set_par_iterate_all(&cl, &_claimer, worker_id);\n+    \/\/ Report per-region type timings.\n+    cl.report_timing();\n+  }\n+};\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":233,"deletions":182,"binary":false,"changes":415,"status":"modified"},{"patch":"@@ -56,42 +56,0 @@\n-class G1PostEvacuateCollectionSetCleanupTask1::MergePssTask : public G1AbstractSubTask {\n-  G1ParScanThreadStateSet* _per_thread_states;\n-\n-public:\n-  MergePssTask(G1ParScanThreadStateSet* per_thread_states);\n-\n-  double worker_cost() const override { return 1.0; }\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask1::RecalculateUsedTask : public G1AbstractSubTask {\n-public:\n-  RecalculateUsedTask() : G1AbstractSubTask(G1GCPhaseTimes::RecalculateUsed) { }\n-\n-  double worker_cost() const override;\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask1::SampleCollectionSetCandidatesTask : public G1AbstractSubTask {\n-public:\n-  SampleCollectionSetCandidatesTask() : G1AbstractSubTask(G1GCPhaseTimes::SampleCollectionSetCandidates) { }\n-\n-  static bool should_execute();\n-\n-  double worker_cost() const override;\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask1::RemoveSelfForwardPtrsTask : public G1AbstractSubTask {\n-  G1ParRemoveSelfForwardPtrsTask _task;\n-  G1EvacFailureRegions* _evac_failure_regions;\n-\n-public:\n-  RemoveSelfForwardPtrsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n-  ~RemoveSelfForwardPtrsTask();\n-\n-  static bool should_execute();\n-\n-  double worker_cost() const override;\n-  void do_work(uint worker_id) override;\n-};\n-\n@@ -124,91 +82,0 @@\n-class G1PostEvacuateCollectionSetCleanupTask2::ResetHotCardCacheTask : public G1AbstractSubTask {\n-public:\n-  ResetHotCardCacheTask() : G1AbstractSubTask(G1GCPhaseTimes::ResetHotCardCache) { }\n-\n-  double worker_cost() const override { return 0.5; }\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask2::PurgeCodeRootsTask : public G1AbstractSubTask {\n-public:\n-  PurgeCodeRootsTask() : G1AbstractSubTask(G1GCPhaseTimes::PurgeCodeRoots) { }\n-\n-  double worker_cost() const override { return 1.0; }\n-  void do_work(uint worker_id) override;\n-};\n-\n-#if COMPILER2_OR_JVMCI\n-class G1PostEvacuateCollectionSetCleanupTask2::UpdateDerivedPointersTask : public G1AbstractSubTask {\n-public:\n-  UpdateDerivedPointersTask() : G1AbstractSubTask(G1GCPhaseTimes::UpdateDerivedPointers) { }\n-\n-  double worker_cost() const override { return 1.0; }\n-  void do_work(uint worker_id) override;\n-};\n-#endif\n-\n-class G1PostEvacuateCollectionSetCleanupTask2::EagerlyReclaimHumongousObjectsTask : public G1AbstractSubTask {\n-  uint _humongous_regions_reclaimed;\n-  size_t _bytes_freed;\n-\n-public:\n-  EagerlyReclaimHumongousObjectsTask();\n-  virtual ~EagerlyReclaimHumongousObjectsTask();\n-\n-  static bool should_execute();\n-\n-  double worker_cost() const override { return 1.0; }\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask2::RestorePreservedMarksTask : public G1AbstractSubTask {\n-  PreservedMarksSet* _preserved_marks;\n-  AbstractGangTask* _task;\n-\n-public:\n-  RestorePreservedMarksTask(PreservedMarksSet* preserved_marks);\n-  virtual ~RestorePreservedMarksTask();\n-\n-  static bool should_execute();\n-\n-  double worker_cost() const override;\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask2::RedirtyLoggedCardsTask : public G1AbstractSubTask {\n-  G1RedirtyCardsQueueSet* _rdcqs;\n-  BufferNode* volatile _nodes;\n-  G1EvacFailureRegions* _evac_failure_regions;\n-\n-public:\n-  RedirtyLoggedCardsTask(G1RedirtyCardsQueueSet* rdcqs, G1EvacFailureRegions* evac_failure_regions);\n-  virtual ~RedirtyLoggedCardsTask();\n-\n-  double worker_cost() const override;\n-  void do_work(uint worker_id) override;\n-};\n-\n-class G1PostEvacuateCollectionSetCleanupTask2::FreeCollectionSetTask : public G1AbstractSubTask {\n-  G1CollectedHeap*  _g1h;\n-  G1EvacInfo* _evacuation_info;\n-  FreeCSetStats*    _worker_stats;\n-  HeapRegionClaimer _claimer;\n-  const size_t*     _surviving_young_words;\n-  uint              _active_workers;\n-  G1EvacFailureRegions* _evac_failure_regions;\n-\n-  FreeCSetStats* worker_stats(uint worker);\n-  void report_statistics();\n-\n-public:\n-  FreeCollectionSetTask(G1EvacInfo* evacuation_info,\n-                        const size_t* surviving_young_words,\n-                        G1EvacFailureRegions* evac_failure_regions);\n-  virtual ~FreeCollectionSetTask();\n-\n-  double worker_cost() const override;\n-  void set_max_workers(uint max_workers) override;\n-\n-  void do_work(uint worker_id) override;\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.hpp","additions":0,"deletions":133,"binary":false,"changes":133,"status":"modified"}]}