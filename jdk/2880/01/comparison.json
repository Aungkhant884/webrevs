{"files":[{"patch":"@@ -153,0 +153,1 @@\n+  bool _check_asyncs;\n@@ -154,1 +155,1 @@\n-  ThreadInVMfromJava(JavaThread* thread) : ThreadStateTransition(thread) {\n+  ThreadInVMfromJava(JavaThread* thread, bool check_asyncs = true) : ThreadStateTransition(thread), _check_asyncs(check_asyncs) {\n@@ -162,2 +163,3 @@\n-    \/\/ Check for pending. async. exceptions or suspends.\n-    if (_thread->has_special_runtime_exit_condition()) _thread->handle_special_runtime_exit_condition();\n+    \/\/ We prevent asynchronous exceptions from being installed on return to Java in situations\n+    \/\/ where we can't tolerate them. See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.\n+    if (_thread->has_special_runtime_exit_condition()) _thread->handle_special_runtime_exit_condition(_check_asyncs);\n@@ -225,0 +227,5 @@\n+\/\/ Parameter in_flight_mutex_addr is only used by class Mutex to avoid certain deadlock\n+\/\/ scenarios while making transitions that might block for a safepoint or handshake.\n+\/\/ It's the address of a pointer to the mutex we are trying to acquire. This will be used to\n+\/\/ access and release said mutex when transitioning back from blocked to vm (destructor) in\n+\/\/ case we need to stop for a safepoint or handshake.\n@@ -226,24 +233,0 @@\n- public:\n-  ThreadBlockInVM(JavaThread *thread)\n-  : ThreadStateTransition(thread) {\n-    \/\/ Once we are blocked vm expects stack to be walkable\n-    thread->frame_anchor()->make_walkable(thread);\n-    trans(_thread_in_vm, _thread_blocked);\n-  }\n-  ~ThreadBlockInVM() {\n-    trans(_thread_blocked, _thread_in_vm);\n-    \/\/ We don't need to clear_walkable because it will happen automagically when we return to java\n-  }\n-};\n-\n-\/\/ Unlike ThreadBlockInVM, this class is designed to avoid certain deadlock scenarios while making\n-\/\/ transitions inside class Mutex in cases where we need to block for a safepoint or handshake. It\n-\/\/ receives an extra argument compared to ThreadBlockInVM, the address of a pointer to the mutex we\n-\/\/ are trying to acquire. This will be used to access and release the mutex if needed to avoid\n-\/\/ said deadlocks.\n-\/\/ It works like ThreadBlockInVM but differs from it in two ways:\n-\/\/ - When transitioning in (constructor), it checks for safepoints without blocking, i.e., calls\n-\/\/   back if needed to allow a pending safepoint to continue but does not block in it.\n-\/\/ - When transitioning back (destructor), if there is a pending safepoint or handshake it releases\n-\/\/   the mutex that is only partially acquired.\n-class ThreadBlockInVMWithDeadlockCheck : public ThreadStateTransition {\n@@ -253,8 +236,0 @@\n-  void release_mutex() {\n-    assert(_in_flight_mutex_addr != NULL, \"_in_flight_mutex_addr should have been set on constructor\");\n-    Mutex* in_flight_mutex = *_in_flight_mutex_addr;\n-    if (in_flight_mutex != NULL) {\n-      in_flight_mutex->release_for_safepoint();\n-      *_in_flight_mutex_addr = NULL;\n-    }\n-  }\n@@ -262,1 +237,1 @@\n-  ThreadBlockInVMWithDeadlockCheck(JavaThread* thread, Mutex** in_flight_mutex_addr)\n+  ThreadBlockInVM(JavaThread* thread, Mutex** in_flight_mutex_addr = NULL)\n@@ -264,0 +239,2 @@\n+    assert(thread->thread_state() == _thread_in_vm, \"coming from wrong thread state\");\n+    thread->check_possible_safepoint();\n@@ -266,6 +243,0 @@\n-\n-    \/\/ All unsafe states are treated the same by the VMThread\n-    \/\/ so we can skip the _thread_in_vm_trans state here. Since\n-    \/\/ we don't read poll, it's enough to order the stores.\n-    OrderAccess::storestore();\n-\n@@ -274,1 +245,2 @@\n-  ~ThreadBlockInVMWithDeadlockCheck() {\n+  ~ThreadBlockInVM() {\n+    assert(_thread->thread_state() == _thread_blocked, \"coming from wrong thread state\");\n@@ -276,1 +248,1 @@\n-    _thread->set_thread_state_fence((JavaThreadState)(_thread_blocked_trans));\n+    _thread->set_thread_state_fence(_thread_blocked_trans);\n@@ -279,1 +251,3 @@\n-      release_mutex();\n+      if (_in_flight_mutex_addr != NULL) {\n+        release_mutex();\n+      }\n@@ -285,2 +259,0 @@\n-};\n-\n@@ -288,11 +260,5 @@\n-\/\/ This special transition class is only used to prevent asynchronous exceptions\n-\/\/ from being installed on vm exit in situations where we can't tolerate them.\n-\/\/ See bugs: 4324348, 4854693, 4998314, 5040492, 5050705.\n-class ThreadInVMfromJavaNoAsyncException : public ThreadStateTransition {\n- public:\n-  ThreadInVMfromJavaNoAsyncException(JavaThread* thread) : ThreadStateTransition(thread) {\n-    trans_from_java(_thread_in_vm);\n-  }\n-  ~ThreadInVMfromJavaNoAsyncException()  {\n-    if (_thread->stack_overflow_state()->stack_yellow_reserved_zone_disabled()) {\n-      _thread->stack_overflow_state()->enable_stack_yellow_reserved_zone();\n+  void release_mutex() {\n+    Mutex* in_flight_mutex = *_in_flight_mutex_addr;\n+    if (in_flight_mutex != NULL) {\n+      in_flight_mutex->release_for_safepoint();\n+      *_in_flight_mutex_addr = NULL;\n@@ -300,12 +266,0 @@\n-    trans(_thread_in_vm, _thread_in_Java);\n-    \/\/ NOTE: We do not check for pending. async. exceptions.\n-    \/\/ If we did and moved the pending async exception over into the\n-    \/\/ pending exception field, we would need to deopt (currently C2\n-    \/\/ only). However, to do so would require that we transition back\n-    \/\/ to the _thread_in_vm state. Instead we postpone the handling of\n-    \/\/ the async exception.\n-\n-\n-    \/\/ Check for pending. suspends only.\n-    if (_thread->has_special_runtime_exit_condition())\n-      _thread->handle_special_runtime_exit_condition(false);\n@@ -386,1 +340,1 @@\n-    ThreadInVMfromJavaNoAsyncException __tiv(thread);                \\\n+    ThreadInVMfromJava __tiv(thread, false \/* check asyncs *\/);      \\\n@@ -404,1 +358,1 @@\n-    ThreadInVMfromJavaNoAsyncException __tiv(thread);                \\\n+    ThreadInVMfromJava __tiv(thread, false \/* check asyncs *\/);      \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":26,"deletions":72,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,2 +87,2 @@\n-      { ThreadBlockInVMWithDeadlockCheck tbivmdc(self->as_Java_thread(), &in_flight_mutex);\n-        in_flight_mutex = this;  \/\/ save for ~ThreadBlockInVMWithDeadlockCheck\n+      { ThreadBlockInVM tbivmdc(self->as_Java_thread(), &in_flight_mutex);\n+        in_flight_mutex = this;  \/\/ save for ~ThreadBlockInVM\n@@ -92,1 +92,1 @@\n-        \/\/ Not unlocked by ~ThreadBlockInVMWithDeadlockCheck\n+        \/\/ Not unlocked by ~ThreadBlockInVM\n@@ -239,1 +239,1 @@\n-    ThreadBlockInVMWithDeadlockCheck tbivmdc(self, &in_flight_mutex);\n+    ThreadBlockInVM tbivmdc(self, &in_flight_mutex);\n@@ -248,1 +248,1 @@\n-    in_flight_mutex = this;  \/\/ save for ~ThreadBlockInVMWithDeadlockCheck\n+    in_flight_mutex = this;  \/\/ save for ~ThreadBlockInVM\n@@ -263,1 +263,1 @@\n-    \/\/ Not unlocked by ~ThreadBlockInVMWithDeadlockCheck\n+    \/\/ Not unlocked by ~ThreadBlockInVM\n","filename":"src\/hotspot\/share\/runtime\/mutex.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -971,1 +971,1 @@\n-      ThreadInVMfromJavaNoAsyncException __tiv(self);\n+      ThreadInVMfromJava __tiv(self, false \/* check asyncs *\/);\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}