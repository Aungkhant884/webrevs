{"files":[{"patch":"@@ -7224,1 +7224,0 @@\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -7253,0 +7252,1 @@\n+    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n@@ -7266,0 +7266,38 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      rbp_off,\n+      rbpH_off,\n+      return_off,\n+      return_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    int insts_size = 1024;\n+    int locs_size = 64;\n+    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm, rthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+    jfr_epilogue(_masm);\n+\n+    __ leave();\n+    __ ret(lr);\n+\n+    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -8264,2 +8302,9 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -8267,0 +8312,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3075,0 +3075,40 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      r1_off,\n+      r2_off,\n+      return_off,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+\n+    address start = __ pc();\n+    __ raw_push(R1, R2, LR);\n+    address the_pc = __ pc();\n+\n+    int frame_complete = the_pc - start;\n+\n+    __ set_last_Java_frame(SP, FP, true, Rtemp);\n+    __ mov(c_rarg0, Rthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+    __ reset_last_Java_frame(Rtemp);\n+\n+    __ raw_pop(R1, R2, LR);\n+    __ ret();\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(frame_complete, map);\n+\n+    RuntimeStub* stub =\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code,\n+                                    frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps,\n+                                    false);\n+    return stub;\n+  }\n+\n@@ -3119,2 +3159,9 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -3122,0 +3169,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -4683,0 +4683,35 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  RuntimeStub* generate_jfr_return_lease() {\n+    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+    MacroAssembler* _masm = new MacroAssembler(&code);\n+\n+    Register tmp1 = R10_ARG8;\n+    Register tmp2 = R9_ARG7;\n+\n+    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+    address start = __ pc();\n+    __ mflr(tmp1);\n+    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+    __ push_frame_reg_args(0, tmp1);\n+    int frame_complete = __ pc() - start;\n+    __ set_last_Java_frame(R1_SP, noreg);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+    address calls_return_pc = __ last_calls_return_pc();\n+    __ reset_last_Java_frame();\n+    __ pop_frame();\n+    __ ld(tmp1, _abi0(lr), R1_SP);\n+    __ mtlr(tmp1);\n+    __ blr();\n+\n+    OopMapSet* oop_maps = new OopMapSet();\n+    OopMap* map = new OopMap(framesize, 0);\n+    oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(code.name(),\n+                                    &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -4731,2 +4766,9 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4734,0 +4776,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":45,"deletions":2,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -3926,1 +3926,0 @@\n-    __ resolve_global_jobject(x10, t0, t1);\n@@ -3955,0 +3954,1 @@\n+    __ resolve_global_jobject(x10, t0, t1);\n@@ -3968,0 +3968,38 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      fp_off,\n+      fp_off2,\n+      return_off,\n+      return_off2,\n+      framesize \/\/ inclusive of return address\n+    };\n+\n+    int insts_size = 1024;\n+    int locs_size = 64;\n+    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm, xthread);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+    jfr_epilogue(_masm);\n+    __ leave();\n+    __ ret();\n+\n+    OopMap* map = new OopMap(framesize, 1);\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -4011,2 +4049,9 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4014,0 +4059,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":49,"deletions":3,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -3088,1 +3088,8 @@\n-  #endif \/\/ INCLUD_JFR\n+\n+  RuntimeStub* generate_jfr_return_lease() {\n+    if (!Continuations::enabled()) return nullptr;\n+    Unimplemented();\n+    return nullptr;\n+  }\n+\n+  #endif \/\/ INCLUDE_JFR\n@@ -3136,2 +3143,9 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n+  }\n+\n+#ifdef INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -3139,0 +3153,1 @@\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -4014,1 +4014,0 @@\n-    __ resolve_global_jobject(rax, java_thread, rdx);\n@@ -4047,0 +4046,1 @@\n+    __ resolve_global_jobject(rax, rdi, rdx);\n@@ -4060,0 +4060,41 @@\n+  \/\/ For c2: call to return a leased buffer.\n+  static RuntimeStub* generate_jfr_return_lease() {\n+    enum layout {\n+      FPUState_off = 0,\n+      rbp_off = FPUStateSizeInWords,\n+      rdi_off,\n+      rsi_off,\n+      rcx_off,\n+      rbx_off,\n+      saved_argument_off,\n+      saved_argument_off2, \/\/ 2nd half of double\n+      framesize\n+    };\n+\n+    int insts_size = 1024;\n+    int locs_size = 64;\n+    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+    OopMapSet* oop_maps = new OopMapSet();\n+    MacroAssembler* masm = new MacroAssembler(&code);\n+    MacroAssembler* _masm = masm;\n+\n+    address start = __ pc();\n+    __ enter();\n+    int frame_complete = __ pc() - start;\n+    address the_pc = __ pc();\n+    jfr_prologue(the_pc, _masm);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+    jfr_epilogue(_masm);\n+    __ leave();\n+    __ ret(0);\n+\n+    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+    oop_maps->add_gc_map(the_pc - start, map);\n+\n+    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                    oop_maps, false);\n+    return stub;\n+  }\n+\n@@ -4151,2 +4192,1 @@\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-    JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+    JFR_ONLY(generate_jfr_stubs();)\n@@ -4155,0 +4195,9 @@\n+#if INCLUDE_JFR\n+  void generate_jfr_stubs() {\n+    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+  }\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":52,"deletions":3,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -3753,0 +3753,41 @@\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  MacroAssembler* _masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n@@ -3952,2 +3993,1 @@\n-  JFR_ONLY(StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();)\n-  JFR_ONLY(StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();)\n+  JFR_ONLY(generate_jfr_stubs();)\n@@ -3956,0 +3996,9 @@\n+#if INCLUDE_JFR\n+void StubGenerator::generate_jfr_stubs() {\n+  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n+  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n+  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n+  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n+}\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":51,"deletions":2,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-\n+  void generate_jfr_stubs();\n@@ -528,1 +528,2 @@\n-\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  RuntimeStub* generate_jfr_return_lease();\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -472,4 +472,0 @@\n-#ifdef JFR_HAVE_INTRINSICS\n-  void do_getEventWriter(Intrinsic* x);\n-#endif\n-\n","filename":"src\/hotspot\/share\/c1\/c1_LIRGenerator.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -293,3 +293,7 @@\n-JVM_ENTRY_NO_ENV(jboolean, jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size))\n-  return JfrJavaEventWriter::flush(writer, used_size, requested_size, thread);\n-JVM_END\n+NO_TRANSITION(void, jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size))\n+  JfrJavaEventWriter::flush(writer, used_size, requested_size, JavaThread::current());\n+NO_TRANSITION_END\n+\n+NO_TRANSITION(jlong, jfr_commit(JNIEnv* env, jclass jvm, jlong next_position))\n+  return JfrJavaEventWriter::commit(next_position);\n+NO_TRANSITION_END\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+jlong JNICALL jfr_commit(JNIEnv* env, jclass cls, jlong next_position);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,1 +74,2 @@\n-      (char*)\"flush\", (char*)\"(Ljdk\/jfr\/internal\/event\/EventWriter;II)Z\", (void*)jfr_event_writer_flush,\n+      (char*)\"flush\", (char*)\"(Ljdk\/jfr\/internal\/event\/EventWriter;II)V\", (void*)jfr_event_writer_flush,\n+      (char*)\"commit\", (char*)\"(J)J\", (void*)jfr_commit,\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethodRegistration.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"jfr\/recorder\/stringpool\/jfrStringPool.hpp\"\n@@ -496,0 +497,1 @@\n+  JfrStringPool::on_epoch_shift();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -262,0 +262,8 @@\n+\n+ByteSize JfrBuffer::pos_offset() {\n+  return byte_offset_of(JfrBuffer, _pos);\n+}\n+\n+ByteSize JfrBuffer::flags_offset() {\n+  return byte_offset_of(JfrBuffer, _flags);\n+}\n\\ No newline at end of file\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -177,0 +178,5 @@\n+\n+  \/\/ Code generation\n+  static ByteSize pos_offset();\n+  static ByteSize flags_offset();\n+\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrBuffer.hpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -175,1 +176,1 @@\n-static BufferPtr acquire_promotion_buffer(size_t size, JfrStorageMspace* mspace, JfrStorage& storage_instance, size_t retry_count, Thread* thread) {\n+BufferPtr JfrStorage::acquire_promotion_buffer(size_t size, JfrStorageMspace* mspace, JfrStorage& storage_instance, size_t retry_count, Thread* thread) {\n@@ -178,2 +179,5 @@\n-    BufferPtr buffer= mspace_acquire_live_with_retry(size, mspace, retry_count, thread);\n-    if (buffer == nullptr && storage_instance.control().should_discard()) {\n+    BufferPtr buffer = mspace_acquire_live_with_retry(size, mspace, retry_count, thread);\n+    if (buffer != nullptr) {\n+      return buffer;\n+    }\n+    if (storage_instance.control().should_discard()) {\n@@ -183,1 +187,1 @@\n-    return buffer;\n+    return storage_instance.control().to_disk() ? JfrStorage::acquire_transient(size, thread) : nullptr;\n@@ -253,0 +257,4 @@\n+  if (promotion_buffer->transient()) {\n+    promotion_buffer->set_retired();\n+    register_full(promotion_buffer, thread);\n+  }\n@@ -279,1 +287,0 @@\n-  assert(buffer->acquired_by(thread), \"invariant\");\n@@ -282,0 +289,9 @@\n+    if (thread->is_Java_thread()) {\n+      JavaThread* jt = JavaThread::cast(thread);\n+      if (jt->thread_state() == _thread_in_native) {\n+        \/\/ Transition java thread to vm so it can issue a notify.\n+        ThreadInVMfromNative transition(jt);\n+        _post_box.post(MSG_FULLBUFFER);\n+        return;\n+      }\n+    }\n@@ -329,1 +345,0 @@\n-      assert(oldest->identity() != nullptr, \"invariant\");\n@@ -338,0 +353,1 @@\n+      assert(oldest->identity() != nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.cpp","additions":22,"deletions":6,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,1 @@\n+  BufferPtr acquire_promotion_buffer(size_t size, JfrStorageMspace* mspace, JfrStorage& storage_instance, size_t retry_count, Thread* thread);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/storage\/jfrStorage.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+#include \"classfile\/symbolTable.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n@@ -42,0 +45,39 @@\n+static int generation_offset = invalid_offset;\n+static jobject string_pool = nullptr;\n+\n+static unsigned short generation = 0;\n+\n+static bool setup_string_pool_offsets(TRAPS) {\n+  const char class_name[] = \"jdk\/jfr\/internal\/StringPool\";\n+  Symbol* const k_sym = SymbolTable::new_symbol(class_name);\n+  assert(k_sym != nullptr, \"invariant\");\n+  Klass* klass = SystemDictionary::resolve_or_fail(k_sym, true, CHECK_false);\n+  assert(klass != nullptr, \"invariant\");\n+  klass->initialize(CHECK_false);\n+  assert(!klass->should_be_initialized(), \"invariant\");\n+  assert(string_pool == nullptr, \"invariant\");\n+  jobject pool = JfrJavaSupport::global_jni_handle(klass->java_mirror(), THREAD);\n+  if (pool == nullptr) {\n+    return false;\n+  }\n+  const char generation_name[] = \"generation\";\n+  Symbol* const generation_sym = SymbolTable::new_symbol(generation_name);\n+  assert(generation_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == generation_offset, \"invariant\");\n+  if (!JfrJavaSupport::compute_field_offset(generation_offset, klass, generation_sym, vmSymbols::short_signature(), true)) {\n+    JfrJavaSupport::destroy_global_jni_handle(pool);\n+    return false;\n+  }\n+  assert(generation_offset != invalid_offset, \"invariant\");\n+  string_pool = pool;\n+  return true;\n+}\n+\n+static bool initialize_java_string_pool() {\n+  static bool initialized = false;\n+  if (!initialized) {\n+    initialized = setup_string_pool_offsets(JavaThread::current());\n+  }\n+  return initialized;\n+}\n+\n@@ -78,0 +120,4 @@\n+  if (!initialize_java_string_pool()) {\n+    return false;\n+  }\n+\n@@ -233,0 +279,9 @@\n+\n+void JfrStringPool::on_epoch_shift() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"invariant\");\n+  assert(!JfrTraceIdEpoch::is_synchronizing(), \"invariant\");\n+  assert(string_pool != nullptr, \"invariant\");\n+  oop mirror = JfrJavaSupport::resolve_non_null(string_pool);\n+  assert(mirror != nullptr, \"invariant\");\n+  mirror->short_field_put(generation_offset, generation++);\n+}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.cpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+  static void on_epoch_shift();\n@@ -76,0 +77,1 @@\n+  friend class JfrCheckpointManager;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/stringpool\/jfrStringPool.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,10 @@\n+void JfrIntrinsicSupport::return_lease(JavaThread* jt) {\n+  DEBUG_ONLY(assert_precondition(jt);)\n+  ThreadStateTransition::transition_from_java(jt, _thread_in_native);\n+  assert(jt->jfr_thread_local()->has_java_event_writer(), \"invariant\");\n+  assert(jt->jfr_thread_local()->shelved_buffer() != nullptr, \"invariant\");\n+  JfrJavaEventWriter::flush(jt->jfr_thread_local()->java_event_writer(), 0, 0, jt);\n+  assert(jt->jfr_thread_local()->shelved_buffer() == nullptr, \"invariant\");\n+  ThreadStateTransition::transition_from_native(jt, _thread_in_Java);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+  static void return_lease(JavaThread* jt);\n@@ -64,1 +65,1 @@\n-\n+  do_intrinsic(_jvm_commit,   jdk_jfr_internal_JVM, commit_name, long_long_signature, F_SN)\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrIntrinsics.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"jfr\/recorder\/storage\/jfrBuffer.hpp\"\n@@ -52,0 +53,12 @@\n+#define JAVA_BUFFER_OFFSET_JFR \\\n+  JfrThreadLocal::java_buffer_offset() + THREAD_LOCAL_OFFSET_JFR\n+\n+#define NOTIFY_OFFSET_JFR \\\n+  JfrThreadLocal::notified_offset() + THREAD_LOCAL_OFFSET_JFR\n+\n+#define JFR_BUFFER_POS_OFFSET \\\n+  JfrBuffer::pos_offset()\n+\n+#define JFR_BUFFER_FLAGS_OFFSET \\\n+  JfrBuffer::flags_offset()\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadExtension.hpp","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+  _notified(false),\n@@ -250,0 +251,4 @@\n+ByteSize JfrThreadLocal::java_buffer_offset() {\n+  return byte_offset_of(JfrThreadLocal, _java_buffer);\n+}\n+\n@@ -266,0 +271,4 @@\n+ByteSize JfrThreadLocal::notified_offset() {\n+  return byte_offset_of(JfrThreadLocal, _notified);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  bool _notified;\n@@ -253,0 +254,12 @@\n+  bool is_notified() {\n+    return _notified;\n+  }\n+\n+  void notify() {\n+    _notified = true;\n+  }\n+\n+  void clear_notification() {\n+    _notified = false;\n+  }\n+\n@@ -276,0 +289,1 @@\n+  static ByteSize java_buffer_offset();\n@@ -280,0 +294,1 @@\n+  static ByteSize notified_offset();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrThreadLocal.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -48,1 +49,0 @@\n-static int notified_offset = invalid_offset;\n@@ -67,7 +67,0 @@\n-  const char start_pos_address_name[] = \"startPositionAddress\";\n-  Symbol* const start_pos_address_sym = SymbolTable::new_symbol(start_pos_address_name);\n-  assert(start_pos_address_sym != nullptr, \"invariant\");\n-  assert(invalid_offset == start_pos_address_offset, \"invariant\");\n-  JfrJavaSupport::compute_field_offset(start_pos_address_offset, klass, start_pos_address_sym, vmSymbols::long_signature());\n-  assert(start_pos_address_offset != invalid_offset, \"invariant\");\n-\n@@ -88,7 +81,0 @@\n-  const char notified_name[] = \"notified\";\n-  Symbol* const notified_sym = SymbolTable::new_symbol(notified_name);\n-  assert (notified_sym != nullptr, \"invariant\");\n-  assert(invalid_offset == notified_offset, \"invariant\");\n-  JfrJavaSupport::compute_field_offset(notified_offset, klass, notified_sym, vmSymbols::bool_signature());\n-  assert(notified_offset != invalid_offset, \"invariant\");\n-\n@@ -126,2 +112,2 @@\n-jboolean JfrJavaEventWriter::flush(jobject writer, jint used, jint requested, JavaThread* jt) {\n-  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_vm(jt));\n+void JfrJavaEventWriter::flush(jobject writer, jint used, jint requested, JavaThread* jt) {\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n@@ -129,2 +115,0 @@\n-  oop const w = JNIHandles::resolve_non_null(writer);\n-  assert(w != nullptr, \"invariant\");\n@@ -141,0 +125,4 @@\n+  \/\/ can safepoint here\n+  ThreadInVMfromNative transition(jt);\n+  oop const w = JNIHandles::resolve_non_null(writer);\n+  assert(w != nullptr, \"invariant\");\n@@ -145,1 +133,0 @@\n-    w->long_field_put(start_pos_address_offset, (jlong)buffer->pos_address());\n@@ -151,1 +138,0 @@\n-    return JNI_FALSE;\n@@ -153,5 +139,28 @@\n-  \/\/ An exclusive use of a leased buffer is treated equivalent to\n-  \/\/ holding a system resource. As such, it should be released as soon as possible.\n-  \/\/ Returning true here signals that the thread will need to call flush again\n-  \/\/ on EventWriter.endEvent() and that flush will return the lease.\n-  return buffer->lease() ? JNI_TRUE : JNI_FALSE;\n+}\n+\n+jlong JfrJavaEventWriter::commit(jlong next_position) {\n+  assert(next_position != 0, \"invariant\");\n+  JavaThread* const jt = JavaThread::current();\n+  assert(jt != nullptr, \"invariant\");\n+  DEBUG_ONLY(JfrJavaSupport::check_java_thread_in_native(jt));\n+  JfrThreadLocal* const tl = jt->jfr_thread_local();\n+  assert(tl != nullptr, \"invariant\");\n+  assert(tl->has_java_event_writer(), \"invariant\");\n+  assert(tl->has_java_buffer(), \"invariant\");\n+  JfrBuffer* const current = tl->java_buffer();\n+  assert(current != nullptr, \"invariant\");\n+  u1* const next = reinterpret_cast<u1*>(next_position);\n+  assert(next >= current->start(), \"invariant\");\n+  assert(next <= current->end(), \"invariant\");\n+  if (tl->is_notified()) {\n+    tl->clear_notification();\n+    return reinterpret_cast<jlong>(current->pos());\n+  }\n+  \/\/ set_pos() has release semantics\n+  current->set_pos(next);\n+  if (!current->lease()) {\n+    return next_position;\n+  }\n+  assert(current->lease(), \"invariant\");\n+  flush(tl->java_event_writer(), 0, 0, jt);\n+  return 0; \/\/ signals that the buffer lease was returned.\n@@ -201,3 +210,8 @@\n-    oop buffer_writer = JNIHandles::resolve_non_null(jt->jfr_thread_local()->java_event_writer());\n-    assert(buffer_writer != nullptr, \"invariant\");\n-    buffer_writer->release_bool_field_put(notified_offset, JNI_TRUE);\n+    JfrThreadLocal* const tl = jt->jfr_thread_local();\n+    assert(tl != nullptr, \"invariant\");\n+    oop event_writer = JNIHandles::resolve_non_null(tl->java_event_writer());\n+    assert(event_writer != nullptr, \"invariant\");\n+    const jlong start_pos = event_writer->long_field(start_pos_offset);\n+    if (event_writer->long_field(current_pos_offset) > start_pos) {\n+      tl->notify();\n+    }\n@@ -213,1 +227,1 @@\n-  static const char signature[] = \"(JJJJZZ)V\";\n+  static const char signature[] = \"(JJJZZ)V\";\n@@ -220,1 +234,0 @@\n-  args.push_long((jlong)buffer->pos_address());\n@@ -231,1 +244,0 @@\n-  assert(tl->shelved_buffer() == nullptr, \"invariant\");\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":44,"deletions":32,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+class JfrBuffer;\n@@ -51,1 +52,2 @@\n-  static jboolean flush(jobject writer, jint used, jint requested, JavaThread* jt);\n+  static void flush(jobject writer, jint used, jint requested, JavaThread* jt);\n+  static jlong commit(jlong next_position);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -675,0 +675,1 @@\n+  case vmIntrinsics::_jvm_commit:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -497,0 +497,1 @@\n+  case vmIntrinsics::_jvm_commit:               return inline_native_jvm_commit();\n@@ -3006,0 +3007,130 @@\n+\/\/------------------------inline_native_jvm_commit------------------\n+bool LibraryCallKit::inline_native_jvm_commit() {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory and i_o state.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+  Node* input_io_state = i_o();\n+\n+  \/\/ TLS.\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  \/\/ Jfr java buffer.\n+  Node* java_buffer_offset = _gvn.transform(new AddPNode(top(), tls_ptr, _gvn.transform(MakeConX(in_bytes(JAVA_BUFFER_OFFSET_JFR)))));\n+  Node* java_buffer = _gvn.transform(new LoadPNode(control(), input_memory_state, java_buffer_offset, TypePtr::BOTTOM, TypeRawPtr::NOTNULL, MemNode::unordered));\n+  Node* java_buffer_pos_offset = _gvn.transform(new AddPNode(top(), java_buffer, _gvn.transform(MakeConX(in_bytes(JFR_BUFFER_POS_OFFSET)))));\n+\n+  \/\/ Load the current value of the notified field in the JfrThreadLocal.\n+  Node* notified_offset =  basic_plus_adr(top(), tls_ptr, in_bytes(NOTIFY_OFFSET_JFR));\n+  Node* notified = make_load(control(), notified_offset, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n+  \/\/ Test for notification.\n+  Node* notified_cmp = _gvn.transform(new CmpINode(notified, _gvn.intcon(1)));\n+  Node* test_notified = _gvn.transform(new BoolNode(notified_cmp, BoolTest::eq));\n+  IfNode* iff_notified = create_and_map_if(control(), test_notified, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ True branch, is notified.\n+  Node* is_notified = _gvn.transform(new IfTrueNode(iff_notified));\n+  set_control(is_notified);\n+\n+  \/\/ Reset notified state.\n+  Node* notified_reset_memory = store_to_memory(control(), notified_offset, _gvn.intcon(0), T_BOOLEAN, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ Iff notified, the return address of the commit method is the current position of the backing java buffer. This is used to reset the event writer.\n+  Node* current_pos_X = _gvn.transform(new LoadXNode(control(), input_memory_state, java_buffer_pos_offset, TypeRawPtr::NOTNULL, TypeX_X, MemNode::unordered));\n+  \/\/ Convert the machine-word to a long.\n+  Node* current_pos = _gvn.transform(ConvX2L(current_pos_X));\n+\n+  \/\/ False branch, not notified.\n+  Node* not_notified = _gvn.transform(new IfFalseNode(iff_notified));\n+  set_control(not_notified);\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ Arg is the next position as a long.\n+  Node* arg = argument(0);\n+  \/\/ Convert long to machine-word.\n+  Node* next_pos_X = _gvn.transform(ConvL2X(arg));\n+\n+  \/\/ Store the next_position to the underlying jfr java buffer.\n+  Node* commit_memory;\n+#ifdef _LP64\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_LONG, Compile::AliasIdxRaw, MemNode::release);\n+#else\n+  commit_memory = store_to_memory(control(), java_buffer_pos_offset, next_pos_X, T_INT, Compile::AliasIdxRaw, MemNode::release);\n+#endif\n+\n+  \/\/ Now load the flags from off the java buffer and decide if the buffer is a lease. If so, it needs to be returned post-commit.\n+  Node* java_buffer_flags_offset = _gvn.transform(new AddPNode(top(), java_buffer, _gvn.transform(MakeConX(in_bytes(JFR_BUFFER_FLAGS_OFFSET)))));\n+  Node* flags = make_load(control(), java_buffer_flags_offset, TypeInt::UBYTE, T_BYTE, MemNode::unordered);\n+  Node* lease_constant = _gvn.transform(_gvn.intcon(4));\n+\n+  \/\/ And flags with lease constant.\n+  Node* lease = _gvn.transform(new AndINode(flags, lease_constant));\n+\n+  \/\/ Branch on lease to conditionalize returning the leased java buffer.\n+  Node* lease_cmp = _gvn.transform(new CmpINode(lease, lease_constant));\n+  Node* test_lease = _gvn.transform(new BoolNode(lease_cmp, BoolTest::eq));\n+  IfNode* iff_lease = create_and_map_if(control(), test_lease, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, not a lease.\n+  Node* not_lease = _gvn.transform(new IfFalseNode(iff_lease));\n+\n+  \/\/ True branch, is lease.\n+  Node* is_lease = _gvn.transform(new IfTrueNode(iff_lease));\n+  set_control(is_lease);\n+\n+  \/\/ Make a runtime call, which can safepoint, to return the leased buffer. This updates both the JfrThreadLocal and the Java event writer oop.\n+  Node* call_return_lease = make_runtime_call(RC_NO_LEAF,\n+                                              OptoRuntime::void_void_Type(),\n+                                              StubRoutines::jfr_return_lease(),\n+                                              \"return_lease\", TypePtr::BOTTOM);\n+  Node* call_return_lease_control = _gvn.transform(new ProjNode(call_return_lease, TypeFunc::Control));\n+\n+  RegionNode* lease_compare_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(lease_compare_rgn);\n+  PhiNode* lease_compare_mem = new PhiNode(lease_compare_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(lease_compare_mem);\n+  PhiNode* lease_compare_io = new PhiNode(lease_compare_rgn, Type::ABIO);\n+  record_for_igvn(lease_compare_io);\n+  PhiNode* lease_result_value = new PhiNode(lease_compare_rgn, TypeLong::LONG);\n+  record_for_igvn(lease_result_value);\n+\n+  \/\/ Update control and phi nodes.\n+  lease_compare_rgn->init_req(_true_path, call_return_lease_control);\n+  lease_compare_rgn->init_req(_false_path, not_lease);\n+\n+  lease_compare_mem->init_req(_true_path, _gvn.transform(reset_memory()));\n+  lease_compare_mem->init_req(_false_path, commit_memory);\n+\n+  lease_compare_io->init_req(_true_path, i_o());\n+  lease_compare_io->init_req(_false_path, input_io_state);\n+\n+  lease_result_value->init_req(_true_path, null()); \/\/ if the lease was returned, return 0.\n+  lease_result_value->init_req(_false_path, arg); \/\/ if not lease, return new updated position.\n+\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  PhiNode* result_io = new PhiNode(result_rgn, Type::ABIO);\n+  PhiNode* result_value = new PhiNode(result_rgn, TypeLong::LONG);\n+\n+  \/\/ Update control and phi nodes.\n+  result_rgn->init_req(_true_path, is_notified);\n+  result_rgn->init_req(_false_path, _gvn.transform(lease_compare_rgn));\n+\n+  result_mem->init_req(_true_path, notified_reset_memory);\n+  result_mem->init_req(_false_path, _gvn.transform(lease_compare_mem));\n+\n+  result_io->init_req(_true_path, input_io_state);\n+  result_io->init_req(_false_path, _gvn.transform(lease_compare_io));\n+\n+  result_value->init_req(_true_path, current_pos);\n+  result_value->init_req(_false_path, _gvn.transform(lease_result_value));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+  set_i_o(_gvn.transform(result_io));\n+  set_result(result_rgn, result_value);\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":131,"deletions":0,"binary":false,"changes":131,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+  bool inline_native_jvm_commit();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -389,1 +389,1 @@\n-  JFR_ONLY(JfrConditionalFlushWithStacktrace<EventJavaMonitorEnter> flush(current);)\n+  JFR_ONLY(JfrConditionalFlush<EventJavaMonitorEnter> flush(current);)\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,0 +185,2 @@\n+JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n+JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -263,0 +263,2 @@\n+  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n+  JFR_ONLY(static address _jfr_return_lease;)\n@@ -460,0 +462,1 @@\n+  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -430,1 +430,11 @@\n-    public static native boolean flush(EventWriter writer, int uncommittedSize, int requestedSize);\n+    public static native void flush(EventWriter writer, int uncommittedSize, int requestedSize);\n+\n+    \/**\n+     * Commits an event to the underlying buffer by setting the nextPosition.\n+     *\n+     * @param nextPosition\n+     *\n+     * @return the next startPosition\n+     *\/\n+    @IntrinsicCandidate\n+    public static native long commit(long nextPosition);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVM.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+    \/* mask for constructing generation relative string id. *\/\n+    private static final long SID_MASK = -65536;\n@@ -51,0 +53,2 @@\n+    \/* string pool generation (0-65535) set by the JVM on epoch shift. Not private to avoid being optimized away. *\/\n+    static short generation = 0;\n@@ -52,4 +56,33 @@\n-    public static void reset() {\n-        cache.clear();\n-        synchronized (StringPool.class) {\n-            currentSizeUTF16 = 0;\n+    \/* internalSid is a composite id [48-bit externalSid][16-bit generation]. *\/\n+    private static boolean isCurrentGeneration(long internalSid) {\n+        return generation == (short)internalSid;\n+    }\n+\n+    private static long updateInternalSid(long internalSid) {\n+        return (internalSid & SID_MASK) | generation;\n+    }\n+\n+    private static long nextInternalSid() {\n+        return sidIdx.getAndIncrement() << 16  | generation;\n+    }\n+\n+    \/* externalSid is the most significant 48-bits of the internalSid. *\/\n+    private static long externalSid(long internalSid) {\n+        return internalSid >> 16;\n+    }\n+\n+    \/* synchronized because of writing the string to the JVM. *\/\n+    private static synchronized long storeString(String s) {\n+        Long lsid = cache.get(s);\n+        long internalSid;\n+        if (lsid != null) {\n+            internalSid = lsid.longValue();\n+            if (isCurrentGeneration(internalSid)) {\n+                \/\/ Someone already updated the cache.\n+                return externalSid(internalSid);\n+            }\n+            internalSid = updateInternalSid(internalSid);\n+        } else {\n+            \/\/ Not yet added or the cache was cleared.\n+            internalSid = nextInternalSid();\n+            currentSizeUTF16 += s.length();\n@@ -57,0 +90,11 @@\n+        long extSid = externalSid(internalSid);\n+        \/\/ Write the string to the JVM before publishing to the cache.\n+        JVM.addStringConstant(extSid, s);\n+        cache.put(s, internalSid);\n+        return extSid;\n+    }\n+\n+    \/* a string fetched from the string pool must be of the current generation *\/\n+    private static long ensureCurrentGeneration(String s, Long lsid) {\n+        long internalSid = lsid.longValue();\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n@@ -59,0 +103,9 @@\n+    \/*\n+     * The string pool uses a generational id scheme to sync the JVM and Java sides.\n+     * The string pool relies on the EventWriter and its implementation, especially\n+     * its ability to restart event write attempts on interleaving epoch shifts.\n+     * Even though a string id is generationally valid during StringPool lookup,\n+     * the JVM can evolve the generation before the event is committed,\n+     * effectively invalidating the fetched string id. The event restart mechanism\n+     * of the EventWriter ensures that committed strings are in the correct generation.\n+     *\/\n@@ -62,1 +115,1 @@\n-            return lsid.longValue();\n+            return ensureCurrentGeneration(s, lsid);\n@@ -75,11 +128,0 @@\n-    private static long storeString(String s) {\n-        long sid = sidIdx.getAndIncrement();\n-        \/* we can race but it is ok *\/\n-        cache.put(s, sid);\n-        synchronized (StringPool.class) {\n-            JVM.addStringConstant(sid, s);\n-            currentSizeUTF16 += s.length();\n-        }\n-        return sid;\n-    }\n-\n@@ -103,0 +145,5 @@\n+\n+    private static synchronized void reset() {\n+        cache.clear();\n+        currentSizeUTF16 = 0;\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":64,"deletions":17,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -65,1 +65,0 @@\n-    private long startPositionAddress;\n@@ -69,1 +68,0 @@\n-    boolean notified; \/\/ Not private to avoid being optimized away\n@@ -73,1 +71,0 @@\n-    private boolean flushOnEnd;\n@@ -215,4 +212,0 @@\n-        if (flushOnEnd) {\n-            flushOnEnd = flush();\n-        }\n-        valid = true;\n@@ -226,1 +219,1 @@\n-            flushOnEnd = flush(usedSize(), requestedSize);\n+            flush(usedSize(), requestedSize);\n@@ -235,12 +228,0 @@\n-    private boolean isNotified() {\n-        return notified;\n-    }\n-\n-    private void resetNotified() {\n-        notified = false;\n-    }\n-\n-    private void resetStringPool() {\n-        StringPool.reset();\n-    }\n-\n@@ -251,2 +232,2 @@\n-    private boolean flush() {\n-        return flush(usedSize(), 0);\n+    private void flush() {\n+        flush(usedSize(), 0);\n@@ -255,2 +236,2 @@\n-    private boolean flush(int usedSize, int requestedSize) {\n-        return JVM.flush(this, usedSize, requestedSize);\n+    private void flush(int usedSize, int requestedSize) {\n+        JVM.flush(this, usedSize, requestedSize);\n@@ -259,1 +240,0 @@\n-\n@@ -280,0 +260,1 @@\n+            valid = true;\n@@ -287,1 +268,0 @@\n-\n@@ -301,7 +281,5 @@\n-\n-        if (isNotified()) {\n-            resetNotified();\n-            resetStringPool();\n-            reset();\n-            \/\/ returning false will trigger restart of the event write attempt\n-            return false;\n+        long nextPosition = JVM.commit(currentPosition);\n+        if (nextPosition == currentPosition) {\n+            \/\/ Successful commit. Update the writer start position.\n+            startPosition = nextPosition;\n+            return true;\n@@ -309,6 +287,4 @@\n-        startPosition = currentPosition;\n-        unsafe.storeStoreFence();\n-        unsafe.putAddress(startPositionAddress, currentPosition);\n-        \/\/ the event is now committed\n-        if (flushOnEnd) {\n-            flushOnEnd = flush();\n+        \/\/ If nextPosition == 0, the event was committed, the underlying buffer lease\n+        \/\/ returned and new writer positions updated. Nothing to do.\n+        if (nextPosition == 0) {\n+            return true;\n@@ -316,1 +292,5 @@\n-        return true;\n+        \/\/ The commit was aborted because of an interleaving epoch shift.\n+        \/\/ The nextPosition returned is the current start position.\n+        \/\/ Reset the writer and return false to restart the write attempt.\n+        currentPosition = nextPosition;\n+        return false;\n@@ -319,1 +299,1 @@\n-    private EventWriter(long startPos, long maxPos, long startPosAddress, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n@@ -322,1 +302,0 @@\n-        startPositionAddress = startPosAddress;\n@@ -324,1 +303,0 @@\n-        flushOnEnd = false;\n@@ -326,1 +304,0 @@\n-        notified = false;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":21,"deletions":44,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,0 @@\n- * @ignore\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestChunkIntegrity.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}