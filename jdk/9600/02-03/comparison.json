{"files":[{"patch":"@@ -180,1 +180,0 @@\n-  \/\/ PPC only\n@@ -182,1 +181,0 @@\n-  static void* resolve_function_descriptor(void* p);\n","filename":"src\/hotspot\/os\/aix\/os_aix.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4464,0 +4464,83 @@\n+#if defined(IA32) && !defined(ZERO)\n+\/*\n+ * Work-around (execute code at a high address) for broken NX emulation using CS limit,\n+ * Red Hat patch \"Exec-Shield\" (IA32 only).\n+ *\n+ * Map and execute at a high VA to prevent CS lazy updates race with SMP MM\n+ * invalidation.Further code generation by the JVM will no longer cause CS limit\n+ * updates.\n+ *\n+ * Affects IA32: RHEL 5 & 6, Ubuntu 10.04 (LTS), 10.10, 11.04, 11.10, 12.04.\n+ * @see JDK-8023956\n+ *\/\n+void workaround_expand_exec_shield_cs_limit() {\n+  assert(os::Linux::initial_thread_stack_bottom() != NULL, \"sanity\");\n+  size_t page_size = os::vm_page_size();\n+\n+  \/*\n+   * JDK-8197429\n+   *\n+   * Expand the stack mapping to the end of the initial stack before\n+   * attempting to install the codebuf.  This is needed because newer\n+   * Linux kernels impose a distance of a megabyte between stack\n+   * memory and other memory regions.  If we try to install the\n+   * codebuf before expanding the stack the installation will appear\n+   * to succeed but we'll get a segfault later if we expand the stack\n+   * in Java code.\n+   *\n+   *\/\n+  if (os::is_primordial_thread()) {\n+    address limit = os::Linux::initial_thread_stack_bottom();\n+    if (! DisablePrimordialThreadGuardPages) {\n+      limit += StackOverflow::stack_red_zone_size() +\n+               StackOverflow::stack_yellow_zone_size();\n+    }\n+    os::Linux::expand_stack_to(limit);\n+  }\n+\n+  \/*\n+   * Take the highest VA the OS will give us and exec\n+   *\n+   * Although using -(pagesz) as mmap hint works on newer kernel as you would\n+   * think, older variants affected by this work-around don't (search forward only).\n+   *\n+   * On the affected distributions, we understand the memory layout to be:\n+   *\n+   *   TASK_LIMIT= 3G, main stack base close to TASK_LIMT.\n+   *\n+   * A few pages south main stack will do it.\n+   *\n+   * If we are embedded in an app other than launcher (initial != main stack),\n+   * we don't have much control or understanding of the address space, just let it slide.\n+   *\/\n+  char* hint = (char*)(os::Linux::initial_thread_stack_bottom() -\n+                       (StackOverflow::stack_guard_zone_size() + page_size));\n+  char* codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+\n+  if (codebuf == NULL) {\n+    \/\/ JDK-8197429: There may be a stack gap of one megabyte between\n+    \/\/ the limit of the stack and the nearest memory region: this is a\n+    \/\/ Linux kernel workaround for CVE-2017-1000364.  If we failed to\n+    \/\/ map our codebuf, try again at an address one megabyte lower.\n+    hint -= 1 * M;\n+    codebuf = os::attempt_reserve_memory_at(hint, page_size);\n+  }\n+\n+  if ((codebuf == NULL) || (!os::commit_memory(codebuf, page_size, true))) {\n+    return; \/\/ No matter, we tried, best effort.\n+  }\n+\n+  MemTracker::record_virtual_memory_type((address)codebuf, mtInternal);\n+\n+  log_info(os)(\"[CS limit NX emulation work-around, exec code at: %p]\", codebuf);\n+\n+  \/\/ Some code to exec: the 'ret' instruction\n+  codebuf[0] = 0xC3;\n+\n+  \/\/ Call the code in the codebuf\n+  __asm__ volatile(\"call *%0\" : : \"r\"(codebuf));\n+\n+  \/\/ keep the page mapped so CS limit isn't reduced.\n+}\n+#endif \/\/ defined(IA32) && !defined(ZERO)\n+\n@@ -4492,1 +4575,1 @@\n-  Linux::workaround_expand_exec_shield_cs_limit();\n+  workaround_expand_exec_shield_cs_limit();\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":84,"deletions":1,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -159,0 +159,1 @@\n+  static void expand_stack_to(address bottom);\n@@ -200,1 +201,0 @@\n-  static void expand_stack_to(address bottom);\n@@ -430,17 +430,0 @@\n-\n-#if defined(IA32) && !defined(ZERO)\n-  \/*\n-   * Work-around for broken NX emulation using CS limit, Red Hat patch \"Exec-Shield\"\n-   * (IA32 only).\n-   *\n-   * Map and execute at a high VA to prevent CS lazy updates race with SMP MM\n-   * invalidation.Further code generation by the JVM will no longer cause CS limit\n-   * updates.\n-   *\n-   * Affects IA32: RHEL 5 & 6, Ubuntu 10.04 (LTS), 10.10, 11.04, 11.10, 12.04.\n-   * @see JDK-8023956\n-   *\/\n-  static void workaround_expand_exec_shield_cs_limit();\n-#endif\n-\n-  void* resolve_function_descriptor(void* p);\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -518,2 +518,1 @@\n-\/\/ HAVE_FUNCTION_DESCRIPTORS\n-void* os::Aix::resolve_function_descriptor(void* p) {\n+void* os::resolve_function_descriptor(void* p) {\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-#define PLATFORM_PRINT_NATIVE_STACK 1\n+#define HAVE_PLATFORM_PRINT_NATIVE_STACK 1\n@@ -37,4 +37,0 @@\n-#define HAVE_FUNCTION_DESCRIPTORS 1\n-inline void* os::resolve_function_descriptor(void* p) {\n-  return os::Aix::resolve_function_descriptor(p);\n-}\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.inline.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -520,2 +520,2 @@\n-#ifdef HAVE_FUNCTION_DESCRIPTORS\n-void* os::Linux::resolve_function_descriptor(void* p) {\n+#if !defined(ABI_ELFv2)\n+void* os::resolve_function_descriptor(void* p) {\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,10 +29,0 @@\n-#include \"os_linux.hpp\"\n-\n-#if !defined(ABI_ELFv2)\n-  \/\/ ppc (not ppcle) has function descriptors\n-#define HAVE_FUNCTION_DESCRIPTORS 1\n-inline void* os::resolve_function_descriptor(void* p) {\n-  return os::Linux::resolve_function_descriptor(p);\n-}\n-#endif\n-\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.inline.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -656,77 +656,0 @@\n-\n-#if defined(IA32) && !defined(ZERO)\n-\/*\n- * IA32 only: execute code at a high address in case buggy NX emulation is present. I.e. avoid CS limit\n- * updates (JDK-8023956).\n- *\/\n-void os::Linux::workaround_expand_exec_shield_cs_limit() {\n-  assert(Linux::initial_thread_stack_bottom() != NULL, \"sanity\");\n-  size_t page_size = os::vm_page_size();\n-\n-  \/*\n-   * JDK-8197429\n-   *\n-   * Expand the stack mapping to the end of the initial stack before\n-   * attempting to install the codebuf.  This is needed because newer\n-   * Linux kernels impose a distance of a megabyte between stack\n-   * memory and other memory regions.  If we try to install the\n-   * codebuf before expanding the stack the installation will appear\n-   * to succeed but we'll get a segfault later if we expand the stack\n-   * in Java code.\n-   *\n-   *\/\n-  if (os::is_primordial_thread()) {\n-    address limit = Linux::initial_thread_stack_bottom();\n-    if (! DisablePrimordialThreadGuardPages) {\n-      limit += StackOverflow::stack_red_zone_size() +\n-               StackOverflow::stack_yellow_zone_size();\n-    }\n-    os::Linux::expand_stack_to(limit);\n-  }\n-\n-  \/*\n-   * Take the highest VA the OS will give us and exec\n-   *\n-   * Although using -(pagesz) as mmap hint works on newer kernel as you would\n-   * think, older variants affected by this work-around don't (search forward only).\n-   *\n-   * On the affected distributions, we understand the memory layout to be:\n-   *\n-   *   TASK_LIMIT= 3G, main stack base close to TASK_LIMT.\n-   *\n-   * A few pages south main stack will do it.\n-   *\n-   * If we are embedded in an app other than launcher (initial != main stack),\n-   * we don't have much control or understanding of the address space, just let it slide.\n-   *\/\n-  char* hint = (char*)(Linux::initial_thread_stack_bottom() -\n-                       (StackOverflow::stack_guard_zone_size() + page_size));\n-  char* codebuf = os::attempt_reserve_memory_at(hint, page_size);\n-\n-  if (codebuf == NULL) {\n-    \/\/ JDK-8197429: There may be a stack gap of one megabyte between\n-    \/\/ the limit of the stack and the nearest memory region: this is a\n-    \/\/ Linux kernel workaround for CVE-2017-1000364.  If we failed to\n-    \/\/ map our codebuf, try again at an address one megabyte lower.\n-    hint -= 1 * M;\n-    codebuf = os::attempt_reserve_memory_at(hint, page_size);\n-  }\n-\n-  if ((codebuf == NULL) || (!os::commit_memory(codebuf, page_size, true))) {\n-    return; \/\/ No matter, we tried, best effort.\n-  }\n-\n-  MemTracker::record_virtual_memory_type((address)codebuf, mtInternal);\n-\n-  log_info(os)(\"[CS limit NX emulation work-around, exec code at: %p]\", codebuf);\n-\n-  \/\/ Some code to exec: the 'ret' instruction\n-  codebuf[0] = 0xC3;\n-\n-  \/\/ Call the code in the codebuf\n-  __asm__ volatile(\"call *%0\" : : \"r\"(codebuf));\n-\n-  \/\/ keep the page mapped so CS limit isn't reduced.\n-}\n-#endif \/\/ defined(IA32) && !defined(ZERO)\n-\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-#ifdef PLATFORM_PRINT_NATIVE_STACK\n+#ifdef HAVE_PLATFORM_PRINT_NATIVE_STACK\n@@ -298,1 +298,1 @@\n-#endif \/\/ PLATFORM_PRINT_NATIVE_STACK\n+#endif \/\/ HAVE_PLATFORM_PRINT_NATIVE_STACK\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-#define PLATFORM_PRINT_NATIVE_STACK 1\n+#define HAVE_PLATFORM_PRINT_NATIVE_STACK 1\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -91,3 +91,3 @@\n-\/\/   implemented in one of the two .inline.hpp files, depending on whether\n-\/\/   the feature is generic to the OS, or specific to a particular CPU\n-\/\/   architecture. These two files are automatically included by\n+\/\/   implemented in one of the two .inline.hpp files, depending on\n+\/\/   whether the feature is specific to a particular CPU architecture\n+\/\/   for this OS. These two files are automatically included by\n@@ -700,2 +700,7 @@\n-  \/\/ Used only on PPC.\n-  inline static void* resolve_function_descriptor(void* p);\n+  \/\/ Used only on PPC for AIX, or LINUX (ppc but not ppcle). \n+  static void* resolve_function_descriptor(void* p)\n+#if defined(PPC) && (defined(AIX) || (defined(LINUX) && !defined(ABI_ELFv2)))\n+    ;\n+#else\n+  { return NULL; }\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-#ifndef PLATFORM_PRINT_NATIVE_STACK\n+#ifndef HAVE_PLATFORM_PRINT_NATIVE_STACK\n@@ -57,6 +57,0 @@\n-#ifndef HAVE_FUNCTION_DESCRIPTORS\n-inline void* os::resolve_function_descriptor(void* p) {\n-  return NULL;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/os.inline.hpp","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"}]}