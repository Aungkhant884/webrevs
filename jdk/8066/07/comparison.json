{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -251,0 +253,143 @@\n+    \/**\n+     * Returns the file name extension of this path as an\n+     * {@code Optional<String>}.  The extension is defined to be the portion\n+     * of the {@code String} representation of the file name after the last\n+     * dot ('.').  If the first character in the file name string is a dot\n+     * it is ignored.  If the extension cannot be determined, then an\n+     * {@link Optional#empty empty} {@code Optional} is returned. This will\n+     * occur if the path has zero elements ({@link #getFileName()} returns\n+     * {@code null}), or the file name string does not contain a dot, or only\n+     * the first character is a dot. If the last character is a dot, the\n+     * extension is the empty {@code String} {@code \"\"}.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * <pre>{@code\n+     * if (lastDot <= 0)\n+     *     return Optional.empty();\n+     * return lastDot == name.length() - 1 ?\n+     *     Optional.of(\"\") :\n+     *     Optional.of(name.substring(lastDot + 1));\n+     * }<\/pre>\n+     *\n+     * @return  an {@code Optional} which either contains the file name\n+     *          extension of this path, or is {@link Optional#empty empty}\n+     *          if the extension is not found\n+     *\n+     * @since 19\n+     *\/\n+    default Optional<String> getExtension() {\n+        Path fileName = getFileName();\n+        if (fileName == null) {\n+            return Optional.empty();\n+        }\n+\n+        String fileNameString = fileName.toString();\n+        int length = fileNameString.length();\n+\n+        \/\/ Indeterminate if fileNameString is too short\n+        if (length > 2) {\n+            int lastDotIndex = fileNameString.lastIndexOf('.');\n+            \/\/ Indeterminate if no dot or only at first index\n+            if (lastDotIndex > 0) {\n+                return lastDotIndex == length - 1 ?\n+                    Optional.of(\"\") : \/\/ empty string if last dot at last index\n+                    Optional.of(fileNameString.substring(lastDotIndex + 1));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Returns whether the string representation of this path has an\n+     * extension among the one or more extensions given as parameters.\n+     * The extension of this path will be compared against the given\n+     * parameters in the order in which they are supplied.\n+     *\n+     * @param   ext\n+     *          the first extension for which to check\n+     *\n+     * @param   extensions\n+     *          zero or more subsequent extensions for which to check\n+     *\n+     * @return  an {@code Optional} which either contains the found extension\n+     *          or is {@link Optional#empty empty} if this path either does not\n+     *          have an extension or its extension is not among those given\n+     *\n+     * @since 19\n+     *\/\n+    default Optional<String> hasExtension(String ext, String... extensions) {\n+        Objects.requireNonNull(ext);\n+\n+        Optional<String> extension = getExtension();\n+        String thisExtension = null;\n+        if (extension.isEmpty() ||\n+            (thisExtension = extension.get()).equals(ext))\n+            return extension;\n+\n+        if (extensions != null) {\n+            for (String e : extensions) {\n+                Objects.requireNonNull(e);\n+                if (e.equals(thisExtension))\n+                    return Optional.of(e);\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Returns a {@code Path} which is equal to this path aside from its\n+     * extension which is replaced by the provided extension. If the provided\n+     * extension is {@link String#isEmpty() empty}, then the current extension\n+     * and the dot ('.') preceding it are removed. If this path does not have\n+     * an extension then the provided extension is appended.\n+     *\n+     * @implNote\n+     * This default implementation works with the string representation of this\n+     * path. Paths which have a native representation should override this\n+     * implementation in order to preserve that representation.\n+     *\n+     * @param  extension\n+     *         the extension to replace this path's current extension;\n+     *         if non-empty, may not contain a leading or trailing dot\n+     *         but is not otherwise checked for validity\n+     *\n+     * @return a path equal to this path but with extension replaced by\n+     *         that provided\n+     *\n+     * @throws IllegalArgumentException if the provided extension contains a\n+     *         leading or trailing dot ('.')\n+     *\n+     * @since 19\n+     *\/\n+    default Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.charAt(0) == '.' ||\n+                extension.charAt(extension.length() - 1) == '.')\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n+\n+        String thisPath = toString();\n+        String thisExtension = getExtension().orElse(null);\n+        FileSystem fs = this.getFileSystem();\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null)\n+            return extension.isEmpty() ?\n+                this : fs.getPath(thisPath + \".\" + extension);\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        int dotIndex = thisPath.lastIndexOf('.');\n+        assert dotIndex != -1;\n+        if (extension.isEmpty())\n+            return fs.getPath(thisPath.substring(0, dotIndex));\n+\n+        \/\/ replace the path's extension with that provided\n+        return fs.getPath(thisPath.substring(0, dotIndex + 1) + extension);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":146,"deletions":1,"binary":false,"changes":147,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,9 @@\n-import java.nio.file.*;\n-import java.nio.charset.*;\n-import java.io.*;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.charset.CharacterCodingException;\n+import java.io.IOException;\n@@ -32,1 +38,1 @@\n-import java.util.*;\n+import java.util.Objects;\n@@ -274,0 +280,50 @@\n+    @Override\n+    public Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.charAt(0) == '.' ||\n+                extension.charAt(extension.length() - 1) == '.')\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n+\n+        String thisExtension = getExtension().orElse(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null) {\n+            if (extension.isEmpty()) {\n+                return this;\n+            } else {\n+                byte[] ext = encode(this.fs, extension);\n+                byte[] result = new byte[path.length + 1 + ext.length];\n+                System.arraycopy(path, 0, result, 0, path.length);\n+                result[path.length] = '.';\n+                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n+                return new UnixPath(this.fs, result);\n+            }\n+        }\n+\n+        \/\/ find the index of the last dot in the path\n+        int dotIndex = path.length - 1;\n+        while (path[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        if (extension.isEmpty()) {\n+            byte[] result = new byte[dotIndex];\n+            System.arraycopy(path, 0, result, 0, dotIndex);\n+            return new UnixPath(this.fs, result);\n+        }\n+\n+        \/\/ replace the path's extension with that provided\n+        byte[] ext = encode(this.fs, extension);\n+        byte[] result = new byte[dotIndex + 1 + ext.length];\n+        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n+        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n+        return new UnixPath(this.fs, result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":61,"deletions":5,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,50 @@\n+\n+    @Override\n+    public Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.charAt(0) == '.' ||\n+                extension.charAt(extension.length() - 1) == '.')\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n+\n+        String thisExtension = getExtension().orElse(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null) {\n+            if (extension.isEmpty()) {\n+                return this;\n+            } else {\n+                byte[] ext = normalize(extension);\n+                byte[] result = new byte[path.length + 1 + ext.length];\n+                System.arraycopy(path, 0, result, 0, path.length);\n+                result[path.length] = '.';\n+                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n+                return new ZipPath(this.zfs, result);\n+            }\n+        }\n+\n+        \/\/ find the index of the last dot in the path\n+        int dotIndex = path.length - 1;\n+        while (path[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        if (extension.isEmpty()) {\n+            byte[] result = new byte[dotIndex];\n+            System.arraycopy(path, 0, result, 0, dotIndex);\n+            return new ZipPath(this.zfs, result);\n+        }\n+\n+        \/\/ replace the path's extension with that provided\n+        byte[] ext = normalize(extension);\n+        byte[] result = new byte[dotIndex + 1 + ext.length];\n+        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n+        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n+        return new ZipPath(this.zfs, result);\n+    }\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8057113\n+ * @summary Verify extension methods\n+ * @run testng Extensions\n+ *\/\n+public class Extensions {\n+    private static final Optional EMPTY = Optional.empty();\n+    private static final Optional EMPTY_STRING = of(\"\");\n+\n+    private static Optional<String> of(String s) {\n+        return Optional.of(s);\n+    }\n+\n+    @Test\n+    public static void exceptions() {\n+        Path path = Path.of(\"file.ext\");\n+\n+        Assert.assertThrows(NullPointerException.class,\n+                            () -> {path.hasExtension(null);});\n+\n+        Assert.assertThrows(NullPointerException.class,\n+                            () -> {path.replaceExtension(null);});\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                            () -> {path.replaceExtension(\".leading\");});\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                            () -> {path.replaceExtension(\"trailing.\");});\n+    }\n+\n+    \/**\n+     * Returns path name string and expected extension pairs.\n+     *\n+     * @return {@code {{\"pathname\", \"extension\"},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] getProvider() {\n+        Object[][] pairs = new Object[][] {\n+            new Object[] {\".\",              EMPTY},\n+            new Object[] {\"..\",             EMPTY},\n+            new Object[] {\".a.b\",           of(\"b\")},\n+            new Object[] {\"......\",         EMPTY_STRING},\n+            new Object[] {\".....a\",         of(\"a\")},\n+            new Object[] {\"...a.b\",         of(\"b\")},\n+            new Object[] {\"..foo\",          of(\"foo\")},\n+            new Object[] {\"test.rb\",        of(\"rb\")},\n+            new Object[] {\"a\/b\/d\/test.rb\" , of(\"rb\")},\n+            new Object[] {\".a\/b\/d\/test.rb\", of(\"rb\")},\n+            new Object[] {\"foo.\",           EMPTY_STRING},\n+            new Object[] {\"test\",           EMPTY},\n+            new Object[] {\".profile\",       EMPTY},\n+            new Object[] {\".profile.sh\",    of(\"sh\")},\n+            new Object[] {\"..foo\",          of(\"foo\")},\n+            new Object[] {\".....foo\",       of(\"foo\")},\n+            new Object[] {\".vimrc\",         EMPTY},\n+            new Object[] {\"test.\",          EMPTY_STRING},\n+            new Object[] {\"test..\",         EMPTY_STRING},\n+            new Object[] {\"test...\",        EMPTY_STRING},\n+            new Object[] {\"foo.tar.gz\",     of(\"gz\")},\n+            new Object[] {\"foo.bar.\",       EMPTY_STRING},\n+            new Object[] {\"image.jpg\",      of(\"jpg\")},\n+            new Object[] {\"music.mp3\",      of(\"mp3\")},\n+            new Object[] {\"video.mp4\",      of(\"mp4\")},\n+            new Object[] {\"document.txt\",   of(\"txt\")},\n+        };\n+        return pairs;\n+    }\n+\n+    @Test(dataProvider = \"getProvider\")\n+    public static void get(String pathname, Optional<String> extension) {\n+        Assert.assertEquals(Path.of(pathname).getExtension(), extension);\n+    }\n+\n+    \/**\n+     * Returns path name string, expected result, and extensions to search for.\n+     *\n+     * @return {@code {{\"pathname\", of(\"expected\"), \"ext0\", \"ext1\", ...},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] hasProvider() {\n+        Object[][] v = new Object[][] {\n+            new Object[] {\"image.jpg\", of(\"jpg\"), \"JPEG\", \"jpeg\", \"JPG\", \"jpg\"},\n+            new Object[] {\"image.jpg\", EMPTY, \"jpG\", \"jPG\", \"JPG\"},\n+            new Object[] {\"image.jpg\", EMPTY, \"gif\", \"png\", \"tiff\"},\n+            new Object[] {\"nullext\", EMPTY, \"gif\", \"jpg\", \"png\", \"tiff\"},\n+            new Object[] {\"emptyext.\", EMPTY_STRING, \"gif\", \"jpg\", \"png\", \"\"},\n+            new Object[] {\"doc.txt\", EMPTY, \"doc\"},\n+        };\n+        return v;\n+    }\n+\n+    @Test(dataProvider = \"hasProvider\")\n+    public static void has(String pathname, Optional<String> expected,\n+        String[] extensions) {\n+        String ext = extensions[0];\n+        String[] exts = extensions.length > 1 ?\n+            Arrays.copyOfRange(extensions, 1, extensions.length) : null;\n+        Optional<String> actual = Path.of(pathname).hasExtension(ext, exts);\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    \/**\n+     * Returns path name string, new extension, and expected result.\n+     *\n+     * @return {@code {{\"pathname\", \"extension\", \"expected\"},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] replaceProvider() {\n+        Object[][] v = new Object[][] {\n+            new Object[] {\"image.png\", \"png\", Path.of(\"image.png\")},\n+            new Object[] {\"image.tiff\", \"jpg\", Path.of(\"image.jpg\")},\n+            new Object[] {\"nullext\", \"dat\", Path.of(\"nullext.dat\")},\n+            new Object[] {\"emptyext.\", \"dat\", Path.of(\"emptyext.dat\")},\n+            new Object[] {\"foo.tar\", \"tar.gz\", Path.of(\"foo.tar.gz\")},\n+            new Object[] {\"foo.\", \"bar\", Path.of(\"foo.bar\")},\n+        };\n+        return v;\n+    }\n+\n+    @Test(dataProvider = \"replaceProvider\")\n+    public static void replace(String pathname, String extension,\n+        Path expected) {\n+        Path actual = Path.of(pathname).replaceExtension(extension);\n+        Assert.assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}