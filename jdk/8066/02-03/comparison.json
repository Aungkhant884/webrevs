{"files":[{"patch":"@@ -353,3 +353,2 @@\n-     *         leading and trailing space is ignored; may contain at most\n-     *         one dot ('.') which if present must be the first character\n-     *         that is not a space\n+     *         if non-empty, may not contain a leading or trailing dot \n+     *         but is not otherwise checked for validity\n@@ -360,2 +359,2 @@\n-     * @throws IllegalArgumentException if the provided extension contains a dot\n-     *         ('.') which is not the first non-space character of the parameter\n+     * @throws IllegalArgumentException if the provided extension contains a\n+     *         leading or trailing dot ('.')\n@@ -368,9 +367,6 @@\n-        \/\/ trim the extension and verify that at most a leading dot is present\n-        extension = extension.trim();\n-        int dotIndex = extension.lastIndexOf('.');\n-        if (dotIndex > 0)\n-            throw new IllegalArgumentException();\n-\n-        \/\/ dispense with the leading dot if present\n-        if (dotIndex == 0)\n-            extension = extension.substring(1);\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.indexOf('.') == 0 ||\n+                extension.lastIndexOf('.') == extension.length() - 1)\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n@@ -378,1 +374,1 @@\n-        String path = toString();\n+        String thisPath = toString();\n@@ -380,0 +376,1 @@\n+        FileSystem fs = this.getFileSystem();\n@@ -384,1 +381,1 @@\n-                this : Path.of(path + \".\" + extension);\n+                this : fs.getPath(thisPath + \".\" + extension);\n@@ -387,1 +384,1 @@\n-        dotIndex = path.lastIndexOf('.');\n+        int dotIndex = thisPath.lastIndexOf('.');\n@@ -390,1 +387,1 @@\n-            return Path.of(path.substring(0, dotIndex));\n+            return fs.getPath(thisPath.substring(0, dotIndex));\n@@ -393,3 +390,1 @@\n-        StringBuilder sb = new StringBuilder(path.substring(0, dotIndex + 1));\n-        sb.append(extension);\n-        return Path.of(sb.toString());\n+        return fs.getPath(thisPath.substring(0, dotIndex + 1) + extension);\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":16,"deletions":21,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -280,10 +280,0 @@\n-    private static int getLastDotIndex(byte[] b) {\n-        int dotIndex = b.length - 1;\n-        while (b[dotIndex] != '.') {\n-            dotIndex--;\n-            if (dotIndex < 0)\n-                throw new IndexOutOfBoundsException();\n-        }\n-        return dotIndex;\n-    }\n-\n@@ -294,9 +284,6 @@\n-        \/\/ trim the extension and verify that at most a leading dot is present\n-        extension = extension.trim();\n-        int dotIndex = extension.lastIndexOf('.');\n-        if (dotIndex > 0)\n-            throw new IllegalArgumentException();\n-\n-        \/\/ dispense with the leading dot if present\n-        if (dotIndex == 0)\n-            extension = extension.substring(1);\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.indexOf('.') == 0 ||\n+                extension.lastIndexOf('.') == extension.length() - 1)\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n@@ -320,0 +307,8 @@\n+        \/\/ find the index of the last dot in the path\n+        int dotIndex = path.length - 1;\n+        while (path[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+\n@@ -321,1 +316,0 @@\n-        dotIndex = getLastDotIndex(path);\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -111,9 +111,6 @@\n-        \/\/ trim the extension and verify that at most a leading dot is present\n-        extension = extension.trim();\n-        int dotIndex = extension.lastIndexOf('.');\n-        if (dotIndex > 0)\n-            throw new IllegalArgumentException();\n-\n-        \/\/ dispense with the leading dot if present\n-        if (dotIndex == 0)\n-            extension = extension.substring(1);\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.indexOf('.') == 0 ||\n+                extension.lastIndexOf('.') == extension.length() - 1)\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n@@ -128,1 +125,1 @@\n-                byte[] ext = encode(this.fs, extension);\n+                byte[] ext = normalize(extension);\n@@ -133,1 +130,1 @@\n-                return new UnixPath(this.fs, result);\n+                return new ZipPath(this.zfs, result);\n@@ -137,0 +134,8 @@\n+        \/\/ find the index of the last dot in the path\n+        int dotIndex = path.length - 1;\n+        while (path[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+\n@@ -138,1 +143,0 @@\n-        dotIndex = getLastDotIndex(path);\n@@ -142,1 +146,1 @@\n-            return new UnixPath(this.fs, result);\n+            return new ZipPath(this.zfs, result);\n@@ -146,1 +150,1 @@\n-        byte[] ext = encode(this.fs, extension);\n+        byte[] ext = normalize(extension);\n@@ -150,1 +154,1 @@\n-        return new UnixPath(this.fs, result);\n+        return new ZipPath(this.zfs, result);\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"}]}