{"files":[{"patch":"@@ -54,1 +54,1 @@\n- * elements.\n+ * elements, and {@link #getExtension() getExtension} to obtain its extension.\n@@ -98,0 +98,7 @@\n+ * @apiNote\n+ * On some file systems a {@code Path} may have an internal representation\n+ * which cannot be converted to a {@code String} without losing information.\n+ * Otherwise stated, the internal representation might not be recoverable\n+ * from the derived path string. This applies to the {@code Path} as a whole\n+ * as well as to its components.\n+ *\n@@ -255,1 +262,1 @@\n-     * {@code Optional<String>}.  The extension is defined to be the portion\n+     * {@code Optional<String>}. The extension is defined to be the portion\n@@ -257,7 +264,6 @@\n-     * dot ('.').  If the first character in the file name string is a dot\n-     * it is ignored.  If the extension cannot be determined, then an\n-     * {@link Optional#empty empty} {@code Optional} is returned. This will\n-     * occur if the path has zero elements ({@link #getFileName()} returns\n-     * {@code null}), or the file name string does not contain a dot, or only\n-     * the first character is a dot. If the last character is a dot, the\n-     * extension is the empty {@code String} {@code \"\"}.\n+     * dot ('.'). All leading dots are ignored. If the extension is missing,\n+     * then an {@link Optional#empty empty} {@code Optional} is returned. This\n+     * will occur if the path has zero elements ({@link #getFileName()} returns\n+     * {@code null}), the file name string does not contain a dot, or only the\n+     * first character is a dot. If the last character is a dot, the extension\n+     * is the empty string.\n@@ -276,2 +282,2 @@\n-     *          extension of this path, or is {@link Optional#empty empty}\n-     *          if the extension is not found\n+     *          extension of this path, which might be the empty string,\n+     *          or equals {@link Optional#empty} if no extension is found\n@@ -304,92 +310,0 @@\n-    \/**\n-     * Returns whether the string representation of this path has an\n-     * extension among the one or more extensions given as parameters.\n-     * The extension of this path will be compared against the given\n-     * parameters in the order in which they are supplied.\n-     *\n-     * @param   ext\n-     *          the first extension for which to check\n-     *\n-     * @param   extensions\n-     *          zero or more subsequent extensions for which to check\n-     *\n-     * @return  an {@code Optional} which either contains the found extension\n-     *          or is {@link Optional#empty empty} if this path either does not\n-     *          have an extension or its extension is not among those given\n-     *\n-     * @since 20\n-     *\/\n-    default Optional<String> hasExtension(String ext, String... extensions) {\n-        Objects.requireNonNull(ext);\n-\n-        Optional<String> extension = getExtension();\n-        String thisExtension = null;\n-        if (extension.isEmpty() ||\n-            (thisExtension = extension.get()).equals(ext))\n-            return extension;\n-\n-        if (extensions != null) {\n-            for (String e : extensions) {\n-                Objects.requireNonNull(e);\n-                if (e.equals(thisExtension))\n-                    return Optional.of(e);\n-            }\n-        }\n-\n-        return Optional.empty();\n-    }\n-\n-    \/**\n-     * Returns a {@code Path} which is equal to this path aside from its\n-     * extension which is replaced by the provided extension. If the provided\n-     * extension is {@link String#isEmpty() empty}, then the current extension\n-     * and the dot ('.') preceding it are removed. If this path does not have\n-     * an extension then the provided extension is appended.\n-     *\n-     * @implNote\n-     * This default implementation works with the string representation of this\n-     * path. Paths which have a native representation should override this\n-     * implementation in order to preserve that representation.\n-     *\n-     * @param  extension\n-     *         the extension to replace this path's current extension;\n-     *         if non-empty, may not contain a leading or trailing dot\n-     *         but is not otherwise checked for validity\n-     *\n-     * @return a path equal to this path but with extension replaced by\n-     *         that provided\n-     *\n-     * @throws IllegalArgumentException if the provided extension contains a\n-     *         leading or trailing dot ('.')\n-     *\n-     * @since 20\n-     *\/\n-    default Path replaceExtension(String extension) {\n-        Objects.requireNonNull(extension, \"extension\");\n-\n-        \/\/ verify the extension contains neither a leading nor trailing dot\n-        if (!extension.isEmpty()) {\n-            if (extension.charAt(0) == '.' ||\n-                extension.charAt(extension.length() - 1) == '.')\n-                throw new IllegalArgumentException(\"leading or trailing dot\");\n-        }\n-\n-        String thisPath = toString();\n-        String thisExtension = getExtension().orElse(null);\n-        FileSystem fs = this.getFileSystem();\n-\n-        \/\/ if this path has no extension, append that provided\n-        if (thisExtension == null)\n-            return extension.isEmpty() ?\n-                this : fs.getPath(thisPath + \".\" + extension);\n-\n-        \/\/ if the provided extension is empty, strip this path's extension\n-        int dotIndex = thisPath.lastIndexOf('.');\n-        assert dotIndex != -1;\n-        if (extension.isEmpty())\n-            return fs.getPath(thisPath.substring(0, dotIndex));\n-\n-        \/\/ replace the path's extension with that provided\n-        return fs.getPath(thisPath.substring(0, dotIndex + 1) + extension);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":17,"deletions":103,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -280,50 +280,0 @@\n-    @Override\n-    public Path replaceExtension(String extension) {\n-        Objects.requireNonNull(extension, \"extension\");\n-\n-        \/\/ verify the extension contains neither a leading nor trailing dot\n-        if (!extension.isEmpty()) {\n-            if (extension.charAt(0) == '.' ||\n-                extension.charAt(extension.length() - 1) == '.')\n-                throw new IllegalArgumentException(\"leading or trailing dot\");\n-        }\n-\n-        String thisExtension = getExtension().orElse(null);\n-\n-        \/\/ if this path has no extension, append that provided\n-        if (thisExtension == null) {\n-            if (extension.isEmpty()) {\n-                return this;\n-            } else {\n-                byte[] ext = encode(this.fs, extension);\n-                byte[] result = new byte[path.length + 1 + ext.length];\n-                System.arraycopy(path, 0, result, 0, path.length);\n-                result[path.length] = '.';\n-                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n-                return new UnixPath(this.fs, result);\n-            }\n-        }\n-\n-        \/\/ find the index of the last dot in the path\n-        int dotIndex = path.length - 1;\n-        while (path[dotIndex] != '.') {\n-            dotIndex--;\n-            if (dotIndex < 0)\n-                throw new IndexOutOfBoundsException();\n-        }\n-\n-        \/\/ if the provided extension is empty, strip this path's extension\n-        if (extension.isEmpty()) {\n-            byte[] result = new byte[dotIndex];\n-            System.arraycopy(path, 0, result, 0, dotIndex);\n-            return new UnixPath(this.fs, result);\n-        }\n-\n-        \/\/ replace the path's extension with that provided\n-        byte[] ext = encode(this.fs, extension);\n-        byte[] result = new byte[dotIndex + 1 + ext.length];\n-        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n-        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n-        return new UnixPath(this.fs, result);\n-    }\n-\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -106,50 +106,0 @@\n-\n-    @Override\n-    public Path replaceExtension(String extension) {\n-        Objects.requireNonNull(extension, \"extension\");\n-\n-        \/\/ verify the extension contains neither a leading nor trailing dot\n-        if (!extension.isEmpty()) {\n-            if (extension.charAt(0) == '.' ||\n-                extension.charAt(extension.length() - 1) == '.')\n-                throw new IllegalArgumentException(\"leading or trailing dot\");\n-        }\n-\n-        String thisExtension = getExtension().orElse(null);\n-\n-        \/\/ if this path has no extension, append that provided\n-        if (thisExtension == null) {\n-            if (extension.isEmpty()) {\n-                return this;\n-            } else {\n-                byte[] ext = normalize(extension);\n-                byte[] result = new byte[path.length + 1 + ext.length];\n-                System.arraycopy(path, 0, result, 0, path.length);\n-                result[path.length] = '.';\n-                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n-                return new ZipPath(this.zfs, result);\n-            }\n-        }\n-\n-        \/\/ find the index of the last dot in the path\n-        int dotIndex = path.length - 1;\n-        while (path[dotIndex] != '.') {\n-            dotIndex--;\n-            if (dotIndex < 0)\n-                throw new IndexOutOfBoundsException();\n-        }\n-\n-        \/\/ if the provided extension is empty, strip this path's extension\n-        if (extension.isEmpty()) {\n-            byte[] result = new byte[dotIndex];\n-            System.arraycopy(path, 0, result, 0, dotIndex);\n-            return new ZipPath(this.zfs, result);\n-        }\n-\n-        \/\/ replace the path's extension with that provided\n-        byte[] ext = normalize(extension);\n-        byte[] result = new byte[dotIndex + 1 + ext.length];\n-        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n-        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n-        return new ZipPath(this.zfs, result);\n-    }\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -103,53 +103,0 @@\n-\n-    \/**\n-     * Returns path name string, expected result, and extensions to search for.\n-     *\n-     * @return {@code {{\"pathname\", of(\"expected\"), \"ext0\", \"ext1\", ...},...}}\n-     *\/\n-    @DataProvider\n-    static Object[][] hasProvider() {\n-        Object[][] v = {\n-            {\"image.jpg\", of(\"jpg\"), \"JPEG\", \"jpeg\", \"JPG\", \"jpg\"},\n-            {\"image.jpg\", EMPTY, \"jpG\", \"jPG\", \"JPG\"},\n-            {\"image.jpg\", EMPTY, \"gif\", \"png\", \"tiff\"},\n-            {\"nullext\", EMPTY, \"gif\", \"jpg\", \"png\", \"tiff\"},\n-            {\"emptyext.\", EMPTY_STRING, \"gif\", \"jpg\", \"png\", \"\"},\n-            {\"doc.txt\", EMPTY, \"doc\"},\n-        };\n-        return v;\n-    }\n-\n-    @Test(dataProvider = \"hasProvider\")\n-    public static void has(String pathname, Optional<String> expected,\n-        String[] extensions) {\n-        String ext = extensions[0];\n-        String[] exts = extensions.length > 1 ?\n-            Arrays.copyOfRange(extensions, 1, extensions.length) : null;\n-        Optional<String> actual = Path.of(pathname).hasExtension(ext, exts);\n-        Assert.assertEquals(actual, expected);\n-    }\n-\n-    \/**\n-     * Returns path name string, new extension, and expected result.\n-     *\n-     * @return {@code {{\"pathname\", \"extension\", \"expected\"},...}}\n-     *\/\n-    @DataProvider\n-    static Object[][] replaceProvider() {\n-        Object[][] v = {\n-            {\"image.png\", \"png\", Path.of(\"image.png\")},\n-            {\"image.tiff\", \"jpg\", Path.of(\"image.jpg\")},\n-            {\"nullext\", \"dat\", Path.of(\"nullext.dat\")},\n-            {\"emptyext.\", \"dat\", Path.of(\"emptyext.dat\")},\n-            {\"foo.tar\", \"tar.gz\", Path.of(\"foo.tar.gz\")},\n-            {\"foo.\", \"bar\", Path.of(\"foo.bar\")},\n-        };\n-        return v;\n-    }\n-\n-    @Test(dataProvider = \"replaceProvider\")\n-    public static void replace(String pathname, String extension,\n-        Path expected) {\n-        Path actual = Path.of(pathname).replaceExtension(extension);\n-        Assert.assertEquals(actual, expected);\n-    }\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"modified"}]}