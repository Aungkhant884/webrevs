{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -251,0 +253,140 @@\n+    \/**\n+     * Returns the file name extension of this path as a {@code String},\n+     * or a default value.  The extension is defined to be the portion of\n+     * the {@code String} representation of the file name after the last\n+     * dot ('.').  If the first character in the file name string is a dot\n+     * it is ignored.  If the extension cannot be determined, then the\n+     * parameter {@code defaultExtension} is returned.  This will occur if\n+     * the path has zero elements ({@link #getFileName()} returns\n+     * {@code null}), or the file name string does not contain a dot, only\n+     * the first character is a dot, or the last character is a dot.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * <pre>{@code\n+     *     String name = getFileName().toString();\n+     *     int lastDot = name.lastIndexOf('.');\n+     *     lastDot > 0 && lastDot < name.length() - 1 ?\n+     *         name.substring(lastDot + 1) : defaultExtension;\n+     * }<\/pre>\n+     *\n+     * @param   defaultExtension\n+     *          the value to return if the extension is indeterminate;\n+     *          may be {@code null}\n+     *\n+     * @return  the file name extension of this path, or\n+     *          {@code defaultExtension} if the extension is indeterminate\n+     *\n+     * @since 19\n+     *\/\n+    default String getExtension(String defaultExtension) {\n+        Path fileName = getFileName();\n+        if (fileName == null) {\n+            return defaultExtension;\n+        }\n+\n+        String fileNameString = fileName.toString();\n+        int length = fileNameString.length();\n+\n+        \/\/ Indeterminate if fileNameString is too short\n+        if (length > 2) {\n+            int lastDotIndex = fileNameString.lastIndexOf('.');\n+            \/\/ Indeterminate if no dot or found at last or only the first index\n+            if (lastDotIndex > 0 && lastDotIndex < length - 1) {\n+                return fileNameString.substring(lastDotIndex + 1);\n+            }\n+        }\n+\n+        return defaultExtension;\n+    }\n+\n+    \/**\n+     * Returns whether the string representation of this path has an\n+     * extension among the one or more extensions given as parameters.\n+     * The extension of this path will be compared against the given\n+     * parameters in the order in which they are supplied.\n+     *\n+     * @param   ext\n+     *          the first extension for which to check\n+     *\n+     * @param   extensions\n+     *          zero or more subsequent extensions for which to check\n+     *\n+     * @return  an {@code Optional} which either contains the found extension\n+     *          or is empty if this path either does not have an extension or\n+     *          its extension is not among those given\n+     *\n+     * @since 19\n+     *\/\n+    default Optional<String> hasExtension(String ext, String... extensions) {\n+        String thisExtension = getExtension(null);\n+        if (thisExtension == null)\n+            return Optional.empty();\n+\n+        Objects.requireNonNull(ext);\n+        if (ext.equals(thisExtension))\n+            return Optional.of(ext);\n+\n+        for (String e : extensions) {\n+            Objects.requireNonNull(e);\n+            if (e.equals(thisExtension))\n+                return Optional.of(e);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Returns a new {@code Path} which is equal to this path aside from its\n+     * extension which is replaced by the provided extension. If the provided\n+     * extension is {@link String#isEmpty() empty}, then the current extension\n+     * and the dot ('.') preceding it are removed. If this path does not have\n+     * an extension then the provided extension is appended.\n+     *\n+     * @implNote\n+     * This default implementation works with the string representation of this\n+     * path. Paths which have a native representation should override this\n+     * implementation in order to preserve that representation.\n+     *\n+     * @param  extension\n+     *         the extension to replace this path's current extension;\n+     *         if non-empty, may not contain a leading or trailing dot\n+     *         but is not otherwise checked for validity\n+     *\n+     * @return a new path equal to this path but with extension replaced by\n+     *         that provided\n+     *\n+     * @throws IllegalArgumentException if the provided extension contains a\n+     *         leading or trailing dot ('.')\n+     *\n+     * @since 19\n+     *\/\n+    default Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.indexOf('.') == 0 ||\n+                extension.lastIndexOf('.') == extension.length() - 1)\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n+\n+        String thisPath = toString();\n+        String thisExtension = getExtension(null);\n+        FileSystem fs = this.getFileSystem();\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null)\n+            return extension.isEmpty() ?\n+                this : fs.getPath(thisPath + \".\" + extension);\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        int dotIndex = thisPath.lastIndexOf('.');\n+        assert dotIndex != -1;\n+        if (extension.isEmpty())\n+            return fs.getPath(thisPath.substring(0, dotIndex));\n+\n+        \/\/ replace the path's extension with that provided\n+        return fs.getPath(thisPath.substring(0, dotIndex + 1) + extension);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":143,"deletions":1,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,9 @@\n-import java.nio.file.*;\n-import java.nio.charset.*;\n-import java.io.*;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.charset.CharacterCodingException;\n+import java.io.IOException;\n@@ -32,1 +38,1 @@\n-import java.util.*;\n+import java.util.Objects;\n@@ -274,0 +280,50 @@\n+    @Override\n+    public Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.indexOf('.') == 0 ||\n+                extension.lastIndexOf('.') == extension.length() - 1)\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n+\n+        String thisExtension = getExtension(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null) {\n+            if (extension.isEmpty()) {\n+                return this;\n+            } else {\n+                byte[] ext = encode(this.fs, extension);\n+                byte[] result = new byte[path.length + 1 + ext.length];\n+                System.arraycopy(path, 0, result, 0, path.length);\n+                result[path.length] = '.';\n+                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n+                return new UnixPath(this.fs, result);\n+            }\n+        }\n+\n+        \/\/ find the index of the last dot in the path\n+        int dotIndex = path.length - 1;\n+        while (path[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        if (extension.isEmpty()) {\n+            byte[] result = new byte[dotIndex];\n+            System.arraycopy(path, 0, result, 0, dotIndex);\n+            return new UnixPath(this.fs, result);\n+        }\n+\n+        \/\/ replace the path's extension with that provided\n+        byte[] ext = encode(this.fs, extension);\n+        byte[] result = new byte[dotIndex + 1 + ext.length];\n+        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n+        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n+        return new UnixPath(this.fs, result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":61,"deletions":5,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,50 @@\n+\n+    @Override\n+    public Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ verify the extension contains neither a leading nor trailing dot\n+        if (!extension.isEmpty()) {\n+            if (extension.indexOf('.') == 0 ||\n+                extension.lastIndexOf('.') == extension.length() - 1)\n+                throw new IllegalArgumentException(\"leading or trailing dot\");\n+        }\n+\n+        String thisExtension = getExtension(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null) {\n+            if (extension.isEmpty()) {\n+                return this;\n+            } else {\n+                byte[] ext = normalize(extension);\n+                byte[] result = new byte[path.length + 1 + ext.length];\n+                System.arraycopy(path, 0, result, 0, path.length);\n+                result[path.length] = '.';\n+                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n+                return new ZipPath(this.zfs, result);\n+            }\n+        }\n+\n+        \/\/ find the index of the last dot in the path\n+        int dotIndex = path.length - 1;\n+        while (path[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        if (extension.isEmpty()) {\n+            byte[] result = new byte[dotIndex];\n+            System.arraycopy(path, 0, result, 0, dotIndex);\n+            return new ZipPath(this.zfs, result);\n+        }\n+\n+        \/\/ replace the path's extension with that provided\n+        byte[] ext = normalize(extension);\n+        byte[] result = new byte[dotIndex + 1 + ext.length];\n+        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n+        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n+        return new ZipPath(this.zfs, result);\n+    }\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":51,"deletions":1,"binary":false,"changes":52,"status":"modified"}]}