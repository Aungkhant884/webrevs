{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -52,1 +54,1 @@\n- * elements.\n+ * elements, and {@link #getExtension() getExtension} to obtain its extension.\n@@ -96,0 +98,7 @@\n+ * @apiNote\n+ * On some file systems a {@code Path} may have an internal representation\n+ * which cannot be converted to a {@code String} without losing information.\n+ * Otherwise stated, the internal representation might not be recoverable\n+ * from the derived path string. This applies to the {@code Path} as a whole\n+ * as well as to its components.\n+ *\n@@ -251,0 +260,50 @@\n+    \/**\n+     * Returns the file name extension of this path as an\n+     * {@code Optional<String>}. The extension is defined to be the portion\n+     * of the {@code String} representation of the file name after the last\n+     * dot ('.'). All leading dots are ignored. If the extension is missing,\n+     * then an {@link Optional#empty empty} {@code Optional} is returned. This\n+     * will occur if the path has zero elements ({@link #getFileName()} returns\n+     * {@code null}), the file name string does not contain a dot, or only the\n+     * first character is a dot. If the last character is a dot, the extension\n+     * is the empty string.\n+     *\n+     * @implSpec\n+     * The default implementation is equivalent for this path to:\n+     * <pre>{@code\n+     * if (lastDot <= 0)\n+     *     return Optional.empty();\n+     * return lastDot == name.length() - 1 ?\n+     *     Optional.of(\"\") :\n+     *     Optional.of(name.substring(lastDot + 1));\n+     * }<\/pre>\n+     *\n+     * @return  an {@code Optional} which either contains the file name\n+     *          extension of this path, which might be the empty string,\n+     *          or equals {@link Optional#empty} if no extension is found\n+     *\n+     * @since 20\n+     *\/\n+    default Optional<String> getExtension() {\n+        Path fileName = getFileName();\n+        if (fileName == null) {\n+            return Optional.empty();\n+        }\n+\n+        String fileNameString = fileName.toString();\n+        int length = fileNameString.length();\n+\n+        \/\/ Indeterminate if fileNameString is too short\n+        if (length > 2) {\n+            int lastDotIndex = fileNameString.lastIndexOf('.');\n+            \/\/ Indeterminate if no dot or only at first index\n+            if (lastDotIndex > 0) {\n+                return lastDotIndex == length - 1 ?\n+                    Optional.of(\"\") : \/\/ empty string if last dot at last index\n+                    Optional.of(fileNameString.substring(lastDotIndex + 1));\n+            }\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":61,"deletions":2,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,9 @@\n-import java.nio.file.*;\n-import java.nio.charset.*;\n-import java.io.*;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.charset.CharacterCodingException;\n+import java.io.IOException;\n@@ -32,1 +38,1 @@\n-import java.util.*;\n+import java.util.Objects;\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8057113\n+ * @summary Verify extension methods\n+ * @run testng Extensions\n+ *\/\n+public class Extensions {\n+    private static final Optional EMPTY = Optional.empty();\n+    private static final Optional EMPTY_STRING = of(\"\");\n+\n+    private static Optional<String> of(String s) {\n+        return Optional.of(s);\n+    }\n+\n+    @Test\n+    public static void exceptions() {\n+        Path path = Path.of(\"file.ext\");\n+\n+        Assert.assertThrows(NullPointerException.class,\n+                            () -> {path.hasExtension(null);});\n+\n+        Assert.assertThrows(NullPointerException.class,\n+                            () -> {path.replaceExtension(null);});\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                            () -> {path.replaceExtension(\".leading\");});\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                            () -> {path.replaceExtension(\"trailing.\");});\n+    }\n+\n+    \/**\n+     * Returns path name string and expected extension pairs.\n+     *\n+     * @return {@code {{\"pathname\", \"extension\"},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] getProvider() {\n+        Object[][] pairs = {\n+            {\".\",              EMPTY},\n+            {\"..\",             EMPTY},\n+            {\".a.b\",           of(\"b\")},\n+            {\"......\",         EMPTY_STRING},\n+            {\".....a\",         of(\"a\")},\n+            {\"...a.b\",         of(\"b\")},\n+            {\"..foo\",          of(\"foo\")},\n+            {\"test.rb\",        of(\"rb\")},\n+            {\"a\/b\/d\/test.rb\" , of(\"rb\")},\n+            {\".a\/b\/d\/test.rb\", of(\"rb\")},\n+            {\"foo.\",           EMPTY_STRING},\n+            {\"test\",           EMPTY},\n+            {\".profile\",       EMPTY},\n+            {\".profile.sh\",    of(\"sh\")},\n+            {\"..foo\",          of(\"foo\")},\n+            {\".....foo\",       of(\"foo\")},\n+            {\".vimrc\",         EMPTY},\n+            {\"test.\",          EMPTY_STRING},\n+            {\"test..\",         EMPTY_STRING},\n+            {\"test...\",        EMPTY_STRING},\n+            {\"foo.tar.gz\",     of(\"gz\")},\n+            {\"foo.bar.\",       EMPTY_STRING},\n+            {\"image.jpg\",      of(\"jpg\")},\n+            {\"music.mp3\",      of(\"mp3\")},\n+            {\"video.mp4\",      of(\"mp4\")},\n+            {\"document.txt\",   of(\"txt\")},\n+        };\n+        return pairs;\n+    }\n+\n+    @Test(dataProvider = \"getProvider\")\n+    public static void get(String pathname, Optional<String> extension) {\n+        Assert.assertEquals(Path.of(pathname).getExtension(), extension);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"}]}