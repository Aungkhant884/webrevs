{"files":[{"patch":"@@ -261,2 +261,3 @@\n-     * {@code null}), or the file name string does not contain a dot, only\n-     * the first character is a dot, or the last character is a dot.\n+     * {@code null}), or the file name string does not contain a dot, or only\n+     * the first character is a dot. If the last character is a dot, the\n+     * extension is the empty {@code String} {@code \"\"}.\n@@ -269,2 +270,6 @@\n-     *     lastDot > 0 && lastDot < name.length() - 1 ?\n-     *         Optional.of(name.substring(lastDot + 1)) : Optional.empty();\n+     *     if (lastDot > 0)\n+     *         lastDot == name.length() - 1) ?\n+     *             Optional.of(\"\") :\n+     *             Optional.of(name.substring(lastDot + 1));\n+     *     else\n+     *         Optional.empty();\n@@ -291,3 +296,5 @@\n-            \/\/ Indeterminate if no dot or found at last or only the first index\n-            if (lastDotIndex > 0 && lastDotIndex < length - 1) {\n-                return Optional.of(fileNameString.substring(lastDotIndex + 1));\n+            \/\/ Indeterminate if no dot or only at first index\n+            if (lastDotIndex > 0) {\n+                return lastDotIndex == length - 1 ?\n+                    Optional.of(\"\") : \/\/ empty string if last dot at last index\n+                    Optional.of(fileNameString.substring(lastDotIndex + 1));\n@@ -327,4 +334,6 @@\n-        for (String e : extensions) {\n-            Objects.requireNonNull(e);\n-            if (e.equals(thisExtension))\n-                return Optional.of(e);\n+        if (extensions != null) {\n+            for (String e : extensions) {\n+                Objects.requireNonNull(e);\n+                if (e.equals(thisExtension))\n+                    return Optional.of(e);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":20,"deletions":11,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Optional;\n+\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8057113\n+ * @summary Verify extension methods\n+ * @run testng Extensions\n+ *\/\n+public class Extensions {\n+    private static final Optional EMPTY = Optional.empty();\n+    private static final Optional EMPTY_STRING = of(\"\");\n+\n+    private static Optional<String> of(String s) {\n+        return Optional.of(s);\n+    }\n+\n+    @Test\n+    public static void exceptions() {\n+        Path path = Path.of(\"file.ext\");\n+\n+        Assert.assertThrows(NullPointerException.class,\n+                            () -> {path.hasExtension(null);});\n+\n+        Assert.assertThrows(NullPointerException.class,\n+                            () -> {path.replaceExtension(null);});\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                            () -> {path.replaceExtension(\".leading\");});\n+        Assert.assertThrows(IllegalArgumentException.class,\n+                            () -> {path.replaceExtension(\"trailing.\");});\n+    }\n+\n+    \/**\n+     * Returns path name string and expected extension pairs.\n+     *\n+     * @return {@code {{\"pathname\", \"extension\"},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] getProvider() {\n+        Object[][] pairs = new Object[][] {\n+            new Object[] {\".\",              EMPTY},\n+            new Object[] {\"..\",             EMPTY},\n+            new Object[] {\".a.b\",           of(\"b\")},\n+            new Object[] {\"......\",         EMPTY_STRING},\n+            new Object[] {\".....a\",         of(\"a\")},\n+            new Object[] {\"...a.b\",         of(\"b\")},\n+            new Object[] {\"..foo\",          of(\"foo\")},\n+            new Object[] {\"test.rb\",        of(\"rb\")},\n+            new Object[] {\"a\/b\/d\/test.rb\" , of(\"rb\")},\n+            new Object[] {\".a\/b\/d\/test.rb\", of(\"rb\")},\n+            new Object[] {\"foo.\",           EMPTY_STRING},\n+            new Object[] {\"test\",           EMPTY},\n+            new Object[] {\".profile\",       EMPTY},\n+            new Object[] {\".profile.sh\",    of(\"sh\")},\n+            new Object[] {\"..foo\",          of(\"foo\")},\n+            new Object[] {\".....foo\",       of(\"foo\")},\n+            new Object[] {\".vimrc\",         EMPTY},\n+            new Object[] {\"test.\",          EMPTY_STRING},\n+            new Object[] {\"test..\",         EMPTY_STRING},\n+            new Object[] {\"test...\",        EMPTY_STRING},\n+            new Object[] {\"foo.tar.gz\",     of(\"gz\")},\n+            new Object[] {\"foo.bar.\",       EMPTY_STRING},\n+            new Object[] {\"image.jpg\",      of(\"jpg\")},\n+            new Object[] {\"music.mp3\",      of(\"mp3\")},\n+            new Object[] {\"video.mp4\",      of(\"mp4\")},\n+            new Object[] {\"document.txt\",   of(\"txt\")},\n+        };\n+        return pairs;\n+    }\n+\n+    @Test(dataProvider = \"getProvider\")\n+    public static void get(String pathname, Optional<String> extension) {\n+        Assert.assertEquals(Path.of(pathname).getExtension(), extension);\n+    }\n+\n+    \/**\n+     * Returns path name string, expected result, and extensions to search for.\n+     *\n+     * @return {@code {{\"pathname\", of(\"expected\"), \"ext0\", \"ext1\", ...},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] hasProvider() {\n+        Object[][] v = new Object[][] {\n+            new Object[] {\"image.jpg\", of(\"jpg\"), \"JPEG\", \"jpeg\", \"JPG\", \"jpg\"},\n+            new Object[] {\"image.jpg\", EMPTY, \"jpG\", \"jPG\", \"JPG\"},\n+            new Object[] {\"image.jpg\", EMPTY, \"gif\", \"png\", \"tiff\"},\n+            new Object[] {\"nullext\", EMPTY, \"gif\", \"jpg\", \"png\", \"tiff\"},\n+            new Object[] {\"emptyext.\", EMPTY_STRING, \"gif\", \"jpg\", \"png\", \"\"},\n+            new Object[] {\"doc.txt\", EMPTY, \"doc\"},\n+        };\n+        return v;\n+    }\n+\n+    @Test(dataProvider = \"hasProvider\")\n+    public static void has(String pathname, Optional<String> expected,\n+        String[] extensions) {\n+        String ext = extensions[0];\n+        String[] exts = extensions.length > 1 ?\n+            Arrays.copyOfRange(extensions, 1, extensions.length) : null;\n+        Optional<String> actual = Path.of(pathname).hasExtension(ext, exts);\n+        Assert.assertEquals(actual, expected);\n+    }\n+\n+    \/**\n+     * Returns path name string, new extension, and expected result.\n+     *\n+     * @return {@code {{\"pathname\", \"extension\", \"expected\"},...}}\n+     *\/\n+    @DataProvider\n+    static Object[][] replaceProvider() {\n+        Object[][] v = new Object[][] {\n+            new Object[] {\"image.png\", \"png\", Path.of(\"image.png\")},\n+            new Object[] {\"image.tiff\", \"jpg\", Path.of(\"image.jpg\")},\n+            new Object[] {\"nullext\", \"dat\", Path.of(\"nullext.dat\")},\n+            new Object[] {\"emptyext.\", \"dat\", Path.of(\"emptyext.dat\")},\n+            new Object[] {\"foo.tar\", \"tar.gz\", Path.of(\"foo.tar.gz\")},\n+            new Object[] {\"foo.\", \"bar\", Path.of(\"foo.bar\")},\n+        };\n+        return v;\n+    }\n+\n+    @Test(dataProvider = \"replaceProvider\")\n+    public static void replace(String pathname, String extension,\n+        Path expected) {\n+        Path actual = Path.of(pathname).replaceExtension(extension);\n+        Assert.assertEquals(actual, expected);\n+    }\n+}\n","filename":"test\/jdk\/java\/nio\/file\/Path\/Extensions.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"}]}