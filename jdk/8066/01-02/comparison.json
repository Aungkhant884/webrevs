{"files":[{"patch":"@@ -34,0 +34,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -301,0 +303,95 @@\n+    \/**\n+     * Returns whether the string representation of this path has an\n+     * extension among the one or more extensions given as parameters.\n+     * The extension of this path will be compared against the given\n+     * parameters in the order in which they are supplied.\n+     *\n+     * @param   ext\n+     *          the first extension for which to check\n+     *\n+     * @param   extensions\n+     *          zero or more subsequent extensions for which to check\n+     *\n+     * @return  an {@code Optional} which either contains the found extension\n+     *          or is empty if this path either does not have an extension or\n+     *          its extension is not among those given\n+     *\n+     * @since 19\n+     *\/\n+    default Optional<String> hasExtension(String ext, String... extensions) {\n+        String thisExtension = getExtension(null);\n+        if (thisExtension == null)\n+            return Optional.empty();\n+\n+        Objects.requireNonNull(ext);\n+        if (ext.equals(thisExtension))\n+            return Optional.of(ext);\n+\n+        for (String e : extensions) {\n+            Objects.requireNonNull(e);\n+            if (e.equals(thisExtension))\n+                return Optional.of(e);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Returns a new {@code Path} which is equal to this path aside from its\n+     * extension which is replaced by the provided extension. If the provided\n+     * extension is {@link String#isEmpty() empty}, then the current extension\n+     * and the dot ('.') preceding it are removed. If this path does not have\n+     * an extension then the provided extension is appended.\n+     *\n+     * @implNote\n+     * This default implementation works with the string representation of this\n+     * path. Paths which have a native representation should override this\n+     * implementation in order to preserve that representation.\n+     *\n+     * @param  extension\n+     *         the extension to replace this path's current extension;\n+     *         leading and trailing space is ignored; may contain at most\n+     *         one dot ('.') which if present must be the first character\n+     *         that is not a space\n+     *\n+     * @return a new path equal to this path but with extension replaced by\n+     *         that provided\n+     *\n+     * @throws IllegalArgumentException if the provided extension contains a dot\n+     *         ('.') which is not the first non-space character of the parameter\n+     *\n+     * @since 19\n+     *\/\n+    default Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ trim the extension and verify that at most a leading dot is present\n+        extension = extension.trim();\n+        int dotIndex = extension.lastIndexOf('.');\n+        if (dotIndex > 0)\n+            throw new IllegalArgumentException();\n+\n+        \/\/ dispense with the leading dot if present\n+        if (dotIndex == 0)\n+            extension = extension.substring(1);\n+\n+        String path = toString();\n+        String thisExtension = getExtension(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null)\n+            return extension.isEmpty() ?\n+                this : Path.of(path + \".\" + extension);\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        dotIndex = path.lastIndexOf('.');\n+        assert dotIndex != -1;\n+        if (extension.isEmpty())\n+            return Path.of(path.substring(0, dotIndex));\n+\n+        \/\/ replace the path's extension with that provided\n+        StringBuilder sb = new StringBuilder(path.substring(0, dotIndex + 1));\n+        sb.append(extension);\n+        return Path.of(sb.toString());\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/file\/Path.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,9 @@\n-import java.nio.file.*;\n-import java.nio.charset.*;\n-import java.io.*;\n+import java.nio.file.InvalidPathException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.nio.file.ProviderMismatchException;\n+import java.nio.file.WatchEvent;\n+import java.nio.file.WatchKey;\n+import java.nio.file.WatchService;\n+import java.nio.charset.CharacterCodingException;\n+import java.io.IOException;\n@@ -32,1 +38,1 @@\n-import java.util.*;\n+import java.util.Objects;\n@@ -274,0 +280,56 @@\n+    private static int getLastDotIndex(byte[] b) {\n+        int dotIndex = b.length - 1;\n+        while (b[dotIndex] != '.') {\n+            dotIndex--;\n+            if (dotIndex < 0)\n+                throw new IndexOutOfBoundsException();\n+        }\n+        return dotIndex;\n+    }\n+\n+    @Override\n+    public Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ trim the extension and verify that at most a leading dot is present\n+        extension = extension.trim();\n+        int dotIndex = extension.lastIndexOf('.');\n+        if (dotIndex > 0)\n+            throw new IllegalArgumentException();\n+\n+        \/\/ dispense with the leading dot if present\n+        if (dotIndex == 0)\n+            extension = extension.substring(1);\n+\n+        String thisExtension = getExtension(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null) {\n+            if (extension.isEmpty()) {\n+                return this;\n+            } else {\n+                byte[] ext = encode(this.fs, extension);\n+                byte[] result = new byte[path.length + 1 + ext.length];\n+                System.arraycopy(path, 0, result, 0, path.length);\n+                result[path.length] = '.';\n+                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n+                return new UnixPath(this.fs, result);\n+            }\n+        }\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        dotIndex = getLastDotIndex(path);\n+        if (extension.isEmpty()) {\n+            byte[] result = new byte[dotIndex];\n+            System.arraycopy(path, 0, result, 0, dotIndex);\n+            return new UnixPath(this.fs, result);\n+        }\n+\n+        \/\/ replace the path's extension with that provided\n+        byte[] ext = encode(this.fs, extension);\n+        byte[] result = new byte[dotIndex + 1 + ext.length];\n+        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n+        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n+        return new UnixPath(this.fs, result);\n+    }\n+\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/fs\/UnixPath.java","additions":67,"deletions":5,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,0 +106,46 @@\n+\n+    @Override\n+    public Path replaceExtension(String extension) {\n+        Objects.requireNonNull(extension, \"extension\");\n+\n+        \/\/ trim the extension and verify that at most a leading dot is present\n+        extension = extension.trim();\n+        int dotIndex = extension.lastIndexOf('.');\n+        if (dotIndex > 0)\n+            throw new IllegalArgumentException();\n+\n+        \/\/ dispense with the leading dot if present\n+        if (dotIndex == 0)\n+            extension = extension.substring(1);\n+\n+        String thisExtension = getExtension(null);\n+\n+        \/\/ if this path has no extension, append that provided\n+        if (thisExtension == null) {\n+            if (extension.isEmpty()) {\n+                return this;\n+            } else {\n+                byte[] ext = encode(this.fs, extension);\n+                byte[] result = new byte[path.length + 1 + ext.length];\n+                System.arraycopy(path, 0, result, 0, path.length);\n+                result[path.length] = '.';\n+                System.arraycopy(ext, 0, result, path.length + 1, ext.length);\n+                return new UnixPath(this.fs, result);\n+            }\n+        }\n+\n+        \/\/ if the provided extension is empty, strip this path's extension\n+        dotIndex = getLastDotIndex(path);\n+        if (extension.isEmpty()) {\n+            byte[] result = new byte[dotIndex];\n+            System.arraycopy(path, 0, result, 0, dotIndex);\n+            return new UnixPath(this.fs, result);\n+        }\n+\n+        \/\/ replace the path's extension with that provided\n+        byte[] ext = encode(this.fs, extension);\n+        byte[] result = new byte[dotIndex + 1 + ext.length];\n+        System.arraycopy(path, 0, result, 0, dotIndex + 1);\n+        System.arraycopy(ext, 0, result, dotIndex + 1, ext.length);\n+        return new UnixPath(this.fs, result);\n+    }\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipPath.java","additions":47,"deletions":1,"binary":false,"changes":48,"status":"modified"}]}