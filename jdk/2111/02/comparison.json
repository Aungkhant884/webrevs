{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -270,1 +270,2 @@\n-    tty.print(\"Method \" + getName().asString() + getSignature().asString() + \"@\" + getAddress());\n+      tty.print(\"Method \" + getMethodHolder().getName().asString() + \".\" +\n+                getName().asString() + getSignature().asString() + \"@\" + getAddress());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Method.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -470,1 +470,1 @@\n-  private Address lastSPDbg() {\n+  public Address lastSPDbg() {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/JavaThread.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.jvm.hotspot.debugger.cdbg.*;\n@@ -31,1 +32,0 @@\n-import sun.jvm.hotspot.runtime.*;\n@@ -33,0 +33,3 @@\n+import sun.jvm.hotspot.oops.Metadata;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.WrongTypeException;\n@@ -40,0 +43,41 @@\n+    Threads threads = VM.getVM().getThreads();\n+\n+    \/\/ Check if address is a pointer to a Metadata object.\n+    try {\n+      loc.metadata = Metadata.instantiateWrapperFor(a);\n+      return loc;\n+    } catch (Exception e) {\n+      \/\/ Just ignore. This just means we aren't dealing with a Metadata pointer.\n+    }\n+\n+    \/\/ Check if address is some other C++ type that we can deduce\n+    loc.ctype = VM.getVM().getTypeDataBase().guessTypeForAddress(a);\n+    if (loc.ctype == null && VM.getVM().isSharingEnabled()) {\n+      \/\/ Check if the value falls in the _md_region\n+      try {\n+        Address loc1 = a.getAddressAt(0);\n+        FileMapInfo cdsFileMapInfo = VM.getVM().getFileMapInfo();\n+        if (cdsFileMapInfo.inCopiedVtableSpace(loc1)) {\n+          loc.ctype = cdsFileMapInfo.getTypeForVptrAddress(loc1);\n+        }\n+      } catch (AddressException | WrongTypeException e) {\n+        \/\/ This can happen if \"a\" or \"loc1\" is a bad address. Just ignore.\n+      }\n+    }\n+    if (loc.ctype != null) {\n+      return loc;\n+    }\n+\n+    \/\/ Check if address is in the stack of a JavaThread\n+    for (int i = 0; i < threads.getNumberOfThreads(); i++) {\n+        JavaThread t = threads.getJavaThreadAt(i);\n+        Address stackBase = t.getStackBase();\n+        if (stackBase != null) {\n+            Long stackSize = t.getStackSize();\n+            Address stackEnd = stackBase.addOffsetTo(-stackSize);\n+            if (a.lessThanOrEqual(stackBase) && a.greaterThan(stackEnd)) {\n+                loc.stackThread = t;\n+                return loc;\n+            }\n+        }\n+    }\n@@ -41,0 +85,12 @@\n+    \/\/ Check if address is a native (C++) symbol\n+    JVMDebugger dbg = VM.getVM().getDebugger();\n+    CDebugger cdbg = dbg.getCDebugger();\n+    if (cdbg != null) {\n+        loc.loadObject = cdbg.loadObjectContainingPC(a);\n+        if (loc.loadObject != null) {\n+            loc.nativeSymbol = loc.loadObject.closestSymbolToPC(a);\n+            return loc;\n+        }\n+    }\n+\n+    \/\/ Check if address is in the java heap.\n@@ -53,1 +109,1 @@\n-          if (Assert.ASSERTS_ENABLED) {\n+        if (Assert.ASSERTS_ENABLED) {\n@@ -59,1 +115,0 @@\n-          Threads threads = VM.getVM().getThreads();\n@@ -81,0 +136,1 @@\n+    \/\/ Check if address is in the interpreter\n@@ -88,0 +144,1 @@\n+    \/\/ Check if address is in the code cache\n@@ -130,1 +187,0 @@\n-    Threads threads = VM.getVM().getThreads();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerFinder.java","additions":61,"deletions":5,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.debugger.cdbg.*;\n@@ -32,1 +33,0 @@\n-import sun.jvm.hotspot.runtime.*;\n@@ -34,0 +34,3 @@\n+import sun.jvm.hotspot.oops.Metadata;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.types.Type;\n@@ -48,0 +51,7 @@\n+  Metadata metadata;\n+  Type ctype;\n+  JavaThread stackThread;\n+\n+  LoadObject loadObject;\n+  ClosestSymbol nativeSymbol;\n+\n@@ -83,0 +93,16 @@\n+  public boolean isMetadata() {\n+    return metadata != null;\n+  }\n+\n+  public boolean isCtype() {\n+    return ctype != null;\n+  }\n+\n+  public boolean isInJavaStack() {\n+    return stackThread != null;\n+  }\n+\n+  public boolean isNativeSymbol() {\n+    return loadObject != null;\n+  }\n+\n@@ -178,2 +204,3 @@\n-    return (!(isInHeap() || isInInterpreter() || isInCodeCache() ||\n-              isInStrongGlobalJNIHandles() || isInWeakGlobalJNIHandles() || isInLocalJNIHandleBlock()));\n+      return (!(isMetadata() || isCtype() || isInJavaStack() || isNativeSymbol() || isInHeap() ||\n+                isInInterpreter() || isInCodeCache() || isInStrongGlobalJNIHandles() ||\n+                isInWeakGlobalJNIHandles() || isInLocalJNIHandleBlock()));\n@@ -189,1 +216,5 @@\n-    printOn(System.out);\n+      printOn(System.out, true, true);\n+  }\n+\n+  public void print(boolean printAddress, boolean verbose) {\n+    printOn(System.out, printAddress, verbose);\n@@ -193,5 +224,12 @@\n-    tty.print(\"Address \");\n-    if (addr == null) {\n-      tty.print(\"0x0\");\n-    } else {\n-      tty.print(addr.toString());\n+    printOn(tty, true, true);\n+  }\n+\n+  public void printOn(PrintStream tty, boolean printAddress, boolean verbose) {\n+    if (printAddress) {\n+      tty.print(\"Address \");\n+      if (addr == null) {\n+        tty.print(\"0x0\");\n+      } else {\n+        tty.print(addr.toString());\n+      }\n+      tty.print(\": \");\n@@ -199,2 +237,34 @@\n-    tty.print(\": \");\n-    if (isInHeap()) {\n+    if (isMetadata()) {\n+      metadata.printValueOn(tty); \/\/ does not include \"\\n\"\n+      tty.println();\n+    } else if (isCtype()) {\n+      tty.println(\"Is of type \" + ctype.getName());\n+    } else if (isInJavaStack()) {\n+        if (verbose) {\n+            tty.format(\"In java stack [%s,%s,%s] for thread %s:\\n   \",\n+                       stackThread.getStackBase(), stackThread.lastSPDbg(),\n+                       stackThread.getStackBase().addOffsetTo(-stackThread.getStackSize()),\n+                       stackThread);\n+            stackThread.printThreadInfoOn(tty); \/\/ includes \"\\n\"\n+        } else {\n+            tty.format(\"In java stack for thread \\\"%s\\\" %s\\n\", stackThread.getThreadName(), stackThread);\n+        }\n+    } else if (isNativeSymbol()) {\n+        CDebugger cdbg = VM.getVM().getDebugger().getCDebugger();\n+        long diff;\n+        if (nativeSymbol != null) {\n+            String name = nativeSymbol.getName();\n+            if (cdbg.canDemangle()) {\n+                name = cdbg.demangle(name);\n+            }\n+            tty.print(name);\n+            diff = nativeSymbol.getOffset();\n+        } else {\n+            tty.print(loadObject.getName());\n+            diff = addr.minus(loadObject.getBase());\n+        }\n+        if (diff != 0L) {\n+            tty.print(\" + 0x\" + Long.toHexString(diff));\n+        }\n+        tty.println();\n+    } else if (isInHeap()) {\n@@ -202,3 +272,2 @@\n-        tty.print(\"In thread-local allocation buffer for thread \\\"\" +\n-                  getTLABThread().getThreadName() + \"\\\" (\");\n-        getTLABThread().printThreadIDOn(tty);\n+        tty.print(\"In thread-local allocation buffer for thread (\");\n+        getTLABThread().printThreadInfoOn(tty);\n@@ -206,1 +275,1 @@\n-        getTLAB().printOn(tty);\n+        getTLAB().printOn(tty); \/\/ includes \"\\n\"\n@@ -216,1 +285,1 @@\n-          getGeneration().printOn(tty);\n+          getGeneration().printOn(tty); \/\/ does not include \"\\n\"\n@@ -218,0 +287,1 @@\n+        tty.println();\n@@ -220,2 +290,2 @@\n-      tty.println(\"In interpreter codelet \\\"\" + interpreterCodelet.getDescription() + \"\\\"\");\n-      interpreterCodelet.printOn(tty);\n+      tty.print(\"In interpreter codelet: \");\n+      interpreterCodelet.printOn(tty); \/\/ includes \"\\n\"\n@@ -223,0 +293,2 @@\n+      \/\/ TODO: print the type of CodeBlob. See \"look for known code blobs\" comment\n+      \/\/ in PStack.java for example code.\n@@ -238,1 +310,5 @@\n-      b.printOn(tty);\n+      if (verbose) {\n+          b.printOn(tty); \/\/ includes \"\\n\"\n+      } else {\n+          tty.println(b.toString());\n+      }\n@@ -242,1 +318,1 @@\n-      tty.print(\"In JNI strong global\");\n+      tty.println(\"In JNI strong global\");\n@@ -244,1 +320,1 @@\n-      tty.print(\"In JNI weak global\");\n+      tty.println(\"In JNI weak global\");\n@@ -250,1 +326,1 @@\n-        ((JavaThread) handleThread).printThreadIDOn(tty);\n+        ((JavaThread) handleThread).printThreadIDOn(tty); \/\/ includes \"\\n\"\n@@ -252,1 +328,1 @@\n-        tty.print(\" for a non-Java Thread\");\n+        tty.println(\" for a non-Java Thread\");\n@@ -259,1 +335,1 @@\n-      tty.print(\"In unknown location\");\n+      tty.println(\"In unknown location\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/PointerLocation.java","additions":101,"deletions":25,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.test.lib.Platform;\n@@ -78,0 +79,3 @@\n+    static LingeredApp theApp = null;\n+    static String coreFileName = null;\n+    static ClhsdbLauncher test = null;\n@@ -80,2 +84,0 @@\n-        LingeredApp theApp = null;\n-        String coreFileName = null;\n@@ -83,1 +85,6 @@\n-            ClhsdbLauncher test = new ClhsdbLauncher();\n+            String segvAddress = null;\n+            List<String> cmds = null;\n+            String cmdStr = null;\n+            Map<String, List<String>> expStrMap = null;\n+\n+            test = new ClhsdbLauncher();\n@@ -100,1 +107,0 @@\n-            \/\/ Get the core file name if we are debugging a core instead of live process\n@@ -102,2 +108,8 @@\n-                coreFileName = CoreUtils.getCoreFileLocation(theApp.getOutput().getStdout(), theApp.getPid());\n-            }\n+                String crashOutput = theApp.getOutput().getStdout();\n+                \/\/ Get the core file name if we are debugging a core instead of live process\n+                coreFileName = CoreUtils.getCoreFileLocation(crashOutput, theApp.getPid());\n+                \/\/ Get the SEGV Address from the following line:\n+                \/\/  #  SIGSEGV (0xb) at pc=0x00007f20a897f7f4, pid=8561, tid=8562\n+                String[] parts = crashOutput.split(\" pc=\");\n+                String[] tokens = parts[1].split(\",\");\n+                segvAddress = tokens[0];\n@@ -105,7 +117,12 @@\n-            \/\/ Run 'jstack -v' command to get the findpc address\n-            List<String> cmds = List.of(\"jstack -v\");\n-            String output;\n-            if (withCore) {\n-                output = test.runOnCore(coreFileName, cmds, null, null);\n-            } else {\n-                output = test.run(theApp.getPid(), cmds, null, null);\n+                \/\/ Test the 'findpc' command passing in the SEGV address\n+                cmds = new ArrayList<String>();\n+                cmdStr = \"findpc \" + segvAddress;\n+                cmds.add(cmdStr);\n+                expStrMap = new HashMap<>();\n+                if (Platform.isOSX()) {\n+                    \/\/ OSX will only find addresses in JVM libraries, not user or system libraries\n+                    expStrMap.put(cmdStr, List.of(\"In unknown location\"));\n+                } else { \/\/ symbol lookups not supported with OSX live process\n+                    expStrMap.put(cmdStr, List.of(\"Java_jdk_test_lib_apps_LingeredApp_crash\"));\n+                }\n+                runTest(withCore, cmds, expStrMap);\n@@ -114,0 +131,4 @@\n+            \/\/ Run 'jstack -v' command to get the pc and other useful values\n+            cmds = List.of(\"jstack -v\");\n+            String jStackOutput = runTest(withCore, cmds, null);\n+\n@@ -117,1 +138,1 @@\n-            String[] parts = output.split(\"LingeredAppWithTrivialMain.main\");\n+            String[] parts = jStackOutput.split(\"LingeredAppWithTrivialMain.main\");\n@@ -131,1 +152,1 @@\n-            \/\/ Test the 'findpc' command passing in the pc obtained from above\n+            \/\/ Test the 'findpc' command passing in the pc obtained from jstack above\n@@ -133,1 +154,1 @@\n-            String cmdStr = \"findpc \" + pcAddress;\n+            cmdStr = \"findpc \" + pcAddress;\n@@ -135,1 +156,1 @@\n-            Map<String, List<String>> expStrMap = new HashMap<>();\n+            expStrMap = new HashMap<>();\n@@ -146,0 +167,1 @@\n+            runTest(withCore, cmds, expStrMap);\n@@ -147,2 +169,66 @@\n-            if (withCore) {\n-                test.runOnCore(coreFileName, cmds, expStrMap, null);\n+            \/\/ Run findpc on a Method*. We can find one in the jstack output. For example:\n+            \/\/ - LingeredAppWithTrivialMain.main(java.lang.String[]) @bci=1, line=33, pc=..., Method*=0x0000008041000208 ...\n+            \/\/ This is testing the PointerFinder support for C++ MetaData types.\n+            parts = jStackOutput.split(\"LingeredAppWithTrivialMain.main\");\n+            parts = parts[1].split(\"Method\\\\*=\");\n+            parts = parts[1].split(\" \");\n+            String methodAddr = parts[0];\n+            cmdStr = \"findpc \" + methodAddr;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"Method \",\n+                                          \"LingeredAppWithTrivialMain.main\",\n+                                          methodAddr));\n+            runTest(withCore, cmds, expStrMap);\n+\n+            \/\/ Run findpc on a JavaThread*. We can find one in the jstack output.\n+            \/\/ The tid for a thread is it's JavaThread*. For example:\n+            \/\/  \"main\" #1 prio=5 tid=0x00000080263398f0 nid=0x277e0 ...\n+            \/\/ This is testing the PointerFinder support for all C++ types other than MetaData types.\n+            parts = jStackOutput.split(\"tid=\");\n+            parts = parts[1].split(\" \");\n+            String tid = parts[0];  \/\/ address of the JavaThread\n+            cmdStr = \"findpc \" + tid;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"Is of type JavaThread\"));\n+            runTest(withCore, cmds, expStrMap);\n+\n+            \/\/ Run findpc on a java stack address. We can find one in the jstack output.\n+            \/\/   \"main\" #1 prio=5 tid=... nid=0x277e0 waiting on condition [0x0000008025aef000]\n+            \/\/ The stack address is the last word between the brackets.\n+            \/\/ This is testing the PointerFinder support for thread stack addresses.\n+            parts = jStackOutput.split(\"tid=\");\n+            parts = parts[1].split(\" \\\\[\");\n+            parts = parts[1].split(\"\\\\]\");\n+            String stackAddress = parts[0];  \/\/ address of the thread's stack\n+            cmdStr = \"findpc \" + stackAddress;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            expStrMap.put(cmdStr, List.of(\"In java stack\"));\n+            runTest(withCore, cmds, expStrMap);\n+\n+            \/\/ Run 'examine <addr>' using a thread's tid as the address. The\n+            \/\/ examine output will be the of the form:\n+            \/\/    <tid>: <value>\n+            \/\/ Where <value> is the word stored at <tid>. <value> also happens to\n+            \/\/ be the vtable address. We then run findpc on this vtable address.\n+            \/\/ This tests PointerFinder support for native C++ symbols.\n+            cmds = List.of(\"examine \" + tid);\n+            String examineOutput = runTest(withCore, cmds, null);\n+            \/\/ Extract <value>.\n+            parts = examineOutput.split(tid + \": \");\n+            String value = parts[1];\n+            \/\/ Use findpc on <value>. The output should look something like:\n+            \/\/    Address 0x00007fed86f610b8: vtable for JavaThread + 0x10\n+            cmdStr = \"findpc \" + value;\n+            cmds = List.of(cmdStr);\n+            expStrMap = new HashMap<>();\n+            if (Platform.isWindows()) {\n+                expStrMap.put(cmdStr, List.of(\"jvm.+JavaThread\"));\n+            } else if (Platform.isOSX()) {\n+                if (withCore) {\n+                    expStrMap.put(cmdStr, List.of(\"__ZTV10JavaThread\"));\n+                } else { \/\/ symbol lookups not supported with OSX live process\n+                    expStrMap.put(cmdStr, List.of(\"In unknown location\"));\n+                }\n@@ -150,1 +236,1 @@\n-                test.run(theApp.getPid(), cmds, expStrMap, null);\n+                expStrMap.put(cmdStr, List.of(\"vtable for JavaThread\"));\n@@ -152,0 +238,1 @@\n+            runTest(withCore, cmds, expStrMap);\n@@ -163,0 +250,10 @@\n+    private static String runTest(boolean withCore, List<String> cmds, Map<String, List<String>> expStrMap)\n+        throws Exception\n+    {\n+        if (withCore) {\n+            return test.runOnCore(coreFileName, cmds, expStrMap, null);\n+        } else {\n+            return test.run(theApp.getPid(), cmds, expStrMap, null);\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/serviceability\/sa\/ClhsdbFindPC.java","additions":117,"deletions":20,"binary":false,"changes":137,"status":"modified"}]}