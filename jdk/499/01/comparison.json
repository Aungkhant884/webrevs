{"files":[{"patch":"@@ -295,1 +295,1 @@\n-        final StringBuilder buf = new StringBuilder(writer.anchorName(executableElement));\n+        final StringBuilder buf = new StringBuilder(executableElement.getSimpleName());\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractExecutableMemberWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.io.IOException;\n-import java.io.Writer;\n-import java.util.HashMap;\n-import java.util.Iterator;\n@@ -33,3 +29,1 @@\n-import java.util.Map;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.SortedSet;\n@@ -39,1 +33,0 @@\n-import javax.lang.model.element.ExecutableElement;\n@@ -45,1 +38,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;\n+\n@@ -53,2 +46,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFile;\n-import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n@@ -56,1 +47,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n@@ -71,1 +61,1 @@\n- * @see    IndexBuilder\n+ * @see IndexBuilder\n@@ -75,6 +65,1 @@\n-    \/**\n-     * The index of all the members with unicode character.\n-     *\/\n-    protected IndexBuilder indexBuilder;\n-\n-    protected Navigation navBar;\n+    protected final IndexBuilder mainIndex;\n@@ -82,1 +67,1 @@\n-    protected final Map<Character, List<SearchIndexItem>> tagSearchIndexMap;\n+    protected final Navigation navBar;\n@@ -85,2 +70,2 @@\n-     * This constructor will be used by {@link SplitIndexWriter}. Initializes\n-     * path to this file and relative path from this file.\n+     * Initializes the common data for writers that can generate index files\n+     * based on the information in {@code configuration.mainIndex}.\n@@ -88,3 +73,2 @@\n-     * @param configuration  The current configuration\n-     * @param path       Path to the file which is getting generated.\n-     * @param indexBuilder Unicode based Index from {@link IndexBuilder}\n+     * @param configuration  the current configuration\n+     * @param path           path to the file which is getting generated.\n@@ -93,2 +77,1 @@\n-                                  DocPath path,\n-                                  IndexBuilder indexBuilder) {\n+                                  DocPath path) {\n@@ -96,1 +79,1 @@\n-        this.indexBuilder = indexBuilder;\n+        this.mainIndex = configuration.mainIndex;\n@@ -98,4 +81,0 @@\n-        Stream<SearchIndexItem> items =\n-                searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY)\n-                        .sorted(comparators.makeGenericSearchIndexComparator());\n-        this.tagSearchIndexMap = buildSearchTagIndex(items);\n@@ -104,1 +83,1 @@\n-    protected void addContents(Character uc, List<IndexItem> memberlist,\n+    protected void addContents(Character uc, SortedSet<IndexItem> memberlist,\n@@ -109,6 +88,2 @@\n-        Map<String,Integer> duplicateLabelCheck = new HashMap<>();\n-        memberlist.forEach(e -> duplicateLabelCheck.compute(e.getFullyQualifiedLabel(utils),\n-                (k, v) -> v == null ? 1 : v + 1));\n-        for (IndexItem indexItem : memberlist) {\n-            addDescription(indexItem, dl,\n-                    duplicateLabelCheck.get(indexItem.getFullyQualifiedLabel(utils)) > 1);\n+        for (IndexItem item : memberlist) {\n+            addDescription(item, dl);\n@@ -128,9 +103,5 @@\n-    protected void addDescription(IndexItem indexItem, Content dl, boolean addModuleInfo) {\n-        SearchIndexItem si = indexItem.getSearchTag();\n-        if (si != null) {\n-            addDescription(si, dl);\n-        } else {\n-            si = new SearchIndexItem();\n-            si.setLabel(indexItem.getLabel());\n-            addElementDescription(indexItem, dl, si, addModuleInfo);\n-            searchItems.add(si);\n+    protected void addDescription(IndexItem indexItem, Content dl) {\n+        if (indexItem.isTagItem()) {\n+            addTagDescription(indexItem, dl);\n+        } else if (indexItem.isElementItem()) {\n+            addElementDescription(indexItem, dl);\n@@ -143,1 +114,1 @@\n-     * @param indexItem the element to be documented\n+     * @param item the element to be documented\n@@ -145,2 +116,0 @@\n-     * @param si the search index item\n-     * @param addModuleInfo whether to include module information\n@@ -148,2 +117,1 @@\n-    protected void addElementDescription(IndexItem indexItem, Content dlTree, SearchIndexItem si,\n-                                         boolean addModuleInfo) {\n+    protected void addElementDescription(IndexItem item, Content dlTree) {\n@@ -151,2 +119,2 @@\n-        Element element = indexItem.getElement();\n-        String label = indexItem.getLabel();\n+        Element element = item.getElement();\n+        String label = item.getLabel();\n@@ -155,2 +123,1 @@\n-                dt = HtmlTree.DT(getModuleLink((ModuleElement)element, new StringContent(label)));\n-                si.setCategory(Category.MODULES);\n+                dt = HtmlTree.DT(getModuleLink((ModuleElement) element, new StringContent(label)));\n@@ -159,0 +126,1 @@\n+\n@@ -160,1 +128,1 @@\n-                dt = HtmlTree.DT(getPackageLink((PackageElement)element, new StringContent(label)));\n+                dt = HtmlTree.DT(getPackageLink((PackageElement) element, new StringContent(label)));\n@@ -162,1 +130,1 @@\n-                    si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n+                    item.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n@@ -164,1 +132,0 @@\n-                si.setCategory(Category.PACKAGES);\n@@ -167,0 +134,1 @@\n+\n@@ -173,6 +141,1 @@\n-                        LinkInfoImpl.Kind.INDEX, (TypeElement)element).strong(true)));\n-                si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));\n-                if (configuration.showModules && addModuleInfo) {\n-                    si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n-                }\n-                si.setCategory(Category.TYPES);\n+                        LinkInfoImpl.Kind.INDEX, (TypeElement) element).strong(true)));\n@@ -180,1 +143,1 @@\n-                addClassInfo((TypeElement)element, dt);\n+                addClassInfo((TypeElement) element, dt);\n@@ -182,2 +145,6 @@\n-            default:\n-                TypeElement containingType = indexItem.getTypeElement();\n+\n+            case CONSTRUCTOR:\n+            case METHOD:\n+            case FIELD:\n+            case ENUM_CONSTANT:\n+                TypeElement containingType = item.getContainingTypeElement();\n@@ -186,12 +153,0 @@\n-                si.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));\n-                si.setContainingClass(utils.getSimpleName(containingType));\n-                if (configuration.showModules && addModuleInfo) {\n-                    si.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n-                }\n-                if (utils.isExecutableElement(element)) {\n-                    String url = HtmlTree.encodeURL(links.getName(getAnchor((ExecutableElement)element)));\n-                    if (!label.equals(url)) {\n-                        si.setUrl(url);\n-                    }\n-                }\n-                si.setCategory(Category.MEMBERS);\n@@ -201,0 +156,3 @@\n+\n+            default:\n+                throw new Error();\n@@ -227,4 +185,4 @@\n-    protected void addDescription(SearchIndexItem sii, Content dlTree) {\n-        String siiPath = pathToRoot.isEmpty() ? \"\" : pathToRoot.getPath() + \"\/\";\n-        siiPath += sii.getUrl();\n-        HtmlTree labelLink = HtmlTree.A(siiPath, new StringContent(sii.getLabel()));\n+    protected void addTagDescription(IndexItem item, Content dlTree) {\n+        String itemPath = pathToRoot.isEmpty() ? \"\" : pathToRoot.getPath() + \"\/\";\n+        itemPath += item.getUrl();\n+        HtmlTree labelLink = HtmlTree.A(itemPath, new StringContent(item.getLabel()));\n@@ -233,1 +191,1 @@\n-        dt.add(contents.getContent(\"doclet.Search_tag_in\", sii.getHolder()));\n+        dt.add(contents.getContent(\"doclet.Search_tag_in\", item.getHolder()));\n@@ -236,1 +194,1 @@\n-        if (sii.getDescription().isEmpty()) {\n+        if (item.getDescription().isEmpty()) {\n@@ -239,1 +197,1 @@\n-            dd.add(sii.getDescription());\n+            dd.add(item.getDescription());\n@@ -316,81 +274,0 @@\n-    \/**\n-     * @throws DocFileIOException if there is a problem creating any of the search index files\n-     *\/\n-    protected void createSearchIndexFiles() throws DocFileIOException {\n-        createSearchIndexFile(DocPaths.MODULE_SEARCH_INDEX_JS,\n-                              searchItems.itemsOfCategories(Category.MODULES),\n-                              \"moduleSearchIndex\");\n-        if (!configuration.packages.isEmpty()) {\n-            SearchIndexItem si = new SearchIndexItem();\n-            si.setCategory(Category.PACKAGES);\n-            si.setLabel(resources.getText(\"doclet.All_Packages\"));\n-            si.setUrl(DocPaths.ALLPACKAGES_INDEX.getPath());\n-            searchItems.add(si);\n-        }\n-        createSearchIndexFile(DocPaths.PACKAGE_SEARCH_INDEX_JS,\n-                              searchItems.itemsOfCategories(Category.PACKAGES),\n-                              \"packageSearchIndex\");\n-        SearchIndexItem si = new SearchIndexItem();\n-        si.setCategory(Category.TYPES);\n-        si.setLabel(resources.getText(\"doclet.All_Classes\"));\n-        si.setUrl(DocPaths.ALLCLASSES_INDEX.getPath());\n-        searchItems.add(si);\n-        createSearchIndexFile(DocPaths.TYPE_SEARCH_INDEX_JS,\n-                              searchItems.itemsOfCategories(Category.TYPES),\n-                              \"typeSearchIndex\");\n-        createSearchIndexFile(DocPaths.MEMBER_SEARCH_INDEX_JS,\n-                              searchItems.itemsOfCategories(Category.MEMBERS),\n-                              \"memberSearchIndex\");\n-        createSearchIndexFile(DocPaths.TAG_SEARCH_INDEX_JS,\n-                              searchItems.itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY),\n-                              \"tagSearchIndex\");\n-    }\n-\n-    \/**\n-     * Creates a search index file.\n-     *\n-     * @param searchIndexJS     the file for the JavaScript to be generated\n-     * @param searchIndex       the search index items\n-     * @param varName           the variable name to write in the JavaScript file\n-     * @throws DocFileIOException if there is a problem creating the search index file\n-     *\/\n-    protected void createSearchIndexFile(DocPath searchIndexJS,\n-                                         Stream<SearchIndexItem> searchIndex,\n-                                         String varName)\n-            throws DocFileIOException\n-    {\n-        \/\/ The file needs to be created even if there are no searchIndex items\n-        \/\/ File could be written straight-through, without an intermediate StringBuilder\n-        Iterator<SearchIndexItem> index = searchIndex.iterator();\n-        StringBuilder searchVar = new StringBuilder(\"[\");\n-        boolean first = true;\n-        while (index.hasNext()) {\n-            SearchIndexItem item = index.next();\n-            if (first) {\n-                searchVar.append(item.toString());\n-                first = false;\n-            } else {\n-                searchVar.append(\",\").append(item.toString());\n-            }\n-        }\n-        searchVar.append(\"];\");\n-        DocFile jsFile = DocFile.createFileForOutput(configuration, searchIndexJS);\n-        try (Writer wr = jsFile.openWriter()) {\n-            wr.write(varName);\n-            wr.write(\" = \");\n-            wr.write(searchVar.toString());\n-            wr.write(\"updateSearchResults();\");\n-        } catch (IOException ie) {\n-            throw new DocFileIOException(jsFile, DocFileIOException.Mode.WRITE, ie);\n-        }\n-    }\n-\n-    private static Map<Character, List<SearchIndexItem>> buildSearchTagIndex(\n-            Stream<? extends SearchIndexItem> searchItems)\n-    {\n-        return searchItems.collect(Collectors.groupingBy(i -> keyCharacter(i.getLabel())));\n-    }\n-\n-    protected static Character keyCharacter(String s) {\n-        return s.isEmpty() ? '*' : Character.toUpperCase(s.charAt(0));\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AbstractIndexWriter.java","additions":46,"deletions":169,"binary":false,"changes":215,"status":"modified"},{"patch":"@@ -136,2 +136,2 @@\n-        for (Character unicode : indexBuilder.keys()) {\n-            for (IndexItem indexItem : indexBuilder.getMemberList(unicode)) {\n+        for (Character unicode : indexBuilder.getFirstCharacters()) {\n+            for (IndexItem indexItem : indexBuilder.getItems(unicode)) {\n@@ -139,2 +139,2 @@\n-                if (typeElement == null || !utils.isCoreClass(typeElement)) {\n-                    continue;\n+                if (typeElement != null && utils.isCoreClass(typeElement)) {\n+                    addTableRow(table, typeElement);\n@@ -142,1 +142,0 @@\n-                addTableRow(table, typeElement);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/AllClassesIndexWriter.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-                .setId(links.getName(writer.getAnchor(constructor)));\n+                .setId(links.getAnchor(constructor));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ConstructorWriterImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;\n@@ -96,1 +97,10 @@\n-    protected SearchIndexItems searchItems;\n+    \/**\n+     * The collections of items for the main index.\n+     * This field is only initialized if {@code options.createIndex()}\n+     * is {@code true}.\n+     * This index is populated somewhat lazily:\n+     * 1. items found in doc comments are found while generating declaration pages\n+     * 2. items for elements are added in bulk before generating the index files\n+     * 3. additional items are added as needed\n+     *\/\n+    protected HtmlIndexBuilder mainIndex;\n@@ -204,0 +214,3 @@\n+        if (options.createIndex()) {\n+            mainIndex = new HtmlIndexBuilder(this);\n+        }\n@@ -355,6 +368,0 @@\n-\n-    @Override\n-    protected void initConfiguration(DocletEnvironment docEnv) {\n-        super.initConfiguration(docEnv);\n-        searchItems = new SearchIndexItems(utils);\n-    }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlConfiguration.java","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -172,1 +172,2 @@\n-            IndexBuilder indexBuilder = new IndexBuilder(configuration, nodeprecated);\n+            SystemPropertiesWriter.generate(configuration);\n+            configuration.mainIndex.addElements();\n@@ -174,1 +175,1 @@\n-                SplitIndexWriter.generate(configuration, indexBuilder);\n+                SplitIndexWriter.generate(configuration);\n@@ -176,1 +177,1 @@\n-                SingleIndexWriter.generate(configuration, indexBuilder);\n+                SingleIndexWriter.generate(configuration);\n@@ -178,2 +179,3 @@\n-            AllClassesIndexWriter.generate(configuration,\n-                    new IndexBuilder(configuration, nodeprecated, true));\n+            IndexBuilder allClassesIndex = new IndexBuilder(configuration, nodeprecated, true);\n+            allClassesIndex.addElements();\n+            AllClassesIndexWriter.generate(configuration, allClassesIndex);\n@@ -183,1 +185,1 @@\n-            SystemPropertiesWriter.generate(configuration);\n+            configuration.mainIndex.createSearchIndexFiles();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDoclet.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -158,2 +158,0 @@\n-    protected final SearchIndexItems searchItems;\n-\n@@ -219,1 +217,0 @@\n-        this.searchItems = configuration.searchItems;\n@@ -224,1 +221,1 @@\n-        this.links = new Links(path);\n+        this.links = new Links(path, configuration.utils);\n@@ -958,1 +955,1 @@\n-                .where(links.getName(getAnchor(ee, isProperty)))\n+                .where(links.getAnchor(ee, isProperty))\n@@ -991,1 +988,1 @@\n-                .where(links.getName(getAnchor(emd))));\n+                .where(links.getAnchor(emd)));\n@@ -1000,21 +997,0 @@\n-    public String getAnchor(ExecutableElement executableElement) {\n-        return getAnchor(executableElement, false);\n-    }\n-\n-    public String getAnchor(ExecutableElement executableElement, boolean isProperty) {\n-        if (isProperty) {\n-            return executableElement.getSimpleName().toString();\n-        }\n-        String member = anchorName(executableElement);\n-        String erasedSignature = utils.makeSignature(executableElement, null, true, true);\n-        return member + erasedSignature;\n-    }\n-\n-    public String anchorName(Element member) {\n-        if (member.getKind() == ElementKind.CONSTRUCTOR) {\n-            return \"<init>\";\n-        } else {\n-            return utils.getSimpleName(member);\n-        }\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":3,"deletions":27,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,241 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.javadoc.internal.doclets.formats.html;\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.SortedSet;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.ExecutableElement;\n+import javax.lang.model.element.TypeElement;\n+\n+import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;\n+import jdk.javadoc.internal.doclets.formats.html.markup.Links;\n+import jdk.javadoc.internal.doclets.toolkit.Resources;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFile;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n+import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexBuilder;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n+\n+\/**\n+ * Extensions to {@code IndexBuilder} to fill in remaining fields\n+ * in index items: {@code containingModule}, {@code containingPackage},\n+ * {@code containingClass}, and {@code url}, and to write out the\n+ * JavaScript files.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public class HtmlIndexBuilder extends IndexBuilder {\n+    private final HtmlConfiguration configuration;\n+\n+    private final Links links;\n+    private final Resources resources;\n+    private final Utils utils;\n+\n+    \/**\n+     * Creates a new {@code HtmlIndexBuilder}.\n+     *\n+     * @param configuration the current configuration of the doclet\n+     *\/\n+    HtmlIndexBuilder(HtmlConfiguration configuration) {\n+        super(configuration, configuration.getOptions().noDeprecated());\n+        this.configuration = configuration;\n+        links = new Links(DocPath.empty, configuration.utils);\n+        resources = configuration.docResources;\n+        utils = configuration.utils;\n+    }\n+\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * After the initial work to add the element items, the remaining fields in\n+     * the items are also initialized.\n+     *\/\n+    public void addElements() {\n+        super.addElements();\n+        if (classesOnly) {\n+            return;\n+        }\n+\n+\n+        Map<String,Integer> duplicateLabelCheck = new HashMap<>();\n+        for (Character ch : getFirstCharacters()) {\n+            for (IndexItem item : getItems(ch)) {\n+                duplicateLabelCheck.compute(item.getFullyQualifiedLabel(utils),\n+                                            (k, v) -> v == null ? 1 : v + 1);\n+            }\n+        }\n+\n+        for (Character ch : getFirstCharacters()) {\n+            for (IndexItem item : getItems(ch)) {\n+                if (item.isElementItem()) {\n+                    boolean addModuleInfo =\n+                            duplicateLabelCheck.get(item.getFullyQualifiedLabel(utils)) > 1;\n+                    addContainingInfo(item, addModuleInfo);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void addContainingInfo(IndexItem item, boolean addModuleInfo) {\n+        Element element = item.getElement();\n+        switch (element.getKind()) {\n+            case MODULE:\n+                break;\n+\n+            case PACKAGE:\n+                if (configuration.showModules) {\n+                    item.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n+                }\n+                break;\n+\n+            case CLASS:\n+            case ENUM:\n+            case RECORD:\n+            case ANNOTATION_TYPE:\n+            case INTERFACE:\n+                item.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));\n+                if (configuration.showModules && addModuleInfo) {\n+                    item.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n+                }\n+                break;\n+\n+            case CONSTRUCTOR:\n+            case METHOD:\n+            case FIELD:\n+            case ENUM_CONSTANT:\n+                TypeElement containingType = item.getContainingTypeElement();\n+                item.setContainingPackage(utils.getPackageName(utils.containingPackage(element)));\n+                item.setContainingClass(utils.getSimpleName(containingType));\n+                if (configuration.showModules && addModuleInfo) {\n+                    item.setContainingModule(utils.getFullyQualifiedName(utils.containingModule(element)));\n+                }\n+                if (utils.isExecutableElement(element)) {\n+                    String url = HtmlTree.encodeURL(links.getAnchor((ExecutableElement) element));\n+                    if (!url.equals(item.getLabel())) {\n+                        item.setUrl(url);\n+                    }\n+                }\n+                break;\n+\n+            default:\n+                throw new Error();\n+        }\n+    }\n+\n+\n+    \/**\n+     * Generates the set of index files used by interactive search.\n+     *\n+     * @throws DocFileIOException if there is a problem creating any of the search index files\n+     *\/\n+    public void createSearchIndexFiles() throws DocFileIOException {\n+        \/\/ add last-minute items\n+        if (!configuration.packages.isEmpty()) {\n+            IndexItem item = IndexItem.of(IndexItem.Category.PACKAGES,\n+                    resources.getText(\"doclet.All_Packages\"),\n+                    DocPaths.ALLPACKAGES_INDEX);\n+            add(item);\n+        }\n+        IndexItem item = IndexItem.of(IndexItem.Category.TYPES,\n+                resources.getText(\"doclet.All_Classes\"),\n+                DocPaths.ALLCLASSES_INDEX);\n+        add(item);\n+\n+        for (IndexItem.Category category : IndexItem.Category.values()) {\n+            DocPath file;\n+            String varName;\n+            switch (category) {\n+                case MODULES -> {\n+                    file = DocPaths.MODULE_SEARCH_INDEX_JS;\n+                    varName = \"moduleSearchIndex\";\n+                }\n+                case PACKAGES -> {\n+                    file = DocPaths.PACKAGE_SEARCH_INDEX_JS;\n+                    varName = \"packageSearchIndex\";\n+                }\n+                case TYPES -> {\n+                    file = DocPaths.TYPE_SEARCH_INDEX_JS;\n+                    varName = \"typeSearchIndex\";\n+                }\n+                case MEMBERS -> {\n+                    file = DocPaths.MEMBER_SEARCH_INDEX_JS;\n+                    varName = \"memberSearchIndex\";\n+                }\n+                case TAGS -> {\n+                    file = DocPaths.TAG_SEARCH_INDEX_JS;\n+                    varName = \"tagSearchIndex\";\n+                }\n+                default -> throw new Error();\n+            }\n+\n+            createSearchIndexFile(file, getItems(category), varName);\n+        }\n+    }\n+\n+    \/**\n+     * Creates a search index file.\n+     *\n+     * @param searchIndexJS the file for the JavaScript to be generated\n+     * @param indexItems    the search index items\n+     * @param varName       the variable name to write in the JavaScript file\n+     *\n+     * @throws DocFileIOException if there is a problem creating the search index file\n+     *\/\n+    private void createSearchIndexFile(DocPath searchIndexJS,\n+                                         SortedSet<IndexItem> indexItems,\n+                                         String varName)\n+            throws DocFileIOException\n+    {\n+        \/\/ The file needs to be created even if there are no searchIndex items\n+        DocFile jsFile = DocFile.createFileForOutput(configuration, searchIndexJS);\n+        try (Writer wr = jsFile.openWriter()) {\n+            wr.write(varName);\n+            wr.write(\" = [\");\n+            boolean first = true;\n+            for (IndexItem item : indexItems) {\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    wr.write(\",\");\n+                }\n+                wr.write(item.toJSON());\n+            }\n+            wr.write(\"];\");\n+            wr.write(\"updateSearchResults();\");\n+        } catch (IOException ie) {\n+            throw new DocFileIOException(jsFile, DocFileIOException.Mode.WRITE, ie);\n+        }\n+    }\n+}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIndexBuilder.java","additions":241,"deletions":0,"binary":false,"changes":241,"status":"added"},{"patch":"@@ -114,1 +114,1 @@\n-                .setId(links.getName(writer.getAnchor(method)));\n+                .setId(links.getAnchor(method));\n@@ -287,1 +287,1 @@\n-                            .where(writer.links.getName(writer.getAnchor(method)))\n+                            .where(writer.links.getAnchor(method))\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/MethodWriterImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,1 +145,1 @@\n-        this.links = new Links(path);\n+        this.links = new Links(path, configuration.utils);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/Navigation.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import javax.lang.model.element.Element;\n-\n-\/**\n- * Index item for search.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public class SearchIndexItem {\n-\n-    enum Category {\n-        MODULES,\n-        PACKAGES,\n-        TYPES,\n-        MEMBERS,\n-        \/**\n-         * The category of items corresponding to {@code {@index}} tags.\n-         *\/\n-        INDEX,\n-        \/**\n-         * The category of items corresponding to {@code {@systemProperty}} tags.\n-         *\/\n-        SYSTEM_PROPERTY\n-    }\n-\n-    private Category category;\n-    private String label = \"\";\n-    private String url = \"\";\n-    private String containingModule = \"\";\n-    private String containingPackage = \"\";\n-    private String containingClass = \"\";\n-    private String holder = \"\";\n-    private String description = \"\";\n-    private Element element;\n-\n-    public void setLabel(String l) {\n-        label = l;\n-    }\n-\n-    public String getLabel() {\n-        return label;\n-    }\n-\n-    public void setUrl(String u) {\n-        url = u;\n-    }\n-\n-    public String getUrl() {\n-        return url;\n-    }\n-\n-    public void setContainingModule(String m) {\n-        containingModule = m;\n-    }\n-\n-    public void setContainingPackage(String p) {\n-        containingPackage = p;\n-    }\n-\n-    public void setContainingClass(String c) {\n-        containingClass = c;\n-    }\n-\n-    public void setCategory(Category c) {\n-        category = c;\n-    }\n-\n-    public void setHolder(String h) {\n-        holder = h;\n-    }\n-\n-    public String getHolder() {\n-        return holder;\n-    }\n-\n-    public void setDescription(String d) {\n-        description = d;\n-    }\n-\n-    public String getDescription() {\n-        return description;\n-    }\n-\n-    protected Category getCategory() {\n-        return category;\n-    }\n-\n-    public void setElement(Element element) {\n-        this.element = element;\n-    }\n-\n-    public Element getElement() {\n-        return element;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        \/\/ TODO: Additional processing is required, see JDK-8238495\n-        StringBuilder item = new StringBuilder();\n-        switch (category) {\n-            case MODULES:\n-                item.append(\"{\")\n-                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\")\n-                        .append(\"}\");\n-                break;\n-            case PACKAGES:\n-                item.append(\"{\");\n-                if (!containingModule.isEmpty()) {\n-                    item.append(\"\\\"m\\\":\\\"\").append(containingModule).append(\"\\\",\");\n-                }\n-                item.append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\");\n-                if (!url.isEmpty()) {\n-                    item.append(\",\\\"u\\\":\\\"\").append(url).append(\"\\\"\");\n-                }\n-                item.append(\"}\");\n-                break;\n-            case TYPES:\n-                item.append(\"{\");\n-                if (!containingPackage.isEmpty()) {\n-                    item.append(\"\\\"p\\\":\\\"\").append(containingPackage).append(\"\\\",\");\n-                }\n-                if (!containingModule.isEmpty()) {\n-                    item.append(\"\\\"m\\\":\\\"\").append(containingModule).append(\"\\\",\");\n-                }\n-                item.append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\");\n-                if (!url.isEmpty()) {\n-                    item.append(\",\\\"u\\\":\\\"\").append(url).append(\"\\\"\");\n-                }\n-                item.append(\"}\");\n-                break;\n-            case MEMBERS:\n-                item.append(\"{\");\n-                if (!containingModule.isEmpty()) {\n-                    item.append(\"\\\"m\\\":\\\"\").append(containingModule).append(\"\\\",\");\n-                }\n-                item.append(\"\\\"p\\\":\\\"\").append(containingPackage).append(\"\\\",\")\n-                        .append(\"\\\"c\\\":\\\"\").append(containingClass).append(\"\\\",\")\n-                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\");\n-                if (!url.isEmpty()) {\n-                    item.append(\",\\\"u\\\":\\\"\").append(url).append(\"\\\"\");\n-                }\n-                item.append(\"}\");\n-                break;\n-            case INDEX:\n-            case SYSTEM_PROPERTY:\n-                item.append(\"{\")\n-                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\",\")\n-                        .append(\"\\\"h\\\":\\\"\").append(holder).append(\"\\\",\");\n-                if (!description.isEmpty()) {\n-                    item.append(\"\\\"d\\\":\\\"\").append(description).append(\"\\\",\");\n-                }\n-                item.append(\"\\\"u\\\":\\\"\").append(url).append(\"\\\"\")\n-                        .append(\"}\");\n-                break;\n-            default:\n-                throw new AssertionError(\"Unexpected category: \" + category);\n-        }\n-        return item.toString();\n-    }\n-\n-    \/**\n-     * Get the part of the label after the last dot, or whole label if no dots.\n-     *\n-     * @return the simple name\n-     *\/\n-    public String getSimpleName() {\n-        return label.substring(label.lastIndexOf('.') + 1);\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SearchIndexItem.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.javadoc.internal.doclets.formats.html;\n-\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;\n-import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n-\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import java.util.stream.Stream;\n-\n-\/**\n- * A container for organizing {@linkplain SearchIndexItem search items}\n- * by {@linkplain Category category}.\n- *\n- *  <p><b>This is NOT part of any supported API.\n- *  If you write code that depends on this, you do so at your own risk.\n- *  This code and its internal interfaces are subject to change or\n- *  deletion without notice.<\/b>\n- *\/\n-public final class SearchIndexItems {\n-\n-    private final Map<Category, Set<SearchIndexItem>> items = new HashMap<>();\n-    private final Utils utils;\n-\n-    public SearchIndexItems(Utils utils) {\n-        this.utils = Objects.requireNonNull(utils);\n-    }\n-\n-    \/**\n-     * Adds the specified item to this container.\n-     *\n-     * @param item\n-     *         the item to add\n-     *\/\n-    public void add(SearchIndexItem item) {\n-        Objects.requireNonNull(item);\n-        items.computeIfAbsent(item.getCategory(), this::newSetForCategory)\n-                .add(item);\n-    }\n-\n-    private Set<SearchIndexItem> newSetForCategory(Category category) {\n-        final Comparator<SearchIndexItem> cmp;\n-        if (category == Category.TYPES) {\n-            cmp = utils.comparators.makeTypeSearchIndexComparator();\n-        } else {\n-            cmp = utils.comparators.makeGenericSearchIndexComparator();\n-        }\n-        return new TreeSet<>(cmp);\n-    }\n-\n-    \/**\n-     * Checks if there are items of any of the specified categories\n-     * in this container.\n-     *\n-     * <p> Iff there exists an item {@code i} for which there is a category\n-     * {@code c} from the specified categories such that\n-     * {@code i.getCategory().equals(c)}, then {@code true} is returned.\n-     *\n-     * @param firstCategory\n-     *         the first category\n-     * @param otherCategories\n-     *         other categories (optional)\n-     *\n-     * @return {@code true} if there are items of any of the specified categories,\n-     *         {@code false} otherwise\n-     *\n-     * @throws NullPointerException\n-     *         if there are {@code null} categories\n-     *\/\n-    public boolean containsAnyOfCategories(Category firstCategory,\n-                                           Category... otherCategories)\n-    {\n-        return itemsOfCategories(firstCategory, otherCategories)\n-                .findAny()\n-                .isPresent();\n-    }\n-\n-    \/**\n-     * Returns a stream of items of any of the specified categories\n-     * from this container.\n-     *\n-     * <p> The returned stream consists of all items {@code i} for which there\n-     * is a category {@code c} from the specified categories such that\n-     * {@code i.getCategory().equals(c)}. The stream may be empty.\n-     *\n-     * @param firstCategory\n-     *         the first category\n-     * @param otherCategories\n-     *         other categories (optional)\n-     *\n-     * @return a stream of items of the specified categories\n-     *\n-     * @throws NullPointerException\n-     *         if there are {@code null} categories\n-     *\/\n-    public Stream<SearchIndexItem> itemsOfCategories(Category firstCategory,\n-                                                     Category... otherCategories)\n-    {\n-        return concatenatedStreamOf(firstCategory, otherCategories)\n-                .distinct()\n-                .flatMap(this::itemsOf);\n-    }\n-\n-    private Stream<SearchIndexItem> itemsOf(Category cat) {\n-        Objects.requireNonNull(cat);\n-        return items.getOrDefault(cat, Set.of()).stream();\n-    }\n-\n-    \/**\n-     * Returns a concatenated stream of elements.\n-     *\n-     * <p> The elements of the returned stream are encountered in the following order:\n-     * {@code first, remaining[0], remaining[1], ..., remaining[remaining.length - 1]}.\n-     *\n-     * @param first\n-     *         the first element\n-     * @param remaining\n-     *         the remaining elements, if any\n-     * @param <T>\n-     *         the type of elements\n-     *\n-     * @return the stream of elements\n-     *\n-     * @throws NullPointerException\n-     *         if {@code remaining} is {@code null}\n-     *\/\n-    private static <T> Stream<T> concatenatedStreamOf(T first, T[] remaining) {\n-        return Stream.concat(Stream.of(first), Stream.of(remaining));\n-    }\n-}\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SearchIndexItems.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -31,1 +31,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;\n+import com.sun.source.doctree.DocTree;\n@@ -41,1 +41,0 @@\n-import jdk.javadoc.internal.doclets.toolkit.util.DocPath;\n@@ -44,0 +43,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem.Category;\n@@ -60,1 +60,1 @@\n-    private Set<Character> elements;\n+    private Set<Character> firstCharacters;\n@@ -67,2 +67,0 @@\n-     * @param filename     Name of the index file to be generated.\n-     * @param indexBuilder Unicode based Index from {@link IndexBuilder}\n@@ -70,4 +68,2 @@\n-    public SingleIndexWriter(HtmlConfiguration configuration,\n-                             DocPath filename,\n-                             IndexBuilder indexBuilder) {\n-        super(configuration, filename, indexBuilder);\n+    public SingleIndexWriter(HtmlConfiguration configuration) {\n+        super(configuration, DocPaths.INDEX_ALL);\n@@ -80,1 +76,0 @@\n-     * @param indexBuilder IndexBuilder built by {@link IndexBuilder}\n@@ -83,5 +78,2 @@\n-    public static void generate(HtmlConfiguration configuration,\n-                                IndexBuilder indexBuilder) throws DocFileIOException {\n-        DocPath filename = DocPaths.INDEX_ALL;\n-        SingleIndexWriter indexgen = new SingleIndexWriter(configuration,\n-                                         filename, indexBuilder);\n+    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n+        SingleIndexWriter indexgen = new SingleIndexWriter(configuration);\n@@ -104,2 +96,1 @@\n-        elements = new TreeSet<>(indexBuilder.asMap().keySet());\n-        elements.addAll(tagSearchIndexMap.keySet());\n+        firstCharacters = new TreeSet<>(mainIndex.getFirstCharacters());\n@@ -107,5 +98,2 @@\n-        for (Character unicode : elements) {\n-            if (tagSearchIndexMap.get(unicode) != null) {\n-                indexBuilder.addSearchTags(unicode, tagSearchIndexMap.get(unicode));\n-            }\n-            addContents(unicode, indexBuilder.getMemberList(unicode), mainContent);\n+        for (Character ch : firstCharacters) {\n+            addContents(ch, mainIndex.getItems(ch), mainContent);\n@@ -125,1 +113,0 @@\n-        createSearchIndexFiles();\n@@ -135,1 +122,1 @@\n-        for (Character ch : elements) {\n+        for (Character ch : firstCharacters) {\n@@ -150,1 +137,2 @@\n-        if (searchItems.containsAnyOfCategories(Category.SYSTEM_PROPERTY)) {\n+        boolean anySystemProperties = !mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).isEmpty();\n+        if (anySystemProperties) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SingleIndexWriter.java","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.util.Set;\n@@ -35,1 +34,0 @@\n-import java.util.stream.Collectors;\n@@ -37,1 +35,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;\n+import com.sun.source.doctree.DocTree;\n@@ -50,0 +48,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem.Category;\n@@ -73,1 +72,0 @@\n-     * @param indexBuilder Unicode based Index from {@link IndexBuilder}\n@@ -78,1 +76,0 @@\n-                            IndexBuilder indexBuilder,\n@@ -80,1 +77,1 @@\n-        super(configuration, path, indexBuilder);\n+        super(configuration, path);\n@@ -89,1 +86,0 @@\n-     * @param indexBuilder IndexBuilder built by {@link IndexBuilder}\n@@ -92,3 +88,1 @@\n-    public static void generate(HtmlConfiguration configuration,\n-                                IndexBuilder indexBuilder) throws DocFileIOException\n-    {\n+    public static void generate(HtmlConfiguration configuration) throws DocFileIOException {\n@@ -96,6 +90,2 @@\n-        SortedSet<Character> keys = new TreeSet<>(indexBuilder.asMap().keySet());\n-        Set<Character> searchItemsKeys = configuration.searchItems\n-                .itemsOfCategories(Category.INDEX, Category.SYSTEM_PROPERTY)\n-                .map(i -> keyCharacter(i.getLabel()))\n-                .collect(Collectors.toSet());\n-        keys.addAll(searchItemsKeys);\n+        IndexBuilder mainIndex = configuration.mainIndex;\n+        SortedSet<Character> keys = new TreeSet<>(mainIndex.getFirstCharacters());\n@@ -107,2 +97,1 @@\n-                                                             path.resolve(filename),\n-                                                             indexBuilder, keys);\n+                                                             path.resolve(filename), keys);\n@@ -110,3 +99,0 @@\n-            if (!li.hasNext()) {\n-                indexgen.createSearchIndexFiles();\n-            }\n@@ -138,4 +124,1 @@\n-        if (tagSearchIndexMap.get(unicode) != null) {\n-            indexBuilder.addSearchTags(unicode, tagSearchIndexMap.get(unicode));\n-        }\n-        addContents(unicode, indexBuilder.getMemberList(unicode), mainContent);\n+        addContents(unicode, mainIndex.getItems(unicode), mainContent);\n@@ -176,1 +159,2 @@\n-        if (searchItems.containsAnyOfCategories(Category.SYSTEM_PROPERTY)) {\n+        boolean anySystemProperties = !mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).isEmpty();\n+        if (anySystemProperties) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SplitIndexWriter.java","additions":10,"deletions":26,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;\n+import com.sun.source.doctree.DocTree;\n@@ -43,0 +43,2 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem.Category;\n@@ -88,2 +90,2 @@\n-        boolean hasSystemProperties = configuration.searchItems\n-                .containsAnyOfCategories(Category.SYSTEM_PROPERTY);\n+        boolean hasSystemProperties = configuration.mainIndex != null\n+                && !configuration.mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).isEmpty();\n@@ -135,1 +137,1 @@\n-        Map<String, List<SearchIndexItem>> searchIndexMap = groupSystemProperties();\n+        Map<String, List<IndexItem>> searchIndexMap = groupSystemProperties();\n@@ -141,1 +143,1 @@\n-        for (Entry<String, List<SearchIndexItem>> entry : searchIndexMap.entrySet()) {\n+        for (Entry<String, List<IndexItem>> entry : searchIndexMap.entrySet()) {\n@@ -143,1 +145,1 @@\n-            List<SearchIndexItem> searchIndexItems = entry.getValue();\n+            List<IndexItem> searchIndexItems = entry.getValue();\n@@ -155,4 +157,3 @@\n-    private Map<String, List<SearchIndexItem>> groupSystemProperties() {\n-        return searchItems\n-                .itemsOfCategories(Category.SYSTEM_PROPERTY)\n-                .collect(groupingBy(SearchIndexItem::getLabel, TreeMap::new, toList()));\n+    private Map<String, List<IndexItem>> groupSystemProperties() {\n+        return configuration.mainIndex.getItems(DocTree.Kind.SYSTEM_PROPERTY).stream()\n+                .collect(groupingBy(IndexItem::getLabel, TreeMap::new, toList()));\n@@ -161,8 +162,8 @@\n-    private Content createLink(SearchIndexItem i) {\n-        assert i.getCategory() == Category.SYSTEM_PROPERTY : i;\n-        if (i.getElement() != null) {\n-            if (i.getElement() instanceof OverviewElement) {\n-                return links.createLink(pathToRoot.resolve(i.getUrl()),\n-                                        resources.getText(\"doclet.Overview\"));\n-            }\n-            DocletElement e = ((DocletElement) i.getElement());\n+    private Content createLink(IndexItem i) {\n+        assert i.getDocTree().getKind() == DocTree.Kind.SYSTEM_PROPERTY : i;\n+        Element element = i.getElement();\n+        if (element instanceof OverviewElement) {\n+            return links.createLink(pathToRoot.resolve(i.getUrl()),\n+                    resources.getText(\"doclet.Overview\"));\n+        } else if (element instanceof DocletElement) {\n+            DocletElement e = (DocletElement) element;\n@@ -172,1 +173,1 @@\n-            String t = titles.computeIfAbsent(i.getElement(), utils::getHTMLTitle);\n+            String t = titles.computeIfAbsent(element, utils::getHTMLTitle);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/SystemPropertiesWriter.java","additions":20,"deletions":19,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem.Category;\n@@ -62,0 +61,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.IndexItem;\n@@ -114,1 +114,1 @@\n-        IndexTree itt = (IndexTree)tag;\n+        IndexTree itt = (IndexTree) tag;\n@@ -123,1 +123,1 @@\n-        return createAnchorAndSearchIndex(element, tagText, desc, false);\n+        return createAnchorAndSearchIndex(element, tagText, desc, tag);\n@@ -286,1 +286,1 @@\n-                resources.getText(\"doclet.System_Property\"), true));\n+                resources.getText(\"doclet.System_Property\"), tag));\n@@ -369,1 +369,1 @@\n-    private Content createAnchorAndSearchIndex(Element element, String tagText, String desc, boolean isSystemProperty) {\n+    private Content createAnchorAndSearchIndex(Element element, String tagText, String desc, DocTree tree) {\n@@ -382,5 +382,1 @@\n-                SearchIndexItem si = new SearchIndexItem();\n-                si.setLabel(tagText);\n-                si.setDescription(desc);\n-                si.setUrl(htmlWriter.path.getPath() + \"#\" + anchorName);\n-                new SimpleElementVisitor14<Void, Void>() {\n+                String holder = new SimpleElementVisitor14<String, Void>() {\n@@ -389,4 +385,3 @@\n-                    public Void visitModule(ModuleElement e, Void p) {\n-                        si.setHolder(resources.getText(\"doclet.module\")\n-                                             + \" \" + utils.getFullyQualifiedName(e));\n-                        return null;\n+                    public String visitModule(ModuleElement e, Void p) {\n+                        return resources.getText(\"doclet.module\")\n+                                + \" \" + utils.getFullyQualifiedName(e);\n@@ -396,4 +391,3 @@\n-                    public Void visitPackage(PackageElement e, Void p) {\n-                        si.setHolder(resources.getText(\"doclet.package\")\n-                                             + \" \" + utils.getFullyQualifiedName(e));\n-                        return null;\n+                    public String visitPackage(PackageElement e, Void p) {\n+                        return resources.getText(\"doclet.package\")\n+                                + \" \" + utils.getFullyQualifiedName(e);\n@@ -403,4 +397,3 @@\n-                    public Void visitType(TypeElement e, Void p) {\n-                        si.setHolder(utils.getTypeElementName(e, true)\n-                                             + \" \" + utils.getFullyQualifiedName(e));\n-                        return null;\n+                    public String visitType(TypeElement e, Void p) {\n+                        return utils.getTypeElementName(e, true)\n+                                + \" \" + utils.getFullyQualifiedName(e);\n@@ -410,5 +403,4 @@\n-                    public Void visitExecutable(ExecutableElement e, Void p) {\n-                        si.setHolder(utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n-                                             + \".\" + utils.getSimpleName(e)\n-                                             + utils.flatSignature(e, htmlWriter.getCurrentPageElement()));\n-                        return null;\n+                    public String visitExecutable(ExecutableElement e, Void p) {\n+                        return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                                + \".\" + utils.getSimpleName(e)\n+                                + utils.flatSignature(e, htmlWriter.getCurrentPageElement());\n@@ -418,4 +410,3 @@\n-                    public Void visitVariable(VariableElement e, Void p) {\n-                        TypeElement te = utils.getEnclosingTypeElement(e);\n-                        si.setHolder(utils.getFullyQualifiedName(te) + \".\" + utils.getSimpleName(e));\n-                        return null;\n+                    public String visitVariable(VariableElement e, Void p) {\n+                        return utils.getFullyQualifiedName(utils.getEnclosingTypeElement(e))\n+                                + \".\" + utils.getSimpleName(e);\n@@ -425,1 +416,1 @@\n-                    public Void visitUnknown(Element e, Void p) {\n+                    public String visitUnknown(Element e, Void p) {\n@@ -428,12 +419,4 @@\n-                            si.setElement(de);\n-                            switch (de.getSubKind()) {\n-                                case OVERVIEW:\n-                                    si.setHolder(resources.getText(\"doclet.Overview\"));\n-                                    break;\n-                                case DOCFILE:\n-                                    si.setHolder(getHolderName(de));\n-                                    break;\n-                                default:\n-                                    throw new IllegalStateException();\n-                            }\n-                            return null;\n+                            return switch (de.getSubKind()) {\n+                                case OVERVIEW -> resources.getText(\"doclet.Overview\");\n+                                case DOCFILE -> getHolderName(de);\n+                            };\n@@ -446,3 +429,2 @@\n-                    protected Void defaultAction(Element e, Void p) {\n-                        si.setHolder(utils.getFullyQualifiedName(e));\n-                        return null;\n+                    protected String defaultAction(Element e, Void p) {\n+                        return utils.getFullyQualifiedName(e);\n@@ -451,2 +433,3 @@\n-                si.setCategory(isSystemProperty ? Category.SYSTEM_PROPERTY : Category.INDEX);\n-                configuration.searchItems.add(si);\n+                IndexItem item = IndexItem.of(element, tree, tagText, holder, desc,\n+                        new DocLink(htmlWriter.path, anchorName));\n+                configuration.mainIndex.add(item);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/TagletWriterImpl.java","additions":32,"deletions":49,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import javax.lang.model.element.ExecutableElement;\n+\n@@ -32,0 +34,1 @@\n+import jdk.javadoc.internal.doclets.toolkit.util.Utils;\n@@ -50,0 +53,1 @@\n+    private final Utils utils;\n@@ -59,1 +63,1 @@\n-    public Links(DocPath file) {\n+    public Links(DocPath file, Utils utils) {\n@@ -61,0 +65,1 @@\n+        this.utils = utils;\n@@ -263,2 +268,28 @@\n-     * Converts a name to a valid HTML name (id).\n-     * This depends on the HTML version specified when the {@code Links} object was created.\n+     * Returns the HTML id to use for an executable element.\n+     *\n+     * @param executableElement the element\n+     *\n+     * @return the id\n+     *\/\n+    public String getAnchor(ExecutableElement executableElement) {\n+        return getAnchor(executableElement, false);\n+    }\n+\n+    \/**\n+     * Returns the HTML id to use for an executable element.\n+     *\n+     * @param executableElement the element\n+     * @param isProperty whether or not the element represents a property\n+     *\n+     * @return the id\n+     *\/\n+    public String getAnchor(ExecutableElement executableElement, boolean isProperty) {\n+        String a = isProperty\n+                ? executableElement.getSimpleName().toString()\n+                : executableElement.getSimpleName()\n+                    + utils.makeSignature(executableElement, null, true, true);\n+        return getName(a);\n+    }\n+\n+    \/**\n+     * Converts a name to a valid HTML id.\n@@ -266,1 +297,1 @@\n-     * @param name the string that needs to be converted to a valid HTML name\n+     * @param name the string that needs to be converted to a valid HTML id\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/markup\/Links.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -410,4 +410,2 @@\n-        if (!finishOptionSettings0() || !finishOptionSettings())\n-            return false;\n-\n-        return true;\n+        return finishOptionSettings0()\n+                && finishOptionSettings();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/BaseConfiguration.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;\n@@ -282,33 +281,0 @@\n-    \/**\n-     * Returns a comparator for the {@code IndexItem}s in the index page. This is a composite\n-     * comparator that must be able to compare all kinds {@code Element}s as well as\n-     * {@code SearchIndexItem}s.\n-     *\n-     * @return a comparator for index page items.\n-     *\/\n-    public Comparator<IndexItem> makeIndexComparator(boolean classesOnly) {\n-        Comparator<Element> elementComparator = classesOnly\n-                ? makeAllClassesComparator()\n-                : makeIndexElementComparator();\n-        Comparator<SearchIndexItem> searchTagComparator =\n-                makeGenericSearchIndexComparator();\n-\n-        return (o1, o2) -> {\n-            \/\/ Compare two elements\n-            if (o1.getElement() != null && o2.getElement() != null) {\n-                return elementComparator.compare(o1.getElement(), o2.getElement());\n-            }\n-            \/\/ Compare two search tags\n-            if (o1.getSearchTag() != null && o2.getSearchTag() != null) {\n-                return searchTagComparator.compare(o1.getSearchTag(), o2.getSearchTag());\n-            }\n-            \/\/ Compare an element with a search tag.\n-            \/\/ Compares labels, if those are equal put the search tag first.\n-            int d = utils.compareStrings(o1.getLabel(), o2.getLabel());\n-            if (d == 0) {\n-                d = o1.getElement() == null ? 1 : -1;\n-            }\n-            return d;\n-        };\n-    }\n-\n@@ -318,2 +284,3 @@\n-     * Compares the FullyQualifiedNames of two TypeMirrors\n-     * @return\n+     * Returns a comparator that compares the fully qualified names of two type mirrors.\n+     *\n+     * @return the comparator\n@@ -335,2 +302,2 @@\n-     * Compares the SimpleNames of TypeMirrors if equal then the\n-     * FullyQualifiedNames of TypeMirrors.\n+     * Returns a comparator that compares the simple names of two type mirrors,\n+     * or the fully qualified names if the simple names are equal.\n@@ -338,1 +305,1 @@\n-     * @return\n+     * @return the comparator\n@@ -471,1 +438,1 @@\n-            \/\/ add simplename to be compatible\n+            \/\/ add simple name to be compatible\n@@ -530,14 +497,14 @@\n-            switch (e.getKind()) {\n-                case MODULE:            return 0;\n-                case PACKAGE:           return 1;\n-                case CLASS:             return 2;\n-                case ENUM:              return 3;\n-                case ENUM_CONSTANT:     return 4;\n-                case RECORD:            return 5;\n-                case INTERFACE:         return 6;\n-                case ANNOTATION_TYPE:   return 7;\n-                case FIELD:             return 8;\n-                case CONSTRUCTOR:       return 9;\n-                case METHOD:            return 10;\n-                default: throw new IllegalArgumentException(e.getKind().toString());\n-            }\n+            return switch (e.getKind()) {\n+                case MODULE ->          0;\n+                case PACKAGE ->         1;\n+                case CLASS ->           2;\n+                case ENUM ->            3;\n+                case ENUM_CONSTANT ->   4;\n+                case RECORD ->          5;\n+                case INTERFACE ->       6;\n+                case ANNOTATION_TYPE -> 7;\n+                case FIELD ->           8;\n+                case CONSTRUCTOR ->     9;\n+                case METHOD ->          10;\n+                default -> throw new IllegalArgumentException(e.getKind().toString());\n+            };\n@@ -601,44 +568,0 @@\n-\n-    \/**\n-     * Returns a Comparator for SearchIndexItems representing types. Items are\n-     * compared by short name, or full string representation if names are equal.\n-     *\n-     * @return a Comparator\n-     *\/\n-    public Comparator<SearchIndexItem> makeTypeSearchIndexComparator() {\n-        return (SearchIndexItem sii1, SearchIndexItem sii2) -> {\n-            int result = utils.compareStrings(sii1.getSimpleName(), sii2.getSimpleName());\n-            if (result == 0) {\n-                \/\/ TreeSet needs this to be consistent with equal so we do\n-                \/\/ a plain comparison of string representations as fallback.\n-                result = sii1.toString().compareTo(sii2.toString());\n-            }\n-            return result;\n-        };\n-    }\n-\n-    private Comparator<SearchIndexItem> genericSearchIndexComparator = null;\n-\n-    \/**\n-     * Returns a Comparator for SearchIndexItems representing modules, packages, or members.\n-     * Items are compared by label (member name plus signature for members, package name for\n-     * packages, and module name for modules). If labels are equal then full string\n-     * representation is compared.\n-     *\n-     * @return a Comparator\n-     *\/\n-    public Comparator<SearchIndexItem> makeGenericSearchIndexComparator() {\n-        if (genericSearchIndexComparator == null) {\n-            genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -> {\n-                int result = utils.compareStrings(sii1.getLabel(), sii2.getLabel());\n-                if (result == 0) {\n-                    \/\/ TreeSet needs this to be consistent with equal so we do\n-                    \/\/ a plain comparison of string representations as fallback.\n-                    result = sii1.toString().compareTo(sii2.toString());\n-                }\n-                return result;\n-            };\n-        }\n-        return genericSearchIndexComparator;\n-    }\n-\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Comparators.java","additions":21,"deletions":98,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;\n+import com.sun.source.doctree.DocTree;\n@@ -43,1 +43,5 @@\n- *  An alphabetical index of {@link Element elements}.\n+ *  An alphabetical index of elements, search tags, and other items.\n+ *  Two tables are maintained:\n+ *  one is indexed by the first character of each items name;\n+ *  the other is index by the item's category, indicating the JavaScript\n+ *  file in which the item should be written.\n@@ -53,2 +57,2 @@\n-     * Sets of elements keyed by the first character of the names of the\n-     * elements in those sets.\n+     * Sets of items keyed by the first character of the names (labels)\n+     * of the items in those sets.\n@@ -56,1 +60,7 @@\n-    private final Map<Character, SortedSet<IndexItem>> indexMap;\n+    private final Map<Character, SortedSet<IndexItem>> itemsByFirstChar;\n+\n+    \/**\n+     * Sets of items keyed by the {@link IndexItem.Category category}\n+     * of the items in those sets.\n+     *\/\n+    private final Map<IndexItem.Category, SortedSet<IndexItem>> itemsByCategory;\n@@ -66,1 +76,1 @@\n-    private final boolean classesOnly;\n+    protected final boolean classesOnly;\n@@ -70,1 +80,5 @@\n-    private final Comparator<IndexItem> comparator;\n+\n+    \/**\n+     * The comparator used for the sets in {@code itemsByFirstChar}.\n+     *\/\n+    private final Comparator<IndexItem> mainComparator;\n@@ -109,3 +123,5 @@\n-        this.indexMap = new TreeMap<>();\n-        comparator = utils.comparators.makeIndexComparator(classesOnly);\n-        buildIndex();\n+\n+        itemsByFirstChar = new TreeMap<>();\n+        itemsByCategory = new EnumMap<>(IndexItem.Category.class);\n+\n+        mainComparator = makeIndexComparator(classesOnly);\n@@ -115,1 +131,2 @@\n-     * Indexes all the members in all the packages and all the classes.\n+     * Adds all the selected modules, packages, types and their members to the index,\n+     * or just the type elements if {@code classesOnly} is {@code true}.\n@@ -117,1 +134,1 @@\n-    private void buildIndex()  {\n+    public void addElements()  {\n@@ -141,0 +158,59 @@\n+    \/**\n+     * Adds an individual item to the two collections of items.\n+     *\n+     * @param item the item to add\n+     *\/\n+    public void add(IndexItem item) {\n+        Objects.requireNonNull(item);\n+\n+        itemsByFirstChar.computeIfAbsent(keyCharacter(item.getLabel()),\n+                    c -> new TreeSet<>(mainComparator))\n+                .add(item);\n+\n+        itemsByCategory.computeIfAbsent(item.getCategory(),\n+                    c -> new TreeSet<>(mainComparator))\n+                .add(item);\n+    }\n+\n+    \/**\n+     * Returns a sorted list of items whose names start with the\n+     * provided character.\n+     *\n+     * @param key index key\n+     * @return list of items keyed by the provided character\n+     *\/\n+    public SortedSet<IndexItem> getItems(Character key) {\n+        return itemsByFirstChar.get(key);\n+    }\n+\n+    \/**\n+     * Returns a list of index keys.\n+     *\/\n+    public List<Character> getFirstCharacters() {\n+        return new ArrayList<>(itemsByFirstChar.keySet());\n+    }\n+\n+    \/**\n+     * Returns a sorted list of items in a given category.\n+     *\n+     * @param cat the category\n+     * @return list of items keyed by the provided character\n+     *\/\n+    public SortedSet<IndexItem> getItems(IndexItem.Category cat) {\n+        Objects.requireNonNull(cat);\n+        return itemsByCategory.getOrDefault(cat, Collections.emptySortedSet());\n+    }\n+\n+    \/**\n+     * Returns a sorted list of items with a given kind of doc tree.\n+     *\n+     * @param kind the kind\n+     * @return list of items keyed by the provided character\n+     *\/\n+    public SortedSet<IndexItem> getItems(DocTree.Kind kind) {\n+        Objects.requireNonNull(kind);\n+        return itemsByCategory.getOrDefault(IndexItem.Category.TAGS, Collections.emptySortedSet()).stream()\n+                .filter(i -> i.getDocTree().getKind() == kind)\n+                .collect(Collectors.toCollection(() -> new TreeSet<>(mainComparator)));\n+    }\n+\n@@ -149,6 +225,6 @@\n-        indexElements(vmt.getVisibleMembers(FIELDS), te);\n-        indexElements(vmt.getVisibleMembers(ANNOTATION_TYPE_MEMBER_OPTIONAL), te);\n-        indexElements(vmt.getVisibleMembers(ANNOTATION_TYPE_MEMBER_REQUIRED), te);\n-        indexElements(vmt.getVisibleMembers(METHODS), te);\n-        indexElements(vmt.getVisibleMembers(CONSTRUCTORS), te);\n-        indexElements(vmt.getVisibleMembers(ENUM_CONSTANTS), te);\n+        indexMembers(te, vmt.getVisibleMembers(FIELDS));\n+        indexMembers(te, vmt.getVisibleMembers(ANNOTATION_TYPE_MEMBER_OPTIONAL));\n+        indexMembers(te, vmt.getVisibleMembers(ANNOTATION_TYPE_MEMBER_REQUIRED));\n+        indexMembers(te, vmt.getVisibleMembers(METHODS));\n+        indexMembers(te, vmt.getVisibleMembers(CONSTRUCTORS));\n+        indexMembers(te, vmt.getVisibleMembers(ENUM_CONSTANTS));\n@@ -160,1 +236,1 @@\n-     * @param elements a collection of elements\n+     * @param members a collection of elements\n@@ -162,7 +238,4 @@\n-    private void indexElements(Iterable<? extends Element> elements, TypeElement typeElement) {\n-        for (Element element : elements) {\n-            if (shouldIndex(element)) {\n-                String name = utils.getSimpleName(element);\n-                Character ch = keyCharacter(name);\n-                SortedSet<IndexItem> set = indexMap.computeIfAbsent(ch, c -> new TreeSet<>(comparator));\n-                set.add(new IndexItem(element, typeElement, utils));\n+    private void indexMembers(TypeElement typeElement, Iterable<? extends Element> members) {\n+        for (Element member : members) {\n+            if (shouldIndex(member)) {\n+                add(IndexItem.of(typeElement, member, utils));\n@@ -181,4 +254,1 @@\n-                String name = utils.getSimpleName(typeElement);\n-                Character ch = keyCharacter(name);\n-                SortedSet<IndexItem> set = indexMap.computeIfAbsent(ch, c -> new TreeSet<>(comparator));\n-                set.add(new IndexItem(typeElement, utils));\n+                add(IndexItem.of(typeElement, utils));\n@@ -189,4 +259,0 @@\n-    private static Character keyCharacter(String s) {\n-        return s.isEmpty() ? '*' : Character.toUpperCase(s.charAt(0));\n-    }\n-\n@@ -198,3 +264,1 @@\n-            Character ch = keyCharacter(m.getQualifiedName().toString());\n-            SortedSet<IndexItem> set = indexMap.computeIfAbsent(ch, c -> new TreeSet<>(comparator));\n-            set.add(new IndexItem(m, utils));\n+            add(IndexItem.of(m, utils));\n@@ -211,3 +275,1 @@\n-            Character ch = keyCharacter(utils.getPackageName(packageElement));\n-            SortedSet<IndexItem> set = indexMap.computeIfAbsent(ch, c -> new TreeSet<>(comparator));\n-            set.add(new IndexItem(packageElement, utils));\n+            add(IndexItem.of(packageElement, utils));\n@@ -239,7 +301,2 @@\n-    \/**\n-     * Returns a map representation of this index.\n-     *\n-     * @return map\n-     *\/\n-    public Map<Character, SortedSet<IndexItem>> asMap() {\n-        return indexMap;\n+    private static Character keyCharacter(String s) {\n+        return s.isEmpty() ? '*' : Character.toUpperCase(s.charAt(0));\n@@ -248,0 +305,1 @@\n+\n@@ -249,2 +307,3 @@\n-     * Returns a sorted list of elements whose names start with the\n-     * provided character.\n+     * Returns a comparator for the {@code IndexItem}s in the index page.\n+     * This is a composite comparator that must be able to compare all kinds of items:\n+     * for element items, tag items, and others.\n@@ -252,2 +311,1 @@\n-     * @param key index key\n-     * @return list of elements keyed by the provided character\n+     * @return a comparator for index page items\n@@ -255,7 +313,4 @@\n-    public List<IndexItem> getMemberList(Character key) {\n-        SortedSet<IndexItem> set = indexMap.get(key);\n-        if (set == null) {\n-            return null;\n-        }\n-        return new ArrayList<>(set);\n-    }\n+    private Comparator<IndexItem> makeIndexComparator(boolean classesOnly) {\n+        Comparator<Element> elementComparator = classesOnly\n+                ? utils.comparators.makeAllClassesComparator()\n+                : utils.comparators.makeIndexElementComparator();\n@@ -263,6 +318,7 @@\n-    \/**\n-     * Returns a list of index keys.\n-     *\/\n-    public List<Character> keys() {\n-        return new ArrayList<>(indexMap.keySet());\n-    }\n+        Comparator<IndexItem> labelComparator =\n+                (ii1, ii2) -> utils.compareStrings(ii1.getLabel(), ii2.getLabel());\n+        Comparator<IndexItem> searchTagComparator =\n+                labelComparator\n+                        .thenComparing(IndexItem::getHolder)\n+                        .thenComparing(IndexItem::getDescription)\n+                        .thenComparing(IndexItem::getUrl);\n@@ -270,11 +326,15 @@\n-    \/**\n-     * Add search tags for the key {@code key}.\n-     *\n-     * @param key the index key\n-     * @param searchTags the search tags\n-     *\/\n-    public void addSearchTags(char key, List<SearchIndexItem> searchTags) {\n-        searchTags.forEach(searchTag -> {\n-            SortedSet<IndexItem> set = indexMap.computeIfAbsent(key, c -> new TreeSet<>(comparator));\n-            set.add(new IndexItem(searchTag));\n-        });\n+        return (ii1, ii2) -> {\n+            \/\/ If both are element items, compare the elements\n+            if (ii1.isElementItem() && ii2.isElementItem()) {\n+                return elementComparator.compare(ii1.getElement(), ii2.getElement());\n+            }\n+\n+            \/\/ If one is an element item, compare labels; if equal, put element item last\n+            if (ii1.isElementItem() || ii2.isElementItem()) {\n+                int d = labelComparator.compare(ii1, ii2);\n+                return d != 0 ? d : ii1.isElementItem() ? 1 : -1;\n+            }\n+\n+            \/\/ Otherwise, compare labels and other fields of the items\n+            return searchTagComparator.compare(ii1, ii2);\n+        };\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/IndexBuilder.java","additions":135,"deletions":75,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -28,2 +28,1 @@\n-import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;\n-\n+import java.util.Objects;\n@@ -35,0 +34,4 @@\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.util.SimpleElementVisitor14;\n+\n+import com.sun.source.doctree.DocTree;\n@@ -37,1 +40,38 @@\n- *  A holder for an indexed {@link Element} or {@link SearchIndexItem}.\n+ * An item to be included in the index pages and in interactive search.\n+ *\n+ * <p>\n+ * Items are primarily defined by their position in the documentation,\n+ * which is one of:\n+ *\n+ * <ul>\n+ * <li>An element (module, package, type or member)\n+ * <li>One of a small set of tags in the doc comment for an element:\n+ *     {@code {@index ...}}, {@code {@systemProperty ...}}, etc\n+ * <li>One of a small set of outliers, corresponding to summary pages:\n+ *     \"All Classes\", \"All Packages\", etc\n+ * <\/ul>\n+ *\n+ * <p>\n+ * All items have a \"label\", which is the presentation string used\n+ * to display the item in the list of matching choices. The\n+ * label is specified when the item is created.  Items also\n+ * have a \"url\" and a \"description\", which are provided by\n+ * the specific doclet.\n+ *\n+ * <p>\n+ * Each item provides details to be included in the search index files\n+ * read and processed by JavaScript.\n+ * Items have a \"category\", which is normally derived from the element\n+ * kind or doc tree kind; it corresponds to the JavaScript file\n+ * in which this item will be written.\n+ *\n+ * <p>\n+ * Items for an element may have one or more of the following:\n+ * \"containing module\", \"containing package\", \"containing type\".\n+ *\n+ * <p>\n+ * Items for a node in a doc tree have a \"holder\", which is a\n+ * text form of the enclosing element or page.\n+ * They will typically also have a \"description\" derived from\n+ * content in the doc tree node.\n+ *\n@@ -46,0 +86,22 @@\n+    \/**\n+     * The \"category\" used to group items for the interactive search index.\n+     * Categories correspond directly to the JavaScript files that will be generated.\n+     *\/\n+    public enum Category {\n+        MODULES,\n+        PACKAGES,\n+        TYPES,\n+        MEMBERS,\n+        TAGS\n+    }\n+\n+    \/**\n+     * The presentation string for the item. It must be non-empty.\n+     *\/\n+    private final String label;\n+\n+    \/**\n+     * The element for the item. It is only null for items for summary pages that are not\n+     * associated with any specific element.\n+     *\n+     *\/\n@@ -47,3 +109,0 @@\n-    private final SearchIndexItem searchTag;\n-    private String label;\n-    private TypeElement typeElement;\n@@ -51,5 +110,5 @@\n-    public IndexItem(SearchIndexItem searchTag) {\n-        this.element = null;\n-        this.searchTag = searchTag;\n-        this.label = searchTag.getLabel();\n-    }\n+    \/**\n+     * The URL pointing to the element, doc tree or page being indexed.\n+     * It may be empty if the information can be determined from other fields.\n+     *\/\n+    private String url = \"\";\n@@ -57,4 +116,11 @@\n-    private IndexItem(Element element) {\n-        this.element = element;\n-        this.searchTag = null;\n-    }\n+    \/**\n+     * The containing module, if any, for the item.\n+     * It will be empty if the element is not in a package, and may be omitted if the\n+     * name of the package is unique.\n+     *\/\n+    private String containingModule = \"\";\n+\n+    \/**\n+     * The containing package, if any, for the item.\n+     *\/\n+    private String containingPackage = \"\";\n@@ -62,3 +128,15 @@\n-    public IndexItem(TypeElement typeElement, Utils utils) {\n-        this(typeElement);\n-        this.label = utils.getSimpleName(typeElement);\n+    \/**\n+     * The containing class, if any, for the item.\n+     *\/\n+    private String containingClass = \"\";\n+\n+    \/**\n+     * Creates an index item for a module element.\n+     *\n+     * @param moduleElement the element\n+     * @param utils         the common utilities class\n+     *\n+     * @return the item\n+     *\/\n+    public static IndexItem of(ModuleElement moduleElement, Utils utils) {\n+        return new IndexItem(moduleElement, utils.getFullyQualifiedName(moduleElement));\n@@ -67,3 +145,10 @@\n-    public IndexItem(ModuleElement moduleElement, Utils utils) {\n-        this(moduleElement);\n-        this.label = utils.getFullyQualifiedName(moduleElement);\n+    \/**\n+     * Creates an index item for a package element.\n+     *\n+     * @param packageElement the element\n+     * @param utils          the common utilities class\n+     *\n+     * @return the item\n+     *\/\n+    public static IndexItem of(PackageElement packageElement, Utils utils) {\n+        return new IndexItem(packageElement, utils.getPackageName(packageElement));\n@@ -72,3 +157,11 @@\n-    public IndexItem(PackageElement packageElement, Utils utils) {\n-        this(packageElement);\n-        this.label = utils.getPackageName(packageElement);\n+    \/**\n+     * Creates an index item for a type element.\n+     * Note: use {@code getElement()} to access this value, not {@code getTypeElement}.\n+     *\n+     * @param typeElement the element\n+     * @param utils       the common utilities class\n+     *\n+     * @return the item\n+     *\/\n+    public static IndexItem of(TypeElement typeElement, Utils utils) {\n+        return new IndexItem(typeElement, utils.getSimpleName(typeElement));\n@@ -77,3 +170,14 @@\n-    public IndexItem(Element member, TypeElement typeElement, Utils utils) {\n-        this(member);\n-        this.typeElement = typeElement;\n+    \/**\n+     * Creates an index item for a member element.\n+     * Note: the given type element may not be the same as the enclosing element of the member\n+     *       in cases where the enclosing element is not visible in the documentation.\n+     *\n+     * @param typeElement the element that contains the member\n+     * @param member      the member\n+     * @param utils       the common utilities class\n+     *\n+     * @return the item\n+     *\n+     * @see #getContainingTypeElement()\n+     *\/\n+    public static IndexItem of(TypeElement typeElement, Element member, Utils utils) {\n@@ -85,1 +189,6 @@\n-        this.label = name;\n+        return new IndexItem(member, name) {\n+            @Override\n+            public TypeElement getContainingTypeElement() {\n+                return typeElement;\n+            }\n+        };\n@@ -88,0 +197,96 @@\n+    \/**\n+     * Creates an index item for a node in the doc comment for an element.\n+     * The node should only be one that gives rise to an entry in the index.\n+     *\n+     * @param element     the element\n+     * @param docTree     the node in the doc comment\n+     * @param label       the label\n+     * @param holder      the holder for the comment\n+     * @param description the description of the item\n+     * @param link        the root-relative link to the item in the generated docs\n+     *\n+     * @return the item\n+     *\/\n+    public static IndexItem of(Element element, DocTree docTree, String label,\n+                               String holder, String description, DocLink link) {\n+        Objects.requireNonNull(element);\n+        Objects.requireNonNull(holder);\n+        Objects.requireNonNull(description);\n+        Objects.requireNonNull(link);\n+\n+        switch (docTree.getKind()) {\n+            case INDEX, SYSTEM_PROPERTY -> { }\n+            default -> throw new IllegalArgumentException(docTree.getKind().toString());\n+        }\n+\n+        return new IndexItem(element, label, link.toString()) {\n+            @Override\n+            public DocTree getDocTree() {\n+                return docTree;\n+            }\n+            @Override\n+            public Category getCategory() {\n+                return getCategory(docTree);\n+            }\n+            @Override\n+            public String getHolder() {\n+                return holder;\n+            }\n+            @Override\n+            public String getDescription() {\n+                return description;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Creates an index item for a summary page, that is not associated with any element or\n+     * node in a doc comment.\n+     *\n+     * @param category the category for the item\n+     * @param label the label for the item\n+     * @param path the path for the page\n+     *\n+     * @return the item\n+     *\/\n+    public static IndexItem of(Category category, String label, DocPath path) {\n+        Objects.requireNonNull(category);\n+        return new IndexItem(null, label, path.getPath()) {\n+            @Override\n+            public DocTree getDocTree() {\n+                return null;\n+            }\n+            @Override\n+            public Category getCategory() {\n+                return category;\n+            }\n+            @Override\n+            public String getHolder() {\n+                return \"\";\n+            }\n+            @Override\n+            public String getDescription() {\n+                return \"\";\n+            }\n+        };\n+    }\n+\n+    private IndexItem(Element element, String label) {\n+        if (label.isEmpty()) {\n+            throw new IllegalArgumentException();\n+        }\n+\n+        this.element = element;\n+        this.label = label;\n+    }\n+\n+    private IndexItem(Element element, String label, String url) {\n+        this(element, label);\n+        setUrl(url);\n+    }\n+\n+    \/**\n+     * Returns the label of the item.\n+     *\n+     * @return the label\n+     *\/\n@@ -92,0 +297,17 @@\n+    \/**\n+     * Returns the part of the label after the last dot, or the whole label if there are no dots.\n+     *\n+     * @return the simple name\n+     *\/\n+    public String getSimpleName() {\n+        return label.substring(label.lastIndexOf('.') + 1);\n+    }\n+\n+    \/**\n+     * Returns the label with a fully-qualified type name.\n+     * (Used to determine if labels are unique or need to be qualified.)\n+     *\n+     * @param utils the common utilities class\n+     *\n+     * @return the fully qualified name\n+     *\/\n@@ -93,0 +315,1 @@\n+        TypeElement typeElement = getContainingTypeElement();\n@@ -95,1 +318,1 @@\n-        } else if (element != null) {\n+        } else if (isElementItem()) {\n@@ -102,0 +325,5 @@\n+    \/**\n+     * Returns the element associate with this item, or {@code null}.\n+     *\n+     * @return the element\n+     *\/\n@@ -106,2 +334,15 @@\n-    public SearchIndexItem getSearchTag() {\n-        return searchTag;\n+    \/**\n+     * Returns the category for this item, that indicates the JavaScript file\n+     * in which this item should be written.\n+     *\n+     * @return the category\n+     *\/\n+    public Category getCategory() {\n+        return getCategory(element);\n+    }\n+\n+    protected Category getCategory(DocTree docTree) {\n+        return switch (docTree.getKind()) {\n+            case INDEX, SYSTEM_PROPERTY -> Category.TAGS;\n+            default -> throw new IllegalArgumentException(docTree.getKind().toString());\n+        };\n@@ -110,2 +351,224 @@\n-    public TypeElement getTypeElement() {\n-        return typeElement;\n+    @SuppressWarnings(\"preview\")\n+    protected Category getCategory(Element element) {\n+        return new SimpleElementVisitor14<Category, Void>() {\n+            @Override\n+            public Category visitModule(ModuleElement t, Void v) {\n+                return Category.MODULES;\n+            }\n+\n+            @Override\n+            public Category visitPackage(PackageElement e, Void v) {\n+                return Category.PACKAGES;\n+            }\n+\n+            @Override\n+            public Category visitType(TypeElement e, Void v) {\n+                return Category.TYPES;\n+            }\n+\n+            @Override\n+            public Category visitVariable(VariableElement e, Void v) {\n+                return Category.MEMBERS;\n+            }\n+\n+            @Override\n+            public Category visitExecutable(ExecutableElement e, Void v) {\n+                return Category.MEMBERS;\n+            }\n+\n+            @Override\n+            public Category defaultAction(Element e, Void v) {\n+                throw new IllegalArgumentException(e.toString());\n+            }\n+        }.visit(element);\n+    }\n+\n+    \/**\n+     * Returns the type element that is documented as containing a member element,\n+     * or {@code null} if this item does not represent a member element.\n+     *\n+     * @return the type element\n+     *\/\n+    public TypeElement getContainingTypeElement() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns the documentation tree node for this item, of {@code null} if this item\n+     * does not represent a documentation tree node.\n+     *\n+     * @return the documentation tree node\n+     *\/\n+    public DocTree getDocTree() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this index is for an element.\n+     *\n+     * @return {@code true} if this index is for an element\n+     *\/\n+    public boolean isElementItem() {\n+        return element != null && getDocTree() == null;\n+    }\n+\n+    \/**\n+     * Returns {@code true} if this index is for a tag in a doc comment.\n+     *\n+     * @return {@code true} if this index is for a tag in a doc comment\n+     *\/\n+    public boolean isTagItem() {\n+        return getDocTree() != null;\n+    }\n+\n+    \/**\n+     * Sets the URL for the item, when it cannot otherwise be inferred from other fields.\n+     *\n+     * @param u the url\n+     *\n+     * @return this item\n+     *\/\n+    public IndexItem setUrl(String u) {\n+        url = Objects.requireNonNull(u);\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns the URL for this item, or an empty string if no value has been set.\n+     *\n+     * @return the URL for this item, or an empty string if no value has been set\n+     *\/\n+    public String getUrl() {\n+        return url;\n+    }\n+\n+    \/**\n+     * Sets the name of the containing module for this item.\n+     *\n+     * @param m the module\n+     *\n+     * @return this item\n+     *\/\n+    public IndexItem setContainingModule(String m) {\n+        containingModule = Objects.requireNonNull(m);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the name of the containing package for this item.\n+     *\n+     * @param p the package\n+     *\n+     * @return this item\n+     *\/\n+    public IndexItem setContainingPackage(String p) {\n+        containingPackage = Objects.requireNonNull(p);\n+        return this;\n+    }\n+\n+    \/**\n+     * Sets the name of the containing class for this item.\n+     *\n+     * @param c the class\n+     *\n+     * @return this item\n+     *\/\n+    public IndexItem setContainingClass(String c) {\n+        containingClass = Objects.requireNonNull(c);\n+        return this;\n+    }\n+\n+    \/**\n+     * Returns a description of the element owning the documentation comment for this item,\n+     * or {@code null} if this is not a item for a tag for an item in a documentation tag.\n+     *\n+     * @return the description of the element that owns this item\n+     *\/\n+    public String getHolder() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a description of the tag for this item or {@code null} if this is not a item\n+     * for a tag for an item in a documentation tag.\n+     *\n+     * @return the description of the tag\n+     *\/\n+    public String getDescription() {\n+        return null;\n+    }\n+\n+    \/**\n+     * Returns a string representing this item in JSON notation.\n+     *\n+     * @return a string representing this item in JSON notation\n+     *\/\n+    public String toJSON() {\n+        \/\/ TODO: Additional processing is required, see JDK-8238495\n+        StringBuilder item = new StringBuilder();\n+        Category category = getCategory();\n+        switch (category) {\n+            case MODULES:\n+                item.append(\"{\")\n+                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\")\n+                        .append(\"}\");\n+                break;\n+\n+            case PACKAGES:\n+                item.append(\"{\");\n+                if (!containingModule.isEmpty()) {\n+                    item.append(\"\\\"m\\\":\\\"\").append(containingModule).append(\"\\\",\");\n+                }\n+                item.append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\");\n+                if (!url.isEmpty()) {\n+                    item.append(\",\\\"u\\\":\\\"\").append(url).append(\"\\\"\");\n+                }\n+                item.append(\"}\");\n+                break;\n+\n+            case TYPES:\n+                item.append(\"{\");\n+                if (!containingPackage.isEmpty()) {\n+                    item.append(\"\\\"p\\\":\\\"\").append(containingPackage).append(\"\\\",\");\n+                }\n+                if (!containingModule.isEmpty()) {\n+                    item.append(\"\\\"m\\\":\\\"\").append(containingModule).append(\"\\\",\");\n+                }\n+                item.append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\");\n+                if (!url.isEmpty()) {\n+                    item.append(\",\\\"u\\\":\\\"\").append(url).append(\"\\\"\");\n+                }\n+                item.append(\"}\");\n+                break;\n+\n+            case MEMBERS:\n+                item.append(\"{\");\n+                if (!containingModule.isEmpty()) {\n+                    item.append(\"\\\"m\\\":\\\"\").append(containingModule).append(\"\\\",\");\n+                }\n+                item.append(\"\\\"p\\\":\\\"\").append(containingPackage).append(\"\\\",\")\n+                        .append(\"\\\"c\\\":\\\"\").append(containingClass).append(\"\\\",\")\n+                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\"\");\n+                if (!url.isEmpty()) {\n+                    item.append(\",\\\"u\\\":\\\"\").append(url).append(\"\\\"\");\n+                }\n+                item.append(\"}\");\n+                break;\n+\n+            case TAGS:\n+                String holder = getHolder();\n+                String description = getDescription();\n+                item.append(\"{\")\n+                        .append(\"\\\"l\\\":\\\"\").append(label).append(\"\\\",\")\n+                        .append(\"\\\"h\\\":\\\"\").append(holder).append(\"\\\",\");\n+                if (!description.isEmpty()) {\n+                    item.append(\"\\\"d\\\":\\\"\").append(description).append(\"\\\",\");\n+                }\n+                item.append(\"\\\"u\\\":\\\"\").append(url).append(\"\\\"\")\n+                        .append(\"}\");\n+                break;\n+\n+            default:\n+                throw new AssertionError(\"Unexpected category: \" + category);\n+        }\n+        return item.toString();\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/IndexItem.java","additions":496,"deletions":33,"binary":false,"changes":529,"status":"modified"},{"patch":"@@ -285,2 +285,1 @@\n-     * According to\n-     * <cite>The Java Language Specification<\/cite>,\n+     * According to <cite>The Java Language Specification<\/cite>,\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/Utils.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}