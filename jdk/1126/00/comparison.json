{"files":[{"patch":"@@ -885,0 +885,5 @@\n+\n+  \/\/ Vector API support (implemented in vectorIntrinsics.cpp)\n+  Node* box_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool deoptimize_on_exception = false);\n+  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector = false);\n+  Node* vector_shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/graphKit.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -327,3 +327,0 @@\n-  Node* box_vector(Node* in, const TypeInstPtr* vbox_type, BasicType bt, int num_elem);\n-  Node* unbox_vector(Node* in, const TypeInstPtr* vbox_type, BasicType bt, int num_elem, bool shuffle_to_vector = false);\n-  Node* shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -195,6 +195,0 @@\n-        PreserveReexecuteState prs(&kit);\n-\n-        kit.jvms()->set_should_reexecute(true);\n-\n-        const TypeInstPtr* vbox_type = vec_box->box_type();\n-        const TypeVect* vect_type = vec_box->vec_type();\n@@ -202,0 +196,4 @@\n+        const TypeInstPtr* vbox_type = vec_box->box_type();\n+        const TypeVect* vt = vec_box->vec_type();\n+        BasicType elem_bt = vt->element_basic_type();\n+        int num_elem = vt->length();\n@@ -203,8 +201,1 @@\n-        VectorBoxAllocateNode* alloc = new VectorBoxAllocateNode(C, vbox_type);\n-        kit.set_edges_for_java_call(alloc, \/*must_throw=*\/false, \/*separate_io_proj=*\/true);\n-        kit.make_slow_call_ex(alloc, C->env()->Throwable_klass(), \/*separate_io_proj=*\/true, \/*deoptimize=*\/true);\n-        kit.set_i_o(gvn.transform( new ProjNode(alloc, TypeFunc::I_O) ));\n-        kit.set_all_memory(gvn.transform( new ProjNode(alloc, TypeFunc::Memory) ));\n-        Node* ret = gvn.transform(new ProjNode(alloc, TypeFunc::Parms));\n-\n-        new_vbox = gvn.transform(new VectorBoxNode(C, ret, vect, vbox_type, vect_type));\n+        new_vbox = kit.box_vector(vect, vbox_type, elem_bt, num_elem, \/*deoptimize=*\/true);\n@@ -366,6 +357,6 @@\n-                                                            vec_field,\n-                                                            vec_adr_type,\n-                                                            arr,\n-                                                            TypeOopPtr::make_from_klass(field->type()->as_klass()),\n-                                                            T_OBJECT,\n-                                                            IN_HEAP));\n+                                                        vec_field,\n+                                                        vec_adr_type,\n+                                                        arr,\n+                                                        TypeOopPtr::make_from_klass(field->type()->as_klass()),\n+                                                        T_OBJECT,\n+                                                        IN_HEAP));\n","filename":"src\/hotspot\/share\/opto\/vector.cpp","additions":11,"deletions":20,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -32,0 +32,70 @@\n+#ifdef ASSERT\n+static bool is_vector(ciKlass* klass) {\n+  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n+}\n+\n+static bool check_vbox(const TypeInstPtr* vbox_type) {\n+  assert(vbox_type->klass_is_exact(), \"\");\n+\n+  ciInstanceKlass* ik = vbox_type->klass()->as_instance_klass();\n+  assert(is_vector(ik), \"not a vector\");\n+\n+  ciField* fd1 = ik->get_field_by_name(ciSymbol::ETYPE_name(), ciSymbol::class_signature(), \/* is_static *\/ true);\n+  assert(fd1 != NULL, \"element type info is missing\");\n+\n+  ciConstant val1 = fd1->constant_value();\n+  BasicType elem_bt = val1.as_object()->as_instance()->java_mirror_type()->basic_type();\n+  assert(is_java_primitive(elem_bt), \"element type info is missing\");\n+\n+  ciField* fd2 = ik->get_field_by_name(ciSymbol::VLENGTH_name(), ciSymbol::int_signature(), \/* is_static *\/ true);\n+  assert(fd2 != NULL, \"vector length info is missing\");\n+\n+  ciConstant val2 = fd2->constant_value();\n+  assert(val2.as_int() > 0, \"vector length info is missing\");\n+\n+  return true;\n+}\n+#endif\n+\n+Node* GraphKit::box_vector(Node* vector, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool deoptimize_on_exception) {\n+  assert(EnableVectorSupport, \"\");\n+\n+  PreserveReexecuteState preexecs(this);\n+  jvms()->set_should_reexecute(true);\n+\n+  VectorBoxAllocateNode* alloc = new VectorBoxAllocateNode(C, vbox_type);\n+  set_edges_for_java_call(alloc, \/*must_throw=*\/false, \/*separate_io_proj=*\/true);\n+  make_slow_call_ex(alloc, env()->Throwable_klass(), \/*separate_io_proj=*\/true, deoptimize_on_exception);\n+  set_i_o(gvn().transform( new ProjNode(alloc, TypeFunc::I_O) ));\n+  set_all_memory(gvn().transform( new ProjNode(alloc, TypeFunc::Memory) ));\n+  Node* ret = gvn().transform(new ProjNode(alloc, TypeFunc::Parms));\n+\n+  assert(check_vbox(vbox_type), \"\");\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vt);\n+  return gvn().transform(vbox);\n+}\n+\n+Node* GraphKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n+  assert(EnableVectorSupport, \"\");\n+  const TypeInstPtr* vbox_type_v = gvn().type(v)->is_instptr();\n+  if (vbox_type->klass() != vbox_type_v->klass()) {\n+    return NULL; \/\/ arguments don't agree on vector shapes\n+  }\n+  if (vbox_type_v->maybe_null()) {\n+    return NULL; \/\/ no nulls are allowed\n+  }\n+  assert(check_vbox(vbox_type), \"\");\n+  const TypeVect* vt = TypeVect::make(elem_bt, num_elem);\n+  Node* unbox = gvn().transform(new VectorUnboxNode(C, vt, v, merged_memory(), shuffle_to_vector));\n+  return unbox;\n+}\n+\n+Node* GraphKit::vector_shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem) {\n+  assert(bt == T_INT || bt == T_LONG || bt == T_SHORT || bt == T_BYTE, \"byte, short, long and int are supported\");\n+  juint mask = (type2aelembytes(bt) * BitsPerByte - 1);\n+  Node* nmask = gvn().transform(ConNode::make(TypeInt::make(mask)));\n+  Node* mcnt = gvn().transform(new AndINode(cnt, nmask));\n+  return gvn().transform(VectorNode::shift_count(shift_op, mcnt, num_elem, bt));\n+}\n+\n@@ -111,60 +181,0 @@\n-#ifdef ASSERT\n-static bool is_vector(ciKlass* klass) {\n-  return klass->is_subclass_of(ciEnv::current()->vector_VectorPayload_klass());\n-}\n-\n-static bool check_vbox(const TypeInstPtr* vbox_type) {\n-  assert(vbox_type->klass_is_exact(), \"\");\n-\n-  ciInstanceKlass* ik = vbox_type->klass()->as_instance_klass();\n-  assert(is_vector(ik), \"not a vector\");\n-\n-  ciField* fd1 = ik->get_field_by_name(ciSymbol::ETYPE_name(), ciSymbol::class_signature(), \/* is_static *\/ true);\n-  assert(fd1 != NULL, \"element type info is missing\");\n-\n-  ciConstant val1 = fd1->constant_value();\n-  BasicType elem_bt = val1.as_object()->as_instance()->java_mirror_type()->basic_type();\n-  assert(is_java_primitive(elem_bt), \"element type info is missing\");\n-\n-  ciField* fd2 = ik->get_field_by_name(ciSymbol::VLENGTH_name(), ciSymbol::int_signature(), \/* is_static *\/ true);\n-  assert(fd2 != NULL, \"vector length info is missing\");\n-\n-  ciConstant val2 = fd2->constant_value();\n-  assert(val2.as_int() > 0, \"vector length info is missing\");\n-\n-  return true;\n-}\n-#endif\n-\n-Node* LibraryCallKit::box_vector(Node* vector, const TypeInstPtr* vbox_type,\n-                                 BasicType elem_bt, int num_elem) {\n-  assert(EnableVectorSupport, \"\");\n-  const TypeVect* vec_type = TypeVect::make(elem_bt, num_elem);\n-\n-  VectorBoxAllocateNode* alloc = new VectorBoxAllocateNode(C, vbox_type);\n-  set_edges_for_java_call(alloc, \/*must_throw=*\/false, \/*separate_io_proj=*\/true);\n-  make_slow_call_ex(alloc, env()->Throwable_klass(), \/*separate_io_proj=*\/true);\n-  set_i_o(gvn().transform( new ProjNode(alloc, TypeFunc::I_O) ));\n-  set_all_memory(gvn().transform( new ProjNode(alloc, TypeFunc::Memory) ));\n-  Node* ret = gvn().transform(new ProjNode(alloc, TypeFunc::Parms));\n-\n-  assert(check_vbox(vbox_type), \"\");\n-  VectorBoxNode* vbox = new VectorBoxNode(C, ret, vector, vbox_type, vec_type);\n-  return gvn().transform(vbox);\n-}\n-\n-Node* LibraryCallKit::unbox_vector(Node* v, const TypeInstPtr* vbox_type, BasicType elem_bt, int num_elem, bool shuffle_to_vector) {\n-  assert(EnableVectorSupport, \"\");\n-  const TypeInstPtr* vbox_type_v = gvn().type(v)->is_instptr();\n-  if (vbox_type->klass() != vbox_type_v->klass()) {\n-    return NULL; \/\/ arguments don't agree on vector shapes\n-  }\n-  if (vbox_type_v->maybe_null()) {\n-    return NULL; \/\/ no nulls are allowed\n-  }\n-  assert(check_vbox(vbox_type), \"\");\n-  const TypeVect* vec_type = TypeVect::make(elem_bt, num_elem);\n-  Node* unbox = gvn().transform(new VectorUnboxNode(C, vec_type, v, merged_memory(), shuffle_to_vector));\n-  return unbox;\n-}\n-\n@@ -1168,8 +1178,0 @@\n-Node* LibraryCallKit::shift_count(Node* cnt, int shift_op, BasicType bt, int num_elem) {\n-  assert(bt == T_INT || bt == T_LONG || bt == T_SHORT || bt == T_BYTE, \"byte, short, long and int are supported\");\n-  juint mask = (type2aelembytes(bt) * BitsPerByte - 1);\n-  Node* nmask = gvn().transform(ConNode::make(TypeInt::make(mask)));\n-  Node* mcnt = gvn().transform(new AndINode(cnt, nmask));\n-  return gvn().transform(VectorNode::shift_count(shift_op, mcnt, num_elem, bt));\n-}\n-\n@@ -1226,1 +1228,1 @@\n-  Node* opd2 = shift_count(argument(5), opc, elem_bt, num_elem);\n+  Node* opd2 = vector_shift_count(argument(5), opc, elem_bt, num_elem);\n","filename":"src\/hotspot\/share\/opto\/vectorIntrinsics.cpp","additions":71,"deletions":69,"binary":false,"changes":140,"status":"modified"}]}