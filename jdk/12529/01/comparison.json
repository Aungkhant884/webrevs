{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -330,1 +330,1 @@\n-  if (!has_free_compaction_targets) {\n+  if (scope()->do_maximal_compaction() || !has_free_compaction_targets) {\n@@ -351,7 +351,13 @@\n-void G1FullCollector::phase2c_prepare_serial_compaction() {\n-  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n-  \/\/ At this point we know that after parallel compaction there will be no\n-  \/\/ completely free regions. That means that the last region of\n-  \/\/ all compaction queues still have data in them. We try to compact\n-  \/\/ these regions in serial to avoid a premature OOM when the mutator wants\n-  \/\/ to allocate the first eden region after gc.\n+void G1FullCollector::add_regions_for_serial_compaction() {\n+  \/\/ At this point, we know that after parallel compaction there will be regions that\n+  \/\/ are partially compacted into. Thus, the last compaction region of all\n+  \/\/ compaction queues still have space in them. We try to re-compact these regions\n+  \/\/ in serial to avoid a premature OOM when the mutator wants to allocate the first\n+  \/\/ eden region after gc.\n+\n+  \/\/ For maximum compaction, we need to re-prepare all objects above the lowest\n+  \/\/ region among the current regions for all thread compaction points. It may\n+  \/\/ happen that due to the uneven distribution of objects to parallel threads, holes\n+  \/\/ have been created as threads compact to different target regions between the\n+  \/\/ lowest and the highest region in the tails of the compaction points.\n+  uint lowest_current_hr = (uint)-1;\n@@ -361,1 +367,1 @@\n-      serial_compaction_point()->add(cp->remove_last());\n+      lowest_current_hr = MIN2(lowest_current_hr, cp->current_region()->hrm_index());\n@@ -365,0 +371,18 @@\n+  G1FullGCCompactionPoint* serial_cp = serial_compaction_point();\n+  for (uint i = 0; i < workers(); i++) {\n+    G1FullGCCompactionPoint* cp = compaction_point(i);\n+    if (cp->has_regions()) {\n+      cp->move_regions_with_higher_hrm_index(serial_cp, lowest_current_hr);\n+    }\n+  }\n+\n+  \/\/ We use regions as compaction targets in the order they appear in the compaction\n+  \/\/ point. To get maximum compaction and reduce fragmentation, we sort the regions\n+  \/\/ by hrm_index so that we compact objects to one end of the heap.\n+  serial_cp->sort_regions();\n+}\n+\n+void G1FullCollector::phase2c_prepare_serial_compaction() {\n+  GCTraceTime(Debug, gc, phases) debug(\"Phase 2: Prepare serial compaction\", scope()->timer());\n+\n+  add_regions_for_serial_compaction();\n@@ -368,0 +392,1 @@\n+  HeapWord* dense_prefix_top = nullptr;\n@@ -374,0 +399,1 @@\n+      dense_prefix_top = compaction_top(current);\n@@ -376,1 +402,1 @@\n-      G1SerialRePrepareClosure re_prepare(cp, current);\n+      G1SerialRePrepareClosure re_prepare(cp, current, dense_prefix_top);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":37,"deletions":11,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,0 +147,1 @@\n+  void add_regions_for_serial_compaction();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,2 +119,34 @@\n-HeapRegion* G1FullGCCompactionPoint::remove_last() {\n-  return _compaction_regions->pop();\n+int G1FullGCCompactionPoint::compare(HeapRegion* const& hr, HeapRegion* const& e) {\n+  return compare(hr->hrm_index(), e->hrm_index());\n+}\n+\n+void G1FullGCCompactionPoint::sort_regions(){\n+  regions()->sort(compare_ptr);\n+}\n+\n+int G1FullGCCompactionPoint::find_sorted(HeapRegion* hr) {\n+  bool found = false;\n+  int pos = _compaction_regions->find_sorted<HeapRegion*, compare>(hr, found);\n+  if (found) {\n+    return pos;\n+  }\n+  return -1;\n+}\n+\n+void G1FullGCCompactionPoint::move_regions_with_higher_hrm_index(G1FullGCCompactionPoint* cp, uint bottom) {\n+  HeapRegion* cur = current_region();\n+  assert(cur->hrm_index() >= bottom, \"Sanity!\");\n+\n+  HeapRegion* start = nullptr;\n+  for (HeapRegion* r : *_compaction_regions) {\n+    if (r->hrm_index() >= bottom) {\n+      cp->add(r);\n+      if (start == nullptr) {\n+        start = r;\n+      }\n+    }\n+  }\n+\n+  int start_index = find_sorted(start);\n+  assert(start_index >= 0, \"Should have atleast one region\");\n+  _compaction_regions->trunc_to(start_index);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,11 @@\n+  static int compare(uint a, uint b) {\n+    return a > b ? 1 : (a < b) ? -1 : 0;\n+  }\n+\n+  static int compare_ptr(HeapRegion** hr1, HeapRegion** hr2) {\n+    return compare(*hr1, *hr2);\n+  }\n+\n+  static int compare(HeapRegion* const& hr, HeapRegion* const& e);\n+  int find_sorted(HeapRegion* hr);\n+\n@@ -58,1 +69,2 @@\n-  HeapRegion* remove_last();\n+  void move_regions_with_higher_hrm_index(G1FullGCCompactionPoint* cp, uint bottom);\n+  void sort_regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,2 @@\n+  HeapWord* _dense_prefix_top;\n+  uint _bottom_index;\n@@ -125,1 +127,1 @@\n-  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapRegion* hr) :\n+  G1SerialRePrepareClosure(G1FullGCCompactionPoint* hrcp, HeapRegion* hr, HeapWord* dense_prefix_top) :\n@@ -127,1 +129,2 @@\n-    _current(hr) { }\n+    _current(hr),\n+    _dense_prefix_top(dense_prefix_top) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,4 +113,6 @@\n-  \/\/ We only re-prepare objects forwarded within the current region, so\n-  \/\/ skip objects that are already forwarded to another region.\n-  if (obj->is_forwarded() && !_current->is_in(obj->forwardee())) {\n-    return obj->size();\n+  if (obj->is_forwarded()) {\n+    \/\/ We skip objects compiled into the first region or\n+    \/\/ into regions not part of the serial compaction point.\n+    if (cast_from_oop<HeapWord*>(obj->forwardee()) < _dense_prefix_top) {\n+      return obj->size();\n+    }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCPrepareTask.inline.hpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,0 +46,1 @@\n+    _do_maximal_compaction(do_maximal_compaction),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+  bool                    _do_maximal_compaction;\n@@ -71,0 +72,1 @@\n+  bool do_maximal_compaction() { return _do_maximal_compaction; }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCScope.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"}]}