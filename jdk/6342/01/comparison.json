{"files":[{"patch":"@@ -1634,5 +1634,2 @@\n-                        if ((entryLen == nameLen && entry.equals(name)) ||\n-                                (addSlash &&\n-                                nameLen + 1 == entryLen &&\n-                                entry.startsWith(name) &&\n-                                entry.charAt(entryLen - 1) == '\/')) {\n+                        if (entryLen == nameLen && entry.equals(name)) {\n+                            \/\/ Found our match\n@@ -1641,0 +1638,8 @@\n+                        \/\/ If addSlash is true we'll now test for name+\/ providing\n+                        if (addSlash && nameLen + 1 == entryLen\n+                                && entry.startsWith(name) &&\n+                                entry.charAt(entryLen - 1) == '\/') {\n+                            \/\/ Found the entry \"name+\/\", now find the CEN entry pos\n+                            int exactPos = getEntryPos(name, false);\n+                            return exactPos == -1 ? pos : exactPos;\n+                        }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,581 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.JarURLConnection;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Formatter;\n+import java.util.List;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.jar.JarInputStream;\n+import java.util.jar.JarOutputStream;\n+import java.util.stream.Collectors;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipInputStream;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.testng.Assert.*;\n+\n+\/**\n+ * @test\n+ * @bug 8276123\n+ * @summary ZipFile::getEntry will not return a file entry when there is a\n+ * directory entry of the same name within a Zip File\n+ * @run testng\/othervm ZipFileDuplicateEntryTest\n+ *\/\n+public class ZipFileDuplicateEntryTest {\n+\n+    \/**\n+     * Name to use for creating Zip entries\n+     *\/\n+    private static final String ENTRY_NAME = \"entry\";\n+\n+    \/**\n+     * Zip and Jar files to be created\n+     *\/\n+    private static final Path ZIP_FILE = Paths.get(\"fileDirEntry.zip\");\n+    private static final Path ZIP_FILE2 = Paths.get(\"OnlyDirEntry.zip\");\n+    private static final Path DUPLICATE_FILE_ENTRY_FILE = Paths.get(\"DupFIleEntry.zip\");\n+    private static final Path TEST_JAR = Paths.get(\"fileDirEntry.jar\");\n+\n+    \/**\n+     * Directory entry added to the Zip File.\n+     *\/\n+    private static final Entry DIR_ENTRY =\n+            Entry.of(ENTRY_NAME + \"\/\", ZipEntry.DEFLATED,\n+                    \"I am a Directory\");\n+\n+    \/**\n+     * File entry added to the Zip File.\n+     *\/\n+    private static final Entry FILE_ENTRY =\n+            Entry.of(ENTRY_NAME, ZipEntry.DEFLATED, \"I am a File\");\n+\n+    \/**\n+     * Duplicate File entry added to the Zip file. This is the 2nd entry added\n+     * to the Zip file and is expected to be returned.\n+     *\/\n+    private static final Entry DUPLICATE_FILE_ENTRY =\n+            Entry.of(ENTRY_NAME, ZipEntry.DEFLATED, \"Yet another File\");\n+    \/**\n+     * Entries expected to be returned via ZipFile::stream\n+     *\/\n+    private static final List<String> EXPECTED_ENTRIES =\n+            Arrays.asList(FILE_ENTRY.name, DIR_ENTRY.name);\n+\n+    \/**\n+     * Max buffer size for readAllBytes method which can be used when\n+     * InputStream::readAllBytes is not available\n+     *\/\n+    private static final int MAX_BUFFER_SIZE = 1024;\n+\n+    \/**\n+     * Flag to enable test output\n+     *\/\n+    private static final boolean DEBUG = false;\n+\n+    \/**\n+     * Array representing a Jar File with the entries:\n+     * Name: entry, contents: \"I am a File\"\n+     * Name: entry, contents: \"Yet another File\"\n+     * See createByteArray()\n+     *\/\n+    private static final byte[] DUPLICATE_ENTRY_JAR_BYTES = {\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n+            (byte) 0x8, (byte) 0x0, (byte) 0x60, (byte) 0x59, (byte) 0x55, (byte) 0x53, (byte) 0x8e, (byte) 0x39,\n+            (byte) 0x14, (byte) 0x49, (byte) 0xd, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xb, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x5, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x65, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x72, (byte) 0x79, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0xb,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xd,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xf3,\n+            (byte) 0x54, (byte) 0x48, (byte) 0xcc, (byte) 0x55, (byte) 0x48, (byte) 0x54, (byte) 0x70, (byte) 0xcb,\n+            (byte) 0xcc, (byte) 0x49, (byte) 0x5, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x60, (byte) 0x59,\n+            (byte) 0x55, (byte) 0x53, (byte) 0xe1, (byte) 0x4c, (byte) 0x29, (byte) 0xa4, (byte) 0x12, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x5, (byte) 0x0,\n+            (byte) 0x14, (byte) 0x0, (byte) 0x65, (byte) 0x6e, (byte) 0x74, (byte) 0x72, (byte) 0x79, (byte) 0x1,\n+            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x12, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x8b, (byte) 0x4c, (byte) 0x2d, (byte) 0x51, (byte) 0x48,\n+            (byte) 0xcc, (byte) 0xcb, (byte) 0x2f, (byte) 0xc9, (byte) 0x48, (byte) 0x2d, (byte) 0x52, (byte) 0x70,\n+            (byte) 0xcb, (byte) 0xcc, (byte) 0x49, (byte) 0x5, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1,\n+            (byte) 0x2, (byte) 0x14, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n+            (byte) 0x0, (byte) 0x60, (byte) 0x59, (byte) 0x55, (byte) 0x53, (byte) 0x8e, (byte) 0x39, (byte) 0x14,\n+            (byte) 0x49, (byte) 0xd, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xb, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x5, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x65, (byte) 0x6e, (byte) 0x74, (byte) 0x72, (byte) 0x79,\n+            (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x14, (byte) 0x0, (byte) 0x14, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x60, (byte) 0x59, (byte) 0x55, (byte) 0x53,\n+            (byte) 0xe1, (byte) 0x4c, (byte) 0x29, (byte) 0xa4, (byte) 0x12, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x10, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x5, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x44, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x65, (byte) 0x6e,\n+            (byte) 0x74, (byte) 0x72, (byte) 0x79, (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2, (byte) 0x0, (byte) 0x2, (byte) 0x0, (byte) 0x66,\n+            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x8d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n+            (byte) 0x0,\n+    };\n+\n+    \/**\n+     * Create Zip files used by the tests.\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @BeforeTest\n+    public static void setup() throws IOException {\n+\n+        \/**\n+         *  Zip contains two entries named \"entry\" and \"entry\/\"\n+         *\/\n+        Files.deleteIfExists(ZIP_FILE);\n+        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(ZIP_FILE))) {\n+            zos.putNextEntry(new ZipEntry(FILE_ENTRY.name));\n+            zos.write(FILE_ENTRY.bytes);\n+            zos.closeEntry();\n+            zos.putNextEntry(new ZipEntry(DIR_ENTRY.name));\n+            zos.write(DIR_ENTRY.bytes);\n+            zos.closeEntry();\n+        }\n+\n+        \/**\n+         *  Jar contains two entries named \"entry\" and \"entry\/\"\n+         *\/\n+        Files.deleteIfExists(TEST_JAR);\n+        try (JarOutputStream jos = new JarOutputStream(Files.newOutputStream(TEST_JAR))) {\n+            jos.putNextEntry(new JarEntry(FILE_ENTRY.name));\n+            jos.write(FILE_ENTRY.bytes);\n+            jos.closeEntry();\n+            jos.putNextEntry(new JarEntry(DIR_ENTRY.name));\n+            jos.write(DIR_ENTRY.bytes);\n+            jos.closeEntry();\n+        }\n+\n+        \/**\n+         *  Zip contains the entry \"entry\/\"\n+         *\/\n+        Files.deleteIfExists(ZIP_FILE2);\n+        try (ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(ZIP_FILE2))) {\n+            zos.putNextEntry(new ZipEntry(DIR_ENTRY.name));\n+            zos.write(DIR_ENTRY.bytes);\n+            zos.closeEntry();\n+        }\n+\n+        \/**\n+         *  Create a Jar that contains two entries named \"entry\"\n+         *\/\n+        Files.deleteIfExists(DUPLICATE_FILE_ENTRY_FILE);\n+        Files.write(DUPLICATE_FILE_ENTRY_FILE, DUPLICATE_ENTRY_JAR_BYTES);\n+    }\n+\n+    \/**\n+     * Clean up after the test run\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @AfterTest\n+    public static void cleanup() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+        Files.deleteIfExists(ZIP_FILE2);\n+        Files.deleteIfExists(DUPLICATE_FILE_ENTRY_FILE);\n+        Files.deleteIfExists(TEST_JAR);\n+    }\n+\n+    \/**\n+     * DataProvider used to specify the Zip entries to use\n+     *\n+     * @return The Entry to use within the test\n+     *\/\n+    @DataProvider\n+    public Object[][] entries() {\n+        return new Object[][]{\n+                {FILE_ENTRY},\n+                {DIR_ENTRY}\n+        };\n+    }\n+\n+    \/**\n+     * Test whether ZipFile::getEntry can find a directory entry within a Zip\n+     * file specifying \"name\" vs \"name\/\"\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void readDirWithoutSlash() throws IOException {\n+        System.out.printf(\"%n%n**** readDirWithoutSlash ***%n\");\n+        try (ZipFile zip = new ZipFile(ZIP_FILE2.toString())) {\n+            ZipEntry ze = zip.getEntry(ENTRY_NAME);\n+            if (DEBUG) {\n+                System.out.printf(\"    Entry:%s, found:%s%n\", ENTRY_NAME, ze != null);\n+            }\n+            assertNotNull(ze);\n+            assertTrue(ze.isDirectory());\n+            try (InputStream in = zip.getInputStream(ze)) {\n+                byte[] bytes = in.readAllBytes();\n+                if (DEBUG) {\n+                    System.out.printf(\"name: %s, isDirectory: %s, payload= %s%n\",\n+                            ze.getName(), ze.isDirectory(), new String(bytes));\n+                }\n+                assertEquals(bytes, DIR_ENTRY.bytes,\n+                        String.format(\"Expected payload: %s\",\n+                                new String(DIR_ENTRY.bytes)));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate that ZipFile::getEntry will return the correct entry when a file\n+     * and directory have the same name\n+     *\n+     * @param entry The entry to search for\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test(dataProvider = \"entries\")\n+    public void testSameFileDirEntryName(Entry entry) throws IOException {\n+        System.out.printf(\"%n%n**** testSameFileDirEntryName ***%n\");\n+\n+        try (ZipFile zip = new ZipFile(ZIP_FILE.toString())) {\n+            ZipEntry ze = zip.getEntry(entry.name);\n+            if (DEBUG) {\n+                System.out.printf(\"    Entry:%s, found:%s%n\", entry.name, ze != null);\n+            }\n+            assertNotNull(ze);\n+            try (InputStream in = zip.getInputStream(ze)) {\n+                byte[] bytes = in.readAllBytes();\n+                if (DEBUG) {\n+                    System.out.printf(\"name: %s, isDirectory: %s, payload= %s%n\",\n+                            ze.getName(), ze.isDirectory(), new String(bytes));\n+                }\n+                assertEquals(entry.bytes, bytes,\n+                        String.format(\"Expected payload: %s\", new String(entry.bytes)));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Validate that ZipFile::getEntry will return the correct entry, which\n+     * is the second entry, when there are duplicate entries within the Zip file.\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void DupFileEntryTest() throws IOException {\n+        System.out.printf(\"%n%n**** DupFileEntryTest ***%n\");\n+        try (ZipFile zip =\n+                     new ZipFile(DUPLICATE_FILE_ENTRY_FILE.toString())) {\n+            ZipEntry ze = zip.getEntry(ENTRY_NAME);\n+            if (DEBUG) {\n+                System.out.printf(\"    Entry:%s, found:%s%n\", ENTRY_NAME, ze != null);\n+            }\n+            assertNotNull(ze);\n+            try (InputStream in = zip.getInputStream(ze)) {\n+                byte[] bytes = in.readAllBytes();\n+                if (DEBUG) {\n+                    System.out.printf(\"name: %s, isDirectory: %s, payload= %s%n\",\n+                            ze.getName(), ze.isDirectory(), new String(bytes));\n+                }\n+                assertEquals(bytes, DUPLICATE_FILE_ENTRY.bytes,\n+                        String.format(\"Expected payload: %s\", new String(DUPLICATE_FILE_ENTRY.bytes)));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that ZipInputStream can be used to read all Zip entries including\n+     * a file and directory entry with the same name\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void ZipInputStreamTest() throws IOException {\n+        System.out.printf(\"%n%n**** ZipInputStreamTest ***%n\");\n+        try (ZipInputStream zis = new ZipInputStream(\n+                new FileInputStream(ZIP_FILE.toFile()))) {\n+            ZipEntry zipEntry = zis.getNextEntry();\n+            assertNotNull(zipEntry);\n+            while (zipEntry != null) {\n+                Entry e;\n+                if (zipEntry.getName().equals(FILE_ENTRY.name)) {\n+                    e = FILE_ENTRY;\n+                } else if (zipEntry.getName().equals(DIR_ENTRY.name)) {\n+                    e = DIR_ENTRY;\n+                } else {\n+                    throw new RuntimeException(\n+                            String.format(\"Invalid Zip entry: %s\", zipEntry.getName()));\n+                }\n+                assertEquals(zipEntry.getMethod(), e.method);\n+                assertEquals(zis.readAllBytes(), e.bytes,\n+                        String.format(\"Expected payload: %s\", new String(e.bytes)));\n+                zipEntry = zis.getNextEntry();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that ZipFile::stream returns all Zip entries including\n+     * a file and directory entry with the same name\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void ZipFileStreamTest() throws IOException {\n+        System.out.printf(\"%n%n**** ZipFileStreamTest ***%n\");\n+        try (ZipFile zf = new ZipFile(ZIP_FILE.toFile())) {\n+            List<? extends ZipEntry> entries = zf.stream().collect(Collectors.toList());\n+            assertEquals(EXPECTED_ENTRIES.size(), entries.size());\n+            for (ZipEntry e : entries) {\n+                assertTrue(EXPECTED_ENTRIES.contains(e.getName()));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that JarFile can be used to read all the entries including\n+     * a file and directory entry with the same name\n+     *\n+     * @param entry The entry to validate\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test(dataProvider = \"entries\")\n+    public static void JarFileInputStreamTest(Entry entry) throws IOException {\n+        System.out.printf(\"%n%n**** JarFileInputStreamTest ***%n\");\n+        try (JarFile jarFile = new JarFile(TEST_JAR.toFile())) {\n+            JarEntry je = jarFile.getJarEntry(entry.name);\n+            assertNotNull(je);\n+            if (DEBUG) {\n+                System.out.printf(\"Entry Name: %s, method: %s, Expected Method: %s%n\",\n+                        entry.name, je.getMethod(), entry.method);\n+            }\n+            assertEquals(entry.method, je.getMethod());\n+            try (InputStream in = jarFile.getInputStream(je)) {\n+                byte[] bytes = in.readAllBytes();\n+                if (DEBUG) {\n+                    System.out.printf(\"bytes= %s, expected=%s%n\",\n+                            new String(bytes), new String(entry.bytes));\n+                }\n+                assertEquals(bytes, entry.bytes,\n+                        String.format(\"Expected payload: %s\", new String(entry.bytes)));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that JarInputStream can be used to read all entries including\n+     * a file and directory entry with the same name\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void JarInputStreamTest() throws IOException {\n+        System.out.printf(\"%n%n**** JarInputStreamTest ***%n\");\n+        try (JarInputStream jis = new JarInputStream(\n+                new FileInputStream(TEST_JAR.toFile()))) {\n+            JarEntry jarEntry = jis.getNextJarEntry();\n+            assertNotNull(jarEntry);\n+            while (jarEntry != null) {\n+                Entry e;\n+                if (jarEntry.getName().equals(FILE_ENTRY.name)) {\n+                    e = FILE_ENTRY;\n+                } else if (jarEntry.getName().equals(DIR_ENTRY.name)) {\n+                    e = DIR_ENTRY;\n+                } else {\n+                    throw new RuntimeException(\n+                            String.format(\"Invalid Jar entry: %s\", jarEntry.getName()));\n+                }\n+                assertEquals(jarEntry.getMethod(), e.method);\n+                assertEquals(jis.readAllBytes(), e.bytes,\n+                        String.format(\"Expected payload: %s\", new String(e.bytes)));\n+                jarEntry = jis.getNextJarEntry();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that JarURLConnection can be used to access all the entries including\n+     * a file and directory entry with the same name within a jar file\n+     *\n+     * @param entry The entry to validate\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test(dataProvider = \"entries\")\n+    public void JarURLConnectionTest(Entry entry) throws Exception {\n+        System.out.printf(\"%n%n**** JarURLConnectionTest ***%n\");\n+        URL url = new URL(\"jar:\" + TEST_JAR.toUri().toURL() + \"!\/\" + entry.name);\n+        if (DEBUG) {\n+            System.out.printf(\"URL=%s%n\", url);\n+        }\n+        JarURLConnection con = (JarURLConnection) url.openConnection();\n+        con.connect();\n+        JarEntry je = con.getJarEntry();\n+        try (JarFile jarFile = con.getJarFile()) {\n+            assertNotNull(je);\n+            assertNotNull(jarFile);\n+            assertNull(con.getAttributes());\n+            assertNull(con.getMainAttributes());\n+            assertNull(con.getManifest());\n+            assertEquals(je.getName(), entry.name);\n+            assertEquals(con.getEntryName(), entry.name);\n+            assertEquals(je.getMethod(), entry.method);\n+            assertEquals(con.getJarFileURL(), TEST_JAR.toUri().toURL());\n+            if (DEBUG) {\n+                System.out.printf(\"   getEntryName: %s,  getJarFileURL:%s%n\",\n+                        con.getEntryName(), con.getJarFileURL());\n+                System.out.printf(\"   Jar Entry= %s, size= %s%n\", je.getName(), je.getSize());\n+            }\n+\n+            try (InputStream is = jarFile.getInputStream(je)) {\n+                byte[] bytes = is.readAllBytes();\n+                if (DEBUG) {\n+                    System.out.printf(\"   Bytes read:%s%n\", new String(bytes));\n+                }\n+                assertEquals(bytes, entry.bytes,\n+                        String.format(\"Expected payload: %s\", new String(entry.bytes)));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verify that JarFile::stream returns all entries including\n+     * a file and directory entry with the same name\n+     *\n+     * @throws IOException If an error occurs\n+     *\/\n+    @Test\n+    public void JarFileStreamTest() throws IOException {\n+        System.out.printf(\"%n%n**** JarFileStreamTest ***%n\");\n+        try (JarFile jf = new JarFile(TEST_JAR.toFile())) {\n+            List<? extends JarEntry> entries = jf.stream().collect(Collectors.toList());\n+            assertEquals(EXPECTED_ENTRIES.size(), jf.size());\n+            for (JarEntry e : entries) {\n+                assertTrue(EXPECTED_ENTRIES.contains(e.getName()));\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Method used to read  the bytes from an InputStream.  This method is\n+     * here so that the test could be backported to JDK 8 if needed as\n+     * InputStream::readAllBytes() does not exist\n+     *\n+     * @param is The InputStream to read from\n+     * @return The byte array representing bytes read from the InputStream\n+     * @throws IOException If an error occurs\n+     *\/\n+    public static byte[] readAllBytes(InputStream is) throws IOException {\n+        byte[] data = new byte[MAX_BUFFER_SIZE];\n+        ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+        int len;\n+        while ((len = is.read(data, 0, data.length)) != -1) {\n+            buffer.write(data, 0, len);\n+        }\n+        buffer.flush();\n+        return buffer.toByteArray();\n+    }\n+\n+    \/**\n+     * Method used to create a byte[] representing a Jar file with\n+     * duplicate file entries.  This uses ZipArchiveOutputStream as ZipOutputStream\n+     * will fail with a \"java.util.zip.ZipException: duplicate entry\".\n+     *\/\n+\/\/    public static void  createJarWithDuplicateFileEntries() throws IOException {\n+\/\/    Files.deleteIfExists(DUPFILE_ENTRY_FILE);\n+\/\/    try (ZipArchiveOutputStream zos =\n+\/\/                     new ZipArchiveOutputStream(DUPFILE_ENTRY_FILE.toFile())) {\n+\/\/            zos.putArchiveEntry(new ZipArchiveEntry(FILE_ENTRY.name));\n+\/\/            zos.write(FILE_ENTRY.bytes);\n+\/\/            zos.putArchiveEntry(new ZipArchiveEntry(FILE_ENTRY.name));\n+\/\/            zos.write(\"Yet another File\".getBytes(StandardCharsets.UTF_8));\n+\/\/            zos.closeArchiveEntry();\n+\/\/        } catch (IOException e) {\n+\/\/            e.printStackTrace();\n+\/\/        }\n+\/\/        byte[] jarBytes = Files.readAllBytes(DUPFILE_ENTRY_FILE);\n+\/\/        String result = createByteArray(jarBytes, \"DUPLICATE_ENTRY_JAR_BYTES\");\n+\/\/        System.out.println(result);\n+\/\/    }\n+\n+    \/**\n+     * Utility method which takes a byte array and converts to byte array\n+     * declaration.  For example:\n+     * <pre>\n+     *     {@code\n+     *        var fooJar = Files.readAllBytes(Path.of(\"foo.jar\"));\n+     *        var result = createByteArray(fooJar, \"FOOBYTES\");\n+     *      }\n+     * <\/pre>\n+     *\n+     * @param bytes A byte array used to create a byte array declaration\n+     * @param name  Name to be used in the byte array declaration\n+     * @return The formatted byte array declaration\n+     *\/\n+    public static String createByteArray(byte[] bytes, String name) {\n+        StringBuilder sb = new StringBuilder(bytes.length * 5);\n+        Formatter fmt = new Formatter(sb);\n+        fmt.format(\"    public static byte[] %s = {\", name);\n+        final int linelen = 8;\n+        for (int i = 0; i < bytes.length; i++) {\n+            if (i % linelen == 0) {\n+                fmt.format(\"%n        \");\n+            }\n+            fmt.format(\" (byte) 0x%x,\", bytes[i] & 0xff);\n+        }\n+        fmt.format(\"%n    };%n\");\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * Represents an entry in a Zip file. An entry encapsulates a name, a\n+     * compression method, and its contents\/data.\n+     *\/\n+    public static class Entry {\n+        public final String name;\n+        public final int method;\n+        public final byte[] bytes;\n+\n+        public Entry(String name, int method, String contents) {\n+            this.name = name;\n+            this.method = method;\n+            this.bytes = contents.getBytes(StandardCharsets.UTF_8);\n+        }\n+\n+        public static Entry of(String name, int method, String contents) {\n+            return new Entry(name, method, contents);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ZipFileDuplicateEntryTest.java","additions":581,"deletions":0,"binary":false,"changes":581,"status":"added"}]}