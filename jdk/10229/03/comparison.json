{"files":[{"patch":"@@ -971,1 +971,15 @@\n-        if (code == HTTP_CONTINUE && ignoreContinue) {\n+        if (code == 101) {\n+            \/\/ We don't support protocol upgrade through the \"Upgrade:\" request header, so if a\n+            \/\/ server still unexpectedly sends a 101 response, we consider that a protocol violation\n+            \/\/ and close the connection.\n+            closeServer();\n+            logFinest(\"Closed connection due to unexpected 101 response\");\n+            \/\/ clear off the response headers so that they don't get propagated\n+            \/\/ to the application\n+            responses.reset();\n+            throw new ProtocolException(\"Unexpected 101 response from server\");\n+        }\n+        \/\/ ignore interim informational responses and continue to wait for final response.\n+        if ((code == HTTP_CONTINUE && ignoreContinue)\n+                || (code >= 102 && code <= 199)) {\n+            logFinest(\"Ignoring interim informational 1xx response: \" + code);\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/HttpClient.java","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,227 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.InetAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+\n+import jdk.test.lib.net.URIBuilder;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterClass;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n+\/**\n+ * @test\n+ * @bug 8170305\n+ * @summary Tests behaviour of HttpURLConnection when server responds with 1xx interim response status codes\n+ * @library \/test\/lib\n+ * @run testng Response1xxTest\n+ *\/\n+public class Response1xxTest {\n+    private static final String EXPECTED_RSP_BODY = \"Hello World\";\n+\n+    private ServerSocket serverSocket;\n+    private Http11Server server;\n+    private String requestURIBase;\n+\n+\n+    @BeforeClass\n+    public void setup() throws Exception {\n+        serverSocket = new ServerSocket(0, 0, InetAddress.getLoopbackAddress());\n+        server = new Http11Server(serverSocket);\n+        new Thread(server).start();\n+        requestURIBase = URIBuilder.newBuilder().scheme(\"http\").loopback()\n+                .port(serverSocket.getLocalPort()).build().toString();\n+    }\n+\n+    @AfterClass\n+    public void teardown() throws Exception {\n+        if (server != null) {\n+            server.stop = true;\n+            System.out.println(\"(HTTP 1.1) Server stop requested\");\n+        }\n+        if (serverSocket != null) {\n+            serverSocket.close();\n+            System.out.println(\"Closed (HTTP 1.1) server socket\");\n+        }\n+    }\n+\n+    private static final class Http11Server implements Runnable {\n+        private static final int CONTENT_LENGTH = EXPECTED_RSP_BODY.getBytes(StandardCharsets.UTF_8).length;\n+\n+        private static final String HTTP_1_1_RSP_200 = \"HTTP\/1.1 200 OK\\r\\n\" +\n+                \"Content-Length: \" + CONTENT_LENGTH + \"\\r\\n\\r\\n\" +\n+                EXPECTED_RSP_BODY;\n+\n+        private static final String REQ_LINE_FOO = \"GET \/test\/foo HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BAR = \"GET \/test\/bar HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_HELLO = \"GET \/test\/hello HTTP\/1.1\\r\\n\";\n+        private static final String REQ_LINE_BYE = \"GET \/test\/bye HTTP\/1.1\\r\\n\";\n+\n+\n+        private final ServerSocket serverSocket;\n+        private volatile boolean stop;\n+\n+        private Http11Server(final ServerSocket serverSocket) {\n+            this.serverSocket = serverSocket;\n+        }\n+\n+        @Override\n+        public void run() {\n+            System.out.println(\"Server running at \" + serverSocket);\n+            while (!stop) {\n+                Socket socket = null;\n+                try {\n+                    \/\/ accept a connection\n+                    socket = serverSocket.accept();\n+                    System.out.println(\"Accepted connection from client \" + socket);\n+                    \/\/ read request\n+                    final String requestLine;\n+                    try {\n+                        requestLine = readRequestLine(socket);\n+                    } catch (Throwable t) {\n+                        \/\/ ignore connections from potential rogue client\n+                        System.err.println(\"Ignoring connection\/request from client \" + socket\n+                                + \" due to exception:\");\n+                        t.printStackTrace();\n+                        \/\/ close the socket\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    System.out.println(\"Received following request line from client \" + socket\n+                            + \" :\\n\" + requestLine);\n+                    final int informationalResponseCode;\n+                    if (requestLine.startsWith(REQ_LINE_FOO)) {\n+                        \/\/ we will send intermediate\/informational 102 response\n+                        informationalResponseCode = 102;\n+                    } else if (requestLine.startsWith(REQ_LINE_BAR)) {\n+                        \/\/ we will send intermediate\/informational 103 response\n+                        informationalResponseCode = 103;\n+                    } else if (requestLine.startsWith(REQ_LINE_HELLO)) {\n+                        \/\/ we will send intermediate\/informational 100 response\n+                        informationalResponseCode = 100;\n+                    } else if (requestLine.startsWith(REQ_LINE_BYE)) {\n+                        \/\/ we will send intermediate\/informational 101 response\n+                        informationalResponseCode = 101;\n+                    } else {\n+                        \/\/ unexpected client. ignore and close the client\n+                        System.err.println(\"Ignoring unexpected request from client \" + socket);\n+                        safeClose(socket);\n+                        continue;\n+                    }\n+                    try (final OutputStream os = socket.getOutputStream()) {\n+                        \/\/ send informational response headers a few times (spec allows them to\n+                        \/\/ be sent multiple times)\n+                        for (int i = 0; i < 3; i++) {\n+                            \/\/ send 1xx response header\n+                            os.write((\"HTTP\/1.1 \" + informationalResponseCode + \"\\r\\n\\r\\n\")\n+                                    .getBytes(StandardCharsets.UTF_8));\n+                            os.flush();\n+                            System.out.println(\"Sent response code \" + informationalResponseCode\n+                                    + \" to client \" + socket);\n+                        }\n+                        \/\/ now send a final response\n+                        System.out.println(\"Now sending 200 response code to client \" + socket);\n+                        os.write(HTTP_1_1_RSP_200.getBytes(StandardCharsets.UTF_8));\n+                        os.flush();\n+                        System.out.println(\"Sent 200 response code to client \" + socket);\n+                    }\n+                } catch (Throwable t) {\n+                    \/\/ close the client connection\n+                    safeClose(socket);\n+                    \/\/ continue accepting any other client connections until we are asked to stop\n+                    System.err.println(\"Ignoring exception in server:\");\n+                    t.printStackTrace();\n+                }\n+            }\n+        }\n+\n+        static String readRequestLine(final Socket sock) throws IOException {\n+            final InputStream is = sock.getInputStream();\n+            final StringBuilder sb = new StringBuilder(\"\");\n+            byte[] buf = new byte[1024];\n+            while (!sb.toString().endsWith(\"\\r\\n\\r\\n\")) {\n+                final int numRead = is.read(buf);\n+                if (numRead == -1) {\n+                    return sb.toString();\n+                }\n+                final String part = new String(buf, 0, numRead, StandardCharsets.ISO_8859_1);\n+                sb.append(part);\n+            }\n+            return sb.toString();\n+        }\n+\n+        private static void safeClose(final Socket socket) {\n+            try {\n+                socket.close();\n+            } catch (Throwable t) {\n+                \/\/ ignore\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP\/1.1 server sends intermediate 1xx response codes and then the final\n+     * response, the client (internally) will ignore those intermediate informational response codes\n+     * and only return the final response to the application\n+     *\/\n+    @Test\n+    public void test1xx() throws Exception {\n+        final URI[] requestURIs = new URI[]{\n+                new URI(requestURIBase + \"\/test\/foo\"),\n+                new URI(requestURIBase + \"\/test\/bar\"),\n+                new URI(requestURIBase + \"\/test\/hello\")};\n+        for (final URI requestURI : requestURIs) {\n+            System.out.println(\"Issuing request to \" + requestURI);\n+            final HttpURLConnection urlConnection = (HttpURLConnection) requestURI.toURL().openConnection();\n+            final int responseCode = urlConnection.getResponseCode();\n+            Assert.assertEquals(responseCode, 200, \"Unexpected response code\");\n+            final String body;\n+            try (final InputStream is = urlConnection.getInputStream()) {\n+                final byte[] bytes = is.readAllBytes();\n+                body = new String(bytes, StandardCharsets.UTF_8);\n+            }\n+            Assert.assertEquals(body, EXPECTED_RSP_BODY, \"Unexpected response body\");\n+        }\n+    }\n+\n+    \/**\n+     * Tests that when a HTTP\/1.1 server sends 101 response code, when the client\n+     * didn't ask for a connection upgrade, then the request fails with an exception.\n+     *\/\n+    @Test\n+    public void test101CausesRequestFailure() throws Exception {\n+        final URI requestURI = new URI(requestURIBase + \"\/test\/bye\");\n+        System.out.println(\"Issuing request to \" + requestURI);\n+        final HttpURLConnection urlConnection = (HttpURLConnection) requestURI.toURL().openConnection();\n+        \/\/ we expect the request to fail because the server unexpectedly sends a 101 response\n+        Assert.assertThrows(IOException.class, () -> urlConnection.getResponseCode());\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/HttpURLConnection\/Response1xxTest.java","additions":227,"deletions":0,"binary":false,"changes":227,"status":"added"}]}