{"files":[{"patch":"@@ -122,2 +122,2 @@\n-  GrowableArray<Node*> storestore_worklist;\n-  GrowableArray<ArrayCopyNode*> arraycopy_worklist;\n+  GrowableArray<MemBarStoreStoreNode*> storestore_worklist;\n+  GrowableArray<ArrayCopyNode*>  arraycopy_worklist;\n@@ -129,0 +129,1 @@\n+  GrowableArray<MergeMemNode*>   mergemem_worklist;\n@@ -164,16 +165,25 @@\n-    if (n->is_MergeMem()) {\n-      \/\/ Collect all MergeMem nodes to add memory slices for\n-      \/\/ scalar replaceable objects in split_unique_types().\n-      _mergemem_worklist.append(n->as_MergeMem());\n-    } else if (OptimizePtrCompare && n->is_Cmp() &&\n-               (n->Opcode() == Op_CmpP || n->Opcode() == Op_CmpN)) {\n-      \/\/ Collect compare pointers nodes.\n-      ptr_cmp_worklist.append(n);\n-    } else if (n->is_MemBarStoreStore()) {\n-      \/\/ Collect all MemBarStoreStore nodes so that depending on the\n-      \/\/ escape status of the associated Allocate node some of them\n-      \/\/ may be eliminated.\n-      storestore_worklist.append(n);\n-    } else if (n->is_MemBar() && (n->Opcode() == Op_MemBarRelease) &&\n-               (n->req() > MemBarNode::Precedent)) {\n-      record_for_optimizer(n);\n+    \/\/ Collect some interesting nodes for futher use.\n+    switch(n->Opcode()) {\n+      case Op_MergeMem:\n+        \/\/ Collect all MergeMem nodes to add memory slices for\n+        \/\/ scalar replaceable objects in split_unique_types().\n+        mergemem_worklist.append(n->as_MergeMem());\n+        break;\n+      case Op_CmpP:\n+      case Op_CmpN:\n+        \/\/ Collect compare pointers nodes.\n+        if (OptimizePtrCompare) {\n+          ptr_cmp_worklist.append(n);\n+        }\n+        break;\n+      case Op_MemBarStoreStore:\n+        \/\/ Collect all MemBarStoreStore nodes so that depending on the\n+        \/\/ escape status of the associated Allocate node some of them\n+        \/\/ may be eliminated.\n+        storestore_worklist.append(n->as_MemBarStoreStore());\n+        break;\n+      case Op_MemBarRelease:\n+        if (n->req() > MemBarNode::Precedent) {\n+          record_for_optimizer(n);\n+        }\n+        break;\n@@ -181,3 +191,4 @@\n-    } else if (n->is_AddP()) {\n-      \/\/ Collect address nodes for graph verification.\n-      addp_worklist.append(n);\n+      case Op_AddP:\n+        \/\/ Collect address nodes for graph verification.\n+        addp_worklist.append(n);\n+        break;\n@@ -185,4 +196,8 @@\n-    } else if (n->is_ArrayCopy()) {\n-      \/\/ Keep a list of ArrayCopy nodes so if one of its input is non\n-      \/\/ escaping, we can record a unique type\n-      arraycopy_worklist.append(n->as_ArrayCopy());\n+      case Op_ArrayCopy:\n+        \/\/ Keep a list of ArrayCopy nodes so if one of its input is non\n+        \/\/ escaping, we can record a unique type\n+        arraycopy_worklist.append(n->as_ArrayCopy());\n+        break;\n+      default:\n+        \/\/ not interested now, ignore...\n+        break;\n@@ -194,1 +209,1 @@\n-    if (n-> is_SafePoint()) {\n+    if (n->is_SafePoint()) {\n@@ -305,1 +320,1 @@\n-    split_unique_types(alloc_worklist, arraycopy_worklist);\n+    split_unique_types(alloc_worklist, arraycopy_worklist, mergemem_worklist);\n@@ -503,2 +518,1 @@\n-      add_local_var_and_edge(n, PointsToNode::NoEscape,\n-                             n->in(1), delayed_worklist);\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), delayed_worklist);\n@@ -571,2 +585,1 @@\n-        add_local_var_and_edge(n, PointsToNode::NoEscape,\n-                               n->in(0), delayed_worklist);\n+        add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), delayed_worklist);\n@@ -581,2 +594,1 @@\n-        add_local_var_and_edge(n, PointsToNode::GlobalEscape,\n-                               n->in(TypeFunc::Parms), delayed_worklist);\n+        add_local_var_and_edge(n, PointsToNode::GlobalEscape, n->in(TypeFunc::Parms), delayed_worklist);\n@@ -627,11 +639,0 @@\n-#ifdef ASSERT\n-#define ELSE_FAIL(name)                               \\\n-      \/* Should not be called for not pointer type. *\/  \\\n-      n->dump(1);                                       \\\n-      assert(false, name);                              \\\n-      break;\n-#else\n-#define ELSE_FAIL(name) \\\n-      break;\n-#endif\n-\n@@ -672,2 +673,1 @@\n-      add_local_var_and_edge(n, PointsToNode::NoEscape,\n-                             n->in(1), NULL);\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(1), NULL);\n@@ -697,7 +697,4 @@\n-      const Type* t = _igvn->type(n);\n-      if (t->make_ptr() != NULL) {\n-        Node* adr = n->in(MemNode::Address);\n-        add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_LoadP\");\n+      assert(_igvn->type(n)->make_ptr() != NULL,\n+             \"constrain must match when firstly add to cg\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), NULL);\n+      break;\n@@ -708,14 +705,6 @@\n-      const Type* t = n->as_Phi()->type();\n-      if (t->make_ptr() != NULL) {\n-        for (uint i = 1; i < n->req(); i++) {\n-          Node* in = n->in(i);\n-          if (in == NULL) {\n-            continue;  \/\/ ignore NULL\n-          }\n-          Node* uncast_in = in->uncast();\n-          if (uncast_in->is_top() || uncast_in == n) {\n-            continue;  \/\/ ignore top or inputs which go back this node\n-          }\n-          PointsToNode* ptn = ptnode_adr(in->_idx);\n-          assert(ptn != NULL, \"node should be registered\");\n-          add_edge(n_ptn, ptn);\n+      assert(n->as_Phi()->type()->make_ptr() != NULL,\n+             \"constrain must match when firstly add to cg\");\n+      for (uint i = 1; i < n->req(); i++) {\n+        Node* in = n->in(i);\n+        if (in == NULL) {\n+          continue;  \/\/ ignore NULL\n@@ -723,1 +712,7 @@\n-        break;\n+        Node* uncast_in = in->uncast();\n+        if (uncast_in->is_top() || uncast_in == n) {\n+          continue;  \/\/ ignore top or inputs which go back this node\n+        }\n+        PointsToNode* ptn = ptnode_adr(in->_idx);\n+        assert(ptn != NULL, \"node should be registered\");\n+        add_edge(n_ptn, ptn);\n@@ -725,1 +720,1 @@\n-      ELSE_FAIL(\"Op_Phi\");\n+      break;\n@@ -729,6 +724,5 @@\n-      if (n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->is_Call() &&\n-          n->in(0)->as_Call()->returns_pointer()) {\n-        add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), NULL);\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_Proj\");\n+      assert(n->as_Proj()->_con == TypeFunc::Parms && n->in(0)->is_Call() &&\n+             n->in(0)->as_Call()->returns_pointer(),\n+             \"constrain must match when firstly add to cg\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(0), NULL);\n+      break;\n@@ -738,8 +732,5 @@\n-      if (n->req() > TypeFunc::Parms &&\n-          _igvn->type(n->in(TypeFunc::Parms))->isa_oopptr()) {\n-        \/\/ Treat Return value as LocalVar with GlobalEscape escape state.\n-        add_local_var_and_edge(n, PointsToNode::GlobalEscape,\n-                               n->in(TypeFunc::Parms), NULL);\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_Return\");\n+      assert(n->req() > TypeFunc::Parms && _igvn->type(n->in(TypeFunc::Parms))->isa_oopptr(),\n+             \"constrain must match when firstly add to cg\");\n+      \/\/ Treat Return value as LocalVar with GlobalEscape escape state.\n+      add_local_var_and_edge(n, PointsToNode::GlobalEscape, n->in(TypeFunc::Parms), NULL);\n+      break;\n@@ -747,4 +738,0 @@\n-    case Op_StoreP:\n-    case Op_StoreN:\n-    case Op_StoreNKlass:\n-    case Op_StorePConditional:\n@@ -753,0 +740,7 @@\n+    case Op_GetAndSetP:\n+    case Op_GetAndSetN:{\n+      assert(_igvn->type(n)->make_ptr() != NULL,\n+             \"constrain must match when firstly add to cg\");\n+      add_local_var_and_edge(n, PointsToNode::NoEscape, n->in(MemNode::Address), NULL);\n+      \/\/ fall-through\n+    }\n@@ -757,6 +751,6 @@\n-    case Op_GetAndSetP:\n-    case Op_GetAndSetN: {\n-      if (add_final_edges_unsafe_access(n, opcode)) {\n-        break;\n-      }\n-      ELSE_FAIL(\"Op_StoreP\");\n+    case Op_StoreP:\n+    case Op_StoreN:\n+    case Op_StoreNKlass:\n+    case Op_StorePConditional:{\n+      add_final_edges_unsafe_access(n, opcode);\n+      break;\n@@ -853,5 +847,0 @@\n-  if (opcode == Op_GetAndSetP || opcode == Op_GetAndSetN ||\n-      opcode == Op_CompareAndExchangeN || opcode == Op_CompareAndExchangeP) {\n-    add_local_var_and_edge(n, PointsToNode::NoEscape, adr, NULL);\n-  }\n-\n@@ -886,0 +875,4 @@\n+#ifdef ASSERT\n+    n->dump(1);\n+    assert(false, \"not unsafe\");\n+#endif\n@@ -1976,1 +1969,1 @@\n-                                           GrowableArray<Node*>& storestore_worklist) {\n+                                           GrowableArray<MemBarStoreStoreNode*>& storestore_worklist) {\n@@ -2026,1 +2019,0 @@\n-    assert(storestore->is_MemBarStoreStore(), \"\");\n@@ -2041,0 +2033,1 @@\n+  assert(n->Opcode() == Op_CmpN || n->Opcode() == Op_CmpP, \"must be\");\n@@ -3073,1 +3066,3 @@\n-void ConnectionGraph::split_unique_types(GrowableArray<Node *>  &alloc_worklist, GrowableArray<ArrayCopyNode*> &arraycopy_worklist) {\n+void ConnectionGraph::split_unique_types(GrowableArray<Node *>  &alloc_worklist,\n+                                         GrowableArray<ArrayCopyNode*> &arraycopy_worklist,\n+                                         GrowableArray<MergeMemNode*> &mergemem_worklist) {\n@@ -3312,1 +3307,1 @@\n-        assert(_mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n+        assert(mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n@@ -3318,1 +3313,1 @@\n-          assert(_mergemem_worklist.contains(m->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n+          assert(mergemem_worklist.contains(m->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n@@ -3451,1 +3446,1 @@\n-        assert(_mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n+        assert(mergemem_worklist.contains(use->as_MergeMem()), \"EA: missing MergeMem node in the worklist\");\n@@ -3479,1 +3474,1 @@\n-  uint length = _mergemem_worklist.length();\n+  uint length = mergemem_worklist.length();\n@@ -3481,1 +3476,1 @@\n-    MergeMemNode* nmm = _mergemem_worklist.at(next);\n+    MergeMemNode* nmm = mergemem_worklist.at(next);\n","filename":"src\/hotspot\/share\/opto\/escape.cpp","additions":101,"deletions":106,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -461,1 +461,1 @@\n-                            GrowableArray<Node*>& storestore_worklist);\n+                            GrowableArray<MemBarStoreStoreNode*>& storestore_worklist);\n@@ -524,1 +524,3 @@\n-  void split_unique_types(GrowableArray<Node *>  &alloc_worklist, GrowableArray<ArrayCopyNode*> &arraycopy_worklist);\n+  void split_unique_types(GrowableArray<Node *>  &alloc_worklist,\n+                          GrowableArray<ArrayCopyNode*> &arraycopy_worklist,\n+                          GrowableArray<MergeMemNode*> &mergemem_worklist);\n@@ -536,3 +538,0 @@\n-\n-  GrowableArray<MergeMemNode*>  _mergemem_worklist; \/\/ List of all MergeMem nodes\n-\n","filename":"src\/hotspot\/share\/opto\/escape.hpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"}]}