{"files":[{"patch":"@@ -48,1 +48,1 @@\n-\/\/ the value of r may be NULL.\n+\/\/ the value of r may be nullptr.\n@@ -108,1 +108,1 @@\n-  \/\/ first object, or NULL if the queue was empty.  If unsuccessful, because\n+  \/\/ first object, or nullptr if the queue was empty.  If unsuccessful, because\n@@ -114,3 +114,3 @@\n-  \/\/ Thread-safe remove and return the first object in the queue, or NULL if\n-  \/\/ the queue was empty.  This just iterates on try_pop() until it\n-  \/\/ succeeds, returning the (possibly NULL) element obtained from that.\n+  \/\/ Thread-safe remove and return the first object in the queue, or nullptr\n+  \/\/ if the queue was empty.  This just iterates on try_pop() until it\n+  \/\/ succeeds, returning the (possibly nullptr) element obtained from that.\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-NonblockingQueue<T, next_ptr>::NonblockingQueue() : _head(NULL), _tail(NULL) {}\n+NonblockingQueue<T, next_ptr>::NonblockingQueue() : _head(nullptr), _tail(nullptr) {}\n@@ -48,2 +48,2 @@\n-  assert(_head == NULL, \"precondition\");\n-  assert(_tail == NULL, \"precondition\");\n+  assert(_head == nullptr, \"precondition\");\n+  assert(_tail == nullptr, \"precondition\");\n@@ -64,1 +64,1 @@\n-  return head == NULL ? end_marker() : head;\n+  return head == nullptr ? end_marker() : head;\n@@ -74,1 +74,1 @@\n-  return Atomic::load(&_head) == NULL;\n+  return Atomic::load(&_head) == nullptr;\n@@ -88,2 +88,2 @@\n-\/\/ appended. If the old tail is NULL then the queue was empty, then the head\n-\/\/ of the list being appended is instead stored in the queue head.\n+\/\/ appended. If the old tail is nullptr then the queue was empty, then the\n+\/\/ head of the list being appended is instead stored in the queue head.\n@@ -103,1 +103,1 @@\n-  assert(next(last) == NULL, \"precondition\");\n+  assert(next(last) == nullptr, \"precondition\");\n@@ -109,3 +109,3 @@\n-  if (old_tail == NULL) {\n-    \/\/ If old_tail is NULL then the queue was empty, and _head must also be\n-    \/\/ NULL.  The correctness of this assertion depends on try_pop clearing\n+  if (old_tail == nullptr) {\n+    \/\/ If old_tail is nullptr then the queue was empty, and _head must also be\n+    \/\/ nullptr.  The correctness of this assertion depends on try_pop clearing\n@@ -113,1 +113,1 @@\n-    assert(Atomic::load(&_head) == NULL, \"invariant\");\n+    assert(Atomic::load(&_head) == nullptr, \"invariant\");\n@@ -129,1 +129,1 @@\n-    \/\/ list.  The queue was logically empty.  _head is either NULL or\n+    \/\/ list.  The queue was logically empty.  _head is either nullptr or\n@@ -132,1 +132,1 @@\n-    assert((old_head == NULL) || (old_head == old_tail), \"invariant\");\n+    assert((old_head == nullptr) || (old_head == old_tail), \"invariant\");\n@@ -145,2 +145,2 @@\n-  if (old_head == NULL) {\n-    *node_ptr = NULL;\n+  if (old_head == nullptr) {\n+    *node_ptr = nullptr;\n@@ -155,1 +155,1 @@\n-    \/\/ (2) next_node is NULL, because a competing try_pop took old_head.\n+    \/\/ (2) next_node is nullptr, because a competing try_pop took old_head.\n@@ -169,1 +169,1 @@\n-    } else if (next_node == NULL) {\n+    } else if (next_node == nullptr) {\n@@ -174,2 +174,2 @@\n-      \/\/ _head to NULL, \"helping\" the competing try_pop.  _head will remain\n-      \/\/ NULL until a subsequent push\/append.  This is a lost race, and we\n+      \/\/ _head to nullptr, \"helping\" the competing try_pop.  _head will remain\n+      \/\/ nullptr until a subsequent push\/append.  This is a lost race, and we\n@@ -178,1 +178,1 @@\n-      \/\/ trying to set _tail to NULL, as that would just ensure that one or\n+      \/\/ trying to set _tail to nullptr, as that would just ensure that one or\n@@ -186,1 +186,1 @@\n-      set_next(*old_head, NULL);\n+      set_next(*old_head, nullptr);\n@@ -191,1 +191,1 @@\n-  } else if (is_end(Atomic::cmpxchg(next_ptr(*old_head), next_node, (T*)NULL))) {\n+  } else if (is_end(Atomic::cmpxchg(next_ptr(*old_head), next_node, (T*)nullptr))) {\n@@ -194,1 +194,1 @@\n-    \/\/ value to NULL.  However, this leaves the queue in disarray.  Fix up\n+    \/\/ value to nullptr.  However, this leaves the queue in disarray.  Fix up\n@@ -203,2 +203,2 @@\n-    \/\/ Attempt to change the queue head from old_head to NULL.  Failure of the\n-    \/\/ cmpxchg indicates a concurrent operation updated _head first.  That\n+    \/\/ Attempt to change the queue head from old_head to nullptr.  Failure of\n+    \/\/ the cmpxchg indicates a concurrent operation updated _head first.  That\n@@ -206,1 +206,1 @@\n-    Atomic::cmpxchg(&_head, old_head, (T*)NULL);\n+    Atomic::cmpxchg(&_head, old_head, (T*)nullptr);\n@@ -208,2 +208,2 @@\n-    \/\/ Attempt to change the queue tail from old_head to NULL.  Failure of the\n-    \/\/ cmpxchg indicates that a concurrent push\/append updated _tail first.\n+    \/\/ Attempt to change the queue tail from old_head to nullptr.  Failure of\n+    \/\/ the cmpxchg indicates that a concurrent push\/append updated _tail first.\n@@ -212,1 +212,1 @@\n-    Atomic::cmpxchg(&_tail, old_head, (T*)NULL);\n+    Atomic::cmpxchg(&_tail, old_head, (T*)nullptr);\n@@ -229,1 +229,1 @@\n-  T* result = NULL;\n+  T* result = nullptr;\n@@ -241,1 +241,1 @@\n-  if (tail != NULL) set_next(*tail, NULL); \/\/ Clear end marker.\n+  if (tail != nullptr) set_next(*tail, nullptr); \/\/ Clear end marker.\n@@ -243,2 +243,2 @@\n-  Atomic::store(&_head, (T*)NULL);\n-  Atomic::store(&_tail, (T*)NULL);\n+  Atomic::store(&_head, (T*)nullptr);\n+  Atomic::store(&_tail, (T*)nullptr);\n","filename":"src\/hotspot\/share\/utilities\/nonblockingQueue.inline.hpp","additions":34,"deletions":34,"binary":false,"changes":68,"status":"modified"}]}