{"files":[{"patch":"@@ -29,1 +29,3 @@\n-import java.io.CharArrayWriter;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.charset.CharacterCodingException;\n@@ -31,0 +33,3 @@\n+import java.nio.charset.CharsetEncoder;\n+import java.nio.charset.CoderResult;\n+import java.nio.charset.CodingErrorAction;\n@@ -141,5 +146,0 @@\n-    private static void encodeByte(StringBuilder out, byte b) {\n-        out.append('%');\n-        HexFormat.of().withUpperCase().toHexDigits(out, b);\n-    }\n-\n@@ -208,0 +208,2 @@\n+    private static final int ENCODING_CHUNK_SIZE = 8;\n+\n@@ -242,1 +244,0 @@\n-        CharArrayWriter charArrayWriter = new CharArrayWriter();\n@@ -247,0 +248,6 @@\n+        CharsetEncoder ce = charset.newEncoder()\n+                .onMalformedInput(CodingErrorAction.REPLACE)\n+                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n+        CharBuffer cb = CharBuffer.allocate(ENCODING_CHUNK_SIZE);\n+        ByteBuffer bb = ByteBuffer.allocate((int)(ENCODING_CHUNK_SIZE * ce.maxBytesPerChar()));\n+\n@@ -258,1 +265,1 @@\n-                    charArrayWriter.write(c);\n+                    cb.put(c);\n@@ -271,1 +278,1 @@\n-                                charArrayWriter.write(d);\n+                                cb.put(d);\n@@ -276,0 +283,5 @@\n+                    \/\/ Limit to ENCODING_CHUNK_SIZE - 1 so that we can always fit in\n+                    \/\/ a surrogate pair on the next iteration\n+                    if (cb.position() >= ENCODING_CHUNK_SIZE - 1) {\n+                        flushToStringBuilder(out, ce, cb, bb, false);\n+                    }\n@@ -278,7 +290,1 @@\n-\n-                String str = charArrayWriter.toString();\n-                byte[] ba = str.getBytes(charset);\n-                for (byte b : ba) {\n-                    encodeByte(out, b);\n-                }\n-                charArrayWriter.reset();\n+                flushToStringBuilder(out, ce, cb, bb, true);\n@@ -287,1 +293,0 @@\n-\n@@ -290,0 +295,42 @@\n+\n+    \/**\n+     * Encodes input chars in cb and appends the byte values in an escaped format\n+     * (\"%FF\") to out. The temporary byte buffer, bb, must be able to accept\n+     * cb.position() * ce.maxBytesPerChar() bytes.\n+     *\n+     * @param out the StringBuilder to output encoded and escaped bytes to\n+     * @param ce charset encoder. Will be reset if endOfInput is true\n+     * @param cb input buffer, will be cleared\n+     * @param bb output buffer, will be cleared\n+     * @param endOfInput true if this is the last flush for an encoding chunk,\n+     *                  to all bytes in ce is flushed to out and reset\n+     *\/\n+    private static void flushToStringBuilder(StringBuilder out,\n+                                             CharsetEncoder ce,\n+                                             CharBuffer cb,\n+                                             ByteBuffer bb,\n+                                             boolean endOfInput) {\n+        cb.flip();\n+        try {\n+            CoderResult cr = ce.encode(cb, bb, endOfInput);\n+            if (!cr.isUnderflow())\n+                cr.throwException();\n+            if (endOfInput) {\n+                cr = ce.flush(bb);\n+                if (!cr.isUnderflow())\n+                    cr.throwException();\n+                ce.reset();\n+            }\n+        } catch (CharacterCodingException x) {\n+            throw new Error(x); \/\/ Can't happen\n+        }\n+        HexFormat hex = HexFormat.of().withUpperCase();\n+        byte[] bytes = bb.array();\n+        int len = bb.position();\n+        for (int i = 0; i < len; i++) {\n+            out.append('%');\n+            hex.toHexDigits(out, bytes[i]);\n+        }\n+        cb.clear();\n+        bb.clear();\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/net\/URLEncoder.java","additions":64,"deletions":17,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -682,1 +682,0 @@\n-        Objects.requireNonNull(out, \"out\");\n@@ -684,1 +683,1 @@\n-            out.append(toHighHexDigit(value));\n+            out.append(toHighHexDigit(value)); \/\/ implicit null-check\n","filename":"src\/java.base\/share\/classes\/java\/util\/HexFormat.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+                {\"\\u0101\\u0101\\u0101\\u0101\\u0101\\u0101\\uDBFF\\uDC00\\u0101\", \"%C4%81%C4%81%C4%81%C4%81%C4%81%C4%81%F4%8F%B0%80%C4%81\"},\n+                {\"\\u0101\\u0101\\u0101\\u0101\\u0101\\u0101\\u0101\\uDBFF\\uDC00\\u0101\", \"%C4%81%C4%81%C4%81%C4%81%C4%81%C4%81%C4%81%F4%8F%B0%80%C4%81\"},\n+                {\"\\u0101\\u0101\\u0101\\u0101\\u0101\\u0101\\u0101\\u0101\\uDBFF\\uDC00\\u0101\", \"%C4%81%C4%81%C4%81%C4%81%C4%81%C4%81%C4%81%C4%81%F4%8F%B0%80%C4%81\"},\n","filename":"test\/jdk\/java\/net\/URLEncoder\/SurrogatePairs.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -193,0 +193,14 @@\n+    @Benchmark\n+    public void testEncodeLatin1(Blackhole bh) throws UnsupportedEncodingException {\n+        for (String s : testStringsEncode) {\n+            bh.consume(java.net.URLEncoder.encode(s, StandardCharsets.ISO_8859_1));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testDecodeLatin1(Blackhole bh) throws UnsupportedEncodingException {\n+        for (String s : testStringsDecode) {\n+            bh.consume(URLDecoder.decode(s, StandardCharsets.ISO_8859_1));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/net\/URLEncodeDecode.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"}]}