{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -171,1 +171,1 @@\n-    private static boolean isJavaIdentifier(String str) {\n+    public static boolean isJavaIdentifier(String str) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/Checks.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.module.Checks;\n@@ -138,1 +139,1 @@\n-            if (!Type.isValidJavaIdentifier(v.getName())) {\n+            if (!Checks.isJavaIdentifier(v.getName())) {\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/EventFactory.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,7 @@\n- * The name must be a valid identifier as specified in the Java language (for\n- * example, {@code \"com.example.Transaction\"} for an event class or\n- * {@code \"message\"} for an event field).\n+ * For event classes, the name must be a legal class name as specified in the Java\n+ * language, (for example, {@code \"com.example.Transaction\"}. For event fields\n+ * or event settings, the name must be a valid identifier (for example,\n+ * {@code \"message\"}). See section 3.8 and 3.9 of the Java Language\n+ * Specification for more information.\n+ * <p>\n+ * If the specified name is invalid, the annotation is ignored.\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/Name.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,2 +86,2 @@\n-     * The name must be a valid Java identifier (for example, {@code \"maxThroughput\"}). See 3.8\n-     * Java Language Specification for more information.\n+     * The name must be a valid Java identifier (for example, {@code \"maxThroughput\"}). See\n+     * section 3.8 and 3.9 of the Java Language Specification for more information.\n@@ -92,0 +92,2 @@\n+     * @throws IllegalArgumentException if the name is not a valid Java identifier\n+     *\n@@ -121,2 +123,2 @@\n-     * The name must be a valid Java identifier (for example, {@code \"maxThroughput\"}). See 3.8\n-     * Java Language Specification for more information.\n+     * The name must be a valid Java identifier (for example, {@code \"maxThroughput\"}). See\n+     * section 3.8 and 3.9 of the Java Language Specification for more information.\n@@ -129,0 +131,2 @@\n+     * @throws IllegalArgumentException if the name is not a valid Java identifier\n+     *\n@@ -146,0 +150,1 @@\n+        Utils.ensureJavaIdentifier(name);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/ValueDescriptor.java","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,1 +153,1 @@\n-                                name = n.value();\n+                                name = Utils.validJavaIdentifier(n.value(), name);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventControl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -216,0 +216,1 @@\n+        String nameDescriptor = Type.getType(Name.class).getDescriptor();\n@@ -223,0 +224,9 @@\n+                        String name = m.name;\n+                        for (AnnotationNode nameCandidate : m.visibleAnnotations) {\n+                            if (nameDescriptor.equals(nameCandidate.desc)) {\n+                                List<Object> values = nameCandidate.values;\n+                                if (values.size() == 1 && values.get(0) instanceof String s) {\n+                                    name = Utils.validJavaIdentifier(s, name);\n+                                }\n+                            }\n+                        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,0 +258,3 @@\n+                if (!\"package\".equals(f.name) && !\"java.lang.Class\".equals(te.name)) {\n+                    Utils.ensureJavaIdentifier(f.name);\n+                }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MetadataLoader.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+import jdk.internal.module.Checks;\n@@ -79,1 +80,1 @@\n-        Type t =  new Type(name, null, id);\n+        Type t =  new Type(name, null, id, null);\n@@ -102,0 +103,4 @@\n+        if (!Checks.isClassName(javaTypeName)) {\n+            \/\/ Should not be able to come here with an invalid type name\n+            throw new InternalError(javaTypeName + \" is not a valid Java type\");\n+        }\n@@ -106,4 +111,0 @@\n-\n-        if (!isValidJavaIdentifier(javaTypeName)) {\n-            throw new IllegalArgumentException(javaTypeName + \" is not a valid Java identifier\");\n-        }\n@@ -129,18 +130,0 @@\n-    public static boolean isValidJavaIdentifier(String identifier) {\n-        if (identifier.isEmpty()) {\n-            return false;\n-        }\n-        if (!Character.isJavaIdentifierStart(identifier.charAt(0))) {\n-            return false;\n-        }\n-        for (int i = 1; i < identifier.length(); i++) {\n-            char c = identifier.charAt(i);\n-            if (c != '.') {\n-                if (!Character.isJavaIdentifierPart(c)) {\n-                    return false;\n-                }\n-            }\n-        }\n-        return true;\n-    }\n-\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Type.java","additions":6,"deletions":23,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -194,1 +194,4 @@\n-            String typeName = name != null ? name.value() : clazz.getName();\n+            String typeName = clazz.getName();\n+            if (name != null) {\n+                typeName = Utils.validTypeName(name.value(), typeName);\n+            }\n@@ -320,1 +323,0 @@\n-            defineType(long.class, null, false);\n@@ -366,1 +368,1 @@\n-            useName = name.value();\n+            useName = Utils.validJavaIdentifier(name.value(), useName);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/TypeLibrary.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+import jdk.internal.module.Checks;\n@@ -844,0 +845,24 @@\n+\n+    public static String validTypeName(String typeName, String defaultTypeName) {\n+        if (Checks.isClassName(typeName)) {\n+            return typeName;\n+        } else {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"@Name ignored, not a valid Java type name.\");\n+            return defaultTypeName;\n+        }\n+    }\n+\n+    public static String validJavaIdentifier(String identifier, String defaultIdentifier) {\n+        if (Checks.isJavaIdentifier(identifier)) {\n+            return identifier;\n+        } else {\n+            Logger.log(LogTag.JFR, LogLevel.WARN, \"@Name ignored, not a valid Java identifier.\");\n+            return defaultIdentifier;\n+        }\n+    }\n+\n+    public static void ensureJavaIdentifier(String name) {\n+        if (!Checks.isJavaIdentifier(name)) {\n+            throw new IllegalArgumentException(\"'\" + name + \"' is not a valid Java identifier\");\n+        }\n+    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Utils.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import java.lang.annotation.Annotation;\n@@ -30,0 +31,2 @@\n+import java.util.List;\n+import java.util.Map;\n@@ -59,0 +62,35 @@\n+    @MetadataDefinition\n+    @Name(\"for\")\n+    @Target({ ElementType.TYPE })\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface ReservedAnnotation {\n+    }\n+\n+    @MetadataDefinition\n+    @Name(\"Hello World\")\n+    @Target({ ElementType.TYPE })\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface InvalidAnnotation1 {\n+    }\n+\n+    @MetadataDefinition\n+    @Name(\"Bad#Name\")\n+    @Target({ ElementType.TYPE })\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface InvalidAnnotation2 {\n+    }\n+\n+    @MetadataDefinition\n+    @Name(\"com.example.9thing\")\n+    @Target({ ElementType.TYPE })\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface InvalidAnnotation3 {\n+    }\n+\n+    @MetadataDefinition\n+    @Name(\"\")\n+    @Target({ ElementType.TYPE })\n+    @Retention(RetentionPolicy.RUNTIME)\n+    @interface EmptyAnnotation {\n+    }\n+\n@@ -72,0 +110,85 @@\n+    @Name(\"continue\")\n+    static class ReservedEventName extends Event {\n+    }\n+\n+    static class ReservedFieldName extends Event {\n+        @Name(\"final\")\n+        private int field;\n+    }\n+\n+    static class ReservedSettingName extends Event {\n+        @SettingDefinition\n+        @Name(\"true\")\n+        public boolean setting(SimpleSetting s) {\n+            return true;\n+        }\n+    }\n+\n+    @Name(\"Hello World\")\n+    static class InvalidEventName1 extends Event {\n+    }\n+\n+    @Name(\"Bad#Name\")\n+    static class InvalidEventName2 extends Event {\n+    }\n+\n+    @Name(\"com.example.9thing\")\n+    static class InvalidEventName3 extends Event {\n+    }\n+\n+    static class InvalidFieldName1 extends Event {\n+        @Name(\"foo.bar\")\n+        int field;\n+    }\n+\n+    static class InvalidFieldName2 extends Event {\n+        @Name(\"Hello World\")\n+        int field;\n+    }\n+\n+    static class InvalidFieldName3 extends Event {\n+        @Name(\"1up\")\n+        int field;\n+    }\n+\n+    static class InvalidSettingName1 extends Event {\n+        @SettingDefinition\n+        @Name(\"foo.bar\")\n+        public boolean setting(SimpleSetting s) {\n+            return true;\n+        }\n+    }\n+\n+    static class InvalidSettingName2 extends Event {\n+        @SettingDefinition\n+        @Name(\"Hello World\")\n+        public boolean setting(SimpleSetting s) {\n+            return true;\n+        }\n+    }\n+\n+    static class InvalidSettingName3 extends Event {\n+        @SettingDefinition\n+        @Name(\"1up\")\n+        public boolean setting(SimpleSetting s) {\n+            return true;\n+        }\n+    }\n+\n+    @Name(\"\")\n+    static class EmptyEventName extends Event {\n+    }\n+\n+    static class EmptyFieldName extends Event {\n+        @Name(\"\")\n+        private String field;\n+    }\n+\n+    static class EmptySettingName extends Event {\n+        @SettingDefinition\n+        @Name(\"\")\n+        public boolean setting(SimpleSetting s) {\n+            return true;\n+        }\n+    }\n+\n@@ -90,0 +213,42 @@\n+\n+        \/\/ Check invalid event name\n+        assertIllegalEventName(ReservedEventName.class);\n+        assertIllegalEventName(InvalidEventName1.class);\n+        assertIllegalEventName(InvalidEventName2.class);\n+        assertIllegalEventName(InvalidEventName3.class);\n+        assertIllegalEventName(EmptyEventName.class);\n+\n+        \/\/ Check invalid field names\n+        assertIllegalFieldName(ReservedFieldName.class);\n+        assertIllegalFieldName(InvalidFieldName1.class);\n+        assertIllegalFieldName(InvalidFieldName2.class);\n+        assertIllegalFieldName(InvalidFieldName3.class);\n+        assertIllegalFieldName(EmptyFieldName.class);\n+\n+        \/\/ Check invalid setting names\n+        assertIllegalSettingName(ReservedSettingName.class);\n+        assertIllegalSettingName(InvalidSettingName1.class);\n+        assertIllegalSettingName(InvalidSettingName1.class);\n+        assertIllegalSettingName(InvalidSettingName1.class);\n+        assertIllegalSettingName(EmptySettingName.class);\n+\n+        \/\/ Check invalid value descriptor names\n+        testIllegalValueDescriptorName(\"goto\");\n+        testIllegalValueDescriptorName(\"Hello World\");\n+        testIllegalValueDescriptorName(\"1up\");\n+        testIllegalValueDescriptorName(\"foo.bar\");\n+        testIllegalValueDescriptorName(\"\");\n+\n+        \/\/ Check invalid annotation names\n+        testIllegalAnnotationName(ReservedAnnotation.class);\n+        testIllegalAnnotationName(InvalidAnnotation1.class);\n+        testIllegalAnnotationName(InvalidAnnotation2.class);\n+        testIllegalAnnotationName(InvalidAnnotation3.class);\n+        testIllegalAnnotationName(EmptyAnnotation.class);\n+    }\n+\n+    private static void assertIllegalEventName(Class<? extends Event> eventClass) throws Exception {\n+        EventType type = EventType.getEventType(eventClass);\n+        if (!type.getName().equals(eventClass.getName())) {\n+            throw new Exception(\"Expected default name \" + eventClass.getName() + \", not illegal name \" + type.getName());\n+        }\n@@ -92,5 +257,43 @@\n-    \/\/ Can't use assert since the use toString on the object which doesn't work well JFR proxies.\n-    private static void assertAnnotation(Object annotation,String message) throws Exception {\n-       if (annotation == null) {\n-           throw new Exception(message);\n-       }\n+    private static void assertIllegalSettingName(Class<? extends Event> eventClass) throws Exception {\n+        EventType type = EventType.getEventType(eventClass);\n+        for (SettingDescriptor s : type.getSettingDescriptors()) {\n+            if (s.getName().equals(\"setting\")) {\n+                return;\n+            }\n+            if (!List.of(\"threshold\", \"enabled\", \"stackTrace\").contains(s.getName())) {\n+                throw new Exception(\"Expected default setting name 'setting' for event \" + type.getName() + \", not illegal \" + s.getName());\n+            }\n+        }\n+    }\n+\n+    private static void assertIllegalFieldName(Class<? extends Event> eventClass) throws Exception {\n+        EventType type = EventType.getEventType(eventClass);\n+        if (type.getField(\"field\") == null) {\n+            String illegal = type.getFields().get(type.getFields().size() - 1).getName();\n+            throw new Exception(\"Expected default field name 'field' for event \" + type.getName() + \", not illegal name \" + illegal);\n+        }\n+    }\n+\n+    private static void testIllegalValueDescriptorName(String illegalName) throws Exception {\n+        try {\n+            new ValueDescriptor(int.class, illegalName);\n+        } catch (IllegalArgumentException iae) {\n+            \/\/ OK, as expected\n+            return;\n+        }\n+        throw new Exception(\"ValueDescriptor should not accept invalid field name '\" + illegalName + \"'\");\n+    }\n+\n+    private static void testIllegalAnnotationName(Class<? extends Annotation> annotationClass) throws Exception {\n+        AnnotationElement ae = new AnnotationElement(annotationClass, Map.of());\n+        if (!ae.getTypeName().equals(annotationClass.getName())) {\n+            throw new Exception(\"AnnotationElement for class  \" + annotationClass + \" not accept invalid type name '\" + ae.getTypeName() + \"'\");\n+        }\n+    }\n+\n+    \/\/ Can't use assert since the use toString on the object which doesn't work well\n+    \/\/ JFR proxies.\n+    private static void assertAnnotation(Object annotation, String message) throws Exception {\n+        if (annotation == null) {\n+            throw new Exception(message);\n+        }\n","filename":"test\/jdk\/jdk\/jfr\/api\/metadata\/annotations\/TestName.java","additions":209,"deletions":6,"binary":false,"changes":215,"status":"modified"}]}