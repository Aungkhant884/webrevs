{"files":[{"patch":"@@ -191,1 +191,1 @@\n-      JVMCI_ERROR(\"invalid _next_call_type value\");\n+      JVMCI_ERROR(\"invalid _next_call_type value: %d\", _next_call_type);\n@@ -194,2 +194,2 @@\n-  if (os::is_MP() && !call->is_displacement_aligned()) {\n-    JVMCI_ERROR(\"unaligned call displacement for call at offset %d\", pc_offset);\n+  if (!call->is_displacement_aligned()) {\n+    JVMCI_ERROR(\"unaligned displacement for call at offset %d\", pc_offset);\n","filename":"src\/hotspot\/cpu\/x86\/jvmciCodeInstaller_x86.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -264,2 +264,1 @@\n-  return ((uintptr_t)displacement_address() + 0) \/ cache_line_size ==\n-         ((uintptr_t)displacement_address() + 3) \/ cache_line_size;\n+  return (uintptr_t) displacement_address() % 4 == 0;\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -163,2 +163,0 @@\n-  enum { cache_line_size = BytesPerWord };  \/\/ conservative estimate!\n-\n@@ -178,0 +176,1 @@\n+  \/\/ Returns whether the 4-byte displacement operand is 4-byte aligned.\n@@ -181,1 +180,1 @@\n-  void  verify_alignment() { assert((intptr_t)addr_at(displacement_offset) % BytesPerInt == 0, \"must be aligned\"); }\n+  void  verify_alignment() { assert(is_displacement_aligned(), \"displacement of call is not aligned\", p2i()); }\n","filename":"src\/hotspot\/cpu\/x86\/nativeInst_x86.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"}]}