{"files":[{"patch":"@@ -40,0 +40,20 @@\n+#if INCLUDE_JVMTI\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#endif \/\/ INCLUDE_JVMTI\n+\n+void notify_jvmti_tagmaps() {\n+#if INCLUDE_JVMTI\n+  \/\/ Notify JVMTI tagmaps that a STW weak reference processing might be\n+  \/\/ clearing entries, so the tagmaps need cleaning.  Doing this here allows\n+  \/\/ the tagmap's oopstorage notification handler to not care whether it's\n+  \/\/ invoked by STW or concurrent reference processing.\n+  JvmtiTagMap::set_needs_cleaning();\n+\n+  \/\/ Notify JVMTI tagmaps that a STW collection may have moved objects, so\n+  \/\/ the tagmaps need rehashing.  This isn't the right place for this, but\n+  \/\/ is convenient because all the STW collectors use WeakProcessor.  One\n+  \/\/ problem is that the end of a G1 concurrent collection also comes here,\n+  \/\/ possibly triggering unnecessary rehashes.\n+  JvmtiTagMap::set_needs_rehashing();\n+#endif \/\/ INCLUDE_JVMTI\n+}\n@@ -43,0 +63,2 @@\n+  notify_jvmti_tagmaps();\n+\n@@ -99,0 +121,1 @@\n+  notify_jvmti_tagmaps();\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessor.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1692,0 +1692,3 @@\n+    \/\/ Notify JVMTI that the tagmap table will need cleaning.\n+    JvmtiTagMap::set_needs_cleaning();\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,0 +307,3 @@\n+  \/\/ Notify JVMTI that some tagmap entry objects may have died.\n+  JvmtiTagMap::set_needs_cleaning();\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -307,0 +308,2 @@\n+\n+  static void flush_object_free_events(JvmtiEnvBase *env);\n@@ -397,0 +400,12 @@\n+void\n+JvmtiEventControllerPrivate::flush_object_free_events(JvmtiEnvBase* env) {\n+  \/\/ Some of the objects recorded by this env may have died.  If we're\n+  \/\/ (potentially) changing the enable state for ObjectFree events, we\n+  \/\/ need to ensure the env is cleaned up and any events that should\n+  \/\/ be posted are posted.\n+  JvmtiTagMap* tag_map = env->tag_map_acquire();\n+  if (tag_map != NULL) {\n+    tag_map->flush_object_free_events();\n+  }\n+}\n+\n@@ -688,0 +703,3 @@\n+  \/\/ May be changing the event handler for ObjectFree.\n+  flush_object_free_events(env);\n+\n@@ -800,0 +818,4 @@\n+  if (event_type == JVMTI_EVENT_OBJECT_FREE) {\n+    flush_object_free_events(env);\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n@@ -68,0 +69,2 @@\n+bool JvmtiTagMap::_has_object_free_events = false;\n+\n@@ -73,1 +76,2 @@\n-  _needs_rehashing(false) {\n+  _needs_rehashing(false),\n+  _needs_cleaning(false) {\n@@ -127,0 +131,1 @@\n+  assert(!post_events || SafepointSynchronize::is_at_safepoint(), \"precondition\");\n@@ -129,3 +134,0 @@\n-  \/\/ The table cleaning, posting and rehashing can race for\n-  \/\/ concurrent GCs. So fix it here once we have a lock or are\n-  \/\/ at a safepoint.\n@@ -134,5 +136,4 @@\n-  \/\/ Operating on the hashmap must always be locked, since concurrent GC threads may\n-  \/\/ notify while running through a safepoint.\n-  if (post_events && env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n-    log_info(jvmti, table)(\"TagMap table needs posting before heap walk\");\n-    hashmap()->unlink_and_post(env());\n+  if (_needs_cleaning &&\n+      post_events &&\n+      env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n+    remove_dead_entries(true \/* post_object_free *\/);\n@@ -1157,1 +1158,11 @@\n-void JvmtiTagMap::unlink_and_post_locked() {\n+void JvmtiTagMap::remove_dead_entries(bool post_object_free) {\n+  assert(is_locked(), \"precondition\");\n+  if (_needs_cleaning) {\n+    log_info(jvmti, table)(\"TagMap table needs cleaning%s\",\n+                           (post_object_free ? \" and posting\" : \"\"));\n+    hashmap()->remove_dead_entries(env(), post_object_free);\n+    _needs_cleaning = false;\n+  }\n+}\n+\n+void JvmtiTagMap::remove_dead_entries_locked(bool post_object_free) {\n@@ -1159,1 +1170,1 @@\n-  hashmap()->unlink_and_post(env());\n+  remove_dead_entries(post_object_free);\n@@ -1168,2 +1179,1 @@\n-    log_info(jvmti, table)(\"TagMap table needs posting before GetObjectsWithTags\");\n-    _tag_map->unlink_and_post_locked();\n+    _tag_map->remove_dead_entries_locked(true \/* post_object_free *\/);\n@@ -1182,0 +1192,18 @@\n+void JvmtiTagMap::flush_object_free_events() {\n+  assert_not_at_safepoint();\n+  if (env()->is_enabled(JVMTI_EVENT_OBJECT_FREE)) {\n+    {\n+      MutexLocker ml(lock(), Mutex::_no_safepoint_check_flag);\n+      if (!_needs_cleaning || is_empty()) {\n+        _needs_cleaning = false;\n+        return;\n+      }\n+    } \/\/ Drop the lock so we can do the cleaning on the VM thread.\n+    \/\/ Needs both cleaning and event posting (up to some other thread\n+    \/\/ getting there first after we dropped the lock).\n+    post_dead_objects_on_vm_thread();\n+  } else {\n+    remove_dead_entries_locked(false);\n+  }\n+}\n+\n@@ -2997,1 +3025,2 @@\n-void JvmtiTagMap::gc_notification(size_t num_dead_entries) {\n+\/\/ Verify gc_notification follows set_needs_cleaning.\n+DEBUG_ONLY(static bool notified_needs_cleaning = false;)\n@@ -2999,12 +3028,12 @@\n-  bool is_vm_thread = Thread::current()->is_VM_thread();\n-  if (!is_vm_thread) {\n-    if (num_dead_entries != 0) {\n-      JvmtiEnvIterator it;\n-      for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n-        JvmtiTagMap* tag_map = env->tag_map_acquire();\n-        if (tag_map != NULL) {\n-          \/\/ Lock each hashmap from concurrent posting and cleaning\n-          tag_map->unlink_and_post_locked();\n-        }\n-      }\n-      \/\/ there's another callback for needs_rehashing\n+void JvmtiTagMap::set_needs_cleaning() {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"called in gc pause\");\n+  assert(Thread::current()->is_VM_thread(), \"should be the VM thread\");\n+  \/\/ Can't assert !notified_needs_cleaning; a partial GC might be upgraded\n+  \/\/ to a full GC and do this twice without intervening gc_notification.\n+  DEBUG_ONLY(notified_needs_cleaning = true;)\n+\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+    JvmtiTagMap* tag_map = env->tag_map_acquire();\n+    if (tag_map != NULL) {\n+      tag_map->_needs_cleaning = !tag_map->is_empty();\n@@ -3012,2 +3041,2 @@\n-  } else {\n-    assert(SafepointSynchronize::is_at_safepoint(), \"must be\");\n+  }\n+}\n@@ -3015,1 +3044,3 @@\n-    TraceTime timer(\"JvmtiTagMap gc_notification and event posting\", TRACETIME_LOG(Debug, gc, phases));\n+void JvmtiTagMap::gc_notification(size_t num_dead_entries) {\n+  assert(notified_needs_cleaning, \"missing GC notification\");\n+  DEBUG_ONLY(notified_needs_cleaning = false;)\n@@ -3017,0 +3048,9 @@\n+  \/\/ Notify ServiceThread if there's work to do.\n+  {\n+    MonitorLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+    _has_object_free_events = (num_dead_entries != 0);\n+    if (_has_object_free_events) ml.notify_all();\n+  }\n+\n+  \/\/ If no dead entries then cancel cleaning requests.\n+  if (num_dead_entries == 0) {\n@@ -3020,6 +3060,3 @@\n-      if (tag_map != NULL && !tag_map->is_empty()) {\n-        if (num_dead_entries != 0) {\n-          tag_map->hashmap()->unlink_and_post(tag_map->env());\n-        }\n-        \/\/ Later GC code will relocate the oops, so defer rehashing until then.\n-        tag_map->_needs_rehashing = true;\n+      if (tag_map != NULL) {\n+        MutexLocker ml (tag_map->lock(), Mutex::_no_safepoint_check_flag);\n+        tag_map->_needs_cleaning = false;\n@@ -3031,0 +3068,20 @@\n+\/\/ Used by ServiceThread to discover there is work to do.\n+bool JvmtiTagMap::has_object_free_events_and_reset() {\n+  assert_lock_strong(Service_lock);\n+  bool result = _has_object_free_events;\n+  _has_object_free_events = false;\n+  return result;\n+}\n+\n+\/\/ Used by ServiceThread to clean up tagmaps.\n+void JvmtiTagMap::flush_all_object_free_events() {\n+  JavaThread* thread = JavaThread::current();\n+  JvmtiEnvIterator it;\n+  for (JvmtiEnv* env = it.first(); env != NULL; env = it.next(env)) {\n+    JvmtiTagMap* tag_map = env->tag_map_acquire();\n+    if (tag_map != NULL) {\n+      tag_map->flush_object_free_events();\n+      ThreadBlockInVM tbiv(thread); \/\/ Be safepoint-polite while looping.\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":92,"deletions":35,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -44,0 +44,3 @@\n+  bool                  _needs_cleaning;\n+\n+  static bool           _has_object_free_events;\n@@ -110,1 +113,2 @@\n-  void unlink_and_post_locked();\n+  void remove_dead_entries(bool post_object_free);\n+  void remove_dead_entries_locked(bool post_object_free);\n@@ -114,0 +118,1 @@\n+  static void set_needs_cleaning() NOT_JVMTI_RETURN;\n@@ -115,0 +120,6 @@\n+\n+  void flush_object_free_events();\n+\n+  \/\/ For ServiceThread\n+  static void flush_all_object_free_events();\n+  static bool has_object_free_events_and_reset();\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -183,6 +183,2 @@\n-\/\/ Serially remove unused oops from the table, and notify jvmti.\n-void JvmtiTagMapTable::unlink_and_post(JvmtiEnv* env) {\n-\n-  \/\/ Does this environment have the OBJECT_FREE event enabled?\n-  bool post_object_free = env->is_enabled(JVMTI_EVENT_OBJECT_FREE);\n-\n+\/\/ Serially remove entries for dead oops from the table, and notify jvmti.\n+void JvmtiTagMapTable::remove_dead_entries(JvmtiEnv* env, bool post_object_free) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  void unlink_and_post(JvmtiEnv* env);\n+  void remove_dead_entries(JvmtiEnv* env, bool post_object_free);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"prims\/jvmtiTagMap.hpp\"\n@@ -150,0 +151,1 @@\n+    bool jvmti_tagmap_work = false;\n@@ -178,1 +180,2 @@\n-              (deflate_idle_monitors = ObjectSynchronizer::is_async_deflation_needed())\n+              (deflate_idle_monitors = ObjectSynchronizer::is_async_deflation_needed()) |\n+              (jvmti_tagmap_work = JvmtiTagMap::has_object_free_events_and_reset())\n@@ -247,0 +250,4 @@\n+\n+    if (jvmti_tagmap_work) {\n+      JvmtiTagMap::flush_all_object_free_events();\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -72,1 +72,9 @@\n-    nsk_jvmti_aod_disableEventAndFinish(agentName, JVMTI_EVENT_OBJECT_FREE, success, jvmti, jni);\n+\n+    \/* Flush any pending ObjectFree events, which may set success to 1 *\/\n+    if (jvmti->SetEventNotificationMode(JVMTI_DISABLE,\n+                                        JVMTI_EVENT_OBJECT_FREE,\n+                                        NULL) != JVMTI_ERROR_NONE) {\n+        success = 0;\n+    }\n+\n+    nsk_aod_agentFinished(jni, agentName, success);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach021\/attach021Agent00.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\n+    \/\/ Flush any pending ObjectFree events.\n+    if (!nsk_jvmti_aod_disableEvents(jvmti, testEvents, testEventsNumber))\n+        success = 0;\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/AttachOnDemand\/attach022\/attach022Agent00.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -55,0 +55,2 @@\n+    private native void flushObjectFreeEvents();\n+\n@@ -105,0 +107,2 @@\n+        flushObjectFreeEvents();\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP01\/ap01t001.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -194,0 +194,10 @@\n+JNIEXPORT void JNICALL\n+Java_nsk_jvmti_scenarios_allocation_AP01_ap01t001_flushObjectFreeEvents(JNIEnv* jni, jobject obj) {\n+    \/\/ Already enabled, but this triggers flush of pending events.\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                                          JVMTI_EVENT_OBJECT_FREE,\n+                                                          NULL))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP01\/ap01t001\/ap01t001.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+    private native void flushObjectFreeEvents();\n@@ -76,0 +77,1 @@\n+        flushObjectFreeEvents();\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP12\/ap12t001.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,0 +87,10 @@\n+JNIEXPORT void JNICALL\n+Java_nsk_jvmti_scenarios_allocation_AP12_ap12t001_flushObjectFreeEvents(JNIEnv* jni, jobject obj) {\n+    \/\/ Already enabled, but this triggers flush of pending events.\n+    if (!NSK_JVMTI_VERIFY(jvmti->SetEventNotificationMode(JVMTI_ENABLE,\n+                                                          JVMTI_EVENT_OBJECT_FREE,\n+                                                          NULL))) {\n+        nsk_jvmti_setFailStatus();\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/allocation\/AP12\/ap12t001\/ap12t001.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -709,2 +709,3 @@\n-    NSK_DISPLAY0(\"Testcase #3: check if the events are generated\\n\");\n-    if (!checkGeneratedEvents()) {\n+    \/* this will also flush any pending ObjectFree events for event check *\/\n+    NSK_DISPLAY0(\"Testcase #3: check if the object is freed in the tag map\\n\");\n+    if (!checkObjectFreeEvent(jvmti)) {\n@@ -714,2 +715,2 @@\n-    NSK_DISPLAY0(\"Testcase #4: check if the object is freed in the tag map\\n\");\n-    if (!checkObjectFreeEvent(jvmti)) {\n+    NSK_DISPLAY0(\"Testcase #4: check if the events are generated\\n\");\n+    if (!checkGeneratedEvents()) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM02\/cm02t001\/cm02t001.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}