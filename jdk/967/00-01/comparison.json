{"files":[{"patch":"@@ -41,1 +41,1 @@\n-  static const uint weak_count = 5 JVMTI_ONLY(+1) JFR_ONLY(+ 1);\n+  static const uint weak_count = 5 JVMTI_ONLY(+ 1) JFR_ONLY(+ 1);\n","filename":"src\/hotspot\/share\/gc\/shared\/oopStorageSet.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,17 +42,0 @@\n-static void reset_times(double* times, size_t ntimes) {\n-  for (size_t i = 0; i < ntimes; ++i) {\n-    times[i] = uninitialized_time;\n-  }\n-}\n-\n-static void reset_items(size_t* items, size_t nitems) {\n-  for (size_t i = 0; i < nitems; ++i) {\n-    items[i] = 0;\n-  }\n-}\n-\n-void WeakProcessorPhaseTimes::reset_phase_data() {\n-  reset_times(_phase_times_sec, ARRAY_SIZE(_phase_times_sec));\n-  reset_items(_phase_dead_items, ARRAY_SIZE(_phase_dead_items));\n-  reset_items(_phase_total_items, ARRAY_SIZE(_phase_total_items));\n-}\n@@ -68,2 +51,0 @@\n-  reset_phase_data();\n-\n@@ -106,1 +87,0 @@\n-  reset_phase_data();\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhaseTimes.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -46,6 +46,0 @@\n-  \/\/ why is this an array?\n-  double _phase_times_sec[1];\n-  size_t _phase_dead_items[1];\n-  size_t _phase_total_items[1];\n-  void reset_phase_data();\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/weakProcessorPhaseTimes.hpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-class ZPhantomCleanOopClosure : public ZRootsIteratorClosure {\n+class ZPhantomKeepAliveOopClosure : public ZRootsIteratorClosure {\n@@ -64,1 +64,1 @@\n-class ZPhantomKeepAliveOopClosure : public ZRootsIteratorClosure {\n+class ZPhantomCleanOopClosure : public ZRootsIteratorClosure {\n","filename":"src\/hotspot\/share\/gc\/z\/zOopClosures.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -404,3 +404,0 @@\n-  \/\/ Delete me and all my callers!\n-  static void weak_oops_do(BoolObjectClosure* b, OopClosure* f) {}\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -123,0 +123,2 @@\n+  assert(is_locked(), \"checking\");\n+\n@@ -126,1 +128,0 @@\n-  \/\/ SetTag and GetTag should not post events!\n@@ -131,1 +132,0 @@\n-  assert(is_locked(), \"checking\");\n@@ -144,1 +144,0 @@\n-\/\/ The ZDriver may be walking the hashmaps concurrently so all these locks are needed.\n@@ -146,1 +145,0 @@\n-\n@@ -148,0 +146,1 @@\n+\n@@ -154,0 +153,1 @@\n+      \/\/ The ZDriver may be walking the hashmaps concurrently so this lock is needed.\n@@ -160,1 +160,0 @@\n-\n@@ -344,1 +343,3 @@\n-  \/\/ Check if we have to process for concurrent GCs.\n+  \/\/ SetTag should not post events because the JavaThread has to\n+  \/\/ transition to native for the callback and this cannot stop for\n+  \/\/ safepoints with the hashmap lock held.\n@@ -377,1 +378,3 @@\n-  \/\/ Check if we have to processing for concurrent GCs.\n+  \/\/ GetTag should not post events because the JavaThread has to\n+  \/\/ transition to native for the callback and this cannot stop for\n+  \/\/ safepoints with the hashmap lock held.\n@@ -1152,1 +1155,1 @@\n-  log_info(jvmti, table)(\"TagMap table needs posting before GetObjectTags\");\n+  log_info(jvmti, table)(\"TagMap table needs posting before GetObjectsWithTags\");\n@@ -1279,1 +1282,1 @@\n-    \/\/ window where the oop is not marked but hasn't been notified that\n+    \/\/ window where the object is not marked but hasn't been notified that\n@@ -2975,1 +2978,1 @@\n-\/\/ Concurrent GC needs to call this in relocation pause, so after the oops are moved\n+\/\/ Concurrent GC needs to call this in relocation pause, so after the objects are moved\n@@ -2981,3 +2984,0 @@\n-  \/\/ Hopefully quick exit.\n-  if (!JvmtiEnv::environments_might_exist()) { return; }\n-\n@@ -2995,5 +2995,0 @@\n-  \/\/ No locks during VM bring-up (0 threads) and no safepoints after main\n-  \/\/ thread creation and before VMThread creation (1 thread); initial GC\n-  \/\/ verification can happen in that window which gets to here.\n-  if (!JvmtiEnv::environments_might_exist()) { return; }\n-\n@@ -3020,1 +3015,1 @@\n-        if (num_dead_entries > 0) {\n+        if (num_dead_entries != 0) {\n@@ -3023,0 +3018,1 @@\n+        \/\/ Later GC code will relocate the oops, so defer rehashing until then.\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n- public:\n@@ -58,0 +57,1 @@\n+ public:\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,5 +45,1 @@\n-  \/\/ The AS_NO_KEEPALIVE peeks at the oop without keeping it alive.\n-  \/\/ This is dangerous in general but is okay if the loaded oop does\n-  \/\/ not leak out past a thread transition where a safepoint can happen.\n-  \/\/ A subsequent oop_load without AS_NO_KEEPALIVE (the object() accessor)\n-  \/\/ keeps the oop alive before doing so.\n+  \/\/ Just peek at the object without keeping it alive.\n@@ -81,2 +77,2 @@\n-  entry->literal().release(JvmtiExport::weak_tag_storage()); \/\/ release OopStorage\n-  FREE_C_HEAP_ARRAY(char, entry); \/\/ C_Heap free.\n+  entry->literal().release(JvmtiExport::weak_tag_storage()); \/\/ release to OopStorage\n+  FREE_C_HEAP_ARRAY(char, entry);\n@@ -91,0 +87,2 @@\n+  assert(obj != NULL, \"Cannot search for a NULL object\");\n+\n@@ -98,1 +96,1 @@\n-      if (target != NULL && target == obj) {\n+      if (target == obj) {\n@@ -122,2 +120,1 @@\n-  JvmtiTagMapEntry* entry = find(index, hash, obj);\n-  assert (entry == NULL, \"shouldn't already be present\");\n+  assert (find(index, hash, obj) == NULL, \"shouldn't already be present\");\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMapTable.cpp","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-const jlong TESTED_TAG_VALUE = (5555555L);\n+const jlong TESTED_TAG_VALUE = 5555555L;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/scenarios\/capability\/CM02\/cm02t001\/cm02t001.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}