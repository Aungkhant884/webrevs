{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import java.lang.ref.ReferenceQueue;\n@@ -172,0 +173,23 @@\n+    private final ReferenceQueue<VMListener> listenersReferenceQueue = new ReferenceQueue<>();\n+\n+    private void removeUnreachableListeners() {\n+        \/\/ If there are no listeners on the ReferenceQueue, then that means none\n+        \/\/ are unreachable and we can just return.\n+        if (listenersReferenceQueue.poll() == null) {\n+            return; \/\/ There are no unreachable listeners\n+        }\n+\n+        \/\/ We always need to clear the ReferenceQueue\n+        while (listenersReferenceQueue.poll() != null)\n+            ;\n+\n+        \/\/ Remove unreachable listeners since we know there is at least one.\n+        Iterator<WeakReference<VMListener>> iter = listeners.iterator();\n+        while (iter.hasNext()) {\n+            VMListener l = iter.next().get();\n+            if (l == null) {\n+                iter.remove();\n+            }\n+        }\n+    }\n+\n@@ -173,1 +197,2 @@\n-        listeners.add(new WeakReference<VMListener>(listener));\n+        removeUnreachableListeners();\n+        listeners.add(new WeakReference<VMListener>(listener, listenersReferenceQueue));\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VMState.java","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1371,0 +1371,1 @@\n+        boolean found = false;\n@@ -1375,0 +1376,6 @@\n+            found = true;\n+        }\n+\n+        if (found) {\n+            \/\/ If we batched any ObjectReferences for disposing, we can dispose them now.\n+            processBatchedDisposes();\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/VirtualMachineImpl.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,165 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8297638\n+ * @summary JDI memory leak when creating and destroying many threads\n+ *\n+ * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations\n+ * @requires (vm.compMode == \"Xmixed\")\n+ * @run build TestScaffold VMConnection TargetListener TargetAdapter\n+ * @run compile -g ThreadMemoryLeakTest.java\n+ * @comment run with -Xmx6m so any leak will quickly produce OOME\n+ * @run main\/othervm -Xmx6m ThreadMemoryLeakTest\n+ *\/\n+import com.sun.jdi.*;\n+import com.sun.jdi.event.*;\n+import com.sun.jdi.request.*;\n+\n+import java.util.*;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.atomic.LongAdder;\n+\n+    \/********** target program **********\/\n+\n+class ThreadMemoryLeakTarg {\n+    public static void main(String[] args) throws InterruptedException {\n+        System.out.println(\"Howdy!\");\n+        Semaphore semaphore = new Semaphore(500);\n+        LongAdder adder = new LongAdder();\n+        long startTime = System.currentTimeMillis();\n+        int iterations = 0;\n+        \/\/ Run for 100 seconds\n+        while (System.currentTimeMillis() - startTime < 100 * 1000) {\n+            iterations++;\n+            semaphore.acquire();\n+            Executors.defaultThreadFactory().newThread(() -> {\n+                    adder.increment();\n+                    long sum = adder.sum();\n+                    if ((sum % 1000) == 0) {\n+                        System.out.println(\"Progress: \" + sum);\n+                    }\n+                    try {\n+                        Thread.sleep(50);\n+                    }\n+                    catch (InterruptedException e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        semaphore.release();\n+                    }\n+                }).start();\n+        }\n+        System.out.println(\"Goodbye from ThreadMemoryLeakTarg after \" + iterations + \" iterations!\");\n+    }\n+}\n+\n+    \/********** test program **********\/\n+\n+public class ThreadMemoryLeakTest extends TestScaffold {\n+    StepRequest stepRequest = null;\n+    EventRequestManager erm;\n+    boolean mainIsDead;\n+\n+    ThreadMemoryLeakTest (String args[]) {\n+        super(args);\n+    }\n+\n+    public static void main(String[] args)      throws Exception {\n+        new ThreadMemoryLeakTest(args).startTests();\n+    }\n+\n+    \/********** event handlers **********\/\n+\n+    static int threadStartCount;\n+    static int threadDeathCount;\n+    private static List<ThreadReference> threads =\n+        Collections.synchronizedList(new ArrayList<ThreadReference>());\n+\n+    public void threadStarted(ThreadStartEvent event) {\n+        threadStartCount++;\n+        if ((threadStartCount % 1000) == 0) {\n+            println(\"Got ThreadStartEvent #\" + threadStartCount +\n+                               \" threads:\" + threads.size());\n+        }\n+        ThreadStartEvent tse = (ThreadStartEvent)event;\n+        threads.add(tse.thread());\n+    }\n+\n+    public void threadDied(ThreadDeathEvent event) {\n+        threadDeathCount++;\n+        if ((threadDeathCount % 1000) == 0) {\n+            println(\"Got ThreadDeathEvent #\" + threadDeathCount +\n+                               \" threads:\" + threads.size());\n+        }\n+        ThreadDeathEvent tde = (ThreadDeathEvent)event;\n+        ThreadReference thread = tde.thread();\n+        threads.remove(thread);\n+    }\n+\n+    public void vmDied(VMDeathEvent event) {\n+        println(\"Got VMDeathEvent\");\n+    }\n+\n+    public void vmDisconnected(VMDisconnectEvent event) {\n+        println(\"Got VMDisconnectEvent\");\n+    }\n+\n+    \/********** test core **********\/\n+\n+    protected void runTests() throws Exception {\n+        \/*\n+         * Launch debuggee and break at main() method.\n+         *\/\n+        BreakpointEvent bpe = startToMain(\"ThreadMemoryLeakTarg\");\n+\n+        \/*\n+         * Setup ThreadStart and ThreadDeath event requests. Note, SUSPEND_NONE is important\n+         * for this test. Otherwise the memory leak described in 8297638 is not triggered.\n+         * There can't be any events coming in that might result in a suspend since the\n+         * resume will clear out the leak.\n+         *\/\n+        erm = vm().eventRequestManager();\n+        ThreadStartRequest tsrReq = erm.createThreadStartRequest();\n+        ThreadDeathRequest tdrReq = erm.createThreadDeathRequest();\n+        tsrReq.setSuspendPolicy(EventRequest.SUSPEND_NONE);\n+        tdrReq.setSuspendPolicy(EventRequest.SUSPEND_NONE);\n+        tsrReq.enable();\n+        tdrReq.enable();\n+\n+        \/*\n+         * Resume the target and listen for events\n+         *\/\n+        listenUntilVMDisconnect();\n+\n+        \/*\n+         * Any test failure will result in an exception or a timeout. So if we\n+         * get here we passed.\n+         *\/\n+        println(\"ThreadMemoryLeakTest: PASSED\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":165,"deletions":0,"binary":false,"changes":165,"status":"added"}]}