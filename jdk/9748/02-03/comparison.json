{"files":[{"patch":"@@ -4362,4 +4362,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                            XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                                            Register rscratch, AddressLiteral float_sign_flip,\n-                                                            int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                   XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n+                                                                   Register rscratch, AddressLiteral float_sign_flip,\n+                                                                   int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4391,4 +4392,5 @@\n-void C2_MacroAssembler::vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                             Register rscratch, AddressLiteral float_sign_flip,\n-                                                             int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                    Register rscratch, AddressLiteral float_sign_flip,\n+                                                                    int vec_enc) {\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4412,5 +4414,4 @@\n-void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(\n-                                                             XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                             XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                             Register rscratch, AddressLiteral double_sign_flip,\n-                                                             int vec_enc) {\n+void C2_MacroAssembler::vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                     XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                     Register rscratch, AddressLiteral double_sign_flip,\n+                                                                     int vec_enc) {\n@@ -4436,1 +4437,1 @@\n-void C2_MacroAssembler::vector_narrow_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n@@ -4440,0 +4441,1 @@\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4465,4 +4467,4 @@\n-void C2_MacroAssembler::vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                              XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                              Register rscratch, AddressLiteral double_sign_flip,\n-                                                              int vec_enc) {\n+void C2_MacroAssembler::vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                                                      XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n+                                                                      Register rscratch, AddressLiteral double_sign_flip,\n+                                                                      int vec_enc) {\n@@ -4488,8 +4490,9 @@\n-void C2_MacroAssembler::vector_pack_lower_quadword_from_lanes_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp, int vec_enc) {\n-  if (VM_Version::supports_avx2()) {\n-    vpermq(dst, src, 0xD8, vec_enc);\n-  } else {\n-    vextractf128(xtmp, src, 0x1);\n-    pshufd(xtmp, xtmp, 0x4E);\n-    por(dst, xtmp);\n-  }\n+void C2_MacroAssembler::vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                                             XMMRegister xtmp, int index, int vec_enc) {\n+   assert(vec_enc < Assembler::AVX_512bit, \"\");\n+   if (vec_enc == Assembler::AVX_256bit) {\n+     vextractf128_high(xtmp, src);\n+     vshufps(dst, src, xtmp, index, vec_enc);\n+   } else {\n+     vshufps(dst, src, zero, index, vec_enc);\n+   }\n@@ -4498,1 +4501,1 @@\n-void C2_MacroAssembler::vector_narrow_cast_double_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+void C2_MacroAssembler::vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n@@ -4501,0 +4504,2 @@\n+  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n+\n@@ -4513,0 +4518,1 @@\n+  \/\/ Set detination lanes corresponding to unordered source lanes as zero.\n@@ -4515,5 +4521,3 @@\n-  \/\/ Narrow down the mask for quadword lane to integer lane.\n-  vpackssdw(xtmp3, xtmp3, xtmp4, src_vec_enc);\n-  if (src_vec_enc == Assembler::AVX_256bit) {\n-    vector_pack_lower_quadword_from_lanes_avx(xtmp3, xtmp3, xtmp5, src_vec_enc);\n-  }\n+\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n@@ -4525,11 +4529,1 @@\n-  vcmppd(xtmp5, src, xtmp4, Assembler::NLT_UQ, src_vec_enc);\n-  \/\/ Narrow down the mask for quadword lane to integer lane.\n-  vpackssdw(xtmp5, xtmp5, xtmp4, src_vec_enc);\n-  if (src_vec_enc == Assembler::AVX_256bit) {\n-    vector_pack_lower_quadword_from_lanes_avx(xtmp5, xtmp5, xtmp4, src_vec_enc);\n-  }\n-  pand(xtmp5, xtmp2);\n-\n-  vblendvps(dst, dst, xtmp1, xtmp5, Assembler::AVX_128bit);\n-  bind(done);\n-}\n+  vcmppd(xtmp3, src, xtmp4, Assembler::NLT_UQ, src_vec_enc);\n@@ -4537,15 +4531,3 @@\n-\/\/ Handling for downcasting from double to integer or sub-word types on AVX2.\n-void C2_MacroAssembler::vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n-                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n-  int to_elem_sz = type2aelembytes(to_elem_bt);\n-  assert(to_elem_sz < 8, \"\");\n-  vcvttpd2dq(dst, src, vec_enc);\n-  vector_narrow_cast_double_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, xtmp5, rscratch,\n-                                              float_sign_flip, vec_enc);\n-  vpxor(xtmp4, xtmp4, xtmp4, vec_enc);\n-  if (to_elem_sz < 4) {\n-    vector_narrow_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp2, rscratch, Assembler::AVX_128bit);\n-  }\n-}\n+  \/\/ Shuffle mask vector and pack lower doubles word from each quadword lane.\n+  vector_crosslane_doubleword_pack_avx(xtmp3, xtmp3, xtmp4, xtmp5, 0x88, src_vec_enc);\n+  pand(xtmp3, xtmp2);\n@@ -4553,6 +4535,4 @@\n-void C2_MacroAssembler::vector_castD2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                            Register rscratch, int vec_enc) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-  vcvttpd2dq(dst, src, vec_enc);\n-  vector_narrow_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, double_sign_flip, vec_enc);\n+  \/\/ Replace destination lanes holding special value(0x80000000) with max int\n+  \/\/ if corresponding source lane holds a +ve value.\n+  vblendvps(dst, dst, xtmp1, xtmp3, Assembler::AVX_128bit);\n+  bind(done);\n@@ -4561,17 +4541,0 @@\n-\/*\n- * Algorithm for vector D2L and F2I conversions:-\n- * a) Perform vector D2L\/F2I cast.\n- * b) Choose fast path if none of the result vector lane contains 0x80000000 value.\n- *    It signifies that source value could be any of the special floating point\n- *    values(NaN,-Inf,Inf,Max,-Min).\n- * c) Set destination to zero if source is NaN value.\n- * d) Replace 0x80000000 with MaxInt if source lane contains a +ve value.\n- *\/\n-\n-void C2_MacroAssembler::vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                                            Register rscratch, int vec_enc) {\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-  evcvttpd2qq(dst, src, vec_enc);\n-  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, double_sign_flip, vec_enc);\n-}\n@@ -4579,2 +4542,2 @@\n-void C2_MacroAssembler::vector_narrow_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n-                                                          XMMRegister xtmp, Register rscratch, int vec_enc) {\n+void C2_MacroAssembler::vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                                   XMMRegister xtmp, Register rscratch, int vec_enc) {\n@@ -4583,0 +4546,1 @@\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_short_mask())), \"missing\");\n@@ -4585,2 +4549,2 @@\n-      if(vec_enc == Assembler::AVX_256bit) {\n-        vector_pack_lower_quadword_from_lanes_avx(dst, dst, xtmp, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n@@ -4590,0 +4554,1 @@\n+      assert(rscratch != noreg || always_reachable(ExternalAddress(StubRoutines::x86::vector_int_to_byte_mask())), \"missing\");\n@@ -4592,2 +4557,2 @@\n-      if(vec_enc == Assembler::AVX_256bit) {\n-        vector_pack_lower_quadword_from_lanes_avx(dst, dst, xtmp, vec_enc);\n+      if (vec_enc == Assembler::AVX_256bit) {\n+        vector_crosslane_doubleword_pack_avx(dst, dst, zero, xtmp, 0x44, vec_enc);\n@@ -4601,0 +4566,10 @@\n+\/*\n+ * Algorithm for vector D2L and F2I conversions:-\n+ * a) Perform vector D2L\/F2I cast.\n+ * b) Choose fast path if none of the result vector lane contains 0x80000000 value.\n+ *    It signifies that source value could be any of the special floating point\n+ *    values(NaN,-Inf,Inf,Max,-Min).\n+ * c) Set destination to zero if source is NaN value.\n+ * d) Replace 0x80000000 with MaxInt if source lane contains a +ve value.\n+ *\/\n+\n@@ -4604,1 +4579,0 @@\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4608,2 +4582,1 @@\n-  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, rscratch, float_sign_flip, vec_enc);\n-  vpxor(xtmp2, xtmp2, xtmp2, vec_enc);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, rscratch, float_sign_flip, vec_enc);\n@@ -4611,1 +4584,2 @@\n-    vector_narrow_cast_int_to_subword(to_elem_bt, dst, xtmp2, xtmp4, rscratch, vec_enc);\n+    vpxor(xtmp4, xtmp4, xtmp4, vec_enc);\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp3, rscratch, vec_enc);\n@@ -4618,1 +4592,0 @@\n-  assert(rscratch != noreg || always_reachable(float_sign_flip), \"missing\");\n@@ -4622,1 +4595,1 @@\n-  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, float_sign_flip, vec_enc);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, float_sign_flip, vec_enc);\n@@ -4639,2 +4612,0 @@\n-  assert(rscratch != noreg || always_reachable(double_sign_flip), \"missing\");\n-\n@@ -4645,0 +4616,15 @@\n+\/\/ Handling for downcasting from double to integer or sub-word types on AVX2.\n+void C2_MacroAssembler::vector_castD2X_avx(BasicType to_elem_bt, XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n+                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4, XMMRegister xtmp5,\n+                                           AddressLiteral float_sign_flip, Register rscratch, int vec_enc) {\n+  int to_elem_sz = type2aelembytes(to_elem_bt);\n+  assert(to_elem_sz < 8, \"\");\n+  vcvttpd2dq(dst, src, vec_enc);\n+  vector_cast_double_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, xtmp5, rscratch,\n+                                              float_sign_flip, vec_enc);\n+  if (to_elem_sz < 4) {\n+    \/\/ xtmp4 holds all zero lanes.\n+    vector_cast_int_to_subword(to_elem_bt, dst, xtmp4, xtmp5, rscratch, Assembler::AVX_128bit);\n+  }\n+}\n+\n@@ -4649,1 +4635,0 @@\n-  assert(rscratch != noreg || always_reachable(sign_flip), \"missing\");\n@@ -4651,1 +4636,2 @@\n-    vector_castD2L_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, sign_flip, rscratch, vec_enc);\n+    evcvttpd2qq(dst, src, vec_enc);\n+    vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n@@ -4670,1 +4656,2 @@\n-    vector_castD2I_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, sign_flip, rscratch, vec_enc);\n+    vcvttpd2dq(dst, src, vec_enc);\n+    vector_cast_double_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, rscratch, sign_flip, vec_enc);\n@@ -4697,3 +4684,2 @@\n-\n-  vector_cast_double_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n-                                        double_sign_flip, vec_enc);;\n+  vector_cast_double_to_long_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                                double_sign_flip, vec_enc);;\n@@ -4716,2 +4702,2 @@\n-  vector_cast_float_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n-                                       float_sign_flip, vec_enc);\n+  vector_cast_float_to_int_special_cases_evex(dst, src, xtmp1, xtmp2, ktmp1, ktmp2, tmp \/*rscratch*\/,\n+                                              float_sign_flip, vec_enc);\n@@ -4734,1 +4720,1 @@\n-  vector_cast_float_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, tmp \/*rscratch*\/, float_sign_flip, vec_enc);\n+  vector_cast_float_to_int_special_cases_avx(dst, src, xtmp1, xtmp2, xtmp3, xtmp4, tmp \/*rscratch*\/, float_sign_flip, vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":90,"deletions":104,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -311,0 +311,6 @@\n+  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n+                            BasicType from_elem_bt, BasicType to_elem_bt);\n+\n+  void vector_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n+                                  XMMRegister xtmp, Register rscratch, int vec_enc);\n+\n@@ -323,4 +329,0 @@\n-  void vector_castD2L_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                           Register rscratch, int vec_enc);\n-\n@@ -331,4 +333,0 @@\n-  void vector_castD2I_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                           KRegister ktmp1, KRegister ktmp2, AddressLiteral double_sign_flip,\n-                           Register rscratch, int vec_enc);\n-\n@@ -339,1 +337,0 @@\n-  void vector_pack_lower_quadword_from_lanes_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp, int vec_enc);\n@@ -341,7 +338,1 @@\n-  void vector_narrow_cast_int_to_subword(BasicType to_elem_bt, XMMRegister dst, XMMRegister zero,\n-                                         XMMRegister xtmp, Register rscratch, int vec_enc);\n-\n-  void vector_unsigned_cast(XMMRegister dst, XMMRegister src, int vlen_enc,\n-                            BasicType from_elem_bt, BasicType to_elem_bt);\n-\n-  void vector_narrow_cast_double_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+  void vector_cast_double_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n@@ -351,3 +342,2 @@\n-  void vector_narrow_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                    Register rscratch, AddressLiteral float_sign_flip,\n+  void vector_cast_double_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n@@ -356,3 +346,3 @@\n-  void vector_cast_double_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                             KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n-                                             int vec_enc);\n+  void vector_cast_double_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                     KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n+                                                     int vec_enc);\n@@ -360,3 +350,3 @@\n-  void vector_cast_float_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n-                                            KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n-                                            int vec_enc);\n+  void vector_cast_float_to_int_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                   KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral float_sign_flip,\n+                                                   int vec_enc);\n@@ -364,3 +354,2 @@\n-  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                                    XMMRegister xtmp2, KRegister ktmp1, KRegister ktmp2,\n-                                                    Register rscratch, AddressLiteral double_sign_flip,\n+  void vector_cast_float_to_long_special_cases_evex(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2,\n+                                                    KRegister ktmp1, KRegister ktmp2, Register rscratch, AddressLiteral double_sign_flip,\n@@ -369,4 +358,6 @@\n-  void vector_cast_float_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1,\n-                                           XMMRegister xtmp2, XMMRegister xtmp3, XMMRegister xtmp4,\n-                                           Register rscratch, AddressLiteral float_sign_flip,\n-                                           int vec_enc);\n+  void vector_cast_float_to_int_special_cases_avx(XMMRegister dst, XMMRegister src, XMMRegister xtmp1, XMMRegister xtmp2, XMMRegister xtmp3,\n+                                                  XMMRegister xtmp4, Register rscratch, AddressLiteral float_sign_flip,\n+                                                  int vec_enc);\n+\n+  void vector_crosslane_doubleword_pack_avx(XMMRegister dst, XMMRegister src, XMMRegister zero,\n+                                            XMMRegister xtmp, int index, int vec_enc);\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.hpp","additions":23,"deletions":32,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -1891,0 +1891,1 @@\n+      \/\/ fallthrough\n","filename":"src\/hotspot\/cpu\/x86\/x86.ad","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}