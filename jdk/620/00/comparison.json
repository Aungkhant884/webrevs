{"files":[{"patch":"@@ -142,2 +142,0 @@\n-  static bool get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr);\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -910,0 +911,113 @@\n+#ifndef ZERO\n+#ifndef ARM\n+static bool get_frame_at_stack_banging_point(JavaThread* thread, address pc, const void* ucVoid, frame* fr) {\n+  if (Interpreter::contains(pc)) {\n+    \/\/ interpreter performs stack banging after the fixed frame header has\n+    \/\/ been generated while the compilers perform it before. To maintain\n+    \/\/ semantic consistency between interpreted and compiled frames, the\n+    \/\/ method returns the Java sender of the current frame.\n+    *fr = os::fetch_frame_from_context(ucVoid);\n+    if (!fr->is_first_java_frame()) {\n+      \/\/ get_frame_at_stack_banging_point() is only called when we\n+      \/\/ have well defined stacks so java_sender() calls do not need\n+      \/\/ to assert safe_for_sender() first.\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    \/\/ more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      \/\/ Not sure where the pc points to, fallback to default\n+      \/\/ stack overflow handling\n+      return false;\n+    } else {\n+      \/\/ in compiled code, the stack banging is performed just after the return pc\n+      \/\/ has been pushed on the stack\n+      *fr = os::fetch_compiled_frame_from_context(ucVoid);\n+      if (!fr->is_java_frame()) {\n+        assert(!fr->is_first_frame(), \"Safety check\");\n+        \/\/ See java_sender() comment above.\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n+#endif \/\/ ARM\n+\n+\/\/ This return true if the signal handler should just continue, ie. return after calling this\n+bool os::Posix::handle_stack_overflow(JavaThread* thread, address addr, address pc,\n+                                      const void* ucVoid, address* stub) {\n+  \/\/ stack overflow\n+  StackOverflow* overflow_state = thread->stack_overflow_state();\n+  if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n+    if (thread->thread_state() == _thread_in_Java) {\n+#ifndef ARM\n+      \/\/ arm32 doesn't have this\n+      if (overflow_state->in_stack_reserved_zone(addr)) {\n+        frame fr;\n+        if (get_frame_at_stack_banging_point(thread, pc, ucVoid, &fr)) {\n+          assert(fr.is_java_frame(), \"Must be a Java frame\");\n+          frame activation =\n+            SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n+          if (activation.sp() != NULL) {\n+            overflow_state->disable_stack_reserved_zone();\n+            if (activation.is_interpreted_frame()) {\n+              overflow_state->set_reserved_stack_activation((address)(\n+                activation.fp() + frame::interpreter_frame_initial_sp_offset));\n+            } else {\n+              overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n+            }\n+            return true; \/\/ just continue\n+          }\n+        }\n+      }\n+#endif \/\/ ARM\n+      \/\/ Throw a stack overflow exception.  Guard pages will be reenabled\n+      \/\/ while unwinding the stack.\n+      overflow_state->disable_stack_yellow_reserved_zone();\n+      *stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n+    } else {\n+      \/\/ Thread was in the vm or native code.  Return and try to finish.\n+      overflow_state->disable_stack_yellow_reserved_zone();\n+      return true; \/\/ just continue\n+    }\n+  } else if (overflow_state->in_stack_red_zone(addr)) {\n+    \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n+    \/\/ to handle_unexpected_exception way down below.\n+    overflow_state->disable_stack_red_zone();\n+    tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n+\n+    \/\/ This is a likely cause, but hard to verify. Let's just print\n+    \/\/ it as a hint.\n+    tty->print_raw_cr(\"Please check if any of your loaded .so files has \"\n+                      \"enabled executable stack (see man page execstack(8))\");\n+\n+  } else {\n+#if !defined(AIX) && !defined(__APPLE__)\n+    \/\/ bsd and aix don't have this\n+\n+    \/\/ Accessing stack address below sp may cause SEGV if current\n+    \/\/ thread has MAP_GROWSDOWN stack. This should only happen when\n+    \/\/ current thread was created by user code with MAP_GROWSDOWN flag\n+    \/\/ and then attached to VM. See notes in os_linux.cpp.\n+    if (thread->osthread()->expanding_stack() == 0) {\n+       thread->osthread()->set_expanding_stack();\n+       if (os::Linux::manually_expand_stack(thread, addr)) {\n+         thread->osthread()->clear_expanding_stack();\n+         return true; \/\/ just continue\n+       }\n+       thread->osthread()->clear_expanding_stack();\n+    } else {\n+       fatal(\"recursive segv. expanding stack.\");\n+    }\n+#else\n+    tty->print_raw_cr(\"SIGSEGV happened inside stack but outside yellow and red zone.\");\n+#endif \/\/ AIX or BSD\n+  }\n+  return false;\n+}\n+#endif \/\/ ZERO\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":114,"deletions":0,"binary":false,"changes":114,"status":"modified"},{"patch":"@@ -109,0 +109,4 @@\n+\n+  static bool handle_stack_overflow(JavaThread* thread, address addr, address pc,\n+                                    const void* ucVoid,\n+                                    address* stub);\n","filename":"src\/hotspot\/os\/posix\/os_posix.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -145,34 +145,5 @@\n-bool os::Aix::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n-  address pc = (address) os::Aix::ucontext_get_pc(uc);\n-  if (Interpreter::contains(pc)) {\n-    \/\/ Interpreter performs stack banging after the fixed frame header has\n-    \/\/ been generated while the compilers perform it before. To maintain\n-    \/\/ semantic consistency between interpreted and compiled frames, the\n-    \/\/ method returns the Java sender of the current frame.\n-    *fr = os::fetch_frame_from_context(uc);\n-    if (!fr->is_first_java_frame()) {\n-      assert(fr->safe_for_sender(thread), \"Safety check\");\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ More complex code with compiled code.\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling. In compiled code, we bang before\n-      \/\/ the frame is complete.\n-      return false;\n-    } else {\n-      intptr_t* sp = os::Aix::ucontext_get_sp(uc);\n-      address lr = ucontext_get_lr(uc);\n-      *fr = frame(sp, lr);\n-      if (!fr->is_java_frame()) {\n-        assert(fr->safe_for_sender(thread), \"Safety check\");\n-        assert(!fr->is_first_frame(), \"Safety check\");\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  intptr_t* sp = os::Aix::ucontext_get_sp(uc);\n+  address lr = ucontext_get_lr(uc);\n+  *fr = frame(sp, lr);\n@@ -270,43 +241,4 @@\n-      StackOverflow* overflow_state = thread->stack_overflow_state();\n-\n-      \/\/\n-      \/\/ If we are in a yellow zone and we are inside java, we disable the yellow zone and\n-      \/\/ throw a stack overflow exception.\n-      \/\/ If we are in native code or VM C code, we report-and-die. The original coding tried\n-      \/\/ to continue with yellow zone disabled, but that doesn't buy us much and prevents\n-      \/\/ hs_err_pid files.\n-      if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n-        if (thread->thread_state() == _thread_in_Java) {\n-            if (overflow_state->in_stack_reserved_zone(addr)) {\n-              frame fr;\n-              if (os::Aix::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n-                assert(fr.is_java_frame(), \"Must be a Javac frame\");\n-                frame activation =\n-                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n-                if (activation.sp() != NULL) {\n-                  overflow_state->disable_stack_reserved_zone();\n-                  if (activation.is_interpreted_frame()) {\n-                    overflow_state->set_reserved_stack_activation((address)activation.fp());\n-                  } else {\n-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n-                  }\n-                  return 1;\n-                }\n-              }\n-            }\n-          \/\/ Throw a stack overflow exception.\n-          \/\/ Guard pages will be reenabled while unwinding the stack.\n-          overflow_state->disable_stack_yellow_reserved_zone();\n-          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n-          goto run_stub;\n-        } else {\n-          \/\/ Thread was in the vm or native code. Return and try to finish.\n-          overflow_state->disable_stack_yellow_reserved_zone();\n-          return 1;\n-        }\n-      } else if (overflow_state->in_stack_red_zone(addr)) {\n-        \/\/ Fatal red zone violation. Disable the guard pages and fall through\n-        \/\/ to handle_unexpected_exception way down below.\n-        overflow_state->disable_stack_red_zone();\n-        tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n-        goto report_and_die;\n+      if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+        return 1; \/\/ continue\n+      } else if (stub != NULL) {\n+        goto run_stub;\n@@ -314,3 +246,0 @@\n-        \/\/ This means a segv happened inside our stack, but not in\n-        \/\/ the guarded zone. I'd like to know when this happens,\n-        tty->print_raw_cr(\"SIGSEGV happened inside stack but outside yellow and red zone.\");\n@@ -319,1 +248,0 @@\n-\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":9,"deletions":81,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -342,35 +342,6 @@\n-bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n-  address pc = (address) os::Bsd::ucontext_get_pc(uc);\n-  if (Interpreter::contains(pc)) {\n-    \/\/ interpreter performs stack banging after the fixed frame header has\n-    \/\/ been generated while the compilers perform it before. To maintain\n-    \/\/ semantic consistency between interpreted and compiled frames, the\n-    \/\/ method returns the Java sender of the current frame.\n-    *fr = os::fetch_frame_from_context(uc);\n-    if (!fr->is_first_java_frame()) {\n-      \/\/ get_frame_at_stack_banging_point() is only called when we\n-      \/\/ have well defined stacks so java_sender() calls do not need\n-      \/\/ to assert safe_for_sender() first.\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ more complex code with compiled code\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling\n-      return false;\n-    } else {\n-      *fr = os::fetch_frame_from_context(uc);\n-      \/\/ in compiled code, the stack banging is performed just after the return pc\n-      \/\/ has been pushed on the stack\n-      *fr = frame(fr->sp() + 1, fr->fp(), (address)*(fr->sp()));\n-      if (!fr->is_java_frame()) {\n-        \/\/ See java_sender() comment above.\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  frame fr = os::fetch_frame_from_context(uc);\n+  \/\/ in compiled code, the stack banging is performed just after the return pc\n+  \/\/ has been pushed on the stack\n+  return frame(fr.sp() + 1, fr.fp(), (address)*(fr.sp()));\n@@ -498,34 +469,2 @@\n-        StackOverflow* overflow_state = thread->stack_overflow_state();\n-        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n-          if (thread->thread_state() == _thread_in_Java) {\n-            if (overflow_state->in_stack_reserved_zone(addr)) {\n-              frame fr;\n-              if (os::Bsd::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n-                assert(fr.is_java_frame(), \"Must be a Java frame\");\n-                frame activation = SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n-                if (activation.sp() != NULL) {\n-                  overflow_state->disable_stack_reserved_zone();\n-                  if (activation.is_interpreted_frame()) {\n-                    overflow_state->set_reserved_stack_activation((address)(\n-                      activation.fp() + frame::interpreter_frame_initial_sp_offset));\n-                  } else {\n-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n-                  }\n-                  return 1;\n-                }\n-              }\n-            }\n-            \/\/ Throw a stack overflow exception.  Guard pages will be reenabled\n-            \/\/ while unwinding the stack.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n-          } else {\n-            \/\/ Thread was in the vm or native code.  Return and try to finish.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            return 1;\n-          }\n-        } else if (overflow_state->in_stack_red_zone(addr)) {\n-          \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n-          \/\/ to handle_unexpected_exception way down below.\n-          overflow_state->disable_stack_red_zone();\n-          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return 1; \/\/ continue\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":8,"deletions":69,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -137,27 +137,8 @@\n-bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n-  address pc = (address) os::Linux::ucontext_get_pc(uc);\n-  if (Interpreter::contains(pc)) {\n-    \/\/ interpreter performs stack banging after the fixed frame header has\n-    \/\/ been generated while the compilers perform it before. To maintain\n-    \/\/ semantic consistency between interpreted and compiled frames, the\n-    \/\/ method returns the Java sender of the current frame.\n-    *fr = os::fetch_frame_from_context(uc);\n-    if (!fr->is_first_java_frame()) {\n-      assert(fr->safe_for_sender(thread), \"Safety check\");\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ more complex code with compiled code\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling\n-      return false;\n-    } else {\n-      \/\/ In compiled code, the stack banging is performed before LR\n-      \/\/ has been saved in the frame.  LR is live, and SP and FP\n-      \/\/ belong to the caller.\n-      intptr_t* fp = os::Linux::ucontext_get_fp(uc);\n-      intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n-      address pc = (address)(uc->uc_mcontext.regs[REG_LR]\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  \/\/ In compiled code, the stack banging is performed before LR\n+  \/\/ has been saved in the frame.  LR is live, and SP and FP\n+  \/\/ belong to the caller.\n+  intptr_t* fp = os::Linux::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n+  address pc = (address)(uc->uc_mcontext.regs[REG_LR]\n@@ -165,10 +146,1 @@\n-      *fr = frame(sp, fp, pc);\n-      if (!fr->is_java_frame()) {\n-        assert(fr->safe_for_sender(thread), \"Safety check\");\n-        assert(!fr->is_first_frame(), \"Safety check\");\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n+  return frame(sp, fp, pc);\n@@ -282,56 +254,2 @@\n-        StackOverflow* overflow_state = thread->stack_overflow_state();\n-        \/\/ stack overflow\n-        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n-          if (thread->thread_state() == _thread_in_Java) {\n-            if (overflow_state->in_stack_reserved_zone(addr)) {\n-              frame fr;\n-              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n-                assert(fr.is_java_frame(), \"Must be a Java frame\");\n-                frame activation =\n-                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n-                if (activation.sp() != NULL) {\n-                  overflow_state->disable_stack_reserved_zone();\n-                  if (activation.is_interpreted_frame()) {\n-                    overflow_state->set_reserved_stack_activation((address)(\n-                      activation.fp() + frame::interpreter_frame_initial_sp_offset));\n-                  } else {\n-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n-                  }\n-                  return 1;\n-                }\n-              }\n-            }\n-            \/\/ Throw a stack overflow exception.  Guard pages will be reenabled\n-            \/\/ while unwinding the stack.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n-          } else {\n-            \/\/ Thread was in the vm or native code.  Return and try to finish.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            return 1;\n-          }\n-        } else if (overflow_state->in_stack_red_zone(addr)) {\n-          \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n-          \/\/ to handle_unexpected_exception way down below.\n-          overflow_state->disable_stack_red_zone();\n-          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n-\n-          \/\/ This is a likely cause, but hard to verify. Let's just print\n-          \/\/ it as a hint.\n-          tty->print_raw_cr(\"Please check if any of your loaded .so files has \"\n-                            \"enabled executable stack (see man page execstack(8))\");\n-        } else {\n-          \/\/ Accessing stack address below sp may cause SEGV if current\n-          \/\/ thread has MAP_GROWSDOWN stack. This should only happen when\n-          \/\/ current thread was created by user code with MAP_GROWSDOWN flag\n-          \/\/ and then attached to VM. See notes in os_linux.cpp.\n-          if (thread->osthread()->expanding_stack() == 0) {\n-             thread->osthread()->set_expanding_stack();\n-             if (os::Linux::manually_expand_stack(thread, addr)) {\n-               thread->osthread()->clear_expanding_stack();\n-               return 1;\n-             }\n-             thread->osthread()->clear_expanding_stack();\n-          } else {\n-             fatal(\"recursive segv. expanding stack.\");\n-          }\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return 1; \/\/ continue\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":11,"deletions":93,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -165,34 +165,5 @@\n-bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n-  address pc = (address) os::Linux::ucontext_get_pc(uc);\n-  if (Interpreter::contains(pc)) {\n-    \/\/ Interpreter performs stack banging after the fixed frame header has\n-    \/\/ been generated while the compilers perform it before. To maintain\n-    \/\/ semantic consistency between interpreted and compiled frames, the\n-    \/\/ method returns the Java sender of the current frame.\n-    *fr = os::fetch_frame_from_context(uc);\n-    if (!fr->is_first_java_frame()) {\n-      assert(fr->safe_for_sender(thread), \"Safety check\");\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ More complex code with compiled code.\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling. In compiled code, we bang before\n-      \/\/ the frame is complete.\n-      return false;\n-    } else {\n-      intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n-      address lr = ucontext_get_lr(uc);\n-      *fr = frame(sp, lr);\n-      if (!fr->is_java_frame()) {\n-        assert(fr->safe_for_sender(thread), \"Safety check\");\n-        assert(!fr->is_first_frame(), \"Safety check\");\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n+  address lr = ucontext_get_lr(uc);\n+  return frame(sp, lr);\n@@ -330,54 +301,2 @@\n-        StackOverflow* overflow_state = thread->stack_overflow_state();\n-        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n-          if (thread->thread_state() == _thread_in_Java) {\n-            if (overflow_state->in_stack_reserved_zone(addr)) {\n-              frame fr;\n-              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n-                assert(fr.is_java_frame(), \"Must be a Javac frame\");\n-                frame activation =\n-                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n-                if (activation.sp() != NULL) {\n-                  overflow_state->disable_stack_reserved_zone();\n-                  if (activation.is_interpreted_frame()) {\n-                    overflow_state->set_reserved_stack_activation((address)activation.fp());\n-                  } else {\n-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n-                  }\n-                  return 1;\n-                }\n-              }\n-            }\n-            \/\/ Throw a stack overflow exception.\n-            \/\/ Guard pages will be reenabled while unwinding the stack.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n-          } else {\n-            \/\/ Thread was in the vm or native code. Return and try to finish.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            return 1;\n-          }\n-        } else if (overflow_state->in_stack_red_zone(addr)) {\n-          \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n-          \/\/ to handle_unexpected_exception way down below.\n-          overflow_state->disable_stack_red_zone();\n-          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n-\n-          \/\/ This is a likely cause, but hard to verify. Let's just print\n-          \/\/ it as a hint.\n-          tty->print_raw_cr(\"Please check if any of your loaded .so files has \"\n-                            \"enabled executable stack (see man page execstack(8))\");\n-        } else {\n-          \/\/ Accessing stack address below sp may cause SEGV if current\n-          \/\/ thread has MAP_GROWSDOWN stack. This should only happen when\n-          \/\/ current thread was created by user code with MAP_GROWSDOWN flag\n-          \/\/ and then attached to VM. See notes in os_linux.cpp.\n-          if (thread->osthread()->expanding_stack() == 0) {\n-             thread->osthread()->set_expanding_stack();\n-             if (os::Linux::manually_expand_stack(thread, addr)) {\n-               thread->osthread()->clear_expanding_stack();\n-               return 1;\n-             }\n-             thread->osthread()->clear_expanding_stack();\n-          } else {\n-             fatal(\"recursive segv. expanding stack.\");\n-          }\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return 1; \/\/ continue\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":7,"deletions":88,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -148,34 +148,5 @@\n-bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n-  address pc = (address) os::Linux::ucontext_get_pc(uc);\n-  if (Interpreter::contains(pc)) {\n-    \/\/ Interpreter performs stack banging after the fixed frame header has\n-    \/\/ been generated while the compilers perform it before. To maintain\n-    \/\/ semantic consistency between interpreted and compiled frames, the\n-    \/\/ method returns the Java sender of the current frame.\n-    *fr = os::fetch_frame_from_context(uc);\n-    if (!fr->is_first_java_frame()) {\n-      assert(fr->safe_for_sender(thread), \"Safety check\");\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ More complex code with compiled code.\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling. In compiled code, we bang before\n-      \/\/ the frame is complete.\n-      return false;\n-    } else {\n-      intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n-      address lr = ucontext_get_lr(uc);\n-      *fr = frame(sp, lr);\n-      if (!fr->is_java_frame()) {\n-        assert(fr->safe_for_sender(thread), \"Safety check\");\n-        assert(!fr->is_first_frame(), \"Safety check\");\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n+  address lr = ucontext_get_lr(uc);\n+  return frame(sp, lr);\n@@ -326,54 +297,2 @@\n-        StackOverflow* overflow_state = thread->stack_overflow_state();\n-        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n-          if (thread->thread_state() == _thread_in_Java) {\n-            if (overflow_state->in_stack_reserved_zone(addr)) {\n-              frame fr;\n-              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n-                assert(fr.is_java_frame(), \"Must be a Javac frame\");\n-                frame activation =\n-                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n-                if (activation.sp() != NULL) {\n-                  overflow_state->disable_stack_reserved_zone();\n-                  if (activation.is_interpreted_frame()) {\n-                    overflow_state->set_reserved_stack_activation((address)activation.fp());\n-                  } else {\n-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n-                  }\n-                  return 1;\n-                }\n-              }\n-            }\n-            \/\/ Throw a stack overflow exception.\n-            \/\/ Guard pages will be reenabled while unwinding the stack.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n-          } else {\n-            \/\/ Thread was in the vm or native code. Return and try to finish.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            return 1;\n-          }\n-        } else if (overflow_state->in_stack_red_zone(addr)) {\n-          \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n-          \/\/ to handle_unexpected_exception way down below.\n-          overflow_state->disable_stack_red_zone();\n-          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n-\n-          \/\/ This is a likely cause, but hard to verify. Let's just print\n-          \/\/ it as a hint.\n-          tty->print_raw_cr(\"Please check if any of your loaded .so files has \"\n-                            \"enabled executable stack (see man page execstack(8))\");\n-        } else {\n-          \/\/ Accessing stack address below sp may cause SEGV if current\n-          \/\/ thread has MAP_GROWSDOWN stack. This should only happen when\n-          \/\/ current thread was created by user code with MAP_GROWSDOWN flag\n-          \/\/ and then attached to VM. See notes in os_linux.cpp.\n-          if (thread->osthread()->expanding_stack() == 0) {\n-             thread->osthread()->set_expanding_stack();\n-             if (os::Linux::manually_expand_stack(thread, addr)) {\n-               thread->osthread()->clear_expanding_stack();\n-               return 1;\n-             }\n-             thread->osthread()->clear_expanding_stack();\n-          } else {\n-             fatal(\"recursive segv. expanding stack.\");\n-          }\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return 1; \/\/ continue\n","filename":"src\/hotspot\/os_cpu\/linux_s390\/os_linux_s390.cpp","additions":7,"deletions":88,"binary":false,"changes":95,"status":"modified"},{"patch":"@@ -151,37 +151,5 @@\n-bool os::Linux::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n-  address pc = (address) os::Linux::ucontext_get_pc(uc);\n-  if (Interpreter::contains(pc)) {\n-    \/\/ interpreter performs stack banging after the fixed frame header has\n-    \/\/ been generated while the compilers perform it before. To maintain\n-    \/\/ semantic consistency between interpreted and compiled frames, the\n-    \/\/ method returns the Java sender of the current frame.\n-    *fr = os::fetch_frame_from_context(uc);\n-    if (!fr->is_first_java_frame()) {\n-      \/\/ get_frame_at_stack_banging_point() is only called when we\n-      \/\/ have well defined stacks so java_sender() calls do not need\n-      \/\/ to assert safe_for_sender() first.\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ more complex code with compiled code\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling\n-      return false;\n-    } else {\n-      \/\/ in compiled code, the stack banging is performed just after the return pc\n-      \/\/ has been pushed on the stack\n-      intptr_t* fp = os::Linux::ucontext_get_fp(uc);\n-      intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n-      *fr = frame(sp + 1, fp, (address)*sp);\n-      if (!fr->is_java_frame()) {\n-        assert(!fr->is_first_frame(), \"Safety check\");\n-        \/\/ See java_sender() comment above.\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n+frame os::fetch_compiled_frame_from_context(const void* ucVoid) {\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+  intptr_t* fp = os::Linux::ucontext_get_fp(uc);\n+  intptr_t* sp = os::Linux::ucontext_get_sp(uc);\n+  return frame(sp + 1, fp, (address)*sp);\n@@ -327,55 +295,2 @@\n-        StackOverflow* overflow_state = thread->stack_overflow_state();\n-        if (overflow_state->in_stack_yellow_reserved_zone(addr)) {\n-          if (thread->thread_state() == _thread_in_Java) {\n-            if (overflow_state->in_stack_reserved_zone(addr)) {\n-              frame fr;\n-              if (os::Linux::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n-                assert(fr.is_java_frame(), \"Must be a Java frame\");\n-                frame activation =\n-                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n-                if (activation.sp() != NULL) {\n-                  overflow_state->disable_stack_reserved_zone();\n-                  if (activation.is_interpreted_frame()) {\n-                    overflow_state->set_reserved_stack_activation((address)(\n-                      activation.fp() + frame::interpreter_frame_initial_sp_offset));\n-                  } else {\n-                    overflow_state->set_reserved_stack_activation((address)activation.unextended_sp());\n-                  }\n-                  return 1;\n-                }\n-              }\n-            }\n-            \/\/ Throw a stack overflow exception.  Guard pages will be reenabled\n-            \/\/ while unwinding the stack.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n-          } else {\n-            \/\/ Thread was in the vm or native code.  Return and try to finish.\n-            overflow_state->disable_stack_yellow_reserved_zone();\n-            return 1;\n-          }\n-        } else if (overflow_state->in_stack_red_zone(addr)) {\n-          \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n-          \/\/ to handle_unexpected_exception way down below.\n-          overflow_state->disable_stack_red_zone();\n-          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n-\n-          \/\/ This is a likely cause, but hard to verify. Let's just print\n-          \/\/ it as a hint.\n-          tty->print_raw_cr(\"Please check if any of your loaded .so files has \"\n-                            \"enabled executable stack (see man page execstack(8))\");\n-        } else {\n-          \/\/ Accessing stack address below sp may cause SEGV if current\n-          \/\/ thread has MAP_GROWSDOWN stack. This should only happen when\n-          \/\/ current thread was created by user code with MAP_GROWSDOWN flag\n-          \/\/ and then attached to VM. See notes in os_linux.cpp.\n-          if (thread->osthread()->expanding_stack() == 0) {\n-             thread->osthread()->set_expanding_stack();\n-             if (os::Linux::manually_expand_stack(thread, addr)) {\n-               thread->osthread()->clear_expanding_stack();\n-               return 1;\n-             }\n-             thread->osthread()->clear_expanding_stack();\n-          } else {\n-             fatal(\"recursive segv. expanding stack.\");\n-          }\n+        if (os::Posix::handle_stack_overflow(thread, addr, pc, uc, &stub)) {\n+          return 1; \/\/ continue\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":7,"deletions":92,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -485,0 +485,1 @@\n+  static frame      fetch_compiled_frame_from_context(const void* ucVoid);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}