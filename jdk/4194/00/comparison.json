{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2015, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,4 +28,0 @@\n-$(eval $(call SetupBuildLauncher, rmid, \\\n-    MAIN_CLASS := sun.rmi.server.Activation, \\\n-))\n-\n","filename":"make\/modules\/java.rmi\/Launcher.gmk","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1064,1 +1064,0 @@\n-#    java.rmi.activation.ActivationID;\\\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1,352 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.rmi.rmid;\n-\n-import java.security.*;\n-import java.io.*;\n-import java.util.*;\n-\n-\/**\n- * The ExecOptionPermission class represents permission for rmid to use\n- * a specific command-line option when launching an activation group.\n- *\n- * @author Ann Wollrath\n- *\n- * @serial exclude\n- * @deprecated See the\n- * <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-public final class ExecOptionPermission extends Permission\n-{\n-    \/**\n-     * does this permission have a wildcard at the end?\n-     *\/\n-    private transient boolean wildcard;\n-\n-    \/**\n-     * the name without the wildcard on the end\n-     *\/\n-    private transient String name;\n-\n-    \/**\n-     * UID for serialization\n-     *\/\n-    private static final long serialVersionUID = 5842294756823092756L;\n-\n-    public ExecOptionPermission(String name) {\n-        super(name);\n-        init(name);\n-    }\n-\n-    public ExecOptionPermission(String name, String actions) {\n-        this(name);\n-    }\n-\n-    \/**\n-     * Checks if the specified permission is \"implied\" by\n-     * this object.\n-     * <P>\n-     * More specifically, this method returns true if:\n-     * <ul>\n-     * <li> <i>p<\/i>'s class is the same as this object's class, and\n-     * <li> <i>p<\/i>'s name equals or (in the case of wildcards)\n-     *      is implied by this object's\n-     *      name. For example, \"a.b.*\" implies \"a.b.c\", and\n-     *      \"a.b=*\" implies \"a.b=c\"\n-     * <\/ul>\n-     *\n-     * @param p the permission to check against.\n-     *\n-     * @return true if the passed permission is equal to or\n-     * implied by this permission, false otherwise.\n-     *\/\n-    public boolean implies(Permission p) {\n-        if (!(p instanceof ExecOptionPermission))\n-            return false;\n-\n-        ExecOptionPermission that = (ExecOptionPermission) p;\n-\n-        if (this.wildcard) {\n-            if (that.wildcard) {\n-                \/\/ one wildcard can imply another\n-                return that.name.startsWith(name);\n-            } else {\n-                \/\/ make sure p.name is longer so a.b.* doesn't imply a.b\n-                return (that.name.length() > this.name.length()) &&\n-                    that.name.startsWith(this.name);\n-            }\n-        } else {\n-            if (that.wildcard) {\n-                \/\/ a non-wildcard can't imply a wildcard\n-                return false;\n-            } else {\n-                return this.name.equals(that.name);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Checks two ExecOptionPermission objects for equality.\n-     * Checks that <i>obj<\/i>'s class is the same as this object's class\n-     * and has the same name as this object.\n-     *\n-     * @param obj the object we are testing for equality with this object.\n-     * @return true if <i>obj<\/i> is an ExecOptionPermission, and has the same\n-     * name as this ExecOptionPermission object, false otherwise.\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (obj == this)\n-            return true;\n-\n-        if ((obj == null) || (obj.getClass() != getClass()))\n-            return false;\n-\n-        ExecOptionPermission that = (ExecOptionPermission) obj;\n-\n-        return this.getName().equals(that.getName());\n-    }\n-\n-\n-    \/**\n-     * Returns the hash code value for this object.\n-     * The hash code used is the hash code of the name, that is,\n-     * <code>getName().hashCode()<\/code>, where <code>getName<\/code> is\n-     * from the Permission superclass.\n-     *\n-     * @return a hash code value for this object.\n-     *\/\n-    public int hashCode() {\n-        return this.getName().hashCode();\n-    }\n-\n-    \/**\n-     * Returns the canonical string representation of the actions.\n-     *\n-     * @return the canonical string representation of the actions.\n-     *\/\n-    public String getActions() {\n-        return \"\";\n-    }\n-\n-    \/**\n-     * Returns a new PermissionCollection object for storing\n-     * ExecOptionPermission objects.\n-     * <p>\n-     * An ExecOptionPermissionCollection stores a collection of\n-     * ExecOptionPermission permissions.\n-     *\n-     * <p>ExecOptionPermission objects must be stored in a manner that allows\n-     * them to be inserted in any order, but that also enables the\n-     * PermissionCollection <code>implies<\/code> method\n-     * to be implemented in an efficient (and consistent) manner.\n-     *\n-     * @return a new PermissionCollection object suitable for\n-     * storing ExecOptionPermissions.\n-     *\/\n-    public PermissionCollection newPermissionCollection() {\n-        return new ExecOptionPermissionCollection();\n-    }\n-\n-    \/**\n-     * readObject is called to restore the state of the ExecOptionPermission\n-     * from a stream.\n-     *\/\n-    private synchronized void readObject(java.io.ObjectInputStream s)\n-         throws IOException, ClassNotFoundException\n-    {\n-        s.defaultReadObject();\n-        \/\/ init is called to initialize the rest of the values.\n-        init(getName());\n-    }\n-\n-    \/**\n-     * Initialize a ExecOptionPermission object. Common to all constructors.\n-     * Also called during de-serialization.\n-     *\/\n-    private void init(String name)\n-    {\n-        if (name == null)\n-            throw new NullPointerException(\"name can't be null\");\n-\n-        if (name.isEmpty()) {\n-            throw new IllegalArgumentException(\"name can't be empty\");\n-        }\n-\n-        if (name.endsWith(\".*\") || name.endsWith(\"=*\") || name.equals(\"*\")) {\n-            wildcard = true;\n-            if (name.length() == 1) {\n-                this.name = \"\";\n-            } else {\n-                this.name = name.substring(0, name.length()-1);\n-            }\n-        } else {\n-            this.name = name;\n-        }\n-    }\n-\n-    \/**\n-     * A ExecOptionPermissionCollection stores a collection\n-     * of ExecOptionPermission permissions. ExecOptionPermission objects\n-     * must be stored in a manner that allows them to be inserted in any\n-     * order, but enable the implies function to evaluate the implies\n-     * method in an efficient (and consistent) manner.\n-     *\n-     * A ExecOptionPermissionCollection handles comparing a permission like\n-     * \"a.b.c.d.e\" * with a Permission such as \"a.b.*\", or \"*\".\n-     *\n-     * @serial include\n-     *\/\n-    private static class ExecOptionPermissionCollection\n-        extends PermissionCollection\n-        implements java.io.Serializable\n-    {\n-\n-        private Hashtable<String, Permission> permissions;\n-        private boolean all_allowed; \/\/ true if \"*\" is in the collection\n-        private static final long serialVersionUID = -1242475729790124375L;\n-\n-        \/**\n-         * Create an empty ExecOptionPermissionCollection.\n-         *\/\n-        public ExecOptionPermissionCollection() {\n-            permissions = new Hashtable<>(11);\n-            all_allowed = false;\n-        }\n-\n-        \/**\n-         * Adds a permission to the collection. The key for the hash is\n-         * permission.name.\n-         *\n-         * @param permission the Permission object to add.\n-         *\n-         * @exception IllegalArgumentException - if the permission is not a\n-         *                                       ExecOptionPermission\n-         *\n-         * @exception SecurityException - if this ExecOptionPermissionCollection\n-         *                                object has been marked readonly\n-         *\/\n-\n-        public void add(Permission permission)\n-        {\n-            if (! (permission instanceof ExecOptionPermission))\n-                throw new IllegalArgumentException(\"invalid permission: \"+\n-                                                   permission);\n-            if (isReadOnly())\n-                throw new SecurityException(\"attempt to add a Permission to a readonly PermissionCollection\");\n-\n-            ExecOptionPermission p = (ExecOptionPermission) permission;\n-\n-            permissions.put(p.getName(), permission);\n-            if (!all_allowed) {\n-                if (p.getName().equals(\"*\"))\n-                    all_allowed = true;\n-            }\n-        }\n-\n-        \/**\n-         * Check and see if this set of permissions implies the permissions\n-         * expressed in \"permission\".\n-         *\n-         * @param p the Permission object to compare\n-         *\n-         * @return true if \"permission\" is a proper subset of a permission in\n-         * the set, false if not.\n-         *\/\n-        public boolean implies(Permission permission)\n-        {\n-            if (! (permission instanceof ExecOptionPermission))\n-                return false;\n-\n-            ExecOptionPermission p = (ExecOptionPermission) permission;\n-\n-            \/\/ short circuit if the \"*\" Permission was added\n-            if (all_allowed)\n-                return true;\n-\n-            \/\/ strategy:\n-            \/\/ Check for full match first. Then work our way up the\n-            \/\/ name looking for matches on a.b.*\n-\n-            String pname = p.getName();\n-\n-            Permission x = permissions.get(pname);\n-\n-            if (x != null)\n-                \/\/ we have a direct hit!\n-                return x.implies(permission);\n-\n-\n-            \/\/ work our way up the tree...\n-            int last, offset;\n-\n-            offset = pname.length() - 1;\n-\n-            while ((last = pname.lastIndexOf('.', offset)) != -1) {\n-\n-                pname = pname.substring(0, last+1) + \"*\";\n-                x = permissions.get(pname);\n-\n-                if (x != null) {\n-                    return x.implies(permission);\n-                }\n-                offset = last - 1;\n-            }\n-\n-            \/\/ check for \"=*\" wildcard match\n-            pname = p.getName();\n-            offset = pname.length() - 1;\n-\n-            while ((last = pname.lastIndexOf('=', offset)) != -1) {\n-\n-                pname = pname.substring(0, last+1) + \"*\";\n-                x = permissions.get(pname);\n-\n-                if (x != null) {\n-                    return x.implies(permission);\n-                }\n-                offset = last - 1;\n-            }\n-\n-            \/\/ we don't have to check for \"*\" as it was already checked\n-            \/\/ at the top (all_allowed), so we just return false\n-            return false;\n-        }\n-\n-        \/**\n-         * Returns an enumeration of all the ExecOptionPermission objects in the\n-         * container.\n-         *\n-         * @return an enumeration of all the ExecOptionPermission objects.\n-         *\/\n-\n-        public Enumeration<Permission> elements()\n-        {\n-            return permissions.elements();\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/com\/sun\/rmi\/rmid\/ExecOptionPermission.java","additions":0,"deletions":352,"binary":false,"changes":352,"status":"deleted"},{"patch":"@@ -1,302 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package com.sun.rmi.rmid;\n-\n-import java.security.*;\n-import java.io.*;\n-import java.util.*;\n-\n-\/**\n- * The ExecPermission class represents permission for rmid to execute\n- * a specific command to launch an activation group.  An ExecPermission\n- * consists of a pathname of a command to launch an activation group.\n- * <P>\n- * Pathname is the pathname of the file or directory to grant rmid\n- * execute permission.  A pathname that ends in \"\/*\" (where \"\/\" is\n- * the file separator character, <code>File.separatorChar<\/code>) indicates\n- * all the files and directories contained in that directory. A pathname\n- * that ends with \"\/-\" indicates (recursively) all files\n- * and subdirectories contained in that directory. A pathname consisting of\n- * the special token \"{@code <<ALL FILES>>}\" matches <b>any<\/b> file.\n- * <P>\n- * Note: A pathname consisting of a single \"*\" indicates all the files\n- * in the current directory, while a pathname consisting of a single \"-\"\n- * indicates all the files in the current directory and\n- * (recursively) all files and subdirectories contained in the current\n- * directory.\n- *\n- *\n- * @author Ann Wollrath\n- *\n- * @serial exclude\n- * @deprecated See the\n- * <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-public final class ExecPermission extends Permission\n-{\n-    \/**\n-     * UID for serialization\n-     *\/\n-    private static final long serialVersionUID = -6208470287358147919L;\n-\n-    private transient FilePermission fp;\n-\n-    \/**\n-     * Creates a new ExecPermission object with the specified path.\n-     * <i>path<\/i> is the pathname of a file or directory.\n-     *\n-     * <p>A pathname that ends in \"\/*\" (where \"\/\" is\n-     * the file separator character, <code>File.separatorChar<\/code>) indicates\n-     * a directory and all the files contained in that directory. A pathname\n-     * that ends with \"\/-\" indicates a directory and (recursively) all files\n-     * and subdirectories contained in that directory. The special pathname\n-     * \"{@code <<ALL FILES>>}\" matches all files.\n-     *\n-     * <p>A pathname consisting of a single \"*\" indicates all the files\n-     * in the current directory, while a pathname consisting of a single \"-\"\n-     * indicates all the files in the current directory and\n-     * (recursively) all files and subdirectories contained in the current\n-     * directory.\n-     *\n-     * @param path the pathname of the file\/directory.\n-     *\/\n-    public ExecPermission(String path) {\n-        super(path);\n-        init(path);\n-    }\n-\n-    \/**\n-     * Creates a new ExecPermission object with the specified path.\n-     * <i>path<\/i> is the pathname of a file or directory.\n-     *\n-     * <p>A pathname that ends in \"\/*\" (where \"\/\" is\n-     * the file separator character, <code>File.separatorChar<\/code>) indicates\n-     * a directory and all the files contained in that directory. A pathname\n-     * that ends with \"\/-\" indicates a directory and (recursively) all files\n-     * and subdirectories contained in that directory. The special pathname\n-     * \"{@code <<ALL FILES>>}\" matches all files.\n-     *\n-     * <p>A pathname consisting of a single \"*\" indicates all the files\n-     * in the current directory, while a pathname consisting of a single \"-\"\n-     * indicates all the files in the current directory and\n-     * (recursively) all files and subdirectories contained in the current\n-     * directory.\n-     *\n-     * @param path the pathname of the file\/directory.\n-     * @param actions the action string (unused)\n-     *\/\n-    public ExecPermission(String path, String actions) {\n-        this(path);\n-    }\n-\n-    \/**\n-     * Checks if this ExecPermission object \"implies\" the specified permission.\n-     * <P>\n-     * More specifically, this method returns true if:\n-     * <ul>\n-     * <li> <i>p<\/i> is an instanceof ExecPermission, and\n-     * <li> <i>p<\/i>'s pathname is implied by this object's\n-     *      pathname. For example, \"\/tmp\/*\" implies \"\/tmp\/foo\", since\n-     *      \"\/tmp\/*\" encompasses the \"\/tmp\" directory and all files in that\n-     *      directory, including the one named \"foo\".\n-     * <\/ul>\n-     * @param p the permission to check against.\n-     *\n-     * @return true if the specified permission is implied by this object,\n-     * false if not.\n-     *\/\n-    public boolean implies(Permission p) {\n-        if (!(p instanceof ExecPermission))\n-            return false;\n-\n-        ExecPermission that = (ExecPermission) p;\n-\n-        return fp.implies(that.fp);\n-    }\n-\n-    \/**\n-     * Checks two ExecPermission objects for equality.\n-     * Checks that <i>obj<\/i>'s class is the same as this object's class\n-     * and has the same name as this object.\n-     *\n-     * @param obj the object we are testing for equality with this object.\n-     * @return true if <i>obj<\/i> is an ExecPermission, and has the same\n-     * pathname as this ExecPermission object, false otherwise.\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (obj == this)\n-            return true;\n-\n-        if (! (obj instanceof ExecPermission))\n-            return false;\n-\n-        ExecPermission that = (ExecPermission) obj;\n-\n-        return fp.equals(that.fp);\n-    }\n-\n-    \/**\n-     * Returns the hash code value for this object.\n-     *\n-     * @return a hash code value for this object.\n-     *\/\n-    public int hashCode() {\n-        return this.fp.hashCode();\n-    }\n-\n-    \/**\n-     * Returns the canonical string representation of the actions.\n-     *\n-     * @return the canonical string representation of the actions.\n-     *\/\n-    public String getActions() {\n-        return \"\";\n-    }\n-\n-    \/**\n-     * Returns a new PermissionCollection object for storing\n-     * ExecPermission objects.\n-     * <p>\n-     * A ExecPermissionCollection stores a collection of\n-     * ExecPermission permissions.\n-     *\n-     * <p>ExecPermission objects must be stored in a manner that allows\n-     * them to be inserted in any order, but that also enables the\n-     * PermissionCollection <code>implies<\/code> method\n-     * to be implemented in an efficient (and consistent) manner.\n-     *\n-     * @return a new PermissionCollection object suitable for\n-     * storing ExecPermissions.\n-     *\/\n-    public PermissionCollection newPermissionCollection() {\n-        return new ExecPermissionCollection();\n-    }\n-\n-    \/**\n-     * readObject is called to restore the state of the ExecPermission\n-     * from a stream.\n-     *\/\n-    private synchronized void readObject(java.io.ObjectInputStream s)\n-         throws IOException, ClassNotFoundException\n-    {\n-        s.defaultReadObject();\n-        \/\/ init is called to initialize the rest of the values.\n-        init(getName());\n-    }\n-\n-    \/**\n-     * Initialize a ExecPermission object. Common to all constructors.\n-     * Also called during de-serialization.\n-     *\/\n-    private void init(String path) {\n-        this.fp = new FilePermission(path, \"execute\");\n-    }\n-\n-    \/**\n-     * A ExecPermissionCollection stores a collection\n-     * of ExecPermission permissions. ExecPermission objects\n-     * must be stored in a manner that allows them to be inserted in any\n-     * order, but enable the implies function to evaluate the implies\n-     * method in an efficient (and consistent) manner.\n-     *\n-     * @serial include\n-     *\/\n-    private static class ExecPermissionCollection\n-        extends PermissionCollection\n-        implements java.io.Serializable\n-    {\n-        private Vector<Permission> permissions;\n-\n-        private static final long serialVersionUID = -3352558508888368273L;\n-\n-        \/**\n-         * Create an empty ExecPermissionCollection.\n-         *\/\n-        public ExecPermissionCollection() {\n-            permissions = new Vector<>();\n-        }\n-\n-        \/**\n-         * Adds a permission to the collection.\n-         *\n-         * @param permission the Permission object to add.\n-         *\n-         * @exception IllegalArgumentException - if the permission is not a\n-         *                                       ExecPermission\n-         *\n-         * @exception SecurityException - if this ExecPermissionCollection\n-         *                                object has been marked readonly\n-         *\/\n-        public void add(Permission permission)\n-        {\n-            if (! (permission instanceof ExecPermission))\n-                throw new IllegalArgumentException(\"invalid permission: \"+\n-                                                   permission);\n-            if (isReadOnly())\n-                throw new SecurityException(\"attempt to add a Permission to a readonly PermissionCollection\");\n-\n-            permissions.addElement(permission);\n-        }\n-\n-        \/**\n-         * Check and see if this set of permissions implies the permissions\n-         * expressed in \"permission\".\n-         *\n-         * @param p the Permission object to compare\n-         *\n-         * @return true if \"permission\" is a proper subset of a permission in\n-         * the set, false if not.\n-         *\/\n-        public boolean implies(Permission permission)\n-        {\n-            if (! (permission instanceof ExecPermission))\n-                return false;\n-\n-            Enumeration<Permission> e = permissions.elements();\n-\n-            while (e.hasMoreElements()) {\n-                ExecPermission x = (ExecPermission)e.nextElement();\n-                if (x.implies(permission)) {\n-                    return true;\n-                }\n-            }\n-            return false;\n-        }\n-\n-        \/**\n-         * Returns an enumeration of all the ExecPermission objects in the\n-         * container.\n-         *\n-         * @return an enumeration of all the ExecPermission objects.\n-         *\/\n-        public Enumeration<Permission> elements()\n-        {\n-            return permissions.elements();\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/com\/sun\/rmi\/rmid\/ExecPermission.java","additions":0,"deletions":302,"binary":false,"changes":302,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,1 @@\n- * <code>rebind<\/code>, and <code>unbind<\/code>) and methods of the\n- * <code>java.rmi.activation.ActivationSystem<\/code> interface to\n+ * <code>rebind<\/code>, and <code>unbind<\/code>) to\n@@ -41,1 +40,0 @@\n- * @see     java.rmi.activation.ActivationSystem\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/AccessException.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,2 +38,1 @@\n- * <code>java.rmi.server.UnicastRemoteObject<\/code> and\n- * <code>java.rmi.activation.Activatable<\/code> and\n+ * <code>java.rmi.server.UnicastRemoteObject<\/code>.\n@@ -45,1 +44,0 @@\n- * @see     java.rmi.activation.Activatable#unexportObject(Remote,boolean)\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/NoSuchObjectException.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,5 +36,4 @@\n- * can extend other remote implementation classes.  RMI provides some\n- * convenience classes that remote object implementations can extend which\n- * facilitate remote object creation.  These classes are\n- * <code>java.rmi.server.UnicastRemoteObject<\/code> and\n- * <code>java.rmi.activation.Activatable<\/code>.\n+ * can extend other remote implementation classes.  RMI provides a convenience\n+ * class {@link java.rmi.server.UnicastRemoteObject UnicastRemoteObject}\n+ * that remote object implementations can extend and that facilitates remote\n+ * object creation.\n@@ -48,2 +47,0 @@\n- * @see     java.rmi.server.UnicastRemoteObject\n- * @see     java.rmi.activation.Activatable\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/Remote.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,0 @@\n- * A <code>StubNotFoundException<\/code> may also be\n- * thrown when an activatable object is registered via the\n- * <code>java.rmi.activation.Activatable.register<\/code> method.\n@@ -38,1 +35,0 @@\n- * @see     java.rmi.activation.Activatable\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/StubNotFoundException.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,584 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.rmi.MarshalledObject;\n-import java.rmi.NoSuchObjectException;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.UnknownGroupException;\n-import java.rmi.activation.UnknownObjectException;\n-import java.rmi.server.RMIClientSocketFactory;\n-import java.rmi.server.RMIServerSocketFactory;\n-import java.rmi.server.RemoteServer;\n-import sun.rmi.server.ActivatableServerRef;\n-\n-\/**\n- * The <code>Activatable<\/code> class provides support for remote\n- * objects that require persistent access over time and that\n- * can be activated by the system.\n- *\n- * <p>For the constructors and static <code>exportObject<\/code> methods,\n- * the stub for a remote object being exported is obtained as described in\n- * {@link java.rmi.server.UnicastRemoteObject}.\n- *\n- * <p>An attempt to serialize explicitly an instance of this class will\n- * fail.\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @serial      exclude\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public abstract class Activatable extends RemoteServer {\n-\n-    private ActivationID id;\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = -3120617863591563455L;\n-\n-    \/**\n-     * Constructs an activatable remote object by registering\n-     * an activation descriptor (with the specified location, data, and\n-     * restart mode) for this object, and exporting the object with the\n-     * specified port.\n-     *\n-     * <p><strong>Note:<\/strong> Using the <code>Activatable<\/code>\n-     * constructors that both register and export an activatable remote\n-     * object is strongly discouraged because the actions of registering\n-     * and exporting the remote object are <i>not<\/i> guaranteed to be\n-     * atomic.  Instead, an application should register an activation\n-     * descriptor and export a remote object separately, so that exceptions\n-     * can be handled properly.\n-     *\n-     * <p>This method invokes the {@link\n-     * #exportObject(Remote,String,MarshalledObject,boolean,int)\n-     * exportObject} method with this object, and the specified location,\n-     * data, restart mode, and port.  Subsequent calls to {@link #getID}\n-     * will return the activation identifier returned from the call to\n-     * <code>exportObject<\/code>.\n-     *\n-     * @param location the location for classes for this object\n-     * @param data the object's initialization data\n-     * @param port the port on which the object is exported (an anonymous\n-     * port is used if port=0)\n-     * @param restart if true, the object is restarted (reactivated) when\n-     * either the activator is restarted or the object's activation group\n-     * is restarted after an unexpected crash; if false, the object is only\n-     * activated on demand.  Specifying <code>restart<\/code> to be\n-     * <code>true<\/code> does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @throws ActivationException if object registration fails.\n-     * @throws RemoteException if either of the following fails:\n-     * a) registering the object with the activation system or b) exporting\n-     * the object to the RMI runtime.\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation.\n-     * @since 1.2\n-     **\/\n-    protected Activatable(String location,\n-                          MarshalledObject<?> data,\n-                          boolean restart,\n-                          int port)\n-        throws ActivationException, RemoteException\n-    {\n-        super();\n-        id = exportObject(this, location, data, restart, port);\n-    }\n-\n-    \/**\n-     * Constructs an activatable remote object by registering\n-     * an activation descriptor (with the specified location, data, and\n-     * restart mode) for this object, and exporting the object with the\n-     * specified port, and specified client and server socket factories.\n-     *\n-     * <p><strong>Note:<\/strong> Using the <code>Activatable<\/code>\n-     * constructors that both register and export an activatable remote\n-     * object is strongly discouraged because the actions of registering\n-     * and exporting the remote object are <i>not<\/i> guaranteed to be\n-     * atomic.  Instead, an application should register an activation\n-     * descriptor and export a remote object separately, so that exceptions\n-     * can be handled properly.\n-     *\n-     * <p>This method invokes the {@link\n-     * #exportObject(Remote,String,MarshalledObject,boolean,int,RMIClientSocketFactory,RMIServerSocketFactory)\n-     * exportObject} method with this object, and the specified location,\n-     * data, restart mode, port, and client and server socket factories.\n-     * Subsequent calls to {@link #getID} will return the activation\n-     * identifier returned from the call to <code>exportObject<\/code>.\n-     *\n-     * @param location the location for classes for this object\n-     * @param data the object's initialization data\n-     * @param restart if true, the object is restarted (reactivated) when\n-     * either the activator is restarted or the object's activation group\n-     * is restarted after an unexpected crash; if false, the object is only\n-     * activated on demand.  Specifying <code>restart<\/code> to be\n-     * <code>true<\/code> does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @param port the port on which the object is exported (an anonymous\n-     * port is used if port=0)\n-     * @param csf the client-side socket factory for making calls to the\n-     * remote object\n-     * @param ssf the server-side socket factory for receiving remote calls\n-     * @throws ActivationException if object registration fails.\n-     * @throws RemoteException if either of the following fails:\n-     * a) registering the object with the activation system or b) exporting\n-     * the object to the RMI runtime.\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation.\n-     * @since 1.2\n-     **\/\n-    protected Activatable(String location,\n-                          MarshalledObject<?> data,\n-                          boolean restart,\n-                          int port,\n-                          RMIClientSocketFactory csf,\n-                          RMIServerSocketFactory ssf)\n-        throws ActivationException, RemoteException\n-    {\n-        super();\n-        id = exportObject(this, location, data, restart, port, csf, ssf);\n-    }\n-\n-    \/**\n-     * Constructor used to activate\/export the object on a specified\n-     * port. An \"activatable\" remote object must have a constructor that\n-     * takes two arguments: <ul>\n-     * <li>the object's activation identifier (<code>ActivationID<\/code>), and\n-     * <li>the object's initialization data (a <code>MarshalledObject<\/code>).\n-     * <\/ul><p>\n-     *\n-     * A concrete subclass of this class must call this constructor when it is\n-     * <i>activated<\/i> via the two parameter constructor described above. As\n-     * a side-effect of construction, the remote object is \"exported\"\n-     * to the RMI runtime (on the specified <code>port<\/code>) and is\n-     * available to accept incoming calls from clients.\n-     *\n-     * @param id activation identifier for the object\n-     * @param port the port number on which the object is exported\n-     * @throws RemoteException if exporting the object to the RMI\n-     * runtime fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    protected Activatable(ActivationID id, int port)\n-        throws RemoteException\n-    {\n-        super();\n-        this.id = id;\n-        exportObject(this, id, port);\n-    }\n-\n-    \/**\n-     * Constructor used to activate\/export the object on a specified\n-     * port. An \"activatable\" remote object must have a constructor that\n-     * takes two arguments: <ul>\n-     * <li>the object's activation identifier (<code>ActivationID<\/code>), and\n-     * <li>the object's initialization data (a <code>MarshalledObject<\/code>).\n-     * <\/ul><p>\n-     *\n-     * A concrete subclass of this class must call this constructor when it is\n-     * <i>activated<\/i> via the two parameter constructor described above. As\n-     * a side-effect of construction, the remote object is \"exported\"\n-     * to the RMI runtime (on the specified <code>port<\/code>) and is\n-     * available to accept incoming calls from clients.\n-     *\n-     * @param id activation identifier for the object\n-     * @param port the port number on which the object is exported\n-     * @param csf the client-side socket factory for making calls to the\n-     * remote object\n-     * @param ssf the server-side socket factory for receiving remote calls\n-     * @throws RemoteException if exporting the object to the RMI\n-     * runtime fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    protected Activatable(ActivationID id, int port,\n-                          RMIClientSocketFactory csf,\n-                          RMIServerSocketFactory ssf)\n-        throws RemoteException\n-    {\n-        super();\n-        this.id = id;\n-        exportObject(this, id, port, csf, ssf);\n-    }\n-\n-    \/**\n-     * Returns the object's activation identifier.  The method is\n-     * protected so that only subclasses can obtain an object's\n-     * identifier.\n-     * @return the object's activation identifier\n-     * @since 1.2\n-     *\/\n-    protected ActivationID getID() {\n-        return id;\n-    }\n-\n-    \/**\n-     * Register an object descriptor for an activatable remote\n-     * object so that is can be activated on demand.\n-     *\n-     * @param desc  the object's descriptor\n-     * @return the stub for the activatable remote object\n-     * @throws UnknownGroupException if group id in <code>desc<\/code>\n-     * is not registered with the activation system\n-     * @throws ActivationException if activation system is not running\n-     * @throws RemoteException if remote call fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public static Remote register(ActivationDesc desc)\n-        throws UnknownGroupException, ActivationException, RemoteException\n-    {\n-        \/\/ register object with activator.\n-        ActivationID id =\n-            ActivationGroup.getSystem().registerObject(desc);\n-        return sun.rmi.server.ActivatableRef.getStub(desc, id);\n-    }\n-\n-    \/**\n-     * Informs the system that the object with the corresponding activation\n-     * <code>id<\/code> is currently inactive. If the object is currently\n-     * active, the object is \"unexported\" from the RMI runtime (only if\n-     * there are no pending or in-progress calls)\n-     * so the that it can no longer receive incoming calls. This call\n-     * informs this VM's ActivationGroup that the object is inactive,\n-     * that, in turn, informs its ActivationMonitor. If this call\n-     * completes successfully, a subsequent activate request to the activator\n-     * will cause the object to reactivate. The operation may still\n-     * succeed if the object is considered active but has already\n-     * unexported itself.\n-     *\n-     * @param id the object's activation identifier\n-     * @return true if the operation succeeds (the operation will\n-     * succeed if the object in currently known to be active and is\n-     * either already unexported or is currently exported and has no\n-     * pending\/executing calls); false is returned if the object has\n-     * pending\/executing calls in which case it cannot be deactivated\n-     * @throws UnknownObjectException if object is not known (it may\n-     * already be inactive)\n-     * @throws ActivationException if group is not active\n-     * @throws RemoteException if call informing monitor fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public static boolean inactive(ActivationID id)\n-        throws UnknownObjectException, ActivationException, RemoteException\n-    {\n-        return ActivationGroup.currentGroup().inactiveObject(id);\n-    }\n-\n-    \/**\n-     * Revokes previous registration for the activation descriptor\n-     * associated with <code>id<\/code>. An object can no longer be\n-     * activated via that <code>id<\/code>.\n-     *\n-     * @param id the object's activation identifier\n-     * @throws UnknownObjectException if object (<code>id<\/code>) is unknown\n-     * @throws ActivationException if activation system is not running\n-     * @throws RemoteException if remote call to activation system fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public static void unregister(ActivationID id)\n-        throws UnknownObjectException, ActivationException, RemoteException\n-    {\n-        ActivationGroup.getSystem().unregisterObject(id);\n-    }\n-\n-    \/**\n-     * Registers an activation descriptor (with the specified location,\n-     * data, and restart mode) for the specified object, and exports that\n-     * object with the specified port.\n-     *\n-     * <p><strong>Note:<\/strong> Using this method (as well as the\n-     * <code>Activatable<\/code> constructors that both register and export\n-     * an activatable remote object) is strongly discouraged because the\n-     * actions of registering and exporting the remote object are\n-     * <i>not<\/i> guaranteed to be atomic.  Instead, an application should\n-     * register an activation descriptor and export a remote object\n-     * separately, so that exceptions can be handled properly.\n-     *\n-     * <p>This method invokes the {@link\n-     * #exportObject(Remote,String,MarshalledObject,boolean,int,RMIClientSocketFactory,RMIServerSocketFactory)\n-     * exportObject} method with the specified object, location, data,\n-     * restart mode, and port, and <code>null<\/code> for both client and\n-     * server socket factories, and then returns the resulting activation\n-     * identifier.\n-     *\n-     * @param obj the object being exported\n-     * @param location the object's code location\n-     * @param data the object's bootstrapping data\n-     * @param restart if true, the object is restarted (reactivated) when\n-     * either the activator is restarted or the object's activation group\n-     * is restarted after an unexpected crash; if false, the object is only\n-     * activated on demand.  Specifying <code>restart<\/code> to be\n-     * <code>true<\/code> does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @param port the port on which the object is exported (an anonymous\n-     * port is used if port=0)\n-     * @return the activation identifier obtained from registering the\n-     * descriptor, <code>desc<\/code>, with the activation system\n-     * the wrong group\n-     * @throws ActivationException if activation group is not active\n-     * @throws RemoteException if object registration or export fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     **\/\n-    public static ActivationID exportObject(Remote obj,\n-                                            String location,\n-                                            MarshalledObject<?> data,\n-                                            boolean restart,\n-                                            int port)\n-        throws ActivationException, RemoteException\n-    {\n-        return exportObject(obj, location, data, restart, port, null, null);\n-    }\n-\n-    \/**\n-     * Registers an activation descriptor (with the specified location,\n-     * data, and restart mode) for the specified object, and exports that\n-     * object with the specified port, and the specified client and server\n-     * socket factories.\n-     *\n-     * <p><strong>Note:<\/strong> Using this method (as well as the\n-     * <code>Activatable<\/code> constructors that both register and export\n-     * an activatable remote object) is strongly discouraged because the\n-     * actions of registering and exporting the remote object are\n-     * <i>not<\/i> guaranteed to be atomic.  Instead, an application should\n-     * register an activation descriptor and export a remote object\n-     * separately, so that exceptions can be handled properly.\n-     *\n-     * <p>This method first registers an activation descriptor for the\n-     * specified object as follows. It obtains the activation system by\n-     * invoking the method {@link ActivationGroup#getSystem\n-     * ActivationGroup.getSystem}.  This method then obtains an {@link\n-     * ActivationID} for the object by invoking the activation system's\n-     * {@link ActivationSystem#registerObject registerObject} method with\n-     * an {@link ActivationDesc} constructed with the specified object's\n-     * class name, and the specified location, data, and restart mode.  If\n-     * an exception occurs obtaining the activation system or registering\n-     * the activation descriptor, that exception is thrown to the caller.\n-     *\n-     * <p>Next, this method exports the object by invoking the {@link\n-     * #exportObject(Remote,ActivationID,int,RMIClientSocketFactory,RMIServerSocketFactory)\n-     * exportObject} method with the specified remote object, the\n-     * activation identifier obtained from registration, the specified\n-     * port, and the specified client and server socket factories.  If an\n-     * exception occurs exporting the object, this method attempts to\n-     * unregister the activation identifier (obtained from registration) by\n-     * invoking the activation system's {@link\n-     * ActivationSystem#unregisterObject unregisterObject} method with the\n-     * activation identifier.  If an exception occurs unregistering the\n-     * identifier, that exception is ignored, and the original exception\n-     * that occurred exporting the object is thrown to the caller.\n-     *\n-     * <p>Finally, this method invokes the {@link\n-     * ActivationGroup#activeObject activeObject} method on the activation\n-     * group in this VM with the activation identifier and the specified\n-     * remote object, and returns the activation identifier to the caller.\n-     *\n-     * @param obj the object being exported\n-     * @param location the object's code location\n-     * @param data the object's bootstrapping data\n-     * @param restart if true, the object is restarted (reactivated) when\n-     * either the activator is restarted or the object's activation group\n-     * is restarted after an unexpected crash; if false, the object is only\n-     * activated on demand.  Specifying <code>restart<\/code> to be\n-     * <code>true<\/code> does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @param port the port on which the object is exported (an anonymous\n-     * port is used if port=0)\n-     * @param csf the client-side socket factory for making calls to the\n-     * remote object\n-     * @param ssf the server-side socket factory for receiving remote calls\n-     * @return the activation identifier obtained from registering the\n-     * descriptor with the activation system\n-     * @throws ActivationException if activation group is not active\n-     * @throws RemoteException if object registration or export fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     **\/\n-    public static ActivationID exportObject(Remote obj,\n-                                            String location,\n-                                            MarshalledObject<?> data,\n-                                            boolean restart,\n-                                            int port,\n-                                            RMIClientSocketFactory csf,\n-                                            RMIServerSocketFactory ssf)\n-        throws ActivationException, RemoteException\n-    {\n-        ActivationDesc desc = new ActivationDesc(obj.getClass().getName(),\n-                                                 location, data, restart);\n-        \/*\n-         * Register descriptor.\n-         *\/\n-        ActivationSystem system =  ActivationGroup.getSystem();\n-        ActivationID id = system.registerObject(desc);\n-\n-        \/*\n-         * Export object.\n-         *\/\n-        try {\n-            exportObject(obj, id, port, csf, ssf);\n-        } catch (RemoteException e) {\n-            \/*\n-             * Attempt to unregister activation descriptor because export\n-             * failed and register\/export should be atomic (see 4323621).\n-             *\/\n-            try {\n-                system.unregisterObject(id);\n-            } catch (Exception ex) {\n-            }\n-            \/*\n-             * Report original exception.\n-             *\/\n-            throw e;\n-        }\n-\n-        \/*\n-         * This call can't fail (it is a local call, and the only possible\n-         * exception, thrown if the group is inactive, will not be thrown\n-         * because the group is not inactive).\n-         *\/\n-        ActivationGroup.currentGroup().activeObject(id, obj);\n-\n-        return id;\n-    }\n-\n-    \/**\n-     * Export the activatable remote object to the RMI runtime to make\n-     * the object available to receive incoming calls. The object is\n-     * exported on an anonymous port, if <code>port<\/code> is zero. <p>\n-     *\n-     * During activation, this <code>exportObject<\/code> method should\n-     * be invoked explicitly by an \"activatable\" object, that does not\n-     * extend the <code>Activatable<\/code> class. There is no need for objects\n-     * that do extend the <code>Activatable<\/code> class to invoke this\n-     * method directly because the object is exported during construction.\n-     *\n-     * @return the stub for the activatable remote object\n-     * @param obj the remote object implementation\n-     * @param id the object's  activation identifier\n-     * @param port the port on which the object is exported (an anonymous\n-     * port is used if port=0)\n-     * @throws RemoteException if object export fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public static Remote exportObject(Remote obj,\n-                                      ActivationID id,\n-                                      int port)\n-        throws RemoteException\n-    {\n-        return exportObject(obj, new ActivatableServerRef(id, port));\n-    }\n-\n-    \/**\n-     * Export the activatable remote object to the RMI runtime to make\n-     * the object available to receive incoming calls. The object is\n-     * exported on an anonymous port, if <code>port<\/code> is zero. <p>\n-     *\n-     * During activation, this <code>exportObject<\/code> method should\n-     * be invoked explicitly by an \"activatable\" object, that does not\n-     * extend the <code>Activatable<\/code> class. There is no need for objects\n-     * that do extend the <code>Activatable<\/code> class to invoke this\n-     * method directly because the object is exported during construction.\n-     *\n-     * @return the stub for the activatable remote object\n-     * @param obj the remote object implementation\n-     * @param id the object's  activation identifier\n-     * @param port the port on which the object is exported (an anonymous\n-     * port is used if port=0)\n-     * @param csf the client-side socket factory for making calls to the\n-     * remote object\n-     * @param ssf the server-side socket factory for receiving remote calls\n-     * @throws RemoteException if object export fails\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public static Remote exportObject(Remote obj,\n-                                      ActivationID id,\n-                                      int port,\n-                                      RMIClientSocketFactory csf,\n-                                      RMIServerSocketFactory ssf)\n-        throws RemoteException\n-    {\n-        return exportObject(obj, new ActivatableServerRef(id, port, csf, ssf));\n-    }\n-\n-    \/**\n-     * Remove the remote object, obj, from the RMI runtime. If\n-     * successful, the object can no longer accept incoming RMI calls.\n-     * If the force parameter is true, the object is forcibly unexported\n-     * even if there are pending calls to the remote object or the\n-     * remote object still has calls in progress.  If the force\n-     * parameter is false, the object is only unexported if there are\n-     * no pending or in progress calls to the object.\n-     *\n-     * @param obj the remote object to be unexported\n-     * @param force if true, unexports the object even if there are\n-     * pending or in-progress calls; if false, only unexports the object\n-     * if there are no pending or in-progress calls\n-     * @return true if operation is successful, false otherwise\n-     * @throws NoSuchObjectException if the remote object is not\n-     * currently exported\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public static boolean unexportObject(Remote obj, boolean force)\n-        throws NoSuchObjectException\n-    {\n-        return sun.rmi.transport.ObjectTable.unexportObject(obj, force);\n-    }\n-\n-    \/**\n-     * Exports the specified object using the specified server ref.\n-     *\/\n-    private static Remote exportObject(Remote obj, ActivatableServerRef sref)\n-        throws RemoteException\n-    {\n-        \/\/ if obj extends Activatable, set its ref.\n-        if (obj instanceof Activatable) {\n-            ((Activatable) obj).ref = sref;\n-\n-        }\n-        return sref.exportObject(obj, null, false);\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/Activatable.java","additions":0,"deletions":584,"binary":false,"changes":584,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-\/**\n- * This exception is thrown by the RMI runtime when activation\n- * fails during a remote call to an activatable object.\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-public class ActivateFailedException extends java.rmi.RemoteException {\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = 4863550261346652506L;\n-\n-    \/**\n-     * Constructs an <code>ActivateFailedException<\/code> with the specified\n-     * detail message.\n-     *\n-     * @param s the detail message\n-     * @since 1.2\n-     *\/\n-    public ActivateFailedException(String s) {\n-        super(s);\n-    }\n-\n-    \/**\n-     * Constructs an <code>ActivateFailedException<\/code> with the specified\n-     * detail message and nested exception.\n-     *\n-     * @param s the detail message\n-     * @param ex the nested exception\n-     * @since 1.2\n-     *\/\n-    public ActivateFailedException(String s, Exception ex) {\n-        super(s, ex);\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivateFailedException.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,352 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.io.Serializable;\n-import java.rmi.MarshalledObject;\n-\n-\/**\n- * An activation descriptor contains the information necessary to\n- * activate an object: <ul>\n- * <li> the object's group identifier,\n- * <li> the object's fully-qualified class name,\n- * <li> the object's code location (the location of the class), a codebase URL\n- * path,\n- * <li> the object's restart \"mode\", and,\n- * <li> a \"marshalled\" object that can contain object specific\n- * initialization data. <\/ul>\n- *\n- * <p>A descriptor registered with the activation system can be used to\n- * recreate\/activate the object specified by the descriptor. The\n- * <code>MarshalledObject<\/code> in the object's descriptor is passed\n- * as the second argument to the remote object's constructor for\n- * object to use during reinitialization\/activation.\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @see         java.rmi.activation.Activatable\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public final class ActivationDesc implements Serializable {\n-\n-    \/**\n-     * @serial the group's identifier\n-     *\/\n-    private ActivationGroupID groupID;\n-\n-    \/**\n-     * @serial the object's class name\n-     *\/\n-    private String className;\n-\n-    \/**\n-     * @serial the object's code location\n-     *\/\n-    private String location;\n-\n-    \/**\n-     * @serial the object's initialization data\n-     *\/\n-    private MarshalledObject<?> data;\n-\n-    \/**\n-     * @serial indicates whether the object should be restarted\n-     *\/\n-    private boolean restart;\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = 7455834104417690957L;\n-\n-    \/**\n-     * Constructs an object descriptor for an object whose class name\n-     * is <code>className<\/code>, that can be loaded from the\n-     * code <code>location<\/code> and whose initialization\n-     * information is <code>data<\/code>. If this form of the constructor\n-     * is used, the <code>groupID<\/code> defaults to the current id for\n-     * <code>ActivationGroup<\/code> for this VM. All objects with the\n-     * same <code>ActivationGroupID<\/code> are activated in the same VM.\n-     *\n-     * <p>Note that objects specified by a descriptor created with this\n-     * constructor will only be activated on demand (by default, the restart\n-     * mode is <code>false<\/code>).  If an activatable object requires restart\n-     * services, use one of the <code>ActivationDesc<\/code> constructors that\n-     * takes a boolean parameter, <code>restart<\/code>.\n-     *\n-     * <p> This constructor will throw <code>ActivationException<\/code> if\n-     * there is no current activation group for this VM.  To create an\n-     * <code>ActivationGroup<\/code> use the\n-     * <code>ActivationGroup.createGroup<\/code> method.\n-     *\n-     * @param className the object's fully package qualified class name\n-     * @param location the object's code location (from where the class is\n-     * loaded)\n-     * @param data the object's initialization (activation) data contained\n-     * in marshalled form.\n-     * @throws ActivationException if the current group is nonexistent\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public ActivationDesc(String className,\n-                          String location,\n-                          MarshalledObject<?> data)\n-        throws ActivationException\n-    {\n-        this(ActivationGroup.internalCurrentGroupID(),\n-             className, location, data, false);\n-    }\n-\n-    \/**\n-     * Constructs an object descriptor for an object whose class name\n-     * is <code>className<\/code>, that can be loaded from the\n-     * code <code>location<\/code> and whose initialization\n-     * information is <code>data<\/code>. If this form of the constructor\n-     * is used, the <code>groupID<\/code> defaults to the current id for\n-     * <code>ActivationGroup<\/code> for this VM. All objects with the\n-     * same <code>ActivationGroupID<\/code> are activated in the same VM.\n-     *\n-     * <p>This constructor will throw <code>ActivationException<\/code> if\n-     * there is no current activation group for this VM.  To create an\n-     * <code>ActivationGroup<\/code> use the\n-     * <code>ActivationGroup.createGroup<\/code> method.\n-     *\n-     * @param className the object's fully package qualified class name\n-     * @param location the object's code location (from where the class is\n-     * loaded)\n-     * @param data the object's initialization (activation) data contained\n-     * in marshalled form.\n-     * @param restart if true, the object is restarted (reactivated) when\n-     * either the activator is restarted or the object's activation group\n-     * is restarted after an unexpected crash; if false, the object is only\n-     * activated on demand.  Specifying <code>restart<\/code> to be\n-     * <code>true<\/code> does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @throws ActivationException if the current group is nonexistent\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public ActivationDesc(String className,\n-                          String location,\n-                          MarshalledObject<?> data,\n-                          boolean restart)\n-        throws ActivationException\n-    {\n-        this(ActivationGroup.internalCurrentGroupID(),\n-             className, location, data, restart);\n-    }\n-\n-    \/**\n-     * Constructs an object descriptor for an object whose class name\n-     * is <code>className<\/code> that can be loaded from the\n-     * code <code>location<\/code> and whose initialization\n-     * information is <code>data<\/code>. All objects with the same\n-     * <code>groupID<\/code> are activated in the same Java VM.\n-     *\n-     * <p>Note that objects specified by a descriptor created with this\n-     * constructor will only be activated on demand (by default, the restart\n-     * mode is <code>false<\/code>).  If an activatable object requires restart\n-     * services, use one of the <code>ActivationDesc<\/code> constructors that\n-     * takes a boolean parameter, <code>restart<\/code>.\n-     *\n-     * @param groupID the group's identifier (obtained from registering\n-     * <code>ActivationSystem.registerGroup<\/code> method). The group\n-     * indicates the VM in which the object should be activated.\n-     * @param className the object's fully package-qualified class name\n-     * @param location the object's code location (from where the class is\n-     * loaded)\n-     * @param data  the object's initialization (activation) data contained\n-     * in marshalled form.\n-     * @throws IllegalArgumentException if <code>groupID<\/code> is null\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public ActivationDesc(ActivationGroupID groupID,\n-                          String className,\n-                          String location,\n-                          MarshalledObject<?> data)\n-    {\n-        this(groupID, className, location, data, false);\n-    }\n-\n-    \/**\n-     * Constructs an object descriptor for an object whose class name\n-     * is <code>className<\/code> that can be loaded from the\n-     * code <code>location<\/code> and whose initialization\n-     * information is <code>data<\/code>. All objects with the same\n-     * <code>groupID<\/code> are activated in the same Java VM.\n-     *\n-     * @param groupID the group's identifier (obtained from registering\n-     * <code>ActivationSystem.registerGroup<\/code> method). The group\n-     * indicates the VM in which the object should be activated.\n-     * @param className the object's fully package-qualified class name\n-     * @param location the object's code location (from where the class is\n-     * loaded)\n-     * @param data  the object's initialization (activation) data contained\n-     * in marshalled form.\n-     * @param restart if true, the object is restarted (reactivated) when\n-     * either the activator is restarted or the object's activation group\n-     * is restarted after an unexpected crash; if false, the object is only\n-     * activated on demand.  Specifying <code>restart<\/code> to be\n-     * <code>true<\/code> does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @throws IllegalArgumentException if <code>groupID<\/code> is null\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public ActivationDesc(ActivationGroupID groupID,\n-                          String className,\n-                          String location,\n-                          MarshalledObject<?> data,\n-                          boolean restart)\n-    {\n-        if (groupID == null)\n-            throw new IllegalArgumentException(\"groupID can't be null\");\n-        this.groupID = groupID;\n-        this.className = className;\n-        this.location = location;\n-        this.data = data;\n-        this.restart = restart;\n-    }\n-\n-    \/**\n-     * Returns the group identifier for the object specified by this\n-     * descriptor. A group provides a way to aggregate objects into a\n-     * single Java virtual machine. RMI creates\/activates objects with\n-     * the same <code>groupID<\/code> in the same virtual machine.\n-     *\n-     * @return the group identifier\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupID getGroupID() {\n-        return groupID;\n-    }\n-\n-    \/**\n-     * Returns the class name for the object specified by this\n-     * descriptor.\n-     * @return the class name\n-     * @since 1.2\n-     *\/\n-    public String getClassName() {\n-        return className;\n-    }\n-\n-    \/**\n-     * Returns the code location for the object specified by\n-     * this descriptor.\n-     * @return the code location\n-     * @since 1.2\n-     *\/\n-    public String getLocation() {\n-        return location;\n-    }\n-\n-    \/**\n-     * Returns a \"marshalled object\" containing intialization\/activation\n-     * data for the object specified by this descriptor.\n-     * @return the object specific \"initialization\" data\n-     * @since 1.2\n-     *\/\n-    public MarshalledObject<?> getData() {\n-        return data;\n-    }\n-\n-    \/**\n-     * Returns the \"restart\" mode of the object associated with\n-     * this activation descriptor.\n-     *\n-     * @return true if the activatable object associated with this\n-     * activation descriptor is restarted via the activation\n-     * daemon when either the daemon comes up or the object's group\n-     * is restarted after an unexpected crash; otherwise it returns false,\n-     * meaning that the object is only activated on demand via a\n-     * method call.  Note that if the restart mode is <code>true<\/code>, the\n-     * activator does not force an initial immediate activation of\n-     * a newly registered object;  initial activation is lazy.\n-     * @since 1.2\n-     *\/\n-    public boolean getRestartMode() {\n-        return restart;\n-    }\n-\n-    \/**\n-     * Compares two activation descriptors for content equality.\n-     *\n-     * @param   obj     the Object to compare with\n-     * @return  true if these Objects are equal; false otherwise.\n-     * @see             java.util.Hashtable\n-     * @since 1.2\n-     *\/\n-    public boolean equals(Object obj) {\n-\n-        if (obj instanceof ActivationDesc) {\n-            ActivationDesc desc = (ActivationDesc) obj;\n-            return\n-                ((groupID == null ? desc.groupID == null :\n-                  groupID.equals(desc.groupID)) &&\n-                 (className == null ? desc.className == null :\n-                  className.equals(desc.className)) &&\n-                 (location == null ? desc.location == null:\n-                  location.equals(desc.location)) &&\n-                 (data == null ? desc.data == null :\n-                  data.equals(desc.data)) &&\n-                 (restart == desc.restart));\n-\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Return the same hashCode for similar <code>ActivationDesc<\/code>s.\n-     * @return an integer\n-     * @see java.util.Hashtable\n-     *\/\n-    public int hashCode() {\n-        return ((location == null\n-                    ? 0\n-                    : location.hashCode() << 24) ^\n-                (groupID == null\n-                    ? 0\n-                    : groupID.hashCode() << 16) ^\n-                (className == null\n-                    ? 0\n-                    : className.hashCode() << 9) ^\n-                (data == null\n-                    ? 0\n-                    : data.hashCode() << 1) ^\n-                (restart\n-                    ? 1\n-                    : 0));\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationDesc.java","additions":0,"deletions":352,"binary":false,"changes":352,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-\/**\n- * General exception used by the activation interfaces.\n- *\n- * <p>As of release 1.4, this exception has been retrofitted to conform to\n- * the general purpose exception-chaining mechanism.  The \"detail exception\"\n- * that may be provided at construction time and accessed via the public\n- * {@link #detail} field is now known as the <i>cause<\/i>, and may be\n- * accessed via the {@link Throwable#getCause()} method, as well as\n- * the aforementioned \"legacy field.\"\n- *\n- * <p>Invoking the method {@link Throwable#initCause(Throwable)} on an\n- * instance of {@code ActivationException} always throws {@link\n- * IllegalStateException}.\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-public class ActivationException extends Exception {\n-\n-    \/**\n-     * The cause of the activation exception.\n-     *\n-     * <p>This field predates the general-purpose exception chaining facility.\n-     * The {@link Throwable#getCause()} method is now the preferred means of\n-     * obtaining this information.\n-     *\n-     * @serial\n-     *\/\n-    public Throwable detail;\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = -4320118837291406071L;\n-\n-    \/**\n-     * Constructs an {@code ActivationException}.\n-     *\/\n-    public ActivationException() {\n-        initCause(null);  \/\/ Disallow subsequent initCause\n-    }\n-\n-    \/**\n-     * Constructs an {@code ActivationException} with the specified\n-     * detail message.\n-     *\n-     * @param s the detail message\n-     *\/\n-    public ActivationException(String s) {\n-        super(s);\n-        initCause(null);  \/\/ Disallow subsequent initCause\n-    }\n-\n-    \/**\n-     * Constructs an {@code ActivationException} with the specified\n-     * detail message and cause.  This constructor sets the {@link #detail}\n-     * field to the specified {@code Throwable}.\n-     *\n-     * @param s the detail message\n-     * @param cause the cause\n-     *\/\n-    public ActivationException(String s, Throwable cause) {\n-        super(s);\n-        initCause(null);  \/\/ Disallow subsequent initCause\n-        detail = cause;\n-    }\n-\n-    \/**\n-     * Returns the detail message, including the message from the cause, if\n-     * any, of this exception.\n-     *\n-     * @return  the detail message\n-     *\/\n-    public String getMessage() {\n-        if (detail == null)\n-            return super.getMessage();\n-        else\n-            return super.getMessage() +\n-                \"; nested exception is: \\n\\t\" +\n-                detail.toString();\n-    }\n-\n-    \/**\n-     * Returns the cause of this exception.  This method returns the value\n-     * of the {@link #detail} field.\n-     *\n-     * @return  the cause, which may be {@code null}.\n-     * @since   1.4\n-     *\/\n-    public Throwable getCause() {\n-        return detail;\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationException.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,543 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.rmi.MarshalledObject;\n-import java.rmi.Naming;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.UnknownGroupException;\n-import java.rmi.activation.UnknownObjectException;\n-import java.rmi.server.RMIClassLoader;\n-import java.rmi.server.UnicastRemoteObject;\n-import java.security.AccessController;\n-import java.security.PrivilegedAction;\n-\n-\/**\n- * An <code>ActivationGroup<\/code> is responsible for creating new\n- * instances of \"activatable\" objects in its group, informing its\n- * <code>ActivationMonitor<\/code> when either: its object's become\n- * active or inactive, or the group as a whole becomes inactive. <p>\n- *\n- * An <code>ActivationGroup<\/code> is <i>initially<\/i> created in one\n- * of several ways: <ul>\n- * <li>as a side-effect of creating an <code>ActivationDesc<\/code>\n- *     without an explicit <code>ActivationGroupID<\/code> for the\n- *     first activatable object in the group, or\n- * <li>via the <code>ActivationGroup.createGroup<\/code> method\n- * <li>as a side-effect of activating the first object in a group\n- *     whose <code>ActivationGroupDesc<\/code> was only registered.<\/ul><p>\n- *\n- * Only the activator can <i>recreate<\/i> an\n- * <code>ActivationGroup<\/code>.  The activator spawns, as needed, a\n- * separate VM (as a child process, for example) for each registered\n- * activation group and directs activation requests to the appropriate\n- * group. It is implementation specific how VMs are spawned. An\n- * activation group is created via the\n- * <code>ActivationGroup.createGroup<\/code> static method. The\n- * <code>createGroup<\/code> method has two requirements on the group\n- * to be created: 1) the group must be a concrete subclass of\n- * <code>ActivationGroup<\/code>, and 2) the group must have a\n- * constructor that takes two arguments:\n- *\n- * <ul>\n- * <li> the group's <code>ActivationGroupID<\/code>, and\n- * <li> the group's initialization data (in a\n- *      <code>java.rmi.MarshalledObject<\/code>)<\/ul><p>\n- *\n- * When created, the default implementation of\n- * <code>ActivationGroup<\/code> will override the system properties\n- * with the properties requested when its\n- * <code>ActivationGroupDesc<\/code> was created, and will set a\n- * {@link SecurityManager} as the default system\n- * security manager.  If your application requires specific properties\n- * to be set when objects are activated in the group, the application\n- * should create a special <code>Properties<\/code> object containing\n- * these properties, then create an <code>ActivationGroupDesc<\/code>\n- * with the <code>Properties<\/code> object, and use\n- * <code>ActivationGroup.createGroup<\/code> before creating any\n- * <code>ActivationDesc<\/code>s (before the default\n- * <code>ActivationGroupDesc<\/code> is created).  If your application\n- * requires the use of a security manager other than\n- * {@link SecurityManager}, in the\n- * ActivativationGroupDescriptor properties list you can set\n- * <code>java.security.manager<\/code> property to the name of the security\n- * manager you would like to install.\n- *\n- * @author      Ann Wollrath\n- * @see         ActivationInstantiator\n- * @see         ActivationGroupDesc\n- * @see         ActivationGroupID\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public abstract class ActivationGroup\n-        extends UnicastRemoteObject\n-        implements ActivationInstantiator\n-{\n-    \/**\n-     * @serial the group's identifier\n-     *\/\n-    private ActivationGroupID groupID;\n-\n-    \/**\n-     * @serial the group's monitor\n-     *\/\n-    @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n-    private ActivationMonitor monitor;\n-\n-    \/**\n-     * @serial the group's incarnation number\n-     *\/\n-    private long incarnation;\n-\n-    \/** the current activation group for this VM *\/\n-    private static ActivationGroup currGroup;\n-    \/** the current group's identifier *\/\n-    private static ActivationGroupID currGroupID;\n-    \/** the current group's activation system *\/\n-    private static ActivationSystem currSystem;\n-    \/** used to control a group being created only once *\/\n-    private static boolean canCreate = true;\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = -7696947875314805420L;\n-\n-    \/**\n-     * Constructs an activation group with the given activation group\n-     * identifier.  The group is exported as a\n-     * <code>java.rmi.server.UnicastRemoteObject<\/code>.\n-     *\n-     * @param   groupID the group's identifier\n-     * @throws  RemoteException if this group could not be exported\n-     * @throws  UnsupportedOperationException if and only if activation is\n-     *          not supported by this implementation\n-     * @since   1.2\n-     *\/\n-    protected ActivationGroup(ActivationGroupID groupID)\n-        throws RemoteException\n-    {\n-        \/\/ call super constructor to export the object\n-        super();\n-        this.groupID = groupID;\n-    }\n-\n-    \/**\n-     * The group's <code>inactiveObject<\/code> method is called\n-     * indirectly via a call to the <code>Activatable.inactive<\/code>\n-     * method. A remote object implementation must call\n-     * <code>Activatable<\/code>'s <code>inactive<\/code> method when\n-     * that object deactivates (the object deems that it is no longer\n-     * active). If the object does not call\n-     * <code>Activatable.inactive<\/code> when it deactivates, the\n-     * object will never be garbage collected since the group keeps\n-     * strong references to the objects it creates.\n-     *\n-     * <p>The group's <code>inactiveObject<\/code> method unexports the\n-     * remote object from the RMI runtime so that the object can no\n-     * longer receive incoming RMI calls. An object will only be unexported\n-     * if the object has no pending or executing calls.\n-     * The subclass of <code>ActivationGroup<\/code> must override this\n-     * method and unexport the object.\n-     *\n-     * <p>After removing the object from the RMI runtime, the group\n-     * must inform its <code>ActivationMonitor<\/code> (via the monitor's\n-     * <code>inactiveObject<\/code> method) that the remote object is\n-     * not currently active so that the remote object will be\n-     * re-activated by the activator upon a subsequent activation\n-     * request.\n-     *\n-     * <p>This method simply informs the group's monitor that the object\n-     * is inactive.  It is up to the concrete subclass of ActivationGroup\n-     * to fulfill the additional requirement of unexporting the object.\n-     *\n-     * @param id the object's activation identifier\n-     * @return true if the object was successfully deactivated; otherwise\n-     *         returns false.\n-     * @throws UnknownObjectException if object is unknown (may already\n-     * be inactive)\n-     * @throws RemoteException if call informing monitor fails\n-     * @throws ActivationException if group is inactive\n-     * @since 1.2\n-     *\/\n-    public boolean inactiveObject(ActivationID id)\n-        throws ActivationException, UnknownObjectException, RemoteException\n-    {\n-        getMonitor().inactiveObject(id);\n-        return true;\n-    }\n-\n-    \/**\n-     * The group's <code>activeObject<\/code> method is called when an\n-     * object is exported (either by <code>Activatable<\/code> object\n-     * construction or an explicit call to\n-     * <code>Activatable.exportObject<\/code>. The group must inform its\n-     * <code>ActivationMonitor<\/code> that the object is active (via\n-     * the monitor's <code>activeObject<\/code> method) if the group\n-     * hasn't already done so.\n-     *\n-     * @param id the object's identifier\n-     * @param obj the remote object implementation\n-     * @throws UnknownObjectException if object is not registered\n-     * @throws RemoteException if call informing monitor fails\n-     * @throws ActivationException if group is inactive\n-     * @since 1.2\n-     *\/\n-    public abstract void activeObject(ActivationID id, Remote obj)\n-        throws ActivationException, UnknownObjectException, RemoteException;\n-\n-    \/**\n-     * Create and set the activation group for the current VM.  The\n-     * activation group can only be set if it is not currently set.\n-     * An activation group is set using the <code>createGroup<\/code>\n-     * method when the <code>Activator<\/code> initiates the\n-     * re-creation of an activation group in order to carry out\n-     * incoming <code>activate<\/code> requests. A group must first be\n-     * registered with the <code>ActivationSystem<\/code> before it can\n-     * be created via this method.\n-     *\n-     * <p>The group class specified by the\n-     * <code>ActivationGroupDesc<\/code> must be a concrete subclass of\n-     * <code>ActivationGroup<\/code> and have a public constructor that\n-     * takes two arguments: the <code>ActivationGroupID<\/code> for the\n-     * group and the <code>MarshalledObject<\/code> containing the\n-     * group's initialization data (obtained from the\n-     * <code>ActivationGroupDesc<\/code>.\n-     *\n-     * <p>If the group class name specified in the\n-     * <code>ActivationGroupDesc<\/code> is <code>null<\/code>, then\n-     * this method will behave as if the group descriptor contained\n-     * the name of the default activation group implementation class.\n-     *\n-     * <p>Note that if your application creates its own custom\n-     * activation group, a security manager must be set for that\n-     * group.  Otherwise objects cannot be activated in the group.\n-     * {@link SecurityManager} is set by default.\n-     *\n-     * <p>If a security manager is already set in the group VM, this\n-     * method first calls the security manager's\n-     * <code>checkSetFactory<\/code> method.  This could result in a\n-     * <code>SecurityException<\/code>. If your application needs to\n-     * set a different security manager, you must ensure that the\n-     * policy file specified by the group's\n-     * <code>ActivationGroupDesc<\/code> grants the group the necessary\n-     * permissions to set a new security manager.  (Note: This will be\n-     * necessary if your group downloads and sets a security manager).\n-     *\n-     * <p>After the group is created, the\n-     * <code>ActivationSystem<\/code> is informed that the group is\n-     * active by calling the <code>activeGroup<\/code> method which\n-     * returns the <code>ActivationMonitor<\/code> for the group. The\n-     * application need not call <code>activeGroup<\/code>\n-     * independently since it is taken care of by this method.\n-     *\n-     * <p>Once a group is created, subsequent calls to the\n-     * <code>currentGroupID<\/code> method will return the identifier\n-     * for this group until the group becomes inactive.\n-     *\n-     * @param id the activation group's identifier\n-     * @param desc the activation group's descriptor\n-     * @param incarnation the group's incarnation number (zero on group's\n-     * initial creation)\n-     * @return the activation group for the VM\n-     * @throws ActivationException if group already exists or if error\n-     * occurs during group creation\n-     * @throws SecurityException if permission to create group is denied.\n-     * (Note: The default implementation of the security manager\n-     * <code>checkSetFactory<\/code>\n-     * method requires the RuntimePermission \"setFactory\")\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @see SecurityManager#checkSetFactory\n-     * @since 1.2\n-     *\/\n-    public static synchronized\n-        ActivationGroup createGroup(ActivationGroupID id,\n-                                    final ActivationGroupDesc desc,\n-                                    long incarnation)\n-        throws ActivationException\n-    {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null)\n-            security.checkSetFactory();\n-\n-        if (currGroup != null)\n-            throw new ActivationException(\"group already exists\");\n-\n-        if (canCreate == false)\n-            throw new ActivationException(\"group deactivated and \" +\n-                                          \"cannot be recreated\");\n-\n-        try {\n-            \/\/ load group's class\n-            String groupClassName = desc.getClassName();\n-            Class<? extends ActivationGroup> cl;\n-            Class<? extends ActivationGroup> defaultGroupClass =\n-                sun.rmi.server.ActivationGroupImpl.class;\n-            if (groupClassName == null ||       \/\/ see 4252236\n-                groupClassName.equals(defaultGroupClass.getName()))\n-            {\n-                cl = defaultGroupClass;\n-            } else {\n-                Class<?> cl0;\n-                try {\n-                    cl0 = RMIClassLoader.loadClass(desc.getLocation(),\n-                                                   groupClassName);\n-                } catch (Exception ex) {\n-                    throw new ActivationException(\n-                        \"Could not load group implementation class\", ex);\n-                }\n-                if (ActivationGroup.class.isAssignableFrom(cl0)) {\n-                    cl = cl0.asSubclass(ActivationGroup.class);\n-                } else {\n-                    throw new ActivationException(\"group not correct class: \" +\n-                                                  cl0.getName());\n-                }\n-            }\n-\n-            \/\/ create group\n-            Constructor<? extends ActivationGroup> constructor =\n-                cl.getConstructor(ActivationGroupID.class,\n-                                  MarshalledObject.class);\n-            ActivationGroup newGroup =\n-                constructor.newInstance(id, desc.getData());\n-            currSystem = id.getSystem();\n-            newGroup.incarnation = incarnation;\n-            newGroup.monitor =\n-                currSystem.activeGroup(id, newGroup, incarnation);\n-            currGroup = newGroup;\n-            currGroupID = id;\n-            canCreate = false;\n-        } catch (InvocationTargetException e) {\n-                e.getTargetException().printStackTrace();\n-                throw new ActivationException(\"exception in group constructor\",\n-                                              e.getTargetException());\n-\n-        } catch (ActivationException e) {\n-            throw e;\n-\n-        } catch (Exception e) {\n-            throw new ActivationException(\"exception creating group\", e);\n-        }\n-\n-        return currGroup;\n-    }\n-\n-    \/**\n-     * Returns the current activation group's identifier.  Returns null\n-     * if no group is currently active for this VM.\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @return the activation group's identifier\n-     * @since 1.2\n-     *\/\n-    public static synchronized ActivationGroupID currentGroupID() {\n-        return currGroupID;\n-    }\n-\n-    \/**\n-     * Returns the activation group identifier for the VM.  If an\n-     * activation group does not exist for this VM, a default\n-     * activation group is created. A group can be created only once,\n-     * so if a group has already become active and deactivated.\n-     *\n-     * @return the activation group identifier\n-     * @throws ActivationException if error occurs during group\n-     * creation, if security manager is not set, or if the group\n-     * has already been created and deactivated.\n-     *\/\n-    static synchronized ActivationGroupID internalCurrentGroupID()\n-        throws ActivationException\n-    {\n-        if (currGroupID == null)\n-            throw new ActivationException(\"nonexistent group\");\n-\n-        return currGroupID;\n-    }\n-\n-    \/**\n-     * Set the activation system for the VM.  The activation system can\n-     * only be set it if no group is currently active. If the activation\n-     * system is not set via this call, then the <code>getSystem<\/code>\n-     * method attempts to obtain a reference to the\n-     * <code>ActivationSystem<\/code> by looking up the name\n-     * \"java.rmi.activation.ActivationSystem\" in the Activator's\n-     * registry. By default, the port number used to look up the\n-     * activation system is defined by\n-     * <code>ActivationSystem.SYSTEM_PORT<\/code>. This port can be overridden\n-     * by setting the property <code>java.rmi.activation.port<\/code>.\n-     *\n-     * <p>If there is a security manager, this method first\n-     * calls the security manager's <code>checkSetFactory<\/code> method.\n-     * This could result in a SecurityException.\n-     *\n-     * @param system remote reference to the <code>ActivationSystem<\/code>\n-     * @throws ActivationException if activation system is already set\n-     * @throws SecurityException if permission to set the activation system is denied.\n-     * (Note: The default implementation of the security manager\n-     * <code>checkSetFactory<\/code>\n-     * method requires the RuntimePermission \"setFactory\")\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @see #getSystem\n-     * @see SecurityManager#checkSetFactory\n-     * @since 1.2\n-     *\/\n-    public static synchronized void setSystem(ActivationSystem system)\n-        throws ActivationException\n-    {\n-        SecurityManager security = System.getSecurityManager();\n-        if (security != null)\n-            security.checkSetFactory();\n-\n-        if (currSystem != null)\n-            throw new ActivationException(\"activation system already set\");\n-\n-        currSystem = system;\n-    }\n-\n-    \/**\n-     * Returns the activation system for the VM. The activation system\n-     * may be set by the <code>setSystem<\/code> method. If the\n-     * activation system is not set via the <code>setSystem<\/code>\n-     * method, then the <code>getSystem<\/code> method attempts to\n-     * obtain a reference to the <code>ActivationSystem<\/code> by\n-     * looking up the name \"java.rmi.activation.ActivationSystem\" in\n-     * the Activator's registry. By default, the port number used to\n-     * look up the activation system is defined by\n-     * <code>ActivationSystem.SYSTEM_PORT<\/code>. This port can be\n-     * overridden by setting the property\n-     * <code>java.rmi.activation.port<\/code>.\n-     *\n-     * @return the activation system for the VM\/group\n-     * @throws ActivationException if activation system cannot be\n-     *  obtained or is not bound\n-     * (means that it is not running)\n-     * @throws UnsupportedOperationException if and only if activation is\n-     * not supported by this implementation\n-     * @see #setSystem\n-     * @since 1.2\n-     *\/\n-    public static synchronized ActivationSystem getSystem()\n-        throws ActivationException\n-    {\n-        if (currSystem == null) {\n-            try {\n-                int port = AccessController.doPrivileged((PrivilegedAction<Integer>) () ->\n-                    Integer.getInteger(\"java.rmi.activation.port\", ActivationSystem.SYSTEM_PORT));\n-                currSystem = (ActivationSystem)\n-                    Naming.lookup(\"\/\/:\" + port +\n-                                  \"\/java.rmi.activation.ActivationSystem\");\n-            } catch (Exception e) {\n-                throw new ActivationException(\n-                    \"unable to obtain ActivationSystem\", e);\n-            }\n-        }\n-        return currSystem;\n-    }\n-\n-    \/**\n-     * This protected method is necessary for subclasses to\n-     * make the <code>activeObject<\/code> callback to the group's\n-     * monitor. The call is simply forwarded to the group's\n-     * <code>ActivationMonitor<\/code>.\n-     *\n-     * @param id the object's identifier\n-     * @param mobj a marshalled object containing the remote object's stub\n-     * @throws UnknownObjectException if object is not registered\n-     * @throws RemoteException if call informing monitor fails\n-     * @throws ActivationException if an activation error occurs\n-     * @since 1.2\n-     *\/\n-    protected void activeObject(ActivationID id,\n-                                MarshalledObject<? extends Remote> mobj)\n-        throws ActivationException, UnknownObjectException, RemoteException\n-    {\n-        getMonitor().activeObject(id, mobj);\n-    }\n-\n-    \/**\n-     * This protected method is necessary for subclasses to\n-     * make the <code>inactiveGroup<\/code> callback to the group's\n-     * monitor. The call is simply forwarded to the group's\n-     * <code>ActivationMonitor<\/code>. Also, the current group\n-     * for the VM is set to null.\n-     *\n-     * @throws UnknownGroupException if group is not registered\n-     * @throws RemoteException if call informing monitor fails\n-     * @since 1.2\n-     *\/\n-    protected void inactiveGroup()\n-        throws UnknownGroupException, RemoteException\n-    {\n-        try {\n-            getMonitor().inactiveGroup(groupID, incarnation);\n-        } finally {\n-            destroyGroup();\n-        }\n-    }\n-\n-    \/**\n-     * Returns the monitor for the activation group.\n-     *\/\n-    private ActivationMonitor getMonitor() throws RemoteException {\n-        synchronized (ActivationGroup.class) {\n-            if (monitor != null) {\n-                return monitor;\n-            }\n-        }\n-        throw new RemoteException(\"monitor not received\");\n-    }\n-\n-    \/**\n-     * Destroys the current group.\n-     *\/\n-    private static synchronized void destroyGroup() {\n-        currGroup = null;\n-        currGroupID = null;\n-        \/\/ NOTE: don't set currSystem to null since it may be needed\n-    }\n-\n-    \/**\n-     * Returns the current group for the VM.\n-     * @throws ActivationException if current group is null (not active)\n-     *\/\n-    static synchronized ActivationGroup currentGroup()\n-        throws ActivationException\n-    {\n-        if (currGroup == null) {\n-            throw new ActivationException(\"group is not active\");\n-        }\n-        return currGroup;\n-    }\n-\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationGroup.java","additions":0,"deletions":543,"binary":false,"changes":543,"status":"deleted"},{"patch":"@@ -1,381 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.Serializable;\n-import java.rmi.MarshalledObject;\n-import java.util.Arrays;\n-import java.util.Properties;\n-\n-\/**\n- * An activation group descriptor contains the information necessary to\n- * create\/recreate an activation group in which to activate objects.\n- * Such a descriptor contains: <ul>\n- * <li> the group's class name,\n- * <li> the group's code location (the location of the group's class), and\n- * <li> a \"marshalled\" object that can contain group specific\n- * initialization data. <\/ul> <p>\n- *\n- * The group's class must be a concrete subclass of\n- * <code>ActivationGroup<\/code>. A subclass of\n- * <code>ActivationGroup<\/code> is created\/recreated via the\n- * <code>ActivationGroup.createGroup<\/code> static method that invokes\n- * a special constructor that takes two arguments: <ul>\n- *\n- * <li> the group's <code>ActivationGroupID<\/code>, and\n- * <li> the group's initialization data (in a\n- * <code>java.rmi.MarshalledObject<\/code>)<\/ul>\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @see         ActivationGroup\n- * @see         ActivationGroupID\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-public final class ActivationGroupDesc implements Serializable {\n-\n-    \/**\n-     * @serial The group's fully package qualified class name.\n-     *\/\n-    private String className;\n-\n-    \/**\n-     * @serial The location from where to load the group's class.\n-     *\/\n-    private String location;\n-\n-    \/**\n-     * @serial The group's initialization data.\n-     *\/\n-    private MarshalledObject<?> data;\n-\n-    \/**\n-     * @serial The controlling options for executing the VM in\n-     * another process.\n-     *\/\n-    private CommandEnvironment env;\n-\n-    \/**\n-     * @serial A properties map which will override those set\n-     * by default in the subprocess environment.\n-     *\/\n-    private Properties props;\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    @java.io.Serial\n-    private static final long serialVersionUID = -4936225423168276595L;\n-\n-    \/**\n-     * Constructs a group descriptor that uses the system defaults for group\n-     * implementation and code location.  Properties specify Java\n-     * environment overrides (which will override system properties in\n-     * the group implementation's VM).  The command\n-     * environment can control the exact command\/options used in\n-     * starting the child VM, or can be <code>null<\/code> to accept\n-     * rmid's default.\n-     *\n-     * <p>This constructor will create an <code>ActivationGroupDesc<\/code>\n-     * with a <code>null<\/code> group class name, which indicates the system's\n-     * default <code>ActivationGroup<\/code> implementation.\n-     *\n-     * @param overrides the set of properties to set when the group is\n-     * recreated.\n-     * @param cmd the controlling options for executing the VM in\n-     * another process (or <code>null<\/code>).\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupDesc(Properties overrides,\n-                               CommandEnvironment cmd)\n-    {\n-        this(null, null, null, overrides, cmd);\n-    }\n-\n-    \/**\n-     * Specifies an alternate group implementation and execution\n-     * environment to be used for the group.\n-     *\n-     * @param className the group's package qualified class name or\n-     * <code>null<\/code>. A <code>null<\/code> group class name indicates\n-     * the system's default <code>ActivationGroup<\/code> implementation.\n-     * @param location the location from where to load the group's\n-     * class\n-     * @param data the group's initialization data contained in\n-     * marshalled form (could contain properties, for example)\n-     * @param overrides a properties map which will override those set\n-     * by default in the subprocess environment (will be translated\n-     * into <code>-D<\/code> options), or <code>null<\/code>.\n-     * @param cmd the controlling options for executing the VM in\n-     * another process (or <code>null<\/code>).\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupDesc(String className,\n-                               String location,\n-                               MarshalledObject<?> data,\n-                               Properties overrides,\n-                               CommandEnvironment cmd)\n-    {\n-        this.props = overrides;\n-        this.env = cmd;\n-        this.data = data;\n-        this.location = location;\n-        this.className = className;\n-    }\n-\n-    \/**\n-     * Returns the group's class name (possibly <code>null<\/code>).  A\n-     * <code>null<\/code> group class name indicates the system's default\n-     * <code>ActivationGroup<\/code> implementation.\n-     * @return the group's class name\n-     * @since 1.2\n-     *\/\n-    public String getClassName() {\n-        return className;\n-    }\n-\n-    \/**\n-     * Returns the group's code location.\n-     * @return the group's code location\n-     * @since 1.2\n-     *\/\n-    public String getLocation() {\n-        return location;\n-    }\n-\n-    \/**\n-     * Returns the group's initialization data.\n-     * @return the group's initialization data\n-     * @since 1.2\n-     *\/\n-    public MarshalledObject<?> getData() {\n-        return data;\n-    }\n-\n-    \/**\n-     * Returns the group's property-override list.\n-     * @return the property-override list, or <code>null<\/code>\n-     * @since 1.2\n-     *\/\n-    public Properties getPropertyOverrides() {\n-        return (props != null) ? (Properties) props.clone() : null;\n-    }\n-\n-    \/**\n-     * Returns the group's command-environment control object.\n-     * @return the command-environment object, or <code>null<\/code>\n-     * @since 1.2\n-     *\/\n-    public CommandEnvironment getCommandEnvironment() {\n-        return this.env;\n-    }\n-\n-\n-    \/**\n-     * Startup options for ActivationGroup implementations.\n-     *\n-     * This class allows overriding default system properties and\n-     * specifying implementation-defined options for ActivationGroups.\n-     * @since 1.2\n-     *\/\n-    public static class CommandEnvironment implements Serializable {\n-        @java.io.Serial\n-        private static final long serialVersionUID = 6165754737887770191L;\n-\n-        \/**\n-         * @serial\n-         *\/\n-        private String command;\n-\n-        \/**\n-         * @serial\n-         *\/\n-        private String[] options;\n-\n-        \/**\n-         * Create a CommandEnvironment with all the necessary\n-         * information.\n-         *\n-         * @param cmdpath the name of the java executable, including\n-         * the full path, or <code>null<\/code>, meaning \"use rmid's default\".\n-         * The named program <em>must<\/em> be able to accept multiple\n-         * <code>-Dpropname=value<\/code> options (as documented for the\n-         * \"java\" tool)\n-         *\n-         * @param argv extra options which will be used in creating the\n-         * ActivationGroup.  Null has the same effect as an empty\n-         * list.\n-         * @since 1.2\n-         *\/\n-        public CommandEnvironment(String cmdpath,\n-                                  String[] argv)\n-        {\n-            this.command = cmdpath;     \/\/ might be null\n-\n-            \/\/ Hold a safe copy of argv in this.options\n-            if (argv == null) {\n-                this.options = new String[0];\n-            } else {\n-                this.options = new String[argv.length];\n-                System.arraycopy(argv, 0, this.options, 0, argv.length);\n-            }\n-        }\n-\n-        \/**\n-         * Fetch the configured path-qualified java command name.\n-         *\n-         * @return the configured name, or <code>null<\/code> if configured to\n-         * accept the default\n-         * @since 1.2\n-         *\/\n-        public String getCommandPath() {\n-            return (this.command);\n-        }\n-\n-        \/**\n-         * Fetch the configured java command options.\n-         *\n-         * @return An array of the command options which will be passed\n-         * to the new child command by rmid.\n-         * Note that rmid may add other options before or after these\n-         * options, or both.\n-         * Never returns <code>null<\/code>.\n-         * @since 1.2\n-         *\/\n-        public String[] getCommandOptions() {\n-            return options.clone();\n-        }\n-\n-        \/**\n-         * Compares two command environments for content equality.\n-         *\n-         * @param       obj     the Object to compare with\n-         * @return      true if these Objects are equal; false otherwise.\n-         * @see         java.util.Hashtable\n-         * @since 1.2\n-         *\/\n-        public boolean equals(Object obj) {\n-\n-            if (obj instanceof CommandEnvironment) {\n-                CommandEnvironment env = (CommandEnvironment) obj;\n-                return\n-                    ((command == null ? env.command == null :\n-                      command.equals(env.command)) &&\n-                     Arrays.equals(options, env.options));\n-            } else {\n-                return false;\n-            }\n-        }\n-\n-        \/**\n-         * Return identical values for similar\n-         * <code>CommandEnvironment<\/code>s.\n-         * @return an integer\n-         * @see java.util.Hashtable\n-         *\/\n-        public int hashCode()\n-        {\n-            \/\/ hash command and ignore possibly expensive options\n-            return (command == null ? 0 : command.hashCode());\n-        }\n-\n-        \/**\n-         * <code>readObject<\/code> for custom serialization.\n-         *\n-         * <p>This method reads this object's serialized form for this\n-         * class as follows:\n-         * <p>This method first invokes <code>defaultReadObject<\/code> on\n-         * the specified object input stream, and if <code>options<\/code>\n-         * is <code>null<\/code>, then <code>options<\/code> is set to a\n-         * zero-length array of <code>String<\/code>.\n-         *\n-         * @param  in the {@code ObjectInputStream} from which data is read\n-         * @throws IOException if an I\/O error occurs\n-         * @throws ClassNotFoundException if a serialized class cannot be loaded\n-         *\n-         *\/\n-        @java.io.Serial\n-        private void readObject(ObjectInputStream in)\n-            throws IOException, ClassNotFoundException\n-        {\n-            in.defaultReadObject();\n-            if (options == null) {\n-                options = new String[0];\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Compares two activation group descriptors for content equality.\n-     *\n-     * @param   obj     the Object to compare with\n-     * @return  true if these Objects are equal; false otherwise.\n-     * @see             java.util.Hashtable\n-     * @since 1.2\n-     *\/\n-    public boolean equals(Object obj) {\n-\n-        if (obj instanceof ActivationGroupDesc) {\n-            ActivationGroupDesc desc = (ActivationGroupDesc) obj;\n-            return\n-                ((className == null ? desc.className == null :\n-                  className.equals(desc.className)) &&\n-                 (location == null ? desc.location == null :\n-                  location.equals(desc.location)) &&\n-                 (data == null ? desc.data == null : data.equals(desc.data)) &&\n-                 (env == null ? desc.env == null : env.equals(desc.env)) &&\n-                 (props == null ? desc.props == null :\n-                  props.equals(desc.props)));\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Produce identical numbers for similar <code>ActivationGroupDesc<\/code>s.\n-     * @return an integer\n-     * @see java.util.Hashtable\n-     *\/\n-    public int hashCode() {\n-        \/\/ hash location, className, data, and env\n-        \/\/ but omit props (may be expensive)\n-        return ((location == null\n-                    ? 0\n-                    : location.hashCode() << 24) ^\n-                (env == null\n-                    ? 0\n-                    : env.hashCode() << 16) ^\n-                (className == null\n-                    ? 0\n-                    : className.hashCode() << 8) ^\n-                (data == null\n-                    ? 0\n-                    : data.hashCode()));\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationGroupDesc.java","additions":0,"deletions":381,"binary":false,"changes":381,"status":"deleted"},{"patch":"@@ -1,123 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.rmi.server.UID;\n-\n-\/**\n- * The identifier for a registered activation group serves several\n- * purposes: <ul>\n- * <li>identifies the group uniquely within the activation system, and\n- * <li>contains a reference to the group's activation system so that the\n- * group can contact its activation system when necessary.<\/ul><p>\n- *\n- * The <code>ActivationGroupID<\/code> is returned from the call to\n- * <code>ActivationSystem.registerGroup<\/code> and is used to identify\n- * the group within the activation system. This group id is passed\n- * as one of the arguments to the activation group's special constructor\n- * when an activation group is created\/recreated.\n- *\n- * @author      Ann Wollrath\n- * @see         ActivationGroup\n- * @see         ActivationGroupDesc\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public class ActivationGroupID implements java.io.Serializable {\n-    \/**\n-     * @serial The group's activation system.\n-     *\/\n-    @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n-    private ActivationSystem system;\n-\n-    \/**\n-     * @serial The group's unique id.\n-     *\/\n-    private UID uid = new UID();\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private  static final long serialVersionUID = -1648432278909740833L;\n-\n-    \/**\n-     * Constructs a unique group id.\n-     *\n-     * @param system the group's activation system\n-     * @throws UnsupportedOperationException if and only if activation is\n-     *         not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupID(ActivationSystem system) {\n-        this.system = system;\n-    }\n-\n-    \/**\n-     * Returns the group's activation system.\n-     * @return the group's activation system\n-     * @since 1.2\n-     *\/\n-    public ActivationSystem getSystem() {\n-        return system;\n-    }\n-\n-    \/**\n-     * Returns a hashcode for the group's identifier.  Two group\n-     * identifiers that refer to the same remote group will have the\n-     * same hash code.\n-     *\n-     * @see java.util.Hashtable\n-     * @since 1.2\n-     *\/\n-    public int hashCode() {\n-        return uid.hashCode();\n-    }\n-\n-    \/**\n-     * Compares two group identifiers for content equality.\n-     * Returns true if both of the following conditions are true:\n-     * 1) the unique identifiers are equivalent (by content), and\n-     * 2) the activation system specified in each\n-     *    refers to the same remote object.\n-     *\n-     * @param   obj     the Object to compare with\n-     * @return  true if these Objects are equal; false otherwise.\n-     * @see             java.util.Hashtable\n-     * @since 1.2\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (this == obj) {\n-            return true;\n-        } else if (obj instanceof ActivationGroupID) {\n-            ActivationGroupID id = (ActivationGroupID)obj;\n-            return (uid.equals(id.uid) && system.equals(id.system));\n-        } else {\n-            return false;\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationGroupID.java","additions":0,"deletions":123,"binary":false,"changes":123,"status":"deleted"},{"patch":"@@ -1,112 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.lang.reflect.Method;\n-import java.rmi.MarshalledObject;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.UnexpectedException;\n-import java.rmi.server.RemoteRef;\n-import java.rmi.server.RemoteStub;\n-\n-\/**\n- * {@code ActivationGroup_Stub} is a stub class for the subclasses of {@code java.rmi.activation.ActivationGroup}\n- * that are exported as a {@code java.rmi.server.UnicastRemoteObject}.\n- *\n- * @since 1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings({\"rawtypes\", \"removal\", \"unchecked\"})\n-public final class ActivationGroup_Stub\n-        extends RemoteStub\n-        implements ActivationInstantiator, Remote {\n-\n-    @java.io.Serial\n-    private static final long serialVersionUID = 2;\n-\n-    private static Method $method_newInstance_0;\n-\n-    static {\n-        try {\n-            $method_newInstance_0 =\n-                    ActivationInstantiator.class.getMethod(\"newInstance\",\n-                            new Class<?>[] {ActivationID.class, ActivationDesc.class});\n-        } catch (NoSuchMethodException e) {\n-            throw new NoSuchMethodError(\n-                    \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/**\n-     * Constructs a stub for the {@code ActivationGroup} class.\n-     * It invokes the superclass {@code RemoteStub(RemoteRef)}\n-     * constructor with its argument, {@code ref}.\n-     *\n-     * @param ref a remote ref\n-     *\/\n-    public ActivationGroup_Stub(RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/**\n-     * Stub method for {@code ActivationGroup.newInstance}.  Invokes\n-     * the {@code invoke} method on this instance's\n-     * {@code RemoteObject.ref} field, with {@code this} as the\n-     * first argument, a two-element {@code Object[]} as the second\n-     * argument (with {@code id} as the first element and\n-     * {@code desc} as the second element), and -5274445189091581345L\n-     * as the third argument, and returns the result.  If that invocation\n-     * throws a {@code RuntimeException}, {@code RemoteException},\n-     * or an {@code ActivationException}, then that exception is\n-     * thrown to the caller.  If that invocation throws any other\n-     * {@code java.lang.Exception}, then a\n-     * {@code java.rmi.UnexpectedException} is thrown to the caller\n-     * with the original exception as the cause.\n-     *\n-     * @param id   an activation identifier\n-     * @param desc an activation descriptor\n-     * @return the result of the invocation\n-     * @throws RemoteException     if invocation results in a {@code RemoteException}\n-     * @throws ActivationException if invocation results in an {@code ActivationException}\n-     *\/\n-    public MarshalledObject newInstance(ActivationID id,\n-                                        ActivationDesc desc)\n-            throws RemoteException, ActivationException {\n-        try {\n-            Object $result = ref.invoke(this, $method_newInstance_0,\n-                    new Object[]{id, desc}, -5274445189091581345L);\n-            return ((MarshalledObject) $result);\n-        } catch (RuntimeException | RemoteException | ActivationException e) {\n-            throw e;\n-        } catch (Exception e) {\n-            throw new UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationGroup_Stub.java","additions":0,"deletions":112,"binary":false,"changes":112,"status":"deleted"},{"patch":"@@ -1,328 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.io.IOException;\n-import java.io.InvalidObjectException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.Proxy;\n-import java.rmi.MarshalledObject;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.UnmarshalException;\n-import java.rmi.server.RemoteObject;\n-import java.rmi.server.RemoteObjectInvocationHandler;\n-import java.rmi.server.RemoteRef;\n-import java.rmi.server.UID;\n-import java.security.AccessControlContext;\n-import java.security.AccessController;\n-import java.security.Permissions;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.ProtectionDomain;\n-\n-\/**\n- * Activation makes use of special identifiers to denote remote\n- * objects that can be activated over time. An activation identifier\n- * (an instance of the class <code>ActivationID<\/code>) contains several\n- * pieces of information needed for activating an object:\n- * <ul>\n- * <li> a remote reference to the object's activator (a {@link\n- * java.rmi.server.RemoteRef RemoteRef}\n- * instance), and\n- * <li> a unique identifier (a {@link java.rmi.server.UID UID}\n- * instance) for the object. <\/ul> <p>\n- *\n- * An activation identifier for an object can be obtained by registering\n- * an object with the activation system. Registration is accomplished\n- * in a few ways: <ul>\n- * <li>via the <code>Activatable.register<\/code> method\n- * <li>via the first <code>Activatable<\/code> constructor (that takes\n- * three arguments and both registers and exports the object, and\n- * <li>via the first <code>Activatable.exportObject<\/code> method\n- * that takes the activation descriptor, object and port as arguments;\n- * this method both registers and exports the object. <\/ul>\n- *\n- * @author      Ann Wollrath\n- * @see         Activatable\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public class ActivationID implements Serializable {\n-    \/**\n-     * the object's activator\n-     *\/\n-    private transient Activator activator;\n-\n-    \/**\n-     * the object's unique id\n-     *\/\n-    private transient UID uid = new UID();\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    @java.io.Serial\n-    private static final long serialVersionUID = -4608673054848209235L;\n-\n-    \/** an AccessControlContext with no permissions *\/\n-    private static final AccessControlContext NOPERMS_ACC;\n-    static {\n-        Permissions perms = new Permissions();\n-        ProtectionDomain[] pd = { new ProtectionDomain(null, perms) };\n-        NOPERMS_ACC = new AccessControlContext(pd);\n-    }\n-\n-    \/**\n-     * The constructor for <code>ActivationID<\/code> takes a single\n-     * argument, activator, that specifies a remote reference to the\n-     * activator responsible for activating the object associated with\n-     * this identifier. An instance of <code>ActivationID<\/code> is globally\n-     * unique.\n-     *\n-     * @param activator reference to the activator responsible for\n-     * activating the object\n-     * @throws UnsupportedOperationException if and only if activation is\n-     *         not supported by this implementation\n-     * @since 1.2\n-     *\/\n-    public ActivationID(Activator activator) {\n-        this.activator = activator;\n-    }\n-\n-    \/**\n-     * Activate the object for this id.\n-     *\n-     * @param force if true, forces the activator to contact the group\n-     * when activating the object (instead of returning a cached reference);\n-     * if false, returning a cached value is acceptable.\n-     * @return the reference to the active remote object\n-     * @throws ActivationException if activation fails\n-     * @throws UnknownObjectException if the object is unknown\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public Remote activate(boolean force)\n-        throws ActivationException, UnknownObjectException, RemoteException\n-    {\n-        try {\n-            MarshalledObject<? extends Remote> mobj =\n-                activator.activate(this, force);\n-            return AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<Remote>() {\n-                    public Remote run() throws IOException, ClassNotFoundException {\n-                        return mobj.get();\n-                    }\n-                }, NOPERMS_ACC);\n-        } catch (PrivilegedActionException pae) {\n-            Exception ex = pae.getException();\n-            if (ex instanceof RemoteException) {\n-                throw (RemoteException) ex;\n-            } else {\n-                throw new UnmarshalException(\"activation failed\", ex);\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Returns a hashcode for the activation id.  Two identifiers that\n-     * refer to the same remote object will have the same hash code.\n-     *\n-     * @see java.util.Hashtable\n-     * @since 1.2\n-     *\/\n-    public int hashCode() {\n-        return uid.hashCode();\n-    }\n-\n-    \/**\n-     * Compares two activation ids for content equality.\n-     * Returns true if both of the following conditions are true:\n-     * 1) the unique identifiers equivalent (by content), and\n-     * 2) the activator specified in each identifier\n-     *    refers to the same remote object.\n-     *\n-     * @param   obj     the Object to compare with\n-     * @return  true if these Objects are equal; false otherwise.\n-     * @see             java.util.Hashtable\n-     * @since 1.2\n-     *\/\n-    public boolean equals(Object obj) {\n-        if (obj instanceof ActivationID) {\n-            ActivationID id = (ActivationID) obj;\n-            return (uid.equals(id.uid) && activator.equals(id.activator));\n-        } else {\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * <code>writeObject<\/code> for custom serialization.\n-     *\n-     * <p>This method writes this object's serialized form for\n-     * this class as follows:\n-     *\n-     * <p>The <code>writeObject<\/code> method is invoked on\n-     * <code>out<\/code> passing this object's unique identifier\n-     * (a {@link java.rmi.server.UID UID} instance) as the argument.\n-     *\n-     * <p>Next, the {@link\n-     * java.rmi.server.RemoteRef#getRefClass(java.io.ObjectOutput)\n-     * getRefClass} method is invoked on the activator's\n-     * <code>RemoteRef<\/code> instance to obtain its external ref\n-     * type name.  Next, the <code>writeUTF<\/code> method is\n-     * invoked on <code>out<\/code> with the value returned by\n-     * <code>getRefClass<\/code>, and then the\n-     * <code>writeExternal<\/code> method is invoked on the\n-     * <code>RemoteRef<\/code> instance passing <code>out<\/code>\n-     * as the argument.\n-     *\n-     * @serialData The serialized data for this class comprises a\n-     * <code>java.rmi.server.UID<\/code> (written with\n-     * <code>ObjectOutput.writeObject<\/code>) followed by the\n-     * external ref type name of the activator's\n-     * <code>RemoteRef<\/code> instance (a string written with\n-     * <code>ObjectOutput.writeUTF<\/code>), followed by the\n-     * external form of the <code>RemoteRef<\/code> instance as\n-     * written by its <code>writeExternal<\/code> method.\n-     *\n-     * <p>The external ref type name of the\n-     * <code>RemoteRef<\/Code> instance is\n-     * determined using the definitions of external ref type\n-     * names specified in the {@link java.rmi.server.RemoteObject\n-     * RemoteObject} <code>writeObject<\/code> method\n-     * <b>serialData<\/b> specification.  Similarly, the data\n-     * written by the <code>writeExternal<\/code> method and read\n-     * by the <code>readExternal<\/code> method of\n-     * <code>RemoteRef<\/code> implementation classes\n-     * corresponding to each of the defined external ref type\n-     * names is specified in the {@link\n-     * java.rmi.server.RemoteObject RemoteObject}\n-     * <code>writeObject<\/code> method <b>serialData<\/b>\n-     * specification.\n-     *\n-     * @param  out the {@code ObjectOutputStream} to which data is written\n-     * @throws IOException if an I\/O error occurs\n-     **\/\n-    @java.io.Serial\n-    private void writeObject(ObjectOutputStream out)\n-        throws IOException\n-    {\n-        out.writeObject(uid);\n-\n-        RemoteRef ref;\n-        if (activator instanceof RemoteObject) {\n-            ref = ((RemoteObject) activator).getRef();\n-        } else if (Proxy.isProxyClass(activator.getClass())) {\n-            InvocationHandler handler = Proxy.getInvocationHandler(activator);\n-            if (!(handler instanceof RemoteObjectInvocationHandler)) {\n-                throw new InvalidObjectException(\n-                    \"unexpected invocation handler\");\n-            }\n-            ref = ((RemoteObjectInvocationHandler) handler).getRef();\n-\n-        } else {\n-            throw new InvalidObjectException(\"unexpected activator type\");\n-        }\n-        out.writeUTF(ref.getRefClass(out));\n-        ref.writeExternal(out);\n-    }\n-\n-    \/**\n-     * <code>readObject<\/code> for custom serialization.\n-     *\n-     * <p>This method reads this object's serialized form for this\n-     * class as follows:\n-     *\n-     * <p>The <code>readObject<\/code> method is invoked on\n-     * <code>in<\/code> to read this object's unique identifier\n-     * (a {@link java.rmi.server.UID UID} instance).\n-     *\n-     * <p>Next, the <code>readUTF<\/code> method is invoked on\n-     * <code>in<\/code> to read the external ref type name of the\n-     * <code>RemoteRef<\/code> instance for this object's\n-     * activator.  Next, the <code>RemoteRef<\/code>\n-     * instance is created of an implementation-specific class\n-     * corresponding to the external ref type name (returned by\n-     * <code>readUTF<\/code>), and the <code>readExternal<\/code>\n-     * method is invoked on that <code>RemoteRef<\/code> instance\n-     * to read the external form corresponding to the external\n-     * ref type name.\n-     *\n-     * <p>Note: If the external ref type name is\n-     * <code>\"UnicastRef\"<\/code>, <code>\"UnicastServerRef\"<\/code>,\n-     * <code>\"UnicastRef2\"<\/code>, <code>\"UnicastServerRef2\"<\/code>,\n-     * or <code>\"ActivatableRef\"<\/code>, a corresponding\n-     * implementation-specific class must be found, and its\n-     * <code>readExternal<\/code> method must read the serial data\n-     * for that external ref type name as specified to be written\n-     * in the <b>serialData<\/b> documentation for this class.\n-     * If the external ref type name is any other string (of non-zero\n-     * length), a <code>ClassNotFoundException<\/code> will be thrown,\n-     * unless the implementation provides an implementation-specific\n-     * class corresponding to that external ref type name, in which\n-     * case the <code>RemoteRef<\/code> will be an instance of\n-     * that implementation-specific class.\n-     *\n-     * @param  in the {@code ObjectInputStream} from which data is read\n-     * @throws IOException if an I\/O error occurs\n-     * @throws ClassNotFoundException if a serialized class cannot be loaded\n-     *\n-     *\/\n-    @java.io.Serial\n-    private void readObject(ObjectInputStream in)\n-        throws IOException, ClassNotFoundException\n-    {\n-        uid = (UID)in.readObject();\n-\n-        try {\n-            Class<? extends RemoteRef> refClass =\n-                Class.forName(RemoteRef.packagePrefix + \".\" + in.readUTF())\n-                .asSubclass(RemoteRef.class);\n-            @SuppressWarnings(\"deprecation\")\n-            RemoteRef ref = refClass.newInstance();\n-            ref.readExternal(in);\n-            activator = (Activator)\n-                Proxy.newProxyInstance(Activator.class.getClassLoader(),\n-                                       new Class<?>[] { Activator.class },\n-                                       new RemoteObjectInvocationHandler(ref));\n-        } catch (InstantiationException e) {\n-            throw (IOException)\n-                new InvalidObjectException(\n-                    \"Unable to create remote reference\").initCause(e);\n-        } catch (IllegalAccessException e) {\n-            throw (IOException)\n-                new InvalidObjectException(\n-                    \"Unable to create remote reference\").initCause(e);\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationID.java","additions":0,"deletions":328,"binary":false,"changes":328,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.rmi.MarshalledObject;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-\n-\/**\n- * An <code>ActivationInstantiator<\/code> is responsible for creating\n- * instances of \"activatable\" objects. A concrete subclass of\n- * <code>ActivationGroup<\/code> implements the <code>newInstance<\/code>\n- * method to handle creating objects within the group.\n- *\n- * @author      Ann Wollrath\n- * @see         ActivationGroup\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public interface ActivationInstantiator extends Remote {\n-\n-   \/**\n-    * The activator calls an instantiator's <code>newInstance<\/code>\n-    * method in order to recreate in that group an object with the\n-    * activation identifier, <code>id<\/code>, and descriptor,\n-    * <code>desc<\/code>. The instantiator is responsible for: <ul>\n-    *\n-    * <li> determining the class for the object using the descriptor's\n-    * <code>getClassName<\/code> method,\n-    *\n-    * <li> loading the class from the code location obtained from the\n-    * descriptor (using the <code>getLocation<\/code> method),\n-    *\n-    * <li> creating an instance of the class by invoking the special\n-    * \"activation\" constructor of the object's class that takes two\n-    * arguments: the object's <code>ActivationID<\/code>, and the\n-    * <code>MarshalledObject<\/code> containing object specific\n-    * initialization data, and\n-    *\n-    * <li> returning a MarshalledObject containing the stub for the\n-    * remote object it created.<\/ul>\n-    *\n-    * <p>In order for activation to be successful, one of the following requirements\n-    * must be met, otherwise {@link ActivationException} is thrown:\n-    *\n-    * <ul><li>The class to be activated and the special activation constructor are both public,\n-    * and the class resides in a package that is\n-    * {@linkplain Module#isExported(String,Module) exported}\n-    * to at least the {@code java.rmi} module; or\n-    *\n-    * <li>The class to be activated resides in a package that is\n-    * {@linkplain Module#isOpen(String,Module) open}\n-    * to at least the {@code java.rmi} module.\n-    * <\/ul>\n-    *\n-    * @param id the object's activation identifier\n-    * @param desc the object's descriptor\n-    * @return a marshalled object containing the serialized\n-    * representation of remote object's stub\n-    * @throws ActivationException if object activation fails\n-    * @throws RemoteException if remote call fails\n-    * @since 1.2\n-    *\/\n-    public MarshalledObject<? extends Remote> newInstance(ActivationID id,\n-                                                          ActivationDesc desc)\n-        throws ActivationException, RemoteException;\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationInstantiator.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.rmi.MarshalledObject;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.UnknownGroupException;\n-import java.rmi.activation.UnknownObjectException;\n-\n-\/**\n- * An <code>ActivationMonitor<\/code> is specific to an\n- * <code>ActivationGroup<\/code> and is obtained when a group is\n- * reported active via a call to\n- * <code>ActivationSystem.activeGroup<\/code> (this is done\n- * internally). An activation group is responsible for informing its\n- * <code>ActivationMonitor<\/code> when either: its objects become active or\n- * inactive, or the group as a whole becomes inactive.\n- *\n- * @author      Ann Wollrath\n- * @see         Activator\n- * @see         ActivationSystem\n- * @see         ActivationGroup\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public interface ActivationMonitor extends Remote {\n-\n-   \/**\n-     * An activation group calls its monitor's\n-     * <code>inactiveObject<\/code> method when an object in its group\n-     * becomes inactive (deactivates).  An activation group discovers\n-     * that an object (that it participated in activating) in its VM\n-     * is no longer active, via calls to the activation group's\n-     * <code>inactiveObject<\/code> method. <p>\n-     *\n-     * The <code>inactiveObject<\/code> call informs the\n-     * <code>ActivationMonitor<\/code> that the remote object reference\n-     * it holds for the object with the activation identifier,\n-     * <code>id<\/code>, is no longer valid. The monitor considers the\n-     * reference associated with <code>id<\/code> as a stale reference.\n-     * Since the reference is considered stale, a subsequent\n-     * <code>activate<\/code> call for the same activation identifier\n-     * results in re-activating the remote object.\n-     *\n-     * @param id the object's activation identifier\n-     * @throws UnknownObjectException if object is unknown\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public void inactiveObject(ActivationID id)\n-        throws UnknownObjectException, RemoteException;\n-\n-    \/**\n-     * Informs that an object is now active. An <code>ActivationGroup<\/code>\n-     * informs its monitor if an object in its group becomes active by\n-     * other means than being activated directly (i.e., the object\n-     * is registered and \"activated\" itself).\n-     *\n-     * @param id the active object's id\n-     * @param obj the marshalled form of the object's stub\n-     * @throws UnknownObjectException if object is unknown\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public void activeObject(ActivationID id,\n-                             MarshalledObject<? extends Remote> obj)\n-        throws UnknownObjectException, RemoteException;\n-\n-    \/**\n-     * Informs that the group is now inactive. The group will be\n-     * recreated upon a subsequent request to activate an object\n-     * within the group. A group becomes inactive when all objects\n-     * in the group report that they are inactive.\n-     *\n-     * @param id the group's id\n-     * @param incarnation the group's incarnation number\n-     * @throws UnknownGroupException if group is unknown\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public void inactiveGroup(ActivationGroupID id,\n-                              long incarnation)\n-        throws UnknownGroupException, RemoteException;\n-\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationMonitor.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,234 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.UnknownGroupException;\n-import java.rmi.activation.UnknownObjectException;\n-\n-\/**\n- * The <code>ActivationSystem<\/code> provides a means for registering\n- * groups and \"activatable\" objects to be activated within those groups.\n- * The <code>ActivationSystem<\/code> works closely with the\n- * <code>Activator<\/code>, which activates objects registered via the\n- * <code>ActivationSystem<\/code>, and the <code>ActivationMonitor<\/code>,\n- * which obtains information about active and inactive objects,\n- * and inactive groups.\n- *\n- * @author      Ann Wollrath\n- * @see         Activator\n- * @see         ActivationMonitor\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public interface ActivationSystem extends Remote {\n-\n-    \/** The port to lookup the activation system. *\/\n-    public static final int SYSTEM_PORT = 1098;\n-\n-    \/**\n-     * The <code>registerObject<\/code> method is used to register an\n-     * activation descriptor, <code>desc<\/code>, and obtain an\n-     * activation identifier for a activatable remote object. The\n-     * <code>ActivationSystem<\/code> creates an\n-     * <code>ActivationID<\/code> (a activation identifier) for the\n-     * object specified by the descriptor, <code>desc<\/code>, and\n-     * records, in stable storage, the activation descriptor and its\n-     * associated identifier for later use. When the <code>Activator<\/code>\n-     * receives an <code>activate<\/code> request for a specific identifier, it\n-     * looks up the activation descriptor (registered previously) for\n-     * the specified identifier and uses that information to activate\n-     * the object.\n-     *\n-     * @param desc the object's activation descriptor\n-     * @return the activation id that can be used to activate the object\n-     * @throws ActivationException if registration fails (e.g., database\n-     * update failure, etc).\n-     * @throws UnknownGroupException if group referred to in\n-     * <code>desc<\/code> is not registered with this system\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public ActivationID registerObject(ActivationDesc desc)\n-        throws ActivationException, UnknownGroupException, RemoteException;\n-\n-    \/**\n-     * Remove the activation id and associated descriptor previously\n-     * registered with the <code>ActivationSystem<\/code>; the object\n-     * can no longer be activated via the object's activation id.\n-     *\n-     * @param id the object's activation id (from previous registration)\n-     * @throws ActivationException if unregister fails (e.g., database\n-     * update failure, etc).\n-     * @throws UnknownObjectException if object is unknown (not registered)\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public void unregisterObject(ActivationID id)\n-        throws ActivationException, UnknownObjectException, RemoteException;\n-\n-    \/**\n-     * Register the activation group. An activation group must be\n-     * registered with the <code>ActivationSystem<\/code> before objects\n-     * can be registered within that group.\n-     *\n-     * @param desc the group's descriptor\n-     * @return an identifier for the group\n-     * @throws ActivationException if group registration fails\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupID registerGroup(ActivationGroupDesc desc)\n-        throws ActivationException, RemoteException;\n-\n-    \/**\n-     * Callback to inform activation system that group is now\n-     * active. This call is made internally by the\n-     * <code>ActivationGroup.createGroup<\/code> method to inform\n-     * the <code>ActivationSystem<\/code> that the group is now\n-     * active.\n-     *\n-     * @param id the activation group's identifier\n-     * @param group the group's instantiator\n-     * @param incarnation the group's incarnation number\n-     * @return monitor for activation group\n-     * @throws UnknownGroupException if group is not registered\n-     * @throws ActivationException if a group for the specified\n-     * <code>id<\/code> is already active and that group is not equal\n-     * to the specified <code>group<\/code> or that group has a different\n-     * <code>incarnation<\/code> than the specified <code>group<\/code>\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public ActivationMonitor activeGroup(ActivationGroupID id,\n-                                         ActivationInstantiator group,\n-                                         long incarnation)\n-        throws UnknownGroupException, ActivationException, RemoteException;\n-\n-    \/**\n-     * Remove the activation group. An activation group makes this call back\n-     * to inform the activator that the group should be removed (destroyed).\n-     * If this call completes successfully, objects can no longer be\n-     * registered or activated within the group. All information of the\n-     * group and its associated objects is removed from the system.\n-     *\n-     * @param id the activation group's identifier\n-     * @throws ActivationException if unregister fails (e.g., database\n-     * update failure, etc).\n-     * @throws UnknownGroupException if group is not registered\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public void unregisterGroup(ActivationGroupID id)\n-        throws ActivationException, UnknownGroupException, RemoteException;\n-\n-    \/**\n-     * Shutdown the activation system. Destroys all groups spawned by\n-     * the activation daemon and exits the activation daemon.\n-     * @throws RemoteException if failed to contact\/shutdown the activation\n-     * daemon\n-     * @since 1.2\n-     *\/\n-    public void shutdown() throws RemoteException;\n-\n-    \/**\n-     * Set the activation descriptor, <code>desc<\/code> for the object with\n-     * the activation identifier, <code>id<\/code>. The change will take\n-     * effect upon subsequent activation of the object.\n-     *\n-     * @param id the activation identifier for the activatable object\n-     * @param desc the activation descriptor for the activatable object\n-     * @throws UnknownGroupException the group associated with\n-     * <code>desc<\/code> is not a registered group\n-     * @throws UnknownObjectException the activation <code>id<\/code>\n-     * is not registered\n-     * @throws ActivationException for general failure (e.g., unable\n-     * to update log)\n-     * @throws RemoteException if remote call fails\n-     * @return the previous value of the activation descriptor\n-     * @see #getActivationDesc\n-     * @since 1.2\n-     *\/\n-    public ActivationDesc setActivationDesc(ActivationID id,\n-                                            ActivationDesc desc)\n-        throws ActivationException, UnknownObjectException,\n-            UnknownGroupException, RemoteException;\n-\n-    \/**\n-     * Set the activation group descriptor, <code>desc<\/code> for the object\n-     * with the activation group identifier, <code>id<\/code>. The change will\n-     * take effect upon subsequent activation of the group.\n-     *\n-     * @param id the activation group identifier for the activation group\n-     * @param desc the activation group descriptor for the activation group\n-     * @throws UnknownGroupException the group associated with\n-     * <code>id<\/code> is not a registered group\n-     * @throws ActivationException for general failure (e.g., unable\n-     * to update log)\n-     * @throws RemoteException if remote call fails\n-     * @return the previous value of the activation group descriptor\n-     * @see #getActivationGroupDesc\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupDesc setActivationGroupDesc(ActivationGroupID id,\n-                                                      ActivationGroupDesc desc)\n-       throws ActivationException, UnknownGroupException, RemoteException;\n-\n-    \/**\n-     * Returns the activation descriptor, for the object with the activation\n-     * identifier, <code>id<\/code>.\n-     *\n-     * @param id the activation identifier for the activatable object\n-     * @throws UnknownObjectException if <code>id<\/code> is not registered\n-     * @throws ActivationException for general failure\n-     * @throws RemoteException if remote call fails\n-     * @return the activation descriptor\n-     * @see #setActivationDesc\n-     * @since 1.2\n-     *\/\n-    public ActivationDesc getActivationDesc(ActivationID id)\n-       throws ActivationException, UnknownObjectException, RemoteException;\n-\n-    \/**\n-     * Returns the activation group descriptor, for the group\n-     * with the activation group identifier, <code>id<\/code>.\n-     *\n-     * @param id the activation group identifier for the group\n-     * @throws UnknownGroupException if <code>id<\/code> is not registered\n-     * @throws ActivationException for general failure\n-     * @throws RemoteException if remote call fails\n-     * @return the activation group descriptor\n-     * @see #setActivationGroupDesc\n-     * @since 1.2\n-     *\/\n-    public ActivationGroupDesc getActivationGroupDesc(ActivationGroupID id)\n-       throws ActivationException, UnknownGroupException, RemoteException;\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/ActivationSystem.java","additions":0,"deletions":234,"binary":false,"changes":234,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-import java.rmi.MarshalledObject;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.UnknownObjectException;\n-\n-\/**\n- * The <code>Activator<\/code> facilitates remote object activation. A\n- * \"faulting\" remote reference calls the activator's\n- * <code>activate<\/code> method to obtain a \"live\" reference to a\n- * \"activatable\" remote object. Upon receiving a request for activation,\n- * the activator looks up the activation descriptor for the activation\n- * identifier, <code>id<\/code>, determines the group in which the\n- * object should be activated initiates object re-creation via the\n- * group's <code>ActivationInstantiator<\/code> (via a call to the\n- * <code>newInstance<\/code> method). The activator initiates the\n- * execution of activation groups as necessary. For example, if an\n- * activation group for a specific group identifier is not already\n- * executing, the activator initiates the execution of a VM for the\n- * group. <p>\n- *\n- * The <code>Activator<\/code> works closely with\n- * <code>ActivationSystem<\/code>, which provides a means for registering\n- * groups and objects within those groups, and <code>ActivationMonitor<\/code>,\n- * which receives information about active and inactive objects and inactive\n- * groups. <p>\n- *\n- * The activator is responsible for monitoring and detecting when\n- * activation groups fail so that it can remove stale remote references\n- * to groups and active object's within those groups.\n- *\n- * @author      Ann Wollrath\n- * @see         ActivationInstantiator\n- * @see         ActivationGroupDesc\n- * @see         ActivationGroupID\n- * @since       1.2\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public interface Activator extends Remote {\n-    \/**\n-     * Activate the object associated with the activation identifier,\n-     * <code>id<\/code>. If the activator knows the object to be active\n-     * already, and <code>force<\/code> is false , the stub with a\n-     * \"live\" reference is returned immediately to the caller;\n-     * otherwise, if the activator does not know that corresponding\n-     * the remote object is active, the activator uses the activation\n-     * descriptor information (previously registered) to determine the\n-     * group (VM) in which the object should be activated. If an\n-     * <code>ActivationInstantiator<\/code> corresponding to the\n-     * object's group descriptor already exists, the activator invokes\n-     * the activation group's <code>newInstance<\/code> method passing\n-     * it the object's id and descriptor. <p>\n-     *\n-     * If the activation group for the object's group descriptor does\n-     * not yet exist, the activator starts an\n-     * <code>ActivationInstantiator<\/code> executing (by spawning a\n-     * child process, for example). When the activator receives the\n-     * activation group's call back (via the\n-     * <code>ActivationSystem<\/code>'s <code>activeGroup<\/code>\n-     * method) specifying the activation group's reference, the\n-     * activator can then invoke that activation instantiator's\n-     * <code>newInstance<\/code> method to forward each pending\n-     * activation request to the activation group and return the\n-     * result (a marshalled remote object reference, a stub) to the\n-     * caller.<p>\n-     *\n-     * Note that the activator receives a \"marshalled\" object instead of a\n-     * Remote object so that the activator does not need to load the\n-     * code for that object, or participate in distributed garbage\n-     * collection for that object. If the activator kept a strong\n-     * reference to the remote object, the activator would then\n-     * prevent the object from being garbage collected under the\n-     * normal distributed garbage collection mechanism.\n-     *\n-     * @param id the activation identifier for the object being activated\n-     * @param force if true, the activator contacts the group to obtain\n-     * the remote object's reference; if false, returning the cached value\n-     * is allowed.\n-     * @return the remote object (a stub) in a marshalled form\n-     * @throws ActivationException if object activation fails\n-     * @throws UnknownObjectException if object is unknown (not registered)\n-     * @throws RemoteException if remote call fails\n-     * @since 1.2\n-     *\/\n-    public MarshalledObject<? extends Remote> activate(ActivationID id,\n-                                                       boolean force)\n-        throws ActivationException, UnknownObjectException, RemoteException;\n-\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/Activator.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-\/**\n- * An <code>UnknownGroupException<\/code> is thrown by methods of classes and\n- * interfaces in the <code>java.rmi.activation<\/code> package when the\n- * <code>ActivationGroupID<\/code> parameter to the method is determined to be\n- * invalid, i.e., not known by the <code>ActivationSystem<\/code>.  An\n- * <code>UnknownGroupException<\/code> is also thrown if the\n- * <code>ActivationGroupID<\/code> in an <code>ActivationDesc<\/code> refers to\n- * a group that is not registered with the <code>ActivationSystem<\/code>\n- *\n- * @author     Ann Wollrath\n- * @since      1.2\n- * @see        java.rmi.activation.Activatable\n- * @see        java.rmi.activation.ActivationGroup\n- * @see        java.rmi.activation.ActivationGroupID\n- * @see        java.rmi.activation.ActivationMonitor\n- * @see        java.rmi.activation.ActivationSystem\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public class UnknownGroupException extends ActivationException {\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = 7056094974750002460L;\n-\n-    \/**\n-     * Constructs an <code>UnknownGroupException<\/code> with the specified\n-     * detail message.\n-     *\n-     * @param s the detail message\n-     * @since 1.2\n-     *\/\n-    public UnknownGroupException(String s) {\n-        super(s);\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/UnknownGroupException.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,67 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.rmi.activation;\n-\n-\/**\n- * An <code>UnknownObjectException<\/code> is thrown by methods of classes and\n- * interfaces in the <code>java.rmi.activation<\/code> package when the\n- * <code>ActivationID<\/code> parameter to the method is determined to be\n- * invalid.  An <code>ActivationID<\/code> is invalid if it is not currently\n- * known by the <code>ActivationSystem<\/code>.  An <code>ActivationID<\/code>\n- * is obtained by the <code>ActivationSystem.registerObject<\/code> method.\n- * An <code>ActivationID<\/code> is also obtained during the\n- * <code>Activatable.register<\/code> call.\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @see         java.rmi.activation.Activatable\n- * @see         java.rmi.activation.ActivationGroup\n- * @see         java.rmi.activation.ActivationID\n- * @see         java.rmi.activation.ActivationMonitor\n- * @see         java.rmi.activation.ActivationSystem\n- * @see         java.rmi.activation.Activator\n- * @deprecated\n- * See the <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n- *\/\n-@Deprecated(forRemoval=true, since=\"15\")\n-@SuppressWarnings(\"removal\")\n-public class UnknownObjectException extends ActivationException {\n-\n-    \/** indicate compatibility with the Java 2 SDK v1.2 version of class *\/\n-    private static final long serialVersionUID = 3425547551622251430L;\n-\n-    \/**\n-     * Constructs an <code>UnknownObjectException<\/code> with the specified\n-     * detail message.\n-     *\n-     * @param s the detail message\n-     * @since 1.2\n-     *\/\n-    public UnknownObjectException(String s) {\n-        super(s);\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/UnknownObjectException.java","additions":0,"deletions":67,"binary":false,"changes":67,"status":"deleted"},{"patch":"@@ -1,48 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * Provides support for RMI Object Activation.  A remote\n- * object's reference can be made ``persistent'' and later activated into a\n- * ``live'' object using the RMI activation mechanism.\n- *\n- * <p>Implementations are not required to support the activation\n- * mechanism. If activation is not supported by this implementation,\n- * several specific activation API methods are all required to throw\n- * {@code UnsupportedOperationException}. If activation is supported by this\n- * implementation, these methods must never throw {@code\n- * UnsupportedOperationException}. These methods are denoted by the\n- * presence of an entry for {@code UnsupportedOperationException} in the\n- * <strong>Throws<\/strong> section of each method's specification.\n- *\n- * @since 1.2\n- * @deprecated The RMI Activation mechanism has been deprecated and may\n- * be removed from a future version of the Java Platform. All of the classes\n- * and interfaces in this package have been terminally deprecated. The\n- * {@code rmid} tool has also been terminally deprecated. There is no\n- * replacement for the RMI Activation mechanism in the Java Platform. Users of\n- * RMI Activation are advised to migrate their applications to other technologies.\n- *\/\n-package java.rmi.activation;\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/activation\/package-info.java","additions":0,"deletions":48,"binary":false,"changes":48,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 1998, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n- * <code>java.rmi.server.UnicastRemoteObject<\/code> and\n- * <code>java.rmi.activation.Activatable<\/code>.\n+ * <code>java.rmi.server.UnicastRemoteObject<\/code>.\n@@ -38,1 +37,0 @@\n- * @see java.rmi.activation.Activatable\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/ExportException.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n- * of <code>java.rmi.server.UnicastRemoteObject<\/code> and\n- * <code>java.rmi.activation.Activatable<\/code> .\n+ * of <code>java.rmi.server.UnicastRemoteObject<\/code>.\n@@ -59,1 +58,0 @@\n- * @see     java.rmi.activation.Activatable\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RMIClientSocketFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,1 @@\n- * of <code>java.rmi.server.UnicastRemoteObject<\/code> and\n- * <code>java.rmi.activation.Activatable<\/code> .\n+ * of <code>java.rmi.server.UnicastRemoteObject<\/code>.\n@@ -58,1 +57,0 @@\n- * @see     java.rmi.activation.Activatable\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RMIServerSocketFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -215,6 +215,0 @@\n-     * that was returned from any of\n-     * the <code>java.rmi.activation.Activatable.exportObject<\/code> methods,\n-     * the external ref type name is <code>\"ActivatableRef\"<\/code>.\n-     *\n-     * If this object is an instance of\n-     * <code>RemoteStub<\/code> or <code>RemoteObjectInvocationHandler<\/code>\n@@ -321,37 +315,0 @@\n-     * <p>For <code>\"ActivatableRef\"<\/code> with a\n-     * <code>null<\/code> nested remote reference:\n-     *\n-     * <ul>\n-     *\n-     * <li>an instance of\n-     * <code>java.rmi.activation.ActivationID<\/code>,\n-     * written by passing it to an invocation of\n-     * <code>writeObject<\/code> on the stream instance\n-     *\n-     * <li>a zero-length string (<code>\"\"<\/code>),\n-     * written by {@link java.io.ObjectOutput#writeUTF(String)}\n-     *\n-     * <\/ul>\n-     *\n-     * <p>For <code>\"ActivatableRef\"<\/code> with a\n-     * non-<code>null<\/code> nested remote reference:\n-     *\n-     * <ul>\n-     *\n-     * <li>an instance of\n-     * <code>java.rmi.activation.ActivationID<\/code>,\n-     * written by passing it to an invocation of\n-     * <code>writeObject<\/code> on the stream instance\n-     *\n-     * <li>the external ref type name of the nested remote reference,\n-     * which must be <code>\"UnicastRef2\"<\/code>,\n-     * written by {@link java.io.ObjectOutput#writeUTF(String)}\n-     *\n-     * <li>the external form of the nested remote reference,\n-     * written by invoking its <code>writeExternal<\/code> method\n-     * with the stream instance\n-     * (see the description of the external form for\n-     * <code>\"UnicastRef2\"<\/code> above)\n-     *\n-     * <\/ul>\n-     *\n@@ -415,2 +372,2 @@\n-     * <code>\"UnicastRef2\"<\/code>, <code>\"UnicastServerRef2\"<\/code>,\n-     * or <code>\"ActivatableRef\"<\/code>, a corresponding\n+     * <code>\"UnicastRef2\"<\/code>, or <code>\"UnicastServerRef2\"<\/code>,\n+     * a corresponding\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RemoteObject.java","additions":3,"deletions":46,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.rmi.activation.Activatable;\n@@ -48,2 +47,1 @@\n- * or {@link Activatable} has an instance of this class as that proxy's\n- * invocation handler.\n+ * has an instance of this class as that proxy's invocation handler.\n","filename":"src\/java.rmi\/share\/classes\/java\/rmi\/server\/RemoteObjectInvocationHandler.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,7 +31,1 @@\n- * object registry, and the <em>{@index rmid rmid tool}<\/em> tool to start\n- * the activation system daemon.\n- *\n- * <p> <strong>Deprecation Notice:<\/strong> The RMI Activation mechanism has been\n- * deprecated and may be removed from a future version of the Java Platform. See the\n- * <a href=\"{@docRoot}\/java.rmi\/java\/rmi\/activation\/package-summary.html\">\n- * {@code java.rmi.activation}<\/a> package specification for further information.\n+ * object registry.\n@@ -40,1 +34,0 @@\n- * @toolGuide rmid\n@@ -51,1 +44,0 @@\n-    exports java.rmi.activation;\n@@ -57,3 +49,0 @@\n-    \/\/ com.sun.rmi.rmid contains permissions classes that must be\n-    \/\/ accessible to the security manager at initialization time\n-    exports com.sun.rmi.rmid to java.base;\n","filename":"src\/java.rmi\/share\/classes\/module-info.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -467,1 +467,0 @@\n-                    || java.rmi.activation.ActivationID.class.isAssignableFrom(clazz)\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/registry\/RegistryImpl.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,411 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.server;\n-\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectOutput;\n-import java.lang.reflect.Proxy;\n-import java.net.MalformedURLException;\n-import java.net.URL;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.Operation;\n-import java.rmi.server.RMIClassLoader;\n-import java.rmi.server.RemoteCall;\n-import java.rmi.server.RemoteObject;\n-import java.rmi.server.RemoteObjectInvocationHandler;\n-import java.rmi.server.RemoteRef;\n-import java.rmi.server.RemoteStub;\n-\n-@SuppressWarnings({\"deprecation\", \"removal\"})\n-public class ActivatableRef implements RemoteRef {\n-\n-    private static final long serialVersionUID = 7579060052569229166L;\n-\n-    protected ActivationID id;\n-    protected RemoteRef ref;\n-    transient boolean force = false;\n-\n-    private static final int MAX_RETRIES = 3;\n-    private static final String versionComplaint =\n-        \"activation requires 1.2 stubs\";\n-\n-    \/**\n-     * Create a new (empty) ActivatableRef\n-     *\/\n-    public ActivatableRef()\n-    {}\n-\n-    \/**\n-     * Create a ActivatableRef with the specified id\n-     *\/\n-    public ActivatableRef(ActivationID id, RemoteRef ref)\n-    {\n-        this.id = id;\n-        this.ref = ref;\n-    }\n-\n-    \/**\n-     * Returns the stub for the remote object whose class is\n-     * specified in the activation descriptor. The ActivatableRef\n-     * in the resulting stub has its activation id set to the\n-     * activation id supplied as the second argument.\n-     *\/\n-    public static Remote getStub(ActivationDesc desc, ActivationID id)\n-        throws StubNotFoundException\n-    {\n-        String className = desc.getClassName();\n-\n-        try {\n-            Class<?> cl =\n-                RMIClassLoader.loadClass(desc.getLocation(), className);\n-            RemoteRef clientRef = new ActivatableRef(id, null);\n-            return Util.createProxy(cl, clientRef, false);\n-\n-        } catch (IllegalArgumentException e) {\n-            throw new StubNotFoundException(\n-                \"class implements an illegal remote interface\", e);\n-\n-        } catch (ClassNotFoundException e) {\n-            throw new StubNotFoundException(\"unable to load class: \" +\n-                                            className, e);\n-        } catch (MalformedURLException e) {\n-            throw new StubNotFoundException(\"malformed URL\", e);\n-        }\n-    }\n-\n-    \/**\n-     * Invoke method on remote object. This method delegates remote\n-     * method invocation to the underlying ref type.  If the\n-     * underlying reference is not known (is null), then the object\n-     * must be activated first.  If an attempt at method invocation\n-     * fails, the object should force reactivation.  Method invocation\n-     * must preserve \"at most once\" call semantics.  In RMI, \"at most\n-     * once\" applies to parameter deserialization at the remote site\n-     * and the remote object's method execution.  \"At most once\" does\n-     * not apply to parameter serialization at the client so the\n-     * parameters of a call don't need to be buffered in anticipation\n-     * of call retry. Thus, a method call is only be retried if the\n-     * initial method invocation does not execute at all at the server\n-     * (including parameter deserialization).\n-     *\/\n-    public Object invoke(Remote obj,\n-                         java.lang.reflect.Method method,\n-                         Object[] params,\n-                         long opnum)\n-        throws Exception\n-    {\n-\n-        boolean force = false;\n-        RemoteRef localRef;\n-        Exception exception = null;\n-\n-        \/*\n-         * Attempt object activation if active ref is unknown.\n-         * Throws a RemoteException if object can't be activated.\n-         *\/\n-        synchronized (this) {\n-            if (ref == null) {\n-                localRef = activate(force);\n-                force = true;\n-            } else {\n-                localRef = ref;\n-            }\n-        }\n-\n-        for (int retries = MAX_RETRIES; retries > 0; retries--) {\n-\n-            try {\n-                return localRef.invoke(obj, method, params, opnum);\n-            } catch (NoSuchObjectException e) {\n-                \/*\n-                 * Object is not active in VM; retry call\n-                 *\/\n-                exception = e;\n-            } catch (ConnectException e) {\n-                \/*\n-                 * Failure during connection setup; retry call\n-                 *\/\n-                exception = e;\n-            } catch (UnknownHostException e) {\n-                \/*\n-                 * Failure during connection setup; retry call.\n-                 *\/\n-                exception = e;\n-            } catch (ConnectIOException e) {\n-                \/*\n-                 * Failure reusing cached connection; retry call\n-                 *\/\n-                exception = e;\n-            } catch (MarshalException e) {\n-                \/*\n-                 * Failure during parameter serialization; call may\n-                 * have reached server, so call retry not possible.\n-                 *\/\n-                throw e;\n-            } catch (ServerError e) {\n-                \/*\n-                 * Call reached server; propagate remote exception.\n-                 *\/\n-                throw e;\n-            } catch (ServerException e) {\n-                \/*\n-                 * Call reached server; propagate remote exception\n-                 *\/\n-                throw e;\n-            } catch (RemoteException e) {\n-                \/*\n-                 * This is a catch-all for other RemoteExceptions.\n-                 * UnmarshalException being the only one relevant.\n-                 *\n-                 * StubNotFoundException should never show up because\n-                 * it is generally thrown when attempting to locate\n-                 * a stub.\n-                 *\n-                 * UnexpectedException should never show up because\n-                 * it is only thrown by a stub and would be wrapped\n-                 * in a ServerException if it was propagated by a\n-                 * remote call.\n-                 *\/\n-                synchronized (this) {\n-                    if (localRef == ref) {\n-                        ref = null;     \/\/ this may be overly conservative\n-                    }\n-                }\n-\n-                throw e;\n-            }\n-\n-            if (retries > 1) {\n-                \/*\n-                 * Activate object, since object could not be reached.\n-                 *\/\n-                synchronized (this) {\n-                    if (localRef.remoteEquals(ref) || ref == null) {\n-                        RemoteRef newRef = activate(force);\n-\n-                        if (newRef.remoteEquals(localRef) &&\n-                            exception instanceof NoSuchObjectException &&\n-                            force == false) {\n-                            \/*\n-                             * If last exception was NoSuchObjectException,\n-                             * then old value of ref is definitely wrong,\n-                             * so make sure that it is different.\n-                             *\/\n-                            newRef = activate(true);\n-                        }\n-\n-                        localRef = newRef;\n-                        force = true;\n-                    } else {\n-                        localRef = ref;\n-                        force = false;\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Retries unsuccessful, so throw last exception\n-         *\/\n-        throw exception;\n-    }\n-\n-    \/**\n-     * private method to obtain the ref for a call.\n-     *\/\n-    private synchronized RemoteRef getRef()\n-        throws RemoteException\n-    {\n-        if (ref == null) {\n-            ref = activate(false);\n-        }\n-\n-        return ref;\n-    }\n-\n-    \/**\n-     * private method to activate the remote object.\n-     *\n-     * NOTE: the caller must be synchronized on \"this\" before\n-     * calling this method.\n-     *\/\n-    private RemoteRef activate(boolean force)\n-        throws RemoteException\n-    {\n-        assert Thread.holdsLock(this);\n-\n-        ref = null;\n-        try {\n-            \/*\n-             * Activate the object and retrieve the remote reference\n-             * from inside the stub returned as the result. Then\n-             * set this activatable ref's internal ref to be the\n-             * ref inside the ref of the stub. In more clear terms,\n-             * the stub returned from the activate call contains an\n-             * ActivatableRef. We need to set the ref in *this*\n-             * ActivatableRef to the ref inside the ActivatableRef\n-             * retrieved from the stub. The ref type embedded in the\n-             * ActivatableRef is typically a UnicastRef.\n-             *\/\n-\n-            Remote proxy = id.activate(force);\n-            ActivatableRef newRef = null;\n-\n-            if (proxy instanceof RemoteStub) {\n-                newRef = (ActivatableRef) ((RemoteStub) proxy).getRef();\n-            } else {\n-                \/*\n-                 * Assume that proxy is an instance of a dynamic proxy\n-                 * class.  If that assumption is not correct, or either of\n-                 * the casts below fails, the resulting exception will be\n-                 * wrapped in an ActivateFailedException below.\n-                 *\/\n-                RemoteObjectInvocationHandler handler =\n-                    (RemoteObjectInvocationHandler)\n-                    Proxy.getInvocationHandler(proxy);\n-                newRef = (ActivatableRef) handler.getRef();\n-            }\n-            ref = newRef.ref;\n-            return ref;\n-\n-        } catch (ConnectException e) {\n-            throw new ConnectException(\"activation failed\", e);\n-        } catch (RemoteException e) {\n-            throw new ConnectIOException(\"activation failed\", e);\n-        } catch (UnknownObjectException e) {\n-            throw new NoSuchObjectException(\"object not registered\");\n-        } catch (ActivationException e) {\n-            throw new ActivateFailedException(\"activation failed\", e);\n-        }\n-    }\n-\n-    \/**\n-     * This call is used by the old 1.1 stub protocol and is\n-     * unsupported since activation requires 1.2 stubs.\n-     *\/\n-    public synchronized RemoteCall newCall(RemoteObject obj,\n-                                           Operation[] ops,\n-                                           int opnum,\n-                                           long hash)\n-        throws RemoteException\n-    {\n-        throw new UnsupportedOperationException(versionComplaint);\n-    }\n-\n-    \/**\n-     * This call is used by the old 1.1 stub protocol and is\n-     * unsupported since activation requires 1.2 stubs.\n-     *\/\n-    public void invoke(RemoteCall call) throws Exception\n-    {\n-        throw new UnsupportedOperationException(versionComplaint);\n-    }\n-\n-    \/**\n-     * This call is used by the old 1.1 stub protocol and is\n-     * unsupported since activation requires 1.2 stubs.\n-     *\/\n-    public void done(RemoteCall call) throws RemoteException {\n-        throw new UnsupportedOperationException(versionComplaint);\n-    }\n-\n-    \/**\n-     * Returns the class of the ref type to be serialized\n-     *\/\n-    public String getRefClass(ObjectOutput out)\n-    {\n-        return \"ActivatableRef\";\n-    }\n-\n-    \/**\n-     * Write out external representation for remote ref.\n-     *\/\n-    public void writeExternal(ObjectOutput out) throws IOException\n-    {\n-        RemoteRef localRef = ref;\n-\n-        out.writeObject(id);\n-        if (localRef == null) {\n-            out.writeUTF(\"\");\n-        } else {\n-            out.writeUTF(localRef.getRefClass(out));\n-            localRef.writeExternal(out);\n-        }\n-    }\n-\n-    \/**\n-     * Read in external representation for remote ref.\n-     * @exception ClassNotFoundException If the class for an object\n-     * being restored cannot be found.\n-     *\/\n-    public void readExternal(ObjectInput in)\n-        throws IOException, ClassNotFoundException\n-    {\n-        id = (ActivationID)in.readObject();\n-        ref = null;\n-        String className = in.readUTF();\n-\n-        if (className.isEmpty()) return;\n-\n-        try {\n-            Class<?> refClass = Class.forName(RemoteRef.packagePrefix + \".\" +\n-                                              className);\n-            ref = (RemoteRef)refClass.newInstance();\n-            ref.readExternal(in);\n-        } catch (InstantiationException e) {\n-            throw new UnmarshalException(\"Unable to create remote reference\",\n-                                         e);\n-        } catch (IllegalAccessException e) {\n-            throw new UnmarshalException(\"Illegal access creating remote reference\");\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------------;\n-    \/**\n-     * Method from object, forward from RemoteObject\n-     *\/\n-    public String remoteToString() {\n-        return Util.getUnqualifiedName(getClass()) +\n-                \" [remoteRef: \" + ref + \"]\";\n-    }\n-\n-    \/**\n-     * default implementation of hashCode for remote objects\n-     *\/\n-    public int remoteHashCode() {\n-        return id.hashCode();\n-    }\n-\n-    \/** default implementation of equals for remote objects\n-     *\/\n-    public boolean remoteEquals(RemoteRef ref) {\n-        if (ref instanceof ActivatableRef)\n-            return id.equals(((ActivatableRef)ref).id);\n-        return false;\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/ActivatableRef.java","additions":0,"deletions":411,"binary":false,"changes":411,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.server;\n-\n-import java.io.IOException;\n-import java.io.NotSerializableException;\n-import java.io.ObjectOutput;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.ActivationID;\n-import sun.rmi.transport.LiveRef;\n-\n-\/**\n- * Server-side ref for a persistent remote impl.\n- *\n- * @author Ann Wollrath\n- *\/\n-@SuppressWarnings({\"removal\", \"serial\"}) \/\/ Externalizable class w\/o no-arg c'tor\n-public class ActivatableServerRef extends UnicastServerRef2 {\n-\n-    private static final long serialVersionUID = 2002967993223003793L;\n-\n-    private ActivationID id;\n-\n-    \/**\n-     * Construct a Unicast server remote reference to be exported\n-     * on the specified port.\n-     *\/\n-    public ActivatableServerRef(ActivationID id, int port)\n-    {\n-        this(id, port, null, null);\n-    }\n-\n-    \/**\n-     * Construct a Unicast server remote reference to be exported\n-     * on the specified port.\n-     *\/\n-    public ActivatableServerRef(ActivationID id, int port,\n-                                RMIClientSocketFactory csf,\n-                                RMIServerSocketFactory ssf)\n-    {\n-        super(new LiveRef(port, csf, ssf));\n-        this.id = id;\n-    }\n-\n-    \/**\n-     * Returns the class of the ref type to be serialized\n-     *\/\n-    public String getRefClass(ObjectOutput out)\n-    {\n-        return \"ActivatableServerRef\";\n-    }\n-\n-    \/**\n-     * Return the client remote reference for this remoteRef.\n-     * In the case of a client RemoteRef \"this\" is the answer.\n-     * For  a server remote reference, a client side one will have to\n-     * found or created.\n-     *\/\n-    protected RemoteRef getClientRef() {\n-        return new ActivatableRef(id, new UnicastRef2(ref));\n-    }\n-\n-    \/**\n-     * Prevents serialization (because deserializaion is impossible).\n-     *\/\n-    public void writeExternal(ObjectOutput out) throws IOException {\n-        throw new NotSerializableException(\n-            \"ActivatableServerRef not serializable\");\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/ActivatableServerRef.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,239 +0,0 @@\n-\/*\n-* Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n-* DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-*\n-* This code is free software; you can redistribute it and\/or modify it\n-* under the terms of the GNU General Public License version 2 only, as\n-* published by the Free Software Foundation.  Oracle designates this\n-* particular file as subject to the \"Classpath\" exception as provided\n-* by Oracle in the LICENSE file that accompanied this code.\n-*\n-* This code is distributed in the hope that it will be useful, but WITHOUT\n-* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-* FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-* version 2 for more details (a copy is included in the LICENSE file that\n-* accompanied this code).\n-*\n-* You should have received a copy of the GNU General Public License version\n-* 2 along with this work; if not, write to the Free Software Foundation,\n-* Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-*\n-* Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-* or visit www.oracle.com if you need additional information or have any\n-* questions.\n-*\/\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-package sun.rmi.server;\n-\n-\/**\n- * Activation$ActivationSystemImpl_Stub.\n- *\/\n-@SuppressWarnings({\"deprecation\", \"rawtypes\", \"removal\", \"unchecked\"})\n-public final class Activation$ActivationSystemImpl_Stub\n-        extends java.rmi.server.RemoteStub\n-        implements java.rmi.activation.ActivationSystem, java.rmi.Remote {\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_activeGroup_0;\n-    private static java.lang.reflect.Method $method_getActivationDesc_1;\n-    private static java.lang.reflect.Method $method_getActivationGroupDesc_2;\n-    private static java.lang.reflect.Method $method_registerGroup_3;\n-    private static java.lang.reflect.Method $method_registerObject_4;\n-    private static java.lang.reflect.Method $method_setActivationDesc_5;\n-    private static java.lang.reflect.Method $method_setActivationGroupDesc_6;\n-    private static java.lang.reflect.Method $method_shutdown_7;\n-    private static java.lang.reflect.Method $method_unregisterGroup_8;\n-    private static java.lang.reflect.Method $method_unregisterObject_9;\n-\n-    static {\n-        try {\n-            $method_activeGroup_0 = java.rmi.activation.ActivationSystem.class.getMethod(\"activeGroup\", new java.lang.Class[]{java.rmi.activation.ActivationGroupID.class, java.rmi.activation.ActivationInstantiator.class, long.class});\n-            $method_getActivationDesc_1 = java.rmi.activation.ActivationSystem.class.getMethod(\"getActivationDesc\", new java.lang.Class[]{java.rmi.activation.ActivationID.class});\n-            $method_getActivationGroupDesc_2 = java.rmi.activation.ActivationSystem.class.getMethod(\"getActivationGroupDesc\", new java.lang.Class[]{java.rmi.activation.ActivationGroupID.class});\n-            $method_registerGroup_3 = java.rmi.activation.ActivationSystem.class.getMethod(\"registerGroup\", new java.lang.Class[]{java.rmi.activation.ActivationGroupDesc.class});\n-            $method_registerObject_4 = java.rmi.activation.ActivationSystem.class.getMethod(\"registerObject\", new java.lang.Class[]{java.rmi.activation.ActivationDesc.class});\n-            $method_setActivationDesc_5 = java.rmi.activation.ActivationSystem.class.getMethod(\"setActivationDesc\", new java.lang.Class[]{java.rmi.activation.ActivationID.class, java.rmi.activation.ActivationDesc.class});\n-            $method_setActivationGroupDesc_6 = java.rmi.activation.ActivationSystem.class.getMethod(\"setActivationGroupDesc\", new java.lang.Class[]{java.rmi.activation.ActivationGroupID.class, java.rmi.activation.ActivationGroupDesc.class});\n-            $method_shutdown_7 = java.rmi.activation.ActivationSystem.class.getMethod(\"shutdown\", new java.lang.Class[]{});\n-            $method_unregisterGroup_8 = java.rmi.activation.ActivationSystem.class.getMethod(\"unregisterGroup\", new java.lang.Class[]{java.rmi.activation.ActivationGroupID.class});\n-            $method_unregisterObject_9 = java.rmi.activation.ActivationSystem.class.getMethod(\"unregisterObject\", new java.lang.Class[]{java.rmi.activation.ActivationID.class});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                    \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public Activation$ActivationSystemImpl_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of activeGroup(ActivationGroupID, ActivationInstantiator, long)\n-    public java.rmi.activation.ActivationMonitor activeGroup(java.rmi.activation.ActivationGroupID $param_ActivationGroupID_1, java.rmi.activation.ActivationInstantiator $param_ActivationInstantiator_2, long $param_long_3)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownGroupException {\n-        try {\n-            Object $result = ref.invoke(this, $method_activeGroup_0, new java.lang.Object[]{$param_ActivationGroupID_1, $param_ActivationInstantiator_2, new java.lang.Long($param_long_3)}, -4575843150759415294L);\n-            return ((java.rmi.activation.ActivationMonitor) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of getActivationDesc(ActivationID)\n-    public java.rmi.activation.ActivationDesc getActivationDesc(java.rmi.activation.ActivationID $param_ActivationID_1)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownObjectException {\n-        try {\n-            Object $result = ref.invoke(this, $method_getActivationDesc_1, new java.lang.Object[]{$param_ActivationID_1}, 4830055440982622087L);\n-            return ((java.rmi.activation.ActivationDesc) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of getActivationGroupDesc(ActivationGroupID)\n-    public java.rmi.activation.ActivationGroupDesc getActivationGroupDesc(java.rmi.activation.ActivationGroupID $param_ActivationGroupID_1)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownGroupException {\n-        try {\n-            Object $result = ref.invoke(this, $method_getActivationGroupDesc_2, new java.lang.Object[]{$param_ActivationGroupID_1}, -8701843806548736528L);\n-            return ((java.rmi.activation.ActivationGroupDesc) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of registerGroup(ActivationGroupDesc)\n-    public java.rmi.activation.ActivationGroupID registerGroup(java.rmi.activation.ActivationGroupDesc $param_ActivationGroupDesc_1)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException {\n-        try {\n-            Object $result = ref.invoke(this, $method_registerGroup_3, new java.lang.Object[]{$param_ActivationGroupDesc_1}, 6921515268192657754L);\n-            return ((java.rmi.activation.ActivationGroupID) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of registerObject(ActivationDesc)\n-    public java.rmi.activation.ActivationID registerObject(java.rmi.activation.ActivationDesc $param_ActivationDesc_1)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownGroupException {\n-        try {\n-            Object $result = ref.invoke(this, $method_registerObject_4, new java.lang.Object[]{$param_ActivationDesc_1}, -3006759798994351347L);\n-            return ((java.rmi.activation.ActivationID) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of setActivationDesc(ActivationID, ActivationDesc)\n-    public java.rmi.activation.ActivationDesc setActivationDesc(java.rmi.activation.ActivationID $param_ActivationID_1, java.rmi.activation.ActivationDesc $param_ActivationDesc_2)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownGroupException, java.rmi.activation.UnknownObjectException {\n-        try {\n-            Object $result = ref.invoke(this, $method_setActivationDesc_5, new java.lang.Object[]{$param_ActivationID_1, $param_ActivationDesc_2}, 7128043237057180796L);\n-            return ((java.rmi.activation.ActivationDesc) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of setActivationGroupDesc(ActivationGroupID, ActivationGroupDesc)\n-    public java.rmi.activation.ActivationGroupDesc setActivationGroupDesc(java.rmi.activation.ActivationGroupID $param_ActivationGroupID_1, java.rmi.activation.ActivationGroupDesc $param_ActivationGroupDesc_2)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownGroupException {\n-        try {\n-            Object $result = ref.invoke(this, $method_setActivationGroupDesc_6, new java.lang.Object[]{$param_ActivationGroupID_1, $param_ActivationGroupDesc_2}, 1213918527826541191L);\n-            return ((java.rmi.activation.ActivationGroupDesc) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-            throws java.rmi.RemoteException {\n-        try {\n-            ref.invoke(this, $method_shutdown_7, null, -7207851917985848402L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of unregisterGroup(ActivationGroupID)\n-    public void unregisterGroup(java.rmi.activation.ActivationGroupID $param_ActivationGroupID_1)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownGroupException {\n-        try {\n-            ref.invoke(this, $method_unregisterGroup_8, new java.lang.Object[]{$param_ActivationGroupID_1}, 3768097077835970701L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of unregisterObject(ActivationID)\n-    public void unregisterObject(java.rmi.activation.ActivationID $param_ActivationID_1)\n-            throws java.rmi.RemoteException, java.rmi.activation.ActivationException, java.rmi.activation.UnknownObjectException {\n-        try {\n-            ref.invoke(this, $method_unregisterObject_9, new java.lang.Object[]{$param_ActivationID_1}, -6843850585331411084L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.rmi.activation.ActivationException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/Activation$ActivationSystemImpl_Stub.java","additions":0,"deletions":239,"binary":false,"changes":239,"status":"deleted"},{"patch":"@@ -1,2605 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.server;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.File;\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.ObjectInput;\n-import java.io.ObjectInputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.io.Serializable;\n-import java.lang.Process;\n-import java.lang.reflect.InvocationTargetException;\n-import java.lang.reflect.Method;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.SocketAddress;\n-import java.net.SocketException;\n-import java.nio.file.Files;\n-import java.nio.channels.Channel;\n-import java.nio.channels.ServerSocketChannel;\n-import java.rmi.AccessException;\n-import java.rmi.AlreadyBoundException;\n-import java.rmi.ConnectException;\n-import java.rmi.ConnectIOException;\n-import java.rmi.MarshalledObject;\n-import java.rmi.NoSuchObjectException;\n-import java.rmi.NotBoundException;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.ActivationDesc;\n-import java.rmi.activation.ActivationException;\n-import java.rmi.activation.ActivationGroupDesc;\n-import java.rmi.activation.ActivationGroup;\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.activation.ActivationInstantiator;\n-import java.rmi.activation.ActivationMonitor;\n-import java.rmi.activation.ActivationSystem;\n-import java.rmi.activation.Activator;\n-import java.rmi.activation.UnknownGroupException;\n-import java.rmi.activation.UnknownObjectException;\n-import java.rmi.registry.Registry;\n-import java.rmi.server.ObjID;\n-import java.rmi.server.RMIClassLoader;\n-import java.rmi.server.RMIClientSocketFactory;\n-import java.rmi.server.RMIServerSocketFactory;\n-import java.rmi.server.RemoteObject;\n-import java.rmi.server.RemoteServer;\n-import java.rmi.server.UnicastRemoteObject;\n-import java.security.AccessControlException;\n-import java.security.AccessController;\n-import java.security.AllPermission;\n-import java.security.CodeSource;\n-import java.security.Permission;\n-import java.security.PermissionCollection;\n-import java.security.Permissions;\n-import java.security.Policy;\n-import java.security.PrivilegedAction;\n-import java.security.PrivilegedExceptionAction;\n-import java.security.cert.Certificate;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Date;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.MissingResourceException;\n-import java.util.Properties;\n-import java.util.ResourceBundle;\n-import java.util.Set;\n-import java.util.concurrent.ConcurrentHashMap;\n-import sun.rmi.log.LogHandler;\n-import sun.rmi.log.ReliableLog;\n-import sun.rmi.registry.RegistryImpl;\n-import sun.rmi.runtime.NewThreadAction;\n-import sun.rmi.transport.LiveRef;\n-import sun.security.provider.PolicyFile;\n-import com.sun.rmi.rmid.ExecPermission;\n-import com.sun.rmi.rmid.ExecOptionPermission;\n-\n-\/**\n- * The Activator facilitates remote object activation. A \"faulting\"\n- * remote reference calls the activator's <code>activate<\/code> method\n- * to obtain a \"live\" reference to a activatable remote object. Upon\n- * receiving a request for activation, the activator looks up the\n- * activation descriptor for the activation identifier, id, determines\n- * the group in which the object should be activated and invokes the\n- * activate method on the object's activation group (described by the\n- * remote interface <code>ActivationInstantiator<\/code>). The\n- * activator initiates the execution of activation groups as\n- * necessary. For example, if an activation group for a specific group\n- * identifier is not already executing, the activator will spawn a\n- * child process for the activation group. <p>\n- *\n- * The activator is responsible for monitoring and detecting when\n- * activation groups fail so that it can remove stale remote references\n- * from its internal tables. <p>\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- *\/\n-@SuppressWarnings(\"removal\")\n-public class Activation implements Serializable {\n-\n-    \/** indicate compatibility with JDK 1.2 version of class *\/\n-    private static final long serialVersionUID = 2921265612698155191L;\n-    private static final byte MAJOR_VERSION = 1;\n-    private static final byte MINOR_VERSION = 0;\n-\n-    \/** exec policy object *\/\n-    private static Object execPolicy;\n-    private static Method execPolicyMethod;\n-    private static boolean debugExec;\n-\n-    \/** maps activation id to its respective group id *\/\n-    @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-    private Map<ActivationID,ActivationGroupID> idTable =\n-        new ConcurrentHashMap<>();\n-    \/** maps group id to its GroupEntry groups *\/\n-    @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-    private Map<ActivationGroupID,GroupEntry> groupTable =\n-        new ConcurrentHashMap<>();\n-\n-    private byte majorVersion = MAJOR_VERSION;\n-    private byte minorVersion = MINOR_VERSION;\n-\n-    \/** number of simultaneous group exec's *\/\n-    private transient int groupSemaphore;\n-    \/** counter for numbering groups *\/\n-    private transient int groupCounter;\n-    \/** reliable log to hold descriptor table *\/\n-    private transient ReliableLog log;\n-    \/** number of updates since last snapshot *\/\n-    private transient int numUpdates;\n-\n-    \/** the java command *\/\n-    \/\/ accessed by GroupEntry\n-    private transient String[] command;\n-    \/** timeout on wait for child process to be created or destroyed *\/\n-    private static final long groupTimeout =\n-        getInt(\"sun.rmi.activation.groupTimeout\", 60000);\n-    \/** take snapshot after this many updates *\/\n-    private static final int snapshotInterval =\n-        getInt(\"sun.rmi.activation.snapshotInterval\", 200);\n-    \/** timeout on wait for child process to be created *\/\n-    private static final long execTimeout =\n-        getInt(\"sun.rmi.activation.execTimeout\", 30000);\n-\n-    private static final Object initLock = new Object();\n-    private static boolean initDone = false;\n-\n-    \/\/ this should be a *private* method since it is privileged\n-    private static int getInt(String name, int def) {\n-        return AccessController.doPrivileged(\n-                (PrivilegedAction<Integer>) () -> Integer.getInteger(name, def));\n-    }\n-\n-    private transient Activator activator;\n-    private transient Activator activatorStub;\n-    private transient ActivationSystem system;\n-    private transient ActivationSystem systemStub;\n-    private transient ActivationMonitor monitor;\n-    private transient Registry registry;\n-    private transient volatile boolean shuttingDown = false;\n-    private transient volatile Object startupLock;\n-    private transient Thread shutdownHook;\n-\n-    private static ResourceBundle resources = null;\n-\n-    \/**\n-     * Create an uninitialized instance of Activation that can be\n-     * populated with log data.  This is only called when the initial\n-     * snapshot is taken during the first incarnation of rmid.\n-     *\/\n-    private Activation() {}\n-\n-    \/**\n-     * Recover activation state from the reliable log and initialize\n-     * activation services.\n-     *\/\n-    private static void startActivation(int port,\n-                                        RMIServerSocketFactory ssf,\n-                                        String logName,\n-                                        String[] childArgs)\n-        throws Exception\n-    {\n-        ReliableLog log = new ReliableLog(logName, new ActLogHandler());\n-        Activation state = (Activation) log.recover();\n-        state.init(port, ssf, log, childArgs);\n-    }\n-\n-    \/**\n-     * Initialize the Activation instantiation; start activation\n-     * services.\n-     *\/\n-    private void init(int port,\n-                      RMIServerSocketFactory ssf,\n-                      ReliableLog log,\n-                      String[] childArgs)\n-        throws Exception\n-    {\n-        \/\/ initialize\n-        this.log = log;\n-        numUpdates = 0;\n-        shutdownHook =  new ShutdownHook();\n-        groupSemaphore = getInt(\"sun.rmi.activation.groupThrottle\", 3);\n-        groupCounter = 0;\n-        Runtime.getRuntime().addShutdownHook(shutdownHook);\n-\n-        \/\/ Use array size of 0, since the value from calling size()\n-        \/\/ may be out of date by the time toArray() is called.\n-        ActivationGroupID[] gids =\n-            groupTable.keySet().toArray(new ActivationGroupID[0]);\n-\n-        synchronized (startupLock = new Object()) {\n-            \/\/ all the remote methods briefly synchronize on startupLock\n-            \/\/ (via checkShutdown) to make sure they don't happen in the\n-            \/\/ middle of this block.  This block must not cause any such\n-            \/\/ incoming remote calls to happen, or deadlock would result!\n-            activator = new ActivatorImpl(port, ssf);\n-            activatorStub = (Activator) RemoteObject.toStub(activator);\n-            system = new ActivationSystemImpl(port, ssf);\n-            systemStub = (ActivationSystem) RemoteObject.toStub(system);\n-            monitor = new ActivationMonitorImpl(port, ssf);\n-            initCommand(childArgs);\n-            registry = new SystemRegistryImpl(port, null, ssf, systemStub);\n-\n-            if (ssf != null) {\n-                synchronized (initLock) {\n-                    initDone = true;\n-                    initLock.notifyAll();\n-                }\n-            }\n-        }\n-        startupLock = null;\n-\n-        \/\/ restart services\n-        for (int i = gids.length; --i >= 0; ) {\n-            try {\n-                getGroupEntry(gids[i]).restartServices();\n-            } catch (UnknownGroupException e) {\n-                System.err.println(\n-                    getTextResource(\"rmid.restart.group.warning\"));\n-                e.printStackTrace();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Previous versions used HashMap instead of ConcurrentHashMap.\n-     * Replace any HashMaps found during deserialization with\n-     * ConcurrentHashMaps.\n-     *\/\n-    private void readObject(ObjectInputStream ois)\n-        throws IOException, ClassNotFoundException\n-    {\n-        ois.defaultReadObject();\n-        if (! (groupTable instanceof ConcurrentHashMap)) {\n-            groupTable = new ConcurrentHashMap<>(groupTable);\n-        }\n-        if (! (idTable instanceof ConcurrentHashMap)) {\n-            idTable = new ConcurrentHashMap<>(idTable);\n-        }\n-    }\n-\n-    private static class SystemRegistryImpl extends RegistryImpl {\n-\n-        private static final String NAME = ActivationSystem.class.getName();\n-        private static final long serialVersionUID = 4877330021609408794L;\n-        @SuppressWarnings(\"serial\") \/\/ Not statically typed as Serializable\n-        private ActivationSystem systemStub = null;\n-\n-        SystemRegistryImpl(int port,\n-                           RMIClientSocketFactory csf,\n-                           RMIServerSocketFactory ssf,\n-                           ActivationSystem systemStub)\n-            throws RemoteException\n-        {\n-            super(port, csf, ssf);\n-            assert systemStub != null;\n-            synchronized (this) {\n-                this.systemStub = systemStub;\n-                notifyAll();\n-            }\n-        }\n-\n-        \/**\n-         * Waits for systemStub to be initialized and returns its\n-         * initialized value. Any remote call that uses systemStub must\n-         * call this method to get it instead of using direct field\n-         * access. This is necessary because the super() call in the\n-         * constructor exports this object before systemStub is initialized\n-         * (see JDK-8023541), allowing remote calls to come in during this\n-         * time. We can't use checkShutdown() like other nested classes\n-         * because this is a static class.\n-         *\/\n-        private synchronized ActivationSystem getSystemStub() {\n-            boolean interrupted = false;\n-\n-            while (systemStub == null) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ie) {\n-                    interrupted = true;\n-                }\n-            }\n-\n-            if (interrupted) {\n-                Thread.currentThread().interrupt();\n-            }\n-\n-            return systemStub;\n-        }\n-\n-        \/**\n-         * Returns the activation system stub if the specified name\n-         * matches the activation system's class name, otherwise\n-         * returns the result of invoking super.lookup with the specified\n-         * name.\n-         *\/\n-        public Remote lookup(String name)\n-            throws RemoteException, NotBoundException\n-        {\n-            if (name.equals(NAME)) {\n-                return getSystemStub();\n-            } else {\n-                return super.lookup(name);\n-            }\n-        }\n-\n-        public String[] list() throws RemoteException {\n-            String[] list1 = super.list();\n-            int length = list1.length;\n-            String[] list2 = new String[length + 1];\n-            if (length > 0) {\n-                System.arraycopy(list1, 0, list2, 0, length);\n-            }\n-            list2[length] = NAME;\n-            return list2;\n-        }\n-\n-        public void bind(String name, Remote obj)\n-            throws RemoteException, AlreadyBoundException, AccessException\n-        {\n-            if (name.equals(NAME)) {\n-                throw new AccessException(\n-                    \"binding ActivationSystem is disallowed\");\n-            } else {\n-                RegistryImpl.checkAccess(\"ActivationSystem.bind\");\n-                super.bind(name, obj);\n-            }\n-        }\n-\n-        public void unbind(String name)\n-            throws RemoteException, NotBoundException, AccessException\n-        {\n-            if (name.equals(NAME)) {\n-                throw new AccessException(\n-                    \"unbinding ActivationSystem is disallowed\");\n-            } else {\n-                RegistryImpl.checkAccess(\"ActivationSystem.unbind\");\n-                super.unbind(name);\n-            }\n-        }\n-\n-\n-        public void rebind(String name, Remote obj)\n-            throws RemoteException, AccessException\n-        {\n-            if (name.equals(NAME)) {\n-                throw new AccessException(\n-                    \"binding ActivationSystem is disallowed\");\n-            } else {\n-                RegistryImpl.checkAccess(\"ActivationSystem.rebind\");\n-                super.rebind(name, obj);\n-            }\n-        }\n-    }\n-\n-\n-    class ActivatorImpl extends RemoteServer implements Activator {\n-        \/\/ Because ActivatorImpl has a fixed ObjID, it can be\n-        \/\/ called by clients holding stale remote references.  Each of\n-        \/\/ its remote methods, then, must check startupLock (calling\n-        \/\/ checkShutdown() is easiest).\n-\n-        private static final long serialVersionUID = -3654244726254566136L;\n-\n-        \/**\n-         * Construct a new Activator on a specified port.\n-         *\/\n-        ActivatorImpl(int port, RMIServerSocketFactory ssf)\n-            throws RemoteException\n-        {\n-            \/* Server ref must be created and assigned before remote object\n-             * 'this' can be exported.\n-             *\/\n-            LiveRef lref =\n-                new LiveRef(new ObjID(ObjID.ACTIVATOR_ID), port, null, ssf);\n-            UnicastServerRef uref = new UnicastServerRef(lref);\n-            ref = uref;\n-            uref.exportObject(this, null, false);\n-        }\n-\n-        public MarshalledObject<? extends Remote> activate(ActivationID id,\n-                                                           boolean force)\n-            throws ActivationException, UnknownObjectException, RemoteException\n-        {\n-            checkShutdown();\n-            return getGroupEntry(id).activate(id, force);\n-        }\n-    }\n-\n-    class ActivationMonitorImpl extends UnicastRemoteObject\n-        implements ActivationMonitor\n-    {\n-        private static final long serialVersionUID = -6214940464757948867L;\n-\n-        ActivationMonitorImpl(int port, RMIServerSocketFactory ssf)\n-            throws RemoteException\n-        {\n-            super(port, null, ssf);\n-        }\n-\n-        public void inactiveObject(ActivationID id)\n-            throws UnknownObjectException, RemoteException\n-        {\n-            try {\n-                checkShutdown();\n-            } catch (ActivationException e) {\n-                return;\n-            }\n-            RegistryImpl.checkAccess(\"Activator.inactiveObject\");\n-            getGroupEntry(id).inactiveObject(id);\n-        }\n-\n-        public void activeObject(ActivationID id,\n-                                 MarshalledObject<? extends Remote> mobj)\n-            throws UnknownObjectException, RemoteException\n-        {\n-            try {\n-                checkShutdown();\n-            } catch (ActivationException e) {\n-                return;\n-            }\n-            RegistryImpl.checkAccess(\"ActivationSystem.activeObject\");\n-            getGroupEntry(id).activeObject(id, mobj);\n-        }\n-\n-        public void inactiveGroup(ActivationGroupID id,\n-                                  long incarnation)\n-            throws UnknownGroupException, RemoteException\n-        {\n-            try {\n-                checkShutdown();\n-            } catch (ActivationException e) {\n-                return;\n-            }\n-            RegistryImpl.checkAccess(\"ActivationMonitor.inactiveGroup\");\n-            getGroupEntry(id).inactiveGroup(incarnation, false);\n-        }\n-    }\n-\n-\n-    \/**\n-     * SameHostOnlyServerRef checks that access is from a local client\n-     * before the parameters are deserialized.  The unmarshalCustomCallData\n-     * hook is used to check the network address of the caller\n-     * with RegistryImpl.checkAccess().\n-     * The kind of access is retained for an exception if one is thrown.\n-     *\/\n-    @SuppressWarnings(\"serial\") \/\/ Externalizable class w\/o no-arg c'tor\n-    static class SameHostOnlyServerRef extends UnicastServerRef {\n-        private static final long serialVersionUID = 1234L;\n-        private String accessKind;      \/\/ an exception message\n-\n-        \/**\n-         * Construct a new SameHostOnlyServerRef from a LiveRef.\n-         * @param lref a LiveRef\n-         *\/\n-        SameHostOnlyServerRef(LiveRef lref, String accessKind) {\n-            super(lref);\n-            this.accessKind = accessKind;\n-        }\n-\n-        @Override\n-        protected void unmarshalCustomCallData(ObjectInput in) throws IOException, ClassNotFoundException {\n-            RegistryImpl.checkAccess(accessKind);\n-            super.unmarshalCustomCallData(in);\n-        }\n-    }\n-\n-    class ActivationSystemImpl\n-        extends RemoteServer\n-        implements ActivationSystem\n-    {\n-        private static final long serialVersionUID = 9100152600327688967L;\n-\n-        \/\/ Because ActivationSystemImpl has a fixed ObjID, it can be\n-        \/\/ called by clients holding stale remote references.  Each of\n-        \/\/ its remote methods, then, must check startupLock (calling\n-        \/\/ checkShutdown() is easiest).\n-        ActivationSystemImpl(int port, RMIServerSocketFactory ssf)\n-            throws RemoteException\n-        {\n-            \/* Server ref must be created and assigned before remote object\n-             * 'this' can be exported.\n-             *\/\n-            LiveRef lref = new LiveRef(new ObjID(4), port, null, ssf);\n-            UnicastServerRef uref = new SameHostOnlyServerRef(lref,\n-                    \"ActivationSystem.nonLocalAccess\");\n-            ref = uref;\n-            uref.exportObject(this, null);\n-        }\n-\n-        public ActivationID registerObject(ActivationDesc desc)\n-            throws ActivationException, UnknownGroupException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-            ActivationGroupID groupID = desc.getGroupID();\n-            ActivationID id = new ActivationID(activatorStub);\n-            getGroupEntry(groupID).registerObject(id, desc, true);\n-            return id;\n-        }\n-\n-        public void unregisterObject(ActivationID id)\n-            throws ActivationException, UnknownObjectException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-            getGroupEntry(id).unregisterObject(id, true);\n-        }\n-\n-        public ActivationGroupID registerGroup(ActivationGroupDesc desc)\n-            throws ActivationException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-            checkArgs(desc, null);\n-\n-            ActivationGroupID id = new ActivationGroupID(systemStub);\n-            GroupEntry entry = new GroupEntry(id, desc);\n-            \/\/ table insertion must take place before log update\n-            groupTable.put(id, entry);\n-            addLogRecord(new LogRegisterGroup(id, desc));\n-            return id;\n-        }\n-\n-        public ActivationMonitor activeGroup(ActivationGroupID id,\n-                                             ActivationInstantiator group,\n-                                             long incarnation)\n-            throws ActivationException, UnknownGroupException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            getGroupEntry(id).activeGroup(group, incarnation);\n-            return monitor;\n-        }\n-\n-        public void unregisterGroup(ActivationGroupID id)\n-            throws ActivationException, UnknownGroupException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            \/\/ remove entry before unregister so state is updated before\n-            \/\/ logged\n-            removeGroupEntry(id).unregisterGroup(true);\n-        }\n-\n-        public ActivationDesc setActivationDesc(ActivationID id,\n-                                                ActivationDesc desc)\n-            throws ActivationException, UnknownObjectException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            if (!getGroupID(id).equals(desc.getGroupID())) {\n-                throw new ActivationException(\n-                    \"ActivationDesc contains wrong group\");\n-            }\n-            return getGroupEntry(id).setActivationDesc(id, desc, true);\n-        }\n-\n-        public ActivationGroupDesc setActivationGroupDesc(ActivationGroupID id,\n-                                                          ActivationGroupDesc desc)\n-            throws ActivationException, UnknownGroupException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            checkArgs(desc, null);\n-            return getGroupEntry(id).setActivationGroupDesc(id, desc, true);\n-        }\n-\n-        public ActivationDesc getActivationDesc(ActivationID id)\n-            throws ActivationException, UnknownObjectException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            return getGroupEntry(id).getActivationDesc(id);\n-        }\n-\n-        public ActivationGroupDesc getActivationGroupDesc(ActivationGroupID id)\n-            throws ActivationException, UnknownGroupException, RemoteException\n-        {\n-            checkShutdown();\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            return getGroupEntry(id).desc;\n-        }\n-\n-        \/**\n-         * Shutdown the activation system. Destroys all groups spawned by\n-         * the activation daemon and exits the activation daemon.\n-         *\/\n-        public void shutdown() throws AccessException {\n-            \/\/ RegistryImpl.checkAccess() is done in the SameHostOnlyServerRef\n-            \/\/ during unmarshallCustomData and is not applicable to local access.\n-\n-            Object lock = startupLock;\n-            if (lock != null) {\n-                synchronized (lock) {\n-                    \/\/ nothing\n-                }\n-            }\n-\n-            synchronized (Activation.this) {\n-                if (!shuttingDown) {\n-                    shuttingDown = true;\n-                    (new Shutdown()).start();\n-                }\n-            }\n-        }\n-    }\n-\n-    private void checkShutdown() throws ActivationException {\n-        \/\/ if the startup critical section is running, wait until it\n-        \/\/ completes\/fails before continuing with the remote call.\n-        Object lock = startupLock;\n-        if (lock != null) {\n-            synchronized (lock) {\n-                \/\/ nothing\n-            }\n-        }\n-\n-        if (shuttingDown == true) {\n-            throw new ActivationException(\n-                \"activation system shutting down\");\n-        }\n-    }\n-\n-    private static void unexport(Remote obj) {\n-        for (;;) {\n-            try {\n-                if (UnicastRemoteObject.unexportObject(obj, false) == true) {\n-                    break;\n-                } else {\n-                    Thread.sleep(100);\n-                }\n-            } catch (Exception e) {\n-                continue;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Thread to shutdown rmid.\n-     *\/\n-    private class Shutdown extends Thread {\n-        Shutdown() {\n-            super(\"rmid Shutdown\");\n-        }\n-\n-        public void run() {\n-            try {\n-                \/*\n-                 * Unexport activation system services\n-                 *\/\n-                unexport(activator);\n-                unexport(system);\n-\n-                \/\/ destroy all child processes (groups)\n-                for (GroupEntry groupEntry : groupTable.values()) {\n-                    groupEntry.shutdown();\n-                }\n-\n-                Runtime.getRuntime().removeShutdownHook(shutdownHook);\n-\n-                \/*\n-                 * Unexport monitor safely since all processes are destroyed.\n-                 *\/\n-                unexport(monitor);\n-\n-                \/*\n-                 * Close log file, fix for 4243264: rmid shutdown thread\n-                 * interferes with remote calls in progress.  Make sure\n-                 * the log file is only closed when it is impossible for\n-                 * its closure to interfere with any pending remote calls.\n-                 * We close the log when all objects in the rmid VM are\n-                 * unexported.\n-                 *\/\n-                try {\n-                    synchronized (log) {\n-                        log.close();\n-                    }\n-                } catch (IOException e) {\n-                }\n-\n-            } finally {\n-                \/*\n-                 * Now exit... A System.exit should only be done if\n-                 * the RMI activation system daemon was started up\n-                 * by the main method below (in which should always\n-                 * be the case since the Activation constructor is private).\n-                 *\/\n-                System.err.println(getTextResource(\"rmid.daemon.shutdown\"));\n-                System.exit(0);\n-            }\n-        }\n-    }\n-\n-    \/** Thread to destroy children in the event of abnormal termination. *\/\n-    private class ShutdownHook extends Thread {\n-        ShutdownHook() {\n-            super(\"rmid ShutdownHook\");\n-        }\n-\n-        public void run() {\n-            synchronized (Activation.this) {\n-                shuttingDown = true;\n-            }\n-\n-            \/\/ destroy all child processes (groups) quickly\n-            for (GroupEntry groupEntry : groupTable.values()) {\n-                groupEntry.shutdownFast();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Returns the groupID for a given id of an object in the group.\n-     * Throws UnknownObjectException if the object is not registered.\n-     *\/\n-    private ActivationGroupID getGroupID(ActivationID id)\n-        throws UnknownObjectException\n-    {\n-        ActivationGroupID groupID = idTable.get(id);\n-        if (groupID != null) {\n-            return groupID;\n-        }\n-        throw new UnknownObjectException(\"unknown object: \" + id);\n-    }\n-\n-    \/**\n-     * Returns the group entry for the group id, optionally removing it.\n-     * Throws UnknownGroupException if the group is not registered.\n-     *\/\n-    private GroupEntry getGroupEntry(ActivationGroupID id, boolean rm)\n-        throws UnknownGroupException\n-    {\n-        if (id.getClass() == ActivationGroupID.class) {\n-            GroupEntry entry;\n-            if (rm) {\n-                entry = groupTable.remove(id);\n-            } else {\n-                entry = groupTable.get(id);\n-            }\n-            if (entry != null && !entry.removed) {\n-                return entry;\n-            }\n-        }\n-        throw new UnknownGroupException(\"group unknown\");\n-    }\n-\n-    \/**\n-     * Returns the group entry for the group id. Throws\n-     * UnknownGroupException if the group is not registered.\n-     *\/\n-    private GroupEntry getGroupEntry(ActivationGroupID id)\n-        throws UnknownGroupException\n-    {\n-        return getGroupEntry(id, false);\n-    }\n-\n-    \/**\n-     * Removes and returns the group entry for the group id. Throws\n-     * UnknownGroupException if the group is not registered.\n-     *\/\n-    private GroupEntry removeGroupEntry(ActivationGroupID id)\n-        throws UnknownGroupException\n-    {\n-        return getGroupEntry(id, true);\n-    }\n-\n-    \/**\n-     * Returns the group entry for the object's id. Throws\n-     * UnknownObjectException if the object is not registered or the\n-     * object's group is not registered.\n-     *\/\n-    private GroupEntry getGroupEntry(ActivationID id)\n-        throws UnknownObjectException\n-    {\n-        ActivationGroupID gid = getGroupID(id);\n-        GroupEntry entry = groupTable.get(gid);\n-        if (entry != null && !entry.removed) {\n-            return entry;\n-        }\n-        throw new UnknownObjectException(\"object's group removed\");\n-    }\n-\n-    \/**\n-     * Container for group information: group's descriptor, group's\n-     * instantiator, flag to indicate pending group creation, and\n-     * table of the objects that are activated in the group.\n-     *\n-     * WARNING: GroupEntry objects should not be written into log file\n-     * updates.  GroupEntrys are inner classes of Activation and they\n-     * can not be serialized independent of this class.  If the\n-     * complete Activation system is written out as a log update, the\n-     * point of having updates is nullified.\n-     *\/\n-    private class GroupEntry implements Serializable {\n-\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = 7222464070032993304L;\n-        private static final int MAX_TRIES = 2;\n-        private static final int NORMAL = 0;\n-        private static final int CREATING = 1;\n-        private static final int TERMINATE = 2;\n-        private static final int TERMINATING = 3;\n-\n-        ActivationGroupDesc desc = null;\n-        ActivationGroupID groupID = null;\n-        long incarnation = 0;\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        Map<ActivationID,ObjectEntry> objects = new HashMap<>();\n-        @SuppressWarnings(\"serial\") \/\/ Conditionally serializable\n-        Set<ActivationID> restartSet = new HashSet<>();\n-\n-        transient ActivationInstantiator group = null;\n-        transient int status = NORMAL;\n-        transient long waitTime = 0;\n-        transient String groupName = null;\n-        transient Process child = null;\n-        transient boolean removed = false;\n-        transient Watchdog watchdog = null;\n-\n-        GroupEntry(ActivationGroupID groupID, ActivationGroupDesc desc) {\n-            this.groupID = groupID;\n-            this.desc = desc;\n-        }\n-\n-        void restartServices() {\n-            Iterator<ActivationID> iter = null;\n-\n-            synchronized (this) {\n-                if (restartSet.isEmpty()) {\n-                    return;\n-                }\n-\n-                \/*\n-                 * Clone the restartSet so the set does not have to be locked\n-                 * during iteration. Locking the restartSet could cause\n-                 * deadlock if an object we are restarting caused another\n-                 * object in this group to be activated.\n-                 *\/\n-                iter = (new HashSet<ActivationID>(restartSet)).iterator();\n-            }\n-\n-            while (iter.hasNext()) {\n-                ActivationID id = iter.next();\n-                try {\n-                    activate(id, true);\n-                } catch (Exception e) {\n-                    if (shuttingDown) {\n-                        return;\n-                    }\n-                    System.err.println(\n-                        getTextResource(\"rmid.restart.service.warning\"));\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-\n-        synchronized void activeGroup(ActivationInstantiator inst,\n-                                      long instIncarnation)\n-            throws ActivationException, UnknownGroupException\n-        {\n-            if (incarnation != instIncarnation) {\n-                throw new ActivationException(\"invalid incarnation\");\n-            }\n-\n-            if (group != null) {\n-                if (group.equals(inst)) {\n-                    return;\n-                } else {\n-                    throw new ActivationException(\"group already active\");\n-                }\n-            }\n-\n-            if (child != null && status != CREATING) {\n-                throw new ActivationException(\"group not being created\");\n-            }\n-\n-            group = inst;\n-            status = NORMAL;\n-            notifyAll();\n-        }\n-\n-        private void checkRemoved() throws UnknownGroupException {\n-            if (removed) {\n-                throw new UnknownGroupException(\"group removed\");\n-            }\n-        }\n-\n-        private ObjectEntry getObjectEntry(ActivationID id)\n-            throws UnknownObjectException\n-        {\n-            if (removed) {\n-                throw new UnknownObjectException(\"object's group removed\");\n-            }\n-            ObjectEntry objEntry = objects.get(id);\n-            if (objEntry == null) {\n-                throw new UnknownObjectException(\"object unknown\");\n-            }\n-            return objEntry;\n-        }\n-\n-        synchronized void registerObject(ActivationID id,\n-                                         ActivationDesc desc,\n-                                         boolean addRecord)\n-            throws UnknownGroupException, ActivationException\n-        {\n-            checkRemoved();\n-            objects.put(id, new ObjectEntry(desc));\n-            if (desc.getRestartMode() == true) {\n-                restartSet.add(id);\n-            }\n-\n-            \/\/ table insertion must take place before log update\n-            idTable.put(id, groupID);\n-\n-            if (addRecord) {\n-                addLogRecord(new LogRegisterObject(id, desc));\n-            }\n-        }\n-\n-        synchronized void unregisterObject(ActivationID id, boolean addRecord)\n-            throws UnknownGroupException, ActivationException\n-        {\n-            ObjectEntry objEntry = getObjectEntry(id);\n-            objEntry.removed = true;\n-            objects.remove(id);\n-            if (objEntry.desc.getRestartMode() == true) {\n-                restartSet.remove(id);\n-            }\n-\n-            \/\/ table removal must take place before log update\n-            idTable.remove(id);\n-            if (addRecord) {\n-                addLogRecord(new LogUnregisterObject(id));\n-            }\n-        }\n-\n-        synchronized void unregisterGroup(boolean addRecord)\n-           throws UnknownGroupException, ActivationException\n-        {\n-            checkRemoved();\n-            removed = true;\n-            for (Map.Entry<ActivationID,ObjectEntry> entry :\n-                     objects.entrySet())\n-            {\n-                ActivationID id = entry.getKey();\n-                idTable.remove(id);\n-                ObjectEntry objEntry = entry.getValue();\n-                objEntry.removed = true;\n-            }\n-            objects.clear();\n-            restartSet.clear();\n-            reset();\n-            childGone();\n-\n-            \/\/ removal should be recorded before log update\n-            if (addRecord) {\n-                addLogRecord(new LogUnregisterGroup(groupID));\n-            }\n-        }\n-\n-        synchronized ActivationDesc setActivationDesc(ActivationID id,\n-                                                      ActivationDesc desc,\n-                                                      boolean addRecord)\n-            throws UnknownObjectException, UnknownGroupException,\n-                   ActivationException\n-        {\n-            ObjectEntry objEntry = getObjectEntry(id);\n-            ActivationDesc oldDesc = objEntry.desc;\n-            objEntry.desc = desc;\n-            if (desc.getRestartMode() == true) {\n-                restartSet.add(id);\n-            } else {\n-                restartSet.remove(id);\n-            }\n-            \/\/ restart information should be recorded before log update\n-            if (addRecord) {\n-                addLogRecord(new LogUpdateDesc(id, desc));\n-            }\n-\n-            return oldDesc;\n-        }\n-\n-        synchronized ActivationDesc getActivationDesc(ActivationID id)\n-            throws UnknownObjectException, UnknownGroupException\n-        {\n-            return getObjectEntry(id).desc;\n-        }\n-\n-        synchronized ActivationGroupDesc setActivationGroupDesc(\n-                ActivationGroupID id,\n-                ActivationGroupDesc desc,\n-                boolean addRecord)\n-            throws UnknownGroupException, ActivationException\n-        {\n-            checkRemoved();\n-            ActivationGroupDesc oldDesc = this.desc;\n-            this.desc = desc;\n-            \/\/ state update should occur before log update\n-            if (addRecord) {\n-                addLogRecord(new LogUpdateGroupDesc(id, desc));\n-            }\n-            return oldDesc;\n-        }\n-\n-        synchronized void inactiveGroup(long incarnation, boolean failure)\n-            throws UnknownGroupException\n-        {\n-            checkRemoved();\n-            if (this.incarnation != incarnation) {\n-                throw new UnknownGroupException(\"invalid incarnation\");\n-            }\n-\n-            reset();\n-            if (failure) {\n-                terminate();\n-            } else if (child != null && status == NORMAL) {\n-                status = TERMINATE;\n-                watchdog.noRestart();\n-            }\n-        }\n-\n-        synchronized void activeObject(ActivationID id,\n-                                       MarshalledObject<? extends Remote> mobj)\n-                throws UnknownObjectException\n-        {\n-            getObjectEntry(id).stub = mobj;\n-        }\n-\n-        synchronized void inactiveObject(ActivationID id)\n-            throws UnknownObjectException\n-        {\n-            getObjectEntry(id).reset();\n-        }\n-\n-        private synchronized void reset() {\n-            group = null;\n-            for (ObjectEntry objectEntry : objects.values()) {\n-                objectEntry.reset();\n-            }\n-        }\n-\n-        private void childGone() {\n-            if (child != null) {\n-                child = null;\n-                watchdog.dispose();\n-                watchdog = null;\n-                status = NORMAL;\n-                notifyAll();\n-            }\n-        }\n-\n-        private void terminate() {\n-            if (child != null && status != TERMINATING) {\n-                child.destroy();\n-                status = TERMINATING;\n-                waitTime = System.currentTimeMillis() + groupTimeout;\n-                notifyAll();\n-            }\n-        }\n-\n-       \/*\n-        * Fallthrough from TERMINATE to TERMINATING\n-        * is intentional\n-        *\/\n-        @SuppressWarnings(\"fallthrough\")\n-        private void await() {\n-            while (true) {\n-                switch (status) {\n-                case NORMAL:\n-                    return;\n-                case TERMINATE:\n-                    terminate();\n-                case TERMINATING:\n-                    try {\n-                        child.exitValue();\n-                    } catch (IllegalThreadStateException e) {\n-                        long now = System.currentTimeMillis();\n-                        if (waitTime > now) {\n-                            try {\n-                                wait(waitTime - now);\n-                            } catch (InterruptedException ee) {\n-                            }\n-                            continue;\n-                        }\n-                        \/\/ REMIND: print message that group did not terminate?\n-                    }\n-                    childGone();\n-                    return;\n-                case CREATING:\n-                    try {\n-                        wait();\n-                    } catch (InterruptedException e) {\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ no synchronization to avoid delay wrt getInstantiator\n-        void shutdownFast() {\n-            Process p = child;\n-            if (p != null) {\n-                p.destroy();\n-            }\n-        }\n-\n-        synchronized void shutdown() {\n-            reset();\n-            terminate();\n-            await();\n-        }\n-\n-        MarshalledObject<? extends Remote> activate(ActivationID id,\n-                                                    boolean force)\n-            throws ActivationException\n-        {\n-            Exception detail = null;\n-\n-            \/*\n-             * Attempt to activate object and reattempt (several times)\n-             * if activation fails due to communication problems.\n-             *\/\n-            for (int tries = MAX_TRIES; tries > 0; tries--) {\n-                ActivationInstantiator inst;\n-                long currentIncarnation;\n-\n-                \/\/ look up object to activate\n-                ObjectEntry objEntry;\n-                synchronized (this) {\n-                    objEntry = getObjectEntry(id);\n-                    \/\/ if not forcing activation, return cached stub\n-                    if (!force && objEntry.stub != null) {\n-                        return objEntry.stub;\n-                    }\n-                    inst = getInstantiator(groupID);\n-                    currentIncarnation = incarnation;\n-                }\n-\n-                boolean groupInactive = false;\n-                boolean failure = false;\n-                \/\/ activate object\n-                try {\n-                    return objEntry.activate(id, force, inst);\n-                } catch (NoSuchObjectException e) {\n-                    groupInactive = true;\n-                    detail = e;\n-                } catch (ConnectException e) {\n-                    groupInactive = true;\n-                    failure = true;\n-                    detail = e;\n-                } catch (ConnectIOException e) {\n-                    groupInactive = true;\n-                    failure = true;\n-                    detail = e;\n-                } catch (InactiveGroupException e) {\n-                    groupInactive = true;\n-                    detail = e;\n-                } catch (RemoteException e) {\n-                    \/\/ REMIND: wait some here before continuing?\n-                    if (detail == null) {\n-                        detail = e;\n-                    }\n-                }\n-\n-                if (groupInactive) {\n-                    \/\/ group has failed or is inactive; mark inactive\n-                    try {\n-                        System.err.println(\n-                            MessageFormat.format(\n-                                getTextResource(\"rmid.group.inactive\"),\n-                                detail.toString()));\n-                        detail.printStackTrace();\n-                        getGroupEntry(groupID).\n-                            inactiveGroup(currentIncarnation, failure);\n-                    } catch (UnknownGroupException e) {\n-                        \/\/ not a problem\n-                    }\n-                }\n-            }\n-\n-            \/**\n-             * signal that group activation failed, nested exception\n-             * specifies what exception occurred when the group did not\n-             * activate\n-             *\/\n-            throw new ActivationException(\"object activation failed after \" +\n-                                          MAX_TRIES + \" tries\", detail);\n-        }\n-\n-        \/**\n-         * Returns the instantiator for the group specified by id and\n-         * entry. If the group is currently inactive, exec some\n-         * bootstrap code to create the group.\n-         *\/\n-        private ActivationInstantiator getInstantiator(ActivationGroupID id)\n-            throws ActivationException\n-        {\n-            assert Thread.holdsLock(this);\n-\n-            await();\n-            if (group != null) {\n-                return group;\n-            }\n-            checkRemoved();\n-            boolean acquired = false;\n-\n-            try {\n-                groupName = Pstartgroup();\n-                acquired = true;\n-                String[] argv = activationArgs(desc);\n-                checkArgs(desc, argv);\n-\n-                if (debugExec) {\n-                    StringBuilder sb = new StringBuilder(argv[0]);\n-                    int j;\n-                    for (j = 1; j < argv.length; j++) {\n-                        sb.append(' ');\n-                        sb.append(argv[j]);\n-                    }\n-                    System.err.println(\n-                        MessageFormat.format(\n-                            getTextResource(\"rmid.exec.command\"),\n-                            sb.toString()));\n-                }\n-\n-                try {\n-                    child = Runtime.getRuntime().exec(argv);\n-                    status = CREATING;\n-                    ++incarnation;\n-                    watchdog = new Watchdog();\n-                    watchdog.start();\n-                    addLogRecord(new LogGroupIncarnation(id, incarnation));\n-\n-                    \/\/ handle child I\/O streams before writing to child\n-                    PipeWriter.plugTogetherPair\n-                        (child.getInputStream(), System.out,\n-                         child.getErrorStream(), System.err);\n-                    try (MarshalOutputStream out =\n-                            new MarshalOutputStream(child.getOutputStream())) {\n-                        out.writeObject(id);\n-                        out.writeObject(desc);\n-                        out.writeLong(incarnation);\n-                        out.flush();\n-                    }\n-\n-\n-                } catch (IOException e) {\n-                    terminate();\n-                    throw new ActivationException(\n-                        \"unable to create activation group\", e);\n-                }\n-\n-                try {\n-                    long now = System.currentTimeMillis();\n-                    long stop = now + execTimeout;\n-                    do {\n-                        wait(stop - now);\n-                        if (group != null) {\n-                            return group;\n-                        }\n-                        now = System.currentTimeMillis();\n-                    } while (status == CREATING && now < stop);\n-                } catch (InterruptedException e) {\n-                }\n-\n-                terminate();\n-                throw new ActivationException(\n-                        (removed ?\n-                         \"activation group unregistered\" :\n-                         \"timeout creating child process\"));\n-            } finally {\n-                if (acquired) {\n-                    Vstartgroup();\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Waits for process termination and then restarts services.\n-         *\/\n-        private class Watchdog extends Thread {\n-            private final Process groupProcess = child;\n-            private final long groupIncarnation = incarnation;\n-            private boolean canInterrupt = true;\n-            private boolean shouldQuit = false;\n-            private boolean shouldRestart = true;\n-\n-            Watchdog() {\n-                super(\"WatchDog-\"  + groupName + \"-\" + incarnation);\n-                setDaemon(true);\n-            }\n-\n-            public void run() {\n-\n-                if (shouldQuit) {\n-                    return;\n-                }\n-\n-                \/*\n-                 * Wait for the group to crash or exit.\n-                 *\/\n-                try {\n-                    groupProcess.waitFor();\n-                } catch (InterruptedException exit) {\n-                    return;\n-                }\n-\n-                boolean restart = false;\n-                synchronized (GroupEntry.this) {\n-                    if (shouldQuit) {\n-                        return;\n-                    }\n-                    canInterrupt = false;\n-                    interrupted(); \/\/ clear interrupt bit\n-                    \/*\n-                     * Since the group crashed, we should\n-                     * reset the entry before activating objects\n-                     *\/\n-                    if (groupIncarnation == incarnation) {\n-                        restart = shouldRestart && !shuttingDown;\n-                        reset();\n-                        childGone();\n-                    }\n-                }\n-\n-                \/*\n-                 * Activate those objects that require restarting\n-                 * after a crash.\n-                 *\/\n-                if (restart) {\n-                    restartServices();\n-                }\n-            }\n-\n-            \/**\n-             * Marks this thread as one that is no longer needed.\n-             * If the thread is in a state in which it can be interrupted,\n-             * then the thread is interrupted.\n-             *\/\n-            void dispose() {\n-                shouldQuit = true;\n-                if (canInterrupt) {\n-                    interrupt();\n-                }\n-            }\n-\n-            \/**\n-             * Marks this thread as no longer needing to restart objects.\n-             *\/\n-            void noRestart() {\n-                shouldRestart = false;\n-            }\n-        }\n-    }\n-\n-    private String[] activationArgs(ActivationGroupDesc desc) {\n-        ActivationGroupDesc.CommandEnvironment cmdenv;\n-        cmdenv = desc.getCommandEnvironment();\n-\n-        \/\/ argv is the literal command to exec\n-        List<String> argv = new ArrayList<>();\n-\n-        \/\/ Command name\/path\n-        argv.add((cmdenv != null && cmdenv.getCommandPath() != null)\n-                    ? cmdenv.getCommandPath()\n-                    : command[0]);\n-\n-        \/\/ Group-specific command options\n-        if (cmdenv != null && cmdenv.getCommandOptions() != null) {\n-            argv.addAll(Arrays.asList(cmdenv.getCommandOptions()));\n-        }\n-\n-        \/\/ Properties become -D parameters\n-        Properties props = desc.getPropertyOverrides();\n-        if (props != null) {\n-            for (Enumeration<?> p = props.propertyNames();\n-                 p.hasMoreElements();)\n-            {\n-                String name = (String) p.nextElement();\n-                \/* Note on quoting: it would be wrong\n-                 * here, since argv will be passed to\n-                 * Runtime.exec, which should not parse\n-                 * arguments or split on whitespace.\n-                 *\/\n-                argv.add(\"-D\" + name + \"=\" + props.getProperty(name));\n-            }\n-        }\n-\n-        \/* Finally, rmid-global command options (e.g. -C options)\n-         * and the classname\n-         *\/\n-        for (int i = 1; i < command.length; i++) {\n-            argv.add(command[i]);\n-        }\n-\n-        String[] realArgv = new String[argv.size()];\n-        System.arraycopy(argv.toArray(), 0, realArgv, 0, realArgv.length);\n-\n-        return realArgv;\n-    }\n-\n-    private void checkArgs(ActivationGroupDesc desc, String[] cmd)\n-        throws SecurityException, ActivationException\n-    {\n-        \/*\n-         * Check exec command using execPolicy object\n-         *\/\n-        if (execPolicyMethod != null) {\n-            if (cmd == null) {\n-                cmd = activationArgs(desc);\n-            }\n-            try {\n-                execPolicyMethod.invoke(execPolicy, desc, cmd);\n-            } catch (InvocationTargetException e) {\n-                Throwable targetException = e.getCause();\n-                if (targetException instanceof SecurityException) {\n-                    throw (SecurityException) targetException;\n-                } else {\n-                    throw new ActivationException(\n-                        execPolicyMethod.getName() + \": unexpected exception\",\n-                        e);\n-                }\n-            } catch (Exception e) {\n-                throw new ActivationException(\n-                    execPolicyMethod.getName() + \": unexpected exception\", e);\n-            }\n-        }\n-    }\n-\n-    private static class ObjectEntry implements Serializable {\n-\n-        private static final long serialVersionUID = -5500114225321357856L;\n-\n-        \/** descriptor for object *\/\n-        ActivationDesc desc;\n-        \/** the stub (if active) *\/\n-        volatile transient MarshalledObject<? extends Remote> stub = null;\n-        volatile transient boolean removed = false;\n-\n-        ObjectEntry(ActivationDesc desc) {\n-            this.desc = desc;\n-        }\n-\n-        synchronized MarshalledObject<? extends Remote>\n-            activate(ActivationID id,\n-                     boolean force,\n-                     ActivationInstantiator inst)\n-            throws RemoteException, ActivationException\n-        {\n-            MarshalledObject<? extends Remote> nstub = stub;\n-            if (removed) {\n-                throw new UnknownObjectException(\"object removed\");\n-            } else if (!force && nstub != null) {\n-                return nstub;\n-            }\n-\n-            nstub = inst.newInstance(id, desc);\n-            stub = nstub;\n-            \/*\n-             * stub could be set to null by a group reset, so return\n-             * the newstub here to prevent returning null.\n-             *\/\n-            return nstub;\n-        }\n-\n-        void reset() {\n-            stub = null;\n-        }\n-    }\n-\n-    \/**\n-     * Add a record to the activation log. If the number of updates\n-     * passes a predetermined threshold, record a snapshot.\n-     *\/\n-    private void addLogRecord(LogRecord rec) throws ActivationException {\n-        synchronized (log) {\n-            checkShutdown();\n-            try {\n-                log.update(rec, true);\n-            } catch (Exception e) {\n-                numUpdates = snapshotInterval;\n-                System.err.println(getTextResource(\"rmid.log.update.warning\"));\n-                e.printStackTrace();\n-            }\n-            if (++numUpdates < snapshotInterval) {\n-                return;\n-            }\n-            try {\n-                log.snapshot(this);\n-                numUpdates = 0;\n-            } catch (Exception e) {\n-                System.err.println(\n-                    getTextResource(\"rmid.log.snapshot.warning\"));\n-                e.printStackTrace();\n-                try {\n-                    \/\/ shutdown activation system because snapshot failed\n-                    system.shutdown();\n-                } catch (RemoteException ignore) {\n-                    \/\/ can't happen\n-                }\n-                \/\/ warn the client of the original update problem\n-                throw new ActivationException(\"log snapshot failed\", e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Handler for the log that knows how to take the initial snapshot\n-     * and apply an update (a LogRecord) to the current state.\n-     *\/\n-    private static class ActLogHandler extends LogHandler {\n-\n-        ActLogHandler() {\n-        }\n-\n-        public Object initialSnapshot()\n-        {\n-            \/**\n-             * Return an empty Activation object.  Log will update\n-             * this object with recovered state.\n-             *\/\n-            return new Activation();\n-        }\n-\n-        public Object applyUpdate(Object update, Object state)\n-            throws Exception\n-        {\n-            return ((LogRecord) update).apply(state);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Abstract class for all log records. The subclass contains\n-     * specific update information and implements the apply method\n-     * that applys the update information contained in the record\n-     * to the current state.\n-     *\/\n-    private static abstract class LogRecord implements Serializable {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = 8395140512322687529L;\n-        abstract Object apply(Object state) throws Exception;\n-    }\n-\n-    \/**\n-     * Log record for registering an object.\n-     *\/\n-    private static class LogRegisterObject extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = -6280336276146085143L;\n-        private ActivationID id;\n-        private ActivationDesc desc;\n-\n-        LogRegisterObject(ActivationID id, ActivationDesc desc) {\n-            this.id = id;\n-            this.desc = desc;\n-        }\n-\n-        Object apply(Object state) {\n-            try {\n-                ((Activation) state).getGroupEntry(desc.getGroupID()).\n-                    registerObject(id, desc, false);\n-            } catch (Exception ignore) {\n-                System.err.println(\n-                    MessageFormat.format(\n-                        getTextResource(\"rmid.log.recover.warning\"),\n-                        \"LogRegisterObject\"));\n-                ignore.printStackTrace();\n-            }\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Log record for unregistering an object.\n-     *\/\n-    private static class LogUnregisterObject extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = 6269824097396935501L;\n-        private ActivationID id;\n-\n-        LogUnregisterObject(ActivationID id) {\n-            this.id = id;\n-        }\n-\n-        Object apply(Object state) {\n-            try {\n-                ((Activation) state).getGroupEntry(id).\n-                    unregisterObject(id, false);\n-            } catch (Exception ignore) {\n-                System.err.println(\n-                    MessageFormat.format(\n-                        getTextResource(\"rmid.log.recover.warning\"),\n-                        \"LogUnregisterObject\"));\n-                ignore.printStackTrace();\n-            }\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Log record for registering a group.\n-     *\/\n-    private static class LogRegisterGroup extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = -1966827458515403625L;\n-        private ActivationGroupID id;\n-        private ActivationGroupDesc desc;\n-\n-        LogRegisterGroup(ActivationGroupID id, ActivationGroupDesc desc) {\n-            this.id = id;\n-            this.desc = desc;\n-        }\n-\n-        Object apply(Object state) {\n-            \/\/ modify state directly; cant ask a nonexistent GroupEntry\n-            \/\/ to register itself.\n-            ((Activation) state).groupTable.put(id, ((Activation) state).new\n-                                                GroupEntry(id, desc));\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Log record for udpating an activation desc\n-     *\/\n-    private static class LogUpdateDesc extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = 545511539051179885L;\n-\n-        private ActivationID id;\n-        private ActivationDesc desc;\n-\n-        LogUpdateDesc(ActivationID id, ActivationDesc desc) {\n-            this.id = id;\n-            this.desc = desc;\n-        }\n-\n-        Object apply(Object state) {\n-            try {\n-                ((Activation) state).getGroupEntry(id).\n-                    setActivationDesc(id, desc, false);\n-            } catch (Exception ignore) {\n-                System.err.println(\n-                    MessageFormat.format(\n-                        getTextResource(\"rmid.log.recover.warning\"),\n-                        \"LogUpdateDesc\"));\n-                ignore.printStackTrace();\n-            }\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Log record for unregistering a group.\n-     *\/\n-    private static class LogUpdateGroupDesc extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = -1271300989218424337L;\n-        private ActivationGroupID id;\n-        private ActivationGroupDesc desc;\n-\n-        LogUpdateGroupDesc(ActivationGroupID id, ActivationGroupDesc desc) {\n-            this.id = id;\n-            this.desc = desc;\n-        }\n-\n-        Object apply(Object state) {\n-            try {\n-                ((Activation) state).getGroupEntry(id).\n-                    setActivationGroupDesc(id, desc, false);\n-            } catch (Exception ignore) {\n-                System.err.println(\n-                    MessageFormat.format(\n-                        getTextResource(\"rmid.log.recover.warning\"),\n-                        \"LogUpdateGroupDesc\"));\n-                ignore.printStackTrace();\n-            }\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Log record for unregistering a group.\n-     *\/\n-    private static class LogUnregisterGroup extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = -3356306586522147344L;\n-        private ActivationGroupID id;\n-\n-        LogUnregisterGroup(ActivationGroupID id) {\n-            this.id = id;\n-        }\n-\n-        Object apply(Object state) {\n-            GroupEntry entry = ((Activation) state).groupTable.remove(id);\n-            try {\n-                entry.unregisterGroup(false);\n-            } catch (Exception ignore) {\n-                System.err.println(\n-                    MessageFormat.format(\n-                        getTextResource(\"rmid.log.recover.warning\"),\n-                        \"LogUnregisterGroup\"));\n-                ignore.printStackTrace();\n-            }\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Log record for an active group incarnation\n-     *\/\n-    private static class LogGroupIncarnation extends LogRecord {\n-        \/** indicate compatibility with JDK 1.2 version of class *\/\n-        private static final long serialVersionUID = 4146872747377631897L;\n-        private ActivationGroupID id;\n-        private long inc;\n-\n-        LogGroupIncarnation(ActivationGroupID id, long inc) {\n-            this.id = id;\n-            this.inc = inc;\n-        }\n-\n-        Object apply(Object state) {\n-            try {\n-                GroupEntry entry = ((Activation) state).getGroupEntry(id);\n-                entry.incarnation = inc;\n-            } catch (Exception ignore) {\n-                System.err.println(\n-                    MessageFormat.format(\n-                        getTextResource(\"rmid.log.recover.warning\"),\n-                        \"LogGroupIncarnation\"));\n-                ignore.printStackTrace();\n-            }\n-            return state;\n-        }\n-    }\n-\n-    \/**\n-     * Initialize command to exec a default group.\n-     *\/\n-    private void initCommand(String[] childArgs) {\n-        command = new String[childArgs.length + 2];\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            public Void run() {\n-                try {\n-                    command[0] = System.getProperty(\"java.home\") +\n-                        File.separator + \"bin\" + File.separator + \"java\";\n-                } catch (Exception e) {\n-                    System.err.println(\n-                        getTextResource(\"rmid.unfound.java.home.property\"));\n-                    command[0] = \"java\";\n-                }\n-                return null;\n-            }\n-        });\n-        System.arraycopy(childArgs, 0, command, 1, childArgs.length);\n-        command[command.length-1] = \"sun.rmi.server.ActivationGroupInit\";\n-    }\n-\n-    private static void bomb(String error) {\n-        System.err.println(\"rmid: \" + error); \/\/ $NON-NLS$\n-        System.err.println(MessageFormat.format(getTextResource(\"rmid.usage\"),\n-                    \"rmid\"));\n-        System.exit(1);\n-    }\n-\n-    \/**\n-     * The default policy for checking a command before it is executed\n-     * makes sure the appropriate com.sun.rmi.rmid.ExecPermission and\n-     * set of com.sun.rmi.rmid.ExecOptionPermissions have been granted.\n-     *\/\n-    public static class DefaultExecPolicy {\n-\n-        public void checkExecCommand(ActivationGroupDesc desc, String[] cmd)\n-            throws SecurityException\n-        {\n-            PermissionCollection perms = getExecPermissions();\n-\n-            \/*\n-             * Check properties overrides.\n-             *\/\n-            Properties props = desc.getPropertyOverrides();\n-            if (props != null) {\n-                Enumeration<?> p = props.propertyNames();\n-                while (p.hasMoreElements()) {\n-                    String name = (String) p.nextElement();\n-                    String value = props.getProperty(name);\n-                    String option = \"-D\" + name + \"=\" + value;\n-                    try {\n-                        checkPermission(perms,\n-                            new ExecOptionPermission(option));\n-                    } catch (AccessControlException e) {\n-                        if (value.isEmpty()) {\n-                            checkPermission(perms,\n-                                new ExecOptionPermission(\"-D\" + name));\n-                        } else {\n-                            throw e;\n-                        }\n-                    }\n-                }\n-            }\n-\n-            \/*\n-             * Check group class name (allow nothing but the default),\n-             * code location (must be null), and data (must be null).\n-             *\/\n-            String groupClassName = desc.getClassName();\n-            if ((groupClassName != null &&\n-                 !groupClassName.equals(\n-                    ActivationGroupImpl.class.getName())) ||\n-                (desc.getLocation() != null) ||\n-                (desc.getData() != null))\n-            {\n-                throw new AccessControlException(\n-                    \"access denied (custom group implementation not allowed)\");\n-            }\n-\n-            \/*\n-             * If group descriptor has a command environment, check\n-             * command and options.\n-             *\/\n-            ActivationGroupDesc.CommandEnvironment cmdenv;\n-            cmdenv = desc.getCommandEnvironment();\n-            if (cmdenv != null) {\n-                String path = cmdenv.getCommandPath();\n-                if (path != null) {\n-                    checkPermission(perms, new ExecPermission(path));\n-                }\n-\n-                String[] options = cmdenv.getCommandOptions();\n-                if (options != null) {\n-                    for (String option : options) {\n-                        checkPermission(perms,\n-                                        new ExecOptionPermission(option));\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/**\n-         * Prints warning message if installed Policy is the default Policy\n-         * implementation and globally granted permissions do not include\n-         * AllPermission or any ExecPermissions\/ExecOptionPermissions.\n-         *\/\n-        static void checkConfiguration() {\n-            Policy policy =\n-                AccessController.doPrivileged(new PrivilegedAction<Policy>() {\n-                    public Policy run() {\n-                        return Policy.getPolicy();\n-                    }\n-                });\n-            if (!(policy instanceof PolicyFile)) {\n-                return;\n-            }\n-            PermissionCollection perms = getExecPermissions();\n-            for (Enumeration<Permission> e = perms.elements();\n-                 e.hasMoreElements();)\n-            {\n-                Permission p = e.nextElement();\n-                if (p instanceof AllPermission ||\n-                    p instanceof ExecPermission ||\n-                    p instanceof ExecOptionPermission)\n-                {\n-                    return;\n-                }\n-            }\n-            System.err.println(getTextResource(\"rmid.exec.perms.inadequate\"));\n-        }\n-\n-        private static PermissionCollection getExecPermissions() {\n-            \/*\n-             * The approach used here is taken from the similar method\n-             * getLoaderAccessControlContext() in the class\n-             * sun.rmi.server.LoaderHandler.\n-             *\/\n-\n-            \/\/ obtain permissions granted to all code in current policy\n-            PermissionCollection perms = AccessController.doPrivileged(\n-                new PrivilegedAction<PermissionCollection>() {\n-                    public PermissionCollection run() {\n-                        CodeSource codesource =\n-                            new CodeSource(null, (Certificate[]) null);\n-                        Policy p = Policy.getPolicy();\n-                        if (p != null) {\n-                            return p.getPermissions(codesource);\n-                        } else {\n-                            return new Permissions();\n-                        }\n-                    }\n-                });\n-\n-            return perms;\n-        }\n-\n-        private static void checkPermission(PermissionCollection perms,\n-                                            Permission p)\n-            throws AccessControlException\n-        {\n-            if (!perms.implies(p)) {\n-                throw new AccessControlException(\n-                   \"access denied \" + p.toString());\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Main program to start the activation system. <br>\n-     * The usage is as follows: rmid [-port num] [-log dir].\n-     *\/\n-    public static void main(String[] args) {\n-        boolean stop = false;\n-\n-        \/\/ Create and install the security manager if one is not installed\n-        \/\/ already.\n-        if (System.getSecurityManager() == null) {\n-            System.setSecurityManager(new SecurityManager());\n-        }\n-\n-        try {\n-            int port = ActivationSystem.SYSTEM_PORT;\n-            RMIServerSocketFactory ssf = null;\n-\n-            \/*\n-             * If rmid has an inherited channel (meaning that it was\n-             * launched from inetd), set the server socket factory to\n-             * return the inherited server socket.\n-             **\/\n-            Channel inheritedChannel = AccessController.doPrivileged(\n-                new PrivilegedExceptionAction<Channel>() {\n-                    public Channel run() throws IOException {\n-                        return System.inheritedChannel();\n-                    }\n-                });\n-\n-            if (inheritedChannel != null &&\n-                inheritedChannel instanceof ServerSocketChannel)\n-            {\n-                \/*\n-                 * Redirect System.err output to a file.\n-                 *\/\n-                AccessController.doPrivileged(\n-                    new PrivilegedExceptionAction<Void>() {\n-                        public Void run() throws IOException {\n-                            boolean disable = Boolean.getBoolean(\n-                                    \"sun.rmi.server.activation.disableErrRedirect\");\n-                            if (disable)\n-                                return null;\n-\n-                            File file =\n-                                Files.createTempFile(\"rmid-err\", null).toFile();\n-                            PrintStream errStream =\n-                                new PrintStream(new FileOutputStream(file));\n-                            System.setErr(errStream);\n-                            return null;\n-                        }\n-                    });\n-\n-                ServerSocket serverSocket =\n-                    ((ServerSocketChannel) inheritedChannel).socket();\n-                port = serverSocket.getLocalPort();\n-                ssf = new ActivationServerSocketFactory(serverSocket);\n-\n-                System.err.println(new Date());\n-                System.err.println(getTextResource(\n-                                       \"rmid.inherited.channel.info\") +\n-                                       \": \" + inheritedChannel);\n-            }\n-\n-            String log = null;\n-            List<String> childArgs = new ArrayList<>();\n-\n-            \/*\n-             * Parse arguments\n-             *\/\n-            for (int i = 0; i < args.length; i++) {\n-                if (args[i].equals(\"-port\")) {\n-                    if (ssf != null) {\n-                        bomb(getTextResource(\"rmid.syntax.port.badarg\"));\n-                    }\n-                    if ((i + 1) < args.length) {\n-                        try {\n-                            port = Integer.parseInt(args[++i]);\n-                        } catch (NumberFormatException nfe) {\n-                            bomb(getTextResource(\"rmid.syntax.port.badnumber\"));\n-                        }\n-                    } else {\n-                        bomb(getTextResource(\"rmid.syntax.port.missing\"));\n-                    }\n-\n-                } else if (args[i].equals(\"-log\")) {\n-                    if ((i + 1) < args.length) {\n-                        log = args[++i];\n-                    } else {\n-                        bomb(getTextResource(\"rmid.syntax.log.missing\"));\n-                    }\n-\n-                } else if (args[i].equals(\"-stop\")) {\n-                    stop = true;\n-\n-                } else if (args[i].startsWith(\"-C\")) {\n-                    childArgs.add(args[i].substring(2));\n-\n-                } else {\n-                    bomb(MessageFormat.format(\n-                        getTextResource(\"rmid.syntax.illegal.option\"),\n-                        args[i]));\n-                }\n-            }\n-\n-            if (log == null) {\n-                if (ssf != null) {\n-                    bomb(getTextResource(\"rmid.syntax.log.required\"));\n-                } else {\n-                    log = \"log\";\n-                }\n-            }\n-\n-            debugExec = AccessController.doPrivileged(\n-                (PrivilegedAction<Boolean>) () -> Boolean.getBoolean(\"sun.rmi.server.activation.debugExec\"));\n-\n-            \/**\n-             * Determine class name for activation exec policy (if any).\n-             *\/\n-            String execPolicyClassName = AccessController.doPrivileged(\n-                (PrivilegedAction<String>) () -> System.getProperty(\"sun.rmi.activation.execPolicy\"));\n-            if (execPolicyClassName == null) {\n-                if (!stop) {\n-                    DefaultExecPolicy.checkConfiguration();\n-                }\n-                execPolicyClassName = \"default\";\n-            }\n-\n-            \/**\n-             * Initialize method for activation exec policy.\n-             *\/\n-            if (!execPolicyClassName.equals(\"none\")) {\n-                if (execPolicyClassName.isEmpty() ||\n-                    execPolicyClassName.equals(\"default\"))\n-                {\n-                    execPolicyClassName = DefaultExecPolicy.class.getName();\n-                }\n-\n-                try {\n-                    Class<?> execPolicyClass = getRMIClass(execPolicyClassName);\n-                    @SuppressWarnings(\"deprecation\")\n-                    Object tmp = execPolicyClass.newInstance();\n-                    execPolicy = tmp;\n-                    execPolicyMethod =\n-                        execPolicyClass.getMethod(\"checkExecCommand\",\n-                                                  ActivationGroupDesc.class,\n-                                                  String[].class);\n-                } catch (Exception e) {\n-                    if (debugExec) {\n-                        System.err.println(\n-                            getTextResource(\"rmid.exec.policy.exception\"));\n-                        e.printStackTrace();\n-                    }\n-                    bomb(getTextResource(\"rmid.exec.policy.invalid\"));\n-                }\n-            }\n-\n-            if (stop == true) {\n-                final int finalPort = port;\n-                AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-                    public Void run() {\n-                        System.setProperty(\"java.rmi.activation.port\",\n-                                           Integer.toString(finalPort));\n-                        return null;\n-                    }\n-                });\n-                ActivationSystem system = ActivationGroup.getSystem();\n-                system.shutdown();\n-                System.exit(0);\n-            }\n-\n-            System.err.println(getTextResource(\"rmid.deprecation.warning\"));\n-\n-            \/*\n-             * Fix for 4173960: Create and initialize activation using\n-             * a static method, startActivation, which will build the\n-             * Activation state in two ways: if when rmid is run, no\n-             * log file is found, the ActLogHandler.recover(...)\n-             * method will create a new Activation instance.\n-             * Alternatively, if a logfile is available, a serialized\n-             * instance of activation will be read from the log's\n-             * snapshot file.  Log updates will be applied to this\n-             * Activation object until rmid's state has been fully\n-             * recovered.  In either case, only one instance of\n-             * Activation is created.\n-             *\/\n-            startActivation(port, ssf, log,\n-                            childArgs.toArray(new String[childArgs.size()]));\n-\n-            \/\/ prevent activator from exiting\n-            while (true) {\n-                try {\n-                    Thread.sleep(Long.MAX_VALUE);\n-                } catch (InterruptedException e) {\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\n-                MessageFormat.format(\n-                    getTextResource(\"rmid.unexpected.exception\"), e));\n-            e.printStackTrace();\n-        }\n-        System.exit(1);\n-    }\n-\n-    \/**\n-     * Retrieves text resources from the locale-specific properties file.\n-     *\/\n-    private static String getTextResource(String key) {\n-        if (Activation.resources == null) {\n-            try {\n-                Activation.resources = ResourceBundle.getBundle(\n-                    \"sun.rmi.server.resources.rmid\");\n-            } catch (MissingResourceException mre) {\n-            }\n-            if (Activation.resources == null) {\n-                \/\/ throwing an Error is a bit extreme, methinks\n-                return (\"[missing resource file: \" + key + \"]\");\n-            }\n-        }\n-\n-        String val = null;\n-        try {\n-            val = Activation.resources.getString (key);\n-        } catch (MissingResourceException mre) {\n-        }\n-\n-        if (val == null) {\n-            return (\"[missing resource: \" + key + \"]\");\n-        } else {\n-            return val;\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    private static Class<?> getRMIClass(String execPolicyClassName) throws Exception  {\n-        return RMIClassLoader.loadClass(execPolicyClassName);\n-    }\n-    \/*\n-     * Dijkstra semaphore operations to limit the number of subprocesses\n-     * rmid attempts to make at once.\n-     *\/\n-    \/**\n-     * Acquire the group semaphore and return a group name.  Each\n-     * Pstartgroup must be followed by a Vstartgroup.  The calling thread\n-     * will wait until there are fewer than <code>N<\/code> other threads\n-     * holding the group semaphore.  The calling thread will then acquire\n-     * the semaphore and return.\n-     *\/\n-    private synchronized String Pstartgroup() throws ActivationException {\n-        while (true) {\n-            checkShutdown();\n-            \/\/ Wait until positive, then decrement.\n-            if (groupSemaphore > 0) {\n-                groupSemaphore--;\n-                return \"Group-\" + groupCounter++;\n-            }\n-\n-            try {\n-                wait();\n-            } catch (InterruptedException e) {\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Release the group semaphore.  Every P operation must be\n-     * followed by a V operation.  This may cause another thread to\n-     * wake up and return from its P operation.\n-     *\/\n-    private synchronized void Vstartgroup() {\n-        \/\/ Increment and notify a waiter (not necessarily FIFO).\n-        groupSemaphore++;\n-        notifyAll();\n-    }\n-\n-    \/**\n-     * A server socket factory to use when rmid is launched via 'inetd'\n-     * with 'wait' status.  This socket factory's 'createServerSocket'\n-     * method returns the server socket specified during construction that\n-     * is specialized to delay accepting requests until the\n-     * 'initDone' flag is 'true'.  The server socket supplied to\n-     * the constructor should be the server socket obtained from the\n-     * ServerSocketChannel returned from the 'System.inheritedChannel'\n-     * method.\n-     **\/\n-    private static class ActivationServerSocketFactory\n-        implements RMIServerSocketFactory\n-    {\n-        private final ServerSocket serverSocket;\n-\n-        \/**\n-         * Constructs an 'ActivationServerSocketFactory' with the specified\n-         * 'serverSocket'.\n-         **\/\n-        ActivationServerSocketFactory(ServerSocket serverSocket) {\n-            this.serverSocket = serverSocket;\n-        }\n-\n-        \/**\n-         * Returns the server socket specified during construction wrapped\n-         * in a 'DelayedAcceptServerSocket'.\n-         **\/\n-        public ServerSocket createServerSocket(int port)\n-            throws IOException\n-        {\n-            return new DelayedAcceptServerSocket(serverSocket);\n-        }\n-\n-    }\n-\n-    \/**\n-     * A server socket that delegates all public methods to the underlying\n-     * server socket specified at construction.  The accept method is\n-     * overridden to delay calling accept on the underlying server socket\n-     * until the 'initDone' flag is 'true'.\n-     **\/\n-    private static class DelayedAcceptServerSocket extends ServerSocket {\n-\n-        private final ServerSocket serverSocket;\n-\n-        DelayedAcceptServerSocket(ServerSocket serverSocket)\n-            throws IOException\n-        {\n-            this.serverSocket = serverSocket;\n-        }\n-\n-        public void bind(SocketAddress endpoint) throws IOException {\n-            serverSocket.bind(endpoint);\n-        }\n-\n-        public void bind(SocketAddress endpoint, int backlog)\n-                throws IOException\n-        {\n-            serverSocket.bind(endpoint, backlog);\n-        }\n-\n-        public InetAddress getInetAddress() {\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<InetAddress>() {\n-                    @Override\n-                    public InetAddress run() {\n-                        return serverSocket.getInetAddress();\n-                    }\n-                });\n-        }\n-\n-        public int getLocalPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        public SocketAddress getLocalSocketAddress() {\n-            return AccessController.doPrivileged(\n-                new PrivilegedAction<SocketAddress>() {\n-                    @Override\n-                    public SocketAddress run() {\n-                        return serverSocket.getLocalSocketAddress();\n-                    }\n-                });\n-        }\n-\n-        \/**\n-         * Delays calling accept on the underlying server socket until the\n-         * remote service is bound in the registry.\n-         **\/\n-        public Socket accept() throws IOException {\n-            synchronized (initLock) {\n-                try {\n-                    while (!initDone) {\n-                        initLock.wait();\n-                    }\n-                } catch (InterruptedException ignore) {\n-                    throw new AssertionError(ignore);\n-                }\n-            }\n-            return serverSocket.accept();\n-        }\n-\n-        public void close() throws IOException {\n-            serverSocket.close();\n-        }\n-\n-        public ServerSocketChannel getChannel() {\n-            return serverSocket.getChannel();\n-        }\n-\n-        public boolean isBound() {\n-            return serverSocket.isBound();\n-        }\n-\n-        public boolean isClosed() {\n-            return serverSocket.isClosed();\n-        }\n-\n-        public void setSoTimeout(int timeout)\n-            throws SocketException\n-        {\n-            serverSocket.setSoTimeout(timeout);\n-        }\n-\n-        public int getSoTimeout() throws IOException {\n-            return serverSocket.getSoTimeout();\n-        }\n-\n-        public void setReuseAddress(boolean on) throws SocketException {\n-            serverSocket.setReuseAddress(on);\n-        }\n-\n-        public boolean getReuseAddress() throws SocketException {\n-            return serverSocket.getReuseAddress();\n-        }\n-\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        public void setReceiveBufferSize(int size)\n-            throws SocketException\n-        {\n-            serverSocket.setReceiveBufferSize(size);\n-        }\n-\n-        public int getReceiveBufferSize()\n-            throws SocketException\n-        {\n-            return serverSocket.getReceiveBufferSize();\n-        }\n-    }\n-}\n-\n-\/**\n- * PipeWriter plugs together two pairs of input and output streams by\n- * providing readers for input streams and writing through to\n- * appropriate output streams.  Both output streams are annotated on a\n- * per-line basis.\n- *\n- * @author Laird Dornin, much code borrowed from Peter Jones, Ken\n- *         Arnold and Ann Wollrath.\n- *\/\n-class PipeWriter implements Runnable {\n-\n-    \/** stream used for buffering lines *\/\n-    private ByteArrayOutputStream bufOut;\n-\n-    \/** count since last separator *\/\n-    private int cLast;\n-\n-    \/** current chunk of input being compared to lineSeparator.*\/\n-    private byte[] currSep;\n-\n-    private PrintWriter out;\n-    private InputStream in;\n-\n-    private String pipeString;\n-    private String execString;\n-\n-    private static String lineSeparator;\n-    private static int lineSeparatorLength;\n-\n-    private static int numExecs = 0;\n-\n-    static {\n-        lineSeparator = AccessController.doPrivileged(\n-           (PrivilegedAction<String>) () -> System.getProperty(\"line.separator\"));\n-        lineSeparatorLength = lineSeparator.length();\n-    }\n-\n-    \/**\n-     * Create a new PipeWriter object. All methods of PipeWriter,\n-     * except plugTogetherPair, are only accesible to PipeWriter\n-     * itself.  Synchronization is unnecessary on functions that will\n-     * only be used internally in PipeWriter.\n-     *\n-     * @param in input stream from which pipe input flows\n-     * @param out output stream to which log messages will be sent\n-     * @param dest String which tags output stream as 'out' or 'err'\n-     * @param nExecs number of execed processes, Activation groups.\n-     *\/\n-    private PipeWriter\n-        (InputStream in, OutputStream out, String tag, int nExecs) {\n-\n-        this.in = in;\n-        this.out = new PrintWriter(out);\n-\n-        bufOut = new ByteArrayOutputStream();\n-        currSep = new byte[lineSeparatorLength];\n-\n-        \/* set unique pipe\/pair annotations *\/\n-        execString = \":ExecGroup-\" +\n-            Integer.toString(nExecs) + ':' + tag + ':';\n-    }\n-\n-    \/**\n-     * Create a thread to listen and read from input stream, in.  buffer\n-     * the data that is read until a marker which equals lineSeparator\n-     * is read.  Once such a string has been discovered; write out an\n-     * annotation string followed by the buffered data and a line\n-     * separator.\n-     *\/\n-    public void run() {\n-        byte[] buf = new byte[256];\n-        int count;\n-\n-        try {\n-            \/* read bytes till there are no more. *\/\n-            while ((count = in.read(buf)) != -1) {\n-                write(buf, 0, count);\n-            }\n-\n-            \/*  flush internal buffer... may not have ended on a line\n-             *  separator, we also need a last annotation if\n-             *  something was left.\n-             *\/\n-            String lastInBuffer = bufOut.toString();\n-            bufOut.reset();\n-            if (lastInBuffer.length() > 0) {\n-                out.println (createAnnotation() + lastInBuffer);\n-                out.flush();                    \/\/ add a line separator\n-                                                \/\/ to make output nicer\n-            }\n-\n-        } catch (IOException e) {\n-        }\n-    }\n-\n-    \/**\n-     * Write a subarray of bytes.  Pass each through write byte method.\n-     *\/\n-    private void write(byte b[], int off, int len) throws IOException {\n-\n-        if (len < 0) {\n-            throw new ArrayIndexOutOfBoundsException(len);\n-        }\n-        for (int i = 0; i < len; ++ i) {\n-            write(b[off + i]);\n-        }\n-    }\n-\n-    \/**\n-     * Write a byte of data to the stream.  If we have not matched a\n-     * line separator string, then the byte is appended to the internal\n-     * buffer.  If we have matched a line separator, then the currently\n-     * buffered line is sent to the output writer with a prepended\n-     * annotation string.\n-     *\/\n-    private void write(byte b) throws IOException {\n-        int i = 0;\n-\n-        \/* shift current to the left *\/\n-        for (i = 1 ; i < (currSep.length); i ++) {\n-            currSep[i-1] = currSep[i];\n-        }\n-        currSep[i-1] = b;\n-        bufOut.write(b);\n-\n-        \/* enough characters for a separator? *\/\n-        if ( (cLast >= (lineSeparatorLength - 1)) &&\n-             (lineSeparator.equals(new String(currSep))) ) {\n-\n-            cLast = 0;\n-\n-            \/* write prefix through to underlying byte stream *\/\n-            out.print(createAnnotation() + bufOut.toString());\n-            out.flush();\n-            bufOut.reset();\n-\n-            if (out.checkError()) {\n-                throw new IOException\n-                    (\"PipeWriter: IO Exception when\"+\n-                     \" writing to output stream.\");\n-            }\n-\n-        } else {\n-            cLast++;\n-        }\n-    }\n-\n-    \/**\n-     * Create an annotation string to be printed out after\n-     * a new line and end of stream.\n-     *\/\n-    private String createAnnotation() {\n-\n-        \/* construct prefix for log messages:\n-         * date\/time stamp...\n-         *\/\n-        return ((new Date()).toString()  +\n-                 \/* ... print pair # ... *\/\n-                 (execString));\n-    }\n-\n-    \/**\n-     * Allow plugging together two pipes at a time, to associate\n-     * output from an execed process.  This is the only publicly\n-     * accessible method of this object; this helps ensure that\n-     * synchronization will not be an issue in the annotation\n-     * process.\n-     *\n-     * @param in input stream from which pipe input comes\n-     * @param out output stream to which log messages will be sent\n-     * @param in1 input stream from which pipe input comes\n-     * @param out1 output stream to which log messages will be sent\n-     *\/\n-    static void plugTogetherPair(InputStream in,\n-                                 OutputStream out,\n-                                 InputStream in1,\n-                                 OutputStream out1) {\n-        Thread inThread = null;\n-        Thread outThread = null;\n-\n-        int nExecs = getNumExec();\n-\n-        \/* start RMI threads to read output from child process *\/\n-        inThread = AccessController.doPrivileged(\n-            new NewThreadAction(new PipeWriter(in, out, \"out\", nExecs),\n-                                \"out\", true));\n-        outThread = AccessController.doPrivileged(\n-            new NewThreadAction(new PipeWriter(in1, out1, \"err\", nExecs),\n-                                \"err\", true));\n-        inThread.start();\n-        outThread.start();\n-    }\n-\n-    private static synchronized int getNumExec() {\n-        return numExecs++;\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/Activation.java","additions":0,"deletions":2605,"binary":false,"changes":2605,"status":"deleted"},{"patch":"@@ -1,502 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.server;\n-\n-import java.io.IOException;\n-import java.lang.reflect.Constructor;\n-import java.lang.reflect.InvocationTargetException;\n-import java.net.ServerSocket;\n-import java.rmi.MarshalledObject;\n-import java.rmi.NoSuchObjectException;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.Activatable;\n-import java.rmi.activation.ActivationDesc;\n-import java.rmi.activation.ActivationException;\n-import java.rmi.activation.ActivationGroup;\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.activation.UnknownObjectException;\n-import java.rmi.server.RMIClassLoader;\n-import java.rmi.server.RMIServerSocketFactory;\n-import java.rmi.server.RMISocketFactory;\n-import java.rmi.server.UnicastRemoteObject;\n-import java.security.AccessController;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-import java.util.ArrayList;\n-import java.util.Hashtable;\n-import java.util.List;\n-import sun.rmi.registry.RegistryImpl;\n-\n-\/**\n- * The default activation group implementation.\n- *\n- * @author      Ann Wollrath\n- * @since       1.2\n- * @see         java.rmi.activation.ActivationGroup\n- *\/\n-@SuppressWarnings(\"removal\")\n-public class ActivationGroupImpl extends ActivationGroup {\n-\n-    \/\/ use serialVersionUID from JDK 1.2.2 for interoperability\n-    private static final long serialVersionUID = 5758693559430427303L;\n-\n-    \/** maps persistent IDs to activated remote objects *\/\n-    private final Hashtable<ActivationID,ActiveEntry> active =\n-        new Hashtable<>();\n-    private boolean groupInactive = false;\n-    private final ActivationGroupID groupID;\n-    @SuppressWarnings(\"serial\")  \/\/ Conditionally serializable\n-    private final List<ActivationID> lockedIDs = new ArrayList<>();\n-\n-    \/**\n-     * Creates a default activation group implementation.\n-     *\n-     * @param id the group's identifier\n-     * @param data ignored\n-     *\/\n-    public ActivationGroupImpl(ActivationGroupID id, MarshalledObject<?> data)\n-        throws RemoteException\n-    {\n-        super(id);\n-        groupID = id;\n-\n-        \/*\n-         * Unexport activation group impl and attempt to export it on\n-         * an unshared anonymous port.  See 4692286.\n-         *\/\n-        unexportObject(this, true);\n-        RMIServerSocketFactory ssf = new ServerSocketFactoryImpl();\n-        UnicastRemoteObject.exportObject(this, 0, null, ssf);\n-\n-        if (System.getSecurityManager() == null) {\n-            try {\n-                \/\/ Provide a default security manager.\n-                System.setSecurityManager(new SecurityManager());\n-\n-            } catch (Exception e) {\n-                throw new RemoteException(\"unable to set security manager\", e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Trivial server socket factory used to export the activation group\n-     * impl on an unshared port.\n-     *\/\n-    private static class ServerSocketFactoryImpl\n-        implements RMIServerSocketFactory\n-    {\n-        public ServerSocket createServerSocket(int port) throws IOException\n-        {\n-            RMISocketFactory sf = RMISocketFactory.getSocketFactory();\n-            if (sf == null) {\n-                sf = RMISocketFactory.getDefaultSocketFactory();\n-            }\n-            return sf.createServerSocket(port);\n-        }\n-    }\n-\n-    \/*\n-     * Obtains a lock on the ActivationID id before returning. Allows only one\n-     * thread at a time to hold a lock on a particular id.  If the lock for id\n-     * is in use, all requests for an equivalent (in the Object.equals sense)\n-     * id will wait for the id to be notified and use the supplied id as the\n-     * next lock. The caller of \"acquireLock\" must execute the \"releaseLock\"\n-     * method\" to release the lock and \"notifyAll\" waiters for the id lock\n-     * obtained from this method.  The typical usage pattern is as follows:\n-     *\n-     * try {\n-     *    acquireLock(id);\n-     *    \/\/ do stuff pertaining to id...\n-     * } finally {\n-     *    releaseLock(id);\n-     *    checkInactiveGroup();\n-     * }\n-     *\/\n-    private void acquireLock(ActivationID id) {\n-\n-        ActivationID waitForID;\n-\n-        for (;;) {\n-\n-            synchronized (lockedIDs) {\n-                int index = lockedIDs.indexOf(id);\n-                if (index < 0) {\n-                    lockedIDs.add(id);\n-                    return;\n-                } else {\n-                    waitForID = lockedIDs.get(index);\n-                }\n-            }\n-\n-            synchronized (waitForID) {\n-                synchronized (lockedIDs) {\n-                    int index = lockedIDs.indexOf(waitForID);\n-                    if (index < 0) continue;\n-                    ActivationID actualID = lockedIDs.get(index);\n-                    if (actualID != waitForID)\n-                        \/*\n-                         * don't wait on an id that won't be notified.\n-                         *\/\n-                        continue;\n-                }\n-\n-                try {\n-                    waitForID.wait();\n-                } catch (InterruptedException ignore) {\n-                }\n-            }\n-        }\n-\n-    }\n-\n-    \/*\n-     * Releases the id lock obtained via the \"acquireLock\" method and then\n-     * notifies all threads waiting on the lock.\n-     *\/\n-    private void releaseLock(ActivationID id) {\n-        synchronized (lockedIDs) {\n-            id = lockedIDs.remove(lockedIDs.indexOf(id));\n-        }\n-\n-        synchronized (id) {\n-            id.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * Creates a new instance of an activatable remote object. The\n-     * <code>Activator<\/code> calls this method to create an activatable\n-     * object in this group. This method should be idempotent; a call to\n-     * activate an already active object should return the previously\n-     * activated object.\n-     *\n-     * Note: this method assumes that the Activator will only invoke\n-     * newInstance for the same object in a serial fashion (i.e.,\n-     * the activator will not allow the group to see concurrent requests\n-     * to activate the same object.\n-     *\n-     * @param id the object's activation identifier\n-     * @param desc the object's activation descriptor\n-     * @return a marshalled object containing the activated object's stub\n-     *\/\n-    public MarshalledObject<? extends Remote>\n-                                      newInstance(final ActivationID id,\n-                                                  final ActivationDesc desc)\n-        throws ActivationException, RemoteException\n-    {\n-        RegistryImpl.checkAccess(\"ActivationInstantiator.newInstance\");\n-\n-        if (!groupID.equals(desc.getGroupID()))\n-            throw new ActivationException(\"newInstance in wrong group\");\n-\n-        try {\n-            acquireLock(id);\n-            synchronized (this) {\n-                if (groupInactive == true)\n-                    throw new InactiveGroupException(\"group is inactive\");\n-            }\n-\n-            ActiveEntry entry = active.get(id);\n-            if (entry != null)\n-                return entry.mobj;\n-\n-            String className = desc.getClassName();\n-\n-            final Class<? extends Remote> cl =\n-                RMIClassLoader.loadClass(desc.getLocation(), className)\n-                .asSubclass(Remote.class);\n-            Remote impl = null;\n-\n-            final Thread t = Thread.currentThread();\n-            final ClassLoader savedCcl = t.getContextClassLoader();\n-            ClassLoader objcl = cl.getClassLoader();\n-            final ClassLoader ccl = covers(objcl, savedCcl) ? objcl : savedCcl;\n-\n-            \/*\n-             * Fix for 4164971: allow non-public activatable class\n-             * and\/or constructor, create the activatable object in a\n-             * privileged block\n-             *\/\n-            try {\n-                \/*\n-                 * The code below is in a doPrivileged block to\n-                 * protect against user code which code might have set\n-                 * a global socket factory (in which case application\n-                 * code would be on the stack).\n-                 *\/\n-                impl = AccessController.doPrivileged(\n-                      new PrivilegedExceptionAction<Remote>() {\n-                      public Remote run() throws InstantiationException,\n-                          NoSuchMethodException, IllegalAccessException,\n-                          InvocationTargetException\n-                      {\n-                          Constructor<? extends Remote> constructor =\n-                              cl.getDeclaredConstructor(\n-                                  ActivationID.class, MarshalledObject.class);\n-                          constructor.setAccessible(true);\n-                          try {\n-                              \/*\n-                               * Fix for 4289544: make sure to set the\n-                               * context class loader to be the class\n-                               * loader of the impl class before\n-                               * constructing that class.\n-                               *\/\n-                              t.setContextClassLoader(ccl);\n-                              return constructor.newInstance(id,\n-                                                             desc.getData());\n-                          } finally {\n-                              t.setContextClassLoader(savedCcl);\n-                          }\n-                      }\n-                  });\n-            } catch (PrivilegedActionException pae) {\n-                Throwable e = pae.getException();\n-\n-                \/\/ narrow the exception's type and rethrow it\n-                if (e instanceof InstantiationException) {\n-                    throw (InstantiationException) e;\n-                } else if (e instanceof NoSuchMethodException) {\n-                    throw (NoSuchMethodException) e;\n-                } else if (e instanceof IllegalAccessException) {\n-                    throw (IllegalAccessException) e;\n-                } else if (e instanceof InvocationTargetException) {\n-                    throw (InvocationTargetException) e;\n-                } else if (e instanceof RuntimeException) {\n-                    throw (RuntimeException) e;\n-                } else if (e instanceof Error) {\n-                    throw (Error) e;\n-                }\n-            }\n-\n-            entry = new ActiveEntry(impl);\n-            active.put(id, entry);\n-            return entry.mobj;\n-\n-        } catch (NoSuchMethodException | NoSuchMethodError e) {\n-            \/* user forgot to provide activatable constructor?\n-             * or code recompiled and user forgot to provide\n-             *  activatable constructor?\n-             *\/\n-            throw new ActivationException\n-                (\"Activatable object must provide an activation\"+\n-                 \" constructor\", e );\n-\n-        } catch (InvocationTargetException e) {\n-            throw new ActivationException(\"exception in object constructor\",\n-                                          e.getCause());\n-\n-        } catch (Exception e) {\n-            throw new ActivationException(\"unable to activate object\", e);\n-        } finally {\n-            releaseLock(id);\n-            checkInactiveGroup();\n-        }\n-    }\n-\n-\n-   \/**\n-    * The group's <code>inactiveObject<\/code> method is called\n-    * indirectly via a call to the <code>Activatable.inactive<\/code>\n-    * method. A remote object implementation must call\n-    * <code>Activatable<\/code>'s <code>inactive<\/code> method when\n-    * that object deactivates (the object deems that it is no longer\n-    * active). If the object does not call\n-    * <code>Activatable.inactive<\/code> when it deactivates, the\n-    * object will never be garbage collected since the group keeps\n-    * strong references to the objects it creates. <p>\n-    *\n-    * The group's <code>inactiveObject<\/code> method\n-    * unexports the remote object from the RMI runtime so that the\n-    * object can no longer receive incoming RMI calls. This call will\n-    * only succeed if the object has no pending\/executing calls. If\n-    * the object does have pending\/executing RMI calls, then false\n-    * will be returned.\n-    *\n-    * If the object has no pending\/executing calls, the object is\n-    * removed from the RMI runtime and the group informs its\n-    * <code>ActivationMonitor<\/code> (via the monitor's\n-    * <code>inactiveObject<\/code> method) that the remote object is\n-    * not currently active so that the remote object will be\n-    * re-activated by the activator upon a subsequent activation\n-    * request.\n-    *\n-    * @param id the object's activation identifier\n-    * @return true if the operation succeeds (the operation will\n-    * succeed if the object in currently known to be active and is\n-    * either already unexported or is currently exported and has no\n-    * pending\/executing calls); false is returned if the object has\n-    * pending\/executing calls in which case it cannot be deactivated\n-    * @exception UnknownObjectException if object is unknown (may already\n-    * be inactive)\n-    * @exception RemoteException if call informing monitor fails\n-    *\/\n-    public boolean inactiveObject(ActivationID id)\n-        throws ActivationException, UnknownObjectException, RemoteException\n-    {\n-\n-        try {\n-            acquireLock(id);\n-            synchronized (this) {\n-                if (groupInactive == true)\n-                    throw new ActivationException(\"group is inactive\");\n-            }\n-\n-            ActiveEntry entry = active.get(id);\n-            if (entry == null) {\n-                \/\/ REMIND: should this be silent?\n-                throw new UnknownObjectException(\"object not active\");\n-            }\n-\n-            try {\n-                if (Activatable.unexportObject(entry.impl, false) == false)\n-                    return false;\n-            } catch (NoSuchObjectException allowUnexportedObjects) {\n-            }\n-\n-            try {\n-                super.inactiveObject(id);\n-            } catch (UnknownObjectException allowUnregisteredObjects) {\n-            }\n-\n-            active.remove(id);\n-\n-        } finally {\n-            releaseLock(id);\n-            checkInactiveGroup();\n-        }\n-\n-        return true;\n-    }\n-\n-    \/*\n-     * Determines if the group has become inactive and\n-     * marks it as such.\n-     *\/\n-    private void checkInactiveGroup() {\n-        boolean groupMarkedInactive = false;\n-        synchronized (this) {\n-            if (active.size() == 0 && lockedIDs.size() == 0 &&\n-                groupInactive == false)\n-            {\n-                groupInactive = true;\n-                groupMarkedInactive = true;\n-            }\n-        }\n-\n-        if (groupMarkedInactive) {\n-            try {\n-                super.inactiveGroup();\n-            } catch (Exception ignoreDeactivateFailure) {\n-            }\n-\n-            try {\n-                UnicastRemoteObject.unexportObject(this, true);\n-            } catch (NoSuchObjectException allowUnexportedGroup) {\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * The group's <code>activeObject<\/code> method is called when an\n-     * object is exported (either by <code>Activatable<\/code> object\n-     * construction or an explicit call to\n-     * <code>Activatable.exportObject<\/code>. The group must inform its\n-     * <code>ActivationMonitor<\/code> that the object is active (via\n-     * the monitor's <code>activeObject<\/code> method) if the group\n-     * hasn't already done so.\n-     *\n-     * @param id the object's identifier\n-     * @param impl the remote object implementation\n-     * @exception UnknownObjectException if object is not registered\n-     * @exception RemoteException if call informing monitor fails\n-     *\/\n-    public void activeObject(ActivationID id, Remote impl)\n-        throws ActivationException, UnknownObjectException, RemoteException\n-    {\n-\n-        try {\n-            acquireLock(id);\n-            synchronized (this) {\n-                if (groupInactive == true)\n-                    throw new ActivationException(\"group is inactive\");\n-            }\n-            if (!active.containsKey(id)) {\n-                ActiveEntry entry = new ActiveEntry(impl);\n-                active.put(id, entry);\n-                \/\/ created new entry, so inform monitor of active object\n-                try {\n-                    super.activeObject(id, entry.mobj);\n-                } catch (RemoteException e) {\n-                    \/\/ daemon can still find it by calling newInstance\n-                }\n-            }\n-        } finally {\n-            releaseLock(id);\n-            checkInactiveGroup();\n-        }\n-    }\n-\n-    \/**\n-     * Entry in table for active object.\n-     *\/\n-    private static class ActiveEntry {\n-        Remote impl;\n-        MarshalledObject<Remote> mobj;\n-\n-        ActiveEntry(Remote impl) throws ActivationException {\n-            this.impl =  impl;\n-            try {\n-                this.mobj = new MarshalledObject<Remote>(impl);\n-            } catch (IOException e) {\n-                throw new\n-                    ActivationException(\"failed to marshal remote object\", e);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Returns true if the first argument is either equal to, or is a\n-     * descendant of, the second argument.  Null is treated as the root of\n-     * the tree.\n-     *\/\n-    private static boolean covers(ClassLoader sub, ClassLoader sup) {\n-        if (sup == null) {\n-            return true;\n-        } else if (sub == null) {\n-            return false;\n-        }\n-        do {\n-            if (sub == sup) {\n-                return true;\n-            }\n-            sub = sub.getParent();\n-        } while (sub != null);\n-        return false;\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/ActivationGroupImpl.java","additions":0,"deletions":502,"binary":false,"changes":502,"status":"deleted"},{"patch":"@@ -1,86 +0,0 @@\n-\/*\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.server;\n-\n-import java.rmi.activation.ActivationGroupDesc;\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.activation.ActivationGroup;\n-\n-\/**\n- * This is the bootstrap code to start a VM executing an activation\n- * group.\n- *\n- * The activator spawns (as a child process) an activation group as needed\n- * and directs activation requests to the appropriate activation\n- * group. After spawning the VM, the activator passes some\n- * information to the bootstrap code via its stdin:\n- * <ul>\n- * <li> the activation group's id,\n- * <li> the activation group's descriptor (an instance of the class\n- *    java.rmi.activation.ActivationGroupDesc) for the group, adn\n- * <li> the group's incarnation number.\n- * <\/ul><p>\n- *\n- * When the bootstrap VM starts executing, it reads group id and\n- * descriptor from its stdin so that it can create the activation\n- * group for the VM.\n- *\n- * @author Ann Wollrath\n- *\/\n-@SuppressWarnings(\"removal\")\n-public abstract class ActivationGroupInit\n-{\n-    \/**\n-     * Main program to start a VM for an activation group.\n-     *\/\n-    public static void main(String args[])\n-    {\n-        try {\n-            if (System.getSecurityManager() == null) {\n-                System.setSecurityManager(new SecurityManager());\n-            }\n-            \/\/ read group id, descriptor, and incarnation number from stdin\n-            MarshalInputStream in = new MarshalInputStream(System.in);\n-            ActivationGroupID id  = (ActivationGroupID)in.readObject();\n-            ActivationGroupDesc desc = (ActivationGroupDesc)in.readObject();\n-            long incarnation = in.readLong();\n-\n-            \/\/ create and set group for the VM\n-            ActivationGroup.createGroup(id, desc, incarnation);\n-        } catch (Exception e) {\n-            System.err.println(\"Exception in starting ActivationGroupInit:\");\n-            e.printStackTrace();\n-        } finally {\n-            try {\n-                System.in.close();\n-                \/\/ note: system out\/err shouldn't be closed\n-                \/\/ since the parent may want to read them.\n-            } catch (Exception ex) {\n-                \/\/ ignore exceptions\n-            }\n-        }\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/ActivationGroupInit.java","additions":0,"deletions":86,"binary":false,"changes":86,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package sun.rmi.server;\n-\n-import java.rmi.activation.ActivationException;\n-\n-\/**\n- * Thrown if a local or remote call is made on a group implementation\n- * instance that is inactive.\n- *\n- * @author Sun Microsystems, Inc.\n- *\n- * @since 1.6\n- *\/\n-@SuppressWarnings(\"removal\")\n-public class InactiveGroupException extends ActivationException {\n-\n-    private static final long serialVersionUID = -7491041778450214975L;\n-\n-    \/**\n-     * Constructs an instance with the specified detail message.\n-     *\n-     * @param s the detail message\n-     *\/\n-    public InactiveGroupException(String s) {\n-        super(s);\n-    }\n-}\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/InactiveGroupException.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -89,10 +89,0 @@\n-     * Fix for 4179055: The remote object services inside the\n-     * activation daemon use stubs that are in the package\n-     * sun.rmi.server.  Classes for these stubs should be loaded from\n-     * the classpath by RMI system code and not by the normal\n-     * unmarshalling process as applications should not need to have\n-     * permission to access the sun implementation classes.\n-     *\n-     * Note: this fix should be redone when API changes may be\n-     * integrated\n-     *\n@@ -100,1 +90,1 @@\n-     * access to three sun.* stub classes\n+     * access to sun.* stub classes\n@@ -104,2 +94,0 @@\n-            String system =\n-                \"sun.rmi.server.Activation$ActivationSystemImpl_Stub\";\n@@ -107,2 +95,0 @@\n-\n-            permittedSunClasses.put(system, Class.forName(system));\n@@ -110,1 +96,0 @@\n-\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/MarshalInputStream.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -1,136 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=\\\n-        rmid was launched from inetd with an invalid status (must be wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=\\\n-\tport cannot be specified if rmid is launched from inetd\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=\\\n-\tport is not a number\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=\\\n-\t-port option requires argument\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=\\\n-\t-log option requires argument\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=\\\n-\t-log option required\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=\\\n-\tinvalid option: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=\\\n-\tActivation.main: an exception occurred: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=\\\n-\tActivatorImpl: unable to locate java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=\\\n-\trmid startup with inherited channel\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=\\\n-\tActivation.main: invalid exec policy class\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=\\\n-\trmid: attempt to obtain exec policy throws:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=\\\n-\trmid: debugExec: running \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=\\\n-\trmid: activation group inactive: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=\\\n-\tActivation.main: warning: sun.rmi.activation.execPolicy system\\n\\\n-    property unspecified and no ExecPermissions\/ExecOptionPermissions\\n\\\n-    granted; subsequent activation attempts may fail due to unsuccessful\\n\\\n-    ExecPermission\/ExecOptionPermission permission checks. \\n\\\n-    To configure security, refer to the rmid documentation.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Usage: {0} <options>\\\n-\\n\\\n-\\nwhere <options> include:\\\n-\\n  -port <port>        Specify port for rmid to use\\\n-\\n  -log <directory>    Specify directory in which rmid writes log\\\n-\\n  -stop               Stop current invocation of rmid (for specified port)\\\n-\\n  -C<runtime flag>    Pass argument to each child process (activation group)\\\n-\\n  -J<runtime flag>    Pass argument to the java interpreter\\\n-\\n\\\n-\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=\\\n-\tactivation daemon shut down\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\\n-\\nrmid: (WARNING) restart group throws:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\\n-\\nrmid: (WARNING) restart service throws:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\\n-\\nrmid: (WARNING) log update throws:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\\n-\\nrmid: (SEVERE) log snapshot throws:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\\n-\\nrmid: (WARNING) {0}: skipping log record during recovery:\n-\n-# \"rmid\" should not be translated\n-rmid.deprecation.warning=\\\n-\trmid: (WARNING) The RMI Activation mechanism and the rmid tool\\n\\\n-    have been deprecated for removal. They may be removed from a future\\n\\\n-    version of the Java Platform.\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid.properties","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid wurde mit einem ung\\u00FCltigen Status (muss \"wait\" sein) von inetd gestartet\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=Port kann nicht angegeben werden, wenn rmid von inetd gestartet wird\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=Port ist keine Zahl\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=F\\u00FCr Option -port ist ein Argument erforderlich\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=F\\u00FCr Option -log ist ein Argument erforderlich\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=Option -log ist erforderlich\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=Ung\\u00FCltige Option: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: Es ist eine Ausnahme aufgetreten: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: java.home konnte nicht gefunden werden\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=rmid-Start mit \\u00FCbernommenem Kanal\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: Ung\\u00FCltige exec-Policy-Klasse\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: Versuch, die exec-Policy abzurufen, l\\u00F6st Folgendes aus:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: \"{0}\" wird ausgef\\u00FChrt\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: Aktivierungsgruppe inaktiv: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: Warnung: Es wurde keine Systemeigenschaft sun.rmi.activation.execPolicy\\nangegeben und keine ExecPermissions\/ExecOptionPermissions\\nerteilt. Nachfolgende Aktivierungsversuche scheitern m\\u00F6glicherweise aufgrund\\nnicht erfolgreicher Berechtigungspr\\u00FCfungen ExecPermission\/ExecOptionPermission. \\nInformationen zur Sicherheitskonfiguration finden Sie in der rmid-Dokumentation.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Verwendung: {0} <Optionen>\\n\\nwobei folgende <Optionen> m\\u00F6glich sind:\\n  -port <Port>        Port f\\u00FCr rmid angeben\\n  -log <Verzeichnis>    Verzeichnis, in das rmid die Logdatei schreibt, angeben\\n  -stop               Aktuellen Aufruf von rmid stoppen (f\\u00FCr den angegebenen Port)\\n  -C<Laufzeitkennzeichen>    Argument an jeden untergeordneten Prozess (Aktivierungsgruppe) \\u00FCbergeben\\n  -J<Laufzeitkennzeichen>    Argument an den Java-Interpreter \\u00FCbergeben\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=Aktivierungsdaemon heruntergefahren\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (WARNUNG) Neustart der Gruppe l\\u00F6st Folgendes aus:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (WARNUNG) Neustart des Service l\\u00F6st Folgendes aus:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (WARNUNG) Logupdate l\\u00F6st Folgendes aus:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (SCHWERWIEGEND) Log-Snapshot l\\u00F6st Folgendes aus:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (WARNUNG) {0}: Logdatensatz wird bei Wiederherstellung \\u00FCbersprungen:\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_de.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid se ha iniciado desde inetd con un estado no v\\u00E1lido (debe ser wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=no se puede especificar el puerto si rmid se ha iniciado desde inetd\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=el puerto no es un n\\u00FAmero\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=la opci\\u00F3n -port requiere un argumento\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=la opci\\u00F3n -log requiere un argumento\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=la opci\\u00F3n -log es obligatoria\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=opci\\u00F3n no permitida: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: se ha producido una excepci\\u00F3n: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: no se ha encontrado java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=inicio de rmid con canal heredado\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: clase de pol\\u00EDtica de ejecuci\\u00F3n no v\\u00E1lida\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: el intento de obtener la pol\\u00EDtica de ejecuci\\u00F3n devuelve:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: en ejecuci\\u00F3n \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: grupo de activaci\\u00F3n inactivo: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: advertencia: no se han especificado las propiedades del sistema sun.rmi.activation.execPolicy\\ny no se han otorgado ExecPermissions\/ExecOptionPermissions;\\nlos intentos de activaci\\u00F3n posteriores pueden fallar debido a\\ncomprobaciones de permiso ExecPermission\/ExecOptionPermission incorrectas. \\nPara configurar la seguridad, consulte la documentaci\\u00F3n sobre rmid.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Sintaxis: {0} <opciones>\\n\\ndonde <opciones> incluye:\\n  -port <puerto>      Especificar puerto para uso de rmid\\n  -log <directorio>   Especificar directorio en el que rmid escribir\\u00E1 el registro\\n  -stop               Parar la llamada actual de rmid (para el puerto especificado)\\n  -C<indicador de tiempo de ejecuci\\u00F3n> Pasar argumento a cada uno de los procesos secundarios (grupo de activaci\\u00F3n)\\n  -J<indicador de tiempo de ejecuci\\u00F3n> Pasar argumento al int\\u00E9rprete de Java\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=daemon de activaci\\u00F3n cerrado\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (ADVERTENCIA) el reinicio del grupo devuelve:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (ADVERTENCIA) el reinicio del servicio devuelve:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (ADVERTENCIA) la actualizaci\\u00F3n del log indica:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (GRAVE) la instant\\u00E1nea del log indica:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (ADVERTENCIA) {0}: se omitir\\u00E1 el registro del log durante la recuperaci\\u00F3n:\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_es.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid a \\u00E9t\\u00E9 lanc\\u00E9 depuis inetd avec un statut non valide (doit \\u00EAtre wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=impossible de sp\\u00E9cifier port si rmid est lanc\\u00E9 depuis inetd\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=port n'est pas un num\\u00E9ro\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=l'option -port exige un argument\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=l'option -log exige un argument\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=option -log obligatoire\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=option non admise : {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main : une exception s''est produite - {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl : impossible de localiser java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=d\\u00E9marrage de rmid avec le canal existant\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main : classe de r\\u00E8gle exec incorrecte\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid : tentative d'obtention des basculements de classes exec :\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid : debugExec : ex\\u00E9cution de \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid : groupe d''activation inactif : {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main : avertissement : propri\\u00E9t\\u00E9 syst\\u00E8me sun.rmi.activation.execPolicy\\nnon indiqu\\u00E9e et ExecPermissions\/ExecOptionPermissions\\nnon accord\\u00E9s ; les tentatives d'activation suivantes risquent d'\\u00E9chouer en raison de la v\\u00E9rification des droits\\nExecPermission\/ExecOptionPermission. \\nPour configurer la s\\u00E9curit\\u00E9, reportez-vous \\u00E0 la documentation rmid.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Syntaxe : {0} <options>\\n\\no\\u00F9 <options> comprend :\\n  -port <port>        Port que rmid doit utiliser\\n  -log <r\\u00E9pertoire>    R\\u00E9pertoire o\\u00F9 rmid enregistre le journal\\n  -stop               Arr\\u00EAter l''appel en cours de rmid (pour le port sp\\u00E9cifi\\u00E9)\\n  -C<indicateur d''ex\\u00E9cution>    Transmet l''argument \\u00E0 chaque processus enfant (groupe d''activation)\\n  -J<indicateur d''ex\\u00E9cution>    Transmet l''argument \\u00E0 l''interpr\\u00E9teur Java\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=d\\u00E9mon d'activation arr\\u00EAt\\u00E9\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid : (AVERTISSEMENT) red\\u00E9marrer les basculements de groupes :\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid : (AVERTISSEMENT) red\\u00E9marrer les basculements de services :\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid : (AVERTISSEMENT) consigner les basculements de mises \\u00E0 jour :\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid : (GRAVE) consigner les basculements de clich\\u00E9s :\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid : (AVERTISSEMENT) {0} : enregistrement du journal ignor\\u00E9 lors de la r\\u00E9cup\\u00E9ration :\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_fr.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid \\u00E8 stato avviato da inetd con uno stato non valido (diverso da wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=non \\u00E8 possibile specificare la porta se rmid viene avviato da inetd\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=la porta non \\u00E8 un numero\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=L'opzione -port richiede un argomento\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=L'opzione -log richiede un argomento\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=\\u00C8 richiesta l'opzione -log\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=opzione non valida: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: si \\u00E8 verificata un''eccezione: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: impossibile individuare java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=Avvio di rmid con canale ereditato\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: classe di criteri eseguibili non valida\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: il tentativo di ottenere i criteri di esecuzione ha restituito:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: esecuzione di \"{0}\" in corso\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: gruppo attivazione inattivo: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: avvertenza: propriet\\u00E0 di sistema sun.rmi.activation.execPolicy\\nnon specificata e nessun ExecPermissions\/ExecOptionPermissions\\nconcesso. I tentativi di attivazione successivi potrebbero fallire a causa di \\ncontrolli di autorizzazione ExecPermission\/ExecOptionPermission non riusciti.\\nPer configurare la sicurezza, fare riferimento alla documentazione rmid.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Uso: {0} <opzioni>\\n\\ndove <opzioni> include:\\n  -port <porta>       Specifica la porta usata da rmid\\n  -log <directory>    Specifica la directory in cui rmid scrive il log\\n  -stop              Arresta l''invocazione corrente di rmid (per la porta specificata)\\n  -C<flag fase di esecuzione>    Passa l''argomento a ciascun processo figlio (gruppo di attivazione)\\n  -J<flag fase di esecuzione>    Passa l''argomento all''interprete java\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=daemon di attivazione terminato\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (AVVERTENZA) il riavvio del gruppo ha restituito:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (AVVERTENZA) il riavvio del servizio ha restituito:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (AVVERTENZA) il log dell'aggiornamento ha restituito:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (GRAVE) snapshot log ha restituito:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (AVVERTENZA) {0}: record del log ignorato durante il recupero:\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_it.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid\\u304Cinetd\\u304B\\u3089\\u7121\\u52B9\\u306A\\u72B6\\u614B\\u3067\\u8D77\\u52D5\\u3055\\u308C\\u307E\\u3057\\u305F(wait\\u3067\\u3042\\u308B\\u5FC5\\u8981\\u304C\\u3042\\u308A\\u307E\\u3059)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=rmid\\u304Cinetd\\u304B\\u3089\\u8D77\\u52D5\\u3055\\u308C\\u305F\\u5834\\u5408\\u3001\\u30DD\\u30FC\\u30C8\\u306F\\u6307\\u5B9A\\u3067\\u304D\\u307E\\u305B\\u3093\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=port\\u306F\\u756A\\u53F7\\u3067\\u306F\\u3042\\u308A\\u307E\\u305B\\u3093\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=-port\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306B\\u306F\\u5F15\\u6570\\u304C\\u5FC5\\u8981\\u3067\\u3059\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=-log\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u306B\\u306F\\u5F15\\u6570\\u304C\\u5FC5\\u8981\\u3067\\u3059\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=-log\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3\\u304C\\u5FC5\\u8981\\u3067\\u3059\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=\\u7121\\u52B9\\u306A\\u30AA\\u30D7\\u30B7\\u30E7\\u30F3: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: \\u4F8B\\u5916\\u304C\\u767A\\u751F\\u3057\\u307E\\u3057\\u305F: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: java.home\\u3092\\u691C\\u51FA\\u3067\\u304D\\u307E\\u305B\\u3093\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=rmid\\u306F\\u7D99\\u627F\\u3055\\u308C\\u305F\\u30C1\\u30E3\\u30CD\\u30EB\\u3067\\u8D77\\u52D5\\u3057\\u307E\\u3059\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: \\u7121\\u52B9\\u306A\\u5B9F\\u884C\\u30DD\\u30EA\\u30B7\\u30FC\\u30FB\\u30AF\\u30E9\\u30B9\\u3067\\u3059\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: \\u5B9F\\u884C\\u30DD\\u30EA\\u30B7\\u30FC\\u306E\\u53D6\\u5F97\\u3067\\u6B21\\u304C\\u30B9\\u30ED\\u30FC\\u3055\\u308C\\u307E\\u3057\\u305F:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: \"{0}\"\\u3092\\u5B9F\\u884C\\u4E2D\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: \\u8D77\\u52D5\\u30B0\\u30EB\\u30FC\\u30D7\\u304C\\u505C\\u6B62\\u3057\\u3066\\u3044\\u307E\\u3059: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: \\u8B66\\u544A:sun.rmi.activation.execPolicy\\u30B7\\u30B9\\u30C6\\u30E0\\n\\u30D7\\u30ED\\u30D1\\u30C6\\u30A3\\u304C\\u6307\\u5B9A\\u3055\\u308C\\u3066\\u3044\\u306A\\u3044\\u3001\\u307E\\u305F\\u306FExecPermissions\/ExecOptionPermissions\\u304C\\n\\u8A31\\u53EF\\u3055\\u308C\\u307E\\u305B\\u3093\\u3002ExecPermissions\/ExecOptionPermissions\\u30A2\\u30AF\\u30BB\\u30B9\\u6A29\\u691C\\u67FB\\u3067\\u8A31\\u53EF\\u3055\\u308C\\n\\u306A\\u3044\\u305F\\u3081\\u3001\\u5F8C\\u306B\\u7D9A\\u304F\\u8D77\\u52D5\\u306F\\u5931\\u6557\\u3059\\u308B\\u53EF\\u80FD\\u6027\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002\\n\\u30BB\\u30AD\\u30E5\\u30EA\\u30C6\\u30A3\\u3092\\u78BA\\u8A8D\\u3059\\u308B\\u306B\\u306F\\u3001rmid\\u306E\\u30C9\\u30AD\\u30E5\\u30E1\\u30F3\\u30C8\\u3092\\u53C2\\u7167\\u3057\\u3066\\u304F\\u3060\\u3055\\u3044\\u3002\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=\\u4F7F\\u7528\\u65B9\\u6CD5: {0} <options>\\n\\n<options>\\u306B\\u306F\\u6B21\\u306E\\u3082\\u306E\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002\\n -port<port>     rmid\\u304C\\u4F7F\\u7528\\u3059\\u308B\\u30DD\\u30FC\\u30C8\\u3092\\u6307\\u5B9A\\u3059\\u308B\\n -log <directory>  rmid\\u304C\\u30ED\\u30B0\\u3092\\u66F8\\u304D\\u8FBC\\u3080\\u30C7\\u30A3\\u30EC\\u30AF\\u30C8\\u30EA\\u3092\\u6307\\u5B9A\\u3059\\u308B\\n -stop         \\u6307\\u5B9A\\u30DD\\u30FC\\u30C8\\u306B\\u5BFE\\u3059\\u308Brmid\\u306E\\u73FE\\u5728\\u306E\\u547C\\u51FA\\u3057\\u3092\\u4E2D\\u6B62\\u3059\\u308B\\n -C<runtime flag>   \\u5404\\u5B50\\u30D7\\u30ED\\u30BB\\u30B9(\\u8D77\\u52D5\\u30B0\\u30EB\\u30FC\\u30D7)\\u306B\\u5F15\\u6570\\u3092\\u6E21\\u3059\\n -J<runtime flag>  java\\u30A4\\u30F3\\u30BF\\u30D7\\u30EA\\u30BF\\u306B\\u5F15\\u6570\\u3092\\u6E21\\u3059\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=\\u8D77\\u52D5\\u30C7\\u30FC\\u30E2\\u30F3\\u304C\\u505C\\u6B62\\u3057\\u307E\\u3057\\u305F\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (\\u8B66\\u544A)\\u30B0\\u30EB\\u30FC\\u30D7\\u306E\\u518D\\u8D77\\u52D5\\u3067\\u6B21\\u304C\\u30B9\\u30ED\\u30FC\\u3055\\u308C\\u307E\\u3057\\u305F:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (\\u8B66\\u544A)\\u30B5\\u30FC\\u30D3\\u30B9\\u306E\\u518D\\u8D77\\u52D5\\u3067\\u6B21\\u304C\\u30B9\\u30ED\\u30FC\\u3055\\u308C\\u307E\\u3057\\u305F:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (\\u8B66\\u544A)\\u30ED\\u30B0\\u66F4\\u65B0\\u3067\\u6B21\\u304C\\u30B9\\u30ED\\u30FC\\u3055\\u308C\\u307E\\u3057\\u305F:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (\\u91CD\\u5927)\\u30ED\\u30B0\\u30FB\\u30B9\\u30CA\\u30C3\\u30D7\\u30B7\\u30E7\\u30C3\\u30C8\\u3067\\u6B21\\u304C\\u30B9\\u30ED\\u30FC\\u3055\\u308C\\u307E\\u3057\\u305F:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (\\u8B66\\u544A){0}: \\u56DE\\u5FA9\\u4E2D\\u306E\\u30ED\\u30B0\\u30FB\\u30EC\\u30B3\\u30FC\\u30C9\\u306E\\u30B9\\u30AD\\u30C3\\u30D7:\n-\n-# \"rmid\" should not be translated\n-rmid.deprecation.warning=rmid: (\\u8B66\\u544A) RMI\\u8D77\\u52D5\\u30E1\\u30AB\\u30CB\\u30BA\\u30E0\\u304A\\u3088\\u3073rmid\\u30C4\\u30FC\\u30EB\\u306F\\u524A\\u9664\\u4E88\\u5B9A\\u306E\\u305F\\u3081\\n\\u975E\\u63A8\\u5968\\u306B\\u306A\\u308A\\u307E\\u3057\\u305F\\u3002\\u3053\\u308C\\u3089\\u306F\\u3001Java\\u30D7\\u30E9\\u30C3\\u30C8\\u30D5\\u30A9\\u30FC\\u30E0\\u306E\\u5C06\\u6765\\u306E\\u30D0\\u30FC\\u30B8\\u30E7\\u30F3\\n\\u304B\\u3089\\u524A\\u9664\\u3055\\u308C\\u308B\\u53EF\\u80FD\\u6027\\u304C\\u3042\\u308A\\u307E\\u3059\\u3002\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_ja.properties","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid\\uAC00 \\uBD80\\uC801\\uD569\\uD55C \\uC0C1\\uD0DC\\uC758 inetd\\uC5D0\\uC11C \\uC2DC\\uC791\\uB418\\uC5C8\\uC2B5\\uB2C8\\uB2E4. \\uC0C1\\uD0DC\\uB294 wait\\uC5EC\\uC57C \\uD569\\uB2C8\\uB2E4.\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=rmid\\uAC00 inetd\\uC5D0\\uC11C \\uC2DC\\uC791\\uB41C \\uACBD\\uC6B0 \\uD3EC\\uD2B8\\uB97C \\uC9C0\\uC815\\uD560 \\uC218 \\uC5C6\\uC2B5\\uB2C8\\uB2E4.\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=\\uD3EC\\uD2B8\\uB294 \\uC22B\\uC790\\uAC00 \\uC544\\uB2D9\\uB2C8\\uB2E4.\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=-port \\uC635\\uC158\\uC744 \\uC0AC\\uC6A9\\uD558\\uB824\\uBA74 \\uC778\\uC218\\uAC00 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=-log \\uC635\\uC158\\uC744 \\uC0AC\\uC6A9\\uD558\\uB824\\uBA74 \\uC778\\uC218\\uAC00 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=-log \\uC635\\uC158\\uC774 \\uD544\\uC694\\uD569\\uB2C8\\uB2E4.\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=\\uC798\\uBABB\\uB41C \\uC635\\uC158: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: \\uC608\\uC678\\uC0AC\\uD56D \\uBC1C\\uC0DD: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: java.home\\uC744 \\uCC3E\\uC744 \\uC218 \\uC5C6\\uC2B5\\uB2C8\\uB2E4.\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=\\uC0C1\\uC18D\\uB41C \\uCC44\\uB110\\uC744 \\uC0AC\\uC6A9\\uD558\\uC5EC rmid \\uC2DC\\uC791\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: \\uC2E4\\uD589 \\uC815\\uCC45 \\uD074\\uB798\\uC2A4\\uAC00 \\uBD80\\uC801\\uD569\\uD569\\uB2C8\\uB2E4.\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: \\uC2E4\\uD589 \\uC815\\uCC45\\uC744 \\uAC00\\uC838\\uC624\\uB824\\uB294 \\uC2DC\\uB3C4\\uB85C \\uBC1C\\uC0DD\\uD55C \\uC608\\uC678\\uC0AC\\uD56D:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: \"{0}\" \\uC2E4\\uD589 \\uC911\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: \\uD65C\\uC131\\uD654 \\uADF8\\uB8F9 \\uBE44\\uD65C\\uC131: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: \\uACBD\\uACE0: sun.rmi.activation.execPolicy \\uC2DC\\uC2A4\\uD15C \\uC18D\\uC131\\uC774\\n\\uC9C0\\uC815\\uB418\\uC9C0 \\uC54A\\uC558\\uC73C\\uBA70 ExecPermissions\/ExecOptionPermissions\\uAC00 \\uBD80\\uC5EC\\uB418\\uC9C0\\n\\uC54A\\uC558\\uC2B5\\uB2C8\\uB2E4. \\uD65C\\uC131\\uD654\\uB97C \\uACC4\\uC18D \\uC2DC\\uB3C4\\uD558\\uBA74 ExecPermission\/ExecOptionPermission\\n\\uAD8C\\uD55C \\uAC80\\uC0AC \\uC2E4\\uD328\\uB85C \\uC778\\uD574 \\uC2E4\\uD328\\uD560 \\uC218 \\uC788\\uC2B5\\uB2C8\\uB2E4.\\n\\uBCF4\\uC548\\uC744 \\uAD6C\\uC131\\uD558\\uB824\\uBA74 rmid \\uC124\\uBA85\\uC11C\\uB97C \\uCC38\\uC870\\uD558\\uC2ED\\uC2DC\\uC624.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=\\uC0AC\\uC6A9\\uBC95: {0} <options> \\n\\n\\uC5EC\\uAE30\\uC11C <options>\\uB294 \\uB2E4\\uC74C\\uACFC \\uAC19\\uC2B5\\uB2C8\\uB2E4.\\n  -port <port>        rmid\\uAC00 \\uC0AC\\uC6A9\\uD560 \\uD3EC\\uD2B8\\uB97C \\uC9C0\\uC815\\uD569\\uB2C8\\uB2E4.\\n  -log <directory>    rmid\\uAC00 \\uB85C\\uADF8\\uB97C \\uAE30\\uB85D\\uD560 \\uB514\\uB809\\uD1A0\\uB9AC\\uB97C \\uC9C0\\uC815\\uD569\\uB2C8\\uB2E4.\\n  -stop               \\uC9C0\\uC815\\uB41C \\uD3EC\\uD2B8\\uC5D0 \\uB300\\uD574 rmid\\uC758 \\uD604\\uC7AC \\uD638\\uCD9C\\uC744 \\uC815\\uC9C0\\uD569\\uB2C8\\uB2E4.\\n  -C<runtime flag>    \\uAC01\\uAC01\\uC758 \\uD558\\uC704 \\uD504\\uB85C\\uC138\\uC2A4(\\uD65C\\uC131\\uD654 \\uADF8\\uB8F9)\\uC5D0 \\uC778\\uC218\\uB97C \\uC804\\uB2EC\\uD569\\uB2C8\\uB2E4.\\n  -J<runtime flag>    Java \\uC778\\uD130\\uD504\\uB9AC\\uD130\\uC5D0 \\uC778\\uC218\\uB97C \\uC804\\uB2EC\\uD569\\uB2C8\\uB2E4.\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=\\uD65C\\uC131 \\uB370\\uBAAC \\uC885\\uB8CC\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (\\uACBD\\uACE0) \\uADF8\\uB8F9 \\uC7AC\\uC2DC\\uC791\\uC73C\\uB85C \\uC778\\uD574 \\uBC1C\\uC0DD\\uD55C \\uC624\\uB958:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (\\uACBD\\uACE0) \\uC11C\\uBE44\\uC2A4 \\uC7AC\\uC2DC\\uC791\\uC73C\\uB85C \\uC778\\uD574 \\uBC1C\\uC0DD\\uD55C \\uC624\\uB958:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (\\uACBD\\uACE0) \\uB85C\\uADF8 \\uC5C5\\uB370\\uC774\\uD2B8\\uB85C \\uC778\\uD574 \\uBC1C\\uC0DD\\uD55C \\uC624\\uB958:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (\\uC2EC\\uAC01) \\uB85C\\uADF8 \\uC2A4\\uB0C5\\uC0F7\\uC73C\\uB85C \\uC778\\uD574 \\uBC1C\\uC0DD\\uD55C \\uC624\\uB958:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (\\uACBD\\uACE0) {0}: \\uBCF5\\uAD6C\\uD558\\uB294 \\uB3D9\\uC548 \\uB808\\uCF54\\uB4DC \\uAE30\\uB85D\\uC744 \\uAC74\\uB108 \\uB6F0\\uB294 \\uC911:\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_ko.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid foi acionado a partir de inetd com um status inv\\u00E1lido (deve ser wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=a porta n\\u00E3o poder\\u00E1 ser especificada se rmid for acionado a partir de inetd\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=a porta n\\u00E3o \\u00E9 um n\\u00FAmero\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=a op\\u00E7\\u00E3o -port requer um argumento\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=a op\\u00E7\\u00E3o -log requer um argumento\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=op\\u00E7\\u00E3o -log necess\\u00E1ria\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=op\\u00E7\\u00E3o inv\\u00E1lida: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: ocorreu uma exce\\u00E7\\u00E3o: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: n\\u00E3o \\u00E9 poss\\u00EDvel localizar java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=inicializa\\u00E7\\u00E3o de rmid com canal herdado\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: classe de pol\\u00EDtica de execu\\u00E7\\u00E3o inv\\u00E1lida\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: a tentativa de obter a pol\\u00EDtica de execu\\u00E7\\u00E3o gera:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: executando \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: grupo de ativa\\u00E7\\u00E3o inativo: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: warning: sun.rmi.activation.execPolicy system\\npropriedade n\\u00E3o especificada e nenhuma permiss\\u00E3o ExecPermissions\/ExecOptionPermissions\\nconcedida; as tentativas subsequentes de ativa\\u00E7\\u00E3o poder\\u00E3o falhar por causa das\\nverifica\\u00E7\\u00F5es malsucedidas da permiss\\u00E3o ExecPermission\/ExecOptionPermission. \\nPara configurar a seguran\\u00E7a, consulte a documenta\\u00E7\\u00E3o do rmid.\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Uso: {0} <op\\u00E7\\u00F5es>\\n\\nem que <op\\u00E7\\u00F5es> inclui:\\n  -port <porta>        especifica a porta que rmid usar\\u00E1\\n  -log <diret\\u00F3rio>    especifica o diret\\u00F3rio no qual o rmid grava o log\\n  -stop               para a chamada atual de rmid (para a porta especificada)\\n  -C<flag de runtime>    especifica o argumento para cada processo filho (grupo de ativa\\u00E7\\u00E3o)\\n  -J<flag de runtime>    especifica o argumento para o int\\u00E9rprete de java\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=shutdown do daemon de ativa\\u00E7\\u00E3o\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (ADVERT\\u00CANCIA) a reinicializa\\u00E7\\u00E3o do grupo gera:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (ADVERT\\u00CANCIA) a reinicializa\\u00E7\\u00E3o do servi\\u00E7o gera:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (ADVERT\\u00CANCIA) o registro da atualiza\\u00E7\\u00E3o gera:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (GRAVE) o registro do snapshot gera:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (ADVERT\\u00CANCIA) {0}: ignorando registro de log durante a recupera\\u00E7\\u00E3o:\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_pt_BR.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid startades fr\\u00E5n inetd med ogiltig status (m\\u00E5ste vara wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=port kan inte anges om rmid startas fr\\u00E5n inetd\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=port \\u00E4r inte ett tal\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=alternativet -port kr\\u00E4ver argument\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=alternativet -log kr\\u00E4ver argument\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=alternativet -log kr\\u00E4vs\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=otill\\u00E5tet alternativ: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: ett undantag uppstod: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: hittar inte java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=start av rmid med \\u00E4rvd kanal\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: ogiltig exec policy-klass\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: f\\u00F6rs\\u00F6k att h\\u00E4mta throws f\\u00F6r exec-policy:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: k\\u00F6r \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: aktiveringsgruppen \\u00E4r inaktiv: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: Varning: Systemegenskapen sun.rmi.activation.execPolicy\\nhar inte angetts och inga ExecPermissions\/ExecOptionPermissions har\\ntilldelats. Efterf\\u00F6ljande aktiveringsf\\u00F6rs\\u00F6k kanske inte utf\\u00F6rs p\\u00E5 grund\\nav ej utf\\u00F6rda ExecPermission\/ExecOptionPermission-beh\\u00F6righetskontroller. \\nOm du vill konfigurera s\\u00E4kerhet l\\u00E4ser du i dokumentationen f\\u00F6r rmid.\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=Syntax: {0} <alternativ>\\n\\nd\\u00E4r <alternativ> inkluderar:\\n  -port <port>        Ange porten f\\u00F6r rmid\\n  -log <katalog>      Ange katalogen d\\u00E4r rmid ska spara loggen\\n  -stop               Stoppa p\\u00E5g\\u00E5ende rmid-anrop (f\\u00F6r angiven port)\\n  -C<k\\u00F6rningsflagga>   Skicka argumentet till varje underordnad process (aktiveringsgrupp)\\n  -J<k\\u00F6rningsflagga>   Skicka argumentet till Javatolken\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=aktiveringsdemonen avslutas\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (Varning) starta om gruppkast:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (Varning) starta om tj\\u00E4nstekast:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (Varning) logga uppdateringskast:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (Allvarligt) logga \\u00F6gonblickskast:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (Varning) {0}: hoppar \\u00F6ver loggpost under \\u00E5terst\\u00E4llning:\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_sv.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid \\u5DF2\\u4ECE inetd \\u542F\\u52A8, \\u4E14\\u72B6\\u6001\\u65E0\\u6548 (\\u5FC5\\u987B\\u7B49\\u5F85)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=\\u5982\\u679C rmid \\u4ECE inetd \\u542F\\u52A8, \\u5219\\u65E0\\u6CD5\\u6307\\u5B9A\\u7AEF\\u53E3\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=\\u7AEF\\u53E3\\u4E0D\\u662F\\u4E00\\u4E2A\\u6570\\u5B57\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=-port \\u9009\\u9879\\u9700\\u8981\\u53C2\\u6570\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=-log \\u9009\\u9879\\u9700\\u8981\\u53C2\\u6570\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=\\u9700\\u8981 -log \\u9009\\u9879\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=\\u65E0\\u6548\\u7684\\u9009\\u9879\\uFF1A{0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: \\u51FA\\u73B0\\u5F02\\u5E38\\u9519\\u8BEF: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: \\u627E\\u4E0D\\u5230 java.home\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=rmid \\u901A\\u8FC7\\u7EE7\\u627F\\u7684\\u901A\\u9053\\u542F\\u52A8\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: \\u65E0\\u6548\\u7684\\u53EF\\u6267\\u884C policy \\u7C7B\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: \\u5C1D\\u8BD5\\u83B7\\u53D6\\u6267\\u884C\\u7B56\\u7565\\u629B\\u51FA:\n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: \\u6B63\\u5728\\u8FD0\\u884C \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: \\u6FC0\\u6D3B\\u7EC4\\u65E0\\u6548: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: \\u8B66\\u544A: \\u672A\\u6307\\u5B9A sun.rmi.activation.execPolicy\\n\\u7CFB\\u7EDF\\u5C5E\\u6027\\u5E76\\u4E14\\u672A\\u6388\\u4E88 ExecPermissions\/ExecOptionPermissions\\u3002\\n\\u7531\\u4E8E\\u5BF9 ExecPermission\/ExecOptionPermission \\u7684\\n\\u6743\\u9650\\u68C0\\u67E5\\u5931\\u8D25, \\u968F\\u540E\\u7684\\u6FC0\\u6D3B\\u5C1D\\u8BD5\\u53EF\\u80FD\\u4F1A\\u5931\\u8D25\\u3002\\n\\u8981\\u914D\\u7F6E\\u5B89\\u5168\\u6027, \\u8BF7\\u53C2\\u9605 rmid \\u6587\\u6863\\u3002\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=\\u7528\\u6CD5: {0} <options>\\n\\n\\u5176\\u4E2D, <options> \\u5305\\u62EC:\\n  -port <port>        \\u6307\\u5B9A\\u4F9B rmid \\u4F7F\\u7528\\u7684\\u7AEF\\u53E3\\n  -log <directory>    \\u6307\\u5B9A rmid \\u5C06\\u65E5\\u5FD7\\u5199\\u5165\\u7684\\u76EE\\u5F55\\n  -stop               \\u505C\\u6B62\\u5F53\\u524D\\u7684 rmid \\u8C03\\u7528 (\\u5BF9\\u6307\\u5B9A\\u7AEF\\u53E3)\\n  -C<runtime flag>    \\u5411\\u6BCF\\u4E2A\\u5B50\\u8FDB\\u7A0B\\u4F20\\u9012\\u53C2\\u6570 (\\u6FC0\\u6D3B\\u7EC4)\\n  -J<runtime flag>    \\u5411 java \\u89E3\\u91CA\\u5668\\u4F20\\u9012\\u53C2\\u6570\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=\\u6FC0\\u6D3B\\u5B88\\u62A4\\u7A0B\\u5E8F\\u5DF2\\u5173\\u95ED\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (\\u8B66\\u544A) \\u91CD\\u65B0\\u542F\\u52A8\\u7EC4\\u629B\\u51FA:\n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (\\u8B66\\u544A) \\u91CD\\u65B0\\u542F\\u52A8\\u670D\\u52A1\\u629B\\u51FA:\n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (\\u8B66\\u544A) \\u65E5\\u5FD7\\u66F4\\u65B0\\u629B\\u51FA:\n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (\\u4E25\\u91CD) \\u65E5\\u5FD7\\u5FEB\\u7167\\u629B\\u51FA:\n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (\\u8B66\\u544A) {0}:  \\u6062\\u590D\\u671F\\u95F4\\u8DF3\\u8FC7\\u65E5\\u5FD7\\u8BB0\\u5F55:\n-\n-# \"rmid\" should not be translated\n-rmid.deprecation.warning=rmid\\uFF1A\\uFF08\\u8B66\\u544A\\uFF09RMI \\u6FC0\\u6D3B\\u673A\\u5236\\u548C rmid \\u5DE5\\u5177\\n\\u5DF2\\u8FC7\\u65F6\\uFF0C\\u5373\\u5C06\\u5220\\u9664\\u3002\\u5728\\u5C06\\u6765\\u7684\\nJava \\u5E73\\u53F0\\u7248\\u672C\\u4E2D\\u53EF\\u80FD\\u4F1A\\u5C06\\u5176\\u5220\\u9664\\u3002\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_zh_CN.properties","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-#\n-#\n-# Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.  Oracle designates this\n-# particular file as subject to the \"Classpath\" exception as provided\n-# by Oracle in the LICENSE file that accompanied this code.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# \"rmid\", inetd\", and \"wait\" should not be translated.\n-rmid.syntax.exec.invalid=rmid \\u5DF2\\u5F9E inetd \\u555F\\u52D5\\uFF0C\\u4F46\\u72C0\\u614B\\u7121\\u6548 (\\u5FC5\\u9808\\u662F wait)\n-\n-# \"rmid\" and \"inetd\" should not be translated.\n-rmid.syntax.port.badarg=\\u5982\\u679C rmid \\u5F9E inetd \\u555F\\u52D5\\uFF0C\\u5247\\u7121\\u6CD5\\u6307\\u5B9A\\u9023\\u63A5\\u57E0\n-\n-# \"port\" here refers to a TCP port for the server to listen on.\n-rmid.syntax.port.badnumber=port \\u4E0D\\u662F\\u4E00\\u500B\\u6578\\u5B57\n-\n-# \"-port\" should not be translated, because it's part of command syntax.\n-rmid.syntax.port.missing=-port \\u9078\\u9805\\u9700\\u8981\\u5F15\\u6578\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.missing=-log \\u9078\\u9805\\u9700\\u8981\\u5F15\\u6578\n-\n-# \"-log\" should not be translated, because it's part of command syntax.\n-rmid.syntax.log.required=-log \\u9078\\u9805\\u662F\\u5FC5\\u9700\\u7684\n-\n-# {0} = the (string) illegal argument in question\n-rmid.syntax.illegal.option=\\u7121\\u6548\\u7684\\u9078\\u9805: {0}\n-\n-# {0} = the (string) reason text that came with a thrown exception\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.unexpected.exception=Activation.main: \\u767C\\u751F\\u7570\\u5E38\\u72C0\\u6CC1: {0}\n-\n-# \"java.home\" should not be translated, because it's a property name\n-# \"ActivatorImpl\" should not be translated, because it's a codepoint\n-rmid.unfound.java.home.property=ActivatorImpl: \\u627E\\u4E0D\\u5230 java.home \\u7684\\u6240\\u5728\n-\n-# \"rmid\" should not be translated\n-rmid.inherited.channel.info=rmid \\u4F7F\\u7528\\u7E7C\\u627F\\u7684\\u901A\\u9053\\u555F\\u52D5\n-\n-# \"Activation.main\" should not be translated, because it's a codepoint\n-rmid.exec.policy.invalid=Activation.main: \\u7121\\u6548\\u7684\\u57F7\\u884C\\u539F\\u5247\\u985E\\u5225\n-\n-# \"rmid\" should not be translated\n-rmid.exec.policy.exception=rmid: \\u5617\\u8A66\\u53D6\\u5F97\\u57F7\\u884C\\u539F\\u5247\\u62CB\\u68C4: \n-\n-# \"rmid\" should not be translated\n-rmid.exec.command=rmid: debugExec: \\u57F7\\u884C \"{0}\"\n-\n-# \"rmid\" should not be translated\n-rmid.group.inactive=rmid: \\u555F\\u52D5\\u7FA4\\u7D44\\u672A\\u5728\\u4F7F\\u7528\\u4E2D: {0}\n-\n-# \"Activation.main\", \"sun.rmi.activation.execPolicy\", \"ExecPermission\" and \n-# \"ExecOptionPermission\" should not be translated, since they refer to\n-# class\/permission names.\n-rmid.exec.perms.inadequate=Activation.main: \\u8B66\\u544A: sun.rmi.activation.execPolicy \\u7CFB\\u7D71\\n\\u5C6C\\u6027\\u672A\\u6307\\u5B9A\\uFF0C\\u800C\\u4E14\\u672A\\u6388\\u4E88 ExecPermissions\/ExecOptionPermissions;\\n\\u5F8C\\u7E8C\\u7684\\u555F\\u52D5\\u5617\\u8A66\\u53EF\\u80FD\\u6703\\u56E0\\u70BA\\u4E0D\\u6210\\u529F\\u7684\\nExecPermission\/ExecOptionPermission \\u6B0A\\u9650\\u6AA2\\u67E5\\u800C\\u5931\\u6557\\u3002\\n\\u5982\\u9700\\u8A2D\\u5B9A\\u5B89\\u5168\\uFF0C\\u8ACB\\u53C3\\u8003 rmid \\u6587\\u4EF6\\u3002\\n\n-\n-# \"rmid\", \"-port\", \"-log\", \"-stop\", \"-C\" and \"-J\" should not be translated,\n-# because they are syntax\n-rmid.usage=\\u7528\\u6CD5: {0} <options>\\n\\n\\u5176\\u4E2D <options> \\u5305\\u62EC: \\n  -port <port>        \\u6307\\u5B9A\\u4F9B rmid \\u4F7F\\u7528\\u7684\\u9023\\u63A5\\u57E0\\n  -log <directory>    \\u6307\\u5B9A\\u4F9B rmid \\u5BEB\\u5165\\u65E5\\u8A8C\\u7684\\u76EE\\u9304\\n  -stop               \\u505C\\u6B62\\u76EE\\u524D rmid \\u7684\\u547C\\u53EB (\\u91DD\\u5C0D\\u6307\\u5B9A\\u7684\\u9023\\u63A5\\u57E0)\\n  -C<runtime flag>    \\u50B3\\u905E\\u5F15\\u6578\\u81F3\\u6BCF\\u4E00\\u5B50\\u904E\\u7A0B (\\u4F5C\\u7528\\u7FA4\\u7D44)\\n  -J<runtime flag>    \\u50B3\\u905E\\u5F15\\u6578\\u81F3 java \\u89E3\\u8B6F\\u7A0B\\u5F0F\\n\n-# This means \"The currently running activation daemon has been shut down,\n-# and is about to exit\".\n-rmid.daemon.shutdown=\\u95DC\\u9589 activation \\u5354\\u52A9\\u7A0B\\u5F0F\n-\n-# \"rmid\" should not be translated\n-rmid.restart.group.warning=\\nrmid: (\\u8B66\\u544A) \\u91CD\\u65B0\\u555F\\u52D5\\u7FA4\\u7D44\\u62CB\\u68C4: \n-\n-# \"rmid\" should not be translated\n-rmid.restart.service.warning=\\nrmid: (\\u8B66\\u544A) \\u91CD\\u65B0\\u555F\\u52D5\\u670D\\u52D9\\u62CB\\u68C4: \n-\n-# \"rmid\" should not be translated\n-rmid.log.update.warning=\\nrmid: (\\u8B66\\u544A) \\u8A18\\u9304\\u66F4\\u65B0\\u62CB\\u68C4: \n-\n-# \"rmid\" should not be translated\n-rmid.log.snapshot.warning=\\nrmid: (\\u56B4\\u91CD) \\u8A18\\u9304\\u5FEB\\u7167\\u62CB\\u68C4: \n-\n-# \"rmid\" should not be translated\n-rmid.log.recover.warning=\\nrmid: (\\u8B66\\u544A) {0}: \\u5728\\u56DE\\u5FA9\\u904E\\u7A0B\\u4E2D\\u7565\\u904E\\u65E5\\u8A8C\\u8A18\\u9304: \n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/server\/resources\/rmid_zh_TW.properties","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -1,413 +0,0 @@\n-.\\\" Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n-.\\\" DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-.\\\"\n-.\\\" This code is free software; you can redistribute it and\/or modify it\n-.\\\" under the terms of the GNU General Public License version 2 only, as\n-.\\\" published by the Free Software Foundation.\n-.\\\"\n-.\\\" This code is distributed in the hope that it will be useful, but WITHOUT\n-.\\\" ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-.\\\" FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-.\\\" version 2 for more details (a copy is included in the LICENSE file that\n-.\\\" accompanied this code).\n-.\\\"\n-.\\\" You should have received a copy of the GNU General Public License version\n-.\\\" 2 along with this work; if not, write to the Free Software Foundation,\n-.\\\" Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-.\\\"\n-.\\\" Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-.\\\" or visit www.oracle.com if you need additional information or have any\n-.\\\" questions.\n-.\\\"\n-.\\\" Automatically generated by Pandoc 2.3.1\n-.\\\"\n-.TH \"RMID\" \"1\" \"2021\" \"JDK 17\\-ea\" \"JDK Commands\"\n-.hy\n-.SH NAME\n-.PP\n-rmid \\- start the activation system daemon that enables objects to be\n-registered and activated in a Java Virtual Machine (JVM)\n-.SH SYNOPSIS\n-.PP\n-\\f[CB]rmid\\f[R] [\\f[I]options\\f[R]]\n-.TP\n-.B \\f[I]options\\f[R]\n-This represent the command\\-line options for the \\f[CB]rmid\\f[R] command.\n-See \\f[B]Options for rmid\\f[R].\n-.RS\n-.RE\n-.SH DESCRIPTION\n-.PP\n-\\f[B]Deprecation Notice:\\f[R] The rmid tool and the RMI Activation\n-mechanism have been deprecated and may be removed from a future version\n-of the platform.\n-See \\f[B]JEP 385\\f[R] [https:\/\/openjdk.java.net\/jeps\/385] for further\n-information.\n-.PP\n-The \\f[CB]rmid\\f[R] command starts the activation system daemon.\n-The activation system daemon must be started before objects that can be\n-activated are either registered with the activation system or activated\n-in a JVM.\n-.PP\n-Start the daemon by executing the \\f[CB]rmid\\f[R] command and specifying a\n-security policy file, as follows:\n-.RS\n-.PP\n-\\f[CB]rmid\\ \\-J\\-Djava.security.policy=rmid.policy\\f[R]\n-.RE\n-.PP\n-When you run Oracle\\[aq]s implementation of the \\f[CB]rmid\\f[R] command,\n-by default you must specify a security policy file so that the\n-\\f[CB]rmid\\f[R] command can verify whether or not the information in each\n-\\f[CB]ActivationGroupDesc\\f[R] is allowed to be used to start a JVM for an\n-activation group.\n-Specifically, the command and options specified by the\n-\\f[CB]CommandEnvironment\\f[R] and any properties passed to an\n-\\f[CB]ActivationGroupDesc\\f[R] constructor must now be explicitly allowed\n-in the security policy file for the \\f[CB]rmid\\f[R] command.\n-The value of the \\f[CB]sun.rmi.activation.execPolicy\\f[R] property\n-dictates the policy that the \\f[CB]rmid\\f[R] command uses to determine\n-whether or not the information in an \\f[CB]ActivationGroupDesc\\f[R] can be\n-used to start a JVM for an activation group.\n-For more information see the description of the\n-\\f[CB]\\-J\\-Dsun.rmi.activation.execPolicy=policy\\f[R] option.\n-.PP\n-Executing the \\f[CB]rmid\\f[R] command starts the \\f[CB]Activator\\f[R] and an\n-internal registry on the default port 1098 and binds an\n-\\f[CB]ActivationSystem\\f[R] to the name\n-\\f[CB]java.rmi.activation.ActivationSystem\\f[R] in this internal registry.\n-.PP\n-To specify an alternate port for the registry, you must specify the\n-\\f[CB]\\-port\\f[R] option when you execute the \\f[CB]rmid\\f[R] command.\n-For example, the following command starts the activation system daemon\n-and a registry on the registry\\[aq]s default port, 1099.\n-.RS\n-.PP\n-\\f[CB]rmid\\ \\-J\\-Djava.security.policy=rmid.policy\\ \\-port\\ 1099\\f[R]\n-.RE\n-.SH START RMID ON DEMAND (LINUX ONLY)\n-.PP\n-An alternative to starting \\f[CB]rmid\\f[R] from the command line is to\n-configure \\f[CB]xinetd\\f[R] (Linux) to start \\f[CB]rmid\\f[R] on demand.\n-.PP\n-When RMID starts, it attempts to obtain an inherited channel (inherited\n-from \\f[CB]inetd\\f[R]\/\\f[CB]xinetd\\f[R]) by calling the\n-\\f[CB]System.inheritedChannel\\f[R] method.\n-If the inherited channel is null or not an instance of\n-\\f[CB]java.nio.channels.ServerSocketChannel\\f[R], then RMID assumes that\n-it wasn\\[aq]t started by \\f[CB]inetd\\f[R]\/\\f[CB]xinetd\\f[R], and it starts\n-as previously described.\n-.PP\n-If the inherited channel is a \\f[CB]ServerSocketChannel\\f[R] instance,\n-then RMID uses the \\f[CB]java.net.ServerSocket\\f[R] obtained from the\n-\\f[CB]ServerSocketChannel\\f[R] as the server socket that accepts requests\n-for the remote objects it exports: The registry in which the\n-\\f[CB]java.rmi.activation.ActivationSystem\\f[R] is bound and the\n-\\f[CB]java.rmi.activation.Activator\\f[R] remote object.\n-In this mode, RMID behaves the same as when it is started from the\n-command line, except in the following cases:\n-.IP \\[bu] 2\n-Output printed to \\f[CB]System.err\\f[R] is redirected to a file.\n-This file is located in the directory specified by the\n-\\f[CB]java.io.tmpdir\\f[R] system property (typically \\f[CB]\/var\/tmp\\f[R] or\n-\\f[CB]\/tmp\\f[R]) with the prefix \\f[CB]rmid\\-err\\f[R] and the suffix\n-\\f[CB]tmp\\f[R].\n-.IP \\[bu] 2\n-The \\f[CB]\\-port\\f[R] option isn\\[aq]t allowed.\n-If this option is specified, then RMID exits with an error message.\n-.IP \\[bu] 2\n-The \\f[CB]\\-log\\f[R] option is required.\n-If this option isn\\[aq]t specified, then RMID exits with an error\n-message\n-.SH OPTIONS FOR RMID\n-.TP\n-.B \\f[CB]\\-C\\f[R]\\f[I]option\\f[R]\n-Specifies an option that\\[aq]s passed as a command\\-line argument to\n-each child process (activation group) of the \\f[CB]rmid\\f[R] command when\n-that process is created.\n-For example, you could pass a property to each virtual machine spawned\n-by the activation system daemon:\n-.RS\n-.RS\n-.PP\n-\\f[CB]rmid\\ \\-C\\-Dsome.property=value\\f[R]\n-.RE\n-.PP\n-This ability to pass command\\-line arguments to child processes can be\n-useful for debugging.\n-For example, the following command enables server\\-call logging in all\n-child JVMs.\n-.RS\n-.PP\n-\\f[CB]rmid\\ \\-C\\-Djava.rmi.server.logCalls=true\\f[R]\n-.RE\n-.RE\n-.TP\n-.B \\f[CB]\\-J\\f[R]\\f[I]option\\f[R]\n-Specifies an option that\\[aq]s passed to the Java interpreter running\n-RMID command.\n-For example, to specify that the \\f[CB]rmid\\f[R] command use a policy file\n-named \\f[CB]rmid.policy\\f[R], the \\f[CB]\\-J\\f[R] option can be used to\n-define the \\f[CB]java.security.policy\\f[R] property on the \\f[CB]rmid\\f[R]\n-command line, for example:\n-.RS\n-.RS\n-.PP\n-\\f[CB]rmid\\ \\-J\\-Djava.security.policy\\-rmid.policy\\f[R]\n-.RE\n-.RE\n-.TP\n-.B \\f[CB]\\-J\\-Dsun.rmi.activation.execPolicy=\\f[R]\\f[I]policy\\f[R]\n-Specifies the policy that the RMID command employs to check commands and\n-command\\-line options used to start the JVM in which an activation group\n-runs.\n-This option exists only in Oracle\\[aq]s implementation of the Java RMI\n-activation daemon.\n-If this property isn\\[aq]t specified on the command line, then the\n-result is the same as though\n-\\f[CB]\\-J\\-Dsun.rmi.activation.execPolicy=default\\f[R] were specified.\n-.RS\n-.PP\n-The possible values of \\f[I]policy\\f[R] can be \\f[CB]default\\f[R],\n-\\f[I]policyClassName\\f[R], or \\f[CB]none\\f[R].\n-.IP \\[bu] 2\n-\\f[CB]default\\f[R]\n-.RS 2\n-.PP\n-The \\f[CB]default\\f[R] or unspecified value \\f[CB]execPolicy\\f[R] allows the\n-\\f[CB]rmid\\f[R] command to execute commands with specific command\\-line\n-options only when the \\f[CB]rmid\\f[R] command was granted permission to\n-execute those commands and options in the security policy file that the\n-\\f[CB]rmid\\f[R] command uses.\n-Only the default activation group implementation can be used with the\n-default execution policy.\n-.PP\n-The \\f[CB]rmid\\f[R] command starts a JVM for an activation group with the\n-information in the group\\[aq]s registered activation group descriptor,\n-\\f[CB]ActivationGroupDesc\\f[R].\n-The group descriptor specifies an optional\n-\\f[CB]ActivationGroupDesc.CommandEnvironment\\f[R] that includes the\n-command to execute to start the activation group and any command\\-line\n-options to be added to the command line.\n-By default, the \\f[CB]rmid\\f[R] command uses the \\f[CB]java\\f[R] command\n-found in \\f[CB]java.home\\f[R].\n-The group descriptor also contains properties overrides that are added\n-to the command line as options defined as:\n-\\f[CB]\\-D\\f[R]\\f[I]property\\f[R]\\f[CB]=\\f[R]\\f[I]value\\f[R].\n-The \\f[CB]com.sun.rmi.rmid.ExecPermission\\f[R] permission grants the\n-\\f[CB]rmid\\f[R] command permission to execute a command that\\[aq]s\n-specified in the group descriptor\\[aq]s \\f[CB]CommandEnvironment\\f[R] to\n-start an activation group.\n-The \\f[CB]com.sun.rmi.rmid.ExecOptionPermission\\f[R] permission enables\n-the \\f[CB]rmid\\f[R] command to use command\\-line options, specified as\n-properties overrides in the group descriptor or as options in the\n-\\f[CB]CommandEnvironment\\f[R] when starting the activation group.\n-When granting the \\f[CB]rmid\\f[R] command permission to execute various\n-commands and options, the permissions \\f[CB]ExecPermission\\f[R] and\n-\\f[CB]ExecOptionPermission\\f[R] must be granted to all code sources.\n-.PP\n-\\f[CB]ExecPermission\\f[R] class: Represents permission for the\n-\\f[CB]rmid\\f[R] command to execute a specific command to start an\n-activation group.\n-.PP\n-\\f[CB]ExecPermission\\f[R] syntax: The name of \\f[CB]ExecPermission\\f[R] is\n-the path name of a command to grant the \\f[CB]rmid\\f[R] command permission\n-to execute.\n-.PP\n-A path name that ends in a slash (\\f[CB]\/\\f[R]) and an asterisk\n-(\\f[CB]*\\f[R]) indicates that all of the files are contained in that\n-directory where the slash is the file\\-separator character,\n-\\f[CB]File.separatorChar\\f[R].\n-.PP\n-A path name that ends in a slash (\\f[CB]\/\\f[R]) and a minus sign\n-(\\f[CB]\\-\\f[R]) indicates that all files and subdirectories are contained\n-in that directory (recursively).\n-.PP\n-A path name that consists of the special token \\f[CB]<<ALL\\ FILES>>\\f[R]\n-matches any file.\n-.PP\n-A path name that consists of an asterisk (\\f[CB]*\\f[R]) indicates that all\n-the files are in the current directory.\n-.PP\n-A path name that consists of a minus sign (\\f[CB]\\-\\f[R]) indicates that\n-all the files are in the current directory and (recursively) all files\n-and subdirectories are contained in the current directory.\n-.PP\n-\\f[CB]ExecOptionPermission\\f[R] class: Represents permission for the\n-\\f[CB]rmid\\f[R] command to use a specific command\\-line option when\n-starting an activation group.\n-The name of \\f[CB]ExecOptionPermission\\f[R] is the value of a\n-command\\-line option.\n-.PP\n-\\f[CB]ExecOptionPermission\\f[R] syntax: Options support a limited wild\n-card scheme.\n-An asterisk signifies a wild card match, and it can appear as the option\n-name itself (matches any option), or an asterisk (*) can appear at the\n-end of the option name only when the asterisk (\\f[CB]*\\f[R]) follows a dot\n-(\\f[CB]\\&.\\f[R]) or an equals sign (\\f[CB]=\\f[R]).\n-.PP\n-For example: \\f[CB]*\\f[R] or \\f[CB]\\-Dmydir.*\\f[R] or \\f[CB]\\-Da.b.c=*\\f[R] is\n-valid, but \\f[CB]*mydir\\f[R] or \\f[CB]\\-Da*b\\f[R] or \\f[CB]ab*\\f[R] isn\\[aq]t\n-valid.\n-.PP\n-\\f[B]Policy file for rmid\\f[R]\n-.PP\n-When you grant the \\f[CB]rmid\\f[R] command permission to execute various\n-commands and options, the permissions \\f[CB]ExecPermission\\f[R] and\n-\\f[CB]ExecOptionPermission\\f[R] must be granted to all code sources\n-(universally).\n-It is safe to grant these permissions universally because only the\n-\\f[CB]rmid\\f[R] command checks these permissions.\n-.PP\n-An example policy file that grants various execute permissions to the\n-\\f[CB]rmid\\f[R] command is:\n-.IP \\[bu] 2\n-\\f[B]Linux:\\f[R]\n-.RS 2\n-.IP\n-.nf\n-\\f[CB]\n-grant\\ {\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\/files\/apps\/java\/jdk1.7.0\/linux\/bin\/java\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\/files\/apps\/rmidcmds\/*\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecOptionPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\\-Djava.security.policy=\/files\/policies\/group.policy\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecOptionPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\\-Djava.security.debug=*\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecOptionPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\\-Dsun.rmi.*\";\n-};\n-\\f[R]\n-.fi\n-.RE\n-.IP \\[bu] 2\n-\\f[B]Windows:\\f[R]\n-.RS 2\n-.IP\n-.nf\n-\\f[CB]\n-grant\\ {\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"c:\\\\\\\\files\\\\\\\\apps\\\\\\\\java\\\\\\\\jdk1.7.0\\\\\\\\win\\\\\\\\bin\\\\\\\\java\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"c:\\\\\\\\files\\\\\\\\apps\\\\\\\\rmidcmds\\\\\\\\*\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecOptionPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\\-Djava.security.policy=c:\\\\\\\\files\\\\\\\\policies\\\\\\\\group.policy\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecOptionPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\\-Djava.security.debug=*\";\n-\n-\\ \\ \\ \\ permission\\ com.sun.rmi.rmid.ExecOptionPermission\n-\\ \\ \\ \\ \\ \\ \\ \\ \"\\-Dsun.rmi.*\";\n-};\n-\\f[R]\n-.fi\n-.RE\n-.PP\n-The first permission granted allows the \\f[CB]rmid\\f[R] command to execute\n-the 1.7.0 release of the \\f[CB]java\\f[R] command, specified by its\n-explicit path name.\n-By default, the version of the \\f[CB]java\\f[R] command found in\n-\\f[CB]java.home\\f[R] is used (the same one that the \\f[CB]rmid\\f[R] command\n-uses), and doesn\\[aq]t need to be specified in the policy file.\n-The second permission allows the \\f[CB]rmid\\f[R] command to execute any\n-command in either the directory \\f[CB]\/files\/apps\/rmidcmds\\f[R] (Linux and\n-macOS) or the directory \\f[CB]c:\\\\files\\\\apps\\\\rmidcmds\\\\\\f[R] (Windows).\n-.PP\n-The third permission granted, \\f[CB]ExecOptionPermission\\f[R], allows the\n-\\f[CB]rmid\\f[R] command to start an activation group that defines the\n-security policy file to be either \\f[CB]\/files\/policies\/group.policy\\f[R]\n-(Linux) or \\f[CB]c:\\\\files\\\\policies\\\\group.policy\\f[R] (Windows).\n-The next permission allows the \\f[CB]java.security.debug\\ property\\f[R] to\n-be used by an activation group.\n-The last permission allows any property in the\n-\\f[CB]sun.rmi\\ property\\f[R] name hierarchy to be used by activation\n-groups.\n-.PP\n-To start the \\f[CB]rmid\\f[R] command with a policy file, the\n-\\f[CB]java.security.policy\\f[R] property needs to be specified on the\n-\\f[CB]rmid\\f[R] command line, for example:\n-.PP\n-\\f[CB]rmid\\ \\-J\\-Djava.security.policy=rmid.policy\\f[R].\n-.RE\n-.IP \\[bu] 2\n-\\f[I]policyClassName\\f[R]\n-.RS 2\n-.PP\n-If the default behavior isn\\[aq]t flexible enough, then an administrator\n-can provide, when starting the \\f[CB]rmid\\f[R] command, the name of a\n-class whose \\f[CB]checkExecCommand\\f[R] method is executed to check\n-commands to be executed by the \\f[CB]rmid\\f[R] command.\n-.PP\n-The \\f[CB]policyClassName\\f[R] specifies a public class with a public,\n-no\\-argument constructor and an implementation of the following\n-\\f[CB]checkExecCommand\\f[R] method:\n-.IP\n-.nf\n-\\f[CB]\n-\\ public\\ void\\ checkExecCommand(ActivationGroupDesc\\ desc,\\ String[]\\ command)\n-\\ \\ \\ \\ \\ \\ \\ \\ throws\\ SecurityException;\n-\\f[R]\n-.fi\n-.PP\n-Before starting an activation group, the \\f[CB]rmid\\f[R] command calls the\n-policy\\[aq]s \\f[CB]checkExecCommand\\f[R] method and passes to it the\n-activation group descriptor and an array that contains the complete\n-command to start the activation group.\n-If the \\f[CB]checkExecCommand\\f[R] throws a \\f[CB]SecurityException\\f[R],\n-then the \\f[CB]rmid\\f[R] command doesn\\[aq]t start the activation group\n-and an \\f[CB]ActivationException\\f[R] is thrown to the caller attempting\n-to activate the object.\n-.RE\n-.IP \\[bu] 2\n-\\f[CB]none\\f[R]\n-.RS 2\n-.PP\n-If the \\f[CB]sun.rmi.activation.execPolicy\\f[R] property value is\n-\\f[CB]none\\f[R], then the \\f[CB]rmid\\f[R] command doesn\\[aq]t perform any\n-validation of commands to start activation groups.\n-.RE\n-.RE\n-.TP\n-.B \\f[CB]\\-log\\f[R] \\f[I]dir\\f[R]\n-Specifies the name of the directory that the activation system daemon\n-uses to write its database and associated information.\n-The log directory defaults to creating a log, in the directory in which\n-the \\f[CB]rmid\\f[R] command was executed.\n-.RS\n-.RE\n-.TP\n-.B \\f[CB]\\-port\\f[R] \\f[I]port\\f[R]\n-Specifies the port that the registry uses.\n-The activation system daemon binds \\f[CB]ActivationSystem\\f[R], with the\n-name \\f[CB]java.rmi.activation.ActivationSystem\\f[R], in this registry.\n-The \\f[CB]ActivationSystem\\f[R] on the local machine can be obtained using\n-the following \\f[CB]Naming.lookup\\f[R] method call:\n-.RS\n-.IP\n-.nf\n-\\f[CB]\n-import\\ java.rmi.*;\n-import\\ java.rmi.activation.*;\n-\n-ActivationSystem\\ system;\\ system\\ =\\ (ActivationSystem)\n-Naming.lookup(\"\/\/:port\/java.rmi.activation.ActivationSystem\");\n-\\f[R]\n-.fi\n-.RE\n-.TP\n-.B \\f[CB]\\-stop\\f[R]\n-Stops the current invocation of the \\f[CB]rmid\\f[R] command for a port\n-specified by the \\f[CB]\\-port\\f[R] option.\n-If no port is specified, then this option stops the \\f[CB]rmid\\f[R]\n-invocation running on port 1098.\n-.RS\n-.RE\n","filename":"src\/java.rmi\/share\/man\/rmid.1","additions":0,"deletions":413,"binary":false,"changes":413,"status":"deleted"},{"patch":"@@ -638,6 +638,0 @@\n-java\/rmi\/activation\/Activatable\/extLoadedImpl\/ext.sh            8062724 generic-all\n-\n-java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/DownloadActivationGroup.java 8169569 windows-all\n-\n-java\/rmi\/activation\/rmidViaInheritedChannel\/InheritedChannelNotServerSocket.java 8170562 generic-all\n-\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -520,1 +520,0 @@\n-    java\/rmi\/activation\/nonLocalActivation\/NonLocalActivationTest.java \\\n","filename":"test\/jdk\/TEST.groups","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.rmi.activation.ActivationException;\n@@ -71,3 +70,0 @@\n-        test(new ActivationException(), null, null);\n-        test(new ActivationException(foo), foo, null);\n-        test(new ActivationException(foo, t), fooMsg, t);\n","filename":"test\/jdk\/java\/rmi\/RemoteException\/chaining\/Chaining.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkActivateRef\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4105080\n- * @summary Activation retry during a remote method call to an activatable\n- *          object can cause infinite recursion in some situations. The\n- *          RemoteRef contained in the ActivatableRef should never be\n- *          an ActivatableRef, but another type.\n- * (Needs \/othervm to evade JavaTest security manager --aecolley)\n- * @author Ann Wollrath\n- *\n- * @bug 4164971\n- * @summary allow non-public activatable class and\/or constructor\n- *          Main test class hasa non-public constructor to ensure\n- *          functionality is in place\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server:+open\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivateMe CheckActivateRef_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 -Djava.rmi.server.ignoreStubClasses=true CheckActivateRef\n- * @run main\/othervm\/policy=security.policy\/timeout=240 -Djava.rmi.server.ignoreStubClasses=false CheckActivateRef\n- * @key intermittent\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.*;\n-import sun.rmi.server.ActivatableRef;\n-import java.lang.reflect.*;\n-import java.util.Properties;\n-\n-public class CheckActivateRef\n-        extends Activatable\n-        implements ActivateMe, Runnable\n-{\n-\n-    private CheckActivateRef(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        super(id, 0);\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"CheckActivateRef\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args)  {\n-        \/*\n-         * The following line is required with the JDK 1.2 VM so that the\n-         * VM can exit gracefully when this test completes.  Otherwise, the\n-         * conservative garbage collector will find a handle to the server\n-         * object on the native stack and not clear the weak reference to\n-         * it in the RMI runtime's object table.\n-         *\/\n-        Object dummy = new Object();\n-        RMID rmid = null;\n-        ActivateMe obj;\n-\n-        \/\/ test should tolerate certain types of failures\n-        int failures = 0;\n-        int i = 0;\n-\n-        System.err.println(\"\\nRegression test for bug 4105080\\n\");\n-        System.err.println(\"java.security.policy = \" +\n-                           System.getProperty(\"java.security.policy\",\n-                                              \"no policy\"));\n-\n-\n-        String propValue =\n-            System.getProperty(\"java.rmi.server.useDynamicProxies\", \"false\");\n-        boolean useDynamicProxies = Boolean.parseBoolean(propValue);\n-\n-        CheckActivateRef server;\n-        try {\n-            TestLibrary.suggestSecurityManager(TestParams.defaultSecurityManager);\n-\n-            \/\/ start an rmid.\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-            p.put(\"java.rmi.server.useDynamicProxies\", propValue);\n-\n-            \/*\n-             * Activate an object by registering its object\n-             * descriptor and invoking a method on the\n-             * stub returned from the register call.\n-             *\/\n-            System.err.println(\"Create activation group in this VM\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            ActivationGroup.createGroup(groupID, groupDesc, 0);\n-            System.err.println(\"Creating descriptor\");\n-            ActivationDesc desc =\n-                new ActivationDesc(\"CheckActivateRef\", null, null);\n-            System.err.println(\"Registering descriptor\");\n-            obj = (ActivateMe) Activatable.register(desc);\n-\n-            System.err.println(\"proxy = \" + obj);\n-\n-            if (useDynamicProxies && !Proxy.isProxyClass(obj.getClass()))\n-            {\n-                throw new RuntimeException(\"proxy is not dynamic proxy\");\n-            }\n-\n-            \/*\n-             * Loop a bunch of times to force activator to\n-             * spawn VMs (groups)\n-             *\/\n-            try {\n-                for (; i < 7; i++) {\n-\n-                    System.err.println(\"Activate object via method call\");\n-\n-                    \/*\n-                     * Fix for 4277196: if we got an inactive group\n-                     * exception, it is likely that we accidentally\n-                     * invoked a method on an old activation\n-                     * group. Give some time for the group to go away\n-                     * and then retry the activation.\n-                     *\/\n-                    try {\n-                        obj.ping();\n-                    } catch (RemoteException e) {\n-                        Exception detail = (Exception) e.detail;\n-                        if ((detail != null) &&\n-                            (detail instanceof ActivationException) &&\n-                            (detail.getMessage().equals(\"group is inactive\")))\n-                        {\n-                            try {\n-                                Thread.sleep(5000);\n-                            } catch (InterruptedException ex) {\n-                            }\n-                            obj.ping();\n-\n-                        } else {\n-                            throw e;\n-                        }\n-                    }\n-\n-                    System.err.println(\"proxy = \" + obj);\n-\n-                    \/*\n-                     * Now that object is activated, check to make sure that\n-                     * the RemoteRef inside the stub's ActivatableRef\n-                     * is *not* an ActivatableRef.\n-                     *\/\n-                    ActivatableRef aref;\n-                    if (obj instanceof RemoteStub) {\n-                        aref = (ActivatableRef) ((RemoteObject) obj).getRef();\n-                    } else if (Proxy.isProxyClass(obj.getClass())) {\n-                        RemoteObjectInvocationHandler handler =\n-                            (RemoteObjectInvocationHandler)\n-                            Proxy.getInvocationHandler(obj);\n-                        aref = (ActivatableRef) handler.getRef();\n-                    } else {\n-                        throw new RuntimeException(\"unknown proxy type\");\n-                    }\n-\n-                    final ActivatableRef ref = aref;\n-                    Field f = (Field)\n-                        java.security.AccessController.doPrivileged\n-                        (new java.security.PrivilegedExceptionAction() {\n-                            public Object run() throws Exception {\n-                                Field ff = ref.getClass().getDeclaredField(\"ref\");\n-                                ff.setAccessible(true);\n-                                return ff;\n-                            }\n-                        });\n-                    Object insideRef = f.get(ref);\n-                    System.err.println(\"insideRef = \" + insideRef);\n-                    if (insideRef instanceof ActivatableRef) {\n-                        TestLibrary.bomb(\"Embedded ref is an ActivatableRef\");\n-                    } else {\n-                        System.err.println(\"ActivatableRef's embedded ref type: \" +\n-                                           insideRef.getClass().getName());\n-                    }\n-\n-                    \/*\n-                     * Clean up object too.\n-                     *\/\n-                    System.err.println(\"Deactivate object via method call\");\n-                    obj.shutdown();\n-\n-                    try {\n-                        \/\/ give activation group time to go away\n-                        Thread.sleep(3000);\n-                    } catch (InterruptedException e) {\n-                    }\n-                }\n-            } catch (java.rmi.UnmarshalException ue) {\n-                \/\/ account for test's activation race condition\n-                if (ue.detail instanceof java.io.IOException) {\n-                    if ((failures ++) >= 3) {\n-                        throw ue;\n-                    }\n-                } else {\n-                    throw ue;\n-                }\n-            }\n-\n-            System.err.println(\"\\nsuccess: CheckActivateRef test passed \");\n-\n-        } catch (java.rmi.activation.ActivationException e) {\n-            \/\/ test only needs to pass 3 times in 7\n-            if (i < 4) {\n-                TestLibrary.bomb(e);\n-            }\n-        } catch (Exception e) {\n-            if (e instanceof java.security.PrivilegedActionException)\n-                e = ((java.security.PrivilegedActionException)e).getException();\n-            TestLibrary.bomb(\"\\nfailure: unexpected exception \" +\n-                             e.getClass().getName(), e);\n-\n-        } finally {\n-            rmid.cleanup();\n-            obj = null;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkActivateRef\/CheckActivateRef.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class CheckActivateRef_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = 10333549859256328L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public CheckActivateRef_Stub() {\n-        super();\n-    }\n-    public CheckActivateRef_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkActivateRef\/CheckActivateRef_Stub.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,11 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-\n-  permission java.lang.RuntimePermission \"getClassLoader\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkActivateRef\/group.security.policy","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.rmi.server.useDynamicProxies=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkActivateRef\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ test explicitly acccesses sun.rmi.server.ActivatableRef\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.server\";\n-\n-  \/\/ ref to make sure that internal ref is a UnicastRef\n-  permission java.lang.RuntimePermission \"accessDeclaredMembers\";\n-  permission java.lang.reflect.ReflectPermission \"suppressAccessChecks\";\n-\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.rmi.server.useDynamicProxies\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"getClassLoader\";\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkActivateRef\/security.policy","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,280 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4109103\n- * @summary rmid should annotate child process output\n- *\n- * @author Laird Dornin; code borrowed from Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider MyRMI CheckAnnotations_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=480 CheckAnnotations\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.*;\n-import java.security.CodeSource;\n-import java.util.Properties;\n-import java.util.StringTokenizer;\n-\n-\n-public class CheckAnnotations\n-    extends Activatable implements MyRMI, Runnable\n-{\n-    private static final double TIME_FACTOR = TestLibrary.getTimeoutFactor();\n-\n-    private static Object dummy = new Object();\n-    private static MyRMI myRMI = null;\n-\n-    \/\/ buffers to store rmid output.\n-    private static ByteArrayOutputStream rmidOut = new ByteArrayOutputStream();\n-    private static ByteArrayOutputStream rmidErr = new ByteArrayOutputStream();\n-\n-    public static void main(String args[]) {\n-        \/*\n-         * The following line is required with the JDK 1.2 VM so that the\n-         * VM can exit gracefully when this test completes.  Otherwise, the\n-         * conservative garbage collector will find a handle to the server\n-         * object on the native stack and not clear the weak reference to\n-         * it in the RMI runtime's object table.\n-         *\/\n-        Object dummy1 = new Object();\n-        RMID rmid = null;\n-\n-        System.err.println(\"\\nRegression test for bug\/rfe 4109103\\n\");\n-\n-        try {\n-\n-            \/\/ Set security manager according to the\n-            \/\/ testlibrary.\n-            TestLibrary.suggestSecurityManager(TestParams.defaultSecurityManager);\n-\n-            \/\/ start an rmid.\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort(rmidOut, rmidErr, false);\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/* new desc - we will reuse in order to get multiple vms.*\/\n-            System.err.println(\"Create activation group in this VM\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            ActivationGroup.createGroup(groupID, groupDesc, 0);\n-\n-            ActivationDesc desc = new ActivationDesc\n-                (\"CheckAnnotations\", null, null);\n-            myRMI = (MyRMI) Activatable.register(desc);\n-\n-            \/* The test-\n-             * Loop a bunch of times to force activator to\n-             * spawn VMs (groups)\n-             *\/\n-            for (int i = 0; i < 3; i++) {\n-\n-                \/\/ object activated in annotation check via method call\n-                checkAnnotations(i-1);\n-\n-                \/*\n-                 * Clean up object too.\n-                 *\/\n-                System.err.println\n-                    (\"Deactivate object via method call\");\n-                myRMI.shutdown();\n-            }\n-            System.err.println\n-                (\"\\nsuccess: CheckAnnotations test passed \");\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"\\nfailure: unexpected exception \", e);\n-        } finally {\n-            try {\n-                Thread.sleep(4000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            myRMI = null;\n-            System.err.println(\"rmid shut down\");\n-            rmid.cleanup();\n-        }\n-    }\n-\n-    \/**\n-     * check to make sure that the output from a spawned vm is\n-     * formatted\/annotated properly.\n-     *\/\n-    public static void checkAnnotations(int iteration)\n-        throws IOException\n-    {\n-        try {\n-            Thread.sleep((long)(5000 * TIME_FACTOR));\n-        } catch(Exception e) {\n-            System.err.println(e.getMessage());\n-        }\n-\n-        final String FAIL_MSG = \"Test failed: output improperly annotated.\";\n-        final String OUT = \"outABC\";\n-        final String ERR = \"errXYZ\";\n-        \/**\n-         * cause the spawned vm to generate output that will\n-         * be checked for proper annotation.  printOut is\n-         * actually being called on an activated implementation.\n-         *\/\n-        myRMI.printOut(OUT + iteration);\n-        myRMI.printErr(ERR + iteration);\n-        myRMI.printOut(OUT + iteration);\n-        myRMI.printErr(ERR + iteration);\n-\n-        \/* we have to wait for output to filter down\n-         * from children so we can read it before we\n-         * kill rmid.\n-         *\/\n-\n-        String outString = null;\n-        String errString = null;\n-\n-        for (int i = 0 ; i < 5 ; i ++ ) {\n-            \/\/ have to give output from rmid time to trickle down to\n-            \/\/ this process\n-            try {\n-                Thread.sleep((long)(4000 * TIME_FACTOR));\n-            } catch(InterruptedException e) {\n-            }\n-\n-            outString = rmidOut.toString();\n-            errString = rmidErr.toString();\n-\n-            if ((!outString.equals(\"\")) &&\n-                (!errString.equals(\"\")))\n-            {\n-                System.err.println(\"obtained annotations\");\n-                break;\n-            }\n-            System.err.println(\"rmid output not yet received, retrying...\");\n-        }\n-\n-        rmidOut.reset();\n-        rmidErr.reset();\n-\n-        \/\/ only test when we are annotating..., first run does not annotate\n-        if (iteration >= 0) {\n-            System.err.println(\"Checking annotations...\");\n-            System.err.println(outString);\n-            System.err.println(errString);\n-\n-            StringTokenizer stOut = new StringTokenizer(outString, \":\");\n-            StringTokenizer stErr = new StringTokenizer(errString, \":\");\n-\n-            String execErr = null;\n-            String execOut = null;\n-            String destOut = null;\n-            String destErr = null;\n-            String outTmp  = null;\n-            String errTmp  = null;\n-\n-            while (stOut.hasMoreTokens()) {\n-                execOut = outTmp;\n-                outTmp  = destOut;\n-                destOut = stOut.nextToken();\n-            }\n-            while (stErr.hasMoreTokens()) {\n-                execErr = errTmp;\n-                errTmp  = destErr;\n-                destErr = stErr.nextToken();\n-            }\n-\n-            if ((execErr == null)||(errTmp == null)||\n-                (destErr == null)) {\n-                TestLibrary.bomb(FAIL_MSG);\n-            }\n-            if ((execOut == null)||(outTmp == null)||\n-                (destOut == null)) {\n-                TestLibrary.bomb(FAIL_MSG);\n-            }\n-\n-\n-            \/\/ just make sure that last two strings are what we expect.\n-            if (!execOut.equals(\"ExecGroup-\" + iteration)\n-                || !(new String(destOut.substring(0,OUT.length()+1)).equals(OUT +\n-                                                              iteration))\n-                || !(execErr.equals(\"ExecGroup-\"+iteration))\n-                || !(new String(destErr.substring(0,ERR.length()+1)).equals(ERR +\n-                                                              iteration)) ) {\n-                TestLibrary.bomb(FAIL_MSG);\n-            }\n-        }\n-    }\n-\n-    \/\/ implementation of MyRMI, make this object activatable.\n-    public CheckAnnotations\n-        (ActivationID id, MarshalledObject mo)\n-     throws RemoteException {\n-\n-        \/\/ register\/export anonymously\n-        super(id,0);\n-    }\n-\n-    public void printOut(String toPrint) {\n-        System.out.println(toPrint);\n-    }\n-\n-    public void printErr(String toPrint) {\n-        System.err.println(toPrint);\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception {\n-        (new Thread(this,\"CheckAnnotations\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkAnnotations\/CheckAnnotations.java","additions":0,"deletions":280,"binary":false,"changes":280,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class CheckAnnotations_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements MyRMI, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void printErr(java.lang.String)\"),\n-        new java.rmi.server.Operation(\"void printOut(java.lang.String)\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = -3955951123118841923L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_printErr_0;\n-    private static java.lang.reflect.Method $method_printOut_1;\n-    private static java.lang.reflect.Method $method_shutdown_2;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_printErr_0 = MyRMI.class.getMethod(\"printErr\", new java.lang.Class[] {java.lang.String.class});\n-            $method_printOut_1 = MyRMI.class.getMethod(\"printOut\", new java.lang.Class[] {java.lang.String.class});\n-            $method_shutdown_2 = MyRMI.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public CheckAnnotations_Stub() {\n-        super();\n-    }\n-    public CheckAnnotations_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of printErr(String)\n-    public void printErr(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_printErr_0, new java.lang.Object[] {$param_String_1}, 1120261287704800747L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                try {\n-                    java.io.ObjectOutput out = call.getOutputStream();\n-                    out.writeObject($param_String_1);\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.MarshalException(\"error marshalling arguments\", e);\n-                }\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of printOut(String)\n-    public void printOut(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_printOut_1, new java.lang.Object[] {$param_String_1}, -7517735248176918178L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-                try {\n-                    java.io.ObjectOutput out = call.getOutputStream();\n-                    out.writeObject($param_String_1);\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.MarshalException(\"error marshalling arguments\", e);\n-                }\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_2, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkAnnotations\/CheckAnnotations_Stub.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface MyRMI extends java.rmi.Remote {\n-    public void printOut(String toPrint) throws RemoteException;\n-    public void printErr(String toPrint) throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkAnnotations\/MyRMI.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkAnnotations\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkAnnotations\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkAnnotations\/security.policy","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\n- *\/\n-\n-import java.rmi.activation.Activatable;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.MarshalledObject;\n-import java.net.URL;\n-\n-public class ActivatableImpl extends Activatable implements MyRMI {\n-\n-    private boolean classLoaderOk = false;\n-\n-    public ActivatableImpl(ActivationID id, MarshalledObject mobj)\n-        throws RemoteException\n-    {\n-        super(id, 0);\n-\n-        ClassLoader thisLoader = ActivatableImpl.class.getClassLoader();\n-        ClassLoader ccl = Thread.currentThread().getContextClassLoader();\n-\n-        System.err.println(\"implLoader: \" + thisLoader);\n-        System.err.println(\"ccl: \" + ccl);\n-\n-        \/*\n-         * the context class loader is the ccl from when this object\n-         * was exported.  If the bug has been fixed, the ccl will be\n-         * the same as the class loader of this class.\n-         *\/\n-        classLoaderOk = (thisLoader == ccl);\n-    }\n-\n-    public boolean classLoaderOk() throws RemoteException {\n-        return classLoaderOk;\n-    }\n-\n-    public void shutdown() throws Exception {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkImplClassLoader\/ActivatableImpl.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ActivatableImpl_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements MyRMI, java.rmi.Remote\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_classLoaderOk_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            $method_classLoaderOk_0 = MyRMI.class.getMethod(\"classLoaderOk\", new java.lang.Class[] {});\n-            $method_shutdown_1 = MyRMI.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ActivatableImpl_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of classLoaderOk()\n-    public boolean classLoaderOk()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            Object $result = ref.invoke(this, $method_classLoaderOk_0, null, 5226188865994330896L);\n-            return ((java.lang.Boolean) $result).booleanValue();\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkImplClassLoader\/ActivatableImpl_Stub.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4289544\n- * @summary ActivationGroupImpl.newInstance does not set context classloader for impl\n- * @author Laird Dornin; code borrowed from Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider\n- *     MyRMI ActivatableImpl ActivatableImpl ActivatableImpl_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=150 CheckImplClassLoader\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.*;\n-import java.net.URL;\n-\n-\/**\n- * sun.rmi.server.ActivationGroupImpl.newInstance() needs to set the\n- * context class loader when it constructs the implementation class of\n- * an Activatable object.  It needs to set the ccl to be the class\n- * loader of the implementation class.\n- *\n- * Test creates an Activatable object whose impl is loaded outside of\n- * CLASSPATH.  The impls constructor checks to make sure that the\n- * correct context class loader has been set when the constructor is\n- * invoked.\n- *\/\n-public class CheckImplClassLoader {\n-\n-    private static Object dummy = new Object();\n-    private static MyRMI myRMI = null;\n-    private static ActivationGroup group = null;\n-\n-    public static void main(String args[]) {\n-        \/*\n-         * The following line is required with the JDK 1.2 VM because\n-         * of gc hocus pocus that may no longer be needed with an\n-         * exact vm (hotspot).\n-         *\/\n-        Object dummy1 = new Object();\n-        RMID rmid = null;\n-\n-        System.err.println(\"\\nRegression test for bug\/rfe 4289544\\n\");\n-\n-        try {\n-\n-            URL implcb = TestLibrary.installClassInCodebase(\"ActivatableImpl\",\n-                                                            \"implcb\");\n-            TestLibrary.installClassInCodebase(\"ActivatableImpl_Stub\",\n-                                               \"implcb\");\n-            TestLibrary.suggestSecurityManager(\n-                TestParams.defaultSecurityManager);\n-\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            System.err.println(\"Create activation group in this VM\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(null, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            group = ActivationGroup.createGroup(groupID, groupDesc, 0);\n-\n-            ActivationDesc desc = new ActivationDesc(\"ActivatableImpl\",\n-                                                     implcb.toString(), null);\n-            myRMI = (MyRMI) Activatable.register(desc);\n-\n-            System.err.println(\"Checking that impl has correct \" +\n-                               \"context class loader\");\n-            if (!myRMI.classLoaderOk()) {\n-                TestLibrary.bomb(\"incorrect context class loader for \" +\n-                                 \"activation constructor\");\n-            }\n-\n-            System.err.println(\"Deactivate object via method call\");\n-            myRMI.shutdown();\n-\n-            System.err.println(\"\\nsuccess: CheckImplClassLoader test passed \");\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"\\nfailure: unexpected exception \", e);\n-        } finally {\n-            try {\n-                Thread.sleep(4000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            myRMI = null;\n-            System.err.println(\"rmid shut down\");\n-            rmid.cleanup();\n-            TestLibrary.unexport(group);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkImplClassLoader\/CheckImplClassLoader.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2000, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-\n-public interface MyRMI extends java.rmi.Remote {\n-    public boolean classLoaderOk() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkImplClassLoader\/MyRMI.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkImplClassLoader\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ need to move some classes out of the tests classpath; specific to this test\n-  permission java.io.FilePermission \"${test.classes}\", \"read,write,delete\";\n-  permission java.io.FilePermission \"${test.classes}${\/}-\", \"read,write,delete\";\n-\n-  \/\/ need to load custom security manager and activation group from a new codebase\n-  permission java.io.FilePermission \".${\/}implcb\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}implcb${\/}-\", \"read,write,delete\";\n-\n-  \/\/ impl class needs to compare context class loader to its own class loader\n-  permission java.lang.RuntimePermission \"getClassLoader\";\n-\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkImplClassLoader\/security.policy","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkRegisterInLog\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,175 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4110548\n- * @summary activate fails if rmid is restarted\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- *     ActivateMe CheckRegisterInLog_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 CheckRegisterInLog\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.*;\n-import sun.rmi.server.ActivatableRef;\n-import java.lang.reflect.*;\n-import java.util.Properties;\n-\n-public class CheckRegisterInLog\n-        extends Activatable\n-        implements ActivateMe, Runnable\n-{\n-\n-    public CheckRegisterInLog(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        super(id, 0);\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"CheckRegisterInLog\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args)  {\n-        \/*\n-         * The following line is required with the JDK 1.2 VM so that the\n-         * VM can exit gracefully when this test completes.  Otherwise, the\n-         * conservative garbage collector will find a handle to the server\n-         * object on the native stack and not clear the weak reference to\n-         * it in the RMI runtime's object table.\n-         *\/\n-        Object dummy = new Object();\n-        RMID rmid = null;\n-        ActivateMe obj;\n-\n-        System.out.println(\"\\nRegression test for bug 4110548\\n\");\n-\n-        CheckRegisterInLog server;\n-\n-        try {\n-            TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-            \/*\n-             * Start up activation system daemon \"rmid\".\n-             *\/\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Register an activation group and an object\n-             * in that group.\n-             *\/\n-            System.err.println(\"Creating group descriptor\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            System.err.println(\"Registering group\");\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-\n-            System.err.println(\"Creating descriptor\");\n-            ActivationDesc desc =\n-                new ActivationDesc(groupID, \"CheckRegisterInLog\",\n-                                   null, null);\n-            System.err.println(\"Registering descriptor\");\n-            obj = (ActivateMe)Activatable.register(desc);\n-\n-            \/*\n-             * Restart rmid to force it to read the log file\n-             *\/\n-            rmid.restart();\n-\n-\n-            \/*\n-             * 4212096: Give rmid time to go away - we want to make\n-             * sure that an attempt to activate the test object is not made\n-             * on the ActivationSystem that is about to be shutdown.\n-             *\/\n-            try {\n-                Thread.sleep(5000);\n-            } catch (InterruptedException ie) {\n-            }\n-\n-            \/*\n-             * Activate the object via a method call.\n-             *\/\n-            System.err.println(\"Activate the object via method call\");\n-            obj.ping();\n-\n-            \/*\n-             * Clean up object too.\n-             *\/\n-            System.err.println(\"Deactivate object via method call\");\n-            obj.shutdown();\n-\n-            System.err.println(\"\\nsuccess: CheckRegisterInLog test passed \");\n-\n-        } catch (Exception e) {\n-            System.err.println(\"\\nfailure: unexpected exception \" +\n-                               e.getClass().getName() + \": \" + e.getMessage());\n-            e.printStackTrace(System.err);\n-            throw new RuntimeException(\"CheckRegisterInLog got exception \" +\n-                                       e.getMessage());\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkRegisterInLog\/CheckRegisterInLog.java","additions":0,"deletions":175,"binary":false,"changes":175,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class CheckRegisterInLog_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = 10333549859256328L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public CheckRegisterInLog_Stub() {\n-        super();\n-    }\n-    public CheckRegisterInLog_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkRegisterInLog\/CheckRegisterInLog_Stub.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkRegisterInLog\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkRegisterInLog\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ allow exporting object with non-public remote interface\n-  permission java.rmi.RMIPermission \"exportRemoteInterface.ActivateMe\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/checkRegisterInLog\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/createPrivateActivable\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4164971\n- * @summary allow non-public activatable class and\/or constructor\n- * @author Laird Dornin\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivateMe\n- * @run main\/othervm\/policy=security.policy\/timeout=240 CreatePrivateActivatable\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.*;\n-import sun.rmi.server.ActivatableRef;\n-import java.lang.reflect.*;\n-import java.util.Properties;\n-\n-\/**\n- * Test creates a private inner class Activatable object with a\n- * private constructor and makes sure that the object can be\n- * activated.\n- *\/\n-public class CreatePrivateActivatable\n-{\n-    private static class PrivateActivatable extends Activatable\n-        implements ActivateMe, Runnable\n-    {\n-        private PrivateActivatable(ActivationID id, MarshalledObject obj)\n-            throws ActivationException, RemoteException\n-        {\n-            super(id, 0);\n-        }\n-\n-        public void ping()\n-        {}\n-\n-        \/**\n-         * Spawns a thread to deactivate the object.\n-         *\/\n-        public void shutdown() throws Exception\n-        {\n-            (new Thread(this, \"CreatePrivateActivatable$PrivateActivatable\")).start();\n-        }\n-\n-        \/**\n-         * Thread to deactivate object. First attempts to make object\n-         * inactive (via the inactive method).  If that fails (the\n-         * object may still have pending\/executing calls), then\n-         * unexport the object forcibly.\n-         *\/\n-        public void run() {\n-            ActivationLibrary.deactivate(this, getID());\n-        }\n-    }\n-\n-    public static void main(String[] args)  {\n-        \/*\n-         * The following line is required with the JDK 1.2 VM so that the\n-         * VM can exit gracefully when this test completes.  Otherwise, the\n-         * conservative garbage collector will find a handle to the server\n-         * object on the native stack and not clear the weak reference to\n-         * it in the RMI runtime's object table.\n-         *\/\n-        Object dummy = new Object();\n-        RMID rmid = null;\n-        ActivateMe obj;\n-\n-        System.err.println(\"\\nRegression test for bug 4164971\\n\");\n-        System.err.println(\"java.security.policy = \" +\n-                           System.getProperty(\"java.security.policy\", \"no policy\"));\n-\n-        CreatePrivateActivatable server;\n-        try {\n-            TestLibrary.suggestSecurityManager(TestParams.defaultSecurityManager);\n-\n-            \/\/ start an rmid.\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Activate an object by registering its object\n-             * descriptor and invoking a method on the\n-             * stub returned from the register call.\n-             *\/\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-\n-            System.err.println(\"Creating descriptor\");\n-            ActivationDesc desc =\n-                new ActivationDesc(groupID,\n-                    \"CreatePrivateActivatable$PrivateActivatable\",\n-                     null, null);\n-\n-            System.err.println(\"Registering descriptor\");\n-            obj = (ActivateMe) Activatable.register(desc);\n-\n-            \/*\n-             * Loop a bunch of times to force activator to\n-             * spawn VMs (groups)\n-             *\/\n-            System.err.println(\"Activate object via method call\");\n-            obj.ping();\n-\n-            \/*\n-             * Clean up object too.\n-             *\/\n-            System.err.println(\"Deactivate object via method call\");\n-            obj.shutdown();\n-\n-            System.err.println(\"\\nsuccess: CreatePrivateActivatable test passed \");\n-\n-        } catch (Exception e) {\n-            if (e instanceof java.security.PrivilegedActionException) {\n-                e = ((java.security.PrivilegedActionException)e).getException();\n-            }\n-            TestLibrary.bomb(\"\\nfailure: unexpected exception \" +\n-                             e.getClass().getName(), e);\n-\n-        } finally {\n-            rmid.cleanup();\n-            obj = null;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/createPrivateActivable\/CreatePrivateActivatable.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/createPrivateActivable\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/createPrivateActivable\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ allow exporting object with non-public remote interface\n-  permission java.rmi.RMIPermission \"exportRemoteInterface.ActivateMe\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/createPrivateActivable\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class Bar extends Foo {\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/Bar.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,149 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4149366\n- * @summary The class loader used to load classes for parameter types sent in\n- * an RMI call to an activatable object should delegate to the class loader\n- * that loaded the class of the activatable object itself, to maximize the\n- * likelihood of type compatibility between downloaded parameter types and\n- * supertypes shared with the activatable object.\n- * @author Peter Jones (much code taken from Ann Wollrath's activation tests)\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- *     Foo FooReceiverImpl FooReceiverImpl_Stub Bar\n- * @run main\/othervm\/policy=security.policy\/timeout=240 DownloadParameterClass\n- *\/\n-\n-import java.io.*;\n-import java.net.*;\n-import java.util.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-\n-public class DownloadParameterClass {\n-\n-    public interface FooReceiver extends Remote {\n-\n-        \/*\n-         * The interface can't actually declare that the method takes a\n-         * Foo, because then Foo would have to be in the test's CLASSPATH,\n-         * which might get propagated to the group VM's CLASSPATH, which\n-         * would nullify the test (the Foo supertype must be loaded in the\n-         * group VM only through the class loader that loaded the\n-         * activatable object).\n-         *\/\n-        public void receiveFoo(Object obj) throws RemoteException;\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.err.println(\"\\nRegression test for bug 4149366\\n\");\n-\n-        \/*\n-         * Install classes to be seen by the activatable object's class\n-         * loader in the \"codebase1\" subdirectory of working directory, and\n-         * install the subtype to be downloaded into the activatable object\n-         * into the \"codebase2\" subdirectory.\n-         *\/\n-        URL codebase1 = null;\n-        URL codebase2 = null;\n-        try {\n-            codebase1 = TestLibrary.installClassInCodebase(\"FooReceiverImpl\", \"codebase1\");\n-            TestLibrary.installClassInCodebase(\"FooReceiverImpl_Stub\", \"codebase1\");\n-            TestLibrary.installClassInCodebase(\"Foo\", \"codebase1\");\n-            codebase2 = TestLibrary.installClassInCodebase(\"Bar\", \"codebase2\");\n-        } catch (MalformedURLException e) {\n-            TestLibrary.bomb(\"failed to install test classes\", e);\n-        }\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Create and register descriptors for activatable object in a\n-             * group other than this VM's group, so that another VM will be\n-             * spawned with the object is activated.\n-             *\/\n-            System.err.println(\"Creating descriptors\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-            ActivationDesc objDesc =\n-                new ActivationDesc(groupID, \"FooReceiverImpl\",\n-                                   codebase1.toString(), null, false);\n-\n-            System.err.println(\"Registering descriptors\");\n-            FooReceiver obj = (FooReceiver) Activatable.register(objDesc);\n-\n-            \/*\n-             * Create an instance of the subtype to be downloaded by the\n-             * activatable object.  The codebase must be a path including\n-             * \"codebase1\" as well as \"codebase2\" because the supertype\n-             * must be visible here as well; the supertype cannot be\n-             * installed in both codebases (like it would be in a typical\n-             * setup) because of the trivial installation mechanism used\n-             * below, and see the comment above for why it can't be in\n-             * the test's CLASSPATH.\n-             *\/\n-            Class subtype = RMIClassLoader.loadClass(\n-                codebase2 + \" \" + codebase1, \"Bar\");\n-            Object subtypeInstance = subtype.newInstance();\n-\n-            obj.receiveFoo(subtypeInstance);\n-\n-            System.err.println(\"\\nTEST PASSED\\n\");\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/DownloadParameterClass.java","additions":0,"deletions":149,"binary":false,"changes":149,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public class Foo implements java.io.Serializable {\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/Foo.java","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-\n-public class FooReceiverImpl implements DownloadParameterClass.FooReceiver {\n-\n-    private ActivationID id;\n-\n-    public FooReceiverImpl(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-    }\n-\n-    public void receiveFoo(Object obj) {\n-        \/*\n-         * Cast argument to the type \"Foo\" as resolved from this activatble\n-         * object's class; a ClassCastException will be thrown if the argument\n-         * implements a type \"Foo\" loaded from a different class loader.\n-         *\/\n-        Foo foo = (Foo) obj;\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/FooReceiverImpl.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class FooReceiverImpl_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements DownloadParameterClass. FooReceiver\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_receiveFoo_0;\n-\n-    static {\n-        try {\n-            $method_receiveFoo_0 = DownloadParameterClass. FooReceiver.class.getMethod(\"receiveFoo\", new java.lang.Class[] {java.lang.Object.class});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public FooReceiverImpl_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of receiveFoo(Object)\n-    public void receiveFoo(java.lang.Object $param_Object_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            ref.invoke(this, $method_receiveFoo_0, new java.lang.Object[] {$param_Object_1}, -1548895758515635945L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/FooReceiverImpl_Stub.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,15 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-\n-  \/\/ need to load custom security manager and activation group from a new codebase\n-  permission java.io.FilePermission \".${\/}codebase1\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}codebase1${\/}-\", \"read,write\";\n-  permission java.io.FilePermission \".${\/}codebase2\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}codebase2${\/}-\", \"read,write,delete\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/group.security.policy","additions":0,"deletions":15,"binary":false,"changes":15,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ need to move some classes out of the tests classpath; specific to this test\n-  permission java.io.FilePermission \".\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}-\", \"read,write,delete\";\n-\n-  \/\/ need to load custom security manager and activation group from a new codebase\n-  permission java.io.FilePermission \".${\/}codebase1\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}codebase1${\/}-\", \"read,write\";\n-  permission java.io.FilePermission \".${\/}codebase2\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}codebase2${\/}-\", \"read,write,delete\";\n-\n-  \/\/ standard activation permissions\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment \n-  permission java.util.PropertyPermission \"test.classes\", \"read\";\n-  permission java.util.PropertyPermission \"test.src\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/manual.security.policy","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ need to move some classes out of the tests classpath; specific to this test\n-  permission java.io.FilePermission \"${test.classes}\", \"read,write,delete\";\n-  permission java.io.FilePermission \"${test.classes}${\/}-\", \"read,write,delete\";\n-\n-  \/\/ need to load custom security manager and activation group from a new codebase\n-  permission java.io.FilePermission \".${\/}codebase1\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}codebase1${\/}-\", \"read,write\";\n-  permission java.io.FilePermission \".${\/}codebase2\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}codebase2${\/}-\", \"read,write,delete\";\n-\n-  \/\/ standard activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/downloadParameterClass\/security.policy","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/elucidateNoSuchMethod\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4128620\n- * @summary synopsis: NoSuchMethodError should be elucidated\n- * @author Laird Dornin\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivateMe ElucidateNoSuchMethod_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 ElucidateNoSuchMethod\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Properties;\n-\n-public class ElucidateNoSuchMethod\n-        extends Activatable\n-        implements ActivateMe, Runnable\n-{\n-\n-    \/**\n-     *  provide a constructor that alllows this object to be made\n-     *  activatable, or at least registered.\n-     *\/\n-    ElucidateNoSuchMethod(ActivationID id, int port)\n-        throws RemoteException\n-    {\n-        super(id, port);\n-    }\n-\n-    \/**\n-     * dont provide an activation constructor so that we get a no such\n-     * method error.\n-     *\/\n-\n-    public void ping() {}\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception {\n-        (new Thread(this,\"ElucidateNoSuchMethod\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for 4128620 \\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            System.err.println(\"Create activation group in this VM\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            ActivationGroup.createGroup(groupID, groupDesc, 0);\n-\n-            System.err.println(\"Creating descriptor\");\n-            ActivationDesc desc =\n-                new ActivationDesc(\"ElucidateNoSuchMethod\", null, null);\n-\n-            System.err.println(\"Registering descriptor\");\n-            ActivateMe obj = (ActivateMe) Activatable.register(desc);\n-\n-            System.err.println(\"Activate object via method call\");\n-\n-            try {\n-                obj.ping();\n-            } catch (ActivateFailedException afe) {\n-                ActivationException a = (ActivationException) afe.detail;\n-\n-                if (((a.detail instanceof NoSuchMethodException) ||\n-                     (a.detail instanceof NoSuchMethodError)) &&\n-                        (a.getMessage().indexOf\n-                      (\"must provide an activation constructor\") > -1)) {\n-                    System.err.println(\"\\ntest passed for 4128620\\n\");\n-                } else {\n-                    TestLibrary.bomb(\"test failed\", afe);\n-                }\n-            }\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/elucidateNoSuchMethod\/ElucidateNoSuchMethod.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,104 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ElucidateNoSuchMethod_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = 10333549859256328L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ElucidateNoSuchMethod_Stub() {\n-        super();\n-    }\n-    public ElucidateNoSuchMethod_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/elucidateNoSuchMethod\/ElucidateNoSuchMethod_Stub.java","additions":0,"deletions":104,"binary":false,"changes":104,"status":"deleted"},{"patch":"@@ -1,13 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-\n-  \/\/ Needed because of bug#: 4182104\n-  permission java.lang.RuntimePermission \"modifyThreadGroup\";\n-  permission java.lang.RuntimePermission \"modifyThread\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/elucidateNoSuchMethod\/group.security.policy","additions":0,"deletions":13,"binary":false,"changes":13,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/elucidateNoSuchMethod\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ Needed because of bug#: 4182104\n-  permission java.lang.RuntimePermission \"modifyThreadGroup\";\n-  permission java.lang.RuntimePermission \"modifyThread\";\n-\n-  \/\/ properties are needed because of bug#: 4179055\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.server\";\n-  permission java.util.PropertyPermission \"package.restrict.access.sun\", \"read\";\n-  permission java.util.PropertyPermission \"package.restrict.access.sun.rmi\", \"read\";\n-\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/elucidateNoSuchMethod\/security.policy","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,26 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public interface CheckLoader extends java.rmi.Remote {\n-    boolean isCorrectContextLoader() throws java.rmi.RemoteException;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/CheckLoader.java","additions":0,"deletions":26,"binary":false,"changes":26,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-\n-public class ExtLoadedImpl implements CheckLoader {\n-\n-    public ExtLoadedImpl(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        Activatable.exportObject(this, id, 0);\n-    }\n-\n-    public boolean isCorrectContextLoader() {\n-        ClassLoader contextLoader =\n-            Thread.currentThread().getContextClassLoader();\n-        ClassLoader implLoader = this.getClass().getClassLoader();\n-        if (contextLoader == implLoader) {\n-            System.err.println(\"contextLoader same as implLoader\");\n-            return false;\n-        } else if (contextLoader.getParent() == implLoader) {\n-            System.err.println(\"contextLoader is child of implLoader\");\n-            return true;\n-        } else {\n-            System.err.println(\"unknown loader relationship\");\n-            return false;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/ExtLoadedImpl.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.util.*;\n-\n-public class ExtLoadedImplTest {\n-\n-    public static void main(String[] args) {\n-\n-        System.err.println(\"\\nRegression test for bug 4500504\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-            Properties p = new Properties();\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-            p.put(\"java.ext.dirs\", \"ext\");\n-\n-\n-            System.err.println(\"Creating descriptors\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-            ActivationDesc objDesc =\n-                new ActivationDesc(groupID, \"ExtLoadedImpl\", null, null);\n-\n-            System.err.println(\"Registering descriptors\");\n-            CheckLoader obj = (CheckLoader) Activatable.register(objDesc);\n-\n-            boolean result = obj.isCorrectContextLoader();\n-\n-            System.err.println(\"\\nTEST \" +\n-                               ((result) ? \"PASSED\" : \"FAILED\") + \"\\n\");\n-\n-            if (!result) {\n-                throw new RuntimeException(\"TEST FAILED\");\n-            }\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/ExtLoadedImplTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ExtLoadedImpl_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements CheckLoader\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_isCorrectContextLoader_0;\n-\n-    static {\n-        try {\n-            $method_isCorrectContextLoader_0 = CheckLoader.class.getMethod(\"isCorrectContextLoader\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ExtLoadedImpl_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of isCorrectContextLoader()\n-    public boolean isCorrectContextLoader()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            Object $result = ref.invoke(this, $method_isCorrectContextLoader_0, null, -5210790440944383968L);\n-            return ((java.lang.Boolean) $result).booleanValue();\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/ExtLoadedImpl_Stub.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,60 +0,0 @@\n-#\n-# Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 4500504\n-# @summary If the context class loader is a child of the impl's class\n-# loader, the context class loader should remain unchanged (i.e., not be\n-# set to the impl's class loader) when the impl is activated.\n-# @library ..\/..\/..\/testlibrary\n-# @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n-# @build ExtLoadedImplTest ExtLoadedImpl ExtLoadedImpl_Stub CheckLoader\n-# @run shell ext.sh\n-\n-OS=`uname -s`\n-case \"$OS\" in\n-  Linux | Darwin | AIX )\n-    PS=\":\"\n-    ;;\n-  Windows* | CYGWIN* )\n-    PS=\";\"\n-    ;;\n-  * )\n-    echo \"Unrecognized system!\"\n-    exit 1;\n-    ;;\n-esac\n-\n-mkdir -p classes\n-for dir in `echo ${TESTCLASSPATH:-$TESTCLASSES} | sed -e \"s\/$PS\/ \/\"` ; do cp $dir\/*.class classes ; done\n-rm classes\/ExtLoadedImpl.class classes\/ExtLoadedImpl_Stub.class classes\/CheckLoader.class\n-mkdir -p ext\n-$COMPILEJAVA\/bin\/jar ${TESTTOOLVMOPTS} cf ext\/ext.jar -C $TESTCLASSES ExtLoadedImpl.class -C $TESTCLASSES ExtLoadedImpl_Stub.class -C $TESTCLASSES CheckLoader.class\n-\n-TESTVMOPTS=\"${TESTVMOPTS} \\\n- --add-exports java.rmi\/sun.rmi.registry=ALL-UNNAMED \\\n- --add-exports java.rmi\/sun.rmi.server=ALL-UNNAMED \\\n- --add-exports java.rmi\/sun.rmi.transport=ALL-UNNAMED \\\n- --add-exports java.rmi\/sun.rmi.transport.tcp=ALL-UNNAMED\"\n-$TESTJAVA\/bin\/java ${TESTVMOPTS} -cp classes -Dtest.src=$TESTSRC -Dtest.classes=$TESTCLASSES -Djava.security.policy=$TESTSRC\/security.policy -Djava.ext.dirs=ext ExtLoadedImplTest\n-\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/ext.sh","additions":0,"deletions":60,"binary":false,"changes":60,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-   permission com.sun.rmi.rmid.ExecOptionPermission\n-\t\"-Djava.security.manager=*\";\n-   permission com.sun.rmi.rmid.ExecOptionPermission\n-\t\"-Djava.security.policy=*\";\n-   permission com.sun.rmi.rmid.ExecOptionPermission\n-\t\"-Djava.ext.dirs=*\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,25 +0,0 @@\n-\n-grant {\n-  \/\/ standard activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/extLoadedImpl\/security.policy","additions":0,"deletions":25,"binary":false,"changes":25,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping(int intId, String responder) throws RemoteException;\n-    public void crash() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,290 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4173960\n- * @summary synopsis: Activatable objects cannot be restarted.\n- * @author Laird Dornin\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- *     ActivateMe ForceLogSnapshot_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=640 ForceLogSnapshot\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.*;\n-\n-public class ForceLogSnapshot\n-        implements ActivateMe\n-{\n-    \/** how many activatable remote objects to create to test rmid *\/\n-    final public static int HOW_MANY = 50;\n-    final public static int NUM_GROUPS = 4;\n-    \/** cause RMID to generate a snapshot every 10th activated object *\/\n-    final public static int SNAPSHOT_INTERVAL = 10;\n-\n-    private ActivationID id;\n-    private Vector responders = new Vector();\n-\n-    private static final String RESTARTABLE = \"restartable\";\n-    private static final String ACTIVATABLE = \"activatable\";\n-\n-    private static Object lock = new Object();\n-    private static boolean[] restartedObjects = new boolean[HOW_MANY];\n-    private static boolean[] activatedObjects = new boolean[HOW_MANY];\n-\n-    public ForceLogSnapshot(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        int intId = 0;\n-\n-        Activatable.exportObject(this, id, 0);\n-        ActivateMe obj;\n-        String responder;\n-        try {\n-            Object[] stuff = (Object[]) mobj.get();\n-\n-            intId = ((Integer) stuff[0]).intValue();\n-            responder = (String) stuff[1];\n-            obj = (ActivateMe) stuff[2];\n-\n-            System.err.println(responder + \" service started\");\n-        } catch (Exception e) {\n-            System.err.println(\"unable to obtain stub from marshalled object\");\n-            System.err.println(e.getMessage());\n-            e.printStackTrace();\n-            return;\n-        }\n-\n-        obj.ping(intId, responder);\n-    }\n-\n-    public ForceLogSnapshot() throws RemoteException {\n-        UnicastRemoteObject.exportObject(this, 0);\n-    }\n-\n-    public void ping(int intId, String responder) {\n-        System.err.println(\"ForceLogSnapshot: received ping from \" +\n-                           responder);\n-        if (responder.equals(RESTARTABLE)) {\n-            synchronized (lock) {\n-                restartedObjects[intId] = true;\n-            }\n-        } else if (responder.equals(ACTIVATABLE)) {\n-            synchronized (lock) {\n-                activatedObjects[intId] = true;\n-            }\n-        }\n-    }\n-\n-    public void crash() {\n-        System.exit(0);\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4173960\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-        ForceLogSnapshot[] unicastObjs = new ForceLogSnapshot[HOW_MANY];\n-\n-        try {\n-            String option = \" -Dsun.rmi.activation.snapshotInterval=\" +\n-                SNAPSHOT_INTERVAL;\n-\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.addOptions(new String[] {option, \"-Djava.compiler=\"});\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            Object[][] stuff = new Object[HOW_MANY][];\n-            MarshalledObject restartMobj = null;\n-            ActivationGroupDesc groupDesc = null;\n-            MarshalledObject activateMobj = null;\n-            ActivationGroupID[] groupIDs = new ActivationGroupID[NUM_GROUPS];\n-            ActivationDesc restartableDesc = null;\n-            ActivationDesc activatableDesc = null;\n-            ActivateMe[] restartableObj = new ActivateMe[HOW_MANY];\n-            ActivateMe[] activatableObj = new ActivateMe[HOW_MANY];\n-\n-            \/*\n-             * Create unicast object to be contacted when service is activated.\n-             *\/\n-            int group = 0;\n-            int groupNo = 0;\n-            for (int i = 0 ; i < HOW_MANY ; i ++ ) {\n-\n-                System.err.println(\"Creating descriptors and remote objects\");\n-\n-                unicastObjs[i] = new ForceLogSnapshot();\n-\n-                \/*\n-                 * Create and register descriptors for a restartable and\n-                 * non-restartable service (respectively) in a group other than\n-                 * this VM's group.\n-                 *\/\n-                stuff[i] = new Object[] { new Integer(i),\n-                                              RESTARTABLE, unicastObjs[i] };\n-                restartMobj = new MarshalledObject(stuff[i]);\n-\n-                stuff[i][1] = ACTIVATABLE;\n-                activateMobj = new MarshalledObject(stuff[i]);\n-\n-                groupDesc =\n-                    new ActivationGroupDesc(p, null);\n-\n-                if (i < NUM_GROUPS) {\n-                    groupNo = i;\n-                    groupIDs[groupNo] =\n-                        ActivationGroup.getSystem().\n-                        registerGroup(groupDesc);\n-                } else {\n-                    groupNo = (group++)%NUM_GROUPS;\n-                }\n-\n-                System.err.println(\"Objects group number: \" + groupNo);\n-\n-                restartableDesc =\n-                    new ActivationDesc(groupIDs[groupNo], \"ForceLogSnapshot\", null,\n-                                       restartMobj, true);\n-\n-                activatableDesc =\n-                    new ActivationDesc(groupIDs[groupNo], \"ForceLogSnapshot\", null,\n-                                       activateMobj, false);\n-\n-                System.err.println(\"Registering descriptors\");\n-                restartableObj[i] =\n-                    (ActivateMe) Activatable.register(restartableDesc);\n-\n-                activatableObj[i] =\n-                    (ActivateMe) Activatable.register(activatableDesc);\n-                System.err.println(\"registered activatable #: \" + i);\n-\n-                \/\/ start reusing groups if we need to do so.\n-            }\n-\n-            int repeatOnce = 1;\n-            do {\n-\n-                \/*\n-                 * Restart rmid; it should start up the restartable service\n-                 *\/\n-                rmid.restart();\n-\n-                if (howManyRestarted(restartedObjects, 10) < HOW_MANY) {\n-                        TestLibrary.bomb(\"Test1 failed: a service would not \" +\n-                                         \"restart\");\n-                }\n-                System.err.println(\"Test1 passed: rmid \" +\n-                                   \"all service(s) restarted. Performing next test.\");\n-\n-                \/*\n-                 * Make sure no activatable services were automatically\n-                 * restarted.\n-                 *\/\n-                if (howManyRestarted(activatedObjects, 2) != 0) {\n-                    TestLibrary.bomb(\"Test2 failed: activatable service restarted!\",\n-                                     null);\n-                }\n-                System.err.println(\"Test2 passed: rmid did not \" +\n-                                   \"restart activatable service(s)\");\n-\n-                if (repeatOnce > 0) {\n-                    try {\n-                        System.err.println(\"\\nCrash restartable object\");\n-                        for (int i = 0 ; i < HOW_MANY ; i ++) {\n-                            restartableObj[i].crash();\n-                        }\n-                    } catch (Exception e) {\n-                    }\n-                }\n-\n-            } while (repeatOnce-- > 0);\n-\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-            for (int i = 0 ; i < HOW_MANY ; i ++) {\n-                TestLibrary.unexport(unicastObjs[i]);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Check to see how many services have been automatically\n-     * restarted.\n-     *\/\n-    private static int howManyRestarted(boolean[] startedObjects, int retries) {\n-        int succeeded = 0;\n-        int restarted = 0;\n-        int atry = 0;\n-\n-        while ((restarted < HOW_MANY) && (atry < retries)) {\n-            restarted = 0;\n-            for (int j = 0 ; j < HOW_MANY ; j ++ ) {\n-                synchronized(lock) {\n-                    if (startedObjects[j]) {\n-                        restarted ++;\n-                    }\n-                }\n-            }\n-            System.err.println(\"not all objects restarted, retrying...\");\n-            try {\n-                Thread.sleep(10000);\n-            } catch (InterruptedException ie) {\n-            }\n-            atry ++;\n-        }\n-        return restarted;\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/ForceLogSnapshot.java","additions":0,"deletions":290,"binary":false,"changes":290,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Skeleton class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ForceLogSnapshot_Skel\n-    implements java.rmi.server.Skeleton\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void crash()\"),\n-        new java.rmi.server.Operation(\"void ping(int, java.lang.String)\")\n-    };\n-\n-    private static final long interfaceHash = -5865767584502007357L;\n-\n-    public java.rmi.server.Operation[] getOperations() {\n-        return (java.rmi.server.Operation[]) operations.clone();\n-    }\n-\n-    public void dispatch(java.rmi.Remote obj, java.rmi.server.RemoteCall call, int opnum, long hash)\n-        throws java.lang.Exception\n-    {\n-        if (opnum < 0) {\n-            if (hash == 8484760490859430950L) {\n-                opnum = 0;\n-            } else if (hash == -1519179153769139224L) {\n-                opnum = 1;\n-            } else {\n-                throw new java.rmi.UnmarshalException(\"invalid method hash\");\n-            }\n-        } else {\n-            if (hash != interfaceHash)\n-                throw new java.rmi.server.SkeletonMismatchException(\"interface hash mismatch\");\n-        }\n-\n-        ForceLogSnapshot server = (ForceLogSnapshot) obj;\n-        switch (opnum) {\n-        case 0: \/\/ crash()\n-        {\n-            call.releaseInputStream();\n-            server.crash();\n-            try {\n-                call.getResultStream(true);\n-            } catch (java.io.IOException e) {\n-                throw new java.rmi.MarshalException(\"error marshalling return\", e);\n-            }\n-            break;\n-        }\n-\n-        case 1: \/\/ ping(int, String)\n-        {\n-            int $param_int_1;\n-            java.lang.String $param_String_2;\n-            try {\n-                java.io.ObjectInput in = call.getInputStream();\n-                $param_int_1 = in.readInt();\n-                $param_String_2 = (java.lang.String) in.readObject();\n-            } catch (java.io.IOException e) {\n-                throw new java.rmi.UnmarshalException(\"error unmarshalling arguments\", e);\n-            } catch (java.lang.ClassNotFoundException e) {\n-                throw new java.rmi.UnmarshalException(\"error unmarshalling arguments\", e);\n-            } finally {\n-                call.releaseInputStream();\n-            }\n-            server.ping($param_int_1, $param_String_2);\n-            try {\n-                call.getResultStream(true);\n-            } catch (java.io.IOException e) {\n-                throw new java.rmi.MarshalException(\"error marshalling return\", e);\n-            }\n-            break;\n-        }\n-\n-        default:\n-            throw new java.rmi.UnmarshalException(\"invalid method number\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/ForceLogSnapshot_Skel.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,111 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ForceLogSnapshot_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void crash()\"),\n-        new java.rmi.server.Operation(\"void ping(int, java.lang.String)\")\n-    };\n-\n-    private static final long interfaceHash = -5865767584502007357L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_crash_0;\n-    private static java.lang.reflect.Method $method_ping_1;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_crash_0 = ActivateMe.class.getMethod(\"crash\", new java.lang.Class[] {});\n-            $method_ping_1 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {int.class, java.lang.String.class});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ForceLogSnapshot_Stub() {\n-        super();\n-    }\n-    public ForceLogSnapshot_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of crash()\n-    public void crash()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_crash_0, null, 8484760490859430950L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-\n-    \/\/ implementation of ping(int, String)\n-    public void ping(int $param_int_1, java.lang.String $param_String_2)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_1, new java.lang.Object[] {new java.lang.Integer($param_int_1), $param_String_2}, -1519179153769139224L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-                try {\n-                    java.io.ObjectOutput out = call.getOutputStream();\n-                    out.writeInt($param_int_1);\n-                    out.writeObject($param_String_2);\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.MarshalException(\"error marshalling arguments\", e);\n-                }\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/ForceLogSnapshot_Stub.java","additions":0,"deletions":111,"binary":false,"changes":111,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ allow exporting object with non-public remote interface\n-  permission java.rmi.RMIPermission \"exportRemoteInterface.ActivateMe\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/forceLogSnapshot\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public ActivateMe getUnicastVersion() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/inactiveGroup\/ActivateMe.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,187 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4116082\n- *\n- * @summary synopsis: rmid should not destroy group when it reports\n- * inactiveGroup\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary ActivateMe InactiveGroup_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 InactiveGroup\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Properties;\n-\n-public class InactiveGroup\n-        implements ActivateMe, Runnable\n-{\n-\n-    private ActivationID id;\n-\n-    public InactiveGroup(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-    }\n-\n-    public InactiveGroup() throws RemoteException {\n-        UnicastRemoteObject.exportObject(this, 0);\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    public ActivateMe getUnicastVersion() throws RemoteException {\n-        return new InactiveGroup();\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"InactiveGroup\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run()\n-    {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4116082\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Create descriptor and activate object in a separate VM.\n-             *\/\n-            System.err.println(\"Creating descriptor\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-            ActivationDesc desc =\n-                new ActivationDesc(groupID, \"InactiveGroup\", null, null);\n-\n-            System.err.println(\"Registering descriptor\");\n-            ActivateMe activatableObj = (ActivateMe) Activatable.register(desc);\n-\n-            System.err.println(\"Activate object via method call\");\n-            activatableObj.ping();\n-\n-            \/*\n-             * Create a unicast object in the activatable object's VM.\n-             *\/\n-            System.err.println(\"Obtain unicast object\");\n-            ActivateMe unicastObj = activatableObj.getUnicastVersion();\n-\n-            \/*\n-             * Make activatable object (and therefore group) inactive.\n-             *\/\n-            System.err.println(\"Make activatable object inactive\");\n-            activatableObj.shutdown();\n-\n-            \/*\n-             * Ping the unicast object a few times to make sure that the\n-             * activation group's process hasn't gone away.\n-             *\/\n-            System.err.println(\"Ping unicast object for existence\");\n-            \/\/ set timeout 5 seconds\n-            final long stopTime = System.currentTimeMillis() + 5000;\n-            while (System.currentTimeMillis() < stopTime) {\n-                unicastObj.ping();\n-                Thread.sleep(500);\n-            }\n-\n-            \/*\n-             * Now, reactivate the activatable object; the unicast object\n-             * should no longer be accessible, since reactivating the\n-             * activatable object should kill the previous group's VM\n-             * and the unicast object along with it.\n-             *\/\n-            System.err.println(\"Reactivate activatable obj\");\n-            activatableObj.ping();\n-\n-            try {\n-                System.err.println(\"Ping unicast object again\");\n-                unicastObj.ping();\n-            } catch (Exception thisShouldFail) {\n-                System.err.println(\"Test passed: couldn't reach unicast obj: \" +\n-                                   thisShouldFail.getMessage());\n-                return;\n-            }\n-\n-            TestLibrary.bomb(\"Test failed: unicast obj accessible after group reactivates\",\n-                 null);\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/inactiveGroup\/InactiveGroup.java","additions":0,"deletions":187,"binary":false,"changes":187,"status":"deleted"},{"patch":"@@ -1,140 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class InactiveGroup_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"ActivateMe getUnicastVersion()\"),\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = -23477180812089514L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_getUnicastVersion_0;\n-    private static java.lang.reflect.Method $method_ping_1;\n-    private static java.lang.reflect.Method $method_shutdown_2;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_getUnicastVersion_0 = ActivateMe.class.getMethod(\"getUnicastVersion\", new java.lang.Class[] {});\n-            $method_ping_1 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_2 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public InactiveGroup_Stub() {\n-        super();\n-    }\n-    public InactiveGroup_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of getUnicastVersion()\n-    public ActivateMe getUnicastVersion()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_getUnicastVersion_0, null, -4366214672304578894L);\n-                return ((ActivateMe) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ActivateMe $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (ActivateMe) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_1, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_2, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/inactiveGroup\/InactiveGroup_Stub.java","additions":0,"deletions":140,"binary":false,"changes":140,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/inactiveGroup\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/inactiveGroup\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ allow exporting object with non-public remote interface\n-  permission java.rmi.RMIPermission \"exportRemoteInterface.ActivateMe\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/inactiveGroup\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,129 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 6245733\n- * @summary synopsis: rmid's registry's list operation doesn't include\n- * activation system\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- * @run main\/othervm\/timeout=240 LookupActivationSystem\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.registry.*;\n-import java.rmi.server.*;\n-import java.io.Serializable;\n-\n-public class LookupActivationSystem implements Remote, Serializable {\n-\n-    private static final String NAME = ActivationSystem.class.getName();\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        System.out.println(\"\\nRegression test for bug 6245733\\n\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            System.err.println(\"look up activation system\");\n-            Registry rmidRegistry =\n-                LocateRegistry.getRegistry(rmid.getPort());\n-            ActivationSystem system = (ActivationSystem)\n-                rmidRegistry.lookup(NAME);\n-\n-            if (system instanceof ActivationSystem) {\n-                System.err.println(\"test1 passed: lookup succeeded\");\n-            }\n-\n-            System.err.println(\"get list of rmid internal registry\");\n-            String[] list = rmidRegistry.list();\n-            if (list.length == 1 && list[0].equals(NAME)) {\n-                System.err.println(\n-                    \"test2 passed: activation system found in list\");\n-            } else {\n-                throw new RuntimeException(\"test2 FAILED\");\n-            }\n-\n-            try {\n-                rmidRegistry.bind(NAME, new LookupActivationSystem());\n-                throw new RuntimeException(\"test3 FAILED: bind succeeded!\");\n-            } catch (ServerException e) {\n-                if (e.getCause() instanceof AccessException) {\n-                    System.err.println(\n-                        \"test3 passed: binding ActivationSystem \" +\n-                        \"failed as expected\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"test3 FAILED: incorrect cause: \" + e.getCause());\n-                }\n-\n-            }\n-\n-            try {\n-                rmidRegistry.rebind(NAME, new LookupActivationSystem());\n-                throw new RuntimeException(\"test4 FAILED: rebind succeeded!\");\n-            } catch (ServerException e) {\n-                if (e.getCause() instanceof AccessException) {\n-                    System.err.println(\n-                        \"test4 passed: rebinding ActivationSystem \" +\n-                        \"failed as expected\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"test4 FAILED: incorrect cause: \" + e.getCause());\n-                }\n-            }\n-\n-            try {\n-                rmidRegistry.unbind(NAME);\n-                throw new RuntimeException(\"test4 FAILED: unbind succeeded!\");\n-            } catch (ServerException e) {\n-                if (e.getCause() instanceof AccessException) {\n-                    System.err.println(\n-                        \"test5 passed: unbinding ActivationSystem \" +\n-                        \"failed as expected\");\n-                } else {\n-                    throw new RuntimeException(\n-                        \"test5 FAILED: incorrect cause: \" + e.getCause());\n-                }\n-            }\n-\n-\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/lookupActivationSystem\/LookupActivationSystem.java","additions":0,"deletions":129,"binary":false,"changes":129,"status":"deleted"},{"patch":"@@ -1,6 +0,0 @@\n-grant {\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/lookupActivationSystem\/rmid.security.policy","additions":0,"deletions":6,"binary":false,"changes":6,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void unregister() throws Exception;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nestedActivate\/ActivateMe.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,176 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4138056\n- * @summary synopsis: Activating objects from an Activatable constructor causes deadlock\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary ActivateMe NestedActivate_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 NestedActivate\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Properties;\n-\n-public class NestedActivate\n-        extends Activatable\n-        implements ActivateMe, Runnable\n-{\n-\n-    private static Exception exception = null;\n-    private static boolean done = false;\n-    private ActivateMe obj = null;\n-\n-    public NestedActivate(ActivationID id, MarshalledObject mobj)\n-        throws Exception\n-    {\n-        super(id, 0);\n-        System.err.println(\"NestedActivate<>: activating object\");\n-        if (mobj != null) {\n-            System.err.println(\"NestedActivate<>: ping obj to activate\");\n-            obj = (ActivateMe) mobj.get();\n-            obj.ping();\n-            System.err.println(\"NestedActivate<>: ping completed\");\n-        }\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    public void unregister() throws Exception {\n-        super.unregister(super.getID());\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"NestedActivate\")).start();\n-        if (obj != null)\n-            obj.shutdown();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.err.println(\"\\nRegression test for bug 4138056\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            final Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            Thread t = new Thread() {\n-                public void run () {\n-                    try {\n-                        System.err.println(\"Creating group descriptor\");\n-                        ActivationGroupDesc groupDesc =\n-                            new ActivationGroupDesc(p, null);\n-                        ActivationGroupID groupID =\n-                            ActivationGroup.getSystem().\n-                            registerGroup(groupDesc);\n-\n-                        System.err.println(\"Creating descriptor: object 1\");\n-                        ActivationDesc desc1 =\n-                            new ActivationDesc(groupID, \"NestedActivate\",\n-                                               null, null);\n-\n-                        System.err.println(\"Registering descriptor: object 1\");\n-                        ActivateMe obj1 =\n-                            (ActivateMe) Activatable.register(desc1);\n-\n-                        System.err.println(\"Creating descriptor: object 2\");\n-                        ActivationDesc desc2 =\n-                            new ActivationDesc(groupID, \"NestedActivate\", null,\n-                                               new MarshalledObject(obj1));\n-\n-                        System.err.println(\"Registering descriptor: object 2\");\n-                        ActivateMe obj2 =\n-                            (ActivateMe) Activatable.register(desc2);\n-\n-                        System.err.println(\"Activating object 2\");\n-                        obj2.ping();\n-\n-                        System.err.println(\"Deactivating objects\");\n-                        obj2.shutdown();\n-                    } catch (Exception e) {\n-                        exception = e;\n-                    }\n-                    done = true;\n-                }\n-            };\n-\n-            t.start();\n-            t.join(35000);\n-\n-            if (exception != null) {\n-                TestLibrary.bomb(\"test failed\", exception);\n-            } else if (!done) {\n-                TestLibrary.bomb(\"test failed: not completed before timeout\", null);\n-            } else {\n-                System.err.println(\"Test passed\");\n-            }\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nestedActivate\/NestedActivate.java","additions":0,"deletions":176,"binary":false,"changes":176,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class NestedActivate_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\"),\n-        new java.rmi.server.Operation(\"void unregister()\")\n-    };\n-\n-    private static final long interfaceHash = 4395146122524413703L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-    private static java.lang.reflect.Method $method_unregister_2;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-            $method_unregister_2 = ActivateMe.class.getMethod(\"unregister\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public NestedActivate_Stub() {\n-        super();\n-    }\n-    public NestedActivate_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-\n-    \/\/ implementation of unregister()\n-    public void unregister()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_unregister_2, null, -5366864281862648102L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nestedActivate\/NestedActivate_Stub.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nestedActivate\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nestedActivate\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ allow exporting of non-public remote interface\n-  permission java.rmi.RMIPermission \"exportRemoteInterface.ActivateMe\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nestedActivate\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void unregister() throws Exception;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nonExistentActivatable\/ActivateMe.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,150 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4115296\n- * @summary synopsis: NoSuchObjectException not thrown for non-existent\n- * activatable objects\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- *     ActivateMe NonExistentActivatable_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 NonExistentActivatable\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Properties;\n-\n-public class NonExistentActivatable\n-        extends Activatable\n-        implements ActivateMe, Runnable\n-{\n-\n-    public NonExistentActivatable(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        super(id, 0);\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    public void unregister() throws Exception {\n-        super.unregister(super.getID());\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"NonExistentActivatable\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run()\n-    {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4115331\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            System.err.println(\"Create activation group in this VM\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            ActivationGroup.createGroup(groupID, groupDesc, 0);\n-\n-            System.err.println(\"Creating descriptor\");\n-            ActivationDesc desc =\n-                new ActivationDesc(\"NonExistentActivatable\", null, null);\n-\n-            System.err.println(\"Registering descriptor\");\n-            ActivateMe obj = (ActivateMe) Activatable.register(desc);\n-\n-            System.err.println(\"Activate object via method call\");\n-            obj.ping();\n-\n-            System.err.println(\"Unregister object\");\n-            obj.unregister();\n-\n-            System.err.println(\"Make object inactive\");\n-            obj.shutdown();\n-\n-            System.err.println(\"Reactivate object\");\n-            try {\n-                obj.ping();\n-            } catch (NoSuchObjectException e) {\n-                System.err.println(\"Test succeeded: \" +\n-                                   \"NoSuchObjectException caught\");\n-                return;\n-            } catch (Exception e) {\n-                TestLibrary.bomb(\"Test failed: exception other than NoSuchObjectException\",\n-                     e);\n-            }\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nonExistentActivatable\/NonExistentActivatable.java","additions":0,"deletions":150,"binary":false,"changes":150,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class NonExistentActivatable_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\"),\n-        new java.rmi.server.Operation(\"void unregister()\")\n-    };\n-\n-    private static final long interfaceHash = 4395146122524413703L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-    private static java.lang.reflect.Method $method_unregister_2;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-            $method_unregister_2 = ActivateMe.class.getMethod(\"unregister\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public NonExistentActivatable_Stub() {\n-        super();\n-    }\n-    public NonExistentActivatable_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-\n-    \/\/ implementation of unregister()\n-    public void unregister()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_unregister_2, null, -5366864281862648102L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nonExistentActivatable\/NonExistentActivatable_Stub.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nonExistentActivatable\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nonExistentActivatable\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ allow exporting object with non-public remote interface\n-  permission java.rmi.RMIPermission \"exportRemoteInterface.ActivateMe\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/nonExistentActivatable\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4460983\n- * @summary This test verifies that an instance of Activatable cannot\n- * be serialized (without implicit impl-to-stub replacement), because\n- * it cannot be meaningfully deserialized anyway.\n- * See also test\/java\/rmi\/server\/RemoteObject\/unrecognizedRefType.\n- * @author Peter Jones\n- *\n- * @run main\/othervm NotSerializable\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.NotSerializableException;\n-import java.io.ObjectInput;\n-import java.io.ObjectOutputStream;\n-import java.io.ObjectOutput;\n-import java.lang.reflect.Method;\n-import java.rmi.MarshalledObject;\n-import java.rmi.NoSuchObjectException;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.server.Operation;\n-import java.rmi.server.RemoteCall;\n-import java.rmi.server.RemoteObject;\n-import java.rmi.server.RemoteRef;\n-import java.rmi.server.RemoteStub;\n-import java.rmi.activation.Activatable;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.activation.Activator;\n-\n-public class NotSerializable {\n-\n-    public static void main(String[] args) throws Exception {\n-        System.err.println(\"\\nRegression test for bug 4460983\\n\");\n-\n-        Activatable act = new FakeActivatable();\n-        try {\n-            ObjectOutputStream out =\n-                new ObjectOutputStream(new ByteArrayOutputStream());\n-            try {\n-                out.writeObject(act);\n-                throw new RuntimeException(\"TEST FAILED: \" +\n-                    \"Activatable instance successfully serialized\");\n-            } catch (NotSerializableException e) {\n-                System.err.println(\"NotSerializableException as expected:\");\n-                e.printStackTrace();\n-            } \/\/ other exceptions cause test failure\n-\n-            System.err.println(\"TEST PASSED\");\n-        } finally {\n-            try {\n-                Activatable.unexportObject(act, true);\n-            } catch (NoSuchObjectException e) {\n-            }\n-        }\n-    }\n-\n-    private static class FakeActivatable extends Activatable {\n-        FakeActivatable() throws RemoteException {\n-            super(new ActivationID(new FakeActivator()), 0);\n-        }\n-    }\n-\n-    private static class FakeActivator\n-        extends RemoteStub implements Activator\n-    {\n-        FakeActivator() {\n-            super(new FakeRemoteRef(\"FakeRef\"));\n-        }\n-\n-        public MarshalledObject activate(ActivationID id, boolean force) {\n-            return null;\n-        }\n-    }\n-\n-    private static class FakeRemoteRef implements RemoteRef {\n-        private final String refType;\n-\n-        FakeRemoteRef(String refType) {\n-            this.refType = refType;\n-        }\n-\n-        public Object invoke(Remote obj,\n-                             Method method,\n-                             Object[] params,\n-                             long opnum)\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public RemoteCall newCall(RemoteObject obj,\n-                                  Operation[] op,\n-                                  int opnum,\n-                                  long hash)\n-        {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void invoke(RemoteCall call) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void done(RemoteCall call) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public String getRefClass(java.io.ObjectOutput out) {\n-            return refType;\n-        }\n-\n-        public int remoteHashCode() { return hashCode(); }\n-        public boolean remoteEquals(RemoteRef obj) { return equals(obj); }\n-        public String remoteToString() { return toString(); }\n-\n-        public void readExternal(ObjectInput in) {\n-            throw new UnsupportedOperationException();\n-        }\n-\n-        public void writeExternal(ObjectOutput out) {\n-            \/\/ no data to write\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/notSerializable\/NotSerializable.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2000, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-\/\/ TEMPORARY HACK!!! to make interface public until MIS.resolveProxyClass is fixed.\n-public interface ActivateMe extends Remote {\n-    public void ping(String responder) throws RemoteException;\n-    public ActivateMe getUnicastVersion() throws RemoteException;\n-    public void crash() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartCrashedService\/ActivateMe.java","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,243 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4095165\n- * @bug 4140736\n- * @summary synopsis: rmid should waitFor restartable objects that crash and restart them\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivateMe RestartCrashedService_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 RestartCrashedService\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Vector;\n-import java.util.Properties;\n-\n-public class RestartCrashedService\n-        implements ActivateMe\n-{\n-\n-    private ActivationID id;\n-    private static Object lock = new Object();\n-    private Vector responders = new Vector();\n-\n-    private static final String RESTARTABLE = \"restartable\";\n-    private static final String ACTIVATABLE = \"activatable\";\n-\n-\n-    public RestartCrashedService(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-        ActivateMe obj;\n-        String responder;\n-        try {\n-            Object[] stuff = (Object[]) mobj.get();\n-            responder = (String) stuff[0];\n-            System.err.println(responder + \" service started\");\n-            obj = (ActivateMe) stuff[1];\n-        } catch (Exception e) {\n-            System.err.println(\"unable to obtain stub from marshalled object\");\n-            return;\n-        }\n-\n-        obj.ping(responder);\n-    }\n-\n-    public RestartCrashedService() throws RemoteException {\n-        UnicastRemoteObject.exportObject(this, 0);\n-    }\n-\n-    public void ping(String responder) {\n-        System.err.println(\"RestartCrashedService: received ping from \" + responder);\n-        synchronized (lock) {\n-            responders.add(responder);\n-            lock.notify();\n-        }\n-    }\n-\n-    public boolean receivedPing(String responder) {\n-        return responders.contains(responder);\n-    }\n-\n-    public void resetResponders() {\n-        responders.clear();\n-    }\n-\n-    public ActivateMe getUnicastVersion() throws RemoteException {\n-        return new RestartCrashedService();\n-    }\n-\n-    public void crash() {\n-        System.exit(0);\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4095165, 4140736\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-        RestartCrashedService unicastObj = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            final Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Create unicast object to be contacted when service is activated.\n-             *\/\n-            unicastObj = new RestartCrashedService();\n-            \/*\n-             * Create and register descriptors for a restartable and\n-             * non-restartable service (respectively) in a group other than\n-             * this VM's group.\n-             *\/\n-            System.err.println(\"Creating descriptors\");\n-\n-            Object[] stuff = new Object[] { RESTARTABLE, unicastObj };\n-            MarshalledObject restartMobj = new MarshalledObject(stuff);\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-\n-            stuff[0] = ACTIVATABLE;\n-            MarshalledObject activateMobj = new MarshalledObject(stuff);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-            ActivationDesc restartableDesc =\n-                new ActivationDesc(groupID, \"RestartCrashedService\", null,\n-                                   restartMobj, true);\n-\n-            ActivationDesc activatableDesc =\n-                new ActivationDesc(groupID, \"RestartCrashedService\", null,\n-                                   activateMobj, false);\n-\n-            System.err.println(\"Registering descriptors\");\n-            ActivateMe restartableObj =\n-                (ActivateMe) Activatable.register(restartableDesc);\n-\n-            ActivateMe activatableObj =\n-                (ActivateMe) Activatable.register(activatableDesc);\n-\n-            \/*\n-             * Restart rmid; it should start up the restartable service\n-             *\/\n-            rmid.restart();\n-\n-            \/*\n-             * Wait for service to be automatically restarted.\n-             *\/\n-            int repeat = 1;\n-\n-            do {\n-\n-                for (int i = 0; i < 15; i++) {\n-                    synchronized (lock) {\n-                        if (unicastObj.receivedPing(RESTARTABLE) != true) {\n-                            lock.wait(5000);\n-                            if (unicastObj.receivedPing(RESTARTABLE) == true) {\n-                                System.err.println(\"Test1 passed: rmid \" +\n-                                                   \"restarted service\");\n-                                break;\n-                            }\n-                        } else {\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                if (unicastObj.receivedPing(RESTARTABLE) != true)\n-                    TestLibrary.bomb(\"Test1 failed: service not restarted by timeout\",\n-                         null);\n-\n-                \/*\n-                 * Make sure activatable services wasn't automatically\n-                 * restarted.\n-                 *\/\n-                synchronized (lock) {\n-                    if (unicastObj.receivedPing(ACTIVATABLE) != true) {\n-                        lock.wait(5000);\n-                        if (unicastObj.receivedPing(ACTIVATABLE) != true) {\n-                            System.err.println(\"Test2 passed: rmid did not \" +\n-                                               \"restart activatable service\");\n-                        } else {\n-                            TestLibrary.bomb(\"Test2 failed: activatable service restarted\",\n-                                 null);\n-                        }\n-                    } else {\n-                        TestLibrary.bomb(\"Test2 failed: activatable service restarted!\",\n-                             null);\n-                    }\n-                }\n-\n-\n-                if (repeat > 0) {\n-                    try {\n-                        System.err.println(\"\\nCrash restartable object\");\n-                        unicastObj.resetResponders();\n-                        restartableObj.crash();\n-                    } catch (Exception e) {\n-                    }\n-                }\n-\n-            } while (repeat-- > 0);\n-\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-            TestLibrary.unexport(unicastObj);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartCrashedService\/RestartCrashedService.java","additions":0,"deletions":243,"binary":false,"changes":243,"status":"deleted"},{"patch":"@@ -1,146 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class RestartCrashedService_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void crash()\"),\n-        new java.rmi.server.Operation(\"ActivateMe getUnicastVersion()\"),\n-        new java.rmi.server.Operation(\"void ping(java.lang.String)\")\n-    };\n-\n-    private static final long interfaceHash = -5511576339806675599L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_crash_0;\n-    private static java.lang.reflect.Method $method_getUnicastVersion_1;\n-    private static java.lang.reflect.Method $method_ping_2;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_crash_0 = ActivateMe.class.getMethod(\"crash\", new java.lang.Class[] {});\n-            $method_getUnicastVersion_1 = ActivateMe.class.getMethod(\"getUnicastVersion\", new java.lang.Class[] {});\n-            $method_ping_2 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {java.lang.String.class});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public RestartCrashedService_Stub() {\n-        super();\n-    }\n-    public RestartCrashedService_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of crash()\n-    public void crash()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_crash_0, null, 8484760490859430950L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-\n-    \/\/ implementation of getUnicastVersion()\n-    public ActivateMe getUnicastVersion()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_getUnicastVersion_1, null, -4366214672304578894L);\n-                return ((ActivateMe) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-                ref.invoke(call);\n-                ActivateMe $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (ActivateMe) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of ping(String)\n-    public void ping(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_2, new java.lang.Object[] {$param_String_1}, 8618968970901024056L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-                try {\n-                    java.io.ObjectOutput out = call.getOutputStream();\n-                    out.writeObject($param_String_1);\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.MarshalException(\"error marshalling arguments\", e);\n-                }\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartCrashedService\/RestartCrashedService_Stub.java","additions":0,"deletions":146,"binary":false,"changes":146,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartCrashedService\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartCrashedService\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartCrashedService\/security.policy","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,268 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4526514\n- * @summary rmid does not handle group restart for latecomer objects\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- *     RestartLatecomer RestartLatecomer_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 RestartLatecomer\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Vector;\n-import java.util.Properties;\n-\n-public class RestartLatecomer\n-        implements ActivateMe, Runnable\n-{\n-\n-    private ActivationID id;\n-    private static Object lock = new Object();\n-    private Vector responders = new Vector();\n-\n-    private static final String RESTARTABLE = \"restartable\";\n-    private static final String ACTIVATABLE = \"activatable\";\n-\n-\n-    public RestartLatecomer(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-        ActivateMe obj;\n-        String responder;\n-        try {\n-            Object[] stuff = (Object[]) mobj.get();\n-            responder = (String) stuff[0];\n-            System.err.println(responder + \" service started\");\n-            obj = (ActivateMe) stuff[1];\n-        } catch (Exception e) {\n-            System.err.println(\"unable to obtain stub from marshalled object\");\n-            return;\n-        }\n-\n-        \/*\n-         * Call back object in the test VM to notify it that\n-         * this object has been activated or restarted.\n-         *\/\n-        obj.callback(responder);\n-    }\n-\n-    public RestartLatecomer() throws RemoteException {\n-        UnicastRemoteObject.exportObject(this, 0);\n-    }\n-\n-    private void waitFor(String responder) throws Exception {\n-        synchronized (lock) {\n-            for (int i = 0; i < 15; i++) {\n-                if (responders.contains(responder) != true) {\n-                    lock.wait(5000);\n-                    if (responders.contains(responder) == true) {\n-                        return;\n-                    }\n-                } else {\n-                    return;\n-                }\n-            }\n-        }\n-\n-        throw new RuntimeException(\n-            \"TEST FAILED: service not restarted by timeout\");\n-    }\n-\n-    private void clearResponders() {\n-        synchronized (lock) {\n-            responders.clear();\n-        }\n-    }\n-\n-\n-    \/**\n-     * Notifies the receiver that the object denoted by \"responder\"\n-     * has activated or restarted.\n-     *\/\n-    public void callback(String responder) {\n-        System.err.println(\n-            \"RestartLatecomer: received callback from \" + responder);\n-        \/*\n-         * Notify waiter that callback has been received and\n-         * test can proceed.\n-         *\/\n-        synchronized (lock) {\n-            responders.add(responder);\n-            lock.notifyAll();\n-        }\n-    }\n-\n-    \/**\n-     * Pings object (to activate it).\n-     *\/\n-    public void ping() {\n-        System.err.println(\"RestartLatecomer: recevied ping\");\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() {\n-        System.err.println(\"RestartLatecomer: received shutdown request\");\n-        (new Thread(this,\"RestartLatecomer\")).start();\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        System.exit(0);\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4526514\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-        RestartLatecomer callbackObj = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Create unicast object to be contacted when service is activated.\n-             *\/\n-            callbackObj = new RestartLatecomer();\n-            \/*\n-             * Create and register descriptors for a restartable and\n-             * non-restartable service (respectively) in a group other than\n-             * this VM's group.\n-             *\/\n-            System.err.println(\"Creating descriptors\");\n-\n-            Object[] stuff = new Object[] { RESTARTABLE, callbackObj };\n-            MarshalledObject restartMobj = new MarshalledObject(stuff);\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-\n-            stuff[0] = ACTIVATABLE;\n-            MarshalledObject activateMobj = new MarshalledObject(stuff);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-\n-            ActivationDesc activatableDesc =\n-                new ActivationDesc(groupID, \"RestartLatecomer\", null,\n-                                   activateMobj, false);\n-            ActivationDesc restartableDesc =\n-                new ActivationDesc(groupID, \"RestartLatecomer\", null,\n-                                   restartMobj, true);\n-\n-\n-            System.err.println(\"Register activatable object's descriptor\");\n-            ActivateMe activatableObj =\n-                (ActivateMe) Activatable.register(activatableDesc);\n-\n-            System.err.println(\"Activate object (starts group VM)\");\n-            activatableObj.ping();\n-\n-            callbackObj.waitFor(ACTIVATABLE);\n-            callbackObj.clearResponders();\n-            System.err.println(\"Callback from activatable object received\");\n-\n-            System.err.println(\"Register restartable object's descriptor\");\n-            ActivateMe restartableObj =\n-                (ActivateMe) Activatable.register(restartableDesc);\n-\n-            System.err.println(\"Shutdown object (exits group VM)\");\n-            try {\n-                activatableObj.shutdown();\n-            } catch (RemoteException ignore) {\n-                \/*\n-                 * Since the shutdown method spawns a thread to call\n-                 * System.exit, the group's VM may exit, closing all\n-                 * connections, before this call had returned.  If that\n-                 * happens, then a RemoteException will be caught\n-                 * here.\n-                 *\/\n-            }\n-\n-            System.err.println(\"Pause for shutdown to happen...\");\n-            Thread.sleep(5000);\n-\n-            \/*\n-             * Wait for \"latecomer\" restartable service to be\n-             * automatically restarted.\n-             *\/\n-            callbackObj.waitFor(RESTARTABLE);\n-            System.err.println(\n-                \"TEST PASSED: rmid restarted latecomer service\");\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(e);\n-        } finally {\n-            rmid.cleanup();\n-            TestLibrary.unexport(callbackObj);\n-        }\n-    }\n-\n-\n-}\n-\n-\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void callback(String responder) throws RemoteException;\n-    public void shutdown() throws RemoteException;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartLatecomer\/RestartLatecomer.java","additions":0,"deletions":268,"binary":false,"changes":268,"status":"deleted"},{"patch":"@@ -1,99 +0,0 @@\n-\/*\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class RestartLatecomer_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_callback_0;\n-    private static java.lang.reflect.Method $method_ping_1;\n-    private static java.lang.reflect.Method $method_shutdown_2;\n-\n-    static {\n-        try {\n-            $method_callback_0 = ActivateMe.class.getMethod(\"callback\", new java.lang.Class[] {java.lang.String.class});\n-            $method_ping_1 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_2 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public RestartLatecomer_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of callback(String)\n-    public void callback(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            ref.invoke(this, $method_callback_0, new java.lang.Object[] {$param_String_1}, -1016900954059279373L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            ref.invoke(this, $method_ping_1, null, 5866401369815527589L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            ref.invoke(this, $method_shutdown_2, null, -7207851917985848402L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartLatecomer\/RestartLatecomer_Stub.java","additions":0,"deletions":99,"binary":false,"changes":99,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartLatecomer\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartLatecomer\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Used in remote impl of Activator.inactive; by the method\n-  \/\/ \"restartThread.dispose()\"when it calls thread.interrupt()\n-  permission java.lang.RuntimePermission \"modifyThreadGroup\";\n-  permission java.lang.RuntimePermission \"modifyThread\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartLatecomer\/security.policy","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2000, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-public interface ActivateMe extends Remote {\n-    public void ping(String responder) throws RemoteException;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartService\/ActivateMe.java","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,234 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4095165 4321151\n- * @key intermittent\n- * @summary synopsis: activator should restart daemon services\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary ActivateMe RestartService_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 RestartService\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Vector;\n-import java.util.Properties;\n-\n-public class RestartService\n-        implements ActivateMe, Runnable\n-{\n-\n-    private ActivationID id;\n-    private static Object lock = new Object();\n-    private Vector responders = new Vector();\n-\n-    private static final String RESTARTABLE = \"restartable\";\n-    private static final String ACTIVATABLE = \"activatable\";\n-\n-\n-    public RestartService(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-        ActivateMe obj;\n-        String responder;\n-        try {\n-            Object[] stuff = (Object[]) mobj.get();\n-            responder = (String) stuff[0];\n-            System.err.println(responder + \" service started\");\n-            obj = (ActivateMe) stuff[1];\n-        } catch (Exception e) {\n-            System.err.println(\"unable to obtain stub from marshalled object\");\n-            return;\n-        }\n-\n-        obj.ping(responder);\n-    }\n-\n-    public RestartService() throws RemoteException {\n-        UnicastRemoteObject.exportObject(this, 0);\n-    }\n-\n-    public void ping(String responder) {\n-        System.err.println(\"RestartService: received ping from \" + responder);\n-        synchronized (lock) {\n-            responders.add(responder);\n-            lock.notify();\n-        }\n-    }\n-\n-    public boolean receivedPing(String responder) {\n-        return responders.contains(responder);\n-    }\n-\n-    public ActivateMe getUnicastVersion() throws RemoteException {\n-        return new RestartService();\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"RestartService\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4095165\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-        RestartService unicastObj = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",  \"\");\n-\n-            \/*\n-             * Create unicast object to be contacted when service is activated.\n-             *\/\n-            unicastObj = new RestartService();\n-            \/*\n-             * Create and register descriptors for a restartable and\n-             * non-restartable service (respectively) in a group other than\n-             * this VM's group.\n-             *\/\n-            System.err.println(\"Creating descriptors\");\n-\n-            Object[] stuff = new Object[] { RESTARTABLE, unicastObj };\n-            MarshalledObject restartMobj = new MarshalledObject(stuff);\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-\n-            stuff[0] = ACTIVATABLE;\n-            MarshalledObject activateMobj = new MarshalledObject(stuff);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-            ActivationDesc restartableDesc =\n-                new ActivationDesc(groupID, \"RestartService\", null,\n-                                   restartMobj, true);\n-\n-            ActivationDesc activatableDesc =\n-                new ActivationDesc(groupID, \"RestartService\", null,\n-                                   activateMobj, false);\n-\n-            System.err.println(\"Registering descriptors\");\n-            ActivateMe restartableObj =\n-                (ActivateMe) Activatable.register(restartableDesc);\n-\n-            ActivateMe activatableObj =\n-                (ActivateMe) Activatable.register(activatableDesc);\n-\n-            \/*\n-             * Restart rmid; it should start up the restartable service\n-             *\/\n-            rmid.restart();\n-\n-            \/*\n-             * Wait for service to be automatically restarted.\n-             *\/\n-            boolean gotPing = false;\n-            for (int i = 0; i < 15; i++) {\n-                synchronized (lock) {\n-                    if (unicastObj.receivedPing(RESTARTABLE) != true) {\n-                        lock.wait(5000);\n-                        if (unicastObj.receivedPing(RESTARTABLE) == true) {\n-                            System.err.println(\"Test1 passed: rmid restarted\" +\n-                                               \" service\");\n-                            gotPing = true;\n-                            break;\n-                        }\n-                    } else {\n-                        gotPing = true;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            if (gotPing == false)\n-                TestLibrary.bomb(\"Test1 failed: service not restarted by timeout\", null);\n-\n-            \/*\n-             * Make sure activatable services wasn't automatically restarted.\n-             *\/\n-            synchronized (lock) {\n-                if (unicastObj.receivedPing(ACTIVATABLE) != true) {\n-                    lock.wait(5000);\n-                    if (unicastObj.receivedPing(ACTIVATABLE) != true) {\n-                        System.err.println(\"Test2 passed: rmid did not \" +\n-                                           \"restart activatable service\");\n-                        return;\n-                    }\n-                }\n-\n-                TestLibrary.bomb(\"Test2 failed: activatable service restarted!\", null);\n-            }\n-\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-            TestLibrary.unexport(unicastObj);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartService\/RestartService.java","additions":0,"deletions":234,"binary":false,"changes":234,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2001, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class RestartService_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping(java.lang.String)\")\n-    };\n-\n-    private static final long interfaceHash = -3290104068898408724L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {java.lang.String.class});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public RestartService_Stub() {\n-        super();\n-    }\n-    public RestartService_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping(String)\n-    public void ping(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, new java.lang.Object[] {$param_String_1}, 8618968970901024056L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                try {\n-                    java.io.ObjectOutput out = call.getOutputStream();\n-                    out.writeObject($param_String_1);\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.MarshalException(\"error marshalling arguments\", e);\n-                }\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartService\/RestartService_Stub.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartService\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartService\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,39 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Used in remote impl of Activator.inactive; by the method\n-  \/\/ \"restartThread.dispose()\"when it calls thread.interrupt()\n-  permission java.lang.RuntimePermission \"modifyThreadGroup\";\n-  permission java.lang.RuntimePermission \"modifyThread\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/restartService\/security.policy","additions":0,"deletions":39,"binary":false,"changes":39,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-\n-public interface RegisteringActivatable extends Remote {\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/RegisteringActivatable.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,195 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4183169 8032050\n- * @summary Minor problem with the way ReliableLog handles IOExceptions.\n- *\n- * @author Laird Dornin; code borrowed from Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider\n- *     TestSecurityManager RegisteringActivatable ShutdownGracefully_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=700 ShutdownGracefully\n- *\/\n-\n-import java.rmi.activation.*;\n-import java.rmi.*;\n-import java.util.Properties;\n-import java.util.concurrent.TimeoutException;\n-\n-\/**\n- * The test creates an rmid with a special security manager.  After\n- * rmid makes two registrations (which is greater than rmid's\n- * snapshotInterval) the security manager stops allowing rmid to write\n- * to update and snapshot log files in rmid's log directory.  The Test\n- * registers an Activatable object twice with different group ids.\n- * The second registration will cause rmid to have to write to a\n- * LogFile (it causes a snapshot) and the security manager will not\n- * allow the file write to happen.  The test makes sure that rmid\n- * shuts down in a graceful manner without any explicit request to do\n- * so.  The test will not exit for 400 seconds if rmid does not exit\n- * (after that time, the test will fail).\n- *\/\n-public class ShutdownGracefully\n-    extends Activatable implements RegisteringActivatable\n-{\n-    private static RegisteringActivatable registering = null;\n-\n-    private final static long SHUTDOWN_TIMEOUT = 400 * 1000;\n-\n-    public static void main(String args[]) {\n-\n-        RMID rmid = null;\n-\n-        \/\/ Save exception if there is a exception or expected behavior\n-        Exception exception = null;\n-        System.err.println(\"\\nRegression test for bug\/rfe 4183169\\n\");\n-\n-        try {\n-            TestLibrary.suggestSecurityManager(\n-                \"java.rmi.RMISecurityManager\");\n-\n-            \/\/ start an rmid.\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-\n-            \/\/ rmid needs to run with a security manager that\n-            \/\/ simulates a log problem; rmid should also snapshot\n-            \/\/ quickly.\n-            rmid.addOptions(new String[] {\n-                \"-Djava.security.manager=TestSecurityManager\",\n-                \"-Dsun.rmi.activation.snapshotInterval=1\"});\n-\n-            \/\/      rmid.addArguments(new String[] {\n-            \/\/          \"-C-Djava.rmi.server.logCalls=true\"});\n-\n-            rmid.start();\n-\n-            \/\/ Ensure that activation groups run with the correct\n-            \/\/ security manager.\n-            \/\/\n-            Properties p = new Properties();\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  \"java.lang.SecurityManager\");\n-\n-            System.err.println(\"activation group will be created \" +\n-                               \"in a new VM\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-\n-            System.err.println(\"registering activatable\");\n-            ActivationDesc desc = new ActivationDesc\n-                (groupID, \"ShutdownGracefully\", null, null);\n-            registering = (RegisteringActivatable)\n-                Activatable.register(desc);\n-\n-            System.err.println(\"activate and deactivate object \" +\n-                               \"via method call\");\n-            registering.shutdown();\n-\n-            \/*\n-             * the security manager rmid is running with will stop\n-             * rmid from writing to its log files; in 1.2.x this would\n-             * have caused rmid to have thrown a runtime exception and\n-             * continue running in an unstable state.  With the fix\n-             * for 4183169, rmid should shutdown gracefully instead.\n-             *\/\n-\n-            \/*\n-             * register another activatable with a new group id; rmid\n-             * should not recover from this...  I use two\n-             * registrations to more closely simulate the environment\n-             * in which the bug was found.  In java versions with out\n-             * the appropriate bug fix, rmid would hide a\n-             * NullPointerException in this circumstance.\n-             *\/\n-            p.put(\"dummyname\", \"dummyvalue\");\n-            groupDesc = new ActivationGroupDesc(p, null);\n-            ActivationGroupID secondGroupID =\n-                system.registerGroup(groupDesc);\n-            desc = new ActivationDesc(secondGroupID,\n-                \"ShutdownGracefully\", null, null);\n-\n-            \/*\n-             * registration request is expected to be failed. succeeded case\n-             * should be recorded. And raise error after clean up  rmid.\n-             *\/\n-            try {\n-                registering = (RegisteringActivatable)\n-                    Activatable.register(desc);\n-                System.err.println(\"The registration request succeeded unexpectedly\");\n-                exception = new RuntimeException(\"The registration request succeeded unexpectedly\");\n-            } catch (ActivationException e) {\n-                System.err.println(\"received exception from registration \" +\n-                                   \"call that should have failed...\");\n-                \/\/ Need wait rmid process terminates.\n-                try {\n-                    int exitCode = rmid.waitFor(SHUTDOWN_TIMEOUT);\n-                    System.err.println(\"RMID has exited gracefully with exitcode:\" + exitCode);\n-                    rmid = null;\n-                } catch (TimeoutException te) {\n-                    System.err.println(\"RMID process has not exited in given time\");\n-                    exception = te;\n-                }\n-            }\n-        } catch (Exception e) {\n-            System.err.println(\"Exception thrown:\" + e);\n-            exception = e;\n-        } finally {\n-            if (rmid != null)\n-                rmid.cleanup();\n-        }\n-        if (exception != null)\n-            TestLibrary.bomb(\"\\nexception thrown in test: \", exception);\n-    }\n-\n-    \/**\n-     * implementation of RegisteringActivatable\n-     *\/\n-    public ShutdownGracefully\n-        (ActivationID id, MarshalledObject mo) throws RemoteException\n-    {\n-        \/\/ register\/export anonymously\n-        super(id, 0);\n-    }\n-\n-    \/**\n-     * Deactivates the object. We need to unexport forcibly because this call\n-     * in-progress on this object, which is the same object that we are trying\n-     * to deactivate.\n-     *\/\n-    public void shutdown() throws Exception {\n-        Activatable.unexportObject(this, true);\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/ShutdownGracefully.java","additions":0,"deletions":195,"binary":false,"changes":195,"status":"deleted"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ShutdownGracefully_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements RegisteringActivatable, java.rmi.Remote\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_shutdown_0;\n-\n-    static {\n-        try {\n-            $method_shutdown_0 = RegisteringActivatable.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ShutdownGracefully_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        ref.invoke(this, $method_shutdown_0, null, -7207851917985848402L);\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/ShutdownGracefully_Stub.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\n- * Security manager which prevents RMID from writing to its logfile\n- * after it has written out a snapshot.\n- *\/\n-\n-import java.io.File;\n-\n-public class TestSecurityManager extends SecurityManager {\n-    public TestSecurityManager() {\n-    }\n-    public void checkWrite(String file) {\n-        if (file.endsWith(\"log\" + File.separatorChar + \"Snapshot.6\")) {\n-            System.out.println(\"writing file: \" + file + \" simulating log failure\");\n-            throw new SecurityException(\"simulating log failure\");\n-        }\n-    }\n-\n-    public void checkRead(String file) {\n-        if (file.endsWith(\"log\" + File.separatorChar + \"Logfile.6\"))\n-        {\n-            System.out.println(\"reading file: \" + file + \" simulating log failure\");\n-            throw new SecurityException(\"simulating log failure\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/TestSecurityManager.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=java.lang.SecurityManager\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Ddummyname=dummyvalue\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/shutdownGracefully\/security.policy","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2000, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-\n-\/\/ TEMPORARY HACK!!! needed to make interface public until MIS is fixed.\n-public interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void unregister() throws Exception;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/unregisterInactive\/ActivateMe.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,136 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4115331\n- * @summary synopsis: activatable object fails to go inactive after\n- * unregister\/inactive sequence.\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary ActivateMe UnregisterInactive_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 UnregisterInactive\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.Properties;\n-\n-public class UnregisterInactive\n-        extends Activatable\n-        implements ActivateMe, Runnable\n-{\n-\n-    public UnregisterInactive(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        super(id, 0);\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    public void unregister() throws Exception {\n-        super.unregister(super.getID());\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"UnregisterInactive\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4115331\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-            System.err.println(\"Creating descriptor\");\n-\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            ActivationGroup.createGroup(groupID, groupDesc, 0);\n-\n-            ActivationDesc desc =\n-                new ActivationDesc(\"UnregisterInactive\", null, null);\n-\n-            System.err.println(\"Registering descriptor\");\n-            ActivateMe obj = (ActivateMe) Activatable.register(desc);\n-\n-            System.err.println(\"Activate object via method call\");\n-            obj.ping();\n-\n-            System.err.println(\"Unregister object\");\n-            obj.unregister();\n-\n-            System.err.println(\"Make object inactive\");\n-            obj.shutdown();\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/unregisterInactive\/UnregisterInactive.java","additions":0,"deletions":136,"binary":false,"changes":136,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 1999, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class UnregisterInactive_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\"),\n-        new java.rmi.server.Operation(\"void unregister()\")\n-    };\n-\n-    private static final long interfaceHash = 4395146122524413703L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-    private static java.lang.reflect.Method $method_unregister_2;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-            $method_unregister_2 = ActivateMe.class.getMethod(\"unregister\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public UnregisterInactive_Stub() {\n-        super();\n-    }\n-    public UnregisterInactive_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-\n-    \/\/ implementation of unregister()\n-    public void unregister()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_unregister_2, null, -5366864281862648102L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/unregisterInactive\/UnregisterInactive_Stub.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/unregisterInactive\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/unregisterInactive\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test rmid uses these properties to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ Needed to create an activation group\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ allow exporting of remote objects on an arbitrary port.\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/Activatable\/unregisterInactive\/security.policy","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,174 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4097135\n- * @summary Need a specific subtype of RemoteException for activation failure.\n- *          If activation fails to happen during a call to a remote object,\n- *          then the call should end in an ActivateFailedException. In this\n- *          test, the actual \"activatable\" remote object fails to activate\n- *          since its * \"activation\" constructor throws an exception.\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID RMIDSelectorProvider ActivationLibrary\n- *     ActivateMe ActivateFails_Stub ShutdownThread\n- * @run main\/othervm\/java.security.policy=security.policy\/timeout=240 ActivateFails\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.rmi.activation.*;\n-import java.io.*;\n-import java.util.Properties;\n-\n-public class ActivateFails\n-        extends Activatable\n-        implements ActivateMe\n-{\n-\n-    public ActivateFails(ActivationID id, MarshalledObject obj)\n-        throws ActivationException, RemoteException\n-    {\n-        super(id, 0);\n-\n-        boolean refuseToActivate = false;\n-        try {\n-            refuseToActivate = ((Boolean)obj.get()).booleanValue();\n-        } catch (Exception impossible) {\n-        }\n-\n-        if (refuseToActivate)\n-            throw new RemoteException(\"object refuses to activate\");\n-    }\n-\n-    public void ping()\n-    {}\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public ShutdownThread shutdown() throws Exception\n-    {\n-        ShutdownThread shutdownThread = new ShutdownThread(this, getID());\n-        shutdownThread.start();\n-        return(shutdownThread);\n-    }\n-\n-    public static void main(String[] args)\n-    {\n-        RMID rmid = null;\n-        ActivateMe obj1, obj2;\n-        ShutdownThread shutdownThread;\n-\n-        System.err.println(\"\\nRegression test for bug 4097135\\n\");\n-        try {\n-            TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-            \/*\n-             * First run \"rmid\" and wait for it to start up.\n-             *\/\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-\n-            \/*\n-             * Create activation descriptor...\n-             *\/\n-            System.err.println(\"creating activation descriptor...\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, null);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-\n-            ActivationDesc desc1 =\n-                new ActivationDesc(groupID, \"ActivateFails\",\n-                                   null,\n-                                   new MarshalledObject(new Boolean(true)));\n-\n-            ActivationDesc desc2 =\n-                new ActivationDesc(groupID, \"ActivateFails\",\n-                                   null,\n-                                   new MarshalledObject(new Boolean(false)));\n-            \/*\n-             * Register activation descriptor and make a call on\n-             * the stub. Activation should fail with an\n-             * ActivateFailedException.  If not, report an\n-             * error as a RuntimeException\n-             *\/\n-\n-            System.err.println(\"registering activation descriptor...\");\n-            obj1 = (ActivateMe)Activatable.register(desc1);\n-            obj2 = (ActivateMe)Activatable.register(desc2);\n-\n-            System.err.println(\"invoking method on activatable object...\");\n-            try {\n-                obj1.ping();\n-                throw new RuntimeException(\"ActivateFailedException is expected\");\n-            } catch (ActivateFailedException e) {\n-\n-                \/*\n-                 * This is what is expected so exit with status 0\n-                 *\/\n-                System.err.println(\"\\nsuccess: ActivateFailedException \" +\n-                                   \"generated\");\n-                e.getMessage();\n-            }\n-\n-            obj2.ping();\n-            shutdownThread = obj2.shutdown();\n-\n-            \/\/ wait for shutdown to work\n-            Thread.sleep(2000);\n-\n-            shutdownThread = null;\n-\n-        } catch (Exception e) {\n-            \/*\n-             * Test failed; unexpected exception generated.\n-             *\/\n-            TestLibrary.bomb(\"\\nfailure: unexpected exception \" +\n-                               e.getClass().getName() + \": \" + e.getMessage(), e);\n-\n-        } finally {\n-            obj1 = obj2 = null;\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/ActivateFails.java","additions":0,"deletions":174,"binary":false,"changes":174,"status":"deleted"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ActivateFails_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"void ping()\"),\n-        new java.rmi.server.Operation(\"ShutdownThread shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = -6632667923281093978L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_ping_0 = ActivateMe.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ActivateFails_Stub() {\n-        super();\n-    }\n-    public ActivateFails_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                ref.done(call);\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public ShutdownThread shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            Object $result = ref.invoke(this, $method_shutdown_1, null, -3616843253114182719L);\n-            return ((ShutdownThread) $result);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-            ref.invoke(call);\n-            ShutdownThread $result;\n-            try {\n-                java.io.ObjectInput in = call.getInputStream();\n-                $result = (ShutdownThread) in.readObject();\n-            } catch (java.io.IOException e) {\n-                throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-            } catch (java.lang.ClassNotFoundException e) {\n-                throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-            } finally {\n-                ref.done(call);\n-            }\n-            return $result;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/ActivateFails_Stub.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public ShutdownThread shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,50 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.io.*;\n-\n-public class ShutdownThread extends Thread implements Serializable {\n-\n-    Remote remoteObject = null;\n-    ActivationID activationID = null;\n-\n-    public ShutdownThread(Remote remoteObject, ActivationID activationID) {\n-        remoteObject = remoteObject;\n-        activationID = activationID;\n-    }\n-\n-    public void run() {\n-\n-        try {\n-\n-            Activatable.unexportObject(remoteObject, true);\n-            Activatable.inactive(activationID);\n-\n-        } catch (Exception e) {\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/ShutdownThread.java","additions":0,"deletions":50,"binary":false,"changes":50,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,8 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/rmid.security.policy","additions":0,"deletions":8,"binary":false,"changes":8,"status":"deleted"},{"patch":"@@ -1,34 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  permission java.lang.RuntimePermission \"selectorProvider\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivateFailedException\/activateFails\/security.policy","additions":0,"deletions":34,"binary":false,"changes":34,"status":"deleted"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4510355\n- * @summary ActivationGroup implementations cannot be downloaded by default;\n- * Creates a custom activation group without setting a security manager\n- * in activation group's descriptor.  The custom activation group\n- * implementation should be downloaded when first object within that group\n- * is activated.\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID ActivationLibrary RMIDSelectorProvider\n- *     DownloadActivationGroup MyActivationGroupImpl DownloadActivationGroup_Stub\n- * @run main\/othervm\/policy=security.policy\/timeout=240 DownloadActivationGroup\n- *\/\n-\n-import java.net.URL;\n-import java.rmi.MarshalledObject;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.Activatable;\n-import java.rmi.activation.ActivationDesc;\n-import java.rmi.activation.ActivationException;\n-import java.rmi.activation.ActivationGroup;\n-import java.rmi.activation.ActivationGroupDesc;\n-import java.rmi.activation.ActivationGroupDesc.CommandEnvironment;\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.server.UnicastRemoteObject;\n-import java.util.Properties;\n-\n-public class DownloadActivationGroup\n-        implements Ping, Runnable\n-{\n-\n-    private ActivationID id;\n-\n-    public DownloadActivationGroup(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-        System.err.println(\"object activated in group\");\n-    }\n-\n-    public DownloadActivationGroup() throws RemoteException {\n-        UnicastRemoteObject.exportObject(this, 0);\n-    }\n-\n-    \/**\n-     * Used to activate object.\n-     *\/\n-    public void ping() {\n-        System.err.println(\"received ping\");\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object (and thus, shuts down the\n-     * activation group).\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"DownloadActivationGroup\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-\n-    public static void main(String[] args) {\n-\n-        RMID rmid = null;\n-\n-        System.out.println(\"\\nRegression test for bug 4510355\\n\");\n-\n-        try {\n-            TestLibrary.suggestSecurityManager(\"java.lang.SecurityManager\");\n-\n-            \/*\n-             * Install group class file in codebase.\n-             *\/\n-            System.err.println(\"install class file in codebase\");\n-            URL groupURL = TestLibrary.installClassInCodebase(\n-                                  \"MyActivationGroupImpl\", \"group\");\n-            System.err.println(\"class file installed\");\n-\n-            \/*\n-             * Start rmid.\n-             *\/\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            String execPolicyOption = \"-Dsun.rmi.activation.execPolicy=none\";\n-            rmid.addOptions(new String[] { execPolicyOption });\n-            rmid.addArguments(new String[] { \"-C-Djava.security.manager=allow\" });\n-            rmid.start();\n-\n-            \/*\n-             * Create and register descriptors for custom group and an\n-             * activatable object in that group.\n-             *\/\n-            System.err.println(\"register group\");\n-\n-            Properties p = new Properties();\n-            p.put(\"java.security.policy\", TestParams.defaultGroupPolicy);\n-            CommandEnvironment cmd = new ActivationGroupDesc.CommandEnvironment(\n-                    null,\n-                    new String[] {\n-                        \"--add-exports=java.rmi\/sun.rmi.registry=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.server=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.transport=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.transport.tcp=ALL-UNNAMED\" });\n-\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(\"MyActivationGroupImpl\",\n-                                        groupURL.toExternalForm(),\n-                                        null, p, cmd);\n-            ActivationGroupID groupID =\n-                ActivationGroup.getSystem().registerGroup(groupDesc);\n-\n-\n-            System.err.println(\"register activatable object\");\n-            ActivationDesc desc =\n-                new ActivationDesc(groupID, \"DownloadActivationGroup\",\n-                                   null, null);\n-            Ping obj = (Ping) Activatable.register(desc);\n-\n-            \/*\n-             * Start group (by calling ping).\n-             *\/\n-            System.err.println(\n-                \"ping object (forces download of group's class)\");\n-            obj.ping();\n-            System.err.println(\n-                \"TEST PASSED: group's class downloaded successfully\");\n-            System.err.println(\"shutdown object\");\n-            obj.shutdown();\n-            System.err.println(\"TEST PASSED\");\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n-\n-interface Ping extends Remote {\n-    public void ping() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/DownloadActivationGroup.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -1,74 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class DownloadActivationGroup_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements Ping\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_ping_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            $method_ping_0 = Ping.class.getMethod(\"ping\", new java.lang.Class[] {});\n-            $method_shutdown_1 = Ping.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public DownloadActivationGroup_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of ping()\n-    public void ping()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            ref.invoke(this, $method_ping_0, null, 5866401369815527589L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/DownloadActivationGroup_Stub.java","additions":0,"deletions":74,"binary":false,"changes":74,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.rmi.*;\n-import sun.rmi.server.*;\n-import java.rmi.activation.*;\n-\n-\n-public class MyActivationGroupImpl extends ActivationGroupImpl {\n-\n-    public MyActivationGroupImpl(ActivationGroupID id, MarshalledObject mobj)\n-        throws RemoteException, ActivationException\n-    {\n-        super(id, mobj);\n-        System.err.println(\"custom group implementation created\");\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/MyActivationGroupImpl.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,11 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.server\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/group.security.policy","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-grant {\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/rmid.security.policy","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  permission java.security.AllPermission;\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroup\/downloadActivationGroup\/security.policy","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,65 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4252236\n- * @summary ActivationGroupDesc should not do early binding of default classname\n- *          This test doesn't need to run with othervm option as all it does is\n- *          create an ActivationGroupDesc instance, which has no side effects\n- * @author Laird Dornin\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- * @build TestLibrary\n- * @run main CheckDefaultGroupName\n- *\/\n-\n-import java.rmi.activation.*;\n-\n-\/**\n- * Test checks the group name for an ActivationGroupDesc which is\n- * created with no explicit activation group implementation class name\n- * supplied.\n- *\/\n-public class CheckDefaultGroupName {\n-    public static void main(String[] args) {\n-        System.out.println(\"\\n\\nRegression test for, 4252236\\n\\n\");\n-\n-        ActivationGroupDesc groupDesc =\n-            new ActivationGroupDesc(null, null);\n-\n-        String className = groupDesc.getClassName();\n-        if (className != null) {\n-            TestLibrary.bomb(\"ActivationGroupDesc had incorrect default\" +\n-                             \" group implementation class name: \" + className);\n-        } else {\n-            System.err.println(\"test passed, had correct default group\" +\n-                               \" implementation class name: \" + className +\n-                               \"\\n\\n\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationGroupDesc\/checkDefaultGroupName\/CheckDefaultGroupName.java","additions":0,"deletions":65,"binary":false,"changes":65,"status":"deleted"},{"patch":"@@ -1,132 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4720528\n- * @summary synopsis: (spec) ActivationSystem.activeGroup spec should be\n- * relaxed (duplicate call to activeGroup with same instantiator and\n- * incarnation should not throw ActivationException; it should succeed)\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID ActivationLibrary RMIDSelectorProvider\n- * @run main\/othervm\/policy=security.policy\/timeout=480 IdempotentActiveGroup\n- *\/\n-\n-import java.rmi.MarshalledObject;\n-import java.rmi.NoSuchObjectException;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.ActivationDesc;\n-import java.rmi.activation.ActivationException;\n-import java.rmi.activation.ActivationGroup;\n-import java.rmi.activation.ActivationGroupDesc;\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.activation.ActivationInstantiator;\n-import java.rmi.activation.ActivationSystem;\n-import java.rmi.server.UnicastRemoteObject;\n-\n-public class IdempotentActiveGroup {\n-\n-    public static void main(String[] args) {\n-\n-        System.err.println(\"\\nRegression test for bug 4720528\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.lang.SecurityManager\");\n-        RMID rmid = null;\n-        ActivationInstantiator inst1 = null;\n-        ActivationInstantiator inst2 = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            System.err.println(\"Create group descriptor\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(null, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            System.err.println(\"Register group descriptor\");\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            inst1 = new FakeInstantiator();\n-            inst2 = new FakeInstantiator();\n-\n-            System.err.println(\"Invoke activeGroup with inst1\");\n-            system.activeGroup(groupID, inst1, 0);\n-\n-            try {\n-            System.err.println(\"Invoke activeGroup with inst2\");\n-                system.activeGroup(groupID, inst2, 0);\n-                throw new RuntimeException(\n-                    \"TEST FAILED: activeGroup with unequal groups succeeded!\");\n-            } catch (ActivationException expected) {\n-                System.err.println(\"Caught expected ActivationException\");\n-                System.err.println(\"Test 1 (of 2) passed\");\n-            }\n-\n-            try {\n-                System.err.println(\"Invoke activeGroup with inst1\");\n-                system.activeGroup(groupID, inst1, 0);\n-                System.err.println(\"activeGroup call succeeded\");\n-                System.err.println(\"Test 2 (of 2) passed\");\n-            } catch (ActivationException unexpected) {\n-                throw new RuntimeException(\n-                    \"TEST FAILED: activeGroup with equal groups failed!\",\n-                    unexpected);\n-            }\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            try {\n-                if (inst1 != null) {\n-                    UnicastRemoteObject.unexportObject(inst1, true);\n-                }\n-                if (inst2 != null) {\n-                    UnicastRemoteObject.unexportObject(inst2, true);\n-                }\n-            } catch (NoSuchObjectException unexpected) {\n-                throw new AssertionError(unexpected);\n-            }\n-            rmid.cleanup();\n-        }\n-    }\n-\n-    private static class FakeInstantiator\n-        extends UnicastRemoteObject\n-        implements ActivationInstantiator\n-    {\n-        FakeInstantiator() throws RemoteException {}\n-\n-        public MarshalledObject newInstance(ActivationID id,\n-                                            ActivationDesc desc)\n-        {\n-            throw new AssertionError();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/activeGroup\/IdempotentActiveGroup.java","additions":0,"deletions":132,"binary":false,"changes":132,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-grant {\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/activeGroup\/rmid.security.policy","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,24 +0,0 @@\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/activeGroup\/security.policy","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.activation.ActivationID;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public String getMessage() throws RemoteException;\n-    public String getProperty(String name) throws RemoteException;\n-    public ActivationID getID() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/modifyDescriptor\/ActivateMe.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,261 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4127754\n- *\n- * @summary synopsis: need to modify registered ActivationDesc and\n- * ActivationGroupDesc\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID ActivationLibrary\n- *     ActivateMe ModifyDescriptor_Stub RMIDSelectorProvider\n- * @run main\/othervm\/policy=security.policy\/timeout=240 ModifyDescriptor\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.rmi.registry.*;\n-import java.util.*;\n-\n-public class ModifyDescriptor\n-        implements ActivateMe, Runnable\n-{\n-\n-    private ActivationID id;\n-    private String message;\n-\n-    private static final String MESSAGE1 = \"hello\";\n-    private static final String MESSAGE2 = \"hello, again\";\n-\n-\n-    public ModifyDescriptor(ActivationID id, MarshalledObject mobj)\n-        throws ActivationException, RemoteException\n-    {\n-        this.id = id;\n-        Activatable.exportObject(this, id, 0);\n-\n-        try {\n-            message = (String) mobj.get();\n-        } catch (Exception e) {\n-            System.err.println(\"unable to get message from marshalled object\");\n-        }\n-    }\n-\n-    public String getMessage() {\n-        return message;\n-    }\n-\n-    public String getProperty(String name) {\n-        return TestLibrary.getProperty(name, null);\n-    }\n-\n-    public ActivationID getID() {\n-        return id;\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"ModifyDescriptor\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4127754\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/*\n-             * Create and register a group and activatable object\n-             *\/\n-\n-            System.err.println(\"Creating group descriptor\");\n-            Properties props = new Properties();\n-            props.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            props.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-            props.put(\"test.message\", MESSAGE1);\n-            ActivationGroupDesc initialGroupDesc =\n-                new ActivationGroupDesc(props, null);\n-            System.err.println(\"Registering group\");\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(initialGroupDesc);\n-\n-            System.err.println(\"Creating descriptor\");\n-            ActivationDesc initialDesc =\n-                new ActivationDesc(groupID, \"ModifyDescriptor\", null,\n-                                   new MarshalledObject(MESSAGE1), false);\n-\n-            System.err.println(\"Registering descriptor\");\n-            ActivateMe obj = (ActivateMe) Activatable.register(initialDesc);\n-\n-            \/*\n-             * Ping object and verify that MarshalledObject is okay.\n-             *\/\n-            System.err.println(\"Ping object\");\n-            String message1 = obj.getMessage();\n-            System.err.println(\"message = \" + message1);\n-\n-            if (message1.equals(MESSAGE1)) {\n-                System.err.println(\"Test1a passed: initial MarshalledObject \" +\n-                                   \"correct\");\n-            } else {\n-                TestLibrary.bomb(\"Test1 failed: unexpected MarshalledObject passed to \" +\n-                     \"constructor\", null);\n-            }\n-\n-            \/*\n-             * Get property from remote group and make sure it's okay\n-             *\/\n-            message1 = obj.getProperty(\"test.message\");\n-            if (message1.equals(MESSAGE1)) {\n-                System.err.println(\"Test1b passed: initial group property \" +\n-                                   \"correct\");\n-            } else {\n-                TestLibrary.bomb(\"Test1 failed: unexpected property passed to \" +\n-                     \"group\", null);\n-            }\n-\n-            \/*\n-             * Update activation descriptor for object and group\n-             *\/\n-            System.err.println(\"Update activation descriptor\");\n-            ActivationDesc newDesc =\n-                new ActivationDesc(groupID, \"ModifyDescriptor\", null,\n-                               new MarshalledObject(MESSAGE2), false);\n-            ActivationID id = obj.getID();\n-            ActivationDesc oldDesc = system.setActivationDesc(id, newDesc);\n-\n-            if (oldDesc.equals(initialDesc)) {\n-                System.err.println(\"Test2a passed: desc returned from \" +\n-                                   \"setActivationDesc is okay\");\n-            } else {\n-                TestLibrary.bomb(\"Test2a failed: desc returned from setActivationDesc \" +\n-                     \"is not the initial descriptor!\", null);\n-            }\n-\n-\n-            Properties props2 = new Properties();\n-            props2.put(\"test.message\", MESSAGE2);\n-            props2.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            props2.put(\"java.security.manager\",\n-                  TestParams.defaultSecurityManager);\n-            ActivationGroupDesc newGroupDesc =\n-                new ActivationGroupDesc(props2, null);\n-\n-            ActivationGroupDesc oldGroupDesc =\n-                system.setActivationGroupDesc(groupID, newGroupDesc);\n-\n-            if (oldGroupDesc.equals(initialGroupDesc)) {\n-                System.err.println(\"Test2b passed: group desc returned from \" +\n-                                   \"setActivationGroupDesc is okay\");\n-            } else {\n-                TestLibrary.bomb(\"Test2b failed: group desc returned from \" +\n-                     \"setActivationGroupDesc is not the initial descriptor!\",\n-                     null);\n-            }\n-\n-            \/*\n-             * Restart rmid; and ping object to make sure that it has\n-             * new message.\n-             *\/\n-            rmid.restart();\n-\n-            System.err.println(\"Ping object after restart\");\n-            String message2 = obj.getMessage();\n-\n-            if (message2.equals(MESSAGE2)) {\n-                System.err.println(\"Test3a passed: setActivationDesc takes \" +\n-                                   \"effect after a restart\");\n-            } else {\n-                TestLibrary.bomb(\"Test3a failed: setActivationDesc did not take effect \" +\n-                     \"after a restart\", null);\n-            }\n-\n-            message2 = obj.getProperty(\"test.message\");\n-\n-            if (message2.equals(MESSAGE2)) {\n-                System.err.println(\"Test3b passed: setActivationGroupDesc \" +\n-                                   \"takes effect after a restart\");\n-            } else {\n-                TestLibrary.bomb(\"Test3b failed: setActivationGroupDesc did not take \" +\n-                     \"effect after a restart\", null);\n-            }\n-\n-            System.err.println(\"Get activation descriptor\");\n-            ActivationDesc latestDesc = system.getActivationDesc(id);\n-\n-            if (latestDesc.equals(newDesc)) {\n-                System.err.println(\"Test4a passed: desc is same as latest\");\n-            } else {\n-                TestLibrary.bomb(\"Test4a failed: there is no way this would happen\", null);\n-            }\n-\n-            System.err.println(\"Get activation group descriptor\");\n-            ActivationGroupDesc latestGroupDesc =\n-                system.getActivationGroupDesc(groupID);\n-\n-            if (latestGroupDesc.equals(newGroupDesc)) {\n-                System.err.println(\"Test4b passed: group desc is same as \" +\n-                                   \"latest\");\n-            } else {\n-                TestLibrary.bomb(\"Test4b failed: there is no way this would happen\", null);\n-            }\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/modifyDescriptor\/ModifyDescriptor.java","additions":0,"deletions":261,"binary":false,"changes":261,"status":"deleted"},{"patch":"@@ -1,194 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class ModifyDescriptor_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements ActivateMe\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"java.rmi.activation.ActivationID getID()\"),\n-        new java.rmi.server.Operation(\"java.lang.String getMessage()\"),\n-        new java.rmi.server.Operation(\"java.lang.String getProperty(java.lang.String)\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = 7998207954486691383L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_getID_0;\n-    private static java.lang.reflect.Method $method_getMessage_1;\n-    private static java.lang.reflect.Method $method_getProperty_2;\n-    private static java.lang.reflect.Method $method_shutdown_3;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_getID_0 = ActivateMe.class.getMethod(\"getID\", new java.lang.Class[] {});\n-            $method_getMessage_1 = ActivateMe.class.getMethod(\"getMessage\", new java.lang.Class[] {});\n-            $method_getProperty_2 = ActivateMe.class.getMethod(\"getProperty\", new java.lang.Class[] {java.lang.String.class});\n-            $method_shutdown_3 = ActivateMe.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public ModifyDescriptor_Stub() {\n-        super();\n-    }\n-    public ModifyDescriptor_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of getID()\n-    public java.rmi.activation.ActivationID getID()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_getID_0, null, -7795865521150345044L);\n-                return ((java.rmi.activation.ActivationID) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-                ref.invoke(call);\n-                java.rmi.activation.ActivationID $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (java.rmi.activation.ActivationID) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of getMessage()\n-    public java.lang.String getMessage()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_getMessage_1, null, 5353407034680111516L);\n-                return ((java.lang.String) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-                ref.invoke(call);\n-                java.lang.String $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (java.lang.String) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of getProperty(String)\n-    public java.lang.String getProperty(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_getProperty_2, new java.lang.Object[] {$param_String_1}, 77249282285080913L);\n-                return ((java.lang.String) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-                try {\n-                    java.io.ObjectOutput out = call.getOutputStream();\n-                    out.writeObject($param_String_1);\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.MarshalException(\"error marshalling arguments\", e);\n-                }\n-                ref.invoke(call);\n-                java.lang.String $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (java.lang.String) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_3, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 3, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/modifyDescriptor\/ModifyDescriptor_Stub.java","additions":0,"deletions":194,"binary":false,"changes":194,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/modifyDescriptor\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,11 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Dtest.message=hello\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Dtest.message=hello, again\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/modifyDescriptor\/rmid.security.policy","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,31 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/modifyDescriptor\/security.policy","additions":0,"deletions":31,"binary":false,"changes":31,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.registry.Registry;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface CanCreateStubs extends java.rmi.Remote {\n-    Registry getRegistry() throws RemoteException;\n-    void shutdown() throws Exception;\n-    Object getForbiddenClass() throws Exception;\n-    ActivationGroupID returnGroupID() throws RemoteException;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/stubClassesPermitted\/CanCreateStubs.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,264 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4179055\n- * @summary Some java apps need to have access to read \"accessClassInPackage.sun.rmi.server\"\n- * @author Laird Dornin\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.base\/sun.security.provider\n- *          java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID ActivationLibrary RMIDSelectorProvider\n- *     CanCreateStubs StubClassesPermitted_Stub\n- * @run main\/othervm\/java.security.policy=security.policy\/secure=java.lang.SecurityManager\/timeout=240 StubClassesPermitted\n- *\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.PrintStream;\n-import java.rmi.MarshalledObject;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.Activatable;\n-import java.rmi.activation.ActivationDesc;\n-import java.rmi.activation.ActivationGroup;\n-import java.rmi.activation.ActivationGroupDesc;\n-import java.rmi.activation.ActivationGroupDesc.CommandEnvironment;\n-import java.rmi.activation.ActivationGroupID;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.activation.ActivationSystem;\n-import java.rmi.registry.Registry;\n-import java.util.Properties;\n-\n-\/**\n- * The RMI activation system needs to explicitly allow itself to\n- * create the following sun.* classes on behalf of code that runs with\n- * user privileges and needs to make use of RMI activation:\n- *\n- *     sun.rmi.server.Activation$ActivationMonitorImpl_Stub\n- *     sun.rmi.server.Activation$ActivationSystemImpl_Stub\n- *     sun.rmi.registry.RegistryImpl_Stub\n- *\n- * The test causes the activation system to need to create each of\n- * these classes in turn.  The test will fail if the activation system\n- * does not allow these classes to be created.\n- *\/\n-public class StubClassesPermitted\n-    extends Activatable implements Runnable, CanCreateStubs\n-{\n-    public static boolean sameGroup = false;\n-    private static int registryPort = -1;\n-    private static CanCreateStubs canCreateStubs = null;\n-    private static Registry registry = null;\n-\n-    public static void main(String args[]) {\n-\n-        sameGroup = true;\n-\n-        RMID rmid = null;\n-\n-        System.err.println(\"\\nRegression test for bug\/rfe 4179055\\n\");\n-\n-        try {\n-            TestLibrary.suggestSecurityManager(\"java.lang.SecurityManager\");\n-\n-            registry = TestLibrary.createRegistryOnEphemeralPort();\n-            registryPort = TestLibrary.getRegistryPort(registry);\n-\n-            \/\/ must run with java.lang.SecurityManager or the test\n-            \/\/ result will be nullified if running with a build where\n-            \/\/ 4180392 has not been fixed.\n-            String smClassName =\n-                System.getSecurityManager().getClass().getName();\n-            if (!smClassName.equals(\"java.lang.SecurityManager\")) {\n-                TestLibrary.bomb(\"Test must run with java.lang.SecurityManager\");\n-            }\n-\n-            \/\/ start an rmid.\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/\/rmid.addOptions(new String[] {\"-C-Djava.rmi.server.logCalls=true\"});\n-\n-            \/\/ Ensure that activation groups run with the correct\n-            \/\/ security manager.\n-            \/\/\n-            Properties p = new Properties();\n-            p.put(\"java.security.policy\",\n-                  TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\",\n-                  \"java.lang.SecurityManager\");\n-\n-            \/\/ This action causes the following classes to be created\n-            \/\/ in this VM (RMI must permit the creation of these classes):\n-            \/\/\n-            \/\/ sun.rmi.server.Activation$ActivationSystemImpl_Stub\n-            \/\/ sun.rmi.server.Activation$ActivationMonitorImpl_Stub\n-            \/\/\n-            System.err.println(\"Create activation group, in a new VM\");\n-            CommandEnvironment cmd = new ActivationGroupDesc.CommandEnvironment(null,\n-                    new String[] {\n-                        \"--add-exports=java.base\/sun.security.provider=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.registry=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.server=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.transport=ALL-UNNAMED\",\n-                        \"--add-exports=java.rmi\/sun.rmi.transport.tcp=ALL-UNNAMED\" });\n-\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(p, cmd);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-\n-            System.err.println(\"register activatable\");\n-            \/\/ Fix for: 4271615: make sure activation group runs in a new VM\n-            ActivationDesc desc = new ActivationDesc\n-                (groupID, \"StubClassesPermitted\", null, null);\n-            canCreateStubs = (CanCreateStubs) Activatable.register(desc);\n-\n-            \/\/ ensure registry stub can be passed in a remote call\n-            System.err.println(\"getting the registry\");\n-            registry = canCreateStubs.getRegistry();\n-\n-            \/\/ make sure a client cant load just any sun.* class, just\n-            \/\/ as a sanity check, try to create a class we are not\n-            \/\/ allowed to access but which was passed in a remote call\n-            try {\n-                System.err.println(\"accessing forbidden class\");\n-                Object secureRandom = canCreateStubs.getForbiddenClass();\n-\n-                TestLibrary.bomb(\"test allowed to access forbidden class,\" +\n-                                 \" sun.security.provider.SecureRandom\");\n-            } catch (java.security.AccessControlException e) {\n-\n-                \/\/ Make sure we received a *local* AccessControlException\n-                ByteArrayOutputStream bout = new ByteArrayOutputStream();\n-                PrintStream ps = new PrintStream(bout);\n-                e.printStackTrace(ps);\n-                ps.flush();\n-                String trace = new String(bout.toByteArray());\n-                if ((trace.indexOf(\"exceptionReceivedFromServer\") >= 0) ||\n-                    trace.equals(\"\"))\n-                {\n-                    throw e;\n-                }\n-                System.err.println(\"received expected local access control exception\");\n-            }\n-\n-            \/\/ make sure that an ActivationGroupID can be passed in a\n-            \/\/ remote call; this is slightly more inclusive than\n-            \/\/ just passing a reference to the activation system\n-            System.err.println(\"returning group desc\");\n-            canCreateStubs.returnGroupID();\n-\n-            \/\/ Clean up object\n-            System.err.println\n-                (\"Deactivate object via method call\");\n-            canCreateStubs.shutdown();\n-\n-            System.err.println\n-                (\"\\nsuccess: StubClassesPermitted test passed \");\n-\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"\\nfailure: unexpected exception \", e);\n-        } finally {\n-            try {\n-                Thread.sleep(4000);\n-            } catch (InterruptedException e) {\n-            }\n-\n-            canCreateStubs = null;\n-            rmid.cleanup();\n-            System.err.println(\"rmid shut down\");\n-        }\n-    }\n-\n-    static ActivationGroupID GroupID = null;\n-\n-    \/**\n-     * implementation of CanCreateStubs\n-     *\/\n-    public StubClassesPermitted\n-        (ActivationID id, MarshalledObject mo) throws RemoteException\n-    {\n-        \/\/ register\/export anonymously\n-        super(id, 0);\n-\n-        \/\/ obtain reference to the test registry\n-        registry = java.rmi.registry.LocateRegistry.\n-            getRegistry(registryPort);\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception {\n-        (new Thread(this,\"StubClassesPermitted\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run() {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    \/**\n-     * Return a reference to the RMI registry, to make sure that\n-     * the stub for it can be deserialized in the test client VM.\n-     *\/\n-    public Registry getRegistry() throws RemoteException {\n-        if (sameGroup) {\n-            System.out.println(\"in same group\");\n-        } else {\n-            System.out.println(\"not in same group\");\n-        }\n-        return registry;\n-    }\n-\n-    \/**\n-     * Remote call to create and return a random serializable sun.*\n-     * class, the test should get a local security exception when\n-     * trying to create the class.  Ensure that not all sun.* classes\n-     * can be resolved in a remote call.\n-     *\/\n-    public Object getForbiddenClass() throws RemoteException {\n-        System.err.println(\"creating sun class\");\n-        return new sun.security.provider.SecureRandom();\n-    }\n-\n-    \/**\n-     * Ensures that an activation group id can be passed in a remote\n-     * call (class may contain a remote reference to the activation\n-     * system implementation).\n-     *\/\n-    public ActivationGroupID returnGroupID() throws RemoteException {\n-        return ActivationGroup.currentGroupID();\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/stubClassesPermitted\/StubClassesPermitted.java","additions":0,"deletions":264,"binary":false,"changes":264,"status":"deleted"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class StubClassesPermitted_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements CanCreateStubs, java.rmi.Remote\n-{\n-    private static final java.rmi.server.Operation[] operations = {\n-        new java.rmi.server.Operation(\"java.lang.Object getForbiddenClass()\"),\n-        new java.rmi.server.Operation(\"java.rmi.registry.Registry getRegistry()\"),\n-        new java.rmi.server.Operation(\"java.rmi.activation.ActivationGroupID returnGroupID()\"),\n-        new java.rmi.server.Operation(\"void shutdown()\")\n-    };\n-\n-    private static final long interfaceHash = 1677779850431817575L;\n-\n-    private static final long serialVersionUID = 2;\n-\n-    private static boolean useNewInvoke;\n-    private static java.lang.reflect.Method $method_getForbiddenClass_0;\n-    private static java.lang.reflect.Method $method_getRegistry_1;\n-    private static java.lang.reflect.Method $method_returnGroupID_2;\n-    private static java.lang.reflect.Method $method_shutdown_3;\n-\n-    static {\n-        try {\n-            java.rmi.server.RemoteRef.class.getMethod(\"invoke\",\n-                new java.lang.Class[] {\n-                    java.rmi.Remote.class,\n-                    java.lang.reflect.Method.class,\n-                    java.lang.Object[].class,\n-                    long.class\n-                });\n-            useNewInvoke = true;\n-            $method_getForbiddenClass_0 = CanCreateStubs.class.getMethod(\"getForbiddenClass\", new java.lang.Class[] {});\n-            $method_getRegistry_1 = CanCreateStubs.class.getMethod(\"getRegistry\", new java.lang.Class[] {});\n-            $method_returnGroupID_2 = CanCreateStubs.class.getMethod(\"returnGroupID\", new java.lang.Class[] {});\n-            $method_shutdown_3 = CanCreateStubs.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            useNewInvoke = false;\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public StubClassesPermitted_Stub() {\n-        super();\n-    }\n-    public StubClassesPermitted_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of getForbiddenClass()\n-    public java.lang.Object getForbiddenClass()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            Object $result = ref.invoke(this, $method_getForbiddenClass_0, null, -658265783646674294L);\n-            return ((java.lang.Object) $result);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 0, interfaceHash);\n-            ref.invoke(call);\n-            java.lang.Object $result;\n-            try {\n-                java.io.ObjectInput in = call.getInputStream();\n-                $result = (java.lang.Object) in.readObject();\n-            } catch (java.io.IOException e) {\n-                throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-            } catch (java.lang.ClassNotFoundException e) {\n-                throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-            } finally {\n-                ref.done(call);\n-            }\n-            return $result;\n-        }\n-    }\n-\n-    \/\/ implementation of getRegistry()\n-    public java.rmi.registry.Registry getRegistry()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_getRegistry_1, null, 255311215504696981L);\n-                return ((java.rmi.registry.Registry) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 1, interfaceHash);\n-                ref.invoke(call);\n-                java.rmi.registry.Registry $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (java.rmi.registry.Registry) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of returnGroupID()\n-    public java.rmi.activation.ActivationGroupID returnGroupID()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            if (useNewInvoke) {\n-                Object $result = ref.invoke(this, $method_returnGroupID_2, null, 6267304638191237098L);\n-                return ((java.rmi.activation.ActivationGroupID) $result);\n-            } else {\n-                java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 2, interfaceHash);\n-                ref.invoke(call);\n-                java.rmi.activation.ActivationGroupID $result;\n-                try {\n-                    java.io.ObjectInput in = call.getInputStream();\n-                    $result = (java.rmi.activation.ActivationGroupID) in.readObject();\n-                } catch (java.io.IOException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } catch (java.lang.ClassNotFoundException e) {\n-                    throw new java.rmi.UnmarshalException(\"error unmarshalling return\", e);\n-                } finally {\n-                    ref.done(call);\n-                }\n-                return $result;\n-            }\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        if (useNewInvoke) {\n-            ref.invoke(this, $method_shutdown_3, null, -7207851917985848402L);\n-        } else {\n-            java.rmi.server.RemoteCall call = ref.newCall((java.rmi.server.RemoteObject) this, operations, 3, interfaceHash);\n-            ref.invoke(call);\n-            ref.done(call);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/stubClassesPermitted\/StubClassesPermitted_Stub.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -1,11 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.security.provider\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/stubClassesPermitted\/group.security.policy","additions":0,"deletions":11,"binary":false,"changes":11,"status":"deleted"},{"patch":"@@ -1,12 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=java.lang.SecurityManager\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-\n-    \/\/ test needs to export a set of internal APIs to access them from unamed module\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/stubClassesPermitted\/rmid.security.policy","additions":0,"deletions":12,"binary":false,"changes":12,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ required for test to get the registry port\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.registry\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.server\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport.tcp\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/stubClassesPermitted\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-interface ActivateMe extends Remote {\n-    public void ping() throws RemoteException;\n-    public void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/unregisterGroup\/ActivateMe.java","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,167 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4134233\n- * @bug 4213186\n- * @summary synopsis: ActivationSystem.unregisterGroup should unregister objects in group\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID ActivationLibrary ActivateMe RMIDSelectorProvider\n- * @run main\/othervm\/policy=security.policy UnregisterGroup\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.util.Properties;\n-\n-public class UnregisterGroup extends Activatable implements ActivateMe\n-{\n-    private static volatile Exception exception = null;\n-    private static volatile String error = null;\n-    private static volatile boolean done = false;\n-    private static final int NUM_OBJECTS = 10;\n-\n-    public UnregisterGroup(ActivationID id, MarshalledObject mobj)\n-        throws Exception\n-    {\n-        super(id, 0);\n-    }\n-\n-    \/**\n-     * Does nothing, but serves to activate this object.\n-     *\/\n-    public void ping() { }\n-\n-    \/**\n-     * Deactivates the object. We need to unexport forcibly because\n-     * this call is in-progress on this object, which is the same object\n-     * that we are trying to deactivate.\n-     *\/\n-    public void shutdown() throws Exception {\n-        Activatable.unexportObject(this, true);\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) throws RemoteException {\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-        RMID rmid = null;\n-\n-        try {\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.start();\n-\n-            \/* Cause activation groups to have a security policy that will\n-             * allow security managers to be downloaded and installed\n-             *\/\n-            final Properties p = new Properties();\n-            \/\/ this test must always set policies\/managers in its\n-            \/\/ activation groups\n-            p.put(\"java.security.policy\", TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\", TestParams.defaultSecurityManager);\n-\n-            Thread t = new Thread() {\n-                public void run () {\n-                    try {\n-                        System.err.println(\"Creating group descriptor\");\n-                        ActivationGroupDesc groupDesc =\n-                            new ActivationGroupDesc(p, null);\n-                        ActivationSystem system = ActivationGroup.getSystem();\n-                        ActivationGroupID groupID =\n-                            system.registerGroup(groupDesc);\n-\n-                        ActivateMe[] obj = new ActivateMe[NUM_OBJECTS];\n-\n-                        for (int i = 0; i < NUM_OBJECTS; i++) {\n-                            System.err.println(\"Creating descriptor: \" + i);\n-                            ActivationDesc desc =\n-                                new ActivationDesc(groupID, \"UnregisterGroup\",\n-                                                   null, null);\n-                            System.err.println(\"Registering descriptor: \" + i);\n-                            obj[i] = (ActivateMe) Activatable.register(desc);\n-                            System.err.println(\"Activating object: \" + i);\n-                            obj[i].ping();\n-                        }\n-\n-                        System.err.println(\"Unregistering group\");\n-                        system.unregisterGroup(groupID);\n-\n-                        try {\n-                            System.err.println(\"Get the group descriptor\");\n-                            system.getActivationGroupDesc(groupID);\n-                            error = \"test failed: group still registered\";\n-                        } catch (UnknownGroupException e) {\n-                            System.err.println(\"Test passed: \" +\n-                                               \"group unregistered\");\n-                        }\n-\n-                        \/*\n-                         * Deactivate objects so group VM will exit.\n-                         *\/\n-                        for (int i = 0; i < NUM_OBJECTS; i++) {\n-                            System.err.println(\"Deactivating object: \" + i);\n-                            obj[i].shutdown();\n-                            obj[i] = null;\n-                        }\n-                        System.err.println(\"Successfully deactivated all objects.\");\n-\n-                    } catch (Exception e) {\n-                        exception = e;\n-                    }\n-\n-                    done = true;\n-                }\n-            };\n-\n-            t.start();\n-\n-            \/\/ Default jtreg timeout is two minutes.\n-            \/\/ Timeout ourselves after one minute so that\n-            \/\/ we can clean up.\n-            t.join(60000);\n-\n-            if (exception != null) {\n-                TestLibrary.bomb(\"test failed\", exception);\n-            } else if (error != null) {\n-                TestLibrary.bomb(error, null);\n-            } else if (!done) {\n-                TestLibrary.bomb(\"test failed: not completed before timeout\", null);\n-            } else {\n-                System.err.println(\"Test passed\");\n-            }\n-        } catch (Exception e) {\n-            TestLibrary.bomb(\"test failed\", e);\n-        } finally {\n-            rmid.cleanup();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/unregisterGroup\/UnregisterGroup.java","additions":0,"deletions":167,"binary":false,"changes":167,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/unregisterGroup\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/unregisterGroup\/rmid.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-\n-  \/\/ required for test to get the registry port\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.registry\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.server\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport.tcp\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/ActivationSystem\/unregisterGroup\/security.policy","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,91 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-\n-public class Doctor\n-    extends Activatable\n-    implements Eliza, Retireable\n-{\n-    \/\/ reanimation constructor\n-    public Doctor(ActivationID id, MarshalledObject blah)\n-        throws RemoteException\n-    {\n-        super(id, 0);   \/\/ export self on port 0 (== assign randomly)\n-        System.out.println(\"Doctor constructed and exported\");\n-    }\n-\n-    private boolean asked = false;\n-\n-    \/\/ implement Eliza.complain()\n-    public String complain(String plaint)\n-    {\n-        System.out.println(\"Doctor will see you now\");\n-        if (this.asked) {\n-            return (\"DO GO ON?\");\n-        } else {\n-            this.asked = true;\n-            return (\"TELL ME ABOUT YOUR MOTHER\");\n-        }\n-    }\n-\n-    \/\/ implement Retireable.retire()\n-    public void retire()\n-    {\n-        System.out.println(\"Doctor retiring\");\n-        try {\n-            Activatable.inactive(this.getID());\n-            ActivationGroup.getSystem().unregisterObject(this.getID());\n-            (new HaraKiri()).start();\n-\n-        } catch (UnknownObjectException uoe) {\n-            System.err.println(\"Exception in Activatable.inactive:\");\n-            uoe.printStackTrace();\n-\n-        } catch (ActivationException ae) {\n-            System.err.println(\"Exception in Activatable.inactive:\");\n-            ae.printStackTrace();\n-\n-        } catch (RemoteException re) {\n-            System.err.println(\"Exception in Activatable.inactive:\");\n-            re.printStackTrace();\n-        }\n-    }\n-\n-    private static class HaraKiri extends Thread\n-    {\n-        public HaraKiri() {\n-            super(\"Thread-of-Death\");\n-        }\n-\n-        public void run()\n-        {\n-            try {\n-                Thread.sleep(5000);\n-            } catch (Exception foo) {\n-            }\n-            System.exit(0);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/Doctor.java","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,83 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class Doctor_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements Eliza, Retireable, java.rmi.Remote\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_complain_0;\n-    private static java.lang.reflect.Method $method_retire_1;\n-\n-    static {\n-        try {\n-            $method_complain_0 = Eliza.class.getMethod(\"complain\", new java.lang.Class[] {java.lang.String.class});\n-            $method_retire_1 = Retireable.class.getMethod(\"retire\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public Doctor_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of complain(String)\n-    public java.lang.String complain(java.lang.String $param_String_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            Object $result = ref.invoke(this, $method_complain_0, new java.lang.Object[] {$param_String_1}, -6341882871094951445L);\n-            return ((java.lang.String) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of retire()\n-    public void retire()\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            ref.invoke(this, $method_retire_1, null, 1748571935738034018L);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/Doctor_Stub.java","additions":0,"deletions":83,"binary":false,"changes":83,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public interface Eliza\n-    extends java.rmi.Remote\n-{\n-    public String complain(String plaint)\n-        throws java.rmi.RemoteException;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/Eliza.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,51 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 6236643\n- * @summary null doesn't have the same effect as empty list for\n- * ActivationGroupDesc.CommandEnvironment\n- * @author  Ann Wollrath\n- *\n- * @run main\/othervm\/timeout=240 NullOptions\n- *\/\n-\n-import java.rmi.activation.ActivationGroupDesc.CommandEnvironment;\n-\n-public class NullOptions {\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        CommandEnvironment env1 =\n-            new CommandEnvironment(null, null);\n-        CommandEnvironment env2 =\n-            new CommandEnvironment(null, new String[0]);\n-\n-        if (env1.equals(env2)) {\n-            System.err.println(\"TEST PASSED: environments are equal\");\n-        } else {\n-            System.err.println(\"TEST FAILED: environments not equal!\");\n-            throw new RuntimeException(\"TEST FAILED\");\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/NullOptions.java","additions":0,"deletions":51,"binary":false,"changes":51,"status":"deleted"},{"patch":"@@ -1,29 +0,0 @@\n-\/*\n- * Copyright (c) 1998, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-public interface Retireable\n-    extends java.rmi.Remote\n-{\n-    public void retire()\n-        throws java.rmi.RemoteException;\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/Retireable.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"deleted"},{"patch":"@@ -1,253 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- *\n- * @bug 4105043\n- * @summary cannot set java.rmi.server.hostname on children of rmid in time\n- *\n- * @bug 4097357\n- * @summary activation group should not overwrite system properties\n- *\n- * @bug 4107184\n- * @summary activation groups should be able to control their JVM properties\n- *\n- * @author Adrian Colley\n- *\n- * @library ..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary RMID ActivationLibrary RMIDSelectorProvider\n- *     Eliza Retireable Doctor Doctor_Stub\n- * @run main\/othervm\/timeout=240\/policy=security.policy SetChildEnv 0 0\n- * @run main\/othervm\/timeout=240\/policy=security.policy SetChildEnv 1 -verbosegc\n- *                       2 foo.bar=SetChildEnvTest sun.rmi.server.doSomething=true\n- * @run main\/othervm\/timeout=240\/policy=security.policy SetChildEnv 0 1 parameter.count=zero\n- * @run main\/othervm\/timeout=240\/policy=security.policy SetChildEnv 1 -Xmx32m 0\n- *\/\n-import java.rmi.*;\n-import java.util.Properties;\n-import java.io.*;\n-import java.util.StringTokenizer;\n-import java.util.Set;\n-import java.util.HashSet;\n-import java.util.Arrays;\n-import java.rmi.activation.*;\n-\n-public class SetChildEnv\n-{\n-    public static void main(String argv[]) throws Exception {\n-        RMID rmid = null;\n-        try {\n-            System.out.println(\"java.compiler=\" + System.getProperty(\"java.compiler\"));\n-            int paramCount = Integer.valueOf(argv[0]);\n-            String[] params = paramCount == 0 ?\n-                    new String[0] : Arrays.copyOfRange(argv, 1, paramCount+1);\n-            int propCount = Integer.valueOf(argv[paramCount+1]);\n-            String[] props = propCount == 0 ?\n-                    new String[0] :\n-                    Arrays.copyOfRange(argv, paramCount+2, paramCount+propCount+2);\n-\n-            TestLibrary.suggestSecurityManager(TestParams.defaultSecurityManager);\n-\n-            \/\/ make a \"watcher\" which listens on a pipe and searches for\n-            \/\/ the debugExec line while teeing to System.err\n-            DebugExecWatcher watcher = DebugExecWatcher.makeWithPipe();\n-\n-            RMID.removeLog();\n-            rmid = RMID.createRMIDOnEphemeralPort(watcher.otherEnd(),\n-                                                  watcher.otherEnd(), true);\n-\n-            rmid.start();\n-\n-            \/\/ compile props\n-            Properties p = new Properties();\n-            p.put(\"java.security.policy\", TestParams.defaultGroupPolicy);\n-            p.put(\"java.security.manager\", TestParams.defaultSecurityManager);\n-            \/\/p.put(\"java.rmi.server.logCalls\", \"true\");\n-            int i;\n-            for (i = 0; i < props.length; i++) {\n-                p.put(props[i].substring(0, props[i].indexOf('=')),\n-                      props[i].substring(props[i].indexOf('=')+1));\n-            }\n-\n-            \/\/ create CommandEnvironment and ActivationGroupDesc\n-            ActivationGroupDesc.CommandEnvironment cmdenv =\n-                    new ActivationGroupDesc.CommandEnvironment(\n-                        null,\n-                        params);\n-\n-            ActivationGroupDesc gdesc = new ActivationGroupDesc(\n-                    p, cmdenv);\n-\n-            \/\/ register group\n-            ActivationSystem actsys = ActivationGroup.getSystem();\n-            ActivationGroupID gid = actsys.registerGroup(gdesc);\n-\n-            \/\/ create ActivationDesc\n-            ActivationDesc odesc = new ActivationDesc(gid, \/\/ group\n-                                                      \"Doctor\", \/\/ class\n-                                                      null, \/\/ codesource\n-                                                      null); \/\/ closure data\n-\n-            \/\/ register activatable object\n-            Eliza doctor = (Eliza)Activatable.register(odesc);\n-\n-            \/\/ invoke a call with oh-so-humorous sample text\n-            System.out.println (\"Invoking complain()...\");\n-            String complaint =\n-                    \"HELP ME, DOCTOR.  I FEEL VIOLENT TOWARDS PEOPLE \" +\n-                    \"WHO INQUIRE ABOUT MY PARENTS.\";\n-\n-            System.out.println(complaint);\n-            String res = doctor.complain(complaint);\n-            System.out.println (\" => \" + res);\n-\n-            \/\/ Get debugExec line, allowing 15 seconds for it to flush\n-            \/\/ through the buffers and pipes.\n-            String found = watcher.found;\n-            if (found == null) {\n-                int fudge = 15;\n-                while (found == null && --fudge > 0) {\n-                    Thread.sleep(1000);\n-                    found = watcher.found;\n-                }\n-                if (found == null) {\n-                    TestLibrary.bomb(\"rmid subprocess produced no \" +\n-                                     \"recognizable debugExec line\");\n-                }\n-            }\n-\n-            System.err.println(\"debugExec found: <<\" + found + \">>\");\n-            \/\/ q: first double-quote after debugExec\n-            int q = found.indexOf('\"', found.indexOf(\"rmid: debugExec\"));\n-            \/\/ qe: last double-quote on debugExec line\n-            int qe = found.lastIndexOf('\"');\n-            if (q <= 1 || qe <= q) {\n-                TestLibrary.bomb(\"rmid subprocess produced \" +\n-                                 \"mangled debugExec line\");\n-            }\n-\n-            \/\/ split args by whitespace\n-            StringTokenizer tk = new StringTokenizer(found.substring(q+1, qe));\n-            tk.nextToken();         \/\/ skip command path\/name\n-\n-            \/\/ Now check off the requested args.  Order isn't important, and\n-            \/\/ any extra args are ignored, even if they're inconsistent or\n-            \/\/ bargage, or duplicates.\n-\n-            Set argset = new HashSet(tk.countTokens());\n-            while (tk.hasMoreTokens()) {\n-                argset.add(tk.nextToken());\n-            }\n-\n-            int m;\n-            for (m = 0; m < params.length; m++) {\n-                if(!argset.contains(params[m]))\n-                    TestLibrary.bomb(\"Parameter \\\"\" + params[m] + \"\\\" not set\");\n-            }\n-\n-            for (m = 0; m < props.length; m++) {\n-                if (!argset.contains(\"-D\" + props[m])) {\n-                    TestLibrary.bomb(\"Property binding \\\"\" + props[m] +\n-                                     \"\\\" not set\");\n-                }\n-            }\n-\n-            \/\/ End doctor\n-            if (doctor instanceof Retireable)\n-                ((Retireable)doctor).retire();\n-            actsys.unregisterGroup(gid);\n-        } finally {\n-            Thread.sleep(5000);\n-            if (rmid != null) {\n-                rmid.cleanup();\n-            }\n-        }\n-    }\n-\n-    public static class DebugExecWatcher\n-        extends Thread\n-    {\n-        public String found;\n-        private BufferedReader str;\n-        private OutputStream otherEnd;\n-\n-        private DebugExecWatcher(InputStream readStream, OutputStream wrStream)\n-        {\n-            super(\"DebugExecWatcher\");\n-            found = null;\n-            str = new BufferedReader(new InputStreamReader(readStream));\n-            otherEnd = wrStream;\n-        }\n-\n-        static public DebugExecWatcher makeWithPipe()\n-            throws IOException\n-        {\n-            PipedOutputStream wr = new PipedOutputStream();\n-            PipedInputStream rd = new PipedInputStream(wr);\n-            DebugExecWatcher embryo = new DebugExecWatcher(rd, wr);\n-            embryo.start();\n-            return embryo;\n-        }\n-\n-        public OutputStream otherEnd()\n-        {\n-            return otherEnd;\n-        }\n-\n-        public synchronized void notifyLine(String s)\n-        {\n-            if (s != null && s.indexOf(\"rmid: debugExec\") != -1)\n-                found = s;\n-        }\n-\n-        public void run()\n-        {\n-            try {\n-                String line;\n-                while ((line = str.readLine()) != null) {\n-                    this.notifyLine(line);\n-                    System.err.println(line);\n-                }\n-            } catch (IOException e) {\n-                \/* During termination of distant rmid, StreamPipes will be broken when\n-                 * distant vm terminates. A \"Pipe broken\" exception is expected because\n-                 * DebugExecWatcher points to the same streams as StreamPipes used by RMID.\n-                 * If we get this exception. We just terminate the thread.\n-                 *\/\n-                if (e.getMessage().equals(\"Pipe broken\")) {\n-                    try {\n-                        str.close();\n-                    } catch (IOException ioe) {}\n-                }\n-                else {\n-                    e.printStackTrace();\n-                }\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/SetChildEnv.java","additions":0,"deletions":253,"binary":false,"changes":253,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,14 +0,0 @@\n-grant {\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.manager=default\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Djava.security.policy=*\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Dsun.rmi.server.doSomething=true\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Dfoo.bar=SetChildEnvTest\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-verbosegc\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Dparameter.count=zero\";\n-    permission com.sun.rmi.rmid.ExecOptionPermission \"-Xmx32m\";\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/rmid.security.policy","additions":0,"deletions":14,"binary":false,"changes":14,"status":"deleted"},{"patch":"@@ -1,32 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-  permission java.util.PropertyPermission \"java.compiler\", \"read\";\n-\n-  \/\/ used by TestLibrary to determine test environment \n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/CommandEnvironment\/security.policy","additions":0,"deletions":32,"binary":false,"changes":32,"status":"deleted"},{"patch":"@@ -1,196 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 4652922\n- *\n- * @summary synopsis: ReliableLog.update should pad records to 4-byte\n- * boundaries\n- * @author Ann Wollrath\n- *\n- * @modules java.rmi\/sun.rmi.log\n- * @run main\/othervm\/timeout=240 LogTest\n- *\/\n-\n-import sun.rmi.log.LogHandler;\n-import sun.rmi.log.ReliableLog;\n-import java.io.FileDescriptor;\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.Serializable;\n-\n-public class LogTest {\n-\n-    private static int crashPoint = 0;\n-    private static boolean spansBoundary = false;\n-    private static ReliableLog log =  null;\n-    private static Counter counter = new Counter();\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        System.err.println(\"\\nRegression test for bug 4652922\\n\");\n-\n-        System.setProperty(\"sun.rmi.log.class\", MyLogFile.class.getName());\n-        \/\/System.setProperty(\"sun.rmi.log.debug\", \"true\");\n-\n-        log = new ReliableLog(\".\", new TestLogHandler(counter), false);\n-\n-        writeUpdatesCrashAndRecover(10, 1, false, 10);\n-        writeUpdatesCrashAndRecover(10, 1, true, 20);\n-        writeUpdatesCrashAndRecover(10, 2, true, 30);\n-        writeUpdatesCrashAndRecover(9, 2, false, 40);\n-        writeUpdatesCrashAndRecover(9, 3, true, 50);\n-        log.close();\n-    }\n-\n-    private static void writeUpdatesCrashAndRecover(int updates,\n-                                                    int crashValue,\n-                                                    boolean spans,\n-                                                    int expectedCount)\n-        throws IOException\n-    {\n-        \/*\n-         * Write updates\n-         *\/\n-        System.err.println(\"\\nwrite updates: \" + updates);\n-        for (int i = 0; i < updates; i++) {\n-            counter.increment();\n-            log.update(counter);\n-        }\n-\n-        \/*\n-         * Crash\n-         *\/\n-        crashPoint = crashValue;\n-        spansBoundary = spans;\n-        System.err.println(\"crash during next update on sync #\" +\n-                           crashPoint +\n-                           \" (spansBoundary = \" + spansBoundary + \")\");\n-        try {\n-            System.err.println(\n-                \"write one update (update record should \" +\n-                ((counter.value() + 1 == expectedCount) ? \"\" : \"not \") +\n-                \"be complete)\");\n-            counter.increment();\n-            log.update(counter);\n-            throw new RuntimeException(\"failed to reach crashpoint \" +\n-                                       crashPoint);\n-        } catch (IOException e) {\n-            System.err.println(\"caught IOException; message: \" +\n-                               e.getMessage());\n-            log.close();\n-        }\n-\n-        \/*\n-         * Recover\n-         *\/\n-        log = new ReliableLog(\".\", new TestLogHandler(null), false);\n-        try {\n-            System.err.println(\"recover log\");\n-            counter = (Counter) log.recover();\n-            System.err.println(\"recovered counter value: \" + counter.value());\n-            if (counter.value() != expectedCount) {\n-                throw new RuntimeException(\"unexpected counter value \" +\n-                                           counter.value());\n-            }\n-            System.err.println(\"log recovery successful\");\n-\n-        } catch (IOException e) {\n-            System.err.println(\"log should recover after crash point\");\n-            e.printStackTrace();\n-            throw new RuntimeException(\n-                \"log should recover after crash point\");\n-        }\n-\n-    }\n-\n-    private static class Counter implements Serializable {\n-        private static long serialVersionUID = 1;\n-        private int count = 0;\n-\n-        Counter() {}\n-\n-        int increment() {\n-            return ++count;\n-        }\n-\n-        int value() {\n-            return count;\n-        }\n-\n-        void update(Counter value) {\n-            if (value.value() < count) {\n-                throw new IllegalStateException(\n-                    \"bad update (count = \" + count + \", value = \" + value + \")\");\n-            } else {\n-                count = value.value();\n-            }\n-        }\n-    }\n-\n-    static class TestLogHandler extends LogHandler {\n-\n-        private final Counter initialState;\n-\n-        TestLogHandler(Counter initialState) {\n-            this.initialState = initialState;\n-        }\n-\n-        public Object initialSnapshot() {\n-            if (initialState == null) {\n-                throw new IllegalStateException(\n-                    \"attempting initialSnapshot with null\");\n-            }\n-            return initialState;\n-        }\n-\n-        public Object applyUpdate(Object update, Object state) {\n-            ((Counter) state).update((Counter) update);\n-            return state;\n-        }\n-    }\n-\n-    public static class MyLogFile extends ReliableLog.LogFile {\n-\n-        public MyLogFile(String name, String mode)\n-            throws FileNotFoundException, IOException\n-        {\n-            super(name, mode);\n-        }\n-\n-        protected void sync() throws IOException {\n-            if (crashPoint != 0) {\n-                if (--crashPoint == 0) {\n-                    throw new IOException(\"crash point reached\");\n-                }\n-            }\n-            super.sync();\n-        }\n-\n-        protected boolean checkSpansBoundary(long fp) {\n-            return\n-                crashPoint > 0 ? spansBoundary : super.checkSpansBoundary(fp);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/log\/LogTest.java","additions":0,"deletions":196,"binary":false,"changes":196,"status":"deleted"},{"patch":"@@ -1,181 +0,0 @@\n-\/*\n- * Copyright (c) 2017, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.net.InetAddress;\n-import java.rmi.AccessException;\n-import java.rmi.activation.ActivationSystem;\n-import java.rmi.registry.LocateRegistry;\n-import java.rmi.registry.Registry;\n-import java.util.Set;\n-\n-\/*\n- * @test\n- * @bug 8174770\n- * @summary Verify that ActivationSystem rejects non-local access.\n- *    The test is manual because the (non-local) host running rmid must be supplied as a property.\n- * @run main\/manual\/othervm -Dactivation.host=rmid-host NonLocalActivationTest\n- *\/\n-\n-\/**\n- * Lookup the ActivationSystem on a different host and invoke its remote interface methods.\n- * They should all throw an exception, non-local access is prohibited.\n- *\n- * This test is a manual test and uses rmid running on a *different* host.\n- * The default port (1098) for the Activation System is ok and expected.\n- * Login or ssh to the different host and invoke {@code $JDK_HOME\/bin\/rmid}.\n- * It will not show any output.\n- *\n- * On the first host modify the @run command above to replace \"rmid-host\"\n- * with the hostname or IP address of the different host and run the test with jtreg.\n- *\/\n-public class NonLocalActivationTest\n-{\n-    public static void main(String[] args) throws Exception {\n-\n-        String host = System.getProperty(\"activation.host\");\n-        if (host == null || host.isEmpty()) {\n-            throw new RuntimeException(\"Specify host with system property: -Dactivation.host=<host>\");\n-        }\n-\n-        \/\/ Check if running the test on a local system; it only applies to remote\n-        String myHostName = InetAddress.getLocalHost().getHostName();\n-        Set<InetAddress> myAddrs = Set.of(InetAddress.getAllByName(myHostName));\n-        Set<InetAddress> hostAddrs = Set.of(InetAddress.getAllByName(host));\n-        if (hostAddrs.stream().anyMatch(i -> myAddrs.contains(i))\n-                || hostAddrs.stream().anyMatch(h -> h.isLoopbackAddress())) {\n-            throw new RuntimeException(\"Error: property 'activation.host' must not be the local host%n\");\n-        }\n-\n-        \/\/ Locate the registry operated by the ActivationSystem\n-        \/\/ Test SystemRegistryImpl\n-        Registry registry = LocateRegistry.getRegistry(host, ActivationSystem.SYSTEM_PORT);\n-        try {\n-            \/\/ Verify it is an ActivationSystem registry\n-            registry.lookup(\"java.rmi.activation.ActivationSystem\");\n-        } catch (Exception nf) {\n-            throw new RuntimeException(\"Not a ActivationSystem registry, does not contain java.rmi.activation.ActivationSystem\", nf);\n-        }\n-\n-        try {\n-            registry.bind(\"foo\", null);\n-            throw new RuntimeException(\"Remote access should not succeed for method: bind\");\n-        } catch (Exception e) {\n-            assertIsAccessException(e, \"Registry.bind\");\n-        }\n-\n-        try {\n-            registry.rebind(\"foo\", null);\n-            throw new RuntimeException(\"Remote access should not succeed for method: rebind\");\n-        } catch (Exception e) {\n-            assertIsAccessException(e, \"Registry.rebind\");\n-        }\n-\n-        try {\n-            registry.unbind(\"foo\");\n-            throw new RuntimeException(\"Remote access should not succeed for method: unbind\");\n-        } catch (Exception e) {\n-            assertIsAccessException(e, \"Registry.unbind\");\n-        }\n-\n-\n-        \/\/ Locate the ActivationSystem on the specified host and default port.\n-        \/\/ Test each of the ActivationSystem methods\n-        ActivationSystem as = (ActivationSystem) registry.lookup(\"java.rmi.activation.ActivationSystem\");\n-\n-        \/\/ Argument is not material, access check is before arg processing\n-\n-        try {\n-            as.registerGroup(null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.getActivationDesc(null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.getActivationGroupDesc(null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.registerObject(null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.unregisterGroup(null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.unregisterObject(null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.setActivationDesc(null, null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-\n-        try {\n-            as.setActivationGroupDesc(null, null);\n-        } catch (Exception aex) {\n-            assertIsAccessException(aex, \"ActivationSystem.nonLocalAccess\");\n-        }\n-    }\n-\n-    \/**\n-     * Check the exception chain for the expected AccessException and message.\n-     * @param ex the exception from the remote invocation.\n-     *\/\n-    private static void assertIsAccessException(Exception ex, String msg1) {\n-        Throwable t = ex;\n-        System.out.println();\n-        while (!(t instanceof AccessException) && t.getCause() != null) {\n-            t = t.getCause();\n-        }\n-        if (t instanceof AccessException) {\n-            String msg = t.getMessage();\n-            int asIndex = msg.indexOf(msg1);\n-            int disallowIndex = msg.indexOf(\"disallowed\");\n-            int nonLocalHostIndex = msg.indexOf(\"non-local host\");\n-            if (asIndex < 0 ||\n-                    disallowIndex < 0 ||\n-                    nonLocalHostIndex < 0 ) {\n-                throw new RuntimeException(\"exception message is malformed\", t);\n-            }\n-            System.out.printf(\"Found expected AccessException: %s%n\", t);\n-        } else {\n-            throw new RuntimeException(\"AccessException did not occur\", ex);\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/nonLocalActivation\/NonLocalActivationTest.java","additions":0,"deletions":181,"binary":false,"changes":181,"status":"deleted"},{"patch":"@@ -1,198 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 6261402 6824141\n- * @summary If rmid has an inherited channel that is not a server\n- * socket (such as it if was started using rsh\/rcmd), then it should\n- * function normally.\n- * @author Peter Jones\n- *\n- * @library ..\/..\/testlibrary\n- * @modules java.base\/sun.nio.ch\n- *          java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- * @build TestLibrary RMID ActivationLibrary\n- * @run main\/othervm\/timeout=240 InheritedChannelNotServerSocket\n- * @key intermittent\n- *\/\n-\n-import java.io.IOException;\n-import java.net.Socket;\n-import java.net.ProtocolFamily;\n-import java.nio.channels.Channel;\n-import java.nio.channels.DatagramChannel;\n-import java.nio.channels.Pipe;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.spi.AbstractSelector;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.rmi.NotBoundException;\n-import java.rmi.Remote;\n-import java.rmi.RemoteException;\n-import java.rmi.activation.ActivationGroup;\n-import java.rmi.activation.ActivationSystem;\n-import java.rmi.registry.LocateRegistry;\n-import java.rmi.registry.Registry;\n-import java.rmi.server.UnicastRemoteObject;\n-\n-public class InheritedChannelNotServerSocket {\n-    private static final Object lock = new Object();\n-    private static boolean notified = false;\n-\n-    private InheritedChannelNotServerSocket() { }\n-\n-    public interface Callback extends Remote {\n-        void notifyTest() throws RemoteException;\n-    }\n-\n-    public static class CallbackImpl implements Callback {\n-        CallbackImpl() { }\n-        public void notifyTest() {\n-            synchronized (lock) {\n-                notified = true;\n-                System.err.println(\"notification received.\");\n-                lock.notifyAll();\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        System.err.println(\"\\nRegression test for bug 6261402\\n\");\n-        System.setProperty(\"java.rmi.activation.port\",\n-                           Integer.toString(TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT));\n-        RMID rmid = null;\n-        Callback obj = null;\n-        try {\n-            \/*\n-             * Export callback object and bind in registry.\n-             *\/\n-            System.err.println(\"export callback object and bind in registry\");\n-            obj = new CallbackImpl();\n-            Callback proxy =\n-                (Callback) UnicastRemoteObject.exportObject(obj, 0);\n-            Registry registry = TestLibrary.createRegistryOnEphemeralPort();\n-            int registryPort = TestLibrary.getRegistryPort(registry);\n-            registry.bind(\"Callback\", proxy);\n-\n-            \/*\n-             * Start rmid.\n-             *\/\n-            System.err.println(\"start rmid with inherited channel\");\n-            RMID.removeLog();\n-            rmid = RMID.createRMID(System.out, System.err, true, true,\n-                                   TestLibrary.INHERITEDCHANNELNOTSERVERSOCKET_ACTIVATION_PORT);\n-            rmid.addOptions(\n-                \"--add-exports=java.base\/sun.nio.ch=ALL-UNNAMED\",\n-                \"-Djava.nio.channels.spi.SelectorProvider=InheritedChannelNotServerSocket$SP\",\n-                \"-Dtest.java.rmi.rmidViaInheritedChannel.registry.port=\" + registryPort);\n-            rmid.start();\n-\n-            \/*\n-             * Get activation system and wait to be notified via callback\n-             * from rmid's selector provider.\n-             *\/\n-            System.err.println(\"get activation system\");\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            System.err.println(\"ActivationSystem = \" + system);\n-            synchronized (lock) {\n-                while (!notified) {\n-                    lock.wait();\n-                }\n-            }\n-            System.err.println(\"TEST PASSED\");\n-        } finally {\n-            if (obj != null) {\n-                UnicastRemoteObject.unexportObject(obj, true);\n-            }\n-            if (rmid != null) {\n-                rmid.cleanup();\n-            }\n-        }\n-    }\n-\n-    public static class SP extends SelectorProvider {\n-        private final SelectorProvider provider;\n-        private volatile SocketChannel channel = null;\n-\n-        public SP() {\n-            provider = sun.nio.ch.DefaultSelectorProvider.get();\n-        }\n-\n-        public DatagramChannel openDatagramChannel() throws IOException {\n-            return provider.openDatagramChannel();\n-        }\n-\n-        public DatagramChannel openDatagramChannel(ProtocolFamily family)\n-            throws IOException\n-        {\n-            return provider.openDatagramChannel(family);\n-        }\n-\n-        public Pipe openPipe() throws IOException {\n-            return provider.openPipe();\n-        }\n-\n-        public AbstractSelector openSelector() throws IOException {\n-            return provider.openSelector();\n-        }\n-\n-        public ServerSocketChannel openServerSocketChannel()\n-            throws IOException\n-        {\n-            return provider.openServerSocketChannel();\n-        }\n-\n-        public SocketChannel openSocketChannel() throws IOException {\n-            return provider.openSocketChannel();\n-        }\n-\n-        public synchronized Channel inheritedChannel() throws IOException {\n-            System.err.println(\"SP.inheritedChannel\");\n-            if (channel == null) {\n-                channel = SocketChannel.open();\n-                Socket socket = channel.socket();\n-                System.err.println(\"socket = \" + socket);\n-\n-                \/*\n-                 * Notify test that inherited channel was created.\n-                 *\/\n-                try {\n-                    System.err.println(\"notify test...\");\n-                    int registryPort = Integer.getInteger(\n-                            \"test.java.rmi.rmidViaInheritedChannel.registry.port\", 0);\n-                    Registry registry = LocateRegistry.getRegistry(registryPort);\n-                    Callback obj = (Callback) registry.lookup(\"Callback\");\n-                    obj.notifyTest();\n-                } catch (NotBoundException nbe) {\n-                    throw (IOException)\n-                        new IOException(\"callback object not bound\").\n-                            initCause(nbe);\n-                }\n-            }\n-            return channel;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/activation\/rmidViaInheritedChannel\/InheritedChannelNotServerSocket.java","additions":0,"deletions":198,"binary":false,"changes":198,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-grant {\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.net.SocketPermission \"*\", \"connect,accept\";\n-    permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-    permission java.util.PropertyPermission \"test.java.rmi.rmidViaInheritedChannel.registry.port\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/activation\/rmidViaInheritedChannel\/rmid.security.policy","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary rmid and rmiregistry could allow alternate security manager\n+ * @summary rmiregistry could allow alternate security manager\n@@ -35,2 +35,1 @@\n- * @build TestLibrary RMID RMIDSelectorProvider RegistryVM RMIRegistryRunner\n- *        TestSecurityManager\n+ * @build TestLibrary RegistryVM RMIRegistryRunner TestSecurityManager\n@@ -42,1 +41,1 @@\n- * be used in rmiregistry and rmid.  Test specifies a security manager\n+ * be used in rmiregistry.  Test specifies a security manager\n@@ -44,1 +43,1 @@\n- * will cause rmiregistry and rmid to exit early because those\n+ * will cause rmiregistry to exit early because those\n@@ -46,1 +45,1 @@\n- * if registry and rmid take too long to exit.\n+ * if registry takes too long to exit.\n@@ -49,1 +48,1 @@\n-    \/\/ variable to hold registry and rmid children\n+    \/\/ variable to hold registry child\n@@ -55,1 +54,0 @@\n-    static final String ACTIVATION = \"sun.rmi.server.Activation\";\n@@ -67,3 +65,0 @@\n-            } else if (utilityToStart.contains(ACTIVATION)) {\n-                vm = RMID.createRMIDOnEphemeralPortWithOptions(\n-                        \"-Djava.security.manager=TestSecurityManager\");\n@@ -71,2 +66,1 @@\n-                TestLibrary.bomb(\"Utility to start must be \" + REGISTRY_IMPL +\n-                        \" or \" + ACTIVATION);\n+                TestLibrary.bomb(\"Utility to start must be \" + REGISTRY_IMPL);\n@@ -96,1 +90,1 @@\n-     * Wait to make sure that the registry and rmid exit after\n+     * Wait to make sure that the registry exits after\n@@ -134,3 +128,0 @@\n-            \/\/ make sure rmid exits early\n-            ensureExit(ACTIVATION);\n-\n@@ -141,2 +132,0 @@\n-        } finally {\n-            RMID.removeLog();\n","filename":"test\/jdk\/java\/rmi\/registry\/altSecurityManager\/AltSecurityManager.java","additions":9,"deletions":20,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,1 @@\n-        \/\/ 4269910: ok, now rmid and the regsitry will *really* go\n-        \/\/ away...\n+        \/\/ 4269910: ok, now the registry will *really* go away...\n@@ -36,1 +35,1 @@\n-        \/\/ rmid and the registry need to listen on sockets so they\n+        \/\/ the registry needs to listen on sockets so they\n","filename":"test\/jdk\/java\/rmi\/registry\/altSecurityManager\/TestSecurityManager.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4,2 +4,0 @@\n-  permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-  permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n","filename":"test\/jdk\/java\/rmi\/registry\/altSecurityManager\/rmid.security.policy","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-interface CompressConstants {\n-\n-    \/\/ constants for 6-bit code values\n-    static final int NOP  = 0;  \/\/ no operation: used to pad words on flush()\n-    static final int RAW  = 1;  \/\/ introduces raw byte format\n-    static final int BASE = 2;  \/\/ base for codes found in lookup table\n-    static final String codeTable =\n-        \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ ,.!?\\\"'()\";\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/CompressConstants.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,110 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-import java.io.*;\n-\n-class CompressInputStream extends FilterInputStream\n-    implements CompressConstants\n-{\n-\n-    public CompressInputStream(InputStream in) {\n-        super(in);\n-    }\n-\n-    \/\/ buffer of unpacked 6-bit codes from last 32-word read\n-    int buf[] = new int[5];\n-\n-    \/\/ position of next code to read in buffer (5 == end of buffer)\n-    int bufPos = 5;\n-\n-    public int read() throws IOException {\n-        try {\n-            int code;\n-            do {\n-                code = readCode();\n-            } while (code == NOP);      \/\/ ignore NOP codes\n-\n-            if (code >= BASE)\n-                return codeTable.charAt(code - BASE);\n-            else if (code == RAW) {\n-                int high = readCode();\n-                int low = readCode();\n-                return (high << 4) | low;\n-            } else\n-                throw new IOException(\"unknown compression code: \" + code);\n-        } catch (EOFException e) {\n-            return -1;\n-        }\n-    }\n-\n-    public int read(byte b[], int off, int len) throws IOException {\n-        if (len <= 0) {\n-            return 0;\n-        }\n-\n-        int c = read();\n-        if (c == -1) {\n-            return -1;\n-        }\n-        b[off] = (byte)c;\n-\n-        int i = 1;\n-\/*****\n-        try {\n-            for (; i < len ; i++) {\n-                c = read();\n-                if (c == -1) {\n-                    break;\n-                }\n-                if (b != null) {\n-                    b[off + i] = (byte)c;\n-                }\n-            }\n-        } catch (IOException ee) {\n-        }\n- *****\/\n-        return i;\n-    }\n-\n-    private int readCode() throws IOException {\n-        if (bufPos == 5) {\n-            int b1 = in.read();\n-            int b2 = in.read();\n-            int b3 = in.read();\n-            int b4 = in.read();\n-            if ((b1 | b2 | b3 | b4) < 0)\n-                throw new EOFException();\n-            int pack = (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;\n-            buf[0] = (pack >>> 24) & 0x3F;\n-            buf[1] = (pack >>> 18) & 0x3F;\n-            buf[2] = (pack >>> 12) & 0x3F;\n-            buf[3] = (pack >>>  6) & 0x3F;\n-            buf[4] = (pack >>>  0) & 0x3F;\n-            bufPos = 0;\n-        }\n-        return buf[bufPos++];\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/CompressInputStream.java","additions":0,"deletions":110,"binary":false,"changes":110,"status":"deleted"},{"patch":"@@ -1,84 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-import java.io.*;\n-\n-class CompressOutputStream extends FilterOutputStream\n-    implements CompressConstants\n-{\n-\n-    public CompressOutputStream(OutputStream out) {\n-        super(out);\n-    }\n-\n-    \/\/ buffer of 6-bit codes to pack into next 32-bit word\n-    int buf[] = new int[5];\n-\n-    \/\/ number of valid codes pending in buffer\n-    int bufPos = 0;\n-\n-    public void write(int b) throws IOException {\n-        b &= 0xFF;                      \/\/ force argument to a byte\n-\n-        int pos = codeTable.indexOf((char)b);\n-        if (pos != -1)\n-            writeCode(BASE + pos);\n-        else {\n-            writeCode(RAW);\n-            writeCode(b >> 4);\n-            writeCode(b & 0xF);\n-        }\n-    }\n-\n-    public void write(byte b[], int off, int len) throws IOException {\n-        \/*\n-         * This is quite an inefficient implementation, because it has to\n-         * call the other write method for every byte in the array.  It\n-         * could be optimized for performance by doing all the processing\n-         * in this method.\n-         *\/\n-        for (int i = 0; i < len; i++)\n-            write(b[off + i]);\n-    }\n-\n-    public void flush() throws IOException {\n-        while (bufPos > 0)\n-            writeCode(NOP);\n-    }\n-\n-    private void writeCode(int c) throws IOException {\n-        buf[bufPos++] = c;\n-        if (bufPos == 5) {      \/\/ write next word when we have 5 codes\n-            int pack = (buf[0] << 24) | (buf[1] << 18) | (buf[2] << 12) |\n-                       (buf[3] << 6) | buf[4];\n-            out.write((pack >>> 24) & 0xFF);\n-            out.write((pack >>> 16) & 0xFF);\n-            out.write((pack >>> 8)  & 0xFF);\n-            out.write((pack >>> 0)  & 0xFF);\n-            bufPos = 0;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/CompressOutputStream.java","additions":0,"deletions":84,"binary":false,"changes":84,"status":"deleted"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-import java.rmi.*;\n-\n-public interface Echo extends Remote {\n-\n-    byte[] echoNot(byte[] data) throws RemoteException;\n-    void shutdown() throws Exception;\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/Echo.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -1,141 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2012, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.server.*;\n-import java.security.CodeSource;\n-import java.net.URL;\n-\n-public class EchoImpl\n-    extends Activatable\n-    implements Echo, Runnable\n-{\n-    private static final byte[] pattern = { (byte) 'A' };\n-\n-    \/**\n-     * Initialization constructor.\n-     *\/\n-    public EchoImpl(String protocol)\n-        throws ActivationException, RemoteException\n-    {\n-        super(null, makeMarshalledObject(protocol), false, 0,\n-              new MultiSocketFactory.ClientFactory(protocol, pattern),\n-              new MultiSocketFactory.ServerFactory(protocol, pattern));\n-    }\n-\n-    \/**\n-     * Activation constructor.\n-     *\/\n-    public EchoImpl(ActivationID id, MarshalledObject obj)\n-        throws RemoteException\n-    {\n-        super(id, 0,\n-              new MultiSocketFactory.ClientFactory(getProtocol(obj), pattern),\n-              new MultiSocketFactory.ServerFactory(getProtocol(obj), pattern));\n-    }\n-\n-    private static MarshalledObject makeMarshalledObject(String protocol) {\n-        MarshalledObject obj = null;\n-        try {\n-            obj = new MarshalledObject(protocol);\n-        } catch (Exception willNotHappen) {\n-        }\n-\n-        return obj;\n-    }\n-\n-    private static String getProtocol(MarshalledObject obj) {\n-        String protocol = \"\";\n-        try {\n-            protocol = (String) obj.get();\n-        } catch (Exception willNotHappen) {\n-        }\n-\n-        return protocol;\n-    }\n-\n-    public byte[] echoNot(byte[] data) {\n-        byte[] result = new byte[data.length];\n-        for (int i = 0; i < data.length; i++)\n-            result[i] = (byte) ~data[i];\n-        return result;\n-    }\n-\n-    \/**\n-     * Spawns a thread to deactivate the object.\n-     *\/\n-    public void shutdown() throws Exception\n-    {\n-        (new Thread(this,\"Echo.shutdown\")).start();\n-    }\n-\n-    \/**\n-     * Thread to deactivate object. First attempts to make object\n-     * inactive (via the inactive method).  If that fails (the\n-     * object may still have pending\/executing calls), then\n-     * unexport the object forcibly.\n-     *\/\n-    public void run()\n-    {\n-        ActivationLibrary.deactivate(this, getID());\n-    }\n-\n-    public static void main(String[] args) {\n-        \/*\n-         * The following line is required with the JDK 1.2 VM so that the\n-         * VM can exit gracefully when this test completes.  Otherwise, the\n-         * conservative garbage collector will find a handle to the server\n-         * object on the native stack and not clear the weak reference to\n-         * it in the RMI runtime's object table.\n-         *\/\n-        Object dummy = new Object();\n-\n-        System.setSecurityManager(new RMISecurityManager());\n-\n-        try {\n-            String protocol = \"\";\n-            if (args.length >= 1)\n-                protocol = args[0];\n-\n-            System.out.println(\"EchoServer: creating remote object\");\n-            ActivationGroupDesc groupDesc =\n-                new ActivationGroupDesc(null, null);\n-            ActivationSystem system = ActivationGroup.getSystem();\n-            ActivationGroupID groupID = system.registerGroup(groupDesc);\n-            ActivationGroup.createGroup(groupID, groupDesc, 0);\n-\n-            EchoImpl impl = new EchoImpl(protocol);\n-            int registryPort = Integer.parseInt(System.getProperty(\"rmi.registry.port\"));\n-            System.out.println(\"EchoServer: binding in registry on port:\" + registryPort);\n-            Naming.rebind(\"\/\/:\" + registryPort +\n-                          \"\/EchoServer\", impl);\n-            System.out.println(\"EchoServer ready.\");\n-        } catch (Exception e) {\n-            System.err.println(\"EXCEPTION OCCURRED:\");\n-            e.printStackTrace();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/EchoImpl.java","additions":0,"deletions":141,"binary":false,"changes":141,"status":"deleted"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/\/ Stub class generated by rmic, do not edit.\n-\/\/ Contents subject to change without notice.\n-\n-public final class EchoImpl_Stub\n-    extends java.rmi.server.RemoteStub\n-    implements Echo, java.rmi.Remote\n-{\n-    private static final long serialVersionUID = 2;\n-\n-    private static java.lang.reflect.Method $method_echoNot_0;\n-    private static java.lang.reflect.Method $method_shutdown_1;\n-\n-    static {\n-        try {\n-            $method_echoNot_0 = Echo.class.getMethod(\"echoNot\", new java.lang.Class[] {byte[].class});\n-            $method_shutdown_1 = Echo.class.getMethod(\"shutdown\", new java.lang.Class[] {});\n-        } catch (java.lang.NoSuchMethodException e) {\n-            throw new java.lang.NoSuchMethodError(\n-                \"stub class initialization failed\");\n-        }\n-    }\n-\n-    \/\/ constructors\n-    public EchoImpl_Stub(java.rmi.server.RemoteRef ref) {\n-        super(ref);\n-    }\n-\n-    \/\/ methods from remote interfaces\n-\n-    \/\/ implementation of echoNot(byte[])\n-    public byte[] echoNot(byte[] $param_arrayOf_byte_1)\n-        throws java.rmi.RemoteException\n-    {\n-        try {\n-            Object $result = ref.invoke(this, $method_echoNot_0, new java.lang.Object[] {$param_arrayOf_byte_1}, -4295721514897591756L);\n-            return ((byte[]) $result);\n-        } catch (java.lang.RuntimeException e) {\n-            throw e;\n-        } catch (java.rmi.RemoteException e) {\n-            throw e;\n-        } catch (java.lang.Exception e) {\n-            throw new java.rmi.UnexpectedException(\"undeclared checked exception\", e);\n-        }\n-    }\n-\n-    \/\/ implementation of shutdown()\n-    public void shutdown()\n-        throws java.lang.Exception\n-    {\n-        ref.invoke(this, $method_shutdown_1, null, -7207851917985848402L);\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/EchoImpl_Stub.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"},{"patch":"@@ -1,226 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- *\/\n-\n-import java.io.*;\n-import java.net.*;\n-import java.rmi.*;\n-import java.rmi.server.*;\n-import java.util.zip.*;\n-\n-\n-public class MultiSocketFactory  {\n-\n-    private static RMISocketFactory def =\n-        RMISocketFactory.getDefaultSocketFactory();\n-\n-\n-    public static class ServerFactory\n-        implements RMIServerSocketFactory, Serializable\n-    {\n-\n-        private String protocol;\n-        private byte[] data;\n-\n-        public ServerFactory(String protocol, byte[] data) {\n-            this.protocol = protocol;\n-            this.data = data;\n-        }\n-\n-        public ServerSocket createServerSocket(int port) throws IOException\n-        {\n-            if (protocol.equals(\"compress\")) {\n-                return new CompressServerSocket(port);\n-\n-            } else if (protocol.equals(\"xor\")) {\n-                if (data == null || data.length != 1)\n-                    throw new IOException(\"invalid argument for XOR protocol\");\n-                return new XorServerSocket(port, data[0]);\n-\n-            }\n-\n-            return def.createServerSocket(port);\n-        }\n-    }\n-\n-    public static class ClientFactory\n-        implements RMIClientSocketFactory, Serializable\n-    {\n-\n-        private String protocol;\n-        private byte[] data;\n-\n-        public ClientFactory(String protocol, byte[] data) {\n-            this.protocol = protocol;\n-            this.data = data;\n-        }\n-\n-        public Socket createSocket(String host, int port)\n-            throws IOException\n-        {\n-            if (protocol.equals(\"compress\")) {\n-                return new CompressSocket(host, port);\n-\n-            } else if (protocol.equals(\"xor\")) {\n-                if (data == null || data.length != 1)\n-                    throw new IOException(\"invalid argument for XOR protocol\");\n-                return new XorSocket(host, port, data[0]);\n-\n-            }\n-\n-            return def.createSocket(host, port);\n-        }\n-    }\n-\n-    static class CompressSocket extends Socket {\n-        private InputStream in;\n-        private OutputStream out;\n-        public CompressSocket() { super(); }\n-        public CompressSocket(String host, int port) throws IOException {\n-            super(host, port);\n-        }\n-        public InputStream getInputStream() throws IOException {\n-            if (in == null) {\n-                in = new CompressInputStream(super.getInputStream());\n-            }\n-            return in;\n-        }\n-        public OutputStream getOutputStream() throws IOException {\n-            if (out == null) {\n-                out = new CompressOutputStream(super.getOutputStream());\n-            }\n-            return out;\n-        }\n-    }\n-\n-    static class CompressServerSocket extends ServerSocket {\n-        public CompressServerSocket(int port) throws IOException {\n-            super(port);\n-        }\n-        public Socket accept() throws IOException {\n-            Socket s = new CompressSocket();\n-            implAccept(s);\n-            return s;\n-        }\n-    }\n-\n-    static class XorSocket extends Socket {\n-        private byte pattern;\n-        private InputStream in;\n-        private OutputStream out;\n-        public XorSocket(byte pattern) { super(); this.pattern = pattern; }\n-        public XorSocket(String host, int port, byte pattern)\n-            throws IOException\n-        {\n-            super(host, port);\n-            this.pattern = pattern;\n-        }\n-        public InputStream getInputStream() throws IOException {\n-            if (in == null) {\n-                in = new XorInputStream(super.getInputStream(), pattern);\n-            }\n-            return in;\n-        }\n-        public OutputStream getOutputStream() throws IOException {\n-            if (out == null) {\n-                out = new XorOutputStream(super.getOutputStream(), pattern);\n-            }\n-            return out;\n-        }\n-    }\n-\n-    static class XorServerSocket extends ServerSocket {\n-        private byte pattern;\n-        public XorServerSocket(int port, byte pattern) throws IOException {\n-            super(port);\n-            this.pattern = pattern;\n-        }\n-        public Socket accept() throws IOException {\n-            Socket s = new XorSocket(pattern);\n-            implAccept(s);\n-            return s;\n-        }\n-    }\n-\n-    static class XorOutputStream extends FilterOutputStream {\n-        private byte pattern;\n-        public XorOutputStream(OutputStream out, byte pattern) {\n-            super(out);\n-            this.pattern = pattern;\n-        }\n-        public void write(int b) throws IOException {\n-            out.write(b ^ pattern);\n-            out.flush();\n-        }\n-        public void write(byte b[], int off, int len) throws IOException {\n-            for (int i = 0; i < len; i++)\n-                write(b[off + i]);\n-        }\n-    }\n-\n-    static class XorInputStream extends FilterInputStream {\n-        private byte pattern;\n-        public XorInputStream(InputStream in, byte pattern) {\n-            super(in);\n-            this.pattern = pattern;\n-        }\n-        public int read() throws IOException {\n-            int b = in.read();\n-\/\/          System.out.print(\"BEFORE: \" + Integer.toHexString(b));\n-            if (b != -1)\n-                b = (b ^ pattern) & 0xFF;\n-\/\/          System.out.println(\"\\tAFTER: \" + Integer.toHexString(b));\n-            return b;\n-        }\n-        public int read(byte b[], int off, int len) throws IOException {\n-            if (len <= 0) {\n-                return 0;\n-            }\n-\n-            int c = read();\n-            if (c == -1) {\n-                return -1;\n-            }\n-            b[off] = (byte)c;\n-\n-            int i = 1;\n-\/*****\n-            try {\n-                for (; i < len ; i++) {\n-                    c = read();\n-                    if (c == -1) {\n-                        break;\n-                    }\n-                    if (b != null) {\n-                        b[off + i] = (byte)c;\n-                    }\n-                }\n-            } catch (IOException ee) {\n-            }\n-*****\/\n-            return i;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/MultiSocketFactory.java","additions":0,"deletions":226,"binary":false,"changes":226,"status":"deleted"},{"patch":"@@ -1,173 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n- * @bug 4115696\n- * @key intermittent\n- * @summary synopsis: cannot use socket factories with Activatable objects\n- * @author Ann Wollrath\n- *\n- * @library ..\/..\/..\/..\/testlibrary\n- * @modules java.rmi\/sun.rmi.registry\n- *          java.rmi\/sun.rmi.server\n- *          java.rmi\/sun.rmi.transport\n- *          java.rmi\/sun.rmi.transport.tcp\n- *          java.base\/sun.nio.ch\n- * @build TestLibrary Echo EchoImpl EchoImpl_Stub RMIDSelectorProvider\n- * @run main\/othervm\/policy=security.policy\/timeout=360 UseCustomSocketFactory\n- *\/\n-\n-import java.io.*;\n-import java.net.MalformedURLException;\n-import java.rmi.*;\n-import java.rmi.registry.*;\n-\n-public class UseCustomSocketFactory {\n-    static int registryPort = -1;\n-\n-    static String[] protocol = new String[] { \"\", \"compress\", \"xor\" };\n-\n-    public static void main(String[] args) {\n-\n-        System.out.println(\"\\nRegression test for bug 4115696\\n\");\n-\n-        TestLibrary.suggestSecurityManager(\"java.rmi.RMISecurityManager\");\n-\n-        try {\n-            Registry reg = LocateRegistry.createRegistry(0);\n-            registryPort = TestLibrary.getRegistryPort(reg);\n-        } catch (RemoteException e) {\n-            TestLibrary.bomb(\"creating registry\", e);\n-        }\n-\n-        RMID rmid = null;\n-\n-        try {\n-            rmid = RMID.createRMIDOnEphemeralPort();\n-            rmid.addArguments(new String[] {\n-                \"-C-Djava.security.policy=\" +\n-                    TestParams.defaultGroupPolicy +\n-                    \" -C-Djava.security.manager=java.rmi.RMISecurityManager \"});\n-            rmid.start();\n-\n-            Echo[] echo = spawnAndTest(rmid.getPort());\n-            reactivateAndTest(echo);\n-        } catch (IOException e) {\n-            TestLibrary.bomb(\"creating rmid\", e);\n-        } finally {\n-            if (rmid != null)\n-                rmid.destroy();\n-        }\n-    }\n-\n-    private static Echo[] spawnAndTest(int rmidPort) {\n-\n-        System.err.println(\"\\nCreate Test-->\");\n-\n-        Echo[] echo = new Echo[protocol.length];\n-\n-        for (int i = 0; i < protocol.length; i++) {\n-            JavaVM serverVM = new JavaVM(\"EchoImpl\",\n-                                         \"-Djava.security.manager=allow\" +\n-                                         \" -Djava.security.policy=\" +\n-                                         TestParams.defaultPolicy +\n-                                         \" -Drmi.registry.port=\" +\n-                                         registryPort +\n-                                         \" -Djava.rmi.activation.port=\" +\n-                                         rmidPort,\n-                                         protocol[i]);\n-\n-            System.err.println(\"\\nusing protocol: \" +\n-                    (\"\".equals(protocol[i]) ? \"none\" : protocol[i]));\n-\n-            try {\n-                \/* spawn VM for EchoServer *\/\n-                serverVM.start();\n-\n-                \/* lookup server *\/\n-                echo[i] = null;\n-                \/\/ 24 seconds timeout\n-                long stopTime = System.currentTimeMillis() + 24000;\n-                do {\n-                    try {\n-                        echo[i] = (Echo) Naming.lookup(\"\/\/:\" + registryPort +\n-                                                       \"\/EchoServer\");\n-                        break;\n-                    } catch (NotBoundException e) {\n-                        try {\n-                            Thread.sleep(200);\n-                        } catch (InterruptedException ignore) {\n-                        }\n-                    }\n-                } while (System.currentTimeMillis() < stopTime);\n-\n-                if (echo[i] == null)\n-                    TestLibrary.bomb(\"server not bound in 120 tries\", null);\n-\n-                \/* invoke remote method and print result*\/\n-                System.err.println(\"Bound to \" + echo[i]);\n-                byte[] data = (\"Greetings, citizen \" +\n-                               System.getProperty(\"user.name\") + \"!\"). getBytes();\n-                byte[] result = echo[i].echoNot(data);\n-                for (int j = 0; j < result.length; j++)\n-                    result[j] = (byte) ~result[j];\n-                System.err.println(\"Result: \" + new String(result));\n-                echo[i].shutdown();\n-\n-            } catch (Exception e) {\n-                TestLibrary.bomb(\"test failed\", e);\n-\n-            } finally {\n-                serverVM.destroy();\n-                try {\n-                    Naming.unbind(\"\/\/:\" + registryPort + \"\/EchoServer\");\n-                } catch (RemoteException | NotBoundException | MalformedURLException e) {\n-                    TestLibrary.bomb(\"unbinding EchoServer\", e);\n-                }\n-            }\n-        }\n-        return echo;\n-    }\n-\n-\n-    private static void reactivateAndTest(Echo[] echo) {\n-\n-        System.err.println(\"\\nReactivate Test-->\");\n-\n-        for (int i = 0; i < echo.length; i++) {\n-            try {\n-                System.err.println(\"\\nusing protocol: \" +\n-                           (\"\".equals(protocol[i]) ? \"none\" : protocol[i]));\n-                byte[] data = (\"Greetings, citizen \" +\n-                               System.getProperty(\"user.name\") + \"!\").getBytes();\n-                byte[] result = echo[i].echoNot(data);\n-                for (int j = 0; j < result.length; j++)\n-                    result[j] = (byte) ~result[j];\n-                System.err.println(\"Result: \" + new String(result));\n-                echo[i].shutdown();\n-            } catch (Exception e) {\n-                TestLibrary.bomb(\"activating EchoServer for protocol \" + protocol[i], e);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/UseCustomSocketFactory.java","additions":0,"deletions":173,"binary":false,"changes":173,"status":"deleted"},{"patch":"@@ -1,9 +0,0 @@\n-\/*\n- * security policy used by activation groups\n- *\/\n-\n-grant {\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-};\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/group.security.policy","additions":0,"deletions":9,"binary":false,"changes":9,"status":"deleted"},{"patch":"@@ -1,7 +0,0 @@\n-grant {\n-    permission java.lang.RuntimePermission \"selectorProvider\";\n-    permission java.lang.RuntimePermission \"accessClassInPackage.sun.nio.ch\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", \"read\";\n-    permission java.util.PropertyPermission \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\", \"read\";\n-    permission java.net.SocketPermission \"*:1024-\", \"listen,resolve,connect,accept\";\n-};\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/rmid.security.policy","additions":0,"deletions":7,"binary":false,"changes":7,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * security policy used by the test process\n- *\/\n-\n-grant {\n-  \/\/ property specifically accessed by this test\n-  permission java.util.PropertyPermission \"user.name\", \"read\";\n-\n-  \/\/ standard test activation permissions\n-  permission java.io.FilePermission \"..${\/}..${\/}test.props\", \"read\";\n-\n-  \/\/ test needs to cleanup rmid's log.\n-  permission java.io.FilePermission \".${\/}log\", \"read,write,delete\";\n-  permission java.io.FilePermission \".${\/}log${\/}-\", \"read,write,delete\";\n-\n-  \/\/ test needs to use java to exec an rmid\n-  permission java.io.FilePermission \"${java.home}${\/}bin${\/}java\", \"execute\";\n-\n-  \/\/ test uses these permissions to propagate security values to rmid\n-  permission java.util.PropertyPermission \"java.security.policy\", \"read\";\n-  permission java.util.PropertyPermission \"java.security.manager\", \"read\";\n-\n-  \/\/ used by TestLibrary to get the RMI Registry port\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.registry\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.server\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport.proxy\";\n-  permission java.lang.RuntimePermission \"accessClassInPackage.sun.rmi.transport.tcp\";\n-\n-  \/\/ used by TestLibrary to determine test environment \n-  permission java.util.PropertyPermission \"test.*\", \"read\";\n-  permission java.util.PropertyPermission \"user.dir\", \"read\";\n-  permission java.util.PropertyPermission \"java.home\", \"read\";\n-\n-  permission java.util.PropertyPermission \"rmi.registry.port\", \"read\";\n-  permission java.util.PropertyPermission \"java.rmi.activation.port\", \"write\";\n-\n-  \/\/ required for test to create an ActivationGroup\n-  permission java.lang.RuntimePermission \"setFactory\";\n-\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n-  permission java.net.SocketPermission \"*:1024-\", \"connect,accept,listen\";\n-};\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/activatable\/security.policy","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -32,1 +32,1 @@\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n+  \/\/ test needs to communicate with objects on arbitrary ports\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/registry\/security.policy","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n- * @build TestLibrary RMID JavaVM Echo EchoImpl EchoImpl_Stub\n+ * @build TestLibrary JavaVM Echo EchoImpl EchoImpl_Stub\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/unicast\/UseCustomSocketFactory.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n+  \/\/ test needs to communicate with objects on arbitrary ports\n","filename":"test\/jdk\/java\/rmi\/server\/RMISocketFactory\/useSocketFactory\/unicast\/security.policy","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n- * See also test\/java\/rmi\/activation\/Activatable\/notSerializable.\n","filename":"test\/jdk\/java\/rmi\/server\/RemoteObject\/unrecognizedRefType\/UnrecognizedRefType.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6,1 +6,1 @@\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n+  \/\/ test needs to communicate with objects on arbitrary ports\n","filename":"test\/jdk\/java\/rmi\/server\/clientStackTrace\/security.policy","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- *\n- *\/\n-\n-import java.io.File;\n-import java.rmi.Naming;\n-import java.rmi.NoSuchObjectException;\n-import java.rmi.NotBoundException;\n-import java.rmi.Remote;\n-import java.rmi.activation.Activatable;\n-import java.rmi.activation.ActivationID;\n-import java.rmi.activation.ActivationSystem;\n-import java.rmi.registry.LocateRegistry;\n-\n-\/**\n- * Class of test utility\/library methods related to Activatable\n- * objects.\n- *\/\n-public class ActivationLibrary {\n-    private static void mesg(Object mesg) {\n-        System.err.println(\"ACTIVATION_LIBRARY: \" + mesg.toString());\n-    }\n-\n-    \/**\n-     * Deactivate an activated Activatable\n-     *\/\n-    public static void deactivate(Remote remote,\n-                                  ActivationID id) {\n-        final long POLLTIME_MS = 100L;\n-        final long DEACTIVATE_TIME_MS = 30_000L;\n-\n-        long startTime = System.currentTimeMillis();\n-        long deadline = TestLibrary.computeDeadline(startTime, DEACTIVATE_TIME_MS);\n-\n-        while (System.currentTimeMillis() < deadline) {\n-            try {\n-                if (Activatable.inactive(id) == true) {\n-                    mesg(\"inactive successful\");\n-                    return;\n-                } else {\n-                    Thread.sleep(POLLTIME_MS);\n-                }\n-            } catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                mesg(\"Thread interrupted while trying to deactivate activatable. Exiting deactivation\");\n-                return;\n-            } catch (Exception e) {\n-                try {\n-                    \/\/ forcibly unexport the object\n-                    mesg(\"Unexpected exception. Have to forcibly unexport the object.\" +\n-                         \" Exception was :\");\n-                    e.printStackTrace();\n-                    Activatable.unexportObject(remote, true);\n-                } catch (NoSuchObjectException ex) {\n-                }\n-                return;\n-            }\n-        }\n-\n-        mesg(\"unable to inactivate after \" +\n-            (System.currentTimeMillis() - startTime) + \"ms.\");\n-        mesg(\"unexporting object forcibly instead\");\n-\n-        try {\n-            Activatable.unexportObject(remote, true);\n-        } catch (NoSuchObjectException e) {\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/ActivationLibrary.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -191,34 +191,0 @@\n-    public int startAndGetPort() throws IOException {\n-        start0();\n-\n-        int port = -1;\n-        if (options.contains(\"java.nio.channels.spi.SelectorProvider=RMIDSelectorProvider\")) {\n-            \/\/ Obtain the server socket channel's ephemeral port number of the\n-            \/\/ child rmid process.\n-            BufferedReader reader = new BufferedReader(\n-                    new InputStreamReader(vm.getInputStream()));\n-            String s;\n-            while ((s = reader.readLine()) != null) {\n-                System.out.println(s);\n-                int i = s.indexOf(RMID.EPHEMERAL_MSG);\n-                if (i != -1) {\n-                    String v = s.substring(RMID.EPHEMERAL_MSG.length());\n-                    port = Integer.valueOf(v);\n-                    break;\n-                }\n-            }\n-            if (port == -1) {\n-                \/\/ something failed\n-                reader = new BufferedReader(new InputStreamReader(vm.getErrorStream()));\n-                while ((s = reader.readLine()) != null)\n-                    System.err.println(s);\n-            }\n-        }\n-\n-        \/* output from the exec'ed process may optionally be captured. *\/\n-        outPipe = StreamPipe.plugTogether(vm.getInputStream(), this.outputStream);\n-        errPipe = StreamPipe.plugTogether(vm.getErrorStream(), this.errorStream);\n-\n-        return port;\n-    }\n-\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/JavaVM.java","additions":1,"deletions":35,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -5,2 +5,2 @@\n-# Since many RMI regression tests spawn child VMs (either directly\n-# or through activation), special support is required for setting\n+# Since many RMI regression tests spawn child VMs,\n+# special support is required for setting\n@@ -12,1 +12,1 @@\n-# code that spawns VMs or instances of rmid.  See the example test.props\n+# code that spawns VMs.  See the example test.props\n@@ -35,4 +35,0 @@\n-#   rmid.jcov.args are the jcov options that should be added as\n-#                  arguments to rmid command line; effectively, these\n-#                  are identical to jcov.options but each option is\n-#                  prefaced with '-C'\n@@ -45,2 +41,0 @@\n-rmid.jcov.args=-C-Xrunjcov:file=\/files\/rmi.jcov -C-Xms256m -C-Xmx256m -C-XX:+UseUnsupportedDeprecatedJVMPI -C-XX:+EnableJVMPIInstructionStartEvent -C-XX:-UseFastEmptyMethods -C-XX:-UseFastAccessorMethods\n-\n@@ -62,1 +56,0 @@\n-        -include=java.rmi.activation.* \\\n@@ -75,1 +68,0 @@\n-        -exclude=com.sun.rmi.rmid.* \\\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/README.jcov","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1,506 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.rmi.*;\n-import java.rmi.activation.*;\n-import java.rmi.registry.*;\n-import java.time.LocalTime;\n-import java.util.concurrent.TimeoutException;\n-\n-\/**\n- * Utility class that creates an instance of rmid with a policy\n- * file of name <code>TestParams.defaultPolicy<\/code>.\n- *\n- * Activation groups should run with the same security manager as the\n- * test.\n- *\/\n-public class RMID extends JavaVM {\n-\n-    \/\/ TODO: adjust these based on the timeout factor\n-    \/\/ such as jcov.sleep.multiplier; see start(long) method.\n-    \/\/ Also consider the test.timeout.factor property (a float).\n-    private static final long TIMEOUT_SHUTDOWN_MS = 60_000L;\n-    private static final long TIMEOUT_DESTROY_MS  = 10_000L;\n-    private static final long STARTTIME_MS        = 15_000L;\n-    private static final long POLLTIME_MS         = 100L;\n-    private static final long TIMEOUT_BASE        = 240_000L;\n-\n-    \/\/ when restart rmid, it may take more time than usual because of\n-    \/\/ \"port in use\" by a possible interloper (check JDK-8168975),\n-    \/\/ so need to set a longer timeout than STARTTIME_MS for restart.\n-    private static final long RESTART_TIMEOUT = (long)(TIMEOUT_BASE * 0.9);\n-    \/\/ Same reason to inheritedChannel in RMIDSelectorProvider.\n-    \/\/ Put it here rather than in RMIDSelectorProvider to adjust\n-    \/\/ both timeout values together.\n-    private static long inheritedChannelTimeout;\n-\n-    private static final String SYSTEM_NAME = ActivationSystem.class.getName();\n-        \/\/ \"java.rmi.activation.ActivationSystem\"\n-\n-    public static String MANAGER_OPTION=\"-Djava.security.manager=\";\n-\n-    \/**\n-     * Test port for rmid.\n-     *\n-     * May initially be 0, which means that the child rmid process will choose\n-     * an ephemeral port and report it back to the parent process. This field\n-     * will then be set to the child rmid's ephemeral port value.\n-     *\/\n-    private volatile int port;\n-    \/\/private final boolean ephemeralPort\n-\n-    \/** Initial log name *\/\n-    protected static String log = \"log\";\n-    \/** rmid's logfile directory; currently must be \".\" *\/\n-    protected static String LOGDIR = \".\";\n-\n-    \/** The output message from the child rmid process that directly precedes\n-     * the ephemeral port number.*\/\n-    public static final String EPHEMERAL_MSG = \"RmidSelectorProvider-listening-On:\";\n-\n-    private static void mesg(Object mesg) {\n-        System.err.println(\"RMID: \" + mesg.toString());\n-    }\n-\n-    \/** make test options and arguments *\/\n-    private static String makeOptions(int port, boolean debugExec,\n-                                      boolean enableSelectorProvider) {\n-\n-        String options = \" -Dsun.rmi.server.activation.debugExec=\" +\n-            debugExec;\n-        \/\/ +\n-        \/\/\" -Djava.compiler= \";\n-\n-        \/\/ if test params set, want to propagate them\n-        if (!TestParams.testSrc.equals(\"\")) {\n-            options += \" -Dtest.src=\" + TestParams.testSrc + \" \";\n-        }\n-        \/\/if (!TestParams.testClasses.equals(\"\")) {\n-        \/\/    options += \" -Dtest.classes=\" + TestParams.testClasses + \" \";\n-        \/\/}\n-        options += \" -Dtest.classes=\" + TestParams.testClasses \/\/;\n-         +\n-         \" -Djava.rmi.server.logLevel=v \";\n-\n-        \/\/ +\n-        \/\/ \" -Djava.security.debug=all \";\n-\n-        \/\/ Set execTimeout to 60 sec (default is 30 sec)\n-        \/\/ to avoid spurious timeouts on slow machines.\n-        options += \" -Dsun.rmi.activation.execTimeout=60000\";\n-\n-        \/\/ It's important to set handshakeTimeout to small value, for example\n-        \/\/ 5 sec (default is 60 sec) to avoid wasting too much time when\n-        \/\/ calling lookupSystem(port) in restart(), because\n-        \/\/   1. If use default value of this option, it will take about 2 minutes\n-        \/\/     to finish lookupSystem(port) in 2 loops in restart();\n-        \/\/   2. If set this option as 5 sec then lookupSystem(port) will return\n-        \/\/     very quickly.\n-        options += \" -Dsun.rmi.transport.tcp.handshakeTimeout=5000\";\n-\n-        if (port == 0 || enableSelectorProvider) {\n-            \/\/ Ephemeral port, so have the rmid child process create the\n-            \/\/ server socket channel and report its port number, over stdin.\n-            options += \" -classpath \" + TestParams.testClassPath;\n-            options += \" --add-exports=java.base\/sun.nio.ch=ALL-UNNAMED\";\n-            options += \" -Djava.nio.channels.spi.SelectorProvider=RMIDSelectorProvider\";\n-            options += \" -Dtest.java.rmi.testlibrary.RMIDSelectorProvider.port=\" + port;\n-            options += \" -Dtest.java.rmi.testlibrary.RMIDSelectorProvider.timeout=\"\n-                        + inheritedChannelTimeout;\n-\n-            \/\/ Disable redirection of System.err to \/tmp\n-            options += \" -Dsun.rmi.server.activation.disableErrRedirect=true\";\n-        }\n-\n-        return options;\n-    }\n-\n-    private static String makeArgs() {\n-        return makeArgs(false, 0);\n-    }\n-\n-    private static String makeArgs(boolean includePortArg, int port) {\n-        \/\/ getAbsolutePath requires permission to read user.dir\n-        String args =\n-            \" -log \" + (new File(LOGDIR, log)).getAbsolutePath();\n-\n-        \/\/ 0 = ephemeral port, do not include an explicit port number\n-        if (includePortArg && port != 0) {\n-            args += \" -port \" + port;\n-        }\n-\n-        \/\/ +\n-        \/\/      \" -C-Djava.compiler= \";\n-\n-        \/\/ if test params set, want to propagate them\n-        if (!TestParams.testSrc.equals(\"\")) {\n-            args += \" -C-Dtest.src=\" + TestParams.testSrc;\n-        }\n-        if (!TestParams.testClasses.equals(\"\")) {\n-            args += \" -C-Dtest.classes=\" + TestParams.testClasses;\n-        }\n-\n-        if (!TestParams.testJavaOpts.equals(\"\")) {\n-            for (String a : TestParams.testJavaOpts.split(\" +\")) {\n-                args += \" -C\" + a;\n-            }\n-        }\n-\n-        if (!TestParams.testVmOpts.equals(\"\")) {\n-            for (String a : TestParams.testVmOpts.split(\" +\")) {\n-                args += \" -C\" + a;\n-            }\n-        }\n-\n-        args += \" -C-Djava.rmi.server.useCodebaseOnly=false \";\n-\n-        args += \" \" + getCodeCoverageArgs();\n-        return args;\n-    }\n-\n-    \/**\n-     * Routine that creates an rmid that will run with or without a\n-     * policy file.\n-     *\/\n-    public static RMID createRMID() {\n-        return createRMID(System.out, System.err, true, true,\n-                          TestLibrary.getUnusedRandomPort());\n-    }\n-\n-    public static RMID createRMID(OutputStream out, OutputStream err,\n-                                  boolean debugExec)\n-    {\n-        return createRMID(out, err, debugExec, true,\n-                          TestLibrary.getUnusedRandomPort());\n-    }\n-\n-    public static RMID createRMID(OutputStream out, OutputStream err,\n-                                  boolean debugExec, boolean includePortArg,\n-                                  int port)\n-    {\n-        return createRMIDWithOptions(out, err, debugExec, includePortArg, port, \"\");\n-    }\n-\n-    \/**\n-     * Create a RMID on a specified port capturing stdout and stderr\n-     * with additional command line options and whether to print out\n-     * debugging information that is used for spawning activation groups.\n-     *\n-     * @param out the OutputStream where the normal output of the\n-     *            rmid subprocess goes\n-     * @param err the OutputStream where the error output of the\n-     *            rmid subprocess goes\n-     * @param debugExec whether to print out debugging information\n-     * @param includePortArg whether to include port argument\n-     * @param port the port on which rmid accepts requests\n-     * @param additionalOptions additional command line options\n-     * @return a RMID instance\n-     *\/\n-    public static RMID createRMIDWithOptions(OutputStream out, OutputStream err,\n-                                  boolean debugExec, boolean includePortArg,\n-                                  int port, String additionalOptions)\n-    {\n-        String options = makeOptions(port, debugExec, false);\n-        options += \" \" + additionalOptions;\n-        String args = makeArgs(includePortArg, port);\n-        RMID rmid = new RMID(\"sun.rmi.server.Activation\", options, args,\n-                             out, err, port);\n-        rmid.setPolicyFile(TestParams.defaultRmidPolicy);\n-\n-        return rmid;\n-    }\n-\n-    public static RMID createRMIDOnEphemeralPort() {\n-        return createRMID(System.out, System.err, true, false, 0);\n-    }\n-\n-    \/**\n-     * Create a RMID on an ephemeral port capturing stdout and stderr\n-     * with additional command line options.\n-     *\n-     * @param additionalOptions additional command line options\n-     * @return a RMID instance\n-     *\/\n-    public static RMID createRMIDOnEphemeralPortWithOptions(\n-                                            String additionalOptions) {\n-        return createRMIDWithOptions(System.out, System.err,\n-                                     true, false, 0, additionalOptions);\n-    }\n-\n-    public static RMID createRMIDOnEphemeralPort(OutputStream out,\n-                                                 OutputStream err,\n-                                                 boolean debugExec)\n-    {\n-        return createRMID(out, err, debugExec, false, 0);\n-    }\n-\n-\n-    \/**\n-     * Private constructor. RMID instances should be created\n-     * using the static factory methods.\n-     *\/\n-    private RMID(String classname, String options, String args,\n-                   OutputStream out, OutputStream err, int port)\n-    {\n-        super(classname, options, args, out, err);\n-        this.port = port;\n-        long waitTime = (long)(TIMEOUT_BASE * TestLibrary.getTimeoutFactor());\n-        inheritedChannelTimeout = (long)(waitTime * 0.8);\n-    }\n-\n-    \/**\n-     * Removes rmid's log file directory.\n-     *\/\n-    public static void removeLog() {\n-        File f = new File(LOGDIR, log);\n-\n-        if (f.exists()) {\n-            mesg(\"Removing rmid's old log file.\");\n-            String[] files = f.list();\n-\n-            if (files != null) {\n-                for (int i=0; i<files.length; i++) {\n-                    (new File(f, files[i])).delete();\n-                }\n-            }\n-\n-            if (! f.delete()) {\n-                mesg(\"Warning: unable to delete old log file.\");\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * This method is used for adding arguments to rmid (not its VM)\n-     * for passing as VM options to its child group VMs.\n-     * Returns the extra command line arguments required\n-     * to turn on jcov code coverage analysis for rmid child VMs.\n-     *\/\n-    protected static String getCodeCoverageArgs() {\n-        return TestLibrary.getExtraProperty(\"rmid.jcov.args\",\"\");\n-    }\n-\n-    \/**\n-     * Looks up the activation system in the registry on the given port,\n-     * returning its stub, or null if it's not present. This method differs from\n-     * ActivationGroup.getSystem() because this method looks on a specific port\n-     * instead of using the java.rmi.activation.port property like\n-     * ActivationGroup.getSystem() does. This method also returns null instead\n-     * of throwing exceptions.\n-     *\/\n-    public static ActivationSystem lookupSystem(int port) {\n-        try {\n-            return (ActivationSystem)LocateRegistry.getRegistry(port).lookup(SYSTEM_NAME);\n-        } catch (RemoteException | NotBoundException ex) {\n-            return null;\n-        }\n-    }\n-\n-    \/**\n-     * Starts rmid and waits up to the default timeout period\n-     * to confirm that it's running.\n-     *\/\n-    public void start() throws IOException {\n-        start(STARTTIME_MS);\n-    }\n-\n-    \/**\n-     * Starts rmid and waits up to the given timeout period\n-     * to confirm that it's running.\n-     *\/\n-    public void start(long waitTime) throws IOException {\n-\n-        \/\/ if rmid is already running, then the test will fail with\n-        \/\/ a well recognized exception (port already in use...).\n-\n-        mesg(\"Starting rmid on port \" + port + \", at \" + LocalTime.now());\n-        if (!options.contains(\"-Djava.security.manager\")) {\n-            options += \" -Djava.security.manager=allow\";\n-        }\n-        int p = super.startAndGetPort();\n-        if (p != -1)\n-            port = p;\n-        mesg(\"Started rmid on port \" + port + \", at \" + LocalTime.now());\n-\n-        \/\/ int slopFactor = 1;\n-        \/\/ try {\n-        \/\/     slopFactor = Integer.valueOf(\n-        \/\/         TestLibrary.getExtraProperty(\"jcov.sleep.multiplier\",\"1\"));\n-        \/\/ } catch (NumberFormatException ignore) {}\n-        \/\/ waitTime = waitTime * slopFactor;\n-\n-        long startTime = System.currentTimeMillis();\n-        long deadline = TestLibrary.computeDeadline(startTime, waitTime);\n-\n-        while (true) {\n-            try {\n-                Thread.sleep(POLLTIME_MS);\n-            } catch (InterruptedException ie) {\n-                Thread.currentThread().interrupt();\n-                mesg(\"Starting rmid interrupted, giving up at \" +\n-                    (System.currentTimeMillis() - startTime) + \"ms.\");\n-                return;\n-            }\n-\n-            try {\n-                int status = vm.exitValue();\n-                waitFor(TIMEOUT_SHUTDOWN_MS);\n-                TestLibrary.bomb(\"Rmid process exited with status \" + status + \" after \" +\n-                    (System.currentTimeMillis() - startTime) + \"ms.\");\n-            } catch (InterruptedException | TimeoutException e) {\n-                mesg(e);\n-            } catch (IllegalThreadStateException ignore) { }\n-\n-            \/\/ The rmid process is alive; check to see whether\n-            \/\/ it responds to a remote call.\n-\n-            mesg(\"looking up activation system, at \" + LocalTime.now());\n-            if (lookupSystem(port) != null) {\n-                \/*\n-                 * We need to set the java.rmi.activation.port value as the\n-                 * activation system will use the property to determine the\n-                 * port #.  The activation system will use this value if set.\n-                 * If it isn't set, the activation system will set it to an\n-                 * incorrect value.\n-                 *\/\n-                System.setProperty(\"java.rmi.activation.port\", Integer.toString(port));\n-                mesg(\"Started successfully after \" +\n-                    (System.currentTimeMillis() - startTime) + \"ms, at \" + LocalTime.now());\n-                return;\n-            }\n-\n-            mesg(\"after fail to looking up activation system, at \" + LocalTime.now());\n-            if (System.currentTimeMillis() > deadline) {\n-                TestLibrary.bomb(\"Failed to start rmid, giving up after \" +\n-                    (System.currentTimeMillis() - startTime) + \"ms.\", null);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Destroys rmid and restarts it. Note that this does NOT clean up\n-     * the log file, because it stores information about restartable\n-     * and activatable objects that must be carried over to the new\n-     * rmid instance.\n-     *\/\n-    public void restart() throws IOException {\n-        destroy();\n-        options = makeOptions(port, true, true);\n-        args = makeArgs();\n-\n-        start(RESTART_TIMEOUT);\n-    }\n-\n-    \/**\n-     * Ask rmid to shutdown gracefully using a remote method call.\n-     * catch any errors that might occur from rmid not being present\n-     * at time of shutdown invocation. If the remote call is\n-     * successful, wait for the process to terminate. Return true\n-     * if the process terminated, otherwise return false.\n-     *\/\n-    private boolean shutdown() throws InterruptedException {\n-        mesg(\"shutdown()\");\n-        long startTime = System.currentTimeMillis();\n-        ActivationSystem system = lookupSystem(port);\n-        if (system == null) {\n-            mesg(\"lookupSystem() returned null after \" +\n-                (System.currentTimeMillis() - startTime) + \"ms.\");\n-            return false;\n-        }\n-\n-        try {\n-            mesg(\"ActivationSystem.shutdown()\");\n-            system.shutdown();\n-        } catch (Exception e) {\n-            mesg(\"Caught exception from ActivationSystem.shutdown():\");\n-            e.printStackTrace();\n-        }\n-\n-        try {\n-            waitFor(TIMEOUT_SHUTDOWN_MS);\n-            mesg(\"Shutdown successful after \" +\n-                (System.currentTimeMillis() - startTime) + \"ms.\");\n-            return true;\n-        } catch (TimeoutException ex) {\n-            mesg(\"Shutdown timed out after \" +\n-                (System.currentTimeMillis() - startTime) + \"ms:\");\n-            ex.printStackTrace();\n-            return false;\n-        }\n-    }\n-\n-    \/**\n-     * Ask rmid to shutdown gracefully but then destroy the rmid\n-     * process if it does not exit by itself.  This method only works\n-     * if rmid is a child process of the current VM.\n-     *\/\n-    public void destroy() {\n-        if (vm == null) {\n-            throw new IllegalStateException(\"can't wait for RMID that isn't running\");\n-        }\n-\n-        long startTime = System.currentTimeMillis();\n-\n-        \/\/ First, attempt graceful shutdown of the activation system.\n-        try {\n-            if (! shutdown()) {\n-                \/\/ Graceful shutdown failed, use Process.destroy().\n-                mesg(\"Destroying RMID process.\");\n-                vm.destroy();\n-                try {\n-                    waitFor(TIMEOUT_DESTROY_MS);\n-                    mesg(\"Destroy successful after \" +\n-                        (System.currentTimeMillis() - startTime) + \"ms.\");\n-                } catch (TimeoutException ex) {\n-                    mesg(\"Destroy timed out, giving up after \" +\n-                        (System.currentTimeMillis() - startTime) + \"ms:\");\n-                    ex.printStackTrace();\n-                }\n-            }\n-        } catch (InterruptedException ie) {\n-            mesg(\"Shutdown\/destroy interrupted, giving up at \" +\n-                (System.currentTimeMillis() - startTime) + \"ms.\");\n-            ie.printStackTrace();\n-            Thread.currentThread().interrupt();\n-            return;\n-        }\n-\n-        vm = null;\n-    }\n-\n-    \/**\n-     * Shuts down rmid and then removes its log file.\n-     *\/\n-    public void cleanup() {\n-        destroy();\n-        RMID.removeLog();\n-    }\n-\n-    \/**\n-     * Gets the port on which this rmid is listening.\n-     *\/\n-    public int getPort() {\n-        return port;\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/RMID.java","additions":0,"deletions":506,"binary":false,"changes":506,"status":"deleted"},{"patch":"@@ -1,139 +0,0 @@\n-\/*\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.*;\n-import java.net.BindException;\n-import java.net.InetSocketAddress;\n-import java.net.ProtocolFamily;\n-import java.nio.channels.Channel;\n-import java.nio.channels.DatagramChannel;\n-import java.nio.channels.Pipe;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.SocketChannel;\n-import java.nio.channels.spi.AbstractSelector;\n-import java.nio.channels.spi.SelectorProvider;\n-import java.time.LocalTime;\n-import static java.net.StandardSocketOptions.SO_REUSEADDR;\n-import static java.net.StandardSocketOptions.SO_REUSEPORT;\n-\n-\/**\n- * A SelectorProvider, that can be loaded by the child rmid process, whose\n- * inheritedChannel method will create a new server socket channel and report\n- * it back to the parent process, over stdout.\n- *\/\n-public class RMIDSelectorProvider extends SelectorProvider {\n-\n-    private final SelectorProvider provider;\n-    private ServerSocketChannel channel;\n-\n-    public RMIDSelectorProvider() {\n-        provider = sun.nio.ch.DefaultSelectorProvider.get();\n-    }\n-\n-    public DatagramChannel openDatagramChannel()\n-        throws IOException\n-    {\n-        return provider.openDatagramChannel();\n-    }\n-\n-    public DatagramChannel openDatagramChannel(ProtocolFamily family)\n-        throws IOException\n-    {\n-        return provider.openDatagramChannel(family);\n-    }\n-\n-    public Pipe openPipe()\n-        throws IOException\n-    {\n-        return provider.openPipe();\n-    }\n-\n-    public AbstractSelector openSelector()\n-        throws IOException\n-    {\n-        return provider.openSelector();\n-    }\n-\n-    public ServerSocketChannel openServerSocketChannel()\n-        throws IOException\n-    {\n-        return provider.openServerSocketChannel();\n-    }\n-\n-    public SocketChannel openSocketChannel()\n-        throws IOException\n-    {\n-        return provider.openSocketChannel();\n-    }\n-\n-    public synchronized Channel inheritedChannel() throws IOException {\n-        System.out.println(\"RMIDSelectorProvider.inheritedChannel\");\n-        if (channel == null) {\n-            \/\/ Create and bind a new server socket channel\n-            channel = ServerSocketChannel.open();\n-\n-            \/\/ Enable SO_REUSEADDR before binding\n-            channel.setOption(SO_REUSEADDR, true);\n-\n-            \/\/ Enable SO_REUSEPORT, if supported, before binding\n-            if (channel.supportedOptions().contains(SO_REUSEPORT)) {\n-                channel.setOption(SO_REUSEPORT, true);\n-            }\n-\n-            \/\/ when it comes here, these properties should have been set with\n-            \/\/ a valid value, but assign a default value anyway.\n-            long timeout = Long.getLong(\n-                    \"test.java.rmi.testlibrary.RMIDSelectorProvider.timeout\",\n-                    200_000);\n-            long deadline = System.currentTimeMillis() + timeout;\n-            int port = Integer.getInteger(\n-                    \"test.java.rmi.testlibrary.RMIDSelectorProvider.port\", 0);\n-            while (true) {\n-                try {\n-                    channel.bind(new InetSocketAddress(port));\n-                    break;\n-                } catch (BindException ex) {\n-                    System.out.format(\"RMIDSelectorProvider: \"\n-                            + \"failed to bind to port %d due to \\\"%s\\\", at %s%n\",\n-                            port, ex.getMessage(), LocalTime.now());\n-                }\n-                if (System.currentTimeMillis() > deadline) {\n-                    System.out.format(\"RMIDSelectorProvider: \"\n-                            + \"fail to bind to port %d after trying for \"\n-                            + \"%d seconds, exiting rmid process, at %s%n\",\n-                            port, timeout\/1000, LocalTime.now());\n-                    channel.close();\n-                    \/\/ can not start rmid on specific port,\n-                    \/\/ there is no need to continue run rmid.\n-                    System.exit(1);\n-                }\n-                try {\n-                    Thread.sleep(1000);\n-                } catch(InterruptedException ignore) { }\n-            }\n-\n-            System.out.println(RMID.EPHEMERAL_MSG + channel.socket().getLocalPort());\n-        }\n-        return channel;\n-    }\n-}\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/RMIDSelectorProvider.java","additions":0,"deletions":139,"binary":false,"changes":139,"status":"deleted"},{"patch":"@@ -91,2 +91,0 @@\n-    public final static int RMIDVIAINHERITEDCHANNEL_ACTIVATION_PORT = 60001;\n-    public final static int RMIDVIAINHERITEDCHANNEL_REGISTRY_PORT = 60002;\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/TestLibrary.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,0 @@\n-    \/** name of default security policy for RMID *\/\n-    public static final String defaultRmidPolicy;\n-\n@@ -48,3 +45,0 @@\n-    \/** name of default security policy for activation groups *\/\n-    public static final String defaultGroupPolicy;\n-\n@@ -72,3 +66,0 @@\n-        defaultRmidPolicy =\n-            testSrc + File.separatorChar + \"rmid.security.policy\";\n-\n@@ -78,3 +69,0 @@\n-        defaultGroupPolicy =\n-            testSrc + File.separatorChar + \"group.security.policy\";\n-\n","filename":"test\/jdk\/java\/rmi\/testlibrary\/TestParams.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -21,1 +21,1 @@\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n+  \/\/ test needs to communicate with objects on arbitrary ports\n","filename":"test\/jdk\/java\/rmi\/transport\/checkLeaseInfoLeak\/security.policy","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n+  \/\/ test needs to communicate with objects on arbitrary ports\n","filename":"test\/jdk\/java\/rmi\/transport\/dgcDeadLock\/registry.security.policy","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-  \/\/ test needs to export rmid and communicate with objects on arbitrary ports\n+  \/\/ test needs to communicate with objects on arbitrary ports\n","filename":"test\/jdk\/java\/rmi\/transport\/dgcDeadLock\/security.policy","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n- * @modules java.rmi\/com.sun.rmi.rmid\n@@ -40,2 +39,0 @@\n-import com.sun.rmi.rmid.ExecPermission;\n-import com.sun.rmi.rmid.ExecOptionPermission;\n","filename":"test\/jdk\/java\/security\/PermissionCollection\/Concurrent.java","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -149,1 +149,0 @@\n-        new ToolHelpSpec(\"rmid\",        0,   0,   0,   0,         0,    0,     1),     \/\/ none, prints help message anyways.\n","filename":"test\/jdk\/tools\/launcher\/HelpFlagsTest.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -107,1 +107,0 @@\n-        \"rmid\",\n","filename":"test\/jdk\/tools\/launcher\/VersionCheck.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}