{"files":[{"patch":"@@ -26,2 +26,3 @@\n- * @bug 4533243\n- * @summary Closing a keep alive stream gives NullPointerException\n+ * @bug 4533243 8263364\n+ * @summary Closing a keep alive stream should not give NullPointerException and should accept a connection from  a\n+ *          client only from this test\n@@ -35,0 +36,3 @@\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n@@ -38,5 +42,2 @@\n-    static class XServer extends Thread {\n-        ServerSocket srv;\n-        Socket s;\n-        InputStream is;\n-        OutputStream os;\n+    private final static String path = \"\/KeepAliveStreamCloseWithWrongContentLength\";\n+    private final static String getRequest1stLine = \"GET %s\".formatted(path);\n@@ -44,2 +45,14 @@\n-        XServer (ServerSocket s) {\n-            srv = s;\n+    static class XServer extends Thread implements AutoCloseable {\n+\n+        final ServerSocket serverSocket;\n+        volatile Socket clientSocket;\n+\n+        XServer (InetAddress address) throws IOException {\n+            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n+            ServerSocket serversocket = serverSocketChannel.socket();\n+            serversocket.bind(new InetSocketAddress(address, 0));\n+            this.serverSocket = serversocket;\n+        }\n+\n+        public int getLocalPort() {\n+            return serverSocket.getLocalPort();\n@@ -49,0 +62,1 @@\n+\n@@ -50,6 +64,27 @@\n-                s = srv.accept ();\n-                \/\/ read HTTP request from client\n-                InputStream is = s.getInputStream();\n-                \/\/ read the first ten bytes\n-                for (int i=0; i<10; i++) {\n-                    is.read();\n+                ByteArrayOutputStream clientBytes;\n+                clientSocket = null;\n+\n+                \/\/ in a concurrent test environment it can happen that other rouge clients connect to this server\n+                \/\/ so we need to identify and connect only to the client from this test\n+                \/\/ if the rouge client sends as least bytes as there is in getRequest1stLine it will be discarded and\n+                \/\/ the test should proceed otherwise it should timeout on readNBytes below\n+                do {\n+                    if (clientSocket != null) {\n+                        final String client = \"%s:%d\".formatted(\n+                                clientSocket.getInetAddress().getHostAddress(),\n+                                clientSocket.getPort()\n+                        );\n+                        try {\n+                            clientSocket.close();\n+                        }\n+                        catch (IOException ioe) {\n+                            ioe.printStackTrace();\n+                        }\n+                        finally {\n+                            System.err.println(\"rogue client (%s) connection attempt, ignoring\".formatted(client));\n+                        }\n+                    }\n+                    clientSocket = serverSocket.accept();\n+                    \/\/ read HTTP request from client\n+                    clientBytes = new ByteArrayOutputStream();\n+                    clientBytes.write(clientSocket.getInputStream().readNBytes(getRequest1stLine.getBytes().length));\n@@ -57,3 +92,8 @@\n-                OutputStreamWriter ow =\n-                    new OutputStreamWriter((os = s.getOutputStream()));\n-                ow.write(\"HTTP\/1.0 200 OK\\n\");\n+                while(!getRequest1stLine.equals(clientBytes.toString()));\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try  {\n+                OutputStreamWriter outputStreamWriter = new OutputStreamWriter(clientSocket.getOutputStream());\n+                outputStreamWriter.write(\"HTTP\/1.0 200 OK\\n\");\n@@ -62,2 +102,2 @@\n-                ow.write(\"Content-Length: 10\\n\");\n-                ow.write(\"Content-Type: text\/html\\n\");\n+                outputStreamWriter.write(\"Content-Length: 10\\n\");\n+                outputStreamWriter.write(\"Content-Type: text\/html\\n\");\n@@ -66,2 +106,2 @@\n-                ow.write(\"Connection: Keep-Alive\\n\");\n-                ow.write(\"\\n\");\n+                outputStreamWriter.write(\"Connection: Keep-Alive\\n\");\n+                outputStreamWriter.write(\"\\n\");\n@@ -70,5 +110,41 @@\n-                ow.write(\"123456789\");\n-                ow.flush();\n-            } catch (Exception e) {\n-            } finally {\n-                try {if (os != null) { os.close(); }} catch (IOException e) {}\n+                outputStreamWriter.write(\"123456789\");\n+                outputStreamWriter.flush();\n+                clientSocket.getChannel().shutdownOutput();\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+        }\n+\n+        @Override\n+        public void close() throws Exception {\n+            final var clientSocket = this.clientSocket;\n+            try {\n+                long drained = drain(clientSocket.getChannel());\n+                System.err.printf(\"Server drained %d bytes from the channel%n\", drained);\n+            } catch (Exception x) {\n+                System.err.println(\"Server failed to drain client socket: \" + x);\n+                x.printStackTrace();\n+            }\n+            serverSocket.close();\n+        }\n+\n+    }\n+    \n+    static long drain(SocketChannel channel) throws IOException {\n+        if (!channel.isOpen()) return 0;\n+        System.err.println(\"Not reading server: draining socket\");\n+        var blocking = channel.isBlocking();\n+        if (blocking) channel.configureBlocking(false);\n+        long count = 0;\n+        try {\n+            ByteBuffer buffer = ByteBuffer.allocateDirect(8 * 1024);\n+            int read;\n+            while ((read = channel.read(buffer)) > 0) {\n+                count += read;\n+                buffer.clear();\n+            }\n+            return count;\n+        } finally {\n+            if (blocking != channel.isBlocking()) {\n+                channel.configureBlocking(blocking);\n@@ -79,0 +155,1 @@\n+\n@@ -80,0 +157,1 @@\n+\n@@ -81,2 +159,0 @@\n-        final ServerSocket serversocket = new ServerSocket();\n-        serversocket.bind(new InetSocketAddress(loopback, 0));\n@@ -84,4 +160,2 @@\n-        try {\n-            int port = serversocket.getLocalPort ();\n-            XServer server = new XServer (serversocket);\n-            server.start ();\n+        try (XServer server = new XServer(loopback)) {\n+            server.start();\n@@ -91,1 +165,2 @@\n-                .port(port)\n+                .path(path)\n+                .port(server.getLocalPort())\n@@ -94,1 +169,1 @@\n-            InputStream is = urlc.getInputStream ();\n+            InputStream is = urlc.getInputStream();\n@@ -99,0 +174,1 @@\n+                    System.out.println(\"client reads: \"+c);\n@@ -105,6 +181,0 @@\n-        } catch (IOException e) {\n-            return;\n-        } catch (NullPointerException e) {\n-            throw new RuntimeException (e);\n-        } finally {\n-            serversocket.close();\n@@ -112,0 +182,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamCloseWithWrongContentLength.java","additions":112,"deletions":41,"binary":false,"changes":153,"status":"modified"}]}