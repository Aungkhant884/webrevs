{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,24 @@\n+################################################################################\n+# Generate interim versions of the ToolProvider.java files for the interim\n+# langtools modules, which will allow to load javac from the interim\n+# jdk.compiler.\n+\n+INTERIM_TOOL_PROVIDER_PATTERN := \\\n+    $(foreach m, $(INTERIM_LANGTOOLS_BASE_MODULES), -e 's\/\"$m\"\/\"$m.interim\"\/g')\n+\n+$(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java: \\\n+    $(TOPDIR)\/src\/java.compiler\/share\/classes\/javax\/tools\/ToolProvider.java\n+\t$(call LogInfo, Generating ToolProvider.java for java.compiler.interim)\n+\t$(call MakeDir, $(@D))\n+\t$(SED) $(INTERIM_TOOL_PROVIDER_PATTERN) $< > $@\n+\n+java.compiler.interim_EXTRA_FILES := \\\n+     $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n+\n+TARGETS += $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n+\n+################################################################################\n+# Use the up-to-date PreviewFeature.java and NoPreview.java from the current\n+# sources, instead of the versions from the boot JDK, as javac may be referring\n+# to constants from the up-to-date versions.\n+\n@@ -76,0 +100,1 @@\n+          $(TOPDIR)\/src\/$1\/share\/classes\/javax\/tools\/ToolProvider.java \\\n@@ -77,1 +102,2 @@\n-      EXTRA_FILES := $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/$1.interim\/module-info.java, \\\n+      EXTRA_FILES := $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/$1.interim\/module-info.java \\\n+          $($1.interim_EXTRA_FILES), \\\n","filename":"make\/CompileInterimLangtools.gmk","additions":28,"deletions":2,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,0 +80,7 @@\n+    JAVAC_FLAGS := \\\n+        --add-exports jdk.compiler\/com.sun.tools.javac.api=ALL-UNNAMED \\\n+        --add-exports jdk.compiler\/com.sun.tools.javac.code=ALL-UNNAMED \\\n+        --add-exports jdk.compiler\/com.sun.tools.javac.comp=ALL-UNNAMED \\\n+        --add-exports jdk.compiler\/com.sun.tools.javac.main=ALL-UNNAMED \\\n+        --add-exports jdk.compiler\/com.sun.tools.javac.tree=ALL-UNNAMED \\\n+        --add-exports jdk.compiler\/com.sun.tools.javac.util=ALL-UNNAMED, \\\n","filename":"make\/CompileToolsJdk.gmk","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -405,0 +405,1 @@\n+    $1_MODFILELIST := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_batch.modfiles\n@@ -407,0 +408,1 @@\n+    $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n@@ -440,0 +442,1 @@\n+          \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n@@ -450,1 +453,1 @@\n-\t\t$$(call LogWarn, Compiling $$(words $$($1_SRCS)) files for $1)\n+\t\t$$(call LogWarn, Compiling up to $$(words $$($1_SRCS)) files for $1)\n@@ -452,0 +455,2 @@\n+\t\t$$(eval $1_MODFILES := $$?)\n+\t\t$$(eval $$(call ListPathsSafely, $1_MODFILES, $$($1_MODFILELIST)))\n@@ -460,0 +465,1 @@\n+\t\t        -XDmodifiedInputs=$$($1_MODFILELIST) \\\n","filename":"make\/common\/JavaCompilation.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,11 @@\n+import com.sun.source.tree.ClassTree;\n+import com.sun.source.tree.CompilationUnitTree;\n+import com.sun.source.tree.IdentifierTree;\n+import com.sun.source.tree.ImportTree;\n+import com.sun.source.tree.LiteralTree;\n+import com.sun.source.tree.MemberReferenceTree;\n+import com.sun.source.tree.MemberSelectTree;\n+import com.sun.source.tree.MethodTree;\n+import com.sun.source.tree.ModifiersTree;\n+import com.sun.source.tree.Tree;\n+import com.sun.source.tree.VariableTree;\n@@ -89,0 +100,1 @@\n+import com.sun.source.util.TreeScanner;\n@@ -90,0 +102,22 @@\n+import com.sun.tools.javac.api.BasicJavacTask;\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.main.JavaCompiler;\n+import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\n+import com.sun.tools.javac.tree.JCTree.JCVariableDecl;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.Context.Key;\n+import com.sun.tools.javac.util.ListBuffer;\n+import com.sun.tools.javac.util.Options;\n+import com.sun.tools.javac.util.StringUtils;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n@@ -91,0 +125,5 @@\n+import javax.lang.model.element.Name;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.StandardLocation;\n+import javax.tools.ToolProvider;\n@@ -101,0 +140,34 @@\n+        addExports();\n+\n+        AtomicBoolean noApiChange = new AtomicBoolean();\n+        try {\n+            Context context = ((BasicJavacTask) jt).getContext();\n+            Options options = Options.instance(context);\n+            String modifiedInputs = options.get(\"modifiedInputs\");\n+            if (modifiedInputs == null) {\n+                throw new IllegalStateException(\"Expected modifiedInputs to be set using -XDmodifiedInputs=<list-of-files>\");\n+            }\n+            String internalAPIPath = options.get(\"internalAPIPath\");\n+            if (internalAPIPath == null) {\n+                throw new IllegalStateException(\"Expected internalAPIPath to be set using -XDinternalAPIPath=<internal-API-path>\");\n+            }\n+            Set<String> modified = new HashSet<>(Files.readAllLines(Paths.get(modifiedInputs)));\n+            Path internalAPIDigestFile = Paths.get(internalAPIPath);\n+            JavaCompiler compiler = JavaCompiler.instance(context);\n+            Class<?> initialFileParserIntf = Class.forName(\"com.sun.tools.javac.main.JavaCompiler$InitialFileParserIntf\");\n+            Class<?> initialFileParser = Class.forName(\"com.sun.tools.javac.main.JavaCompiler$InitialFileParser\");\n+            Field initialParserKeyField = initialFileParser.getDeclaredField(\"initialParserKey\");\n+            @SuppressWarnings(\"unchecked\")\n+            Key<Object> key = (Key<Object>) initialParserKeyField.get(null);\n+            Object initialParserInstance =\n+                    Proxy.newProxyInstance(Depend.class.getClassLoader(),\n+                                           new Class<?>[] {initialFileParserIntf},\n+                                           new FilteredInitialFileParser(compiler,\n+                                                                         modified,\n+                                                                         internalAPIDigestFile,\n+                                                                         noApiChange));\n+            context.<Object>put(key, initialParserInstance);\n+        } catch (Exception ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+\n@@ -137,1 +210,1 @@\n-                if (te.getKind() == Kind.COMPILATION) {\n+                if (te.getKind() == Kind.COMPILATION && !noApiChange.get()) {\n@@ -159,0 +232,88 @@\n+    private void addExports() {\n+        var systemCompiler = ToolProvider.getSystemJavaCompiler();\n+        try (JavaFileManager jfm = systemCompiler.getStandardFileManager(null, null, null)) {\n+            JavaFileManager fm = new ForwardingJavaFileManager<JavaFileManager>(jfm) {\n+                @Override\n+                public ClassLoader getClassLoader(JavaFileManager.Location location) {\n+                    if (location == StandardLocation.CLASS_PATH) {\n+                        return Depend.class.getClassLoader();\n+                    }\n+                    return super.getClassLoader(location);\n+                }\n+            };\n+            ((JavacTask) systemCompiler.getTask(null, fm, null,\n+                                                List.of(\"-proc:only\", \"-XDaccessInternalAPI=true\"),\n+                                                List.of(\"java.lang.Object\"), null))\n+                                       .analyze();\n+        } catch (IOException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n+\n+    private com.sun.tools.javac.util.List<JCCompilationUnit> doFilteredParse(\n+            JavaCompiler compiler, Iterable<JavaFileObject> fileObjects, Set<String> modified,\n+            Path internalAPIDigestFile, AtomicBoolean noApiChange) {\n+        Map<String, String> internalAPI = new LinkedHashMap<>();\n+        if (Files.isReadable(internalAPIDigestFile)) {\n+            try {\n+                Files.readAllLines(internalAPIDigestFile, StandardCharsets.UTF_8)\n+                     .forEach(line -> {\n+                         String[] keyAndValue = line.split(\"=\");\n+                         internalAPI.put(keyAndValue[0], keyAndValue[1]);\n+                     });\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        }\n+        Map<JavaFileObject, JCCompilationUnit> files2CUT = new IdentityHashMap<>();\n+        boolean fullRecompile = modified.stream()\n+                                        .anyMatch(f -> !StringUtils.toLowerCase(f).endsWith(\".java\"));\n+        ListBuffer<JCCompilationUnit> result = new ListBuffer<>();\n+        for (JavaFileObject jfo : fileObjects) {\n+            if (modified.contains(jfo.getName())) {\n+                JCCompilationUnit parsed = compiler.parse(jfo);\n+                files2CUT.put(jfo, parsed);\n+                String currentSignature = treeDigest(parsed);\n+                if (!currentSignature.equals(internalAPI.get(jfo.getName()))) {\n+                    fullRecompile |= true;\n+                    internalAPI.put(jfo.getName(), currentSignature);\n+                }\n+                result.add(parsed);\n+            }\n+        }\n+\n+        if (fullRecompile) {\n+            for (JavaFileObject jfo : fileObjects) {\n+                if (!modified.contains(jfo.getName())) {\n+                    JCCompilationUnit parsed = files2CUT.get(jfo);\n+                    if (parsed == null) {\n+                        parsed = compiler.parse(jfo);\n+                        internalAPI.put(jfo.getName(), treeDigest(parsed));\n+                    }\n+                    result.add(parsed);\n+                }\n+            }\n+            try (OutputStream out = Files.newOutputStream(internalAPIDigestFile)) {\n+                String hashes = internalAPI.entrySet()\n+                                           .stream()\n+                                           .map(e -> e.getKey() + \"=\" + e.getValue())\n+                                           .collect(Collectors.joining(\"\\n\"));\n+                out.write(hashes.getBytes(StandardCharsets.UTF_8));\n+            } catch (IOException ex) {\n+                throw new IllegalStateException(ex);\n+            }\n+        } else {\n+            noApiChange.set(true);\n+        }\n+        return result.toList();\n+    }\n+\n+    private String treeDigest(JCCompilationUnit cu) {\n+        try {\n+            TreeVisitor v = new TreeVisitor(MessageDigest.getInstance(\"MD5\"));\n+            v.scan(cu, null);\n+            return Depend.this.toString(v.apiHash.digest());\n+        } catch (NoSuchAlgorithmException ex) {\n+            throw new IllegalStateException(ex);\n+        }\n+    }\n@@ -540,0 +701,184 @@\n+\n+    private static final class TreeVisitor extends TreeScanner<Void, Void> {\n+\n+        private final Set<Name> seenIdentifiers = new HashSet<>();\n+        private final MessageDigest apiHash;\n+        private final Charset utf8;\n+\n+        public TreeVisitor(MessageDigest apiHash) {\n+            this.apiHash = apiHash;\n+            utf8 = Charset.forName(\"UTF-8\");\n+        }\n+\n+        private void update(CharSequence data) {\n+            apiHash.update(data.toString().getBytes(utf8));\n+        }\n+\n+        @Override\n+        public Void scan(Tree tree, Void p) {\n+            update(\"(\");\n+            if (tree != null) {\n+                update(tree.getKind().name());\n+            };\n+            super.scan(tree, p);\n+            update(\")\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitCompilationUnit(CompilationUnitTree node, Void p) {\n+            seenIdentifiers.clear();\n+            scan(node.getPackage(), p);\n+            scan(node.getTypeDecls(), p);\n+            scan(((JCCompilationUnit) node).getModuleDecl(), p);\n+            List<ImportTree> importantImports = new ArrayList<>();\n+            for (ImportTree imp : node.getImports()) {\n+                Tree t = imp.getQualifiedIdentifier();\n+                if (t.getKind() == Tree.Kind.MEMBER_SELECT) {\n+                    Name member = ((MemberSelectTree) t).getIdentifier();\n+                    if (member.contentEquals(\"*\") || seenIdentifiers.contains(member)) {\n+                        importantImports.add(imp);\n+                    }\n+                } else {\n+                    \/\/should not happen, possibly erroneous source?\n+                    importantImports.add(imp);\n+                }\n+            }\n+            importantImports.sort((imp1, imp2) -> {\n+                if (imp1.isStatic() ^ imp2.isStatic()) {\n+                    return imp1.isStatic() ? -1 : 1;\n+                } else {\n+                    return imp1.getQualifiedIdentifier().toString().compareTo(imp2.getQualifiedIdentifier().toString());\n+                }\n+            });\n+            scan(importantImports, p);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitIdentifier(IdentifierTree node, Void p) {\n+            update(node.getName());\n+            seenIdentifiers.add(node.getName());\n+            return super.visitIdentifier(node, p);\n+        }\n+\n+        @Override\n+        public Void visitMemberSelect(MemberSelectTree node, Void p) {\n+            update(node.getIdentifier());\n+            return super.visitMemberSelect(node, p);\n+        }\n+\n+        @Override\n+        public Void visitMemberReference(MemberReferenceTree node, Void p) {\n+            update(node.getName());\n+            return super.visitMemberReference(node, p);\n+        }\n+\n+        @Override\n+        public Void scan(Iterable<? extends Tree> nodes, Void p) {\n+            update(\"(\");\n+            super.scan(nodes, p);\n+            update(\")\");\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitClass(ClassTree node, Void p) {\n+            update(node.getSimpleName());\n+            scan(node.getModifiers(), p);\n+            scan(node.getTypeParameters(), p);\n+            scan(node.getExtendsClause(), p);\n+            scan(node.getImplementsClause(), p);\n+            scan(node.getMembers()\n+                     .stream()\n+                     .filter(this::importantMember)\n+                     .collect(Collectors.toList()),\n+                 p);\n+            return null;\n+        }\n+\n+        private boolean importantMember(Tree m) {\n+            return switch (m.getKind()) {\n+                case ANNOTATION_TYPE, CLASS, ENUM, INTERFACE, RECORD ->\n+                    !isPrivate(((ClassTree) m).getModifiers());\n+                case METHOD ->\n+                    !isPrivate(((MethodTree) m).getModifiers());\n+                case VARIABLE ->\n+                    !isPrivate(((VariableTree) m).getModifiers()) ||\n+                    isRecordComponent((VariableTree) m);\n+                case BLOCK -> false;\n+                default -> throw new IllegalStateException(\"Unexpected tree kind: \" + m.getKind());\n+            };\n+        }\n+\n+        private boolean isPrivate(ModifiersTree mt) {\n+            return mt.getFlags().contains(Modifier.PRIVATE);\n+        }\n+\n+        private boolean isRecordComponent(VariableTree vt) {\n+            return (((JCVariableDecl) vt).mods.flags & Flags.RECORD) != 0;\n+        }\n+\n+        @Override\n+        public Void visitVariable(VariableTree node, Void p) {\n+            update(node.getName());\n+            return super.visitVariable(node, p);\n+        }\n+\n+        @Override\n+        public Void visitMethod(MethodTree node, Void p) {\n+            update(node.getName());\n+            scan(node.getModifiers(), p);\n+            scan(node.getReturnType(), p);\n+            scan(node.getTypeParameters(), p);\n+            scan(node.getParameters(), p);\n+            scan(node.getReceiverParameter(), p);\n+            scan(node.getThrows(), p);\n+            scan(node.getDefaultValue(), p);\n+            return null;\n+        }\n+\n+        @Override\n+        public Void visitLiteral(LiteralTree node, Void p) {\n+            update(String.valueOf(node.getValue()));\n+            return super.visitLiteral(node, p);\n+        }\n+\n+        @Override\n+        public Void visitModifiers(ModifiersTree node, Void p) {\n+            update(node.getFlags().toString());\n+            return super.visitModifiers(node, p);\n+        }\n+\n+    }\n+\n+    private class FilteredInitialFileParser implements InvocationHandler {\n+\n+        private final JavaCompiler compiler;\n+        private final Set<String> modified;\n+        private final Path internalAPIDigestFile;\n+        private final AtomicBoolean noApiChange;\n+\n+        public FilteredInitialFileParser(JavaCompiler compiler,\n+                                         Set<String> modified,\n+                                         Path internalAPIDigestFile,\n+                                         AtomicBoolean noApiChange) {\n+            this.compiler = compiler;\n+            this.modified = modified;\n+            this.internalAPIDigestFile = internalAPIDigestFile;\n+            this.noApiChange = noApiChange;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            return switch (method.getName()) {\n+                case \"parse\" -> doFilteredParse(compiler,\n+                                                (Iterable<JavaFileObject>) args[0],\n+                                                modified,\n+                                                internalAPIDigestFile,\n+                                                noApiChange);\n+                default -> throw new UnsupportedOperationException();\n+            };\n+        }\n+    }\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/Depend.java","additions":347,"deletions":2,"binary":false,"changes":349,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,2 @@\n+        test.testImports();\n+        test.testModifiers();\n@@ -148,1 +150,2 @@\n-                       false);\n+                       false,\n+                       true); \/\/Tree hash does not tolerate undocumented annotations\n@@ -159,0 +162,77 @@\n+    public void testImports() throws Exception {\n+        doOrdinaryTest(\"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"import java.util.List;\\n\" +\n+                       \"public class Test {\\n\" +\n+                       \"    private List l;\\n\" +\n+                       \"}\",\n+                       false);\n+        doOrdinaryTest(\"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"import java.util.List;\\n\" +\n+                       \"public class Test {\\n\" +\n+                       \"    public List l;\\n\" +\n+                       \"}\",\n+                       true);\n+        doOrdinaryTest(\"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"import java.util.List;\\n\" +\n+                       \"public class Test {\\n\" +\n+                       \"    List l;\\n\" +\n+                       \"}\",\n+                       false,\n+                       true);\n+        doOrdinaryTest(\"package test;\" +\n+                       \"import java.util.*;\\n\" +\n+                       \"public abstract class Test implements List {\\n\" +\n+                       \"}\\n\" +\n+                       \"class H {\\n\" +\n+                       \"    public interface List {}\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"import java.util.*;\\n\" +\n+                       \"import test.H.List;\\n\" +\n+                       \"public abstract class Test implements List {\\n\" +\n+                       \"}\\n\" +\n+                       \"class H {\\n\" +\n+                       \"    public interface List {}\\n\" +\n+                       \"}\",\n+                       true);\n+        doOrdinaryTest(\"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"import java.util.*;\\n\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       false,\n+                       true);\n+        doOrdinaryTest(\"package test;\" +\n+                       \"import java.util.*;\\n\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"}\",\n+                       false,\n+                       true);\n+    }\n+\n+    public void testModifiers() throws Exception {\n+        doOrdinaryTest(\"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"    String l;\\n\" +\n+                       \"}\",\n+                       \"package test;\" +\n+                       \"public class Test {\\n\" +\n+                       \"    public String l;\\n\" +\n+                       \"}\",\n+                       true);\n+    }\n+\n@@ -202,1 +282,2 @@\n-                       false);\n+                       false,\n+                       true);\n@@ -206,1 +287,2 @@\n-                       false);\n+                       false,\n+                       true);\n@@ -230,0 +312,1 @@\n+    private Path treeHash;\n@@ -247,0 +330,1 @@\n+        treeHash = scratch.resolve(\"tree\");\n@@ -250,0 +334,4 @@\n+        doOrdinaryTest(codeBefore, codeAfter, hashChangeExpected, hashChangeExpected);\n+    }\n+\n+    private void doOrdinaryTest(String codeBefore, String codeAfter, boolean apiHashChangeExpected, boolean treeHashChangeExpected) throws Exception {\n@@ -253,1 +341,2 @@\n-                              \"-Xplugin:depend \" + apiHash.toString());\n+                              \"-Xplugin:depend \" + apiHash.toString() + \" \" + treeHash.toString(),\n+                              \"-XDmodifiedInputs=build-all\");\n@@ -258,1 +347,2 @@\n-        byte[] originalHash = Files.readAllBytes(apiHash);\n+        byte[] originalApiHash = Files.readAllBytes(apiHash);\n+        byte[] originalTreeHash = Files.readAllBytes(treeHash);\n@@ -263,1 +353,6 @@\n-        byte[] newHash = Files.readAllBytes(apiHash);\n+        byte[] newApiHash = Files.readAllBytes(apiHash);\n+        byte[] newTreeHash = Files.readAllBytes(treeHash);\n+\n+        if (Arrays.equals(originalApiHash, newApiHash) ^ !apiHashChangeExpected) {\n+            throw new AssertionError(\"Unexpected API hash state.\");\n+        }\n@@ -265,2 +360,4 @@\n-        if (Arrays.equals(originalHash, newHash) ^ !hashChangeExpected) {\n-            throw new AssertionError(\"Unexpected hash state.\");\n+        if (Arrays.equals(originalTreeHash, newTreeHash) ^ !treeHashChangeExpected) {\n+            throw new AssertionError(\"Unexpected Tree hash state, \" +\n+                                     \"original: \" + new String(originalTreeHash) +\n+                                     \", new: \" + new String(newTreeHash));\n@@ -271,0 +368,4 @@\n+        doModuleTest(codeBefore, codeAfter, hashChangeExpected, hashChangeExpected);\n+    }\n+\n+    private void doModuleTest(String codeBefore, String codeAfter, boolean apiHashChangeExpected, boolean treeHashChangeExpected) throws Exception {\n@@ -274,1 +375,2 @@\n-                              \"-Xplugin:depend \" + apiHash.toString());\n+                              \"-Xplugin:depend \" + apiHash.toString() + \" \" + treeHash.toString(),\n+                              \"-XDmodifiedInputs=build-all\");\n@@ -282,1 +384,2 @@\n-        byte[] originalHash = Files.readAllBytes(apiHash);\n+        byte[] originalApiHash = Files.readAllBytes(apiHash);\n+        byte[] originalTreeHash = Files.readAllBytes(treeHash);\n@@ -290,1 +393,6 @@\n-        byte[] newHash = Files.readAllBytes(apiHash);\n+        byte[] newApiHash = Files.readAllBytes(apiHash);\n+        byte[] newTreeHash = Files.readAllBytes(treeHash);\n+\n+        if (Arrays.equals(originalApiHash, newApiHash) ^ !apiHashChangeExpected) {\n+            throw new AssertionError(\"Unexpected API hash state.\");\n+        }\n@@ -292,2 +400,4 @@\n-        if (Arrays.equals(originalHash, newHash) ^ !hashChangeExpected) {\n-            throw new AssertionError(\"Unexpected hash state.\");\n+        if (Arrays.equals(originalTreeHash, newTreeHash) ^ !treeHashChangeExpected) {\n+            throw new AssertionError(\"Unexpected Tree hash state, \" +\n+                                     \"original: \" + new String(originalTreeHash) +\n+                                     \", new: \" + new String(newTreeHash));\n","filename":"make\/jdk\/src\/classes\/build\/tools\/depend\/DependTest.java","additions":124,"deletions":14,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+import com.sun.tools.javac.util.Context.Key;\n@@ -993,1 +994,1 @@\n-       return parseFiles(fileObjects, false);\n+       return InitialFileParser.instance(context).parse(fileObjects);\n@@ -1869,0 +1870,28 @@\n+\n+    public interface InitialFileParserIntf {\n+        public List<JCCompilationUnit> parse(Iterable<JavaFileObject> files);\n+    }\n+\n+    public static class InitialFileParser implements InitialFileParserIntf {\n+\n+        public static final Key<InitialFileParserIntf> initialParserKey = new Key<>();\n+\n+        public static InitialFileParserIntf instance(Context context) {\n+            InitialFileParserIntf instance = context.get(initialParserKey);\n+            if (instance == null)\n+                instance = new InitialFileParser(context);\n+            return instance;\n+        }\n+\n+        private final JavaCompiler compiler;\n+\n+        private InitialFileParser(Context context) {\n+            context.put(initialParserKey, this);\n+            this.compiler = JavaCompiler.instance(context);\n+        }\n+\n+        @Override\n+        public List<JCCompilationUnit> parse(Iterable<JavaFileObject> fileObjects) {\n+           return compiler.parseFiles(fileObjects, false);\n+        }\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"}]}