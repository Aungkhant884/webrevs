{"files":[{"patch":"@@ -132,0 +132,4 @@\n+  JPACKAGE_WIXHELPER_SRC := \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, libwixhelper) \\\n+      $(call FindSrcDirsForComponent, jdk.jpackage, common)\n+\n@@ -139,0 +143,1 @@\n+      SRC := $(JPACKAGE_WIXHELPER_SRC), \\\n@@ -140,1 +145,1 @@\n-          $(JPACKAGE_CXXFLAGS_windows), \\\n+          $(addprefix -I, $(JPACKAGE_WIXHELPER_SRC)) $(JPACKAGE_CXXFLAGS_windows), \\\n@@ -143,1 +148,1 @@\n-      LIBS_windows := msi.lib Shlwapi.lib User32.lib, \\\n+      LIBS_windows := User32.lib, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,0 @@\n-import java.util.stream.Collectors;\n@@ -108,1 +107,1 @@\n-        if (withInstallDirChooserDlg) {\n+        if (withCustomActionsDll) {\n@@ -122,1 +121,1 @@\n-        if (withInstallDirChooserDlg) {\n+        if (withCustomActionsDll) {\n@@ -484,0 +483,1 @@\n+    private boolean withCustomActionsDll = true;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixUiFragmentBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n-    <Binary Id=\"JpCaDll\" SourceFile=\"wixhelper.dll\"\/>\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/InstallDirNotEmptyDlg.wxs","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,4 @@\n+    <Binary Id=\"JpCaDll\" SourceFile=\"wixhelper.dll\"\/>\n+\n+    <CustomAction Id=\"JpFindRelatedProducts\" BinaryKey=\"JpCaDll\" DllEntry=\"FindRelatedProductsEx\" \/>\n+\n@@ -117,1 +121,1 @@\n-      <Custom Action=\"JpDisallowUpgrade\" After=\"FindRelatedProducts\">JP_UPGRADABLE_FOUND<\/Custom>\n+      <Custom Action=\"JpDisallowUpgrade\" After=\"JpFindRelatedProducts\">JP_UPGRADABLE_FOUND<\/Custom>\n@@ -120,1 +124,1 @@\n-      <Custom Action=\"JpDisallowDowngrade\" After=\"FindRelatedProducts\">JP_DOWNGRADABLE_FOUND<\/Custom>\n+      <Custom Action=\"JpDisallowDowngrade\" After=\"JpFindRelatedProducts\">JP_DOWNGRADABLE_FOUND<\/Custom>\n@@ -123,0 +127,1 @@\n+      <Custom Action=\"JpFindRelatedProducts\" After=\"FindRelatedProducts\"\/>\n@@ -125,0 +130,4 @@\n+    <InstallUISequence>\n+      <Custom Action=\"JpFindRelatedProducts\" After=\"FindRelatedProducts\"\/>\n+    <\/InstallUISequence>\n+\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/resources\/main.wxs","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"MsiCA.h\"\n+#include \"MsiDb.h\"\n+#include \"MsiUtils.h\"\n+#include \"FileUtils.h\"\n+#include \"ErrorHandling.h\"\n+#include \"Toolbox.h\"\n+\n+\n+#pragma comment(lib, \"msi.lib\")\n+\n+\n+namespace msi {\n+\n+tstring CAImpl::getProperty(const tstring& name) const {\n+    return getPropertyFromCustomAction(handle, name);\n+}\n+\n+\n+void CAImpl::setProperty(const tstring& name, const tstring& value) {\n+    if (value.empty()) {\n+        JP_THROW(tstrings::any() << \"Attempt to assign empty value to '\"\n+                                          << name << \"' MSI property\");\n+    }\n+\n+    LOG_TRACE(tstrings::any() << \"Setting MSI property '\" << name <<\n+                                                    \"' to '\" << value << \"'\");\n+    const UINT status = MsiSetProperty(handle, name.c_str(), value.c_str());\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(msi::Error(tstrings::any() << \"MsiSetProperty(\" << name\n+                                    << \", \" << value << \") failed\", status));\n+    }\n+}\n+\n+\n+void CAImpl::removeProperty(const tstring& name) {\n+    LOG_TRACE(tstrings::any() << \"Removing MSI property '\" << name << \"'\");\n+    const UINT status = MsiSetProperty(handle, name.c_str(), NULL);\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(msi::Error(tstrings::any() << \"MsiSetProperty(\" << name\n+                                    << \", NULL) failed\", status));\n+    }\n+}\n+\n+\n+Guid CAFacade::getProductCode() const {\n+    return impl.getProperty(_T(\"ProductCode\"));\n+}\n+\n+\n+bool CAFacade::isInMode(MSIRUNMODE v) const {\n+    return MsiGetMode(impl.getHandle(), v) != FALSE;\n+}\n+\n+\n+tstring CAFacade::getModes() const {\n+    tstring modes;\n+    \/\/ Iterate all modes in the range [MSIRUNMODE_ADMIN, MSIRUNMODE_COMMIT]\n+    for (int mode = MSIRUNMODE_ADMIN; mode != MSIRUNMODE_COMMIT + 1; ++mode) {\n+        modes.insert(modes.end(), isInMode(MSIRUNMODE(mode)) ?\n+                                                        _T('1') : _T('0'));\n+    }\n+    return modes;\n+}\n+\n+\n+void CAFacade::doAction(const tstring& name) const {\n+    const UINT status = MsiDoAction(impl.getHandle(), name.c_str());\n+    if (status != ERROR_SUCCESS) {\n+        JP_THROW(msi::Error(tstrings::any() << \"MsiDoAction(\" << name\n+                                                    << \") failed\", status));\n+    }\n+}\n+\n+\n+tstring CAFacade::normalizeDirectoryPath(tstring v) {\n+    if (v.empty()) {\n+        return v;\n+    }\n+    std::replace(v.begin(), v.end(), '\/', '\\\\');\n+    return FileUtils::removeTrailingSlash(v) + _T(\"\\\\\");\n+}\n+\n+\n+CA& CA::setPropertyIfEmpty(const tstring& name, const tstring& v) {\n+    if (getProperty(name).empty()) {\n+        setProperty(name, v);\n+    }\n+    return *this;\n+}\n+\n+\n+tstring DeferredCA::getArg() const {\n+    if (isInMode(MSIRUNMODE_SCHEDULED) || caArgPropertyName.empty()) {\n+        \/\/ Details on accessing MSI properties from deferred custom actions:\n+        \/\/  http:\/\/blogs.technet.com\/b\/alexshev\/archive\/2008\/03\/25\/property-does-not-exist-or-empty-when-accessed-from-deferred-custom-action.aspx\n+        \/\/  http:\/\/stackoverflow.com\/questions\/17988392\/unable-to-fetch-the-install-location-property-in-a-deferred-custom-action\n+        \/\/  http:\/\/stackoverflow.com\/questions\/11233267\/how-to-pass-customactiondata-to-a-customaction-using-wix\n+        return impl.getProperty(_T(\"CustomActionData\"));\n+    }\n+\n+    return impl.getProperty(caArgPropertyName);\n+}\n+\n+\n+tstring DeferredCA::getParsedArg(const tstring& name) const {\n+    const auto entry = theParsedArgs.find(name);\n+    if (entry == theParsedArgs.end()) {\n+        JP_THROW(tstrings::any() << \"Argument << '\" << name\n+                                                        << \"' not found.\");\n+    }\n+    return entry->second;\n+}\n+\n+\n+namespace {\n+std::pair<tstring, tstring> parseArg(const tstring& v) {\n+    const auto pos = v.find(_T('='));\n+    if (pos == tstring::npos) {\n+        JP_THROW(tstrings::any() << \"Missing expected '=' character in [\"\n+                                                        << v << \"] string.\");\n+    }\n+    return std::pair<tstring, tstring>(v.substr(0, pos), v.substr(pos + 1));\n+}\n+\n+void parseArgsImpl(DeferredCA::ArgsCtnr& dst, const tstring& src) {\n+    const tstring_array pairs = tstrings::split(src, _T(\"*\"));\n+    for(auto it = pairs.begin(), end = pairs.end(); it != end; ++it) {\n+        const auto pair = parseArg(*it);\n+        dst[pair.first] = pair.second;\n+    }\n+}\n+} \/\/  namespace\n+void DeferredCA::parseArgs(ArgsCtnr& dst, const tstring& src) {\n+    DeferredCA::ArgsCtnr tmp;\n+\n+    const auto end = src.find(_T(\"**\"));\n+    if (end != tstring::npos) {\n+        parseArgsImpl(tmp, src.substr(0, end));\n+        tmp[tstring()] = src.substr(end + 2);\n+    } else {\n+        parseArgsImpl(tmp, src);\n+    }\n+\n+    tmp.insert(dst.begin(), dst.end());\n+    tmp.swap(dst);\n+}\n+\n+\n+MsiLogAppender::MsiLogAppender(MSIHANDLE h): handle(h),\n+        ctorThread(GetCurrentThreadId()) {\n+\n+}\n+\n+void MsiLogAppender::append(const LogEvent& v) {\n+    const LPCTSTR format = _T(\"[%02u:%02u:%02u.%03u%s%s:%u (%s)] %s: %s\");\n+\n+    tstring ctxInfo = _T(\" \");\n+    if (v.tid != ctorThread) {\n+        ctxInfo = (tstrings::any() << \" (TID: \" << v.tid << \") \").tstr();\n+    }\n+\n+    const tstring buf = tstrings::unsafe_format(format,\n+        unsigned(v.ts.wHour), unsigned(v.ts.wMinute), unsigned(v.ts.wSecond), unsigned(v.ts.wMilliseconds), \/\/ time\n+        ctxInfo.c_str(),\n+        v.fileName.c_str(), v.lineNum, v.funcName.c_str(),\n+        v.logLevel.c_str(),\n+        v.message.c_str());\n+\n+    DatabaseRecord r(1);\n+    r.setString(0, _T(\"Java [1]\"));\n+    r.setString(1, buf);\n+\n+    MsiProcessMessage(handle, INSTALLMESSAGE_INFO, r.getHandle());\n+}\n+\n+\n+MsiLogTrigger::MsiLogTrigger(MSIHANDLE h):\n+        msiLogAppender(h),\n+        oldLogAppender(Logger::defaultLogger().getAppender()),\n+        teeLogAppender(&msiLogAppender, &oldLogAppender) {\n+    Logger::defaultLogger().setAppender(teeLogAppender);\n+}\n+\n+\n+MsiLogTrigger::~MsiLogTrigger() {\n+    Logger::defaultLogger().setAppender(oldLogAppender);\n+}\n+\n+\n+\n+\n+namespace {\n+MSIHANDLE openDatabase(const CA& ca) {\n+    MSIHANDLE h = MsiGetActiveDatabase(ca.getHandle());\n+    if (h == NULL) {\n+        JP_THROW(Error(std::string(\"MsiGetActiveDatabase() failed\"),\n+                                                    ERROR_FUNCTION_FAILED));\n+    }\n+    return h;\n+}\n+\n+} \/\/ namespace\n+\n+Database::Database(const CA& ca): msiPath(_T(\"*CA*\")),\n+                                            dbHandle(openDatabase(ca)) {\n+}\n+\n+} \/\/ namespace msi\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiCA.cpp","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,298 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef MsiCA_h\n+#define MsiCA_h\n+\n+#include <windows.h>\n+#include <Msi.h>\n+#include <msidefs.h>\n+#include <msiquery.h>\n+#include <map>\n+\n+#include \"Log.h\"\n+#include \"Guid.h\"\n+\n+\n+\/**\n+ * Helpers to implement custom actions (CA).\n+ *\/\n+namespace msi {\n+\n+\/**\n+ * Return values from CA functions.\n+ *\/\n+struct CAStatus {\n+    \/\/ https:\/\/msdn.microsoft.com\/en-us\/library\/windows\/desktop\/aa368072(v=vs.85).aspx\n+    enum Values {\n+        Success = ERROR_SUCCESS,\n+\n+        \/\/ Abort installation session.\n+        UserExit = ERROR_INSTALL_USEREXIT,\n+\n+        \/\/ Unexpected error interrupted installation session.\n+        FatalError = ERROR_INSTALL_FAILURE,\n+\n+        \/\/ Complete installation session without running further actions.\n+        ExitNoError = ERROR_NO_MORE_ITEMS\n+    };\n+};\n+\n+\n+\/**\n+ * Wrapper around MSIHANDLE passed in CA function by MSI service.\n+ * Provides basic functionality to read\/write property into the current MSI\n+ * session.\n+ *\/\n+class CAImpl {\n+public:\n+    explicit CAImpl(MSIHANDLE h): handle(h) {\n+    }\n+\n+    \/**\n+     * Returns value of a property with the given name.\n+     * Returns empty string if property with the given name doesn't exist.\n+     * Throws exception if error occurs.\n+     *\/\n+    tstring getProperty(const tstring& name) const;\n+\n+    \/**\n+     * Sets property value.\n+     * Throws exception if error occurs.\n+     * Throws exception if value is empty string.\n+     *\/\n+    void setProperty(const tstring& name, const tstring& v);\n+\n+    \/**\n+     * Removes property.\n+     * Throws exception if error occurs.\n+     *\/\n+    void removeProperty(const tstring& name);\n+\n+    MSIHANDLE getHandle() const {\n+        return handle;\n+    }\n+\n+private:\n+    CAImpl(const CAImpl&);\n+    CAImpl& operator=(const CAImpl&);\n+private:\n+    MSIHANDLE handle;\n+};\n+\n+\n+\/**\n+ * Provides common functionality for deferred and immediate CAs.\n+ *\/\n+class CAFacade: public CAStatus {\n+public:\n+    explicit CAFacade(MSIHANDLE h, UINT* status=NULL): impl(h), status(status) {\n+    }\n+\n+    Guid getProductCode() const;\n+\n+    bool isInMode(MSIRUNMODE v) const;\n+\n+    \/\/ Debug\n+    tstring getModes() const;\n+\n+    void exitStatus(CAStatus::Values v) {\n+        if (status) {\n+            *status = v;\n+        }\n+    }\n+\n+    void doAction(const tstring& name) const;\n+\n+    \/\/ Replaces all forward slashes with back slashes and ensures\n+    \/\/ the last character is a backslash.\n+    \/\/ Terminating directory paths with backslash is standard for MSI.\n+    \/\/ Do nothing if 'path' is empty string.\n+    static tstring normalizeDirectoryPath(tstring path);\n+\n+protected:\n+    CAImpl impl;\n+    UINT* status;\n+};\n+\n+\n+\/**\n+ * Immediate CA.\n+ *\/\n+class CA: public CAFacade {\n+public:\n+    CA(MSIHANDLE h, const tstring& \/* name *\/,\n+                                    UINT* status=NULL): CAFacade(h, status) {\n+    }\n+\n+    tstring getProperty(const tstring& name) const {\n+        return impl.getProperty(name);\n+    }\n+\n+    CA& setProperty(const tstring& name, const tstring& v) {\n+        impl.setProperty(name, v);\n+        return *this;\n+    }\n+\n+    CA& removeProperty(const tstring& name) {\n+        impl.removeProperty(name);\n+        return *this;\n+    }\n+\n+    \/**\n+     * Like setProperty(), but do nothing if property with the given name\n+     * exists and its value is not empty.\n+     *\/\n+    CA& setPropertyIfEmpty(const tstring& name, const tstring& v);\n+\n+    MSIHANDLE getHandle() const {\n+        return impl.getHandle();\n+    }\n+};\n+\n+\n+\/**\n+ * Deferred CA.\n+ *\/\n+class DeferredCA: public CAFacade {\n+public:\n+    DeferredCA(MSIHANDLE h, const tstring& name,\n+            UINT* status=NULL): CAFacade(h, status), caArgPropertyName(name) {\n+    }\n+\n+    typedef std::map<tstring, tstring> ArgsCtnr;\n+\n+    DeferredCA& parseArgs() {\n+        parseArgs(theParsedArgs, getArg());\n+        return *this;\n+    }\n+\n+    tstring getArg() const;\n+\n+    const ArgsCtnr& parsedArgs() const {\n+        return theParsedArgs;\n+    }\n+\n+    tstring getParsedArg(const tstring& name) const;\n+\n+    static void parseArgs(ArgsCtnr& dst, const tstring& src);\n+\n+private:\n+    ArgsCtnr theParsedArgs;\n+    tstring caArgPropertyName;\n+};\n+\n+\n+\/**\n+ * Write log messages into MSI log.\n+ *\/\n+class MsiLogAppender: public LogAppender {\n+public:\n+    explicit MsiLogAppender(MSIHANDLE h);\n+\n+    virtual void append(const LogEvent& v);\n+private:\n+    MSIHANDLE handle;\n+    long ctorThread;\n+};\n+\n+\n+\/**\n+ * Configures logging for the current CA.\n+ * Log messages that we send with LOG_INFO, LOG_ERROR, etc., go to both\n+ * the existing log appender and temporary MSI log file managed by\n+ * MSI service for the running MSI session (if any).\n+ *\/\n+class MsiLogTrigger {\n+public:\n+    explicit MsiLogTrigger(MSIHANDLE h);\n+    ~MsiLogTrigger();\n+private:\n+    MsiLogAppender msiLogAppender;\n+    LogAppender& oldLogAppender;\n+    TeeLogAppender teeLogAppender;\n+};\n+\n+} \/\/ namespace msi\n+\n+\n+\/\/\n+\/\/ Helpers to define CA functions.\n+\/\/\n+\/\/ Sample usage:\n+\/\/  Define immediate CA foo:\n+\/\/      JP_CA(foo) {\n+\/\/          \/\/ `ca` is a local variable of type msi::CA.\n+\/\/          LOG_TRACE(ca.getProperty(\"Some property\"));\n+\/\/      }\n+\/\/\n+\/\/  Define deferred CA bar:\n+\/\/      JP_DEFERRED_CA(bar) {\n+\/\/          \/\/ `ca` is a local variable of type msi::DeferredCA.\n+\/\/          LOG_TRACE(ca.getArg());\n+\/\/      }\n+\/\/\n+\/\/ JP_DEFERRED_CA\/JP_CA macros take care of everything related to setup CA\n+\/\/ handler:\n+\/\/  - define CA function with the right calling convention and arguments\n+\/\/    expected by MSI;\n+\/\/  - construct local instance of either DeferredCA or CA type to access data\n+\/\/    in the running MSI session;\n+\/\/  - setup logging, so that log messages issues with LOG_INFO, LOG_ERROR, etc.\n+\/\/    macros go to MSI log file;\n+\/\/  - registers CA function with linker, so there is no need to manage\n+\/\/    separate .def file with the list of CA functions explicitly.\n+\/\/\n+#define JP_CA_BASE(name, ca_type) \\\n+    static void name ## Body(ca_type&); \\\n+    extern \"C\" UINT __stdcall name(MSIHANDLE hInstall) { \\\n+        __pragma(comment(linker, \"\/EXPORT:\" __FUNCTION__ \"=\" __FUNCDNAME__)); \\\n+        const msi::MsiLogTrigger logTrigger(hInstall); \\\n+        JP_DEBUG_BREAK(JP_CA_DEBUG_BREAK, name); \\\n+        LOG_TRACE_FUNCTION(); \\\n+        JP_TRY; \\\n+        UINT status = ca_type::Success; \\\n+        ca_type ca(hInstall, _T(#name), &status); \\\n+        LOG_TRACE(tstrings::any() << \"CA modes=[\" << ca.getModes() << \"]\"); \\\n+        name ## Body(ca); \\\n+        return status; \\\n+        JP_CATCH_ALL; \\\n+        return ca_type::FatalError; \\\n+    } \\\n+    static void name ## Body(ca_type& ca)\n+#define JP_CA(name) JP_CA_BASE(name, msi::CA)\n+#define JP_DEFERRED_CA(name) JP_CA_BASE(name, msi::DeferredCA)\n+\n+#define JP_CA_DECLARE(name) \\\n+    extern \"C\" UINT __stdcall name(MSIHANDLE); \\\n+    __pragma(comment(linker, \"\/INCLUDE:\" JP_CA_MANGLED_NAME(name)))\n+\n+#ifdef _WIN64\n+    #define JP_CA_MANGLED_NAME(name) #name\n+#else\n+    #define JP_CA_MANGLED_NAME(name) \"_\" #name \"@4\"\n+#endif\n+\n+#endif \/\/ #ifndef MsiCA_h\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/MsiCA.h","additions":298,"deletions":0,"binary":false,"changes":298,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -127,0 +127,22 @@\n+\n+\n+void debugBreak(const SourceCodePos& location, const tstring& envVarName,\n+                                                    const tstring& substr) {\n+    if (!SysInfo::isEnvVariableSet(envVarName)) {\n+        return;\n+    }\n+\n+    const tstring v = SysInfo::getEnvVariable(std::nothrow, envVarName);\n+    if (v != _T(\"*\") && v.find(substr) == tstring::npos) {\n+        return;\n+    }\n+\n+    tstring msg = tstrings::fromUtf8(makeMessage(\n+            std::runtime_error((tstrings::any()\n+                    << \"debug break. Reason: environment variable \"\n+                    << envVarName << \" is set.\").str()),\n+            location));\n+    tstring caption = FileUtils::basename(SysInfo::getCurrentModulePath());\n+\n+    MessageBoxW(NULL, msg.c_str(), caption.c_str(), MB_OK | MB_TASKMODAL);\n+}\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinErrorHandling.cpp","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,0 +49,14 @@\n+\n+\/**\n+ * Debug break. The function tests if the given environment variable is set.\n+ * If it is and value of 'substr' parameter is a substring of value of\n+ * the given environment variable message box is popped up waiting for\n+ * user input.\n+ * If value of environment variable is '*', value of 'substr' parameter is not\n+ * tested and message box is popped up unconditionally.\n+ *\/\n+void debugBreak(const SourceCodePos& location, const tstring& envVarName,\n+                                                        const tstring& substr);\n+\n+#define JP_DEBUG_BREAK(env, substr) ::debugBreak(JP_SOURCE_CODE_POS, _T(#env), _T(#substr))\n+\n","filename":"src\/jdk.jpackage\/windows\/native\/common\/WinErrorHandling.h","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <algorithm>\n+\n+#define NOMINMAX\n+#include \"Version.h\"\n+\n+\n+\n+namespace VersionDetails {\n+\n+size_t Parser::operator ()(const tstring& str, int& buffer,\n+                                                    size_t& bufferSize) const {\n+    if (bufferSize < 1) {\n+        JP_THROW(tstrings::any() << \"Destination buffer can't be empty\");\n+    }\n+\n+    tstring_array strComponents;\n+\n+    tstrings::split(strComponents, str, _T(\".\"));\n+\n+    \/\/ Temporary storage. Needed to preserve destination buffer from\n+    \/\/ partial update if parsing fails.\n+    std::vector<int> recognizedComponents;\n+\n+    tstring_array::const_iterator it = strComponents.begin();\n+    tstring_array::const_iterator end =\n+                            it + std::min(strComponents.size(), bufferSize);\n+\n+    \/\/ Number of successfully parsed characters in 'str'.\n+    size_t cursor = 0;\n+\n+    while (it != end) {\n+        const tstring& strComponent(*it);\n+\n+        try {\n+            recognizedComponents.push_back(parseComponent(strComponent));\n+        } catch (const std::exception&) {\n+            \/\/ error parsing version component\n+            break;\n+        }\n+\n+        cursor += strComponent.size();\n+        if (++it != end) {\n+            ++cursor;\n+        }\n+    }\n+\n+    if (str.size() < cursor) {\n+        \/\/ Should never happen.\n+        JP_THROW(tstrings::any()\n+                        << \"[\" << cursor << \" < \" << str.size() << \"] failed\");\n+    }\n+\n+    \/\/ Publish results only after successful parse.\n+    bufferSize = recognizedComponents.size();\n+    if (bufferSize) {\n+        memcpy(&buffer, &*recognizedComponents.begin(),\n+                                                bufferSize * sizeof(buffer));\n+    }\n+\n+    if (!strComponents.empty() && strComponents.back().size() == 0\n+                                                    && str.size() == cursor) {\n+        \/\/ Input string ends with dot character (.). Mark it as unrecognized.\n+        --cursor;\n+    }\n+\n+    return (str.size() - cursor);\n+}\n+\n+\n+int parseComponent (const tstring& str) {\n+    tistringstream input(str);\n+\n+    do {\n+        if (str.empty() || !isdigit(str[0])) {\n+            break;\n+        }\n+\n+        int reply;\n+        input >> reply;\n+\n+        if (!input.eof() || input.fail()) {\n+            break;\n+        }\n+\n+        return reply;\n+    } while (false);\n+\n+    JP_THROW(tstrings::any()\n+            << \"Failed to recognize version component in [\" << str << \"]\");\n+}\n+\n+} \/\/ namespace VersionDetails\n","filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/Version.cpp","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#ifndef Version_h\n+#define Version_h\n+\n+#include <cstring>\n+#include <stdexcept>\n+\n+#include \"tstrings.h\"\n+#include \"ErrorHandling.h\"\n+\n+\n+\n+\n+\/**\n+ * Generic version. Version is given with string.\n+ * String consists of version components separated with dot char (.).\n+ * E.g.: 1.45.6.778.89\n+ * Maximum number of components in version string is specified with 'N'\n+ * template parameter.\n+ *\/\n+\n+\n+namespace VersionDetails {\n+\n+struct Parser {\n+    \/**\n+     * Parses version components from the given string.\n+     * Returns number of trailing unrecognised characters or 0 if the whole\n+     * string has been recognized.\n+     *\n+     *  @param str\n+     *      string to parse;\n+     *  @param buffer\n+     *      reference to buffer accepting parsed version components;\n+     *  @param bufferSize[in,out]\n+     *      number of elements in the destination buffer; on return is set\n+     *      a number of components recognized in the input string.\n+     *\/\n+    size_t operator () (const tstring& str, int& buffer,\n+                                                    size_t& bufferSize) const;\n+};\n+\n+\n+\/**\n+ * Returns parsed single version component from the given string.\n+ * Throws std::exception if error occurs parsing the given string.\n+ *\n+ *  @param str\n+ *      string to parse;\n+ *\/\n+int parseComponent (const tstring& str);\n+\n+\n+template <int N, class Parser, int MinComponentCount=0>\n+class Base {\n+public:\n+    enum { ComponentCount = N };\n+    Base() {\n+        memset(components, 0, sizeof(components));\n+    }\n+\n+private:\n+    bool verifyComponentCount(size_t recognizedComponentCount) const {\n+        return true;\n+    }\n+\n+protected:\n+    void init(const tstring& str) {\n+        size_t recognizedComponentCount = N;\n+        const size_t unrecognisedChars = Parser()(str, *components,\n+                                                    recognizedComponentCount);\n+        if (unrecognisedChars) {\n+            JP_THROW(tstrings::any()\n+                    << \"Failed to parse [\" << str << \"] version string completely.\"\n+                    << \" Number of unrecognized characters is \" << unrecognisedChars);\n+        }\n+\n+        if (recognizedComponentCount < MinComponentCount || !verifyComponentCount(recognizedComponentCount)) {\n+            \/\/ Input string is too short.\n+            JP_THROW(tstrings::any() << \"Failed to parse [\" << str\n+                                      << \"] version string. The string is too short\");\n+\n+        }\n+        strValue = str;\n+    }\n+\n+public:\n+    const tstring& source() const {\n+        return strValue;\n+    }\n+\n+    bool operator < (const Base& other) const {\n+        for (int i = 0; i < N; ++i) {\n+            const int a = components[i];\n+            const int b = other.components[i];\n+            if (a < b) {\n+                return true;\n+            }\n+            if (b < a) {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    bool operator <= (const Base& other) const {\n+        return *this == other || *this < other;\n+    }\n+\n+    bool operator > (const Base& other) const {\n+        return ! (*this <= other);\n+    }\n+\n+    bool operator >= (const Base& other) const {\n+        return ! (*this < other);\n+    }\n+\n+    bool operator == (const Base& other) const {\n+        return (0 == memcmp(components, other.components, sizeof(components)));\n+    }\n+\n+    bool operator != (const Base& other) const {\n+        return ! (*this == other);\n+    }\n+\n+protected:\n+    int components[N];\n+\n+private:\n+    tstring strValue;\n+};\n+\n+} \/\/ namespace VersionDetails\n+\n+\n+template <class Base>\n+struct Version: public Base {\n+    Version() {\n+    }\n+\n+    explicit Version(const tstring& str) {\n+        Base::init(str);\n+    }\n+\n+    Version(const Base& other): Base(other) {\n+    }\n+};\n+\n+#endif \/\/ #ifndef Version_h\n","filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/Version.h","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,3 +26,0 @@\n-#include <Windows.h>\n-#include <msiquery.h>\n-#include <shlwapi.h>\n@@ -30,1 +27,5 @@\n-extern \"C\" {\n+#include \"MsiDb.h\"\n+#include \"MsiCA.h\"\n+#include \"Version.h\"\n+#include \"FileUtils.h\"\n+#include \"WinErrorHandling.h\"\n@@ -32,4 +33,0 @@\n-#ifdef JP_EXPORT_FUNCTION\n-#error Unexpected JP_EXPORT_FUNCTION define\n-#endif\n-#define JP_EXPORT_FUNCTION comment(linker, \"\/EXPORT:\" __FUNCTION__ \"=\" __FUNCDNAME__)\n@@ -37,3 +34,6 @@\n-    BOOL WINAPI DllMain(HINSTANCE hInst, ULONG ulReason,\n-            LPVOID lpvReserved) {\n-        return TRUE;\n+JP_CA(CheckInstallDir) {\n+    const tstring installDir = ca.getProperty(_T(\"INSTALLDIR\"));\n+\n+    bool canProceed = !FileUtils::isFileExists(installDir);\n+    if (!canProceed && FileUtils::isDirectory(installDir)) {\n+        canProceed = !FileUtils::isDirectoryNotEmpty(installDir);\n@@ -42,5 +42,2 @@\n-    BOOL DirectoryExist(TCHAR *szValue) {\n-        DWORD attr = GetFileAttributes(szValue);\n-        if (attr == INVALID_FILE_ATTRIBUTES) {\n-            return FALSE;\n-        }\n+    ca.setProperty(_T(\"INSTALLDIR_VALID\"), canProceed ? _T(\"1\") : _T(\"0\"));\n+}\n@@ -48,3 +45,0 @@\n-        if (attr & FILE_ATTRIBUTE_DIRECTORY) {\n-            return TRUE;\n-        }\n@@ -52,1 +46,11 @@\n-        return FALSE;\n+namespace {\n+\n+typedef Version<\n+    VersionDetails::Base<10, VersionDetails::Parser, 2>\n+> DottedVersion;\n+\n+\n+class ProductInfo {\n+public:\n+    explicit ProductInfo(const Guid& pc): productCode(pc),\n+            version(msi::getProductInfo(pc, INSTALLPROPERTY_VERSIONSTRING)) {\n@@ -55,2 +59,3 @@\n-    UINT __stdcall CheckInstallDir(MSIHANDLE hInstall) {\n-        #pragma JP_EXPORT_FUNCTION\n+    const DottedVersion& getVersion() const {\n+        return version;\n+    }\n@@ -58,2 +63,3 @@\n-        TCHAR *szValue = NULL;\n-        DWORD cchSize = 0;\n+    const Guid& getProductCode() const {\n+        return productCode;\n+    }\n@@ -61,10 +67,28 @@\n-        UINT result = MsiGetProperty(hInstall, TEXT(\"INSTALLDIR\"),\n-                (LPTSTR)TEXT(\"\"), &cchSize);\n-        if (result == ERROR_MORE_DATA) {\n-            cchSize = cchSize + 1; \/\/ NULL termination\n-            szValue = new TCHAR[cchSize];\n-            if (szValue) {\n-                result = MsiGetProperty(hInstall, TEXT(\"INSTALLDIR\"),\n-                        szValue, &cchSize);\n-            } else {\n-                return ERROR_INSTALL_FAILURE;\n+private:\n+    Guid productCode;\n+    DottedVersion version;\n+};\n+\n+\n+void findInstalledPackages(const Guid& upgradeCode,\n+                                            std::vector<ProductInfo>& products) {\n+    const LPCTSTR upgradeCodeStr = upgradeCode.toMsiString().c_str();\n+    for (DWORD productCodeIdx = 0; true; ++productCodeIdx) {\n+        TCHAR productCode[39 \/* http:\/\/msdn.microsoft.com\/en-us\/library\/aa370101(v=vs.85).aspx *\/];\n+        const UINT status = MsiEnumRelatedProducts(upgradeCodeStr, 0,\n+                                              productCodeIdx, productCode);\n+        if (ERROR_NO_MORE_ITEMS == status) {\n+            break;\n+        }\n+\n+        if (ERROR_SUCCESS == status) {\n+            LOG_TRACE(tstrings::any() << \"Found \" << productCode << \" product\");\n+            JP_NO_THROW(products.push_back(ProductInfo(Guid(productCode))));\n+        } else {\n+            LOG_WARNING(tstrings::any()\n+                        << \"MsiEnumRelatedProducts(\"\n+                        << upgradeCodeStr << \", \"\n+                        << productCodeIdx\n+                        << \") failed with error=[\" << status << \"]\");\n+            if (ERROR_INVALID_PARAMETER == status) {\n+                break;\n@@ -73,0 +97,10 @@\n+    }\n+}\n+\n+DottedVersion getDottedVersion(const msi::DatabaseRecord& record, UINT idx) {\n+    if (!MsiRecordIsNull(record.getHandle(), idx)) {\n+        JP_NO_THROW(return DottedVersion(record.getString(idx)));\n+    }\n+\n+    return DottedVersion();\n+}\n@@ -74,3 +108,46 @@\n-        if (result != ERROR_SUCCESS) {\n-            delete [] szValue;\n-            return ERROR_INSTALL_FAILURE;\n+bool dbContainsUpgradeTable(const msi::Database &db) {\n+    msi::DatabaseView view(db,\n+                    _T(\"SELECT Name FROM _Tables WHERE Name = 'Upgrade'\"));\n+    msi::DatabaseRecord record;\n+    while (!record.tryFetch(view).empty()) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+} \/\/ namespace\n+\n+JP_CA(FindRelatedProductsEx) {\n+    if (ca.isInMode(MSIRUNMODE_MAINTENANCE)) {\n+        \/\/ MSI skips tha standard FindRelatedProducts action is in maintenance mode,\n+        \/\/ so should we do for custom FindRelatedProducts action\n+        LOG_TRACE(\"Not run in maintenance mode\");\n+        return;\n+    }\n+\n+    const msi::Database db(ca);\n+    if (!dbContainsUpgradeTable(db)) {\n+        LOG_TRACE(\"The package doesn't contain Upgrade table\");\n+        return;\n+    }\n+\n+    const Guid upgradeCode = Guid(ca.getProperty(_T(\"UpgradeCode\")));\n+\n+    std::vector<ProductInfo> installedProducts;\n+    findInstalledPackages(upgradeCode, installedProducts);\n+\n+    bool migratePropRemoved = false;\n+\n+    \/\/ https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/adsi\/sql-dialect\n+    msi::DatabaseView view(db, (tstrings::any()\n+            << _T(\"SELECT `VersionMin`,`VersionMax`,`Attributes`,`ActionProperty` FROM Upgrade WHERE `ActionProperty` <> NULL And `UpgradeCode` = '\")\n+            << upgradeCode.toMsiString() << _T(\"'\")).tstr());\n+    msi::DatabaseRecord record;\n+    while (!record.tryFetch(view).empty()) {\n+        const tstring actionProperty = record.getString(4);\n+\n+        \/\/ Clean up properties set by the standard FindRelatedProducts action\n+        ca.removeProperty(actionProperty);\n+        if (!migratePropRemoved) {\n+            ca.removeProperty(_T(\"MIGRATE\"));\n+            migratePropRemoved = true;\n@@ -79,3 +156,16 @@\n-        if (DirectoryExist(szValue)) {\n-            if (PathIsDirectoryEmpty(szValue)) {\n-                MsiSetProperty(hInstall, TEXT(\"INSTALLDIR_VALID\"), TEXT(\"1\"));\n+        const DottedVersion versionMin = getDottedVersion(record, 1);\n+        const DottedVersion versionMax = getDottedVersion(record, 2);\n+\n+        const int attrs = MsiRecordIsNull(\n+                          record.getHandle(), 3) ? 0 : record.getInteger(3);\n+\n+        std::vector<ProductInfo>::const_iterator productIt =\n+                                                installedProducts.begin();\n+        std::vector<ProductInfo>::const_iterator productEnd =\n+                                                installedProducts.end();\n+        for (; productIt != productEnd; ++productIt) {\n+            bool minMatch;\n+            if (versionMin.source().empty()) {\n+                minMatch = true;\n+            } else if (attrs & msidbUpgradeAttributesVersionMinInclusive) {\n+                minMatch = (versionMin <= productIt->getVersion());\n@@ -83,1 +173,1 @@\n-                MsiSetProperty(hInstall, TEXT(\"INSTALLDIR_VALID\"), TEXT(\"0\"));\n+                minMatch = (versionMin < productIt->getVersion());\n@@ -85,3 +175,0 @@\n-        } else {\n-            MsiSetProperty(hInstall, TEXT(\"INSTALLDIR_VALID\"), TEXT(\"1\"));\n-        }\n@@ -89,1 +176,8 @@\n-        delete [] szValue;\n+            bool maxMatch;\n+            if (versionMax.source().empty()) {\n+                maxMatch = true;\n+            } else if (attrs & msidbUpgradeAttributesVersionMaxInclusive) {\n+                maxMatch = (productIt->getVersion() <= versionMax);\n+            } else {\n+                maxMatch = (productIt->getVersion() < versionMax);\n+            }\n@@ -91,1 +185,11 @@\n-        return ERROR_SUCCESS;\n+            if (minMatch && maxMatch) {\n+                tstring value = productIt->getProductCode().toMsiString();\n+                ca.setProperty(actionProperty, value);\n+                ca.setProperty(_T(\"MIGRATE\"), value);\n+                \/\/ Bail out after the first match as action\n+                \/\/ property has been set already.\n+                \/\/ There is no way to communicate multiple product codes\n+                \/\/ through a single property.\n+                break;\n+            }\n+        }\n","filename":"src\/jdk.jpackage\/windows\/native\/libwixhelper\/libwixhelper.cpp","additions":151,"deletions":47,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -334,1 +334,1 @@\n-    public final static class Group extends RunnablePackageTest {\n+    public static class Group extends RunnablePackageTest {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,2 @@\n-            if (hasAction(Action.PURGE) && !actionList.contains(Action.PURGE)) {\n+            if (hasAction(Action.PURGE) && (!actionList.contains(Action.PURGE)\n+                    && actionList.contains(Action.CREATE))) {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/RunnablePackageTest.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+var msi;\n+if (WScript.Arguments.Count() > 0) {\n+  msi = WScript.Arguments(0)\n+} else {\n+  var shell = new ActiveXObject('WScript.Shell')\n+  msi = shell.ExpandEnvironmentStrings('%JpMsiFile%')\n+}\n+\n+var query = \"SELECT `UpgradeCode`, `VersionMin`,`VersionMax`,`Language`,`Attributes`,`Remove`,`ActionProperty` FROM Upgrade WHERE `VersionMax` = NULL\"\n+\n+var installer = new ActiveXObject('WindowsInstaller.Installer');\n+var database = installer.OpenDatabase(msi, 1)\n+var view = database.OpenView(query);\n+view.Execute();\n+\n+try {\n+  var record = view.Fetch();\n+  record.StringData(2) = '2.0.0.3'\n+  record.IntegerData(5) = 257\n+  view.Modify(6, record)\n+  view.Modify(3, record)\n+  database.Commit();\n+} finally {\n+   view.Close();\n+}\n","filename":"test\/jdk\/tools\/jpackage\/resources\/WinLongVersionTest-edit-msi.js","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Supplier;\n+import javax.xml.transform.Result;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathFactory;\n+import jdk.jpackage.internal.IOUtils;\n+import jdk.jpackage.test.Annotations.Test;\n+import jdk.jpackage.test.Executor;\n+import jdk.jpackage.test.PackageTest;\n+import jdk.jpackage.test.PackageType;\n+import jdk.jpackage.test.RunnablePackageTest.Action;\n+import jdk.jpackage.test.TKit;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.NodeList;\n+\n+\/**\n+ * Test --app-version parameter properly supports long version numbers, i.e.\n+ * version numbers with more than three components.\n+ * Output of the test should be WinLongVersionTest-1.0.exe,\n+ * WinLongVersionTest-2.0.0.1.exe, and WinLongVersionTest-2.0.0.2.exe installers.\n+ * The output installers should provide the same functionality as\n+ * the default installer (see description of the default installer in\n+ * SimplePackageTest.java) but have the same product code and different\n+ * versions.\n+ * Test scenario:\n+ *  - Run WinLongVersionTest-2.0.0.2.exe;\n+ *  - Run WinLongVersionTest-1.0.exe; package installed with\n+ *    WinLongVersionTest-2.0.0.2.exe command must remain installed\n+ *  - Run WinLongVersionTest-2.0.0.1.exe; packages installed with\n+ *    WinLongVersionTest-2.0.0.2.exe and WinLongVersionTest-1.0.exe installers\n+ *    must be automatically uninstalled, only WinLongVersionTest-2.0.0.1 package\n+ *    must remain installed\n+ *  - Uninstall WinLongVersionTest-2.0.0.2; all packages installed in the test\n+ *    scenario must be uninstalled\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with long version number\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @requires (jpackage.test.SQETest != null)\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"windows\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile WinLongVersionTest.java\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=WinLongVersionTest.test\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary jpackage with long version number\n+ * @library ..\/helpers\n+ * @key jpackagePlatformPackage\n+ * @requires (jpackage.test.SQETest == null)\n+ * @build jdk.jpackage.test.*\n+ * @requires (os.family == \"windows\")\n+ * @modules jdk.jpackage\/jdk.jpackage.internal\n+ * @compile WinLongVersionTest.java\n+ * @run main\/othervm\/timeout=540 -Xmx512m jdk.jpackage.test.Main\n+ *  --jpt-run=WinLongVersionTest\n+ *\/\n+\n+public class WinLongVersionTest {\n+\n+    @Test\n+    public static void test() throws IOException {\n+        Supplier<PackageTest> init = () -> {\n+            final UUID upgradeCode = UUID.fromString(\n+                    \"65099D7A-D5B1-4E5B-85B1-717F0DE4D5D5\");\n+            return new PackageTest()\n+                .forTypes(PackageType.WINDOWS)\n+                .configureHelloApp()\n+                .addInitializer(cmd -> cmd.addArguments(\"--win-upgrade-uuid\",\n+                        upgradeCode.toString())) ;\n+\n+        };\n+\n+        PackageTest test1 = init.get().addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--app-version\", \"2.0.0.2\");\n+            cmd.setArgumentValue(\"--arguments\", \"bar\");\n+            cmd.setArgumentValue(\"--install-dir\", cmd.name() + \"-1\");\n+        });\n+\n+        \/\/ Tweak Upgrade table of the second package in a way the default\n+        \/\/ FindRelatedProducts MSI action will find 1st package, but custom\n+        \/\/ jpackage's FindRelatedProductsEx action will not as it gracefuly\n+        \/\/ handles more than 3 components of version strings.\n+        \/\/ In MSI log of the 2nd package installartion session it will be something like:\n+        \/*\n+        Action start 12:08:38: FindRelatedProducts.\n+        FindRelatedProducts: Found application: {D88EEA02-56CC-34AD-8216-C2CC244FA898}\n+        MSI (c) (0C:14) [12:08:38:040]: PROPERTY CHANGE: Adding JP_DOWNGRADABLE_FOUND property. Its value is '{D88EEA02-56CC-34AD-8216-C2CC244FA898}'.\n+        MSI (c) (0C:14) [12:08:38:040]: PROPERTY CHANGE: Adding MIGRATE property. Its value is '{D88EEA02-56CC-34AD-8216-C2CC244FA898}'.\n+        Action ended 12:08:38: FindRelatedProducts. Return value 1.\n+        ...\n+        Action start 12:08:38: JpFindRelatedProducts.\n+        Java [12:08:38.180 libwixhelper.cpp:120 (FindRelatedProductsEx)] TRACE: Entering FindRelatedProductsEx\n+        Java [12:08:38.185 libwixhelper.cpp:85 (`anonymous-namespace'::findInstalledPackages)] TRACE: Found {D88EEA02-56CC-34AD-8216-C2CC244FA898} product\n+        Java [12:08:38.187 MsiCA.cpp:61 (msi::CAImpl::removeProperty)] TRACE: Removing MSI property 'JP_UPGRADABLE_FOUND'\n+        Java [12:08:38.187 MsiCA.cpp:61 (msi::CAImpl::removeProperty)] TRACE: Removing MSI property 'MIGRATE'\n+        Java [12:08:38.189 MsiCA.cpp:61 (msi::CAImpl::removeProperty)] TRACE: Removing MSI property 'JP_DOWNGRADABLE_FOUND'\n+        Java [12:08:38.190 libwixhelper.cpp:0 (FindRelatedProductsEx)] TRACE: Exiting FindRelatedProductsEx (entered at libwixhelper.cpp:120)\n+        Action ended 12:08:38: JpFindRelatedProducts. Return value 1.\n+        *\/\n+        PackageTest test2 = init.get().addInstallVerifier(cmd -> {\n+            if (!cmd.isPackageUnpacked()) {\n+                \/\/ Installation of this package must NOT uninstall\n+                \/\/ previously installed package. Verify that.\n+                test1.run(Action.VERIFY_INSTALL);\n+            }\n+        }).forTypes(PackageType.WIN_EXE)\n+        .addInitializer(cmd -> {\n+            final Path resourceDir = TKit.createTempDirectory(\"resources\");\n+            cmd.addArguments(\"--resource-dir\", resourceDir);\n+\n+            Path scriptPath = resourceDir.resolve(String.format(\n+                    \"%s-post-msi.wsf\", cmd.name()));\n+            IOUtils.createXml(scriptPath, xml -> {\n+                xml.writeStartElement(\"job\");\n+                xml.writeAttribute(\"id\", \"main\");\n+                xml.writeStartElement(\"script\");\n+                xml.writeAttribute(\"language\", \"JScript\");\n+                xml.writeCData(String.join(\"\\n\", Files.readAllLines(\n+                        TKit.TEST_SRC_ROOT.resolve(String.format(\n+                                \"resources\/%s-edit-msi.js\", cmd.name())))));\n+                xml.writeEndElement();\n+                xml.writeEndElement();\n+            });\n+        }).forTypes(PackageType.WIN_MSI)\n+        .addBundleVerifier(cmd -> {\n+            Executor.of(\"cscript.exe\", \"\/\/Nologo\")\n+                    .addArgument(TKit.TEST_SRC_ROOT.resolve(String.format(\n+                            \"resources\/%s-edit-msi.js\", cmd.name())))\n+                    .addArgument(cmd.outputBundle())\n+                    .execute();\n+        });\n+\n+        \/\/ Replace real uninstall commands for the first packages with nop action.\n+        \/\/ They will be uninstalled automatically when the last package will\n+        \/\/ be installed.\n+        test1.disablePackageUninstaller();\n+        test2.disablePackageUninstaller();\n+\n+        PackageTest test3 = init.get().addInitializer(cmd -> {\n+            cmd.setArgumentValue(\"--app-version\", \"2.0.0.1\");\n+            cmd.setArgumentValue(\"--arguments\", \"buzz\");\n+        });\n+\n+        new PackageTest.Group(test1, test2, test3).run();\n+    }\n+\n+    @Test\n+    public static void testNoUpgradeTable() throws IOException {\n+        new PackageTest()\n+        .forTypes(PackageType.WINDOWS)\n+        .configureHelloApp()\n+        .addInitializer(cmd -> {\n+            final Path resourceDir = TKit.createTempDirectory(\"resources\");\n+            cmd.addArguments(\"--resource-dir\", resourceDir);\n+\n+            cmd.setFakeRuntime();\n+\n+            \/\/ Create package without Upgrade table\n+            Document doc = IOUtils.initDocumentBuilder().parse(\n+                    Files.newInputStream(TKit.SRC_ROOT.resolve(\n+                            \"windows\/classes\/jdk\/jpackage\/internal\/resources\/main.wxs\")));\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            NodeList nodes = (NodeList) xPath.evaluate(\"\/Wix\/Product\/Upgrade\",\n+                    doc, XPathConstants.NODESET);\n+            nodes.item(0).getParentNode().removeChild(nodes.item(0));\n+\n+            Source source = new DOMSource(doc);\n+            Result result = new StreamResult(Files.newOutputStream(\n+                    resourceDir.resolve(\"main.wxs\")));\n+\n+            Transformer trans = TransformerFactory.newInstance().newTransformer();\n+            trans.transform(source, result);\n+        }).run();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/windows\/WinLongVersionTest.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"}]}