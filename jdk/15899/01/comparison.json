{"files":[{"patch":"@@ -1793,0 +1793,5 @@\n+  INSN(vsse8_v,  0b0100111, 0b000, 0b10, 0b0);\n+  INSN(vsse16_v, 0b0100111, 0b101, 0b10, 0b0);\n+  INSN(vsse32_v, 0b0100111, 0b110, 0b10, 0b0);\n+  INSN(vsse64_v, 0b0100111, 0b111, 0b10, 0b0);\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1292,0 +1292,7 @@\n+  \/\/ rotate vector register left with shift bits, 32-bit version\n+  inline void vrol_vwi(VectorRegister vd, uint32_t shift, VectorRegister tmp_vr) {\n+    vsrl_vi(tmp_vr, vd, 32 - shift);\n+    vsll_vi(vd, vd, shift);\n+    vor_vv(vd, vd, tmp_vr);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -4280,0 +4280,117 @@\n+  void chacha20_quarter_round(VectorRegister aVec, VectorRegister bVec,\n+                          VectorRegister cVec, VectorRegister dVec, VectorRegister tmp_vr) {\n+    \/\/ a += b, d ^= a, d <<<= 16\n+    __ vadd_vv(aVec, aVec, bVec);\n+    __ vxor_vv(dVec, dVec, aVec);\n+    __ vrol_vwi(dVec, 16, tmp_vr);\n+\n+    \/\/ rev32(dVec, T8H, dVec);\n+\n+    \/\/ c += d, b ^= c, b <<<= 12\n+    __ vadd_vv(cVec, cVec, dVec);\n+    __ vxor_vv(bVec, bVec, cVec);\n+    __ vrol_vwi(bVec, 12, tmp_vr);\n+\n+    \/\/ a += b, d ^= a, d <<<= 8\n+    __ vadd_vv(aVec, aVec, bVec);\n+    __ vxor_vv(dVec, dVec, aVec);\n+    __ vrol_vwi(dVec, 8, tmp_vr);\n+\n+    \/\/ c += d, b ^= c, b <<<= 7\n+    __ vadd_vv(cVec, cVec, dVec);\n+    __ vxor_vv(bVec, bVec, cVec);\n+    __ vrol_vwi(bVec, 7, tmp_vr);\n+  }\n+\n+  \/**\n+   * int com.sun.crypto.provider.ChaCha20Cipher.implChaCha20Block(int[] initState, byte[] result)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - state, the starting state\n+   *  c_rarg1   - key_stream, the array that will hold the result of the ChaCha20 block function\n+   *\/\n+  address generate_chacha20Block() {\n+    Label L_Rounds;\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"chacha20Block\");\n+    address start = __ pc();\n+\n+    const int states_len = 16;\n+    const int step = 4;\n+    const Register state = c_rarg0;\n+    const Register key_stream = c_rarg1;\n+    const Register length = t0;\n+    const Register tmp_addr = t1;\n+\n+    const VectorRegister work_vrs[16] = {\n+      v4,  v5,  v6,  v7,  v16, v17, v18, v19,\n+      v20, v21, v22, v23, v24, v25, v26, v27\n+    };\n+    const VectorRegister tmp_vr = v29;\n+    const VectorRegister counter = v30;\n+\n+    {\n+      const Register avl = t2; \/\/ share t2 with other non-overlapping usages.\n+      \/\/ Put 16 here, as com.sun.crypto.providerChaCha20Cipher.KS_MAX_LEN is 1024\n+      \/\/ in java level.\n+      __ mv(avl, 16);\n+      __ vsetvli(length, avl, Assembler::e32, Assembler::m1);\n+    }\n+\n+    \/\/ Load from source state\n+    __ mv(tmp_addr, state);\n+    for (int i = 0; i < states_len; i += 1) {\n+      __ vlse32_v(work_vrs[i], tmp_addr, zr);\n+      __ addi(tmp_addr, tmp_addr, step);\n+    }\n+    __ vid_v(counter);\n+    __ vadd_vv(work_vrs[12], work_vrs[12], counter);\n+\n+    \/\/ Perform 10 iterations of the 8 quarter round set\n+    {\n+      const Register loop = t2; \/\/ share t2 with other non-overlapping usages.\n+      __ mv(loop, 10);\n+      __ BIND(L_Rounds);\n+\n+      chacha20_quarter_round(work_vrs[0], work_vrs[4], work_vrs[8], work_vrs[12], tmp_vr);\n+      chacha20_quarter_round(work_vrs[1], work_vrs[5], work_vrs[9], work_vrs[13], tmp_vr);\n+      chacha20_quarter_round(work_vrs[2], work_vrs[6], work_vrs[10], work_vrs[14], tmp_vr);\n+      chacha20_quarter_round(work_vrs[3], work_vrs[7], work_vrs[11], work_vrs[15], tmp_vr);\n+\n+      chacha20_quarter_round(work_vrs[0], work_vrs[5], work_vrs[10], work_vrs[15], tmp_vr);\n+      chacha20_quarter_round(work_vrs[1], work_vrs[6], work_vrs[11], work_vrs[12], tmp_vr);\n+      chacha20_quarter_round(work_vrs[2], work_vrs[7], work_vrs[8], work_vrs[13], tmp_vr);\n+      chacha20_quarter_round(work_vrs[3], work_vrs[4], work_vrs[9], work_vrs[14], tmp_vr);\n+\n+      __ sub(loop, loop, 1);\n+      __ bnez(loop, L_Rounds);\n+    }\n+\n+    \/\/ Add the end working state back into the original state\n+    __ mv(tmp_addr, state);\n+    for (int i = 0; i < states_len; i += 1) {\n+      __ vlse32_v(tmp_vr, tmp_addr, zr);\n+      __ addi(tmp_addr, tmp_addr, step);\n+      __ vadd_vv(work_vrs[i], work_vrs[i], tmp_vr);\n+    }\n+    __ vadd_vv(work_vrs[12], work_vrs[12], counter);\n+\n+    \/\/ Store result to key stream\n+    {\n+      const Register stride = t2; \/\/ share t2 with other non-overlapping usages.\n+      __ mv(stride, 64);\n+      for (int i = 0; i < states_len; i += 1) {\n+        __ vsse32_v(work_vrs[i], key_stream, stride);\n+        __ addi(key_stream, key_stream, step);\n+      }\n+    }\n+\n+    \/\/ Return length of output key_stream\n+    __ slli(c_rarg0, length, 6);\n+\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -4499,0 +4616,5 @@\n+\n+    if (UseChaCha20Intrinsics) {\n+      StubRoutines::_chacha20Block = generate_chacha20Block();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":122,"deletions":0,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -251,0 +251,10 @@\n+  if (UseRVV) {\n+    if (FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      FLAG_SET_DEFAULT(UseChaCha20Intrinsics, true);\n+    }\n+  } else if (UseChaCha20Intrinsics) {\n+    if (!FLAG_IS_DEFAULT(UseChaCha20Intrinsics)) {\n+      warning(\"Chacha20 Intrinsics requires RVV instructions (not available on this CPU)\");\n+    }\n+    FLAG_SET_DEFAULT(UseChaCha20Intrinsics, false);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"}]}