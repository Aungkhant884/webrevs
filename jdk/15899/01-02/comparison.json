{"files":[{"patch":"@@ -1293,1 +1293,1 @@\n-  inline void vrol_vwi(VectorRegister vd, uint32_t shift, VectorRegister tmp_vr) {\n+  inline void vrole32_vi(VectorRegister vd, uint32_t shift, VectorRegister tmp_vr) {\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -4280,0 +4280,9 @@\n+  \/**\n+   * Perform the quarter round calculations on values contained within four vector registers.\n+   *\n+   * @param aVec the SIMD register containing only the \"a\" values\n+   * @param bVec the SIMD register containing only the \"b\" values\n+   * @param cVec the SIMD register containing only the \"c\" values\n+   * @param dVec the SIMD register containing only the \"d\" values\n+   * @param tmp_vr temporary vector register holds intermedia values.\n+   *\/\n@@ -4285,3 +4294,1 @@\n-    __ vrol_vwi(dVec, 16, tmp_vr);\n-\n-    \/\/ rev32(dVec, T8H, dVec);\n+    __ vrole32_vi(dVec, 16, tmp_vr);\n@@ -4292,1 +4299,1 @@\n-    __ vrol_vwi(bVec, 12, tmp_vr);\n+    __ vrole32_vi(bVec, 12, tmp_vr);\n@@ -4297,1 +4304,1 @@\n-    __ vrol_vwi(dVec, 8, tmp_vr);\n+    __ vrole32_vi(dVec, 8, tmp_vr);\n@@ -4302,1 +4309,1 @@\n-    __ vrol_vwi(bVec, 7, tmp_vr);\n+    __ vrole32_vi(bVec, 7, tmp_vr);\n@@ -4311,0 +4318,4 @@\n+   *\n+   *  Implementation Note:\n+   *   Parallelization is achieved by loading individual state elements into vectors for N blocks.\n+   *   N depends on single vector register length.\n@@ -4318,0 +4329,1 @@\n+    __ enter();\n@@ -4323,2 +4335,2 @@\n-    const Register length = t0;\n-    const Register tmp_addr = t1;\n+    const Register tmp_addr = t0;\n+    const Register length = t1;\n@@ -4326,0 +4338,2 @@\n+    \/\/ Organize vector registers in an array that facilitates\n+    \/\/ putting repetitive opcodes into loop structures below.\n@@ -4327,2 +4341,2 @@\n-      v4,  v5,  v6,  v7,  v16, v17, v18, v19,\n-      v20, v21, v22, v23, v24, v25, v26, v27\n+      v0, v1, v2,  v3,  v4,  v5,  v6,  v7,\n+      v8, v9, v10, v11, v12, v13, v14, v15\n@@ -4330,2 +4344,2 @@\n-    const VectorRegister tmp_vr = v29;\n-    const VectorRegister counter = v30;\n+    const VectorRegister tmp_vr = v16;\n+    const VectorRegister counter = v17;\n@@ -4334,1 +4348,0 @@\n-      const Register avl = t2; \/\/ share t2 with other non-overlapping usages.\n@@ -4337,2 +4350,1 @@\n-      __ mv(avl, 16);\n-      __ vsetvli(length, avl, Assembler::e32, Assembler::m1);\n+      __ vsetivli(length, 16, Assembler::e32, Assembler::m1);\n@@ -4341,1 +4353,2 @@\n-    \/\/ Load from source state\n+    \/\/ Load from source state.\n+    \/\/ Every element in source state is duplicated to all elements in the corresponding vector.\n@@ -4347,0 +4360,1 @@\n+    \/\/ Adjust counter for every individual block.\n@@ -4370,1 +4384,3 @@\n-    \/\/ Add the end working state back into the original state\n+    \/\/ Add the original state into the end working state.\n+    \/\/ We do this by first duplicating every element in source state array to the corresponding\n+    \/\/ vector, then adding it to the post-loop working state.\n@@ -4377,0 +4393,1 @@\n+    \/\/ Add the counter overlay onto work_vrs[12] at the end.\n@@ -4379,1 +4396,1 @@\n-    \/\/ Store result to key stream\n+    \/\/ Store result to key stream.\n@@ -4382,0 +4399,1 @@\n+      \/\/ Every block occupies 64 bytes, so we use 64 as stride of the vector store.\n@@ -4392,0 +4410,1 @@\n+    __ leave();\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":37,"deletions":18,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-      warning(\"Chacha20 Intrinsics requires RVV instructions (not available on this CPU)\");\n+      warning(\"Chacha20 intrinsic requires RVV instructions (not available on this CPU)\");\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}