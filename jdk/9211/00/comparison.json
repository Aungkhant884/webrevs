{"files":[{"patch":"@@ -831,1 +831,1 @@\n-static bool is_con_M1(Node* n) {\n+static bool is_con(Node* n, long con) {\n@@ -834,1 +834,1 @@\n-    if (t->isa_int() && t->is_int()->get_con() == -1) {\n+    if (t->isa_int() && t->is_int()->get_con() == (int)con) {\n@@ -837,1 +837,1 @@\n-    if (t->isa_long() && t->is_long()->get_con() == -1) {\n+    if (t->isa_long() && t->is_long()->get_con() == con) {\n@@ -844,0 +844,1 @@\n+\/\/ Return true if every bit in this vector is 1.\n@@ -850,1 +851,16 @@\n-    return is_con_M1(n->in(1));\n+  case Op_MaskAll:\n+    return is_con(n->in(1), -1);\n+  default:\n+    return false;\n+  }\n+}\n+\n+\/\/ Return true if every bit in this vector is 0.\n+bool VectorNode::is_all_zeros_vector(Node* n) {\n+  switch (n->Opcode()) {\n+  case Op_ReplicateB:\n+  case Op_ReplicateS:\n+  case Op_ReplicateI:\n+  case Op_ReplicateL:\n+  case Op_MaskAll:\n+    return is_con(n->in(1), 0);\n@@ -1778,0 +1794,89 @@\n+Node* AndVNode::Identity(PhaseGVN* phase) {\n+  \/\/ (AndV src (Replicate m1))   => src\n+  \/\/ (AndVMask src (MaskAll m1)) => src\n+  if (VectorNode::is_all_ones_vector(in(2))) {\n+    return in(1);\n+  }\n+  \/\/ (AndV (Replicate zero) src)   => (Replicate zero)\n+  \/\/ (AndVMask (MaskAll zero) src) => (MaskAll zero)\n+  if (VectorNode::is_all_zeros_vector(in(1))) {\n+    return in(1);\n+  }\n+  \/\/ The following transformations are only applied to\n+  \/\/ the un-predicated operation, since the VectorAPI\n+  \/\/ masked operation requires the unmasked lanes to\n+  \/\/ save the same values in the first operand.\n+  if (!is_predicated_vector()) {\n+    \/\/ (AndV (Replicate m1) src)   => src\n+    \/\/ (AndVMask (MaskAll m1) src) => src\n+    if (VectorNode::is_all_ones_vector(in(1))) {\n+      return in(2);\n+    }\n+    \/\/ (AndV src (Replicate zero))   => (Replicate zero)\n+    \/\/ (AndVMask src (MaskAll zero)) => (MaskAll zero)\n+    if (VectorNode::is_all_zeros_vector(in(2))) {\n+      return in(2);\n+    }\n+  }\n+\n+  \/\/ (AndV src src)     => src\n+  \/\/ (AndVMask src src) => src\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* OrVNode::Identity(PhaseGVN* phase) {\n+  \/\/ (OrV (Replicate m1) src)   => (Replicate m1)\n+  \/\/ (OrVMask (MaskAll m1) src) => (MaskAll m1)\n+  if (VectorNode::is_all_ones_vector(in(1))) {\n+    return in(1);\n+  }\n+  \/\/ (OrV src (Replicate zero))   => src\n+  \/\/ (OrVMask src (MaskAll zero)) => src\n+  if (VectorNode::is_all_zeros_vector(in(2))) {\n+    return in(1);\n+  }\n+  \/\/ The following transformations are only applied to\n+  \/\/ the un-predicated operation, since the VectorAPI\n+  \/\/ masked operation requires the unmasked lanes to\n+  \/\/ save the same values in the first operand.\n+  if (!is_predicated_vector()) {\n+    \/\/ (OrV src (Replicate m1))   => (Replicate m1)\n+    \/\/ (OrVMask src (MaskAll m1)) => (MaskAll m1)\n+    if (VectorNode::is_all_ones_vector(in(2))) {\n+      return in(2);\n+    }\n+    \/\/ (OrV (Replicate zero) src)   => src\n+    \/\/ (OrVMask (MaskAll zero) src) => src\n+    if (VectorNode::is_all_zeros_vector(in(1))) {\n+      return in(2);\n+    }\n+  }\n+\n+  \/\/ (OrV src src)     => src\n+  \/\/ (OrVMask src src) => src\n+  if (in(1) == in(2)) {\n+    return in(1);\n+  }\n+  return this;\n+}\n+\n+Node* XorVNode::Ideal(PhaseGVN* phase, bool can_reshape) {\n+  \/\/ (XorV src src)      => (Replicate zero)\n+  \/\/ (XorVMask src src)  => (MaskAll zero)\n+  \/\/\n+  \/\/ The transformation is only applied to the un-predicated\n+  \/\/ operation, since the VectorAPI masked operation requires\n+  \/\/ the unmasked lanes to save the same values in the first\n+  \/\/ operand.\n+  if (!is_predicated_vector() && (in(1) == in(2))) {\n+    BasicType bt = vect_type()->element_basic_type();\n+    Node* zero = phase->transform(phase->zerocon(bt));\n+    return VectorNode::scalar2vector(zero, length(), Type::get_const_basic_type(bt),\n+                                     bottom_type()->isa_vectmask() != NULL);\n+  }\n+  return NULL;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":109,"deletions":4,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  \/\/ Return true if every bit in this vector is 1.\n@@ -107,0 +108,2 @@\n+  \/\/ Return true if every bit in this vector is 0.\n+  static bool is_all_zeros_vector(Node* n);\n@@ -717,0 +720,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -733,0 +737,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -757,0 +762,1 @@\n+  virtual Node* Ideal(PhaseGVN* phase, bool can_reshape);\n@@ -1072,1 +1078,1 @@\n-class AndVMaskNode : public VectorNode {\n+class AndVMaskNode : public AndVNode {\n@@ -1074,1 +1080,1 @@\n-  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  AndVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : AndVNode(in1, in2, vt) {}\n@@ -1079,1 +1085,1 @@\n-class OrVMaskNode : public VectorNode {\n+class OrVMaskNode : public OrVNode {\n@@ -1081,1 +1087,1 @@\n-  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  OrVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : OrVNode(in1, in2, vt) {}\n@@ -1086,1 +1092,1 @@\n-class XorVMaskNode : public VectorNode {\n+class XorVMaskNode : public XorVNode {\n@@ -1088,1 +1094,1 @@\n-  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : VectorNode(in1, in2, vt) {}\n+  XorVMaskNode(Node* in1, Node* in2, const TypeVect* vt) : XorVNode(in1, in2, vt) {}\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -190,0 +190,7 @@\n+    public static final String AND_V = START + \"AndV\" + MID + END;\n+    public static final String OR_V = START + \"OrV\" + MID + END;\n+    public static final String XOR_V = START + \"XorV\" + MID + END;\n+    public static final String AND_V_MASK = START + \"AndVMask\" + MID + END;\n+    public static final String OR_V_MASK = START + \"OrVMask\" + MID + END;\n+    public static final String XOR_V_MASK = START + \"XorVMask\" + MID + END;\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,512 @@\n+\/*\n+ * Copyright (c) 2022, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+import jdk.incubator.vector.ByteVector;\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.LongVector;\n+import jdk.incubator.vector.ShortVector;\n+import jdk.incubator.vector.VectorMask;\n+import jdk.incubator.vector.VectorOperators;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8288294\n+ * @key randomness\n+ * @library \/test\/lib \/\n+ * @summary Add identity transformations for vector logic operations\n+ * @requires (os.simpleArch == \"x64\" & vm.cpu.features ~= \".*avx.*\") | os.arch==\"aarch64\"\n+ * @modules jdk.incubator.vector\n+ *\n+ * @run driver compiler.vectorapi.VectorLogicalOpIdentityTest\n+ *\/\n+\n+public class VectorLogicalOpIdentityTest {\n+    private static final VectorSpecies<Byte> B_SPECIES = ByteVector.SPECIES_MAX;\n+    private static final VectorSpecies<Short> S_SPECIES = ShortVector.SPECIES_MAX;\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_MAX;\n+    private static final VectorSpecies<Long> L_SPECIES = LongVector.SPECIES_MAX;\n+\n+    private static int LENGTH = 128;\n+    private static final Random RD = Utils.getRandomInstance();\n+\n+    private static byte[] ba;\n+    private static byte[] br;\n+    private static short[] sa;\n+    private static short[] sr;\n+    private static int[] ia;\n+    private static int[] ir;\n+    private static long[] la;\n+    private static long[] lr;\n+    private static boolean[] m;\n+    private static boolean[] mr;\n+\n+    static {\n+        ba = new byte[LENGTH];\n+        br = new byte[LENGTH];\n+        sa = new short[LENGTH];\n+        sr = new short[LENGTH];\n+        ia = new int[LENGTH];\n+        ir = new int[LENGTH];\n+        la = new long[LENGTH];\n+        lr = new long[LENGTH];\n+        m = new boolean[LENGTH];\n+        mr = new boolean[LENGTH];\n+\n+        for (int i = 0; i < LENGTH; i++) {\n+            ba[i] = (byte) RD.nextInt(25);\n+            sa[i] = (short) RD.nextInt(25);\n+            ia[i] = RD.nextInt(25);\n+            la[i] = RD.nextLong(25);\n+            m[i] = RD.nextBoolean();\n+        }\n+    }\n+\n+    private static long and(long a, long b) {\n+        return a & b;\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.AND_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testAndMinusOne() {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        av.and((byte) -1).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            Asserts.assertEquals((byte) and(ba[i], (byte) -1), br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.AND_V, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testAndZero() {\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        av.and((short) 0).intoArray(sr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            Asserts.assertEquals((short) and(sa[i], (short) 0), sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.AND_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testAndSame() {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        av.and(av).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals((int) and(ia[i], ia[i]), ir[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.AND_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testMaskedAndMinusOne1() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        LongVector bv = LongVector.broadcast(L_SPECIES, -1);\n+        av.lanewise(VectorOperators.AND, bv, mask).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals(and(la[i], -1), lr[i]);\n+            } else {\n+                Asserts.assertEquals(la[i], lr[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Masked AndV in this test should not be optimized out on SVE.\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    public static void testMaskedAndMinusOne2() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        ByteVector bv = ByteVector.broadcast(B_SPECIES, (byte) -1);\n+        bv.lanewise(VectorOperators.AND, av, mask).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((byte) and(ba[i], (byte) -1), br[i]);\n+            } else {\n+                Asserts.assertEquals((byte) -1, br[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Masked AndV in this test should not be optimized out on SVE.\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    @IR(failOn = IRNode.AND_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    public static void testMaskedAndZero1() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        ShortVector bv = ShortVector.broadcast(S_SPECIES, (short) 0);\n+        av.lanewise(VectorOperators.AND, bv, mask).intoArray(sr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((short) and(sa[i], (short) 0), sr[i]);\n+            } else {\n+                Asserts.assertEquals(sa[i], sr[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.AND_V, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskedAndZero2() {\n+        VectorMask<Integer> mask = VectorMask.fromArray(I_SPECIES, m, 0);\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        IntVector bv = IntVector.broadcast(I_SPECIES, 0);\n+        bv.lanewise(VectorOperators.AND, av, mask).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((int) and(ba[i], 0), ir[i]);\n+            } else {\n+                Asserts.assertEquals(0, ir[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.AND_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testMaskedAndSame() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        av.lanewise(VectorOperators.AND, av, mask).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals(and(la[i], la[i]), lr[i]);\n+            } else {\n+                Asserts.assertEquals(la[i], lr[i]);\n+            }\n+        }\n+    }\n+\n+    private static long or(long a, long b) {\n+        return a | b;\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.OR_V, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testOrMinusOne() {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        av.or((byte) -1).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            Asserts.assertEquals((byte) or(ba[i], (byte) -1), br[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.OR_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testOrZero() {\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        av.or((short) 0).intoArray(sr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            Asserts.assertEquals((short) or(sa[i], (short) 0), sr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.OR_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testOrSame() {\n+        IntVector av = IntVector.fromArray(I_SPECIES, ia, 0);\n+        av.or(av).intoArray(ir, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals((int) or(ia[i], ia[i]), ir[i]);\n+        }\n+    }\n+\n+    \/\/ Masked OrV in this test should not be optimized out on SVE.\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    public static void testMaskedOrMinusOne1() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        ByteVector bv = ByteVector.broadcast(B_SPECIES, -1);\n+        av.lanewise(VectorOperators.OR, bv, mask).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((byte) or(ba[i], -1), br[i]);\n+            } else {\n+                Asserts.assertEquals(ba[i], br[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.OR_V, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskedOrMinusOne2() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        ByteVector bv = ByteVector.broadcast(B_SPECIES, (byte) -1);\n+        bv.lanewise(VectorOperators.OR, av, mask).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((byte) or(ba[i], (byte) -1), br[i]);\n+            } else {\n+                Asserts.assertEquals((byte) -1, br[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.OR_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testMaskedOrZero1() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        ShortVector bv = ShortVector.broadcast(S_SPECIES, (short) 0);\n+        av.lanewise(VectorOperators.OR, bv, mask).intoArray(sr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((short) or(sa[i], (short) 0), sr[i]);\n+            } else {\n+                Asserts.assertEquals(sa[i], sr[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Masked OrV in this test should not be optimized out on SVE.\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    @IR(failOn = IRNode.OR_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    public static void testMaskedOrZero2() {\n+        VectorMask<Byte> mask = VectorMask.fromArray(B_SPECIES, m, 0);\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        ByteVector bv = ByteVector.broadcast(B_SPECIES, 0);\n+        bv.lanewise(VectorOperators.OR, av, mask).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((byte) or(ba[i], 0), br[i]);\n+            } else {\n+                Asserts.assertEquals((byte) 0, br[i]);\n+            }\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.OR_V, counts = {IRNode.LOAD_VECTOR, \">=1\"})\n+    public static void testMaskedOrSame() {\n+        VectorMask<Long> mask = VectorMask.fromArray(L_SPECIES, m, 0);\n+        LongVector av = LongVector.fromArray(L_SPECIES, la, 0);\n+        av.lanewise(VectorOperators.OR, av, mask).intoArray(lr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals(or(la[i], la[i]), lr[i]);\n+            } else {\n+                Asserts.assertEquals(la[i], lr[i]);\n+            }\n+        }\n+    }\n+\n+    private static long xor(long a, long b) {\n+        return a ^ b;\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = IRNode.XOR_V, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testXorSame() {\n+        ByteVector av = ByteVector.fromArray(B_SPECIES, ba, 0);\n+        av.lanewise(VectorOperators.XOR, av).intoArray(br, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            Asserts.assertEquals((byte) xor(ba[i], ba[i]), br[i]);\n+        }\n+    }\n+\n+    \/\/ Masked XorV in this test should not be optimized out on SVE.\n+    @Test\n+    @Warmup(10000)\n+    @IR(counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    @IR(failOn = IRNode.XOR_V, applyIfCPUFeatureAnd = {\"simd\", \"true\", \"sve\", \"false\"})\n+    public static void testMaskedXorSame() {\n+        VectorMask<Short> mask = VectorMask.fromArray(S_SPECIES, m, 0);\n+        ShortVector av = ShortVector.fromArray(S_SPECIES, sa, 0);\n+        av.lanewise(VectorOperators.XOR, av, mask).intoArray(sr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            if (m[i]) {\n+                Asserts.assertEquals((short) xor(sa[i], sa[i]), sr[i]);\n+            } else {\n+                Asserts.assertEquals(sa[i], sr[i]);\n+            }\n+        }\n+    }\n+\n+    \/\/ Following are the vector mask logic operations tests\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.AND_V, IRNode.AND_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskAndMinusOne() {\n+        VectorMask<Integer> ma = VectorMask.fromArray(I_SPECIES, m, 0);\n+        VectorMask<Integer> mb = I_SPECIES.maskAll(true);\n+        ma.and(mb).intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(m[i], mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.AND_V, IRNode.AND_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskAndZero() {\n+        VectorMask<Long> ma = VectorMask.fromArray(L_SPECIES, m, 0);\n+        VectorMask<Long> mb = L_SPECIES.maskAll(false);\n+        ma.and(mb).intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < L_SPECIES.length(); i++) {\n+            Asserts.assertEquals(false, mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.AND_V, IRNode.AND_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskAndSame() {\n+        VectorMask<Byte> ma = VectorMask.fromArray(B_SPECIES, m, 0);\n+        ma.and(ma).intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            Asserts.assertEquals(m[i], mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.OR_V, IRNode.OR_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskOrMinusOne() {\n+        VectorMask<Short> ma = VectorMask.fromArray(S_SPECIES, m, 0);\n+        VectorMask<Short> mb = S_SPECIES.maskAll(true);\n+        ma.or(mb).intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < S_SPECIES.length(); i++) {\n+            Asserts.assertEquals(true, mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.OR_V, IRNode.OR_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskOrZero() {\n+        VectorMask<Integer> ma = VectorMask.fromArray(I_SPECIES, m, 0);\n+        VectorMask<Integer> mb = I_SPECIES.maskAll(false);\n+        ma.or(mb).intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(m[i], mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.OR_V, IRNode.OR_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskOrSame() {\n+        VectorMask<Byte> ma = VectorMask.fromArray(B_SPECIES, m, 0);\n+        ma.or(ma).intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < B_SPECIES.length(); i++) {\n+            Asserts.assertEquals(m[i], mr[i]);\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(10000)\n+    @IR(failOn = {IRNode.XOR_V, IRNode.XOR_V_MASK}, counts = {IRNode.STORE_VECTOR, \">=1\"})\n+    public static void testMaskXorSame() {\n+        VectorMask<Integer> ma = I_SPECIES.maskAll(true);\n+        ma.not().intoArray(mr, 0);\n+\n+        \/\/ Verify results\n+        for (int i = 0; i < I_SPECIES.length(); i++) {\n+            Asserts.assertEquals(false, mr[i]);\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/VectorLogicalOpIdentityTest.java","additions":512,"deletions":0,"binary":false,"changes":512,"status":"added"}]}