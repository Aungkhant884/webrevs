{"files":[{"patch":"@@ -34,0 +34,1 @@\n+#include \"castnode.hpp\"\n@@ -131,1 +132,1 @@\n-Node* ConstraintCastNode::make(Node* c, Node *n, const Type *t, BasicType bt) {\n+Node* ConstraintCastNode::make(Node* c, Node *n, const Type *t, DependencyType dependency, BasicType bt) {\n@@ -134,1 +135,1 @@\n-    return make_cast(Op_CastII, c, n, t, RegularDependency);\n+    return make_cast(Op_CastII, c, n, t, dependency);\n@@ -137,1 +138,1 @@\n-    return make_cast(Op_CastLL, c, n, t, RegularDependency);\n+    return make_cast(Op_CastLL, c, n, t, dependency);\n@@ -208,22 +209,2 @@\n-  if (!_range_check_dependency && phase->C->post_loop_opts_phase()) {\n-    const TypeInt* this_type = res->is_int();\n-    const TypeInt* in_type = phase->type(in(1))->isa_int();\n-    if (in_type != NULL &&\n-        (in_type->_lo != this_type->_lo ||\n-         in_type->_hi != this_type->_hi)) {\n-      jint lo1 = this_type->_lo;\n-      jint hi1 = this_type->_hi;\n-      int w1 = this_type->_widen;\n-      if (lo1 >= 0) {\n-        \/\/ Keep a range assertion of >=0.\n-        lo1 = 0;        hi1 = max_jint;\n-      } else if (hi1 < 0) {\n-        \/\/ Keep a range assertion of <0.\n-        lo1 = min_jint; hi1 = -1;\n-      } else {\n-        lo1 = min_jint; hi1 = max_jint;\n-      }\n-      res = TypeInt::make(MAX2(in_type->_lo, lo1),\n-                          MIN2(in_type->_hi, hi1),\n-                          MAX2((int)in_type->_widen, w1));\n-    }\n+  if (!_range_check_dependency) {\n+    res = widen_type(phase, res, T_INT);\n@@ -294,3 +275,2 @@\n-static Node* find_or_make_CastII(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInt* type, ConstraintCastNode::DependencyType dependency) {\n-  Node* n = new CastIINode(parent, type, dependency);\n-  n->set_req(0, control);\n+static Node* find_or_make_integer_cast(PhaseIterGVN* igvn, Node* parent, Node* control, const TypeInteger* type, ConstraintCastNode::DependencyType dependency, BasicType bt) {\n+  Node* n = ConstraintCastNode::make(control, parent, type, dependency, bt);\n@@ -314,24 +294,2 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n-  const TypeInt* this_type = this->type()->is_int();\n-  Node* z = in(1);\n-  const TypeInteger* rx = NULL;\n-  const TypeInteger* ry = NULL;\n-  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n-  if (!_range_check_dependency && Compile::push_thru_add(phase, z, this_type, rx, ry, T_INT)) {\n-    if (igvn == NULL) {\n-      \/\/ Postpone this optimization to iterative GVN, where we can handle deep\n-      \/\/ AddI chains without an exponential number of recursive Ideal() calls.\n-      phase->record_for_igvn(this);\n-      return NULL;\n-    }\n-    int op = z->Opcode();\n-    Node* x = z->in(1);\n-    Node* y = z->in(2);\n-\n-    Node* cx = find_or_make_CastII(igvn, x, in(0), rx->is_int(), _dependency);\n-    Node* cy = find_or_make_CastII(igvn, y, in(0), ry->is_int(), _dependency);\n-    switch (op) {\n-      case Op_AddI:  return new AddINode(cx, cy);\n-      case Op_SubI:  return new SubINode(cx, cy);\n-      default:       ShouldNotReachHere();\n-    }\n+  if (!_range_check_dependency) {\n+    return optimize_integer_cast(phase, T_INT);\n@@ -374,0 +332,10 @@\n+const Type* CastLLNode::Value(PhaseGVN* phase) const {\n+  const Type* res = ConstraintCastNode::Value(phase);\n+  if (res == Type::TOP) {\n+    return Type::TOP;\n+  }\n+  assert(res->isa_long(), \"res must be long\");\n+\n+  return widen_type(phase, res, T_LONG);\n+}\n+\n@@ -379,0 +347,4 @@\n+  if (can_reshape && !phase->C->post_loop_opts_phase()) {\n+    \/\/ makes sure we run ::Value to potentially remove type assertion after loop opts\n+    phase->C->record_for_post_loop_opts_igvn(this);\n+  }\n@@ -399,1 +371,1 @@\n-  return NULL;\n+  return optimize_integer_cast(phase, T_LONG);\n@@ -623,0 +595,59 @@\n+\n+Node* ConstraintCastNode::optimize_integer_cast(PhaseGVN* phase, BasicType bt) {\n+  PhaseIterGVN *igvn = phase->is_IterGVN();\n+  const TypeInteger* this_type = this->type()->is_integer(bt);\n+  Node* z = in(1);\n+  const TypeInteger* rx = NULL;\n+  const TypeInteger* ry = NULL;\n+  \/\/ Similar to ConvI2LNode::Ideal() for the same reasons\n+  if (Compile::push_thru_add(phase, z, this_type, rx, ry, bt, bt)) {\n+    if (igvn == NULL) {\n+      \/\/ Postpone this optimization to iterative GVN, where we can handle deep\n+      \/\/ AddI chains without an exponential number of recursive Ideal() calls.\n+      phase->record_for_igvn(this);\n+      return NULL;\n+    }\n+    int op = z->Opcode();\n+    Node* x = z->in(1);\n+    Node* y = z->in(2);\n+\n+    Node* cx = find_or_make_integer_cast(igvn, x, in(0), rx, _dependency, bt);\n+    Node* cy = find_or_make_integer_cast(igvn, y, in(0), ry, _dependency, bt);\n+    if (op == Op_Add(bt)) {\n+      return AddNode::make(cx, cy, bt);\n+    } else {\n+      assert(op == Op_Sub(bt), \"\");\n+      return SubNode::make(cx, cy, bt);\n+    }\n+    return NULL;\n+  }\n+  return NULL;\n+}\n+\n+const Type* ConstraintCastNode::widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const {\n+  if (!phase->C->post_loop_opts_phase()) {\n+    return res;\n+  }\n+  const TypeInteger* this_type = res->is_integer(bt);\n+  const TypeInteger* in_type = phase->type(in(1))->isa_integer(bt);\n+  if (in_type != NULL &&\n+      (in_type->lo_as_long() != this_type->lo_as_long() ||\n+       in_type->hi_as_long() != this_type->hi_as_long())) {\n+    jlong lo1 = this_type->lo_as_long();\n+    jlong hi1 = this_type->hi_as_long();\n+    int w1 = this_type->_widen;\n+    if (lo1 >= 0) {\n+      \/\/ Keep a range assertion of >=0.\n+      lo1 = 0;        hi1 = max_signed_integer(bt);\n+    } else if (hi1 < 0) {\n+      \/\/ Keep a range assertion of <0.\n+      lo1 = min_signed_integer(bt); hi1 = -1;\n+    } else {\n+      lo1 = min_signed_integer(bt); hi1 = max_signed_integer(bt);\n+    }\n+    return TypeInteger::make(MAX2(in_type->lo_as_long(), lo1),\n+                             MIN2(in_type->hi_as_long(), hi1),\n+                             MAX2((int)in_type->_widen, w1), bt);\n+  }\n+  return res;\n+}\n","filename":"src\/hotspot\/share\/opto\/castnode.cpp","additions":84,"deletions":53,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+  const Type* widen_type(const PhaseGVN* phase, const Type* res, BasicType bt) const;\n@@ -62,1 +63,1 @@\n-  static Node* make(Node* c, Node *n, const Type *t, BasicType bt);\n+  static Node* make(Node* c, Node *n, const Type *t, DependencyType dependency, BasicType bt);\n@@ -69,0 +70,2 @@\n+\n+  Node* optimize_integer_cast(PhaseGVN* phase, BasicType bt);\n@@ -121,0 +124,1 @@\n+  virtual const Type* Value(PhaseGVN* phase) const;\n","filename":"src\/hotspot\/share\/opto\/castnode.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1214,1 +1214,1 @@\n-                            BasicType bt);\n+                            BasicType out_bt, BasicType in_bt);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,0 +298,1 @@\n+#ifdef ASSERT\n@@ -303,0 +304,233 @@\n+#endif\n+\n+template<class T> static bool subtract_overflows(T x, T y) {\n+  T s = java_subtract(x, y);\n+  return (x >= 0) && (y < 0) && (s < 0);\n+}\n+\n+template<class T> static bool subtract_underflows(T x, T y) {\n+  T s = java_subtract(x, y);\n+  return (x < 0) && (y > 0) && (s > 0);\n+}\n+\n+template<class T> static bool add_overflows(T x, T y) {\n+  T s = java_add(x, y);\n+  return (x > 0) && (y > 0) && (s < 0);\n+}\n+\n+template<class T> static bool add_underflows(T x, T y) {\n+  T s = java_add(x, y);\n+  return (x < 0) && (y < 0) && (s >= 0);\n+}\n+\n+template<class T> static bool ranges_overlap(T xlo, T ylo, T xhi, T yhi, T zlo, T zhi,\n+                                             const Node* n, bool pos) {\n+  assert(xlo <= xhi && ylo <= yhi && zlo <= zhi, \"should not be empty types\");\n+  T x_y_lo;\n+  T x_y_hi;\n+  bool x_y_lo_overflow;\n+  bool x_y_hi_overflow;\n+\n+  if (n->is_Sub()) {\n+    x_y_lo = java_subtract(xlo, yhi);\n+    x_y_hi = java_subtract(xhi, ylo);\n+    x_y_lo_overflow = pos ? subtract_overflows(xlo, yhi) : subtract_underflows(xlo, yhi);\n+    x_y_hi_overflow = pos ? subtract_overflows(xhi, ylo) : subtract_underflows(xhi, ylo);\n+  } else {\n+    assert(n->is_Add(), \"Add or Sub only\");\n+    x_y_lo = java_add(xlo, ylo);\n+    x_y_hi = java_add(xhi, yhi);\n+    x_y_lo_overflow = pos ? add_overflows(xlo, ylo) : add_underflows(xlo, ylo);\n+    x_y_hi_overflow = pos ? add_overflows(xhi, yhi) : add_underflows(xhi, yhi);\n+  }\n+  assert(!pos || !x_y_lo_overflow || x_y_hi_overflow, \"x_y_lo_overflow => x_y_hi_overflow\");\n+  assert(pos || !x_y_hi_overflow || x_y_lo_overflow, \"x_y_hi_overflow => x_y_lo_overflow\");\n+\n+  \/\/ Two ranges overlap iff one range's low point falls in the other range.\n+  \/\/ nbits = 32 or 64\n+  if (pos) {\n+    \/\/ (zlo + 2**nbits  <= x_y_lo && x_y_lo <= zhi ** nbits)\n+    if (x_y_lo_overflow) {\n+      if (zlo <= x_y_lo && x_y_lo <= zhi) {\n+        return true;\n+      }\n+    }\n+\n+    \/\/ (x_y_lo <= zlo + 2**nbits && zlo + 2**nbits <= x_y_hi)\n+    if (x_y_hi_overflow) {\n+      if ((!x_y_lo_overflow || x_y_lo <= zlo) && zlo <= x_y_hi) {\n+        return true;\n+      }\n+    }\n+  } else {\n+    \/\/ (zlo - 2**nbits <= x_y_hi && x_y_hi <= zhi - 2**nbits)\n+    if (x_y_hi_overflow) {\n+      if (zlo <= x_y_hi && x_y_hi <= zhi) {\n+        return true;\n+      }\n+    }\n+\n+    \/\/ (x_y_lo <= zhi - 2**nbits && zhi - 2**nbits <= x_y_hi)\n+    if (x_y_lo_overflow) {\n+      if (x_y_lo <= zhi && (!x_y_hi_overflow || zhi <= x_y_hi)) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+static bool ranges_overlap(const TypeInteger* tx, const TypeInteger* ty, const TypeInteger* tz,\n+                           const Node* n, bool pos, BasicType bt) {\n+  jlong xlo = tx->lo_as_long();\n+  jlong xhi = tx->hi_as_long();\n+  jlong ylo = ty->lo_as_long();\n+  jlong yhi = ty->hi_as_long();\n+  jlong zlo = tz->lo_as_long();\n+  jlong zhi = tz->hi_as_long();\n+\n+  if (bt == T_INT) {\n+    \/\/ See if x+y can cause positive overflow into z+2**32\n+    \/\/ See if x+y can cause negative overflow into z-2**32\n+    bool res =  ranges_overlap(checked_cast<jint>(xlo), checked_cast<jint>(ylo),\n+                               checked_cast<jint>(xhi), checked_cast<jint>(yhi),\n+                               checked_cast<jint>(zlo), checked_cast<jint>(zhi), n, pos);\n+#ifdef ASSERT\n+    jlong vbit = CONST64(1) << BitsPerInt;\n+    if (n->Opcode() == Op_SubI) {\n+      jlong ylo0 = ylo;\n+      ylo = -yhi;\n+      yhi = -ylo0;\n+    }\n+    assert(res == long_ranges_overlap(xlo+ylo, xhi+yhi, pos ? zlo+vbit : zlo-vbit, pos ? zhi+vbit : zhi-vbit), \"inconsistent result\");\n+#endif\n+    return res;\n+  }\n+  assert(bt == T_LONG, \"only int or long\");\n+  \/\/ See if x+y can cause positive overflow into z+2**64\n+  \/\/ See if x+y can cause negative overflow into z-2**64\n+  return ranges_overlap(xlo, ylo, xhi, yhi, zlo, zhi, n, pos);\n+}\n+\n+#ifdef ASSERT\n+static bool compute_updates_ranges_verif(const TypeInteger* tx, const TypeInteger* ty, const TypeInteger* tz,\n+                                         jlong& rxlo, jlong& rxhi, jlong& rylo, jlong& ryhi,\n+                                         const Node* n) {\n+  jlong xlo = tx->lo_as_long();\n+  jlong xhi = tx->hi_as_long();\n+  jlong ylo = ty->lo_as_long();\n+  jlong yhi = ty->hi_as_long();\n+  jlong zlo = tz->lo_as_long();\n+  jlong zhi = tz->hi_as_long();\n+  if (n->is_Sub()) {\n+    swap(ylo, yhi);\n+    ylo = -ylo;\n+    yhi = -yhi;\n+  }\n+\n+  rxlo = MAX2(xlo, zlo - yhi);\n+  rxhi = MIN2(xhi, zhi - ylo);\n+  rylo = MAX2(ylo, zlo - xhi);\n+  ryhi = MIN2(yhi, zhi - xlo);\n+  if (rxlo > rxhi || rylo > ryhi) {\n+    return false;\n+  }\n+  if (n->is_Sub()) {\n+    swap(rylo, ryhi);\n+    rylo = -rylo;\n+    ryhi = -ryhi;\n+  }\n+  assert(rxlo == (int) rxlo && rxhi == (int) rxhi, \"x should not overflow\");\n+  assert(rylo == (int) rylo && ryhi == (int) ryhi, \"y should not overflow\");\n+  return true;\n+}\n+#endif\n+\n+template<class T> static bool compute_updates_ranges(T xlo, T ylo, T xhi, T yhi, T zlo, T zhi,\n+                                                     jlong& rxlo, jlong& rxhi, jlong& rylo, jlong& ryhi,\n+                                                     const Node* n) {\n+  assert(xlo <= xhi && ylo <= yhi && zlo <= zhi, \"should not be empty types\");\n+\n+  \/\/ Now it's always safe to assume x+y does not overflow.\n+  \/\/ This is true even if some pairs x,y might cause overflow, as long\n+  \/\/ as that overflow value cannot fall into [zlo,zhi].\n+\n+  \/\/ Confident that the arithmetic is \"as if infinite precision\",\n+  \/\/ we can now use n's range to put constraints on those of x and y.\n+  \/\/ The \"natural\" range of x [xlo,xhi] can perhaps be narrowed to a\n+  \/\/ more \"restricted\" range by intersecting [xlo,xhi] with the\n+  \/\/ range obtained by subtracting y's range from the asserted range\n+  \/\/ of the I2L conversion.  Here's the interval arithmetic algebra:\n+  \/\/    x == n-y == [zlo,zhi]-[ylo,yhi] == [zlo,zhi]+[-yhi,-ylo]\n+  \/\/    => x in [zlo-yhi, zhi-ylo]\n+  \/\/    => x in [zlo-yhi, zhi-ylo] INTERSECT [xlo,xhi]\n+  \/\/    => x in [xlo MAX zlo-yhi, xhi MIN zhi-ylo]\n+  \/\/ And similarly, x changing place with y.\n+  if (n->is_Sub()) {\n+    if (add_overflows(zlo, ylo) || add_underflows(zhi, yhi) || subtract_underflows(xhi, zlo) ||\n+        subtract_overflows(xlo, zhi)) {\n+      return false;\n+    }\n+    rxlo = add_underflows(zlo, ylo) ? xlo : MAX2(xlo, java_add(zlo, ylo));\n+    rxhi = add_overflows(zhi, yhi) ? xhi : MIN2(xhi, java_add(zhi, yhi));\n+    ryhi = subtract_overflows(xhi, zlo) ? yhi : MIN2(yhi, java_subtract(xhi, zlo));\n+    rylo = subtract_underflows(xlo, zhi) ? ylo : MAX2(ylo, java_subtract(xlo, zhi));\n+  } else {\n+    assert(n->is_Add(), \"Add or Sub only\");\n+    if (subtract_overflows(zlo, yhi) || subtract_underflows(zhi, ylo) ||\n+        subtract_overflows(zlo, xhi) || subtract_underflows(zhi, xlo)) {\n+      return false;\n+    }\n+    rxlo = subtract_underflows(zlo, yhi) ? xlo : MAX2(xlo, java_subtract(zlo, yhi));\n+    rxhi = subtract_overflows(zhi, ylo) ? xhi : MIN2(xhi, java_subtract(zhi, ylo));\n+    rylo = subtract_underflows(zlo, xhi) ? ylo : MAX2(ylo, java_subtract(zlo, xhi));\n+    ryhi = subtract_overflows(zhi, xlo) ? yhi : MIN2(yhi, java_subtract(zhi, xlo));\n+  }\n+\n+  if (rxlo > rxhi || rylo > ryhi) {\n+    return false; \/\/ x or y is dying; don't mess w\/ it\n+  }\n+\n+  return true;\n+}\n+\n+static bool compute_updates_ranges(const TypeInteger* tx, const TypeInteger* ty, const TypeInteger* tz,\n+                                   const TypeInteger*& rx, const TypeInteger*& ry,\n+                                   const Node* n, const BasicType in_bt, BasicType out_bt) {\n+\n+  jlong xlo = tx->lo_as_long();\n+  jlong xhi = tx->hi_as_long();\n+  jlong ylo = ty->lo_as_long();\n+  jlong yhi = ty->hi_as_long();\n+  jlong zlo = tz->lo_as_long();\n+  jlong zhi = tz->hi_as_long();\n+  jlong rxlo, rxhi, rylo, ryhi;\n+\n+  if (in_bt == T_INT) {\n+#ifdef ASSERT\n+    jlong expected_rxlo, expected_rxhi, expected_rylo, expected_ryhi;\n+    bool expected = compute_updates_ranges_verif(tx, ty, tz,\n+                                                 expected_rxlo, expected_rxhi,\n+                                                 expected_rylo, expected_ryhi, n);\n+#endif\n+    if (!compute_updates_ranges(checked_cast<jint>(xlo), checked_cast<jint>(ylo),\n+                                checked_cast<jint>(xhi), checked_cast<jint>(yhi),\n+                                checked_cast<jint>(zlo), checked_cast<jint>(zhi),\n+                                rxlo, rxhi, rylo, ryhi, n)) {\n+      assert(!expected, \"inconsistent\");\n+      return false;\n+    }\n+    assert(expected && rxlo == expected_rxlo && rxhi == expected_rxhi && rylo == expected_rylo && ryhi == expected_ryhi, \"inconsistent\");\n+  } else {\n+    if (!compute_updates_ranges(xlo, ylo, xhi, yhi, zlo, zhi,\n+                            rxlo, rxhi, rylo, ryhi, n)) {\n+      return false;\n+    }\n+  }\n+\n+  int widen =  MAX2(tx->widen_limit(), ty->widen_limit());\n+  rx = TypeInteger::make(rxlo, rxhi, widen, out_bt);\n+  ry = TypeInteger::make(rylo, ryhi, widen, out_bt);\n+  return true;\n+}\n@@ -322,1 +556,1 @@\n-                            BasicType bt) {\n+                            BasicType in_bt, BasicType out_bt) {\n@@ -324,1 +558,1 @@\n-  if (op == Op_AddI || op == Op_SubI) {\n+  if (op == Op_Add(in_bt) || op == Op_Sub(in_bt)) {\n@@ -334,22 +568,5 @@\n-    const TypeInt*  tx = phase->type(x)->is_int();\n-    const TypeInt*  ty = phase->type(y)->is_int();\n-\n-    jlong xlo = tx->is_int()->_lo;\n-    jlong xhi = tx->is_int()->_hi;\n-    jlong ylo = ty->is_int()->_lo;\n-    jlong yhi = ty->is_int()->_hi;\n-    jlong zlo = tz->lo_as_long();\n-    jlong zhi = tz->hi_as_long();\n-    jlong vbit = CONST64(1) << BitsPerInt;\n-    int widen =  MAX2(tx->_widen, ty->_widen);\n-    if (op == Op_SubI) {\n-      jlong ylo0 = ylo;\n-      ylo = -yhi;\n-      yhi = -ylo0;\n-    }\n-    \/\/ See if x+y can cause positive overflow into z+2**32\n-    if (long_ranges_overlap(xlo+ylo, xhi+yhi, zlo+vbit, zhi+vbit)) {\n-      return false;\n-    }\n-    \/\/ See if x+y can cause negative overflow into z-2**32\n-    if (long_ranges_overlap(xlo+ylo, xhi+yhi, zlo-vbit, zhi-vbit)) {\n+    const TypeInteger* tx = phase->type(x)->is_integer(in_bt);\n+    const TypeInteger* ty = phase->type(y)->is_integer(in_bt);\n+\n+    if (ranges_overlap(tx, ty, tz, z, true, in_bt) ||\n+        ranges_overlap(tx, ty, tz, z, false, in_bt)) {\n@@ -358,32 +575,1 @@\n-    \/\/ Now it's always safe to assume x+y does not overflow.\n-    \/\/ This is true even if some pairs x,y might cause overflow, as long\n-    \/\/ as that overflow value cannot fall into [zlo,zhi].\n-\n-    \/\/ Confident that the arithmetic is \"as if infinite precision\",\n-    \/\/ we can now use z's range to put constraints on those of x and y.\n-    \/\/ The \"natural\" range of x [xlo,xhi] can perhaps be narrowed to a\n-    \/\/ more \"restricted\" range by intersecting [xlo,xhi] with the\n-    \/\/ range obtained by subtracting y's range from the asserted range\n-    \/\/ of the I2L conversion.  Here's the interval arithmetic algebra:\n-    \/\/    x == z-y == [zlo,zhi]-[ylo,yhi] == [zlo,zhi]+[-yhi,-ylo]\n-    \/\/    => x in [zlo-yhi, zhi-ylo]\n-    \/\/    => x in [zlo-yhi, zhi-ylo] INTERSECT [xlo,xhi]\n-    \/\/    => x in [xlo MAX zlo-yhi, xhi MIN zhi-ylo]\n-    jlong rxlo = MAX2(xlo, zlo - yhi);\n-    jlong rxhi = MIN2(xhi, zhi - ylo);\n-    \/\/ And similarly, x changing place with y:\n-    jlong rylo = MAX2(ylo, zlo - xhi);\n-    jlong ryhi = MIN2(yhi, zhi - xlo);\n-    if (rxlo > rxhi || rylo > ryhi) {\n-      return false;  \/\/ x or y is dying; don't mess w\/ it\n-    }\n-    if (op == Op_SubI) {\n-      jlong rylo0 = rylo;\n-      rylo = -ryhi;\n-      ryhi = -rylo0;\n-    }\n-    assert(rxlo == (int)rxlo && rxhi == (int)rxhi, \"x should not overflow\");\n-    assert(rylo == (int)rylo && ryhi == (int)ryhi, \"y should not overflow\");\n-    rx = TypeInteger::make(rxlo, rxhi, widen, bt);\n-    ry = TypeInteger::make(rylo, ryhi, widen, bt);\n-    return true;\n+    return compute_updates_ranges(tx, ty, tz, rx, ry, z, in_bt, out_bt);\n@@ -428,1 +614,1 @@\n-  if (Compile::push_thru_add(phase, z, this_type, rx, ry, T_LONG)) {\n+  if (Compile::push_thru_add(phase, z, this_type, rx, ry, T_INT, T_LONG)) {\n","filename":"src\/hotspot\/share\/opto\/convertnode.cpp","additions":243,"deletions":57,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -1106,1 +1106,1 @@\n-  Node* casted_length = ConstraintCastNode::make(control(), length, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), bt);\n+  Node* casted_length = ConstraintCastNode::make(control(), length, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), ConstraintCastNode::RegularDependency, bt);\n@@ -1134,1 +1134,1 @@\n-  Node* result = ConstraintCastNode::make(control(), index, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), bt);\n+  Node* result = ConstraintCastNode::make(control(), index, TypeInteger::make(0, upper_bound, Type::WidenMax, bt), ConstraintCastNode::RegularDependency, bt);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1465,1 +1465,1 @@\n-TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int), _lo(lo), _hi(hi), _widen(w) {\n+TypeInt::TypeInt( jint lo, jint hi, int w ) : TypeInteger(Int, w), _lo(lo), _hi(hi) {\n@@ -1727,1 +1727,1 @@\n-TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long), _lo(lo), _hi(hi), _widen(w) {\n+TypeLong::TypeLong(jlong lo, jlong hi, int w) : TypeInteger(Long, w), _lo(lo), _hi(hi) {\n","filename":"src\/hotspot\/share\/opto\/type.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -555,1 +555,1 @@\n-  TypeInteger(TYPES t) : Type(t) {}\n+  TypeInteger(TYPES t, int w) : Type(t), _widen(w) {}\n@@ -558,0 +558,2 @@\n+  const short _widen;           \/\/ Limit on times we widen this sucker\n+\n@@ -562,0 +564,1 @@\n+  virtual short widen_limit() const { return _widen; }\n@@ -588,1 +591,0 @@\n-  const short _widen;           \/\/ Limit on times we widen this sucker\n@@ -656,1 +658,0 @@\n-  const short _widen;           \/\/ Limit on times we widen this sucker\n","filename":"src\/hotspot\/share\/opto\/type.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2022, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import java.util.Random;\n+import java.util.Objects;\n+\n+\/*\n+ * @test\n+ * @bug 8288022\n+ * @key randomness\n+ * @summary c2: Transform (CastLL (AddL into (AddL (CastLL when possible\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.TestPushAddThruCast\n+ *\/\n+\n+public class TestPushAddThruCast {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    final static int length = RANDOM.nextInt(Integer.MAX_VALUE);\n+    final static long llength = RANDOM.nextInt(Integer.MAX_VALUE);\n+    static int i;\n+    static long l;\n+\n+    @Test\n+    @IR(counts = { IRNode.CAST_II, \"1\" })\n+    public static int test1() {\n+        int j = Objects.checkIndex(i, length);\n+        int k = Objects.checkIndex(i + 1, length);\n+        return j + k;\n+    }\n+\n+    @Run(test = \"test1\")\n+    public static void test1_runner() {\n+        i = RANDOM.nextInt(length-1);\n+        int res = test1();\n+        if (res != i * 2 + 1) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.CAST_LL, \"1\" })\n+    public static long test2() {\n+        long j = Objects.checkIndex(l, llength);\n+        long k = Objects.checkIndex(l + 1, llength);\n+        return j + k;\n+    }\n+\n+    @Run(test = \"test2\")\n+    public static void test2_runner() {\n+        l = RANDOM.nextInt(((int)llength)-1);\n+        long res = test2();\n+        if (res != l * 2 + 1) {\n+            throw new RuntimeException(\"incorrect result: \" + res);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestPushAddThruCast.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}