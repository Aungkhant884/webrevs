{"files":[{"patch":"@@ -86,3 +86,9 @@\n-void VectorSupport::init_vector_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr) {\n-  int elem_size = type2aelembytes(elem_bt);\n-  for (int i = 0; i < num_elem; i++) {\n+void VectorSupport::init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr) {\n+  if (is_mask) {\n+    \/\/ Masks require special handling: when boxed they are packed and stored in boolean\n+    \/\/ arrays, but in scalarized form they have the same size as corresponding vectors.\n+    \/\/ For example, Int512Mask is represented in memory as boolean[16], but\n+    \/\/ occupies the whole 512-bit vector register when scalarized.\n+    \/\/ (In generated code, the conversion is performed by VectorStoreMask.)\n+    \/\/\n+    \/\/ TODO: revisit when predicate registers are fully supported.\n@@ -90,32 +96,8 @@\n-      case T_BYTE: {\n-        jbyte elem_value = *(jbyte*) (value_addr + i * elem_size);\n-        arr->byte_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_SHORT: {\n-        jshort elem_value = *(jshort*) (value_addr + i * elem_size);\n-        arr->short_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_INT: {\n-        jint elem_value = *(jint*) (value_addr + i * elem_size);\n-        arr->int_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_LONG: {\n-        jlong elem_value = *(jlong*) (value_addr + i * elem_size);\n-        arr->long_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_FLOAT: {\n-        jfloat elem_value = *(jfloat*) (value_addr + i * elem_size);\n-        arr->float_at_put(i, elem_value);\n-        break;\n-      }\n-      case T_DOUBLE: {\n-        jdouble elem_value = *(jdouble*) (value_addr + i * elem_size);\n-        arr->double_at_put(i, elem_value);\n-        break;\n-      }\n-      default:\n-        fatal(\"unsupported: %s\", type2name(elem_bt));\n+      case T_BYTE:   arr->bool_at_put(index,  (*(jbyte*)addr) != 0); break;\n+      case T_SHORT:  arr->bool_at_put(index, (*(jshort*)addr) != 0); break;\n+      case T_INT:    \/\/ fall-through\n+      case T_FLOAT:  arr->bool_at_put(index,   (*(jint*)addr) != 0); break;\n+      case T_LONG:   \/\/ fall-through\n+      case T_DOUBLE: arr->bool_at_put(index,  (*(jlong*)addr) != 0); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -123,7 +105,1 @@\n-  }\n-}\n-\n-void VectorSupport::init_mask_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr) {\n-  int elem_size = type2aelembytes(elem_bt);\n-\n-  for (int i = 0; i < num_elem; i++) {\n+  } else {\n@@ -131,24 +107,8 @@\n-      case T_BYTE: {\n-        jbyte elem_value = *(jbyte*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      case T_SHORT: {\n-        jshort elem_value = *(jshort*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      case T_INT:   \/\/ fall-through\n-      case T_FLOAT: {\n-        jint elem_value = *(jint*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      case T_LONG: \/\/ fall-through\n-      case T_DOUBLE: {\n-        jlong elem_value = *(jlong*) (value_addr + i * elem_size);\n-        arr->bool_at_put(i, elem_value != 0);\n-        break;\n-      }\n-      default:\n-        fatal(\"unsupported: %s\", type2name(elem_bt));\n+      case T_BYTE:   arr->  byte_at_put(index,   *(jbyte*)addr); break;\n+      case T_SHORT:  arr-> short_at_put(index,  *(jshort*)addr); break;\n+      case T_INT:    arr->   int_at_put(index,    *(jint*)addr); break;\n+      case T_FLOAT:  arr-> float_at_put(index,  *(jfloat*)addr); break;\n+      case T_LONG:   arr->  long_at_put(index,   *(jlong*)addr); break;\n+      case T_DOUBLE: arr->double_at_put(index, *(jdouble*)addr); break;\n+\n+      default: fatal(\"unsupported: %s\", type2name(elem_bt));\n@@ -159,2 +119,1 @@\n-oop VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, BasicType elem_bt, int num_elem, address value_addr, TRAPS) {\n-\n+Handle VectorSupport::allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS) {\n@@ -163,0 +122,4 @@\n+  int num_elem = klass2length(ik);\n+  BasicType elem_bt = klass2bt(ik);\n+  int elem_size = type2aelembytes(elem_bt);\n+\n@@ -166,1 +129,1 @@\n-  typeArrayOop arr = tak->allocate(num_elem, CHECK_NULL); \/\/ safepoint\n+  typeArrayOop arr = tak->allocate(num_elem, CHECK_NH); \/\/ safepoint\n@@ -168,2 +131,27 @@\n-  if (is_mask) {\n-    init_mask_array(arr, elem_bt, num_elem, value_addr);\n+  if (location.is_register()) {\n+    \/\/ Value was in a callee-saved register.\n+    VMReg vreg = VMRegImpl::as_VMReg(location.register_number());\n+\n+    for (int i = 0; i < num_elem; i++) {\n+      int vslot = (i * elem_size) \/ VMRegImpl::stack_slot_size;\n+      int off   = (i * elem_size) % VMRegImpl::stack_slot_size;\n+\n+      address elem_addr = reg_map->location(vreg->next(vslot)) + off;\n+      init_payload_element(arr, is_mask, elem_bt, i, elem_addr);\n+    }\n+  } else {\n+    \/\/ Value was directly saved on the stack.\n+    address base_addr = ((address)fr->unextended_sp()) + location.stack_offset();\n+    for (int i = 0; i < num_elem; i++) {\n+      init_payload_element(arr, is_mask, elem_bt, i, base_addr + i * elem_size);\n+    }\n+  }\n+  return Handle(THREAD, arr);\n+}\n+\n+Handle VectorSupport::allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS) {\n+  if (payload->is_location() &&\n+      payload->as_LocationValue()->location().type() == Location::vector) {\n+    \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n+    Location location = payload->as_LocationValue()->location();\n+    return allocate_vector_payload_helper(ik, fr, reg_map, location, THREAD); \/\/ safepoint\n@@ -171,1 +159,3 @@\n-    init_vector_array(arr, elem_bt, num_elem, value_addr);\n+    \/\/ Scalar-replaced boxed vector representation.\n+    StackValue* value = StackValue::create_stack_value(fr, reg_map, payload);\n+    return value->get_obj();\n@@ -173,1 +163,0 @@\n-  return arr;\n@@ -176,1 +165,1 @@\n-oop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n+instanceOop VectorSupport::allocate_vector(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ObjectValue* ov, TRAPS) {\n@@ -180,26 +169,5 @@\n-  \/\/ Vector value in an aligned adjacent tuple (1, 2, 4, 8, or 16 slots).\n-  LocationValue* loc_value = ov->field_at(0)->as_LocationValue();\n-\n-  BasicType elem_bt = klass2bt(ik);\n-  int num_elem = klass2length(ik);\n-\n-  Handle vbox = ik->allocate_instance_handle(CHECK_NULL);\n-\n-  Location loc = loc_value->location();\n-\n-  oop payload = NULL;\n-  if (loc.type() == Location::vector) {\n-    address value_addr = loc.is_register()\n-        \/\/ Value was in a callee-save register\n-        ? reg_map->location(VMRegImpl::as_VMReg(loc.register_number()))\n-        \/\/ Else value was directly saved on the stack. The frame's original stack pointer,\n-        \/\/ before any extension by its callee (due to Compiler1 linkage on SPARC), must be used.\n-        : ((address)fr->unextended_sp()) + loc.stack_offset();\n-    payload = allocate_vector_payload_helper(ik, elem_bt, num_elem, value_addr, CHECK_NULL); \/\/ safepoint\n-  } else {\n-    \/\/ assert(false, \"interesting\");\n-    StackValue* value = StackValue::create_stack_value(fr, reg_map, loc_value);\n-    payload = value->get_obj()();\n-  }\n-  vector_VectorPayload::set_payload(vbox(), payload);\n-  return vbox();\n+  ScopeValue* payload_value = ov->field_at(0);\n+  Handle payload_instance = VectorSupport::allocate_vector_payload(ik, fr, reg_map, payload_value, CHECK_NULL);\n+  instanceOop vbox = ik->allocate_instance(CHECK_NULL);\n+  vector_VectorPayload::set_payload(vbox, payload_instance());\n+  return vbox;\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.cpp","additions":68,"deletions":100,"binary":false,"changes":168,"status":"modified"},{"patch":"@@ -42,3 +42,4 @@\n-  static void init_mask_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr);\n-  static void init_vector_array(typeArrayOop arr, BasicType elem_bt, int num_elem, address value_addr);\n-  static oop  allocate_vector_payload_helper(InstanceKlass* ik, BasicType elem_bt, int num_elem, address value_addr, TRAPS);\n+  static Handle allocate_vector_payload(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, ScopeValue* payload, TRAPS);\n+  static Handle allocate_vector_payload_helper(InstanceKlass* ik, frame* fr, RegisterMap* reg_map, Location location, TRAPS);\n+\n+  static void init_payload_element(typeArrayOop arr, bool is_mask, BasicType elem_bt, int index, address addr);\n@@ -84,1 +85,1 @@\n-  static oop  allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n+  static instanceOop allocate_vector(InstanceKlass* holder, frame* fr, RegisterMap* reg_map, ObjectValue* sv, TRAPS);\n","filename":"src\/hotspot\/share\/prims\/vectorSupport.hpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"}]}